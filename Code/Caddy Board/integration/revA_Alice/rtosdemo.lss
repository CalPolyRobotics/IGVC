
rtosdemo.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000002c  00800200  0000535c  000053f0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000535c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000194d  0080022c  0080022c  0000541c  2**0
                  ALLOC
  3 .stab         0000c6d8  00000000  00000000  0000541c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000049db  00000000  00000000  00011af4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000022  00000000  00000000  000164cf  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 8e 00 	jmp	0x11c	; 0x11c <__ctors_end>
       4:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
       8:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
       c:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      10:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      14:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      18:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      1c:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      20:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      24:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      28:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      2c:	0c 94 fb 21 	jmp	0x43f6	; 0x43f6 <__vector_11>
      30:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      34:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      38:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      3c:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      40:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      44:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      48:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      4c:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      50:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      54:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      58:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      5c:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      60:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      64:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      68:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      6c:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      70:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      74:	0c 94 95 27 	jmp	0x4f2a	; 0x4f2a <__vector_29>
      78:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      7c:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      80:	0c 94 b6 1a 	jmp	0x356c	; 0x356c <__vector_32>
      84:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      88:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      8c:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      90:	0c 94 42 1b 	jmp	0x3684	; 0x3684 <__vector_36>
      94:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      98:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      9c:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      a0:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      a4:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      a8:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      ac:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      b0:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      b4:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      b8:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      bc:	0c 94 6f 24 	jmp	0x48de	; 0x48de <__vector_47>
      c0:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      c4:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      c8:	0c 94 0d 24 	jmp	0x481a	; 0x481a <__vector_50>
      cc:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      d0:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      d4:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      d8:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      dc:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      e0:	0c 94 af 00 	jmp	0x15e	; 0x15e <__bad_interrupt>
      e4:	42 20       	and	r4, r2
      e6:	59 20       	and	r5, r9
      e8:	89 20       	and	r8, r9
      ea:	69 20       	and	r6, r9
      ec:	89 20       	and	r8, r9
      ee:	89 20       	and	r8, r9
      f0:	79 20       	and	r7, r9
      f2:	89 20       	and	r8, r9

000000f4 <__trampolines_start>:
      f4:	0c 94 79 20 	jmp	0x40f2	; 0x40f2 <processCommand+0xc8>
      f8:	0c 94 42 20 	jmp	0x4084	; 0x4084 <processCommand+0x5a>
      fc:	0c 94 69 20 	jmp	0x40d2	; 0x40d2 <processCommand+0xa8>
     100:	0c 94 64 0a 	jmp	0x14c8	; 0x14c8 <prvIdleTask>
     104:	0c 94 c6 23 	jmp	0x478c	; 0x478c <getLinearPotCallback>
     108:	0c 94 58 25 	jmp	0x4ab0	; 0x4ab0 <vTaskSteer>
     10c:	0c 94 05 03 	jmp	0x60a	; 0x60a <vTaskFunction_1>
     110:	0c 94 89 20 	jmp	0x4112	; 0x4112 <processCommand+0xe8>
     114:	0c 94 22 28 	jmp	0x5044	; 0x5044 <vTaskADC>
     118:	0c 94 59 20 	jmp	0x40b2	; 0x40b2 <processCommand+0x88>

0000011c <__ctors_end>:
     11c:	11 24       	eor	r1, r1
     11e:	1f be       	out	0x3f, r1	; 63
     120:	cf ef       	ldi	r28, 0xFF	; 255
     122:	d1 e2       	ldi	r29, 0x21	; 33
     124:	de bf       	out	0x3e, r29	; 62
     126:	cd bf       	out	0x3d, r28	; 61
     128:	00 e0       	ldi	r16, 0x00	; 0
     12a:	0c bf       	out	0x3c, r16	; 60

0000012c <__do_copy_data>:
     12c:	12 e0       	ldi	r17, 0x02	; 2
     12e:	a0 e0       	ldi	r26, 0x00	; 0
     130:	b2 e0       	ldi	r27, 0x02	; 2
     132:	ec e5       	ldi	r30, 0x5C	; 92
     134:	f3 e5       	ldi	r31, 0x53	; 83
     136:	00 e0       	ldi	r16, 0x00	; 0
     138:	0b bf       	out	0x3b, r16	; 59
     13a:	02 c0       	rjmp	.+4      	; 0x140 <__do_copy_data+0x14>
     13c:	07 90       	elpm	r0, Z+
     13e:	0d 92       	st	X+, r0
     140:	ac 32       	cpi	r26, 0x2C	; 44
     142:	b1 07       	cpc	r27, r17
     144:	d9 f7       	brne	.-10     	; 0x13c <__do_copy_data+0x10>

00000146 <__do_clear_bss>:
     146:	1b e1       	ldi	r17, 0x1B	; 27
     148:	ac e2       	ldi	r26, 0x2C	; 44
     14a:	b2 e0       	ldi	r27, 0x02	; 2
     14c:	01 c0       	rjmp	.+2      	; 0x150 <.do_clear_bss_start>

0000014e <.do_clear_bss_loop>:
     14e:	1d 92       	st	X+, r1

00000150 <.do_clear_bss_start>:
     150:	a9 37       	cpi	r26, 0x79	; 121
     152:	b1 07       	cpc	r27, r17
     154:	e1 f7       	brne	.-8      	; 0x14e <.do_clear_bss_loop>
     156:	0e 94 c9 00 	call	0x192	; 0x192 <main>
     15a:	0c 94 ac 29 	jmp	0x5358	; 0x5358 <_exit>

0000015e <__bad_interrupt>:
     15e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000162 <vApplicationTickHook>:
int count = 0;

int sonarTime;

void vApplicationTickHook()
{
     162:	cf 93       	push	r28
     164:	df 93       	push	r29
     166:	cd b7       	in	r28, 0x3d	; 61
     168:	de b7       	in	r29, 0x3e	; 62
    count++;
     16a:	80 91 2c 02 	lds	r24, 0x022C
     16e:	90 91 2d 02 	lds	r25, 0x022D
     172:	01 96       	adiw	r24, 0x01	; 1
     174:	90 93 2d 02 	sts	0x022D, r25
     178:	80 93 2c 02 	sts	0x022C, r24
}
     17c:	df 91       	pop	r29
     17e:	cf 91       	pop	r28
     180:	08 95       	ret

00000182 <vApplicationStackOverflowHook>:

void vApplicationStackOverflowHook(){
     182:	cf 93       	push	r28
     184:	df 93       	push	r29
     186:	cd b7       	in	r28, 0x3d	; 61
     188:	de b7       	in	r29, 0x3e	; 62
	return;
     18a:	00 00       	nop
}
     18c:	df 91       	pop	r29
     18e:	cf 91       	pop	r28
     190:	08 95       	ret

00000192 <main>:
/*-----------------------------------------------------------*/

int main( void )
{
     192:	af 92       	push	r10
     194:	bf 92       	push	r11
     196:	cf 92       	push	r12
     198:	df 92       	push	r13
     19a:	ef 92       	push	r14
     19c:	ff 92       	push	r15
     19e:	0f 93       	push	r16
     1a0:	cf 93       	push	r28
     1a2:	df 93       	push	r29
     1a4:	00 d0       	rcall	.+0      	; 0x1a6 <main+0x14>
     1a6:	00 d0       	rcall	.+0      	; 0x1a8 <main+0x16>
     1a8:	cd b7       	in	r28, 0x3d	; 61
     1aa:	de b7       	in	r29, 0x3e	; 62
    
    //- wimpy variable defs
	uint8_t val[2] = {0x3F, 0xFE};
     1ac:	8f e3       	ldi	r24, 0x3F	; 63
     1ae:	8d 83       	std	Y+5, r24	; 0x05
     1b0:	8e ef       	ldi	r24, 0xFE	; 254
     1b2:	8e 83       	std	Y+6, r24	; 0x06
    uint8_t *val0, *val1;
    
	//- avoid pesky warnings...
	val0 = val + 0;
     1b4:	ce 01       	movw	r24, r28
     1b6:	05 96       	adiw	r24, 0x05	; 5
     1b8:	9a 83       	std	Y+2, r25	; 0x02
     1ba:	89 83       	std	Y+1, r24	; 0x01
	val1 = val + 1;
     1bc:	ce 01       	movw	r24, r28
     1be:	05 96       	adiw	r24, 0x05	; 5
     1c0:	01 96       	adiw	r24, 0x01	; 1
     1c2:	9c 83       	std	Y+4, r25	; 0x04
     1c4:	8b 83       	std	Y+3, r24	; 0x03
    
	DDRA = 0xF7;
     1c6:	81 e2       	ldi	r24, 0x21	; 33
     1c8:	90 e0       	ldi	r25, 0x00	; 0
     1ca:	27 ef       	ldi	r18, 0xF7	; 247
     1cc:	fc 01       	movw	r30, r24
     1ce:	20 83       	st	Z, r18
	//PORTA = 0;
	DDRD = 0xFF;
     1d0:	8a e2       	ldi	r24, 0x2A	; 42
     1d2:	90 e0       	ldi	r25, 0x00	; 0
     1d4:	2f ef       	ldi	r18, 0xFF	; 255
     1d6:	fc 01       	movw	r30, r24
     1d8:	20 83       	st	Z, r18
	DDRE = 0xFF;
     1da:	8d e2       	ldi	r24, 0x2D	; 45
     1dc:	90 e0       	ldi	r25, 0x00	; 0
     1de:	2f ef       	ldi	r18, 0xFF	; 255
     1e0:	fc 01       	movw	r30, r24
     1e2:	20 83       	st	Z, r18
	DDRB = 0xFF; 
     1e4:	84 e2       	ldi	r24, 0x24	; 36
     1e6:	90 e0       	ldi	r25, 0x00	; 0
     1e8:	2f ef       	ldi	r18, 0xFF	; 255
     1ea:	fc 01       	movw	r30, r24
     1ec:	20 83       	st	Z, r18
   DDRF = 0;
     1ee:	80 e3       	ldi	r24, 0x30	; 48
     1f0:	90 e0       	ldi	r25, 0x00	; 0
     1f2:	fc 01       	movw	r30, r24
     1f4:	10 82       	st	Z, r1
	DDRK = 0;
     1f6:	87 e0       	ldi	r24, 0x07	; 7
     1f8:	91 e0       	ldi	r25, 0x01	; 1
     1fa:	fc 01       	movw	r30, r24
     1fc:	10 82       	st	Z, r1
	DDRJ = 0;
     1fe:	84 e0       	ldi	r24, 0x04	; 4
     200:	91 e0       	ldi	r25, 0x01	; 1
     202:	fc 01       	movw	r30, r24
     204:	10 82       	st	Z, r1

	PORTD = 0;
     206:	8b e2       	ldi	r24, 0x2B	; 43
     208:	90 e0       	ldi	r25, 0x00	; 0
     20a:	fc 01       	movw	r30, r24
     20c:	10 82       	st	Z, r1
	PORTE = 0;
     20e:	8e e2       	ldi	r24, 0x2E	; 46
     210:	90 e0       	ldi	r25, 0x00	; 0
     212:	fc 01       	movw	r30, r24
     214:	10 82       	st	Z, r1
	PORTK = 2;
     216:	88 e0       	ldi	r24, 0x08	; 8
     218:	91 e0       	ldi	r25, 0x01	; 1
     21a:	22 e0       	ldi	r18, 0x02	; 2
     21c:	fc 01       	movw	r30, r24
     21e:	20 83       	st	Z, r18

    //- init IO with goodness
	vIO_init();
     220:	0e 94 a0 03 	call	0x740	; 0x740 <vIO_init>

	//- Create a 
	xTaskCreate( (pdTASK_CODE) vTaskFunction_1, (signed char *) "T0", configMINIMAL_STACK_SIZE+1000,
     224:	8b 81       	ldd	r24, Y+3	; 0x03
     226:	9c 81       	ldd	r25, Y+4	; 0x04
     228:	a1 2c       	mov	r10, r1
     22a:	b1 2c       	mov	r11, r1
     22c:	c1 2c       	mov	r12, r1
     22e:	d1 2c       	mov	r13, r1
     230:	e1 2c       	mov	r14, r1
     232:	f1 2c       	mov	r15, r1
     234:	01 e0       	ldi	r16, 0x01	; 1
     236:	9c 01       	movw	r18, r24
     238:	4d e3       	ldi	r20, 0x3D	; 61
     23a:	54 e0       	ldi	r21, 0x04	; 4
     23c:	66 e0       	ldi	r22, 0x06	; 6
     23e:	72 e0       	ldi	r23, 0x02	; 2
     240:	85 e0       	ldi	r24, 0x05	; 5
     242:	93 e0       	ldi	r25, 0x03	; 3
     244:	0e 94 b0 03 	call	0x760	; 0x760 <xTaskGenericCreate>
                (void *) val1, 1, NULL );
	xTaskCreate( (pdTASK_CODE) vTaskPot, (signed char *) "T0", configMINIMAL_STACK_SIZE+1000,
                (void *) val1, 1, NULL );*/

 
  	xTaskCreate( (pdTASK_CODE) vTaskSteer, (signed char *) "T4", configMINIMAL_STACK_SIZE+1000,
     248:	8b 81       	ldd	r24, Y+3	; 0x03
     24a:	9c 81       	ldd	r25, Y+4	; 0x04
     24c:	a1 2c       	mov	r10, r1
     24e:	b1 2c       	mov	r11, r1
     250:	c1 2c       	mov	r12, r1
     252:	d1 2c       	mov	r13, r1
     254:	e1 2c       	mov	r14, r1
     256:	f1 2c       	mov	r15, r1
     258:	01 e0       	ldi	r16, 0x01	; 1
     25a:	9c 01       	movw	r18, r24
     25c:	4d e3       	ldi	r20, 0x3D	; 61
     25e:	54 e0       	ldi	r21, 0x04	; 4
     260:	69 e0       	ldi	r22, 0x09	; 9
     262:	72 e0       	ldi	r23, 0x02	; 2
     264:	88 e5       	ldi	r24, 0x58	; 88
     266:	95 e2       	ldi	r25, 0x25	; 37
     268:	0e 94 b0 03 	call	0x760	; 0x760 <xTaskGenericCreate>

   //xTaskCreate( (pdTASK_CODE) vTaskUSARTRead, (signed char *) "T3", configMINIMAL_STACK_SIZE+1000,
   				//(void *) val1, 1, NULL);

	
	xTaskCreate( (pdTASK_CODE) vTaskADC, (signed char *) "T5", configMINIMAL_STACK_SIZE+1000,
     26c:	8b 81       	ldd	r24, Y+3	; 0x03
     26e:	9c 81       	ldd	r25, Y+4	; 0x04
     270:	a1 2c       	mov	r10, r1
     272:	b1 2c       	mov	r11, r1
     274:	c1 2c       	mov	r12, r1
     276:	d1 2c       	mov	r13, r1
     278:	e1 2c       	mov	r14, r1
     27a:	f1 2c       	mov	r15, r1
     27c:	01 e0       	ldi	r16, 0x01	; 1
     27e:	9c 01       	movw	r18, r24
     280:	4d e3       	ldi	r20, 0x3D	; 61
     282:	54 e0       	ldi	r21, 0x04	; 4
     284:	6c e0       	ldi	r22, 0x0C	; 12
     286:	72 e0       	ldi	r23, 0x02	; 2
     288:	82 e2       	ldi	r24, 0x22	; 34
     28a:	98 e2       	ldi	r25, 0x28	; 40
     28c:	0e 94 b0 03 	call	0x760	; 0x760 <xTaskGenericCreate>

//   xTaskCreate( (pdTASK_CODE) vTaskUSARTLog, (signed char *) "T4", configMINIMAL_STACK_SIZE+1000,
//   				(void *) val1, 1, NULL);
    
    //- kick off the scheduler
	vTaskStartScheduler();
     290:	0e 94 af 06 	call	0xd5e	; 0xd5e <vTaskStartScheduler>
    
	return 0;
     294:	80 e0       	ldi	r24, 0x00	; 0
     296:	90 e0       	ldi	r25, 0x00	; 0
}
     298:	26 96       	adiw	r28, 0x06	; 6
     29a:	0f b6       	in	r0, 0x3f	; 63
     29c:	f8 94       	cli
     29e:	de bf       	out	0x3e, r29	; 62
     2a0:	0f be       	out	0x3f, r0	; 63
     2a2:	cd bf       	out	0x3d, r28	; 61
     2a4:	df 91       	pop	r29
     2a6:	cf 91       	pop	r28
     2a8:	0f 91       	pop	r16
     2aa:	ff 90       	pop	r15
     2ac:	ef 90       	pop	r14
     2ae:	df 90       	pop	r13
     2b0:	cf 90       	pop	r12
     2b2:	bf 90       	pop	r11
     2b4:	af 90       	pop	r10
     2b6:	08 95       	ret

000002b8 <printHex>:
/*-----------------------------------------------------------*/

void printHex(int i){
     2b8:	cf 93       	push	r28
     2ba:	df 93       	push	r29
     2bc:	cd b7       	in	r28, 0x3d	; 61
     2be:	de b7       	in	r29, 0x3e	; 62
     2c0:	62 97       	sbiw	r28, 0x12	; 18
     2c2:	0f b6       	in	r0, 0x3f	; 63
     2c4:	f8 94       	cli
     2c6:	de bf       	out	0x3e, r29	; 62
     2c8:	0f be       	out	0x3f, r0	; 63
     2ca:	cd bf       	out	0x3d, r28	; 61
     2cc:	9a 8b       	std	Y+18, r25	; 0x12
     2ce:	89 8b       	std	Y+17, r24	; 0x11
	char hex[] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
     2d0:	20 e1       	ldi	r18, 0x10	; 16
     2d2:	ef e0       	ldi	r30, 0x0F	; 15
     2d4:	f2 e0       	ldi	r31, 0x02	; 2
     2d6:	ce 01       	movw	r24, r28
     2d8:	01 96       	adiw	r24, 0x01	; 1
     2da:	dc 01       	movw	r26, r24
     2dc:	01 90       	ld	r0, Z+
     2de:	0d 92       	st	X+, r0
     2e0:	2a 95       	dec	r18
     2e2:	e1 f7       	brne	.-8      	; 0x2dc <printHex+0x24>

	USART_Write(hex[(i&0xF000) >> 12]);
     2e4:	89 89       	ldd	r24, Y+17	; 0x11
     2e6:	9a 89       	ldd	r25, Y+18	; 0x12
     2e8:	89 2f       	mov	r24, r25
     2ea:	99 27       	eor	r25, r25
     2ec:	82 95       	swap	r24
     2ee:	8f 70       	andi	r24, 0x0F	; 15
     2f0:	9e 01       	movw	r18, r28
     2f2:	2f 5f       	subi	r18, 0xFF	; 255
     2f4:	3f 4f       	sbci	r19, 0xFF	; 255
     2f6:	82 0f       	add	r24, r18
     2f8:	93 1f       	adc	r25, r19
     2fa:	fc 01       	movw	r30, r24
     2fc:	80 81       	ld	r24, Z
     2fe:	0e 94 fc 1a 	call	0x35f8	; 0x35f8 <USART_Write>
	USART_Write(hex[(i&0xF00) >> 8]);
     302:	89 89       	ldd	r24, Y+17	; 0x11
     304:	9a 89       	ldd	r25, Y+18	; 0x12
     306:	88 27       	eor	r24, r24
     308:	9f 70       	andi	r25, 0x0F	; 15
     30a:	89 2f       	mov	r24, r25
     30c:	99 0f       	add	r25, r25
     30e:	99 0b       	sbc	r25, r25
     310:	9e 01       	movw	r18, r28
     312:	2f 5f       	subi	r18, 0xFF	; 255
     314:	3f 4f       	sbci	r19, 0xFF	; 255
     316:	82 0f       	add	r24, r18
     318:	93 1f       	adc	r25, r19
     31a:	fc 01       	movw	r30, r24
     31c:	80 81       	ld	r24, Z
     31e:	0e 94 fc 1a 	call	0x35f8	; 0x35f8 <USART_Write>
	USART_Write(hex[(i&0xF0) >> 4]);
     322:	89 89       	ldd	r24, Y+17	; 0x11
     324:	9a 89       	ldd	r25, Y+18	; 0x12
     326:	80 7f       	andi	r24, 0xF0	; 240
     328:	99 27       	eor	r25, r25
     32a:	95 95       	asr	r25
     32c:	87 95       	ror	r24
     32e:	95 95       	asr	r25
     330:	87 95       	ror	r24
     332:	95 95       	asr	r25
     334:	87 95       	ror	r24
     336:	95 95       	asr	r25
     338:	87 95       	ror	r24
     33a:	9e 01       	movw	r18, r28
     33c:	2f 5f       	subi	r18, 0xFF	; 255
     33e:	3f 4f       	sbci	r19, 0xFF	; 255
     340:	82 0f       	add	r24, r18
     342:	93 1f       	adc	r25, r19
     344:	fc 01       	movw	r30, r24
     346:	80 81       	ld	r24, Z
     348:	0e 94 fc 1a 	call	0x35f8	; 0x35f8 <USART_Write>
	USART_Write(hex[i&0xF]);
     34c:	89 89       	ldd	r24, Y+17	; 0x11
     34e:	9a 89       	ldd	r25, Y+18	; 0x12
     350:	8f 70       	andi	r24, 0x0F	; 15
     352:	99 27       	eor	r25, r25
     354:	9e 01       	movw	r18, r28
     356:	2f 5f       	subi	r18, 0xFF	; 255
     358:	3f 4f       	sbci	r19, 0xFF	; 255
     35a:	82 0f       	add	r24, r18
     35c:	93 1f       	adc	r25, r19
     35e:	fc 01       	movw	r30, r24
     360:	80 81       	ld	r24, Z
     362:	0e 94 fc 1a 	call	0x35f8	; 0x35f8 <USART_Write>

}
     366:	62 96       	adiw	r28, 0x12	; 18
     368:	0f b6       	in	r0, 0x3f	; 63
     36a:	f8 94       	cli
     36c:	de bf       	out	0x3e, r29	; 62
     36e:	0f be       	out	0x3f, r0	; 63
     370:	cd bf       	out	0x3d, r28	; 61
     372:	df 91       	pop	r29
     374:	cf 91       	pop	r28
     376:	08 95       	ret

00000378 <printNum>:

void printNum(unsigned int i){
     378:	cf 93       	push	r28
     37a:	df 93       	push	r29
     37c:	00 d0       	rcall	.+0      	; 0x37e <printNum+0x6>
     37e:	1f 92       	push	r1
     380:	cd b7       	in	r28, 0x3d	; 61
     382:	de b7       	in	r29, 0x3e	; 62
     384:	9c 83       	std	Y+4, r25	; 0x04
     386:	8b 83       	std	Y+3, r24	; 0x03
    
	int draw = 0;
     388:	1a 82       	std	Y+2, r1	; 0x02
     38a:	19 82       	std	Y+1, r1	; 0x01
	USART_Write(i / 10000 + '0');
     38c:	8b 81       	ldd	r24, Y+3	; 0x03
     38e:	9c 81       	ldd	r25, Y+4	; 0x04
     390:	92 95       	swap	r25
     392:	82 95       	swap	r24
     394:	8f 70       	andi	r24, 0x0F	; 15
     396:	89 27       	eor	r24, r25
     398:	9f 70       	andi	r25, 0x0F	; 15
     39a:	89 27       	eor	r24, r25
     39c:	9c 01       	movw	r18, r24
     39e:	a7 e4       	ldi	r26, 0x47	; 71
     3a0:	b3 e0       	ldi	r27, 0x03	; 3
     3a2:	0e 94 78 29 	call	0x52f0	; 0x52f0 <__umulhisi3>
     3a6:	96 95       	lsr	r25
     3a8:	87 95       	ror	r24
     3aa:	96 95       	lsr	r25
     3ac:	87 95       	ror	r24
     3ae:	96 95       	lsr	r25
     3b0:	87 95       	ror	r24
     3b2:	80 5d       	subi	r24, 0xD0	; 208
     3b4:	0e 94 fc 1a 	call	0x35f8	; 0x35f8 <USART_Write>
	USART_Write((i % 10000) / 1000 + '0');
     3b8:	4b 81       	ldd	r20, Y+3	; 0x03
     3ba:	5c 81       	ldd	r21, Y+4	; 0x04
     3bc:	ca 01       	movw	r24, r20
     3be:	92 95       	swap	r25
     3c0:	82 95       	swap	r24
     3c2:	8f 70       	andi	r24, 0x0F	; 15
     3c4:	89 27       	eor	r24, r25
     3c6:	9f 70       	andi	r25, 0x0F	; 15
     3c8:	89 27       	eor	r24, r25
     3ca:	9c 01       	movw	r18, r24
     3cc:	a7 e4       	ldi	r26, 0x47	; 71
     3ce:	b3 e0       	ldi	r27, 0x03	; 3
     3d0:	0e 94 78 29 	call	0x52f0	; 0x52f0 <__umulhisi3>
     3d4:	96 95       	lsr	r25
     3d6:	87 95       	ror	r24
     3d8:	96 95       	lsr	r25
     3da:	87 95       	ror	r24
     3dc:	96 95       	lsr	r25
     3de:	87 95       	ror	r24
     3e0:	60 e1       	ldi	r22, 0x10	; 16
     3e2:	77 e2       	ldi	r23, 0x27	; 39
     3e4:	86 9f       	mul	r24, r22
     3e6:	90 01       	movw	r18, r0
     3e8:	87 9f       	mul	r24, r23
     3ea:	30 0d       	add	r19, r0
     3ec:	96 9f       	mul	r25, r22
     3ee:	30 0d       	add	r19, r0
     3f0:	11 24       	eor	r1, r1
     3f2:	ca 01       	movw	r24, r20
     3f4:	82 1b       	sub	r24, r18
     3f6:	93 0b       	sbc	r25, r19
     3f8:	96 95       	lsr	r25
     3fa:	87 95       	ror	r24
     3fc:	96 95       	lsr	r25
     3fe:	87 95       	ror	r24
     400:	96 95       	lsr	r25
     402:	87 95       	ror	r24
     404:	9c 01       	movw	r18, r24
     406:	a5 ec       	ldi	r26, 0xC5	; 197
     408:	b0 e2       	ldi	r27, 0x20	; 32
     40a:	0e 94 78 29 	call	0x52f0	; 0x52f0 <__umulhisi3>
     40e:	92 95       	swap	r25
     410:	82 95       	swap	r24
     412:	8f 70       	andi	r24, 0x0F	; 15
     414:	89 27       	eor	r24, r25
     416:	9f 70       	andi	r25, 0x0F	; 15
     418:	89 27       	eor	r24, r25
     41a:	80 5d       	subi	r24, 0xD0	; 208
     41c:	0e 94 fc 1a 	call	0x35f8	; 0x35f8 <USART_Write>
	USART_Write((i % 1000) / 100 + '0');
     420:	4b 81       	ldd	r20, Y+3	; 0x03
     422:	5c 81       	ldd	r21, Y+4	; 0x04
     424:	ca 01       	movw	r24, r20
     426:	96 95       	lsr	r25
     428:	87 95       	ror	r24
     42a:	96 95       	lsr	r25
     42c:	87 95       	ror	r24
     42e:	96 95       	lsr	r25
     430:	87 95       	ror	r24
     432:	9c 01       	movw	r18, r24
     434:	a5 ec       	ldi	r26, 0xC5	; 197
     436:	b0 e2       	ldi	r27, 0x20	; 32
     438:	0e 94 78 29 	call	0x52f0	; 0x52f0 <__umulhisi3>
     43c:	92 95       	swap	r25
     43e:	82 95       	swap	r24
     440:	8f 70       	andi	r24, 0x0F	; 15
     442:	89 27       	eor	r24, r25
     444:	9f 70       	andi	r25, 0x0F	; 15
     446:	89 27       	eor	r24, r25
     448:	68 ee       	ldi	r22, 0xE8	; 232
     44a:	73 e0       	ldi	r23, 0x03	; 3
     44c:	86 9f       	mul	r24, r22
     44e:	90 01       	movw	r18, r0
     450:	87 9f       	mul	r24, r23
     452:	30 0d       	add	r19, r0
     454:	96 9f       	mul	r25, r22
     456:	30 0d       	add	r19, r0
     458:	11 24       	eor	r1, r1
     45a:	ca 01       	movw	r24, r20
     45c:	82 1b       	sub	r24, r18
     45e:	93 0b       	sbc	r25, r19
     460:	96 95       	lsr	r25
     462:	87 95       	ror	r24
     464:	96 95       	lsr	r25
     466:	87 95       	ror	r24
     468:	9c 01       	movw	r18, r24
     46a:	ab e7       	ldi	r26, 0x7B	; 123
     46c:	b4 e1       	ldi	r27, 0x14	; 20
     46e:	0e 94 78 29 	call	0x52f0	; 0x52f0 <__umulhisi3>
     472:	96 95       	lsr	r25
     474:	87 95       	ror	r24
     476:	80 5d       	subi	r24, 0xD0	; 208
     478:	0e 94 fc 1a 	call	0x35f8	; 0x35f8 <USART_Write>
	USART_Write((i % 100) / 10 + '0');
     47c:	4b 81       	ldd	r20, Y+3	; 0x03
     47e:	5c 81       	ldd	r21, Y+4	; 0x04
     480:	ca 01       	movw	r24, r20
     482:	96 95       	lsr	r25
     484:	87 95       	ror	r24
     486:	96 95       	lsr	r25
     488:	87 95       	ror	r24
     48a:	9c 01       	movw	r18, r24
     48c:	ab e7       	ldi	r26, 0x7B	; 123
     48e:	b4 e1       	ldi	r27, 0x14	; 20
     490:	0e 94 78 29 	call	0x52f0	; 0x52f0 <__umulhisi3>
     494:	96 95       	lsr	r25
     496:	87 95       	ror	r24
     498:	64 e6       	ldi	r22, 0x64	; 100
     49a:	68 9f       	mul	r22, r24
     49c:	90 01       	movw	r18, r0
     49e:	69 9f       	mul	r22, r25
     4a0:	30 0d       	add	r19, r0
     4a2:	11 24       	eor	r1, r1
     4a4:	ca 01       	movw	r24, r20
     4a6:	82 1b       	sub	r24, r18
     4a8:	93 0b       	sbc	r25, r19
     4aa:	9c 01       	movw	r18, r24
     4ac:	ad ec       	ldi	r26, 0xCD	; 205
     4ae:	bc ec       	ldi	r27, 0xCC	; 204
     4b0:	0e 94 78 29 	call	0x52f0	; 0x52f0 <__umulhisi3>
     4b4:	96 95       	lsr	r25
     4b6:	87 95       	ror	r24
     4b8:	96 95       	lsr	r25
     4ba:	87 95       	ror	r24
     4bc:	96 95       	lsr	r25
     4be:	87 95       	ror	r24
     4c0:	80 5d       	subi	r24, 0xD0	; 208
     4c2:	0e 94 fc 1a 	call	0x35f8	; 0x35f8 <USART_Write>
   USART_Write((i % 10) + '0');
     4c6:	4b 81       	ldd	r20, Y+3	; 0x03
     4c8:	5c 81       	ldd	r21, Y+4	; 0x04
     4ca:	9a 01       	movw	r18, r20
     4cc:	ad ec       	ldi	r26, 0xCD	; 205
     4ce:	bc ec       	ldi	r27, 0xCC	; 204
     4d0:	0e 94 78 29 	call	0x52f0	; 0x52f0 <__umulhisi3>
     4d4:	96 95       	lsr	r25
     4d6:	87 95       	ror	r24
     4d8:	96 95       	lsr	r25
     4da:	87 95       	ror	r24
     4dc:	96 95       	lsr	r25
     4de:	87 95       	ror	r24
     4e0:	88 0f       	add	r24, r24
     4e2:	99 1f       	adc	r25, r25
     4e4:	9c 01       	movw	r18, r24
     4e6:	22 0f       	add	r18, r18
     4e8:	33 1f       	adc	r19, r19
     4ea:	22 0f       	add	r18, r18
     4ec:	33 1f       	adc	r19, r19
     4ee:	82 0f       	add	r24, r18
     4f0:	93 1f       	adc	r25, r19
     4f2:	9a 01       	movw	r18, r20
     4f4:	28 1b       	sub	r18, r24
     4f6:	39 0b       	sbc	r19, r25
     4f8:	c9 01       	movw	r24, r18
     4fa:	80 5d       	subi	r24, 0xD0	; 208
     4fc:	0e 94 fc 1a 	call	0x35f8	; 0x35f8 <USART_Write>
}
     500:	0f 90       	pop	r0
     502:	0f 90       	pop	r0
     504:	0f 90       	pop	r0
     506:	0f 90       	pop	r0
     508:	df 91       	pop	r29
     50a:	cf 91       	pop	r28
     50c:	08 95       	ret

0000050e <getBatteryVoltageHandler>:

static int batteryVoltage;

void getBatteryVoltageHandler(int a,void *dummy){
     50e:	cf 93       	push	r28
     510:	df 93       	push	r29
     512:	00 d0       	rcall	.+0      	; 0x514 <getBatteryVoltageHandler+0x6>
     514:	1f 92       	push	r1
     516:	cd b7       	in	r28, 0x3d	; 61
     518:	de b7       	in	r29, 0x3e	; 62
     51a:	9a 83       	std	Y+2, r25	; 0x02
     51c:	89 83       	std	Y+1, r24	; 0x01
     51e:	7c 83       	std	Y+4, r23	; 0x04
     520:	6b 83       	std	Y+3, r22	; 0x03
	//batteryVoltage = (a - 218) / 4 - 3;
   //batteryVoltage = a;
   printHex(a);
     522:	89 81       	ldd	r24, Y+1	; 0x01
     524:	9a 81       	ldd	r25, Y+2	; 0x02
     526:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <printHex>
   USART_Write('\r');
     52a:	8d e0       	ldi	r24, 0x0D	; 13
     52c:	0e 94 fc 1a 	call	0x35f8	; 0x35f8 <USART_Write>
   USART_Write('\n');
     530:	8a e0       	ldi	r24, 0x0A	; 10
     532:	0e 94 fc 1a 	call	0x35f8	; 0x35f8 <USART_Write>
}
     536:	0f 90       	pop	r0
     538:	0f 90       	pop	r0
     53a:	0f 90       	pop	r0
     53c:	0f 90       	pop	r0
     53e:	df 91       	pop	r29
     540:	cf 91       	pop	r28
     542:	08 95       	ret

00000544 <getTimerCount2>:

unsigned int getTimerCount2(){
     544:	cf 93       	push	r28
     546:	df 93       	push	r29
     548:	cd b7       	in	r28, 0x3d	; 61
     54a:	de b7       	in	r29, 0x3e	; 62

	//volatile char timerLow = TCNT3L;

	return TCNT0;
     54c:	86 e4       	ldi	r24, 0x46	; 70
     54e:	90 e0       	ldi	r25, 0x00	; 0
     550:	fc 01       	movw	r30, r24
     552:	80 81       	ld	r24, Z
     554:	88 2f       	mov	r24, r24
     556:	90 e0       	ldi	r25, 0x00	; 0

}
     558:	df 91       	pop	r29
     55a:	cf 91       	pop	r28
     55c:	08 95       	ret

0000055e <potValue>:


int potValue(int sonarMax,int sonarMin,int potMax,int potMin,int x){
     55e:	0f 93       	push	r16
     560:	1f 93       	push	r17
     562:	cf 93       	push	r28
     564:	df 93       	push	r29
     566:	cd b7       	in	r28, 0x3d	; 61
     568:	de b7       	in	r29, 0x3e	; 62
     56a:	2c 97       	sbiw	r28, 0x0c	; 12
     56c:	0f b6       	in	r0, 0x3f	; 63
     56e:	f8 94       	cli
     570:	de bf       	out	0x3e, r29	; 62
     572:	0f be       	out	0x3f, r0	; 63
     574:	cd bf       	out	0x3d, r28	; 61
     576:	9c 83       	std	Y+4, r25	; 0x04
     578:	8b 83       	std	Y+3, r24	; 0x03
     57a:	7e 83       	std	Y+6, r23	; 0x06
     57c:	6d 83       	std	Y+5, r22	; 0x05
     57e:	58 87       	std	Y+8, r21	; 0x08
     580:	4f 83       	std	Y+7, r20	; 0x07
     582:	3a 87       	std	Y+10, r19	; 0x0a
     584:	29 87       	std	Y+9, r18	; 0x09
     586:	1c 87       	std	Y+12, r17	; 0x0c
     588:	0b 87       	std	Y+11, r16	; 0x0b
	int value;	
	if(x < sonarMin){
     58a:	2b 85       	ldd	r18, Y+11	; 0x0b
     58c:	3c 85       	ldd	r19, Y+12	; 0x0c
     58e:	8d 81       	ldd	r24, Y+5	; 0x05
     590:	9e 81       	ldd	r25, Y+6	; 0x06
     592:	28 17       	cp	r18, r24
     594:	39 07       	cpc	r19, r25
     596:	1c f4       	brge	.+6      	; 0x59e <potValue+0x40>
		return potMin;
     598:	89 85       	ldd	r24, Y+9	; 0x09
     59a:	9a 85       	ldd	r25, Y+10	; 0x0a
     59c:	2b c0       	rjmp	.+86     	; 0x5f4 <potValue+0x96>
	} else if (x > sonarMax){
     59e:	2b 85       	ldd	r18, Y+11	; 0x0b
     5a0:	3c 85       	ldd	r19, Y+12	; 0x0c
     5a2:	8b 81       	ldd	r24, Y+3	; 0x03
     5a4:	9c 81       	ldd	r25, Y+4	; 0x04
     5a6:	82 17       	cp	r24, r18
     5a8:	93 07       	cpc	r25, r19
     5aa:	1c f4       	brge	.+6      	; 0x5b2 <potValue+0x54>
		return potMax;
     5ac:	8f 81       	ldd	r24, Y+7	; 0x07
     5ae:	98 85       	ldd	r25, Y+8	; 0x08
     5b0:	21 c0       	rjmp	.+66     	; 0x5f4 <potValue+0x96>
	} else {
		value = x / 4 - 140;
     5b2:	8b 85       	ldd	r24, Y+11	; 0x0b
     5b4:	9c 85       	ldd	r25, Y+12	; 0x0c
     5b6:	99 23       	and	r25, r25
     5b8:	0c f4       	brge	.+2      	; 0x5bc <potValue+0x5e>
     5ba:	03 96       	adiw	r24, 0x03	; 3
     5bc:	95 95       	asr	r25
     5be:	87 95       	ror	r24
     5c0:	95 95       	asr	r25
     5c2:	87 95       	ror	r24
     5c4:	8c 58       	subi	r24, 0x8C	; 140
     5c6:	91 09       	sbc	r25, r1
     5c8:	9a 83       	std	Y+2, r25	; 0x02
     5ca:	89 83       	std	Y+1, r24	; 0x01
		return value > potMax?potMax:value < potMin?potMin:value;
     5cc:	29 81       	ldd	r18, Y+1	; 0x01
     5ce:	3a 81       	ldd	r19, Y+2	; 0x02
     5d0:	8f 81       	ldd	r24, Y+7	; 0x07
     5d2:	98 85       	ldd	r25, Y+8	; 0x08
     5d4:	82 17       	cp	r24, r18
     5d6:	93 07       	cpc	r25, r19
     5d8:	4c f0       	brlt	.+18     	; 0x5ec <potValue+0x8e>
     5da:	29 85       	ldd	r18, Y+9	; 0x09
     5dc:	3a 85       	ldd	r19, Y+10	; 0x0a
     5de:	89 81       	ldd	r24, Y+1	; 0x01
     5e0:	9a 81       	ldd	r25, Y+2	; 0x02
     5e2:	82 17       	cp	r24, r18
     5e4:	93 07       	cpc	r25, r19
     5e6:	2c f4       	brge	.+10     	; 0x5f2 <potValue+0x94>
     5e8:	c9 01       	movw	r24, r18
     5ea:	03 c0       	rjmp	.+6      	; 0x5f2 <potValue+0x94>
     5ec:	8f 81       	ldd	r24, Y+7	; 0x07
     5ee:	98 85       	ldd	r25, Y+8	; 0x08
     5f0:	00 c0       	rjmp	.+0      	; 0x5f2 <potValue+0x94>
     5f2:	00 00       	nop
	}
} 
     5f4:	2c 96       	adiw	r28, 0x0c	; 12
     5f6:	0f b6       	in	r0, 0x3f	; 63
     5f8:	f8 94       	cli
     5fa:	de bf       	out	0x3e, r29	; 62
     5fc:	0f be       	out	0x3f, r0	; 63
     5fe:	cd bf       	out	0x3d, r28	; 61
     600:	df 91       	pop	r29
     602:	cf 91       	pop	r28
     604:	1f 91       	pop	r17
     606:	0f 91       	pop	r16
     608:	08 95       	ret

0000060a <vTaskFunction_1>:

void vTaskFunction_1(void *pvParameters)
{	
     60a:	cf 93       	push	r28
     60c:	df 93       	push	r29
     60e:	cd b7       	in	r28, 0x3d	; 61
     610:	de b7       	in	r29, 0x3e	; 62
     612:	65 97       	sbiw	r28, 0x15	; 21
     614:	0f b6       	in	r0, 0x3f	; 63
     616:	f8 94       	cli
     618:	de bf       	out	0x3e, r29	; 62
     61a:	0f be       	out	0x3f, r0	; 63
     61c:	cd bf       	out	0x3d, r28	; 61
     61e:	9d 8b       	std	Y+21, r25	; 0x15
     620:	8c 8b       	std	Y+20, r24	; 0x14
	int sonarResult;
	int movingForward = 1;
     622:	81 e0       	ldi	r24, 0x01	; 1
     624:	90 e0       	ldi	r25, 0x00	; 0
     626:	9a 83       	std	Y+2, r25	; 0x02
     628:	89 83       	std	Y+1, r24	; 0x01

	int sonarMax = 0x31C;
     62a:	8c e1       	ldi	r24, 0x1C	; 28
     62c:	93 e0       	ldi	r25, 0x03	; 3
     62e:	9c 83       	std	Y+4, r25	; 0x04
     630:	8b 83       	std	Y+3, r24	; 0x03
	int sonarMin = 0xE0;
     632:	80 ee       	ldi	r24, 0xE0	; 224
     634:	90 e0       	ldi	r25, 0x00	; 0
     636:	9e 83       	std	Y+6, r25	; 0x06
     638:	8d 83       	std	Y+5, r24	; 0x05
	int potMin = 0x18;
     63a:	88 e1       	ldi	r24, 0x18	; 24
     63c:	90 e0       	ldi	r25, 0x00	; 0
     63e:	98 87       	std	Y+8, r25	; 0x08
     640:	8f 83       	std	Y+7, r24	; 0x07
	int potMax = 0x40;;
     642:	80 e4       	ldi	r24, 0x40	; 64
     644:	90 e0       	ldi	r25, 0x00	; 0
     646:	9a 87       	std	Y+10, r25	; 0x0a
     648:	89 87       	std	Y+9, r24	; 0x09
	int backwardSwitch = 0x100;
     64a:	80 e0       	ldi	r24, 0x00	; 0
     64c:	91 e0       	ldi	r25, 0x01	; 1
     64e:	9c 87       	std	Y+12, r25	; 0x0c
     650:	8b 87       	std	Y+11, r24	; 0x0b
	int neutralSwitch = 0x140;
     652:	80 e4       	ldi	r24, 0x40	; 64
     654:	91 e0       	ldi	r25, 0x01	; 1
     656:	9e 87       	std	Y+14, r25	; 0x0e
     658:	8d 87       	std	Y+13, r24	; 0x0d
	int forwardSwitch = 0x160;
     65a:	80 e6       	ldi	r24, 0x60	; 96
     65c:	91 e0       	ldi	r25, 0x01	; 1
     65e:	98 8b       	std	Y+16, r25	; 0x10
     660:	8f 87       	std	Y+15, r24	; 0x0f
	int minTicks = 450;
     662:	82 ec       	ldi	r24, 0xC2	; 194
     664:	91 e0       	ldi	r25, 0x01	; 1
     666:	9a 8b       	std	Y+18, r25	; 0x12
     668:	89 8b       	std	Y+17, r24	; 0x11

	int tickCount;

	char a = 'a';
     66a:	81 e6       	ldi	r24, 0x61	; 97
     66c:	8b 8b       	std	Y+19, r24	; 0x13

	PORTA = 0;
     66e:	82 e2       	ldi	r24, 0x22	; 34
     670:	90 e0       	ldi	r25, 0x00	; 0
     672:	fc 01       	movw	r30, r24
     674:	10 82       	st	Z, r1

   USART_Init(9600, 16000000);
     676:	40 e0       	ldi	r20, 0x00	; 0
     678:	54 e2       	ldi	r21, 0x24	; 36
     67a:	64 ef       	ldi	r22, 0xF4	; 244
     67c:	70 e0       	ldi	r23, 0x00	; 0
     67e:	80 e8       	ldi	r24, 0x80	; 128
     680:	95 e2       	ldi	r25, 0x25	; 37
     682:	0e 94 b9 1a 	call	0x3572	; 0x3572 <USART_Init>

	initializeSteeringTimer();
     686:	0e 94 e9 23 	call	0x47d2	; 0x47d2 <initializeSteeringTimer>

	initializeSPI();
     68a:	0e 94 c9 25 	call	0x4b92	; 0x4b92 <initializeSPI>
	initSpeedController();
     68e:	0e 94 53 23 	call	0x46a6	; 0x46a6 <initSpeedController>
   initializeSteeringTimer();
     692:	0e 94 e9 23 	call	0x47d2	; 0x47d2 <initializeSteeringTimer>
	//setSteeringPWMSpeed(0xB0);

	
	//addADCDevice(3,ADC_OPT_PRECISION_HIGH,getBatteryVoltageHandler,NULL);
   for(;;) {
      PORTA ^= 0x80;
     696:	82 e2       	ldi	r24, 0x22	; 34
     698:	90 e0       	ldi	r25, 0x00	; 0
     69a:	22 e2       	ldi	r18, 0x22	; 34
     69c:	30 e0       	ldi	r19, 0x00	; 0
     69e:	f9 01       	movw	r30, r18
     6a0:	30 81       	ld	r19, Z
     6a2:	20 e8       	ldi	r18, 0x80	; 128
     6a4:	23 27       	eor	r18, r19
     6a6:	fc 01       	movw	r30, r24
     6a8:	20 83       	st	Z, r18
      vTaskDelay(300);
     6aa:	8c e2       	ldi	r24, 0x2C	; 44
     6ac:	91 e0       	ldi	r25, 0x01	; 1
     6ae:	0e 94 1d 05 	call	0xa3a	; 0xa3a <vTaskDelay>
   }
     6b2:	f1 cf       	rjmp	.-30     	; 0x696 <vTaskFunction_1+0x8c>

000006b4 <vTaskFunction_2>:
		PORTL = 0x80;
		vTaskDelay(200);
	}
}

void vTaskFunction_2(void *pvParameters){
     6b4:	cf 93       	push	r28
     6b6:	df 93       	push	r29
     6b8:	1f 92       	push	r1
     6ba:	1f 92       	push	r1
     6bc:	cd b7       	in	r28, 0x3d	; 61
     6be:	de b7       	in	r29, 0x3e	; 62
     6c0:	9a 83       	std	Y+2, r25	; 0x02
     6c2:	89 83       	std	Y+1, r24	; 0x01
	DDRL = 0xF0;
     6c4:	8a e0       	ldi	r24, 0x0A	; 10
     6c6:	91 e0       	ldi	r25, 0x01	; 1
     6c8:	20 ef       	ldi	r18, 0xF0	; 240
     6ca:	fc 01       	movw	r30, r24
     6cc:	20 83       	st	Z, r18
	PORTL = 0xC0;
     6ce:	8b e0       	ldi	r24, 0x0B	; 11
     6d0:	91 e0       	ldi	r25, 0x01	; 1
     6d2:	20 ec       	ldi	r18, 0xC0	; 192
     6d4:	fc 01       	movw	r30, r24
     6d6:	20 83       	st	Z, r18
	for(;;){
		vTaskDelay(300);
     6d8:	8c e2       	ldi	r24, 0x2C	; 44
     6da:	91 e0       	ldi	r25, 0x01	; 1
     6dc:	0e 94 1d 05 	call	0xa3a	; 0xa3a <vTaskDelay>
	}	
     6e0:	fb cf       	rjmp	.-10     	; 0x6d8 <vTaskFunction_2+0x24>

000006e2 <vTaskPot>:
}

void vTaskPot(void *pvParameters){
     6e2:	cf 93       	push	r28
     6e4:	df 93       	push	r29
     6e6:	00 d0       	rcall	.+0      	; 0x6e8 <vTaskPot+0x6>
     6e8:	1f 92       	push	r1
     6ea:	cd b7       	in	r28, 0x3d	; 61
     6ec:	de b7       	in	r29, 0x3e	; 62
     6ee:	9c 83       	std	Y+4, r25	; 0x04
     6f0:	8b 83       	std	Y+3, r24	; 0x03
	initializeSPI();
     6f2:	0e 94 c9 25 	call	0x4b92	; 0x4b92 <initializeSPI>
	int a = 0;
     6f6:	1a 82       	std	Y+2, r1	; 0x02
     6f8:	19 82       	std	Y+1, r1	; 0x01
	initSpeedController();
     6fa:	0e 94 53 23 	call	0x46a6	; 0x46a6 <initSpeedController>
		setPot(a);
		vTaskDelay(80);
		a++;
	}*/
	for(;;){
		setPot(1);
     6fe:	81 e0       	ldi	r24, 0x01	; 1
     700:	90 e0       	ldi	r25, 0x00	; 0
     702:	0e 94 5e 23 	call	0x46bc	; 0x46bc <setPot>
		vTaskDelay(500);
     706:	84 ef       	ldi	r24, 0xF4	; 244
     708:	91 e0       	ldi	r25, 0x01	; 1
     70a:	0e 94 1d 05 	call	0xa3a	; 0xa3a <vTaskDelay>
		setPot(0x40);
     70e:	80 e4       	ldi	r24, 0x40	; 64
     710:	90 e0       	ldi	r25, 0x00	; 0
     712:	0e 94 5e 23 	call	0x46bc	; 0x46bc <setPot>
		vTaskDelay(500);
     716:	84 ef       	ldi	r24, 0xF4	; 244
     718:	91 e0       	ldi	r25, 0x01	; 1
     71a:	0e 94 1d 05 	call	0xa3a	; 0xa3a <vTaskDelay>
		setPot(0x7F);
     71e:	8f e7       	ldi	r24, 0x7F	; 127
     720:	90 e0       	ldi	r25, 0x00	; 0
     722:	0e 94 5e 23 	call	0x46bc	; 0x46bc <setPot>
		vTaskDelay(500);
     726:	84 ef       	ldi	r24, 0xF4	; 244
     728:	91 e0       	ldi	r25, 0x01	; 1
     72a:	0e 94 1d 05 	call	0xa3a	; 0xa3a <vTaskDelay>
		setPot(0x40);
     72e:	80 e4       	ldi	r24, 0x40	; 64
     730:	90 e0       	ldi	r25, 0x00	; 0
     732:	0e 94 5e 23 	call	0x46bc	; 0x46bc <setPot>
		vTaskDelay(500);
     736:	84 ef       	ldi	r24, 0xF4	; 244
     738:	91 e0       	ldi	r25, 0x01	; 1
     73a:	0e 94 1d 05 	call	0xa3a	; 0xa3a <vTaskDelay>
	}
     73e:	df cf       	rjmp	.-66     	; 0x6fe <vTaskPot+0x1c>

00000740 <vIO_init>:
}


void vIO_init(void)
{
     740:	cf 93       	push	r28
     742:	df 93       	push	r29
     744:	cd b7       	in	r28, 0x3d	; 61
     746:	de b7       	in	r29, 0x3e	; 62
    //- set PortB as output
	DDRB = 0xFF; 
     748:	84 e2       	ldi	r24, 0x24	; 36
     74a:	90 e0       	ldi	r25, 0x00	; 0
     74c:	2f ef       	ldi	r18, 0xFF	; 255
     74e:	fc 01       	movw	r30, r24
     750:	20 83       	st	Z, r18
    PORTB = 0; 
     752:	85 e2       	ldi	r24, 0x25	; 37
     754:	90 e0       	ldi	r25, 0x00	; 0
     756:	fc 01       	movw	r30, r24
     758:	10 82       	st	Z, r1
}
     75a:	df 91       	pop	r29
     75c:	cf 91       	pop	r28
     75e:	08 95       	ret

00000760 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
     760:	af 92       	push	r10
     762:	bf 92       	push	r11
     764:	cf 92       	push	r12
     766:	df 92       	push	r13
     768:	ef 92       	push	r14
     76a:	ff 92       	push	r15
     76c:	0f 93       	push	r16
     76e:	1f 93       	push	r17
     770:	cf 93       	push	r28
     772:	df 93       	push	r29
     774:	cd b7       	in	r28, 0x3d	; 61
     776:	de b7       	in	r29, 0x3e	; 62
     778:	64 97       	sbiw	r28, 0x14	; 20
     77a:	0f b6       	in	r0, 0x3f	; 63
     77c:	f8 94       	cli
     77e:	de bf       	out	0x3e, r29	; 62
     780:	0f be       	out	0x3f, r0	; 63
     782:	cd bf       	out	0x3d, r28	; 61
     784:	9f 83       	std	Y+7, r25	; 0x07
     786:	8e 83       	std	Y+6, r24	; 0x06
     788:	79 87       	std	Y+9, r23	; 0x09
     78a:	68 87       	std	Y+8, r22	; 0x08
     78c:	5b 87       	std	Y+11, r21	; 0x0b
     78e:	4a 87       	std	Y+10, r20	; 0x0a
     790:	3d 87       	std	Y+13, r19	; 0x0d
     792:	2c 87       	std	Y+12, r18	; 0x0c
     794:	0e 87       	std	Y+14, r16	; 0x0e
     796:	f8 8a       	std	Y+16, r15	; 0x10
     798:	ef 86       	std	Y+15, r14	; 0x0f
     79a:	da 8a       	std	Y+18, r13	; 0x12
     79c:	c9 8a       	std	Y+17, r12	; 0x11
     79e:	bc 8a       	std	Y+20, r11	; 0x14
     7a0:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
     7a2:	29 89       	ldd	r18, Y+17	; 0x11
     7a4:	3a 89       	ldd	r19, Y+18	; 0x12
     7a6:	8a 85       	ldd	r24, Y+10	; 0x0a
     7a8:	9b 85       	ldd	r25, Y+11	; 0x0b
     7aa:	b9 01       	movw	r22, r18
     7ac:	0e 94 66 0b 	call	0x16cc	; 0x16cc <prvAllocateTCBAndStack>
     7b0:	9b 83       	std	Y+3, r25	; 0x03
     7b2:	8a 83       	std	Y+2, r24	; 0x02

	if( pxNewTCB != NULL )
     7b4:	8a 81       	ldd	r24, Y+2	; 0x02
     7b6:	9b 81       	ldd	r25, Y+3	; 0x03
     7b8:	00 97       	sbiw	r24, 0x00	; 0
     7ba:	09 f4       	brne	.+2      	; 0x7be <xTaskGenericCreate+0x5e>
     7bc:	9f c0       	rjmp	.+318    	; 0x8fc <xTaskGenericCreate+0x19c>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
     7be:	8a 81       	ldd	r24, Y+2	; 0x02
     7c0:	9b 81       	ldd	r25, Y+3	; 0x03
     7c2:	fc 01       	movw	r30, r24
     7c4:	27 89       	ldd	r18, Z+23	; 0x17
     7c6:	30 8d       	ldd	r19, Z+24	; 0x18
     7c8:	8a 85       	ldd	r24, Y+10	; 0x0a
     7ca:	9b 85       	ldd	r25, Y+11	; 0x0b
     7cc:	01 97       	sbiw	r24, 0x01	; 1
     7ce:	82 0f       	add	r24, r18
     7d0:	93 1f       	adc	r25, r19
     7d2:	9d 83       	std	Y+5, r25	; 0x05
     7d4:	8c 83       	std	Y+4, r24	; 0x04
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
     7d6:	4a 85       	ldd	r20, Y+10	; 0x0a
     7d8:	5b 85       	ldd	r21, Y+11	; 0x0b
     7da:	2b 89       	ldd	r18, Y+19	; 0x13
     7dc:	3c 89       	ldd	r19, Y+20	; 0x14
     7de:	68 85       	ldd	r22, Y+8	; 0x08
     7e0:	79 85       	ldd	r23, Y+9	; 0x09
     7e2:	8a 81       	ldd	r24, Y+2	; 0x02
     7e4:	9b 81       	ldd	r25, Y+3	; 0x03
     7e6:	8a 01       	movw	r16, r20
     7e8:	4e 85       	ldd	r20, Y+14	; 0x0e
     7ea:	0e 94 76 0a 	call	0x14ec	; 0x14ec <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     7ee:	4c 85       	ldd	r20, Y+12	; 0x0c
     7f0:	5d 85       	ldd	r21, Y+13	; 0x0d
     7f2:	2e 81       	ldd	r18, Y+6	; 0x06
     7f4:	3f 81       	ldd	r19, Y+7	; 0x07
     7f6:	8c 81       	ldd	r24, Y+4	; 0x04
     7f8:	9d 81       	ldd	r25, Y+5	; 0x05
     7fa:	b9 01       	movw	r22, r18
     7fc:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <pxPortInitialiseStack>
     800:	9c 01       	movw	r18, r24
     802:	8a 81       	ldd	r24, Y+2	; 0x02
     804:	9b 81       	ldd	r25, Y+3	; 0x03
     806:	fc 01       	movw	r30, r24
     808:	31 83       	std	Z+1, r19	; 0x01
     80a:	20 83       	st	Z, r18
		#endif

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
     80c:	8f 85       	ldd	r24, Y+15	; 0x0f
     80e:	98 89       	ldd	r25, Y+16	; 0x10
     810:	00 97       	sbiw	r24, 0x00	; 0
     812:	39 f0       	breq	.+14     	; 0x822 <xTaskGenericCreate+0xc2>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
     814:	8f 85       	ldd	r24, Y+15	; 0x0f
     816:	98 89       	ldd	r25, Y+16	; 0x10
     818:	2a 81       	ldd	r18, Y+2	; 0x02
     81a:	3b 81       	ldd	r19, Y+3	; 0x03
     81c:	fc 01       	movw	r30, r24
     81e:	31 83       	std	Z+1, r19	; 0x01
     820:	20 83       	st	Z, r18
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
     822:	0f b6       	in	r0, 0x3f	; 63
     824:	f8 94       	cli
     826:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
     828:	80 91 7e 02 	lds	r24, 0x027E
     82c:	8f 5f       	subi	r24, 0xFF	; 255
     82e:	80 93 7e 02 	sts	0x027E, r24
			if( pxCurrentTCB == NULL )
     832:	80 91 30 02 	lds	r24, 0x0230
     836:	90 91 31 02 	lds	r25, 0x0231
     83a:	00 97       	sbiw	r24, 0x00	; 0
     83c:	69 f4       	brne	.+26     	; 0x858 <xTaskGenericCreate+0xf8>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
     83e:	8a 81       	ldd	r24, Y+2	; 0x02
     840:	9b 81       	ldd	r25, Y+3	; 0x03
     842:	90 93 31 02 	sts	0x0231, r25
     846:	80 93 30 02 	sts	0x0230, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
     84a:	80 91 7e 02 	lds	r24, 0x027E
     84e:	81 30       	cpi	r24, 0x01	; 1
     850:	b1 f4       	brne	.+44     	; 0x87e <xTaskGenericCreate+0x11e>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
     852:	0e 94 d7 0a 	call	0x15ae	; 0x15ae <prvInitialiseTaskLists>
     856:	13 c0       	rjmp	.+38     	; 0x87e <xTaskGenericCreate+0x11e>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
     858:	80 91 83 02 	lds	r24, 0x0283
     85c:	88 23       	and	r24, r24
     85e:	79 f4       	brne	.+30     	; 0x87e <xTaskGenericCreate+0x11e>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
     860:	80 91 30 02 	lds	r24, 0x0230
     864:	90 91 31 02 	lds	r25, 0x0231
     868:	fc 01       	movw	r30, r24
     86a:	96 89       	ldd	r25, Z+22	; 0x16
     86c:	8e 85       	ldd	r24, Y+14	; 0x0e
     86e:	89 17       	cp	r24, r25
     870:	30 f0       	brcs	.+12     	; 0x87e <xTaskGenericCreate+0x11e>
					{
						pxCurrentTCB = pxNewTCB;
     872:	8a 81       	ldd	r24, Y+2	; 0x02
     874:	9b 81       	ldd	r25, Y+3	; 0x03
     876:	90 93 31 02 	sts	0x0231, r25
     87a:	80 93 30 02 	sts	0x0230, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
     87e:	8a 81       	ldd	r24, Y+2	; 0x02
     880:	9b 81       	ldd	r25, Y+3	; 0x03
     882:	fc 01       	movw	r30, r24
     884:	96 89       	ldd	r25, Z+22	; 0x16
     886:	80 91 81 02 	lds	r24, 0x0281
     88a:	89 17       	cp	r24, r25
     88c:	30 f4       	brcc	.+12     	; 0x89a <xTaskGenericCreate+0x13a>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
     88e:	8a 81       	ldd	r24, Y+2	; 0x02
     890:	9b 81       	ldd	r25, Y+3	; 0x03
     892:	fc 01       	movw	r30, r24
     894:	86 89       	ldd	r24, Z+22	; 0x16
     896:	80 93 81 02 	sts	0x0281, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
     89a:	80 91 88 02 	lds	r24, 0x0288
     89e:	8f 5f       	subi	r24, 0xFF	; 255
     8a0:	80 93 88 02 	sts	0x0288, r24

			prvAddTaskToReadyQueue( pxNewTCB );
     8a4:	8a 81       	ldd	r24, Y+2	; 0x02
     8a6:	9b 81       	ldd	r25, Y+3	; 0x03
     8a8:	fc 01       	movw	r30, r24
     8aa:	96 89       	ldd	r25, Z+22	; 0x16
     8ac:	80 91 82 02 	lds	r24, 0x0282
     8b0:	89 17       	cp	r24, r25
     8b2:	30 f4       	brcc	.+12     	; 0x8c0 <xTaskGenericCreate+0x160>
     8b4:	8a 81       	ldd	r24, Y+2	; 0x02
     8b6:	9b 81       	ldd	r25, Y+3	; 0x03
     8b8:	fc 01       	movw	r30, r24
     8ba:	86 89       	ldd	r24, Z+22	; 0x16
     8bc:	80 93 82 02 	sts	0x0282, r24
     8c0:	8a 81       	ldd	r24, Y+2	; 0x02
     8c2:	9b 81       	ldd	r25, Y+3	; 0x03
     8c4:	ac 01       	movw	r20, r24
     8c6:	4e 5f       	subi	r20, 0xFE	; 254
     8c8:	5f 4f       	sbci	r21, 0xFF	; 255
     8ca:	8a 81       	ldd	r24, Y+2	; 0x02
     8cc:	9b 81       	ldd	r25, Y+3	; 0x03
     8ce:	fc 01       	movw	r30, r24
     8d0:	86 89       	ldd	r24, Z+22	; 0x16
     8d2:	28 2f       	mov	r18, r24
     8d4:	30 e0       	ldi	r19, 0x00	; 0
     8d6:	c9 01       	movw	r24, r18
     8d8:	88 0f       	add	r24, r24
     8da:	99 1f       	adc	r25, r25
     8dc:	88 0f       	add	r24, r24
     8de:	99 1f       	adc	r25, r25
     8e0:	88 0f       	add	r24, r24
     8e2:	99 1f       	adc	r25, r25
     8e4:	82 0f       	add	r24, r18
     8e6:	93 1f       	adc	r25, r19
     8e8:	8e 5c       	subi	r24, 0xCE	; 206
     8ea:	9d 4f       	sbci	r25, 0xFD	; 253
     8ec:	ba 01       	movw	r22, r20
     8ee:	0e 94 00 13 	call	0x2600	; 0x2600 <vListInsertEnd>

			xReturn = pdPASS;
     8f2:	81 e0       	ldi	r24, 0x01	; 1
     8f4:	89 83       	std	Y+1, r24	; 0x01
			portSETUP_TCB( pxNewTCB );
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
     8f6:	0f 90       	pop	r0
     8f8:	0f be       	out	0x3f, r0	; 63
     8fa:	02 c0       	rjmp	.+4      	; 0x900 <xTaskGenericCreate+0x1a0>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     8fc:	8f ef       	ldi	r24, 0xFF	; 255
     8fe:	89 83       	std	Y+1, r24	; 0x01
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
     900:	89 81       	ldd	r24, Y+1	; 0x01
     902:	81 30       	cpi	r24, 0x01	; 1
     904:	79 f4       	brne	.+30     	; 0x924 <xTaskGenericCreate+0x1c4>
	{
		if( xSchedulerRunning != pdFALSE )
     906:	80 91 83 02 	lds	r24, 0x0283
     90a:	88 23       	and	r24, r24
     90c:	59 f0       	breq	.+22     	; 0x924 <xTaskGenericCreate+0x1c4>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
     90e:	80 91 30 02 	lds	r24, 0x0230
     912:	90 91 31 02 	lds	r25, 0x0231
     916:	fc 01       	movw	r30, r24
     918:	96 89       	ldd	r25, Z+22	; 0x16
     91a:	8e 85       	ldd	r24, Y+14	; 0x0e
     91c:	98 17       	cp	r25, r24
     91e:	10 f4       	brcc	.+4      	; 0x924 <xTaskGenericCreate+0x1c4>
			{
				portYIELD_WITHIN_API();
     920:	0e 94 92 19 	call	0x3324	; 0x3324 <vPortYield>
			}
		}
	}

	return xReturn;
     924:	89 81       	ldd	r24, Y+1	; 0x01
}
     926:	64 96       	adiw	r28, 0x14	; 20
     928:	0f b6       	in	r0, 0x3f	; 63
     92a:	f8 94       	cli
     92c:	de bf       	out	0x3e, r29	; 62
     92e:	0f be       	out	0x3f, r0	; 63
     930:	cd bf       	out	0x3d, r28	; 61
     932:	df 91       	pop	r29
     934:	cf 91       	pop	r28
     936:	1f 91       	pop	r17
     938:	0f 91       	pop	r16
     93a:	ff 90       	pop	r15
     93c:	ef 90       	pop	r14
     93e:	df 90       	pop	r13
     940:	cf 90       	pop	r12
     942:	bf 90       	pop	r11
     944:	af 90       	pop	r10
     946:	08 95       	ret

00000948 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
     948:	cf 93       	push	r28
     94a:	df 93       	push	r29
     94c:	cd b7       	in	r28, 0x3d	; 61
     94e:	de b7       	in	r29, 0x3e	; 62
     950:	28 97       	sbiw	r28, 0x08	; 8
     952:	0f b6       	in	r0, 0x3f	; 63
     954:	f8 94       	cli
     956:	de bf       	out	0x3e, r29	; 62
     958:	0f be       	out	0x3f, r0	; 63
     95a:	cd bf       	out	0x3d, r28	; 61
     95c:	9e 83       	std	Y+6, r25	; 0x06
     95e:	8d 83       	std	Y+5, r24	; 0x05
     960:	78 87       	std	Y+8, r23	; 0x08
     962:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
     964:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
     966:	0e 94 f1 06 	call	0xde2	; 0xde2 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     96a:	8d 81       	ldd	r24, Y+5	; 0x05
     96c:	9e 81       	ldd	r25, Y+6	; 0x06
     96e:	fc 01       	movw	r30, r24
     970:	20 81       	ld	r18, Z
     972:	31 81       	ldd	r19, Z+1	; 0x01
     974:	8f 81       	ldd	r24, Y+7	; 0x07
     976:	98 85       	ldd	r25, Y+8	; 0x08
     978:	82 0f       	add	r24, r18
     97a:	93 1f       	adc	r25, r19
     97c:	9b 83       	std	Y+3, r25	; 0x03
     97e:	8a 83       	std	Y+2, r24	; 0x02

			if( xTickCount < *pxPreviousWakeTime )
     980:	8d 81       	ldd	r24, Y+5	; 0x05
     982:	9e 81       	ldd	r25, Y+6	; 0x06
     984:	fc 01       	movw	r30, r24
     986:	20 81       	ld	r18, Z
     988:	31 81       	ldd	r19, Z+1	; 0x01
     98a:	80 91 7f 02 	lds	r24, 0x027F
     98e:	90 91 80 02 	lds	r25, 0x0280
     992:	82 17       	cp	r24, r18
     994:	93 07       	cpc	r25, r19
     996:	b0 f4       	brcc	.+44     	; 0x9c4 <vTaskDelayUntil+0x7c>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
     998:	8d 81       	ldd	r24, Y+5	; 0x05
     99a:	9e 81       	ldd	r25, Y+6	; 0x06
     99c:	fc 01       	movw	r30, r24
     99e:	20 81       	ld	r18, Z
     9a0:	31 81       	ldd	r19, Z+1	; 0x01
     9a2:	8a 81       	ldd	r24, Y+2	; 0x02
     9a4:	9b 81       	ldd	r25, Y+3	; 0x03
     9a6:	82 17       	cp	r24, r18
     9a8:	93 07       	cpc	r25, r19
     9aa:	08 f5       	brcc	.+66     	; 0x9ee <vTaskDelayUntil+0xa6>
     9ac:	80 91 7f 02 	lds	r24, 0x027F
     9b0:	90 91 80 02 	lds	r25, 0x0280
     9b4:	2a 81       	ldd	r18, Y+2	; 0x02
     9b6:	3b 81       	ldd	r19, Y+3	; 0x03
     9b8:	82 17       	cp	r24, r18
     9ba:	93 07       	cpc	r25, r19
     9bc:	c0 f4       	brcc	.+48     	; 0x9ee <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
     9be:	81 e0       	ldi	r24, 0x01	; 1
     9c0:	89 83       	std	Y+1, r24	; 0x01
     9c2:	15 c0       	rjmp	.+42     	; 0x9ee <vTaskDelayUntil+0xa6>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
     9c4:	8d 81       	ldd	r24, Y+5	; 0x05
     9c6:	9e 81       	ldd	r25, Y+6	; 0x06
     9c8:	fc 01       	movw	r30, r24
     9ca:	20 81       	ld	r18, Z
     9cc:	31 81       	ldd	r19, Z+1	; 0x01
     9ce:	8a 81       	ldd	r24, Y+2	; 0x02
     9d0:	9b 81       	ldd	r25, Y+3	; 0x03
     9d2:	82 17       	cp	r24, r18
     9d4:	93 07       	cpc	r25, r19
     9d6:	48 f0       	brcs	.+18     	; 0x9ea <vTaskDelayUntil+0xa2>
     9d8:	80 91 7f 02 	lds	r24, 0x027F
     9dc:	90 91 80 02 	lds	r25, 0x0280
     9e0:	2a 81       	ldd	r18, Y+2	; 0x02
     9e2:	3b 81       	ldd	r19, Y+3	; 0x03
     9e4:	82 17       	cp	r24, r18
     9e6:	93 07       	cpc	r25, r19
     9e8:	10 f4       	brcc	.+4      	; 0x9ee <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
     9ea:	81 e0       	ldi	r24, 0x01	; 1
     9ec:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     9ee:	8d 81       	ldd	r24, Y+5	; 0x05
     9f0:	9e 81       	ldd	r25, Y+6	; 0x06
     9f2:	2a 81       	ldd	r18, Y+2	; 0x02
     9f4:	3b 81       	ldd	r19, Y+3	; 0x03
     9f6:	fc 01       	movw	r30, r24
     9f8:	31 83       	std	Z+1, r19	; 0x01
     9fa:	20 83       	st	Z, r18

			if( xShouldDelay != pdFALSE )
     9fc:	89 81       	ldd	r24, Y+1	; 0x01
     9fe:	88 23       	and	r24, r24
     a00:	59 f0       	breq	.+22     	; 0xa18 <vTaskDelayUntil+0xd0>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
     a02:	80 91 30 02 	lds	r24, 0x0230
     a06:	90 91 31 02 	lds	r25, 0x0231
     a0a:	02 96       	adiw	r24, 0x02	; 2
     a0c:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <uxListRemove>
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
     a10:	8a 81       	ldd	r24, Y+2	; 0x02
     a12:	9b 81       	ldd	r25, Y+3	; 0x03
     a14:	0e 94 1b 0b 	call	0x1636	; 0x1636 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     a18:	0e 94 fd 06 	call	0xdfa	; 0xdfa <xTaskResumeAll>
     a1c:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     a1e:	8c 81       	ldd	r24, Y+4	; 0x04
     a20:	88 23       	and	r24, r24
     a22:	11 f4       	brne	.+4      	; 0xa28 <vTaskDelayUntil+0xe0>
		{
			portYIELD_WITHIN_API();
     a24:	0e 94 92 19 	call	0x3324	; 0x3324 <vPortYield>
		}
	}
     a28:	28 96       	adiw	r28, 0x08	; 8
     a2a:	0f b6       	in	r0, 0x3f	; 63
     a2c:	f8 94       	cli
     a2e:	de bf       	out	0x3e, r29	; 62
     a30:	0f be       	out	0x3f, r0	; 63
     a32:	cd bf       	out	0x3d, r28	; 61
     a34:	df 91       	pop	r29
     a36:	cf 91       	pop	r28
     a38:	08 95       	ret

00000a3a <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
     a3a:	cf 93       	push	r28
     a3c:	df 93       	push	r29
     a3e:	00 d0       	rcall	.+0      	; 0xa40 <vTaskDelay+0x6>
     a40:	1f 92       	push	r1
     a42:	1f 92       	push	r1
     a44:	cd b7       	in	r28, 0x3d	; 61
     a46:	de b7       	in	r29, 0x3e	; 62
     a48:	9d 83       	std	Y+5, r25	; 0x05
     a4a:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
     a4c:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
     a4e:	8c 81       	ldd	r24, Y+4	; 0x04
     a50:	9d 81       	ldd	r25, Y+5	; 0x05
     a52:	00 97       	sbiw	r24, 0x00	; 0
     a54:	d1 f0       	breq	.+52     	; 0xa8a <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
     a56:	0e 94 f1 06 	call	0xde2	; 0xde2 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
     a5a:	20 91 7f 02 	lds	r18, 0x027F
     a5e:	30 91 80 02 	lds	r19, 0x0280
     a62:	8c 81       	ldd	r24, Y+4	; 0x04
     a64:	9d 81       	ldd	r25, Y+5	; 0x05
     a66:	82 0f       	add	r24, r18
     a68:	93 1f       	adc	r25, r19
     a6a:	9b 83       	std	Y+3, r25	; 0x03
     a6c:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
     a6e:	80 91 30 02 	lds	r24, 0x0230
     a72:	90 91 31 02 	lds	r25, 0x0231
     a76:	02 96       	adiw	r24, 0x02	; 2
     a78:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <uxListRemove>
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
     a7c:	8a 81       	ldd	r24, Y+2	; 0x02
     a7e:	9b 81       	ldd	r25, Y+3	; 0x03
     a80:	0e 94 1b 0b 	call	0x1636	; 0x1636 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     a84:	0e 94 fd 06 	call	0xdfa	; 0xdfa <xTaskResumeAll>
     a88:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     a8a:	89 81       	ldd	r24, Y+1	; 0x01
     a8c:	88 23       	and	r24, r24
     a8e:	11 f4       	brne	.+4      	; 0xa94 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
     a90:	0e 94 92 19 	call	0x3324	; 0x3324 <vPortYield>
		}
	}
     a94:	0f 90       	pop	r0
     a96:	0f 90       	pop	r0
     a98:	0f 90       	pop	r0
     a9a:	0f 90       	pop	r0
     a9c:	0f 90       	pop	r0
     a9e:	df 91       	pop	r29
     aa0:	cf 91       	pop	r28
     aa2:	08 95       	ret

00000aa4 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
     aa4:	cf 93       	push	r28
     aa6:	df 93       	push	r29
     aa8:	00 d0       	rcall	.+0      	; 0xaaa <vTaskSuspend+0x6>
     aaa:	1f 92       	push	r1
     aac:	cd b7       	in	r28, 0x3d	; 61
     aae:	de b7       	in	r29, 0x3e	; 62
     ab0:	9c 83       	std	Y+4, r25	; 0x04
     ab2:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
     ab4:	0f b6       	in	r0, 0x3f	; 63
     ab6:	f8 94       	cli
     ab8:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
     aba:	80 91 30 02 	lds	r24, 0x0230
     abe:	90 91 31 02 	lds	r25, 0x0231
     ac2:	2b 81       	ldd	r18, Y+3	; 0x03
     ac4:	3c 81       	ldd	r19, Y+4	; 0x04
     ac6:	28 17       	cp	r18, r24
     ac8:	39 07       	cpc	r19, r25
     aca:	11 f4       	brne	.+4      	; 0xad0 <vTaskSuspend+0x2c>
			{
				pxTaskToSuspend = NULL;
     acc:	1c 82       	std	Y+4, r1	; 0x04
     ace:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
     ad0:	8b 81       	ldd	r24, Y+3	; 0x03
     ad2:	9c 81       	ldd	r25, Y+4	; 0x04
     ad4:	00 97       	sbiw	r24, 0x00	; 0
     ad6:	29 f4       	brne	.+10     	; 0xae2 <vTaskSuspend+0x3e>
     ad8:	80 91 30 02 	lds	r24, 0x0230
     adc:	90 91 31 02 	lds	r25, 0x0231
     ae0:	02 c0       	rjmp	.+4      	; 0xae6 <vTaskSuspend+0x42>
     ae2:	8b 81       	ldd	r24, Y+3	; 0x03
     ae4:	9c 81       	ldd	r25, Y+4	; 0x04
     ae6:	9a 83       	std	Y+2, r25	; 0x02
     ae8:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
     aea:	89 81       	ldd	r24, Y+1	; 0x01
     aec:	9a 81       	ldd	r25, Y+2	; 0x02
     aee:	02 96       	adiw	r24, 0x02	; 2
     af0:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <uxListRemove>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
			}

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
     af4:	89 81       	ldd	r24, Y+1	; 0x01
     af6:	9a 81       	ldd	r25, Y+2	; 0x02
     af8:	fc 01       	movw	r30, r24
     afa:	84 89       	ldd	r24, Z+20	; 0x14
     afc:	95 89       	ldd	r25, Z+21	; 0x15
     afe:	00 97       	sbiw	r24, 0x00	; 0
     b00:	29 f0       	breq	.+10     	; 0xb0c <vTaskSuspend+0x68>
			{
				uxListRemove( &( pxTCB->xEventListItem ) );
     b02:	89 81       	ldd	r24, Y+1	; 0x01
     b04:	9a 81       	ldd	r25, Y+2	; 0x02
     b06:	0c 96       	adiw	r24, 0x0c	; 12
     b08:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <uxListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
     b0c:	89 81       	ldd	r24, Y+1	; 0x01
     b0e:	9a 81       	ldd	r25, Y+2	; 0x02
     b10:	02 96       	adiw	r24, 0x02	; 2
     b12:	bc 01       	movw	r22, r24
     b14:	85 e7       	ldi	r24, 0x75	; 117
     b16:	92 e0       	ldi	r25, 0x02	; 2
     b18:	0e 94 00 13 	call	0x2600	; 0x2600 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
     b1c:	0f 90       	pop	r0
     b1e:	0f be       	out	0x3f, r0	; 63

		if( ( void * ) pxTaskToSuspend == NULL )
     b20:	8b 81       	ldd	r24, Y+3	; 0x03
     b22:	9c 81       	ldd	r25, Y+4	; 0x04
     b24:	00 97       	sbiw	r24, 0x00	; 0
     b26:	a1 f4       	brne	.+40     	; 0xb50 <vTaskSuspend+0xac>
		{
			if( xSchedulerRunning != pdFALSE )
     b28:	80 91 83 02 	lds	r24, 0x0283
     b2c:	88 23       	and	r24, r24
     b2e:	19 f0       	breq	.+6      	; 0xb36 <vTaskSuspend+0x92>
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
     b30:	0e 94 92 19 	call	0x3324	; 0x3324 <vPortYield>
     b34:	0d c0       	rjmp	.+26     	; 0xb50 <vTaskSuspend+0xac>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
     b36:	90 91 75 02 	lds	r25, 0x0275
     b3a:	80 91 7e 02 	lds	r24, 0x027E
     b3e:	98 17       	cp	r25, r24
     b40:	29 f4       	brne	.+10     	; 0xb4c <vTaskSuspend+0xa8>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
     b42:	10 92 31 02 	sts	0x0231, r1
     b46:	10 92 30 02 	sts	0x0230, r1
     b4a:	02 c0       	rjmp	.+4      	; 0xb50 <vTaskSuspend+0xac>
				}
				else
				{
					vTaskSwitchContext();
     b4c:	0e 94 93 08 	call	0x1126	; 0x1126 <vTaskSwitchContext>
				}
			}
		}
	}
     b50:	0f 90       	pop	r0
     b52:	0f 90       	pop	r0
     b54:	0f 90       	pop	r0
     b56:	0f 90       	pop	r0
     b58:	df 91       	pop	r29
     b5a:	cf 91       	pop	r28
     b5c:	08 95       	ret

00000b5e <xTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
     b5e:	cf 93       	push	r28
     b60:	df 93       	push	r29
     b62:	00 d0       	rcall	.+0      	; 0xb64 <xTaskIsTaskSuspended+0x6>
     b64:	1f 92       	push	r1
     b66:	1f 92       	push	r1
     b68:	cd b7       	in	r28, 0x3d	; 61
     b6a:	de b7       	in	r29, 0x3e	; 62
     b6c:	9d 83       	std	Y+5, r25	; 0x05
     b6e:	8c 83       	std	Y+4, r24	; 0x04
	portBASE_TYPE xReturn = pdFALSE;
     b70:	19 82       	std	Y+1, r1	; 0x01
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
     b72:	8c 81       	ldd	r24, Y+4	; 0x04
     b74:	9d 81       	ldd	r25, Y+5	; 0x05
     b76:	9b 83       	std	Y+3, r25	; 0x03
     b78:	8a 83       	std	Y+2, r24	; 0x02
		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
     b7a:	8a 81       	ldd	r24, Y+2	; 0x02
     b7c:	9b 81       	ldd	r25, Y+3	; 0x03
     b7e:	fc 01       	movw	r30, r24
     b80:	82 85       	ldd	r24, Z+10	; 0x0a
     b82:	93 85       	ldd	r25, Z+11	; 0x0b
     b84:	f2 e0       	ldi	r31, 0x02	; 2
     b86:	85 37       	cpi	r24, 0x75	; 117
     b88:	9f 07       	cpc	r25, r31
     b8a:	91 f4       	brne	.+36     	; 0xbb0 <xTaskIsTaskSuspended+0x52>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
     b8c:	8a 81       	ldd	r24, Y+2	; 0x02
     b8e:	9b 81       	ldd	r25, Y+3	; 0x03
     b90:	fc 01       	movw	r30, r24
     b92:	84 89       	ldd	r24, Z+20	; 0x14
     b94:	95 89       	ldd	r25, Z+21	; 0x15
     b96:	f2 e0       	ldi	r31, 0x02	; 2
     b98:	8c 36       	cpi	r24, 0x6C	; 108
     b9a:	9f 07       	cpc	r25, r31
     b9c:	49 f0       	breq	.+18     	; 0xbb0 <xTaskIsTaskSuspended+0x52>
			{
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
     b9e:	8a 81       	ldd	r24, Y+2	; 0x02
     ba0:	9b 81       	ldd	r25, Y+3	; 0x03
     ba2:	fc 01       	movw	r30, r24
     ba4:	84 89       	ldd	r24, Z+20	; 0x14
     ba6:	95 89       	ldd	r25, Z+21	; 0x15
     ba8:	00 97       	sbiw	r24, 0x00	; 0
     baa:	11 f4       	brne	.+4      	; 0xbb0 <xTaskIsTaskSuspended+0x52>
				{
					xReturn = pdTRUE;
     bac:	81 e0       	ldi	r24, 0x01	; 1
     bae:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}

		return xReturn;
     bb0:	89 81       	ldd	r24, Y+1	; 0x01
	}
     bb2:	0f 90       	pop	r0
     bb4:	0f 90       	pop	r0
     bb6:	0f 90       	pop	r0
     bb8:	0f 90       	pop	r0
     bba:	0f 90       	pop	r0
     bbc:	df 91       	pop	r29
     bbe:	cf 91       	pop	r28
     bc0:	08 95       	ret

00000bc2 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
     bc2:	cf 93       	push	r28
     bc4:	df 93       	push	r29
     bc6:	00 d0       	rcall	.+0      	; 0xbc8 <vTaskResume+0x6>
     bc8:	1f 92       	push	r1
     bca:	cd b7       	in	r28, 0x3d	; 61
     bcc:	de b7       	in	r29, 0x3e	; 62
     bce:	9c 83       	std	Y+4, r25	; 0x04
     bd0:	8b 83       	std	Y+3, r24	; 0x03
		/* It does not make sense to resume the calling task. */
		configASSERT( pxTaskToResume );

		/* Remove the task from whichever list it is currently in, and place
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;
     bd2:	8b 81       	ldd	r24, Y+3	; 0x03
     bd4:	9c 81       	ldd	r25, Y+4	; 0x04
     bd6:	9a 83       	std	Y+2, r25	; 0x02
     bd8:	89 83       	std	Y+1, r24	; 0x01

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
     bda:	89 81       	ldd	r24, Y+1	; 0x01
     bdc:	9a 81       	ldd	r25, Y+2	; 0x02
     bde:	00 97       	sbiw	r24, 0x00	; 0
     be0:	09 f4       	brne	.+2      	; 0xbe4 <vTaskResume+0x22>
     be2:	4f c0       	rjmp	.+158    	; 0xc82 <vTaskResume+0xc0>
     be4:	80 91 30 02 	lds	r24, 0x0230
     be8:	90 91 31 02 	lds	r25, 0x0231
     bec:	29 81       	ldd	r18, Y+1	; 0x01
     bee:	3a 81       	ldd	r19, Y+2	; 0x02
     bf0:	28 17       	cp	r18, r24
     bf2:	39 07       	cpc	r19, r25
     bf4:	09 f4       	brne	.+2      	; 0xbf8 <vTaskResume+0x36>
     bf6:	45 c0       	rjmp	.+138    	; 0xc82 <vTaskResume+0xc0>
		{
			taskENTER_CRITICAL();
     bf8:	0f b6       	in	r0, 0x3f	; 63
     bfa:	f8 94       	cli
     bfc:	0f 92       	push	r0
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
     bfe:	89 81       	ldd	r24, Y+1	; 0x01
     c00:	9a 81       	ldd	r25, Y+2	; 0x02
     c02:	0e 94 af 05 	call	0xb5e	; 0xb5e <xTaskIsTaskSuspended>
     c06:	81 30       	cpi	r24, 0x01	; 1
     c08:	d1 f5       	brne	.+116    	; 0xc7e <vTaskResume+0xbc>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					uxListRemove(  &( pxTCB->xGenericListItem ) );
     c0a:	89 81       	ldd	r24, Y+1	; 0x01
     c0c:	9a 81       	ldd	r25, Y+2	; 0x02
     c0e:	02 96       	adiw	r24, 0x02	; 2
     c10:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
     c14:	89 81       	ldd	r24, Y+1	; 0x01
     c16:	9a 81       	ldd	r25, Y+2	; 0x02
     c18:	fc 01       	movw	r30, r24
     c1a:	96 89       	ldd	r25, Z+22	; 0x16
     c1c:	80 91 82 02 	lds	r24, 0x0282
     c20:	89 17       	cp	r24, r25
     c22:	30 f4       	brcc	.+12     	; 0xc30 <vTaskResume+0x6e>
     c24:	89 81       	ldd	r24, Y+1	; 0x01
     c26:	9a 81       	ldd	r25, Y+2	; 0x02
     c28:	fc 01       	movw	r30, r24
     c2a:	86 89       	ldd	r24, Z+22	; 0x16
     c2c:	80 93 82 02 	sts	0x0282, r24
     c30:	89 81       	ldd	r24, Y+1	; 0x01
     c32:	9a 81       	ldd	r25, Y+2	; 0x02
     c34:	ac 01       	movw	r20, r24
     c36:	4e 5f       	subi	r20, 0xFE	; 254
     c38:	5f 4f       	sbci	r21, 0xFF	; 255
     c3a:	89 81       	ldd	r24, Y+1	; 0x01
     c3c:	9a 81       	ldd	r25, Y+2	; 0x02
     c3e:	fc 01       	movw	r30, r24
     c40:	86 89       	ldd	r24, Z+22	; 0x16
     c42:	28 2f       	mov	r18, r24
     c44:	30 e0       	ldi	r19, 0x00	; 0
     c46:	c9 01       	movw	r24, r18
     c48:	88 0f       	add	r24, r24
     c4a:	99 1f       	adc	r25, r25
     c4c:	88 0f       	add	r24, r24
     c4e:	99 1f       	adc	r25, r25
     c50:	88 0f       	add	r24, r24
     c52:	99 1f       	adc	r25, r25
     c54:	82 0f       	add	r24, r18
     c56:	93 1f       	adc	r25, r19
     c58:	8e 5c       	subi	r24, 0xCE	; 206
     c5a:	9d 4f       	sbci	r25, 0xFD	; 253
     c5c:	ba 01       	movw	r22, r20
     c5e:	0e 94 00 13 	call	0x2600	; 0x2600 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     c62:	89 81       	ldd	r24, Y+1	; 0x01
     c64:	9a 81       	ldd	r25, Y+2	; 0x02
     c66:	fc 01       	movw	r30, r24
     c68:	26 89       	ldd	r18, Z+22	; 0x16
     c6a:	80 91 30 02 	lds	r24, 0x0230
     c6e:	90 91 31 02 	lds	r25, 0x0231
     c72:	fc 01       	movw	r30, r24
     c74:	86 89       	ldd	r24, Z+22	; 0x16
     c76:	28 17       	cp	r18, r24
     c78:	10 f0       	brcs	.+4      	; 0xc7e <vTaskResume+0xbc>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
     c7a:	0e 94 92 19 	call	0x3324	; 0x3324 <vPortYield>
					}
				}
			}
			taskEXIT_CRITICAL();
     c7e:	0f 90       	pop	r0
     c80:	0f be       	out	0x3f, r0	; 63
		}
	}
     c82:	0f 90       	pop	r0
     c84:	0f 90       	pop	r0
     c86:	0f 90       	pop	r0
     c88:	0f 90       	pop	r0
     c8a:	df 91       	pop	r29
     c8c:	cf 91       	pop	r28
     c8e:	08 95       	ret

00000c90 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
     c90:	cf 93       	push	r28
     c92:	df 93       	push	r29
     c94:	00 d0       	rcall	.+0      	; 0xc96 <xTaskResumeFromISR+0x6>
     c96:	00 d0       	rcall	.+0      	; 0xc98 <xTaskResumeFromISR+0x8>
     c98:	cd b7       	in	r28, 0x3d	; 61
     c9a:	de b7       	in	r29, 0x3e	; 62
     c9c:	9e 83       	std	Y+6, r25	; 0x06
     c9e:	8d 83       	std	Y+5, r24	; 0x05
	portBASE_TYPE xYieldRequired = pdFALSE;
     ca0:	19 82       	std	Y+1, r1	; 0x01
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxSavedInterruptStatus;

		configASSERT( pxTaskToResume );

		pxTCB = ( tskTCB * ) pxTaskToResume;
     ca2:	8d 81       	ldd	r24, Y+5	; 0x05
     ca4:	9e 81       	ldd	r25, Y+6	; 0x06
     ca6:	9b 83       	std	Y+3, r25	; 0x03
     ca8:	8a 83       	std	Y+2, r24	; 0x02

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     caa:	1c 82       	std	Y+4, r1	; 0x04
		{
			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
     cac:	8a 81       	ldd	r24, Y+2	; 0x02
     cae:	9b 81       	ldd	r25, Y+3	; 0x03
     cb0:	0e 94 af 05 	call	0xb5e	; 0xb5e <xTaskIsTaskSuspended>
     cb4:	81 30       	cpi	r24, 0x01	; 1
     cb6:	09 f0       	breq	.+2      	; 0xcba <xTaskResumeFromISR+0x2a>
     cb8:	48 c0       	rjmp	.+144    	; 0xd4a <xTaskResumeFromISR+0xba>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     cba:	80 91 84 02 	lds	r24, 0x0284
     cbe:	88 23       	and	r24, r24
     cc0:	e1 f5       	brne	.+120    	; 0xd3a <xTaskResumeFromISR+0xaa>
				{
					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
     cc2:	8a 81       	ldd	r24, Y+2	; 0x02
     cc4:	9b 81       	ldd	r25, Y+3	; 0x03
     cc6:	fc 01       	movw	r30, r24
     cc8:	26 89       	ldd	r18, Z+22	; 0x16
     cca:	80 91 30 02 	lds	r24, 0x0230
     cce:	90 91 31 02 	lds	r25, 0x0231
     cd2:	fc 01       	movw	r30, r24
     cd4:	96 89       	ldd	r25, Z+22	; 0x16
     cd6:	81 e0       	ldi	r24, 0x01	; 1
     cd8:	29 17       	cp	r18, r25
     cda:	08 f4       	brcc	.+2      	; 0xcde <xTaskResumeFromISR+0x4e>
     cdc:	80 e0       	ldi	r24, 0x00	; 0
     cde:	89 83       	std	Y+1, r24	; 0x01
					uxListRemove(  &( pxTCB->xGenericListItem ) );
     ce0:	8a 81       	ldd	r24, Y+2	; 0x02
     ce2:	9b 81       	ldd	r25, Y+3	; 0x03
     ce4:	02 96       	adiw	r24, 0x02	; 2
     ce6:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
     cea:	8a 81       	ldd	r24, Y+2	; 0x02
     cec:	9b 81       	ldd	r25, Y+3	; 0x03
     cee:	fc 01       	movw	r30, r24
     cf0:	96 89       	ldd	r25, Z+22	; 0x16
     cf2:	80 91 82 02 	lds	r24, 0x0282
     cf6:	89 17       	cp	r24, r25
     cf8:	30 f4       	brcc	.+12     	; 0xd06 <xTaskResumeFromISR+0x76>
     cfa:	8a 81       	ldd	r24, Y+2	; 0x02
     cfc:	9b 81       	ldd	r25, Y+3	; 0x03
     cfe:	fc 01       	movw	r30, r24
     d00:	86 89       	ldd	r24, Z+22	; 0x16
     d02:	80 93 82 02 	sts	0x0282, r24
     d06:	8a 81       	ldd	r24, Y+2	; 0x02
     d08:	9b 81       	ldd	r25, Y+3	; 0x03
     d0a:	ac 01       	movw	r20, r24
     d0c:	4e 5f       	subi	r20, 0xFE	; 254
     d0e:	5f 4f       	sbci	r21, 0xFF	; 255
     d10:	8a 81       	ldd	r24, Y+2	; 0x02
     d12:	9b 81       	ldd	r25, Y+3	; 0x03
     d14:	fc 01       	movw	r30, r24
     d16:	86 89       	ldd	r24, Z+22	; 0x16
     d18:	28 2f       	mov	r18, r24
     d1a:	30 e0       	ldi	r19, 0x00	; 0
     d1c:	c9 01       	movw	r24, r18
     d1e:	88 0f       	add	r24, r24
     d20:	99 1f       	adc	r25, r25
     d22:	88 0f       	add	r24, r24
     d24:	99 1f       	adc	r25, r25
     d26:	88 0f       	add	r24, r24
     d28:	99 1f       	adc	r25, r25
     d2a:	82 0f       	add	r24, r18
     d2c:	93 1f       	adc	r25, r19
     d2e:	8e 5c       	subi	r24, 0xCE	; 206
     d30:	9d 4f       	sbci	r25, 0xFD	; 253
     d32:	ba 01       	movw	r22, r20
     d34:	0e 94 00 13 	call	0x2600	; 0x2600 <vListInsertEnd>
     d38:	08 c0       	rjmp	.+16     	; 0xd4a <xTaskResumeFromISR+0xba>
				else
				{
					/* We cannot access the delayed or ready lists, so will hold this
					task pending until the scheduler is resumed, at which point a
					yield will be performed if necessary. */
					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
     d3a:	8a 81       	ldd	r24, Y+2	; 0x02
     d3c:	9b 81       	ldd	r25, Y+3	; 0x03
     d3e:	0c 96       	adiw	r24, 0x0c	; 12
     d40:	bc 01       	movw	r22, r24
     d42:	8c e6       	ldi	r24, 0x6C	; 108
     d44:	92 e0       	ldi	r25, 0x02	; 2
     d46:	0e 94 00 13 	call	0x2600	; 0x2600 <vListInsertEnd>
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
     d4a:	89 81       	ldd	r24, Y+1	; 0x01
	}
     d4c:	26 96       	adiw	r28, 0x06	; 6
     d4e:	0f b6       	in	r0, 0x3f	; 63
     d50:	f8 94       	cli
     d52:	de bf       	out	0x3e, r29	; 62
     d54:	0f be       	out	0x3f, r0	; 63
     d56:	cd bf       	out	0x3d, r28	; 61
     d58:	df 91       	pop	r29
     d5a:	cf 91       	pop	r28
     d5c:	08 95       	ret

00000d5e <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
     d5e:	af 92       	push	r10
     d60:	bf 92       	push	r11
     d62:	cf 92       	push	r12
     d64:	df 92       	push	r13
     d66:	ef 92       	push	r14
     d68:	ff 92       	push	r15
     d6a:	0f 93       	push	r16
     d6c:	cf 93       	push	r28
     d6e:	df 93       	push	r29
     d70:	1f 92       	push	r1
     d72:	cd b7       	in	r28, 0x3d	; 61
     d74:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
     d76:	a1 2c       	mov	r10, r1
     d78:	b1 2c       	mov	r11, r1
     d7a:	c1 2c       	mov	r12, r1
     d7c:	d1 2c       	mov	r13, r1
     d7e:	e1 2c       	mov	r14, r1
     d80:	f1 2c       	mov	r15, r1
     d82:	00 e0       	ldi	r16, 0x00	; 0
     d84:	20 e0       	ldi	r18, 0x00	; 0
     d86:	30 e0       	ldi	r19, 0x00	; 0
     d88:	45 e5       	ldi	r20, 0x55	; 85
     d8a:	50 e0       	ldi	r21, 0x00	; 0
     d8c:	6f e1       	ldi	r22, 0x1F	; 31
     d8e:	72 e0       	ldi	r23, 0x02	; 2
     d90:	84 e6       	ldi	r24, 0x64	; 100
     d92:	9a e0       	ldi	r25, 0x0A	; 10
     d94:	0e 94 b0 03 	call	0x760	; 0x760 <xTaskGenericCreate>
     d98:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
     d9a:	89 81       	ldd	r24, Y+1	; 0x01
     d9c:	81 30       	cpi	r24, 0x01	; 1
     d9e:	51 f4       	brne	.+20     	; 0xdb4 <vTaskStartScheduler+0x56>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
     da0:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
     da2:	81 e0       	ldi	r24, 0x01	; 1
     da4:	80 93 83 02 	sts	0x0283, r24
		xTickCount = ( portTickType ) 0U;
     da8:	10 92 80 02 	sts	0x0280, r1
     dac:	10 92 7f 02 	sts	0x027F, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     db0:	0e 94 52 19 	call	0x32a4	; 0x32a4 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
     db4:	0f 90       	pop	r0
     db6:	df 91       	pop	r29
     db8:	cf 91       	pop	r28
     dba:	0f 91       	pop	r16
     dbc:	ff 90       	pop	r15
     dbe:	ef 90       	pop	r14
     dc0:	df 90       	pop	r13
     dc2:	cf 90       	pop	r12
     dc4:	bf 90       	pop	r11
     dc6:	af 90       	pop	r10
     dc8:	08 95       	ret

00000dca <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
     dca:	cf 93       	push	r28
     dcc:	df 93       	push	r29
     dce:	cd b7       	in	r28, 0x3d	; 61
     dd0:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
     dd2:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
     dd4:	10 92 83 02 	sts	0x0283, r1
	vPortEndScheduler();
     dd8:	0e 94 8b 19 	call	0x3316	; 0x3316 <vPortEndScheduler>
}
     ddc:	df 91       	pop	r29
     dde:	cf 91       	pop	r28
     de0:	08 95       	ret

00000de2 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
     de2:	cf 93       	push	r28
     de4:	df 93       	push	r29
     de6:	cd b7       	in	r28, 0x3d	; 61
     de8:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
     dea:	80 91 84 02 	lds	r24, 0x0284
     dee:	8f 5f       	subi	r24, 0xFF	; 255
     df0:	80 93 84 02 	sts	0x0284, r24
}
     df4:	df 91       	pop	r29
     df6:	cf 91       	pop	r28
     df8:	08 95       	ret

00000dfa <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE != 0  */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
     dfa:	0f 93       	push	r16
     dfc:	1f 93       	push	r17
     dfe:	cf 93       	push	r28
     e00:	df 93       	push	r29
     e02:	1f 92       	push	r1
     e04:	1f 92       	push	r1
     e06:	cd b7       	in	r28, 0x3d	; 61
     e08:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
     e0a:	19 82       	std	Y+1, r1	; 0x01
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     e0c:	0f b6       	in	r0, 0x3f	; 63
     e0e:	f8 94       	cli
     e10:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     e12:	80 91 84 02 	lds	r24, 0x0284
     e16:	81 50       	subi	r24, 0x01	; 1
     e18:	80 93 84 02 	sts	0x0284, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     e1c:	80 91 84 02 	lds	r24, 0x0284
     e20:	88 23       	and	r24, r24
     e22:	09 f0       	breq	.+2      	; 0xe26 <xTaskResumeAll+0x2c>
     e24:	64 c0       	rjmp	.+200    	; 0xeee <xTaskResumeAll+0xf4>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
     e26:	80 91 7e 02 	lds	r24, 0x027E
     e2a:	88 23       	and	r24, r24
     e2c:	09 f4       	brne	.+2      	; 0xe30 <xTaskResumeAll+0x36>
     e2e:	5f c0       	rjmp	.+190    	; 0xeee <xTaskResumeAll+0xf4>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
     e30:	1a 82       	std	Y+2, r1	; 0x02

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
     e32:	3a c0       	rjmp	.+116    	; 0xea8 <xTaskResumeAll+0xae>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
     e34:	80 91 71 02 	lds	r24, 0x0271
     e38:	90 91 72 02 	lds	r25, 0x0272
     e3c:	fc 01       	movw	r30, r24
     e3e:	06 81       	ldd	r16, Z+6	; 0x06
     e40:	17 81       	ldd	r17, Z+7	; 0x07
					uxListRemove( &( pxTCB->xEventListItem ) );
     e42:	c8 01       	movw	r24, r16
     e44:	0c 96       	adiw	r24, 0x0c	; 12
     e46:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <uxListRemove>
					uxListRemove( &( pxTCB->xGenericListItem ) );
     e4a:	c8 01       	movw	r24, r16
     e4c:	02 96       	adiw	r24, 0x02	; 2
     e4e:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
     e52:	f8 01       	movw	r30, r16
     e54:	96 89       	ldd	r25, Z+22	; 0x16
     e56:	80 91 82 02 	lds	r24, 0x0282
     e5a:	89 17       	cp	r24, r25
     e5c:	20 f4       	brcc	.+8      	; 0xe66 <xTaskResumeAll+0x6c>
     e5e:	f8 01       	movw	r30, r16
     e60:	86 89       	ldd	r24, Z+22	; 0x16
     e62:	80 93 82 02 	sts	0x0282, r24
     e66:	a8 01       	movw	r20, r16
     e68:	4e 5f       	subi	r20, 0xFE	; 254
     e6a:	5f 4f       	sbci	r21, 0xFF	; 255
     e6c:	f8 01       	movw	r30, r16
     e6e:	86 89       	ldd	r24, Z+22	; 0x16
     e70:	28 2f       	mov	r18, r24
     e72:	30 e0       	ldi	r19, 0x00	; 0
     e74:	c9 01       	movw	r24, r18
     e76:	88 0f       	add	r24, r24
     e78:	99 1f       	adc	r25, r25
     e7a:	88 0f       	add	r24, r24
     e7c:	99 1f       	adc	r25, r25
     e7e:	88 0f       	add	r24, r24
     e80:	99 1f       	adc	r25, r25
     e82:	82 0f       	add	r24, r18
     e84:	93 1f       	adc	r25, r19
     e86:	8e 5c       	subi	r24, 0xCE	; 206
     e88:	9d 4f       	sbci	r25, 0xFD	; 253
     e8a:	ba 01       	movw	r22, r20
     e8c:	0e 94 00 13 	call	0x2600	; 0x2600 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     e90:	f8 01       	movw	r30, r16
     e92:	26 89       	ldd	r18, Z+22	; 0x16
     e94:	80 91 30 02 	lds	r24, 0x0230
     e98:	90 91 31 02 	lds	r25, 0x0231
     e9c:	fc 01       	movw	r30, r24
     e9e:	86 89       	ldd	r24, Z+22	; 0x16
     ea0:	28 17       	cp	r18, r24
     ea2:	10 f0       	brcs	.+4      	; 0xea8 <xTaskResumeAll+0xae>
					{
						xYieldRequired = pdTRUE;
     ea4:	81 e0       	ldi	r24, 0x01	; 1
     ea6:	8a 83       	std	Y+2, r24	; 0x02
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
     ea8:	80 91 6c 02 	lds	r24, 0x026C
     eac:	88 23       	and	r24, r24
     eae:	11 f6       	brne	.-124    	; 0xe34 <xTaskResumeAll+0x3a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
     eb0:	80 91 85 02 	lds	r24, 0x0285
     eb4:	88 23       	and	r24, r24
     eb6:	71 f0       	breq	.+28     	; 0xed4 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
     eb8:	07 c0       	rjmp	.+14     	; 0xec8 <xTaskResumeAll+0xce>
					{
						vTaskIncrementTick();
     eba:	0e 94 b6 07 	call	0xf6c	; 0xf6c <vTaskIncrementTick>
						--uxMissedTicks;
     ebe:	80 91 85 02 	lds	r24, 0x0285
     ec2:	81 50       	subi	r24, 0x01	; 1
     ec4:	80 93 85 02 	sts	0x0285, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
     ec8:	80 91 85 02 	lds	r24, 0x0285
     ecc:	88 23       	and	r24, r24
     ece:	a9 f7       	brne	.-22     	; 0xeba <xTaskResumeAll+0xc0>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
     ed0:	81 e0       	ldi	r24, 0x01	; 1
     ed2:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
     ed4:	8a 81       	ldd	r24, Y+2	; 0x02
     ed6:	81 30       	cpi	r24, 0x01	; 1
     ed8:	21 f0       	breq	.+8      	; 0xee2 <xTaskResumeAll+0xe8>
     eda:	80 91 86 02 	lds	r24, 0x0286
     ede:	81 30       	cpi	r24, 0x01	; 1
     ee0:	31 f4       	brne	.+12     	; 0xeee <xTaskResumeAll+0xf4>
				{
					xAlreadyYielded = pdTRUE;
     ee2:	81 e0       	ldi	r24, 0x01	; 1
     ee4:	89 83       	std	Y+1, r24	; 0x01
					xMissedYield = pdFALSE;
     ee6:	10 92 86 02 	sts	0x0286, r1
					portYIELD_WITHIN_API();
     eea:	0e 94 92 19 	call	0x3324	; 0x3324 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
     eee:	0f 90       	pop	r0
     ef0:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
     ef2:	89 81       	ldd	r24, Y+1	; 0x01
}
     ef4:	0f 90       	pop	r0
     ef6:	0f 90       	pop	r0
     ef8:	df 91       	pop	r29
     efa:	cf 91       	pop	r28
     efc:	1f 91       	pop	r17
     efe:	0f 91       	pop	r16
     f00:	08 95       	ret

00000f02 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
     f02:	cf 93       	push	r28
     f04:	df 93       	push	r29
     f06:	1f 92       	push	r1
     f08:	1f 92       	push	r1
     f0a:	cd b7       	in	r28, 0x3d	; 61
     f0c:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
     f0e:	0f b6       	in	r0, 0x3f	; 63
     f10:	f8 94       	cli
     f12:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     f14:	80 91 7f 02 	lds	r24, 0x027F
     f18:	90 91 80 02 	lds	r25, 0x0280
     f1c:	9a 83       	std	Y+2, r25	; 0x02
     f1e:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
     f20:	0f 90       	pop	r0
     f22:	0f be       	out	0x3f, r0	; 63

	return xTicks;
     f24:	89 81       	ldd	r24, Y+1	; 0x01
     f26:	9a 81       	ldd	r25, Y+2	; 0x02
}
     f28:	0f 90       	pop	r0
     f2a:	0f 90       	pop	r0
     f2c:	df 91       	pop	r29
     f2e:	cf 91       	pop	r28
     f30:	08 95       	ret

00000f32 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
     f32:	cf 93       	push	r28
     f34:	df 93       	push	r29
     f36:	00 d0       	rcall	.+0      	; 0xf38 <xTaskGetTickCountFromISR+0x6>
     f38:	cd b7       	in	r28, 0x3d	; 61
     f3a:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     f3c:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
     f3e:	80 91 7f 02 	lds	r24, 0x027F
     f42:	90 91 80 02 	lds	r25, 0x0280
     f46:	9b 83       	std	Y+3, r25	; 0x03
     f48:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
     f4a:	8a 81       	ldd	r24, Y+2	; 0x02
     f4c:	9b 81       	ldd	r25, Y+3	; 0x03
}
     f4e:	0f 90       	pop	r0
     f50:	0f 90       	pop	r0
     f52:	0f 90       	pop	r0
     f54:	df 91       	pop	r29
     f56:	cf 91       	pop	r28
     f58:	08 95       	ret

00000f5a <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
     f5a:	cf 93       	push	r28
     f5c:	df 93       	push	r29
     f5e:	cd b7       	in	r28, 0x3d	; 61
     f60:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
     f62:	80 91 7e 02 	lds	r24, 0x027E
}
     f66:	df 91       	pop	r29
     f68:	cf 91       	pop	r28
     f6a:	08 95       	ret

00000f6c <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
     f6c:	cf 93       	push	r28
     f6e:	df 93       	push	r29
     f70:	00 d0       	rcall	.+0      	; 0xf72 <vTaskIncrementTick+0x6>
     f72:	00 d0       	rcall	.+0      	; 0xf74 <vTaskIncrementTick+0x8>
     f74:	cd b7       	in	r28, 0x3d	; 61
     f76:	de b7       	in	r29, 0x3e	; 62

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     f78:	80 91 84 02 	lds	r24, 0x0284
     f7c:	88 23       	and	r24, r24
     f7e:	09 f0       	breq	.+2      	; 0xf82 <vTaskIncrementTick+0x16>
     f80:	c4 c0       	rjmp	.+392    	; 0x110a <vTaskIncrementTick+0x19e>
	{
		++xTickCount;
     f82:	80 91 7f 02 	lds	r24, 0x027F
     f86:	90 91 80 02 	lds	r25, 0x0280
     f8a:	01 96       	adiw	r24, 0x01	; 1
     f8c:	90 93 80 02 	sts	0x0280, r25
     f90:	80 93 7f 02 	sts	0x027F, r24
		if( xTickCount == ( portTickType ) 0U )
     f94:	80 91 7f 02 	lds	r24, 0x027F
     f98:	90 91 80 02 	lds	r25, 0x0280
     f9c:	00 97       	sbiw	r24, 0x00	; 0
     f9e:	e9 f5       	brne	.+122    	; 0x101a <vTaskIncrementTick+0xae>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
     fa0:	80 91 68 02 	lds	r24, 0x0268
     fa4:	90 91 69 02 	lds	r25, 0x0269
     fa8:	9a 83       	std	Y+2, r25	; 0x02
     faa:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedTaskList = pxOverflowDelayedTaskList;
     fac:	80 91 6a 02 	lds	r24, 0x026A
     fb0:	90 91 6b 02 	lds	r25, 0x026B
     fb4:	90 93 69 02 	sts	0x0269, r25
     fb8:	80 93 68 02 	sts	0x0268, r24
			pxOverflowDelayedTaskList = pxTemp;
     fbc:	89 81       	ldd	r24, Y+1	; 0x01
     fbe:	9a 81       	ldd	r25, Y+2	; 0x02
     fc0:	90 93 6b 02 	sts	0x026B, r25
     fc4:	80 93 6a 02 	sts	0x026A, r24
			xNumOfOverflows++;
     fc8:	80 91 87 02 	lds	r24, 0x0287
     fcc:	8f 5f       	subi	r24, 0xFF	; 255
     fce:	80 93 87 02 	sts	0x0287, r24

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     fd2:	80 91 68 02 	lds	r24, 0x0268
     fd6:	90 91 69 02 	lds	r25, 0x0269
     fda:	fc 01       	movw	r30, r24
     fdc:	80 81       	ld	r24, Z
     fde:	88 23       	and	r24, r24
     fe0:	39 f4       	brne	.+14     	; 0xff0 <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
     fe2:	8f ef       	ldi	r24, 0xFF	; 255
     fe4:	9f ef       	ldi	r25, 0xFF	; 255
     fe6:	90 93 01 02 	sts	0x0201, r25
     fea:	80 93 00 02 	sts	0x0200, r24
     fee:	15 c0       	rjmp	.+42     	; 0x101a <vTaskIncrementTick+0xae>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     ff0:	80 91 68 02 	lds	r24, 0x0268
     ff4:	90 91 69 02 	lds	r25, 0x0269
     ff8:	fc 01       	movw	r30, r24
     ffa:	85 81       	ldd	r24, Z+5	; 0x05
     ffc:	96 81       	ldd	r25, Z+6	; 0x06
     ffe:	fc 01       	movw	r30, r24
    1000:	86 81       	ldd	r24, Z+6	; 0x06
    1002:	97 81       	ldd	r25, Z+7	; 0x07
    1004:	9c 83       	std	Y+4, r25	; 0x04
    1006:	8b 83       	std	Y+3, r24	; 0x03
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    1008:	8b 81       	ldd	r24, Y+3	; 0x03
    100a:	9c 81       	ldd	r25, Y+4	; 0x04
    100c:	fc 01       	movw	r30, r24
    100e:	82 81       	ldd	r24, Z+2	; 0x02
    1010:	93 81       	ldd	r25, Z+3	; 0x03
    1012:	90 93 01 02 	sts	0x0201, r25
    1016:	80 93 00 02 	sts	0x0200, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    101a:	20 91 7f 02 	lds	r18, 0x027F
    101e:	30 91 80 02 	lds	r19, 0x0280
    1022:	80 91 00 02 	lds	r24, 0x0200
    1026:	90 91 01 02 	lds	r25, 0x0201
    102a:	28 17       	cp	r18, r24
    102c:	39 07       	cpc	r19, r25
    102e:	08 f4       	brcc	.+2      	; 0x1032 <vTaskIncrementTick+0xc6>
    1030:	6b c0       	rjmp	.+214    	; 0x1108 <vTaskIncrementTick+0x19c>
    1032:	80 91 68 02 	lds	r24, 0x0268
    1036:	90 91 69 02 	lds	r25, 0x0269
    103a:	fc 01       	movw	r30, r24
    103c:	80 81       	ld	r24, Z
    103e:	88 23       	and	r24, r24
    1040:	39 f4       	brne	.+14     	; 0x1050 <vTaskIncrementTick+0xe4>
    1042:	8f ef       	ldi	r24, 0xFF	; 255
    1044:	9f ef       	ldi	r25, 0xFF	; 255
    1046:	90 93 01 02 	sts	0x0201, r25
    104a:	80 93 00 02 	sts	0x0200, r24
    104e:	5c c0       	rjmp	.+184    	; 0x1108 <vTaskIncrementTick+0x19c>
    1050:	80 91 68 02 	lds	r24, 0x0268
    1054:	90 91 69 02 	lds	r25, 0x0269
    1058:	fc 01       	movw	r30, r24
    105a:	85 81       	ldd	r24, Z+5	; 0x05
    105c:	96 81       	ldd	r25, Z+6	; 0x06
    105e:	fc 01       	movw	r30, r24
    1060:	86 81       	ldd	r24, Z+6	; 0x06
    1062:	97 81       	ldd	r25, Z+7	; 0x07
    1064:	9c 83       	std	Y+4, r25	; 0x04
    1066:	8b 83       	std	Y+3, r24	; 0x03
    1068:	8b 81       	ldd	r24, Y+3	; 0x03
    106a:	9c 81       	ldd	r25, Y+4	; 0x04
    106c:	fc 01       	movw	r30, r24
    106e:	82 81       	ldd	r24, Z+2	; 0x02
    1070:	93 81       	ldd	r25, Z+3	; 0x03
    1072:	9e 83       	std	Y+6, r25	; 0x06
    1074:	8d 83       	std	Y+5, r24	; 0x05
    1076:	20 91 7f 02 	lds	r18, 0x027F
    107a:	30 91 80 02 	lds	r19, 0x0280
    107e:	8d 81       	ldd	r24, Y+5	; 0x05
    1080:	9e 81       	ldd	r25, Y+6	; 0x06
    1082:	28 17       	cp	r18, r24
    1084:	39 07       	cpc	r19, r25
    1086:	38 f4       	brcc	.+14     	; 0x1096 <vTaskIncrementTick+0x12a>
    1088:	8d 81       	ldd	r24, Y+5	; 0x05
    108a:	9e 81       	ldd	r25, Y+6	; 0x06
    108c:	90 93 01 02 	sts	0x0201, r25
    1090:	80 93 00 02 	sts	0x0200, r24
    1094:	39 c0       	rjmp	.+114    	; 0x1108 <vTaskIncrementTick+0x19c>
    1096:	8b 81       	ldd	r24, Y+3	; 0x03
    1098:	9c 81       	ldd	r25, Y+4	; 0x04
    109a:	02 96       	adiw	r24, 0x02	; 2
    109c:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <uxListRemove>
    10a0:	8b 81       	ldd	r24, Y+3	; 0x03
    10a2:	9c 81       	ldd	r25, Y+4	; 0x04
    10a4:	fc 01       	movw	r30, r24
    10a6:	84 89       	ldd	r24, Z+20	; 0x14
    10a8:	95 89       	ldd	r25, Z+21	; 0x15
    10aa:	00 97       	sbiw	r24, 0x00	; 0
    10ac:	29 f0       	breq	.+10     	; 0x10b8 <vTaskIncrementTick+0x14c>
    10ae:	8b 81       	ldd	r24, Y+3	; 0x03
    10b0:	9c 81       	ldd	r25, Y+4	; 0x04
    10b2:	0c 96       	adiw	r24, 0x0c	; 12
    10b4:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <uxListRemove>
    10b8:	8b 81       	ldd	r24, Y+3	; 0x03
    10ba:	9c 81       	ldd	r25, Y+4	; 0x04
    10bc:	fc 01       	movw	r30, r24
    10be:	96 89       	ldd	r25, Z+22	; 0x16
    10c0:	80 91 82 02 	lds	r24, 0x0282
    10c4:	89 17       	cp	r24, r25
    10c6:	30 f4       	brcc	.+12     	; 0x10d4 <vTaskIncrementTick+0x168>
    10c8:	8b 81       	ldd	r24, Y+3	; 0x03
    10ca:	9c 81       	ldd	r25, Y+4	; 0x04
    10cc:	fc 01       	movw	r30, r24
    10ce:	86 89       	ldd	r24, Z+22	; 0x16
    10d0:	80 93 82 02 	sts	0x0282, r24
    10d4:	8b 81       	ldd	r24, Y+3	; 0x03
    10d6:	9c 81       	ldd	r25, Y+4	; 0x04
    10d8:	ac 01       	movw	r20, r24
    10da:	4e 5f       	subi	r20, 0xFE	; 254
    10dc:	5f 4f       	sbci	r21, 0xFF	; 255
    10de:	8b 81       	ldd	r24, Y+3	; 0x03
    10e0:	9c 81       	ldd	r25, Y+4	; 0x04
    10e2:	fc 01       	movw	r30, r24
    10e4:	86 89       	ldd	r24, Z+22	; 0x16
    10e6:	28 2f       	mov	r18, r24
    10e8:	30 e0       	ldi	r19, 0x00	; 0
    10ea:	c9 01       	movw	r24, r18
    10ec:	88 0f       	add	r24, r24
    10ee:	99 1f       	adc	r25, r25
    10f0:	88 0f       	add	r24, r24
    10f2:	99 1f       	adc	r25, r25
    10f4:	88 0f       	add	r24, r24
    10f6:	99 1f       	adc	r25, r25
    10f8:	82 0f       	add	r24, r18
    10fa:	93 1f       	adc	r25, r19
    10fc:	8e 5c       	subi	r24, 0xCE	; 206
    10fe:	9d 4f       	sbci	r25, 0xFD	; 253
    1100:	ba 01       	movw	r22, r20
    1102:	0e 94 00 13 	call	0x2600	; 0x2600 <vListInsertEnd>
    1106:	95 cf       	rjmp	.-214    	; 0x1032 <vTaskIncrementTick+0xc6>
    1108:	05 c0       	rjmp	.+10     	; 0x1114 <vTaskIncrementTick+0x1a8>
	}
	else
	{
		++uxMissedTicks;
    110a:	80 91 85 02 	lds	r24, 0x0285
    110e:	8f 5f       	subi	r24, 0xFF	; 255
    1110:	80 93 85 02 	sts	0x0285, r24
		{
			vApplicationTickHook();
		}
	}
	#endif
}
    1114:	26 96       	adiw	r28, 0x06	; 6
    1116:	0f b6       	in	r0, 0x3f	; 63
    1118:	f8 94       	cli
    111a:	de bf       	out	0x3e, r29	; 62
    111c:	0f be       	out	0x3f, r0	; 63
    111e:	cd bf       	out	0x3d, r28	; 61
    1120:	df 91       	pop	r29
    1122:	cf 91       	pop	r28
    1124:	08 95       	ret

00001126 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    1126:	cf 93       	push	r28
    1128:	df 93       	push	r29
    112a:	1f 92       	push	r1
    112c:	1f 92       	push	r1
    112e:	cd b7       	in	r28, 0x3d	; 61
    1130:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    1132:	80 91 84 02 	lds	r24, 0x0284
    1136:	88 23       	and	r24, r24
    1138:	21 f0       	breq	.+8      	; 0x1142 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    113a:	81 e0       	ldi	r24, 0x01	; 1
    113c:	80 93 86 02 	sts	0x0286, r24
    1140:	7a c0       	rjmp	.+244    	; 0x1236 <vTaskSwitchContext+0x110>
				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
				ulTaskSwitchedInTime = ulTempCounter;
		}
		#endif

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
    1142:	80 91 30 02 	lds	r24, 0x0230
    1146:	90 91 31 02 	lds	r25, 0x0231
    114a:	fc 01       	movw	r30, r24
    114c:	20 81       	ld	r18, Z
    114e:	31 81       	ldd	r19, Z+1	; 0x01
    1150:	80 91 30 02 	lds	r24, 0x0230
    1154:	90 91 31 02 	lds	r25, 0x0231
    1158:	fc 01       	movw	r30, r24
    115a:	87 89       	ldd	r24, Z+23	; 0x17
    115c:	90 8d       	ldd	r25, Z+24	; 0x18
    115e:	82 17       	cp	r24, r18
    1160:	93 07       	cpc	r25, r19
    1162:	70 f0       	brcs	.+28     	; 0x1180 <vTaskSwitchContext+0x5a>
    1164:	80 91 30 02 	lds	r24, 0x0230
    1168:	90 91 31 02 	lds	r25, 0x0231
    116c:	9c 01       	movw	r18, r24
    116e:	27 5e       	subi	r18, 0xE7	; 231
    1170:	3f 4f       	sbci	r19, 0xFF	; 255
    1172:	80 91 30 02 	lds	r24, 0x0230
    1176:	90 91 31 02 	lds	r25, 0x0231
    117a:	b9 01       	movw	r22, r18
    117c:	0e 94 c1 00 	call	0x182	; 0x182 <vApplicationStackOverflowHook>
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
    1180:	05 c0       	rjmp	.+10     	; 0x118c <vTaskSwitchContext+0x66>
    1182:	80 91 82 02 	lds	r24, 0x0282
    1186:	81 50       	subi	r24, 0x01	; 1
    1188:	80 93 82 02 	sts	0x0282, r24
    118c:	80 91 82 02 	lds	r24, 0x0282
    1190:	28 2f       	mov	r18, r24
    1192:	30 e0       	ldi	r19, 0x00	; 0
    1194:	c9 01       	movw	r24, r18
    1196:	88 0f       	add	r24, r24
    1198:	99 1f       	adc	r25, r25
    119a:	88 0f       	add	r24, r24
    119c:	99 1f       	adc	r25, r25
    119e:	88 0f       	add	r24, r24
    11a0:	99 1f       	adc	r25, r25
    11a2:	82 0f       	add	r24, r18
    11a4:	93 1f       	adc	r25, r19
    11a6:	8e 5c       	subi	r24, 0xCE	; 206
    11a8:	9d 4f       	sbci	r25, 0xFD	; 253
    11aa:	fc 01       	movw	r30, r24
    11ac:	80 81       	ld	r24, Z
    11ae:	88 23       	and	r24, r24
    11b0:	41 f3       	breq	.-48     	; 0x1182 <vTaskSwitchContext+0x5c>
    11b2:	80 91 82 02 	lds	r24, 0x0282
    11b6:	28 2f       	mov	r18, r24
    11b8:	30 e0       	ldi	r19, 0x00	; 0
    11ba:	c9 01       	movw	r24, r18
    11bc:	88 0f       	add	r24, r24
    11be:	99 1f       	adc	r25, r25
    11c0:	88 0f       	add	r24, r24
    11c2:	99 1f       	adc	r25, r25
    11c4:	88 0f       	add	r24, r24
    11c6:	99 1f       	adc	r25, r25
    11c8:	82 0f       	add	r24, r18
    11ca:	93 1f       	adc	r25, r19
    11cc:	8e 5c       	subi	r24, 0xCE	; 206
    11ce:	9d 4f       	sbci	r25, 0xFD	; 253
    11d0:	9a 83       	std	Y+2, r25	; 0x02
    11d2:	89 83       	std	Y+1, r24	; 0x01
    11d4:	89 81       	ldd	r24, Y+1	; 0x01
    11d6:	9a 81       	ldd	r25, Y+2	; 0x02
    11d8:	fc 01       	movw	r30, r24
    11da:	81 81       	ldd	r24, Z+1	; 0x01
    11dc:	92 81       	ldd	r25, Z+2	; 0x02
    11de:	fc 01       	movw	r30, r24
    11e0:	22 81       	ldd	r18, Z+2	; 0x02
    11e2:	33 81       	ldd	r19, Z+3	; 0x03
    11e4:	89 81       	ldd	r24, Y+1	; 0x01
    11e6:	9a 81       	ldd	r25, Y+2	; 0x02
    11e8:	fc 01       	movw	r30, r24
    11ea:	32 83       	std	Z+2, r19	; 0x02
    11ec:	21 83       	std	Z+1, r18	; 0x01
    11ee:	89 81       	ldd	r24, Y+1	; 0x01
    11f0:	9a 81       	ldd	r25, Y+2	; 0x02
    11f2:	fc 01       	movw	r30, r24
    11f4:	21 81       	ldd	r18, Z+1	; 0x01
    11f6:	32 81       	ldd	r19, Z+2	; 0x02
    11f8:	89 81       	ldd	r24, Y+1	; 0x01
    11fa:	9a 81       	ldd	r25, Y+2	; 0x02
    11fc:	03 96       	adiw	r24, 0x03	; 3
    11fe:	28 17       	cp	r18, r24
    1200:	39 07       	cpc	r19, r25
    1202:	69 f4       	brne	.+26     	; 0x121e <vTaskSwitchContext+0xf8>
    1204:	89 81       	ldd	r24, Y+1	; 0x01
    1206:	9a 81       	ldd	r25, Y+2	; 0x02
    1208:	fc 01       	movw	r30, r24
    120a:	81 81       	ldd	r24, Z+1	; 0x01
    120c:	92 81       	ldd	r25, Z+2	; 0x02
    120e:	fc 01       	movw	r30, r24
    1210:	22 81       	ldd	r18, Z+2	; 0x02
    1212:	33 81       	ldd	r19, Z+3	; 0x03
    1214:	89 81       	ldd	r24, Y+1	; 0x01
    1216:	9a 81       	ldd	r25, Y+2	; 0x02
    1218:	fc 01       	movw	r30, r24
    121a:	32 83       	std	Z+2, r19	; 0x02
    121c:	21 83       	std	Z+1, r18	; 0x01
    121e:	89 81       	ldd	r24, Y+1	; 0x01
    1220:	9a 81       	ldd	r25, Y+2	; 0x02
    1222:	fc 01       	movw	r30, r24
    1224:	81 81       	ldd	r24, Z+1	; 0x01
    1226:	92 81       	ldd	r25, Z+2	; 0x02
    1228:	fc 01       	movw	r30, r24
    122a:	86 81       	ldd	r24, Z+6	; 0x06
    122c:	97 81       	ldd	r25, Z+7	; 0x07
    122e:	90 93 31 02 	sts	0x0231, r25
    1232:	80 93 30 02 	sts	0x0230, r24

		traceTASK_SWITCHED_IN();
	}
}
    1236:	0f 90       	pop	r0
    1238:	0f 90       	pop	r0
    123a:	df 91       	pop	r29
    123c:	cf 91       	pop	r28
    123e:	08 95       	ret

00001240 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    1240:	cf 93       	push	r28
    1242:	df 93       	push	r29
    1244:	00 d0       	rcall	.+0      	; 0x1246 <vTaskPlaceOnEventList+0x6>
    1246:	00 d0       	rcall	.+0      	; 0x1248 <vTaskPlaceOnEventList+0x8>
    1248:	cd b7       	in	r28, 0x3d	; 61
    124a:	de b7       	in	r29, 0x3e	; 62
    124c:	9c 83       	std	Y+4, r25	; 0x04
    124e:	8b 83       	std	Y+3, r24	; 0x03
    1250:	7e 83       	std	Y+6, r23	; 0x06
    1252:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    1254:	80 91 30 02 	lds	r24, 0x0230
    1258:	90 91 31 02 	lds	r25, 0x0231
    125c:	9c 01       	movw	r18, r24
    125e:	24 5f       	subi	r18, 0xF4	; 244
    1260:	3f 4f       	sbci	r19, 0xFF	; 255
    1262:	8b 81       	ldd	r24, Y+3	; 0x03
    1264:	9c 81       	ldd	r25, Y+4	; 0x04
    1266:	b9 01       	movw	r22, r18
    1268:	0e 94 57 13 	call	0x26ae	; 0x26ae <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    126c:	80 91 30 02 	lds	r24, 0x0230
    1270:	90 91 31 02 	lds	r25, 0x0231
    1274:	02 96       	adiw	r24, 0x02	; 2
    1276:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <uxListRemove>
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    127a:	8d 81       	ldd	r24, Y+5	; 0x05
    127c:	9e 81       	ldd	r25, Y+6	; 0x06
    127e:	8f 3f       	cpi	r24, 0xFF	; 255
    1280:	2f ef       	ldi	r18, 0xFF	; 255
    1282:	92 07       	cpc	r25, r18
    1284:	59 f4       	brne	.+22     	; 0x129c <vTaskPlaceOnEventList+0x5c>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1286:	80 91 30 02 	lds	r24, 0x0230
    128a:	90 91 31 02 	lds	r25, 0x0231
    128e:	02 96       	adiw	r24, 0x02	; 2
    1290:	bc 01       	movw	r22, r24
    1292:	85 e7       	ldi	r24, 0x75	; 117
    1294:	92 e0       	ldi	r25, 0x02	; 2
    1296:	0e 94 00 13 	call	0x2600	; 0x2600 <vListInsertEnd>
    129a:	0e c0       	rjmp	.+28     	; 0x12b8 <vTaskPlaceOnEventList+0x78>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    129c:	20 91 7f 02 	lds	r18, 0x027F
    12a0:	30 91 80 02 	lds	r19, 0x0280
    12a4:	8d 81       	ldd	r24, Y+5	; 0x05
    12a6:	9e 81       	ldd	r25, Y+6	; 0x06
    12a8:	82 0f       	add	r24, r18
    12aa:	93 1f       	adc	r25, r19
    12ac:	9a 83       	std	Y+2, r25	; 0x02
    12ae:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    12b0:	89 81       	ldd	r24, Y+1	; 0x01
    12b2:	9a 81       	ldd	r25, Y+2	; 0x02
    12b4:	0e 94 1b 0b 	call	0x1636	; 0x1636 <prvAddCurrentTaskToDelayedList>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
    12b8:	26 96       	adiw	r28, 0x06	; 6
    12ba:	0f b6       	in	r0, 0x3f	; 63
    12bc:	f8 94       	cli
    12be:	de bf       	out	0x3e, r29	; 62
    12c0:	0f be       	out	0x3f, r0	; 63
    12c2:	cd bf       	out	0x3d, r28	; 61
    12c4:	df 91       	pop	r29
    12c6:	cf 91       	pop	r28
    12c8:	08 95       	ret

000012ca <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    12ca:	cf 93       	push	r28
    12cc:	df 93       	push	r29
    12ce:	00 d0       	rcall	.+0      	; 0x12d0 <xTaskRemoveFromEventList+0x6>
    12d0:	1f 92       	push	r1
    12d2:	1f 92       	push	r1
    12d4:	cd b7       	in	r28, 0x3d	; 61
    12d6:	de b7       	in	r29, 0x3e	; 62
    12d8:	9d 83       	std	Y+5, r25	; 0x05
    12da:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    12dc:	8c 81       	ldd	r24, Y+4	; 0x04
    12de:	9d 81       	ldd	r25, Y+5	; 0x05
    12e0:	fc 01       	movw	r30, r24
    12e2:	85 81       	ldd	r24, Z+5	; 0x05
    12e4:	96 81       	ldd	r25, Z+6	; 0x06
    12e6:	fc 01       	movw	r30, r24
    12e8:	86 81       	ldd	r24, Z+6	; 0x06
    12ea:	97 81       	ldd	r25, Z+7	; 0x07
    12ec:	9b 83       	std	Y+3, r25	; 0x03
    12ee:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    12f0:	8a 81       	ldd	r24, Y+2	; 0x02
    12f2:	9b 81       	ldd	r25, Y+3	; 0x03
    12f4:	0c 96       	adiw	r24, 0x0c	; 12
    12f6:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <uxListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    12fa:	80 91 84 02 	lds	r24, 0x0284
    12fe:	88 23       	and	r24, r24
    1300:	69 f5       	brne	.+90     	; 0x135c <xTaskRemoveFromEventList+0x92>
	{
		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    1302:	8a 81       	ldd	r24, Y+2	; 0x02
    1304:	9b 81       	ldd	r25, Y+3	; 0x03
    1306:	02 96       	adiw	r24, 0x02	; 2
    1308:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <uxListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    130c:	8a 81       	ldd	r24, Y+2	; 0x02
    130e:	9b 81       	ldd	r25, Y+3	; 0x03
    1310:	fc 01       	movw	r30, r24
    1312:	96 89       	ldd	r25, Z+22	; 0x16
    1314:	80 91 82 02 	lds	r24, 0x0282
    1318:	89 17       	cp	r24, r25
    131a:	30 f4       	brcc	.+12     	; 0x1328 <xTaskRemoveFromEventList+0x5e>
    131c:	8a 81       	ldd	r24, Y+2	; 0x02
    131e:	9b 81       	ldd	r25, Y+3	; 0x03
    1320:	fc 01       	movw	r30, r24
    1322:	86 89       	ldd	r24, Z+22	; 0x16
    1324:	80 93 82 02 	sts	0x0282, r24
    1328:	8a 81       	ldd	r24, Y+2	; 0x02
    132a:	9b 81       	ldd	r25, Y+3	; 0x03
    132c:	ac 01       	movw	r20, r24
    132e:	4e 5f       	subi	r20, 0xFE	; 254
    1330:	5f 4f       	sbci	r21, 0xFF	; 255
    1332:	8a 81       	ldd	r24, Y+2	; 0x02
    1334:	9b 81       	ldd	r25, Y+3	; 0x03
    1336:	fc 01       	movw	r30, r24
    1338:	86 89       	ldd	r24, Z+22	; 0x16
    133a:	28 2f       	mov	r18, r24
    133c:	30 e0       	ldi	r19, 0x00	; 0
    133e:	c9 01       	movw	r24, r18
    1340:	88 0f       	add	r24, r24
    1342:	99 1f       	adc	r25, r25
    1344:	88 0f       	add	r24, r24
    1346:	99 1f       	adc	r25, r25
    1348:	88 0f       	add	r24, r24
    134a:	99 1f       	adc	r25, r25
    134c:	82 0f       	add	r24, r18
    134e:	93 1f       	adc	r25, r19
    1350:	8e 5c       	subi	r24, 0xCE	; 206
    1352:	9d 4f       	sbci	r25, 0xFD	; 253
    1354:	ba 01       	movw	r22, r20
    1356:	0e 94 00 13 	call	0x2600	; 0x2600 <vListInsertEnd>
    135a:	08 c0       	rjmp	.+16     	; 0x136c <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    135c:	8a 81       	ldd	r24, Y+2	; 0x02
    135e:	9b 81       	ldd	r25, Y+3	; 0x03
    1360:	0c 96       	adiw	r24, 0x0c	; 12
    1362:	bc 01       	movw	r22, r24
    1364:	8c e6       	ldi	r24, 0x6C	; 108
    1366:	92 e0       	ldi	r25, 0x02	; 2
    1368:	0e 94 00 13 	call	0x2600	; 0x2600 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    136c:	8a 81       	ldd	r24, Y+2	; 0x02
    136e:	9b 81       	ldd	r25, Y+3	; 0x03
    1370:	fc 01       	movw	r30, r24
    1372:	26 89       	ldd	r18, Z+22	; 0x16
    1374:	80 91 30 02 	lds	r24, 0x0230
    1378:	90 91 31 02 	lds	r25, 0x0231
    137c:	fc 01       	movw	r30, r24
    137e:	86 89       	ldd	r24, Z+22	; 0x16
    1380:	28 17       	cp	r18, r24
    1382:	18 f0       	brcs	.+6      	; 0x138a <xTaskRemoveFromEventList+0xc0>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    1384:	81 e0       	ldi	r24, 0x01	; 1
    1386:	89 83       	std	Y+1, r24	; 0x01
    1388:	01 c0       	rjmp	.+2      	; 0x138c <xTaskRemoveFromEventList+0xc2>
	}
	else
	{
		xReturn = pdFALSE;
    138a:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    138c:	89 81       	ldd	r24, Y+1	; 0x01
}
    138e:	0f 90       	pop	r0
    1390:	0f 90       	pop	r0
    1392:	0f 90       	pop	r0
    1394:	0f 90       	pop	r0
    1396:	0f 90       	pop	r0
    1398:	df 91       	pop	r29
    139a:	cf 91       	pop	r28
    139c:	08 95       	ret

0000139e <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    139e:	cf 93       	push	r28
    13a0:	df 93       	push	r29
    13a2:	1f 92       	push	r1
    13a4:	1f 92       	push	r1
    13a6:	cd b7       	in	r28, 0x3d	; 61
    13a8:	de b7       	in	r29, 0x3e	; 62
    13aa:	9a 83       	std	Y+2, r25	; 0x02
    13ac:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    13ae:	20 91 87 02 	lds	r18, 0x0287
    13b2:	89 81       	ldd	r24, Y+1	; 0x01
    13b4:	9a 81       	ldd	r25, Y+2	; 0x02
    13b6:	fc 01       	movw	r30, r24
    13b8:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    13ba:	20 91 7f 02 	lds	r18, 0x027F
    13be:	30 91 80 02 	lds	r19, 0x0280
    13c2:	89 81       	ldd	r24, Y+1	; 0x01
    13c4:	9a 81       	ldd	r25, Y+2	; 0x02
    13c6:	fc 01       	movw	r30, r24
    13c8:	32 83       	std	Z+2, r19	; 0x02
    13ca:	21 83       	std	Z+1, r18	; 0x01
}
    13cc:	0f 90       	pop	r0
    13ce:	0f 90       	pop	r0
    13d0:	df 91       	pop	r29
    13d2:	cf 91       	pop	r28
    13d4:	08 95       	ret

000013d6 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    13d6:	cf 93       	push	r28
    13d8:	df 93       	push	r29
    13da:	00 d0       	rcall	.+0      	; 0x13dc <xTaskCheckForTimeOut+0x6>
    13dc:	1f 92       	push	r1
    13de:	1f 92       	push	r1
    13e0:	cd b7       	in	r28, 0x3d	; 61
    13e2:	de b7       	in	r29, 0x3e	; 62
    13e4:	9b 83       	std	Y+3, r25	; 0x03
    13e6:	8a 83       	std	Y+2, r24	; 0x02
    13e8:	7d 83       	std	Y+5, r23	; 0x05
    13ea:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    13ec:	0f b6       	in	r0, 0x3f	; 63
    13ee:	f8 94       	cli
    13f0:	0f 92       	push	r0
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    13f2:	8c 81       	ldd	r24, Y+4	; 0x04
    13f4:	9d 81       	ldd	r25, Y+5	; 0x05
    13f6:	fc 01       	movw	r30, r24
    13f8:	80 81       	ld	r24, Z
    13fa:	91 81       	ldd	r25, Z+1	; 0x01
    13fc:	8f 3f       	cpi	r24, 0xFF	; 255
    13fe:	ff ef       	ldi	r31, 0xFF	; 255
    1400:	9f 07       	cpc	r25, r31
    1402:	11 f4       	brne	.+4      	; 0x1408 <xTaskCheckForTimeOut+0x32>
			{
				xReturn = pdFALSE;
    1404:	19 82       	std	Y+1, r1	; 0x01
    1406:	4b c0       	rjmp	.+150    	; 0x149e <xTaskCheckForTimeOut+0xc8>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    1408:	8a 81       	ldd	r24, Y+2	; 0x02
    140a:	9b 81       	ldd	r25, Y+3	; 0x03
    140c:	fc 01       	movw	r30, r24
    140e:	90 81       	ld	r25, Z
    1410:	80 91 87 02 	lds	r24, 0x0287
    1414:	98 17       	cp	r25, r24
    1416:	79 f0       	breq	.+30     	; 0x1436 <xTaskCheckForTimeOut+0x60>
    1418:	8a 81       	ldd	r24, Y+2	; 0x02
    141a:	9b 81       	ldd	r25, Y+3	; 0x03
    141c:	fc 01       	movw	r30, r24
    141e:	21 81       	ldd	r18, Z+1	; 0x01
    1420:	32 81       	ldd	r19, Z+2	; 0x02
    1422:	80 91 7f 02 	lds	r24, 0x027F
    1426:	90 91 80 02 	lds	r25, 0x0280
    142a:	82 17       	cp	r24, r18
    142c:	93 07       	cpc	r25, r19
    142e:	18 f0       	brcs	.+6      	; 0x1436 <xTaskCheckForTimeOut+0x60>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    1430:	81 e0       	ldi	r24, 0x01	; 1
    1432:	89 83       	std	Y+1, r24	; 0x01
    1434:	34 c0       	rjmp	.+104    	; 0x149e <xTaskCheckForTimeOut+0xc8>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    1436:	20 91 7f 02 	lds	r18, 0x027F
    143a:	30 91 80 02 	lds	r19, 0x0280
    143e:	8a 81       	ldd	r24, Y+2	; 0x02
    1440:	9b 81       	ldd	r25, Y+3	; 0x03
    1442:	fc 01       	movw	r30, r24
    1444:	81 81       	ldd	r24, Z+1	; 0x01
    1446:	92 81       	ldd	r25, Z+2	; 0x02
    1448:	28 1b       	sub	r18, r24
    144a:	39 0b       	sbc	r19, r25
    144c:	8c 81       	ldd	r24, Y+4	; 0x04
    144e:	9d 81       	ldd	r25, Y+5	; 0x05
    1450:	fc 01       	movw	r30, r24
    1452:	80 81       	ld	r24, Z
    1454:	91 81       	ldd	r25, Z+1	; 0x01
    1456:	28 17       	cp	r18, r24
    1458:	39 07       	cpc	r19, r25
    145a:	f8 f4       	brcc	.+62     	; 0x149a <xTaskCheckForTimeOut+0xc4>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    145c:	8c 81       	ldd	r24, Y+4	; 0x04
    145e:	9d 81       	ldd	r25, Y+5	; 0x05
    1460:	fc 01       	movw	r30, r24
    1462:	20 81       	ld	r18, Z
    1464:	31 81       	ldd	r19, Z+1	; 0x01
    1466:	8a 81       	ldd	r24, Y+2	; 0x02
    1468:	9b 81       	ldd	r25, Y+3	; 0x03
    146a:	fc 01       	movw	r30, r24
    146c:	41 81       	ldd	r20, Z+1	; 0x01
    146e:	52 81       	ldd	r21, Z+2	; 0x02
    1470:	80 91 7f 02 	lds	r24, 0x027F
    1474:	90 91 80 02 	lds	r25, 0x0280
    1478:	ba 01       	movw	r22, r20
    147a:	68 1b       	sub	r22, r24
    147c:	79 0b       	sbc	r23, r25
    147e:	cb 01       	movw	r24, r22
    1480:	28 0f       	add	r18, r24
    1482:	39 1f       	adc	r19, r25
    1484:	8c 81       	ldd	r24, Y+4	; 0x04
    1486:	9d 81       	ldd	r25, Y+5	; 0x05
    1488:	fc 01       	movw	r30, r24
    148a:	31 83       	std	Z+1, r19	; 0x01
    148c:	20 83       	st	Z, r18
			vTaskSetTimeOutState( pxTimeOut );
    148e:	8a 81       	ldd	r24, Y+2	; 0x02
    1490:	9b 81       	ldd	r25, Y+3	; 0x03
    1492:	0e 94 cf 09 	call	0x139e	; 0x139e <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    1496:	19 82       	std	Y+1, r1	; 0x01
    1498:	02 c0       	rjmp	.+4      	; 0x149e <xTaskCheckForTimeOut+0xc8>
		}
		else
		{
			xReturn = pdTRUE;
    149a:	81 e0       	ldi	r24, 0x01	; 1
    149c:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    149e:	0f 90       	pop	r0
    14a0:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    14a2:	89 81       	ldd	r24, Y+1	; 0x01
}
    14a4:	0f 90       	pop	r0
    14a6:	0f 90       	pop	r0
    14a8:	0f 90       	pop	r0
    14aa:	0f 90       	pop	r0
    14ac:	0f 90       	pop	r0
    14ae:	df 91       	pop	r29
    14b0:	cf 91       	pop	r28
    14b2:	08 95       	ret

000014b4 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    14b4:	cf 93       	push	r28
    14b6:	df 93       	push	r29
    14b8:	cd b7       	in	r28, 0x3d	; 61
    14ba:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    14bc:	81 e0       	ldi	r24, 0x01	; 1
    14be:	80 93 86 02 	sts	0x0286, r24
}
    14c2:	df 91       	pop	r29
    14c4:	cf 91       	pop	r28
    14c6:	08 95       	ret

000014c8 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    14c8:	cf 93       	push	r28
    14ca:	df 93       	push	r29
    14cc:	1f 92       	push	r1
    14ce:	1f 92       	push	r1
    14d0:	cd b7       	in	r28, 0x3d	; 61
    14d2:	de b7       	in	r29, 0x3e	; 62
    14d4:	9a 83       	std	Y+2, r25	; 0x02
    14d6:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    14d8:	0e 94 14 0b 	call	0x1628	; 0x1628 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    14dc:	80 91 32 02 	lds	r24, 0x0232
    14e0:	82 30       	cpi	r24, 0x02	; 2
    14e2:	18 f0       	brcs	.+6      	; 0x14ea <prvIdleTask+0x22>
			{
				taskYIELD();
    14e4:	0e 94 92 19 	call	0x3324	; 0x3324 <vPortYield>
				}
				xTaskResumeAll();
			}
		}
		#endif
	}
    14e8:	f7 cf       	rjmp	.-18     	; 0x14d8 <prvIdleTask+0x10>
    14ea:	f6 cf       	rjmp	.-20     	; 0x14d8 <prvIdleTask+0x10>

000014ec <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    14ec:	0f 93       	push	r16
    14ee:	1f 93       	push	r17
    14f0:	cf 93       	push	r28
    14f2:	df 93       	push	r29
    14f4:	cd b7       	in	r28, 0x3d	; 61
    14f6:	de b7       	in	r29, 0x3e	; 62
    14f8:	29 97       	sbiw	r28, 0x09	; 9
    14fa:	0f b6       	in	r0, 0x3f	; 63
    14fc:	f8 94       	cli
    14fe:	de bf       	out	0x3e, r29	; 62
    1500:	0f be       	out	0x3f, r0	; 63
    1502:	cd bf       	out	0x3d, r28	; 61
    1504:	9a 83       	std	Y+2, r25	; 0x02
    1506:	89 83       	std	Y+1, r24	; 0x01
    1508:	7c 83       	std	Y+4, r23	; 0x04
    150a:	6b 83       	std	Y+3, r22	; 0x03
    150c:	4d 83       	std	Y+5, r20	; 0x05
    150e:	3f 83       	std	Y+7, r19	; 0x07
    1510:	2e 83       	std	Y+6, r18	; 0x06
    1512:	19 87       	std	Y+9, r17	; 0x09
    1514:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    1516:	89 81       	ldd	r24, Y+1	; 0x01
    1518:	9a 81       	ldd	r25, Y+2	; 0x02
    151a:	49 96       	adiw	r24, 0x19	; 25
    151c:	2b 81       	ldd	r18, Y+3	; 0x03
    151e:	3c 81       	ldd	r19, Y+4	; 0x04
    1520:	40 e1       	ldi	r20, 0x10	; 16
    1522:	50 e0       	ldi	r21, 0x00	; 0
    1524:	b9 01       	movw	r22, r18
    1526:	0e 94 9d 29 	call	0x533a	; 0x533a <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    152a:	89 81       	ldd	r24, Y+1	; 0x01
    152c:	9a 81       	ldd	r25, Y+2	; 0x02
    152e:	fc 01       	movw	r30, r24
    1530:	10 a6       	std	Z+40, r1	; 0x28

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    1532:	8d 81       	ldd	r24, Y+5	; 0x05
    1534:	84 30       	cpi	r24, 0x04	; 4
    1536:	10 f0       	brcs	.+4      	; 0x153c <prvInitialiseTCBVariables+0x50>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    1538:	83 e0       	ldi	r24, 0x03	; 3
    153a:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    153c:	89 81       	ldd	r24, Y+1	; 0x01
    153e:	9a 81       	ldd	r25, Y+2	; 0x02
    1540:	2d 81       	ldd	r18, Y+5	; 0x05
    1542:	fc 01       	movw	r30, r24
    1544:	26 8b       	std	Z+22, r18	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    1546:	89 81       	ldd	r24, Y+1	; 0x01
    1548:	9a 81       	ldd	r25, Y+2	; 0x02
    154a:	2d 81       	ldd	r18, Y+5	; 0x05
    154c:	fc 01       	movw	r30, r24
    154e:	21 a7       	std	Z+41, r18	; 0x29
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    1550:	89 81       	ldd	r24, Y+1	; 0x01
    1552:	9a 81       	ldd	r25, Y+2	; 0x02
    1554:	02 96       	adiw	r24, 0x02	; 2
    1556:	0e 94 ee 12 	call	0x25dc	; 0x25dc <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    155a:	89 81       	ldd	r24, Y+1	; 0x01
    155c:	9a 81       	ldd	r25, Y+2	; 0x02
    155e:	0c 96       	adiw	r24, 0x0c	; 12
    1560:	0e 94 ee 12 	call	0x25dc	; 0x25dc <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    1564:	89 81       	ldd	r24, Y+1	; 0x01
    1566:	9a 81       	ldd	r25, Y+2	; 0x02
    1568:	29 81       	ldd	r18, Y+1	; 0x01
    156a:	3a 81       	ldd	r19, Y+2	; 0x02
    156c:	fc 01       	movw	r30, r24
    156e:	31 87       	std	Z+9, r19	; 0x09
    1570:	20 87       	std	Z+8, r18	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    1572:	8d 81       	ldd	r24, Y+5	; 0x05
    1574:	88 2f       	mov	r24, r24
    1576:	90 e0       	ldi	r25, 0x00	; 0
    1578:	24 e0       	ldi	r18, 0x04	; 4
    157a:	30 e0       	ldi	r19, 0x00	; 0
    157c:	28 1b       	sub	r18, r24
    157e:	39 0b       	sbc	r19, r25
    1580:	89 81       	ldd	r24, Y+1	; 0x01
    1582:	9a 81       	ldd	r25, Y+2	; 0x02
    1584:	fc 01       	movw	r30, r24
    1586:	35 87       	std	Z+13, r19	; 0x0d
    1588:	24 87       	std	Z+12, r18	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    158a:	89 81       	ldd	r24, Y+1	; 0x01
    158c:	9a 81       	ldd	r25, Y+2	; 0x02
    158e:	29 81       	ldd	r18, Y+1	; 0x01
    1590:	3a 81       	ldd	r19, Y+2	; 0x02
    1592:	fc 01       	movw	r30, r24
    1594:	33 8b       	std	Z+19, r19	; 0x13
    1596:	22 8b       	std	Z+18, r18	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    1598:	29 96       	adiw	r28, 0x09	; 9
    159a:	0f b6       	in	r0, 0x3f	; 63
    159c:	f8 94       	cli
    159e:	de bf       	out	0x3e, r29	; 62
    15a0:	0f be       	out	0x3f, r0	; 63
    15a2:	cd bf       	out	0x3d, r28	; 61
    15a4:	df 91       	pop	r29
    15a6:	cf 91       	pop	r28
    15a8:	1f 91       	pop	r17
    15aa:	0f 91       	pop	r16
    15ac:	08 95       	ret

000015ae <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    15ae:	cf 93       	push	r28
    15b0:	df 93       	push	r29
    15b2:	1f 92       	push	r1
    15b4:	cd b7       	in	r28, 0x3d	; 61
    15b6:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    15b8:	19 82       	std	Y+1, r1	; 0x01
    15ba:	13 c0       	rjmp	.+38     	; 0x15e2 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    15bc:	89 81       	ldd	r24, Y+1	; 0x01
    15be:	28 2f       	mov	r18, r24
    15c0:	30 e0       	ldi	r19, 0x00	; 0
    15c2:	c9 01       	movw	r24, r18
    15c4:	88 0f       	add	r24, r24
    15c6:	99 1f       	adc	r25, r25
    15c8:	88 0f       	add	r24, r24
    15ca:	99 1f       	adc	r25, r25
    15cc:	88 0f       	add	r24, r24
    15ce:	99 1f       	adc	r25, r25
    15d0:	82 0f       	add	r24, r18
    15d2:	93 1f       	adc	r25, r19
    15d4:	8e 5c       	subi	r24, 0xCE	; 206
    15d6:	9d 4f       	sbci	r25, 0xFD	; 253
    15d8:	0e 94 b8 12 	call	0x2570	; 0x2570 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    15dc:	89 81       	ldd	r24, Y+1	; 0x01
    15de:	8f 5f       	subi	r24, 0xFF	; 255
    15e0:	89 83       	std	Y+1, r24	; 0x01
    15e2:	89 81       	ldd	r24, Y+1	; 0x01
    15e4:	84 30       	cpi	r24, 0x04	; 4
    15e6:	50 f3       	brcs	.-44     	; 0x15bc <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    15e8:	86 e5       	ldi	r24, 0x56	; 86
    15ea:	92 e0       	ldi	r25, 0x02	; 2
    15ec:	0e 94 b8 12 	call	0x2570	; 0x2570 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    15f0:	8f e5       	ldi	r24, 0x5F	; 95
    15f2:	92 e0       	ldi	r25, 0x02	; 2
    15f4:	0e 94 b8 12 	call	0x2570	; 0x2570 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    15f8:	8c e6       	ldi	r24, 0x6C	; 108
    15fa:	92 e0       	ldi	r25, 0x02	; 2
    15fc:	0e 94 b8 12 	call	0x2570	; 0x2570 <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
    1600:	85 e7       	ldi	r24, 0x75	; 117
    1602:	92 e0       	ldi	r25, 0x02	; 2
    1604:	0e 94 b8 12 	call	0x2570	; 0x2570 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1608:	86 e5       	ldi	r24, 0x56	; 86
    160a:	92 e0       	ldi	r25, 0x02	; 2
    160c:	90 93 69 02 	sts	0x0269, r25
    1610:	80 93 68 02 	sts	0x0268, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1614:	8f e5       	ldi	r24, 0x5F	; 95
    1616:	92 e0       	ldi	r25, 0x02	; 2
    1618:	90 93 6b 02 	sts	0x026B, r25
    161c:	80 93 6a 02 	sts	0x026A, r24
}
    1620:	0f 90       	pop	r0
    1622:	df 91       	pop	r29
    1624:	cf 91       	pop	r28
    1626:	08 95       	ret

00001628 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    1628:	cf 93       	push	r28
    162a:	df 93       	push	r29
    162c:	cd b7       	in	r28, 0x3d	; 61
    162e:	de b7       	in	r29, 0x3e	; 62
				prvDeleteTCB( pxTCB );
			}
		}
	}
	#endif
}
    1630:	df 91       	pop	r29
    1632:	cf 91       	pop	r28
    1634:	08 95       	ret

00001636 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    1636:	cf 93       	push	r28
    1638:	df 93       	push	r29
    163a:	1f 92       	push	r1
    163c:	1f 92       	push	r1
    163e:	cd b7       	in	r28, 0x3d	; 61
    1640:	de b7       	in	r29, 0x3e	; 62
    1642:	9a 83       	std	Y+2, r25	; 0x02
    1644:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1646:	80 91 30 02 	lds	r24, 0x0230
    164a:	90 91 31 02 	lds	r25, 0x0231
    164e:	29 81       	ldd	r18, Y+1	; 0x01
    1650:	3a 81       	ldd	r19, Y+2	; 0x02
    1652:	fc 01       	movw	r30, r24
    1654:	33 83       	std	Z+3, r19	; 0x03
    1656:	22 83       	std	Z+2, r18	; 0x02

	if( xTimeToWake < xTickCount )
    1658:	80 91 7f 02 	lds	r24, 0x027F
    165c:	90 91 80 02 	lds	r25, 0x0280
    1660:	29 81       	ldd	r18, Y+1	; 0x01
    1662:	3a 81       	ldd	r19, Y+2	; 0x02
    1664:	28 17       	cp	r18, r24
    1666:	39 07       	cpc	r19, r25
    1668:	78 f4       	brcc	.+30     	; 0x1688 <prvAddCurrentTaskToDelayedList+0x52>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    166a:	80 91 30 02 	lds	r24, 0x0230
    166e:	90 91 31 02 	lds	r25, 0x0231
    1672:	9c 01       	movw	r18, r24
    1674:	2e 5f       	subi	r18, 0xFE	; 254
    1676:	3f 4f       	sbci	r19, 0xFF	; 255
    1678:	80 91 6a 02 	lds	r24, 0x026A
    167c:	90 91 6b 02 	lds	r25, 0x026B
    1680:	b9 01       	movw	r22, r18
    1682:	0e 94 57 13 	call	0x26ae	; 0x26ae <vListInsert>
    1686:	1d c0       	rjmp	.+58     	; 0x16c2 <prvAddCurrentTaskToDelayedList+0x8c>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1688:	80 91 30 02 	lds	r24, 0x0230
    168c:	90 91 31 02 	lds	r25, 0x0231
    1690:	9c 01       	movw	r18, r24
    1692:	2e 5f       	subi	r18, 0xFE	; 254
    1694:	3f 4f       	sbci	r19, 0xFF	; 255
    1696:	80 91 68 02 	lds	r24, 0x0268
    169a:	90 91 69 02 	lds	r25, 0x0269
    169e:	b9 01       	movw	r22, r18
    16a0:	0e 94 57 13 	call	0x26ae	; 0x26ae <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    16a4:	80 91 00 02 	lds	r24, 0x0200
    16a8:	90 91 01 02 	lds	r25, 0x0201
    16ac:	29 81       	ldd	r18, Y+1	; 0x01
    16ae:	3a 81       	ldd	r19, Y+2	; 0x02
    16b0:	28 17       	cp	r18, r24
    16b2:	39 07       	cpc	r19, r25
    16b4:	30 f4       	brcc	.+12     	; 0x16c2 <prvAddCurrentTaskToDelayedList+0x8c>
		{
			xNextTaskUnblockTime = xTimeToWake;
    16b6:	89 81       	ldd	r24, Y+1	; 0x01
    16b8:	9a 81       	ldd	r25, Y+2	; 0x02
    16ba:	90 93 01 02 	sts	0x0201, r25
    16be:	80 93 00 02 	sts	0x0200, r24
		}
	}
}
    16c2:	0f 90       	pop	r0
    16c4:	0f 90       	pop	r0
    16c6:	df 91       	pop	r29
    16c8:	cf 91       	pop	r28
    16ca:	08 95       	ret

000016cc <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    16cc:	cf 93       	push	r28
    16ce:	df 93       	push	r29
    16d0:	00 d0       	rcall	.+0      	; 0x16d2 <prvAllocateTCBAndStack+0x6>
    16d2:	00 d0       	rcall	.+0      	; 0x16d4 <prvAllocateTCBAndStack+0x8>
    16d4:	cd b7       	in	r28, 0x3d	; 61
    16d6:	de b7       	in	r29, 0x3e	; 62
    16d8:	9c 83       	std	Y+4, r25	; 0x04
    16da:	8b 83       	std	Y+3, r24	; 0x03
    16dc:	7e 83       	std	Y+6, r23	; 0x06
    16de:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    16e0:	8a e2       	ldi	r24, 0x2A	; 42
    16e2:	90 e0       	ldi	r25, 0x00	; 0
    16e4:	0e 94 1f 17 	call	0x2e3e	; 0x2e3e <pvPortMalloc>
    16e8:	9a 83       	std	Y+2, r25	; 0x02
    16ea:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    16ec:	89 81       	ldd	r24, Y+1	; 0x01
    16ee:	9a 81       	ldd	r25, Y+2	; 0x02
    16f0:	00 97       	sbiw	r24, 0x00	; 0
    16f2:	51 f1       	breq	.+84     	; 0x1748 <prvAllocateTCBAndStack+0x7c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    16f4:	8d 81       	ldd	r24, Y+5	; 0x05
    16f6:	9e 81       	ldd	r25, Y+6	; 0x06
    16f8:	00 97       	sbiw	r24, 0x00	; 0
    16fa:	29 f4       	brne	.+10     	; 0x1706 <prvAllocateTCBAndStack+0x3a>
    16fc:	8b 81       	ldd	r24, Y+3	; 0x03
    16fe:	9c 81       	ldd	r25, Y+4	; 0x04
    1700:	0e 94 1f 17 	call	0x2e3e	; 0x2e3e <pvPortMalloc>
    1704:	02 c0       	rjmp	.+4      	; 0x170a <prvAllocateTCBAndStack+0x3e>
    1706:	8d 81       	ldd	r24, Y+5	; 0x05
    1708:	9e 81       	ldd	r25, Y+6	; 0x06
    170a:	29 81       	ldd	r18, Y+1	; 0x01
    170c:	3a 81       	ldd	r19, Y+2	; 0x02
    170e:	f9 01       	movw	r30, r18
    1710:	90 8f       	std	Z+24, r25	; 0x18
    1712:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    1714:	89 81       	ldd	r24, Y+1	; 0x01
    1716:	9a 81       	ldd	r25, Y+2	; 0x02
    1718:	fc 01       	movw	r30, r24
    171a:	87 89       	ldd	r24, Z+23	; 0x17
    171c:	90 8d       	ldd	r25, Z+24	; 0x18
    171e:	00 97       	sbiw	r24, 0x00	; 0
    1720:	39 f4       	brne	.+14     	; 0x1730 <prvAllocateTCBAndStack+0x64>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    1722:	89 81       	ldd	r24, Y+1	; 0x01
    1724:	9a 81       	ldd	r25, Y+2	; 0x02
    1726:	0e 94 65 17 	call	0x2eca	; 0x2eca <vPortFree>
			pxNewTCB = NULL;
    172a:	1a 82       	std	Y+2, r1	; 0x02
    172c:	19 82       	std	Y+1, r1	; 0x01
    172e:	0c c0       	rjmp	.+24     	; 0x1748 <prvAllocateTCBAndStack+0x7c>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    1730:	89 81       	ldd	r24, Y+1	; 0x01
    1732:	9a 81       	ldd	r25, Y+2	; 0x02
    1734:	fc 01       	movw	r30, r24
    1736:	87 89       	ldd	r24, Z+23	; 0x17
    1738:	90 8d       	ldd	r25, Z+24	; 0x18
    173a:	2b 81       	ldd	r18, Y+3	; 0x03
    173c:	3c 81       	ldd	r19, Y+4	; 0x04
    173e:	a9 01       	movw	r20, r18
    1740:	65 ea       	ldi	r22, 0xA5	; 165
    1742:	70 e0       	ldi	r23, 0x00	; 0
    1744:	0e 94 96 29 	call	0x532c	; 0x532c <memset>
		}
	}

	return pxNewTCB;
    1748:	89 81       	ldd	r24, Y+1	; 0x01
    174a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    174c:	26 96       	adiw	r28, 0x06	; 6
    174e:	0f b6       	in	r0, 0x3f	; 63
    1750:	f8 94       	cli
    1752:	de bf       	out	0x3e, r29	; 62
    1754:	0f be       	out	0x3f, r0	; 63
    1756:	cd bf       	out	0x3d, r28	; 61
    1758:	df 91       	pop	r29
    175a:	cf 91       	pop	r28
    175c:	08 95       	ret

0000175e <usTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
    175e:	0f 93       	push	r16
    1760:	1f 93       	push	r17
    1762:	cf 93       	push	r28
    1764:	df 93       	push	r29
    1766:	1f 92       	push	r1
    1768:	1f 92       	push	r1
    176a:	cd b7       	in	r28, 0x3d	; 61
    176c:	de b7       	in	r29, 0x3e	; 62
    176e:	9a 83       	std	Y+2, r25	; 0x02
    1770:	89 83       	std	Y+1, r24	; 0x01
	register unsigned short usCount = 0U;
    1772:	00 e0       	ldi	r16, 0x00	; 0
    1774:	10 e0       	ldi	r17, 0x00	; 0

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    1776:	09 c0       	rjmp	.+18     	; 0x178a <usTaskCheckFreeStackSpace+0x2c>
		{
			pucStackByte -= portSTACK_GROWTH;
    1778:	89 81       	ldd	r24, Y+1	; 0x01
    177a:	9a 81       	ldd	r25, Y+2	; 0x02
    177c:	01 96       	adiw	r24, 0x01	; 1
    177e:	9a 83       	std	Y+2, r25	; 0x02
    1780:	89 83       	std	Y+1, r24	; 0x01
			usCount++;
    1782:	c8 01       	movw	r24, r16
    1784:	8c 01       	movw	r16, r24
    1786:	0f 5f       	subi	r16, 0xFF	; 255
    1788:	1f 4f       	sbci	r17, 0xFF	; 255

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    178a:	89 81       	ldd	r24, Y+1	; 0x01
    178c:	9a 81       	ldd	r25, Y+2	; 0x02
    178e:	fc 01       	movw	r30, r24
    1790:	80 81       	ld	r24, Z
    1792:	85 3a       	cpi	r24, 0xA5	; 165
    1794:	89 f3       	breq	.-30     	; 0x1778 <usTaskCheckFreeStackSpace+0x1a>
			usCount++;
		}

		usCount /= sizeof( portSTACK_TYPE );

		return usCount;
    1796:	c8 01       	movw	r24, r16
	}
    1798:	0f 90       	pop	r0
    179a:	0f 90       	pop	r0
    179c:	df 91       	pop	r29
    179e:	cf 91       	pop	r28
    17a0:	1f 91       	pop	r17
    17a2:	0f 91       	pop	r16
    17a4:	08 95       	ret

000017a6 <uxTaskGetStackHighWaterMark>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
	{
    17a6:	cf 93       	push	r28
    17a8:	df 93       	push	r29
    17aa:	cd b7       	in	r28, 0x3d	; 61
    17ac:	de b7       	in	r29, 0x3e	; 62
    17ae:	27 97       	sbiw	r28, 0x07	; 7
    17b0:	0f b6       	in	r0, 0x3f	; 63
    17b2:	f8 94       	cli
    17b4:	de bf       	out	0x3e, r29	; 62
    17b6:	0f be       	out	0x3f, r0	; 63
    17b8:	cd bf       	out	0x3d, r28	; 61
    17ba:	9f 83       	std	Y+7, r25	; 0x07
    17bc:	8e 83       	std	Y+6, r24	; 0x06
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    17be:	8e 81       	ldd	r24, Y+6	; 0x06
    17c0:	9f 81       	ldd	r25, Y+7	; 0x07
    17c2:	00 97       	sbiw	r24, 0x00	; 0
    17c4:	29 f4       	brne	.+10     	; 0x17d0 <uxTaskGetStackHighWaterMark+0x2a>
    17c6:	80 91 30 02 	lds	r24, 0x0230
    17ca:	90 91 31 02 	lds	r25, 0x0231
    17ce:	02 c0       	rjmp	.+4      	; 0x17d4 <uxTaskGetStackHighWaterMark+0x2e>
    17d0:	8e 81       	ldd	r24, Y+6	; 0x06
    17d2:	9f 81       	ldd	r25, Y+7	; 0x07
    17d4:	9a 83       	std	Y+2, r25	; 0x02
    17d6:	89 83       	std	Y+1, r24	; 0x01

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    17d8:	89 81       	ldd	r24, Y+1	; 0x01
    17da:	9a 81       	ldd	r25, Y+2	; 0x02
    17dc:	fc 01       	movw	r30, r24
    17de:	87 89       	ldd	r24, Z+23	; 0x17
    17e0:	90 8d       	ldd	r25, Z+24	; 0x18
    17e2:	9c 83       	std	Y+4, r25	; 0x04
    17e4:	8b 83       	std	Y+3, r24	; 0x03
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
		}
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
    17e6:	8b 81       	ldd	r24, Y+3	; 0x03
    17e8:	9c 81       	ldd	r25, Y+4	; 0x04
    17ea:	0e 94 af 0b 	call	0x175e	; 0x175e <usTaskCheckFreeStackSpace>
    17ee:	8d 83       	std	Y+5, r24	; 0x05

		return uxReturn;
    17f0:	8d 81       	ldd	r24, Y+5	; 0x05
	}
    17f2:	27 96       	adiw	r28, 0x07	; 7
    17f4:	0f b6       	in	r0, 0x3f	; 63
    17f6:	f8 94       	cli
    17f8:	de bf       	out	0x3e, r29	; 62
    17fa:	0f be       	out	0x3f, r0	; 63
    17fc:	cd bf       	out	0x3d, r28	; 61
    17fe:	df 91       	pop	r29
    1800:	cf 91       	pop	r28
    1802:	08 95       	ret

00001804 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	xTaskHandle xTaskGetCurrentTaskHandle( void )
	{
    1804:	cf 93       	push	r28
    1806:	df 93       	push	r29
    1808:	1f 92       	push	r1
    180a:	1f 92       	push	r1
    180c:	cd b7       	in	r28, 0x3d	; 61
    180e:	de b7       	in	r29, 0x3e	; 62
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    1810:	80 91 30 02 	lds	r24, 0x0230
    1814:	90 91 31 02 	lds	r25, 0x0231
    1818:	9a 83       	std	Y+2, r25	; 0x02
    181a:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    181c:	89 81       	ldd	r24, Y+1	; 0x01
    181e:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    1820:	0f 90       	pop	r0
    1822:	0f 90       	pop	r0
    1824:	df 91       	pop	r29
    1826:	cf 91       	pop	r28
    1828:	08 95       	ret

0000182a <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    182a:	cf 93       	push	r28
    182c:	df 93       	push	r29
    182e:	00 d0       	rcall	.+0      	; 0x1830 <vTaskPriorityInherit+0x6>
    1830:	1f 92       	push	r1
    1832:	cd b7       	in	r28, 0x3d	; 61
    1834:	de b7       	in	r29, 0x3e	; 62
    1836:	9c 83       	std	Y+4, r25	; 0x04
    1838:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
    183a:	8b 81       	ldd	r24, Y+3	; 0x03
    183c:	9c 81       	ldd	r25, Y+4	; 0x04
    183e:	9a 83       	std	Y+2, r25	; 0x02
    1840:	89 83       	std	Y+1, r24	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    1842:	8b 81       	ldd	r24, Y+3	; 0x03
    1844:	9c 81       	ldd	r25, Y+4	; 0x04
    1846:	00 97       	sbiw	r24, 0x00	; 0
    1848:	09 f4       	brne	.+2      	; 0x184c <vTaskPriorityInherit+0x22>
    184a:	78 c0       	rjmp	.+240    	; 0x193c <vTaskPriorityInherit+0x112>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    184c:	89 81       	ldd	r24, Y+1	; 0x01
    184e:	9a 81       	ldd	r25, Y+2	; 0x02
    1850:	fc 01       	movw	r30, r24
    1852:	26 89       	ldd	r18, Z+22	; 0x16
    1854:	80 91 30 02 	lds	r24, 0x0230
    1858:	90 91 31 02 	lds	r25, 0x0231
    185c:	fc 01       	movw	r30, r24
    185e:	86 89       	ldd	r24, Z+22	; 0x16
    1860:	28 17       	cp	r18, r24
    1862:	08 f0       	brcs	.+2      	; 0x1866 <vTaskPriorityInherit+0x3c>
    1864:	6b c0       	rjmp	.+214    	; 0x193c <vTaskPriorityInherit+0x112>
			{
				/* Adjust the mutex holder state to account for its new priority. */
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    1866:	80 91 30 02 	lds	r24, 0x0230
    186a:	90 91 31 02 	lds	r25, 0x0231
    186e:	fc 01       	movw	r30, r24
    1870:	86 89       	ldd	r24, Z+22	; 0x16
    1872:	88 2f       	mov	r24, r24
    1874:	90 e0       	ldi	r25, 0x00	; 0
    1876:	24 e0       	ldi	r18, 0x04	; 4
    1878:	30 e0       	ldi	r19, 0x00	; 0
    187a:	28 1b       	sub	r18, r24
    187c:	39 0b       	sbc	r19, r25
    187e:	89 81       	ldd	r24, Y+1	; 0x01
    1880:	9a 81       	ldd	r25, Y+2	; 0x02
    1882:	fc 01       	movw	r30, r24
    1884:	35 87       	std	Z+13, r19	; 0x0d
    1886:	24 87       	std	Z+12, r18	; 0x0c

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    1888:	89 81       	ldd	r24, Y+1	; 0x01
    188a:	9a 81       	ldd	r25, Y+2	; 0x02
    188c:	fc 01       	movw	r30, r24
    188e:	42 85       	ldd	r20, Z+10	; 0x0a
    1890:	53 85       	ldd	r21, Z+11	; 0x0b
    1892:	89 81       	ldd	r24, Y+1	; 0x01
    1894:	9a 81       	ldd	r25, Y+2	; 0x02
    1896:	fc 01       	movw	r30, r24
    1898:	86 89       	ldd	r24, Z+22	; 0x16
    189a:	28 2f       	mov	r18, r24
    189c:	30 e0       	ldi	r19, 0x00	; 0
    189e:	c9 01       	movw	r24, r18
    18a0:	88 0f       	add	r24, r24
    18a2:	99 1f       	adc	r25, r25
    18a4:	88 0f       	add	r24, r24
    18a6:	99 1f       	adc	r25, r25
    18a8:	88 0f       	add	r24, r24
    18aa:	99 1f       	adc	r25, r25
    18ac:	82 0f       	add	r24, r18
    18ae:	93 1f       	adc	r25, r19
    18b0:	8e 5c       	subi	r24, 0xCE	; 206
    18b2:	9d 4f       	sbci	r25, 0xFD	; 253
    18b4:	48 17       	cp	r20, r24
    18b6:	59 07       	cpc	r21, r25
    18b8:	b9 f5       	brne	.+110    	; 0x1928 <vTaskPriorityInherit+0xfe>
				{
					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    18ba:	89 81       	ldd	r24, Y+1	; 0x01
    18bc:	9a 81       	ldd	r25, Y+2	; 0x02
    18be:	02 96       	adiw	r24, 0x02	; 2
    18c0:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <uxListRemove>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    18c4:	80 91 30 02 	lds	r24, 0x0230
    18c8:	90 91 31 02 	lds	r25, 0x0231
    18cc:	fc 01       	movw	r30, r24
    18ce:	26 89       	ldd	r18, Z+22	; 0x16
    18d0:	89 81       	ldd	r24, Y+1	; 0x01
    18d2:	9a 81       	ldd	r25, Y+2	; 0x02
    18d4:	fc 01       	movw	r30, r24
    18d6:	26 8b       	std	Z+22, r18	; 0x16
					prvAddTaskToReadyQueue( pxTCB );
    18d8:	89 81       	ldd	r24, Y+1	; 0x01
    18da:	9a 81       	ldd	r25, Y+2	; 0x02
    18dc:	fc 01       	movw	r30, r24
    18de:	96 89       	ldd	r25, Z+22	; 0x16
    18e0:	80 91 82 02 	lds	r24, 0x0282
    18e4:	89 17       	cp	r24, r25
    18e6:	30 f4       	brcc	.+12     	; 0x18f4 <vTaskPriorityInherit+0xca>
    18e8:	89 81       	ldd	r24, Y+1	; 0x01
    18ea:	9a 81       	ldd	r25, Y+2	; 0x02
    18ec:	fc 01       	movw	r30, r24
    18ee:	86 89       	ldd	r24, Z+22	; 0x16
    18f0:	80 93 82 02 	sts	0x0282, r24
    18f4:	89 81       	ldd	r24, Y+1	; 0x01
    18f6:	9a 81       	ldd	r25, Y+2	; 0x02
    18f8:	ac 01       	movw	r20, r24
    18fa:	4e 5f       	subi	r20, 0xFE	; 254
    18fc:	5f 4f       	sbci	r21, 0xFF	; 255
    18fe:	89 81       	ldd	r24, Y+1	; 0x01
    1900:	9a 81       	ldd	r25, Y+2	; 0x02
    1902:	fc 01       	movw	r30, r24
    1904:	86 89       	ldd	r24, Z+22	; 0x16
    1906:	28 2f       	mov	r18, r24
    1908:	30 e0       	ldi	r19, 0x00	; 0
    190a:	c9 01       	movw	r24, r18
    190c:	88 0f       	add	r24, r24
    190e:	99 1f       	adc	r25, r25
    1910:	88 0f       	add	r24, r24
    1912:	99 1f       	adc	r25, r25
    1914:	88 0f       	add	r24, r24
    1916:	99 1f       	adc	r25, r25
    1918:	82 0f       	add	r24, r18
    191a:	93 1f       	adc	r25, r19
    191c:	8e 5c       	subi	r24, 0xCE	; 206
    191e:	9d 4f       	sbci	r25, 0xFD	; 253
    1920:	ba 01       	movw	r22, r20
    1922:	0e 94 00 13 	call	0x2600	; 0x2600 <vListInsertEnd>
    1926:	0a c0       	rjmp	.+20     	; 0x193c <vTaskPriorityInherit+0x112>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    1928:	80 91 30 02 	lds	r24, 0x0230
    192c:	90 91 31 02 	lds	r25, 0x0231
    1930:	fc 01       	movw	r30, r24
    1932:	26 89       	ldd	r18, Z+22	; 0x16
    1934:	89 81       	ldd	r24, Y+1	; 0x01
    1936:	9a 81       	ldd	r25, Y+2	; 0x02
    1938:	fc 01       	movw	r30, r24
    193a:	26 8b       	std	Z+22, r18	; 0x16
				}

				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
			}
		}
	}
    193c:	0f 90       	pop	r0
    193e:	0f 90       	pop	r0
    1940:	0f 90       	pop	r0
    1942:	0f 90       	pop	r0
    1944:	df 91       	pop	r29
    1946:	cf 91       	pop	r28
    1948:	08 95       	ret

0000194a <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    194a:	cf 93       	push	r28
    194c:	df 93       	push	r29
    194e:	00 d0       	rcall	.+0      	; 0x1950 <vTaskPriorityDisinherit+0x6>
    1950:	1f 92       	push	r1
    1952:	cd b7       	in	r28, 0x3d	; 61
    1954:	de b7       	in	r29, 0x3e	; 62
    1956:	9c 83       	std	Y+4, r25	; 0x04
    1958:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
    195a:	8b 81       	ldd	r24, Y+3	; 0x03
    195c:	9c 81       	ldd	r25, Y+4	; 0x04
    195e:	9a 83       	std	Y+2, r25	; 0x02
    1960:	89 83       	std	Y+1, r24	; 0x01

		if( pxMutexHolder != NULL )
    1962:	8b 81       	ldd	r24, Y+3	; 0x03
    1964:	9c 81       	ldd	r25, Y+4	; 0x04
    1966:	00 97       	sbiw	r24, 0x00	; 0
    1968:	09 f4       	brne	.+2      	; 0x196c <vTaskPriorityDisinherit+0x22>
    196a:	4e c0       	rjmp	.+156    	; 0x1a08 <vTaskPriorityDisinherit+0xbe>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    196c:	89 81       	ldd	r24, Y+1	; 0x01
    196e:	9a 81       	ldd	r25, Y+2	; 0x02
    1970:	fc 01       	movw	r30, r24
    1972:	26 89       	ldd	r18, Z+22	; 0x16
    1974:	89 81       	ldd	r24, Y+1	; 0x01
    1976:	9a 81       	ldd	r25, Y+2	; 0x02
    1978:	fc 01       	movw	r30, r24
    197a:	81 a5       	ldd	r24, Z+41	; 0x29
    197c:	28 17       	cp	r18, r24
    197e:	09 f4       	brne	.+2      	; 0x1982 <vTaskPriorityDisinherit+0x38>
    1980:	43 c0       	rjmp	.+134    	; 0x1a08 <vTaskPriorityDisinherit+0xbe>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    1982:	89 81       	ldd	r24, Y+1	; 0x01
    1984:	9a 81       	ldd	r25, Y+2	; 0x02
    1986:	02 96       	adiw	r24, 0x02	; 2
    1988:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <uxListRemove>
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    198c:	89 81       	ldd	r24, Y+1	; 0x01
    198e:	9a 81       	ldd	r25, Y+2	; 0x02
    1990:	fc 01       	movw	r30, r24
    1992:	21 a5       	ldd	r18, Z+41	; 0x29
    1994:	89 81       	ldd	r24, Y+1	; 0x01
    1996:	9a 81       	ldd	r25, Y+2	; 0x02
    1998:	fc 01       	movw	r30, r24
    199a:	26 8b       	std	Z+22, r18	; 0x16
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    199c:	89 81       	ldd	r24, Y+1	; 0x01
    199e:	9a 81       	ldd	r25, Y+2	; 0x02
    19a0:	fc 01       	movw	r30, r24
    19a2:	86 89       	ldd	r24, Z+22	; 0x16
    19a4:	88 2f       	mov	r24, r24
    19a6:	90 e0       	ldi	r25, 0x00	; 0
    19a8:	24 e0       	ldi	r18, 0x04	; 4
    19aa:	30 e0       	ldi	r19, 0x00	; 0
    19ac:	28 1b       	sub	r18, r24
    19ae:	39 0b       	sbc	r19, r25
    19b0:	89 81       	ldd	r24, Y+1	; 0x01
    19b2:	9a 81       	ldd	r25, Y+2	; 0x02
    19b4:	fc 01       	movw	r30, r24
    19b6:	35 87       	std	Z+13, r19	; 0x0d
    19b8:	24 87       	std	Z+12, r18	; 0x0c
				prvAddTaskToReadyQueue( pxTCB );
    19ba:	89 81       	ldd	r24, Y+1	; 0x01
    19bc:	9a 81       	ldd	r25, Y+2	; 0x02
    19be:	fc 01       	movw	r30, r24
    19c0:	96 89       	ldd	r25, Z+22	; 0x16
    19c2:	80 91 82 02 	lds	r24, 0x0282
    19c6:	89 17       	cp	r24, r25
    19c8:	30 f4       	brcc	.+12     	; 0x19d6 <vTaskPriorityDisinherit+0x8c>
    19ca:	89 81       	ldd	r24, Y+1	; 0x01
    19cc:	9a 81       	ldd	r25, Y+2	; 0x02
    19ce:	fc 01       	movw	r30, r24
    19d0:	86 89       	ldd	r24, Z+22	; 0x16
    19d2:	80 93 82 02 	sts	0x0282, r24
    19d6:	89 81       	ldd	r24, Y+1	; 0x01
    19d8:	9a 81       	ldd	r25, Y+2	; 0x02
    19da:	ac 01       	movw	r20, r24
    19dc:	4e 5f       	subi	r20, 0xFE	; 254
    19de:	5f 4f       	sbci	r21, 0xFF	; 255
    19e0:	89 81       	ldd	r24, Y+1	; 0x01
    19e2:	9a 81       	ldd	r25, Y+2	; 0x02
    19e4:	fc 01       	movw	r30, r24
    19e6:	86 89       	ldd	r24, Z+22	; 0x16
    19e8:	28 2f       	mov	r18, r24
    19ea:	30 e0       	ldi	r19, 0x00	; 0
    19ec:	c9 01       	movw	r24, r18
    19ee:	88 0f       	add	r24, r24
    19f0:	99 1f       	adc	r25, r25
    19f2:	88 0f       	add	r24, r24
    19f4:	99 1f       	adc	r25, r25
    19f6:	88 0f       	add	r24, r24
    19f8:	99 1f       	adc	r25, r25
    19fa:	82 0f       	add	r24, r18
    19fc:	93 1f       	adc	r25, r19
    19fe:	8e 5c       	subi	r24, 0xCE	; 206
    1a00:	9d 4f       	sbci	r25, 0xFD	; 253
    1a02:	ba 01       	movw	r22, r20
    1a04:	0e 94 00 13 	call	0x2600	; 0x2600 <vListInsertEnd>
			}
		}
	}
    1a08:	0f 90       	pop	r0
    1a0a:	0f 90       	pop	r0
    1a0c:	0f 90       	pop	r0
    1a0e:	0f 90       	pop	r0
    1a10:	df 91       	pop	r29
    1a12:	cf 91       	pop	r28
    1a14:	08 95       	ret

00001a16 <xQueueGenericReset>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle pxQueue, portBASE_TYPE xNewQueue )
{
    1a16:	cf 93       	push	r28
    1a18:	df 93       	push	r29
    1a1a:	00 d0       	rcall	.+0      	; 0x1a1c <xQueueGenericReset+0x6>
    1a1c:	cd b7       	in	r28, 0x3d	; 61
    1a1e:	de b7       	in	r29, 0x3e	; 62
    1a20:	9a 83       	std	Y+2, r25	; 0x02
    1a22:	89 83       	std	Y+1, r24	; 0x01
    1a24:	6b 83       	std	Y+3, r22	; 0x03
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1a26:	0f b6       	in	r0, 0x3f	; 63
    1a28:	f8 94       	cli
    1a2a:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1a2c:	89 81       	ldd	r24, Y+1	; 0x01
    1a2e:	9a 81       	ldd	r25, Y+2	; 0x02
    1a30:	fc 01       	movw	r30, r24
    1a32:	20 81       	ld	r18, Z
    1a34:	31 81       	ldd	r19, Z+1	; 0x01
    1a36:	89 81       	ldd	r24, Y+1	; 0x01
    1a38:	9a 81       	ldd	r25, Y+2	; 0x02
    1a3a:	fc 01       	movw	r30, r24
    1a3c:	83 8d       	ldd	r24, Z+27	; 0x1b
    1a3e:	68 2f       	mov	r22, r24
    1a40:	70 e0       	ldi	r23, 0x00	; 0
    1a42:	89 81       	ldd	r24, Y+1	; 0x01
    1a44:	9a 81       	ldd	r25, Y+2	; 0x02
    1a46:	fc 01       	movw	r30, r24
    1a48:	84 8d       	ldd	r24, Z+28	; 0x1c
    1a4a:	48 2f       	mov	r20, r24
    1a4c:	50 e0       	ldi	r21, 0x00	; 0
    1a4e:	64 9f       	mul	r22, r20
    1a50:	c0 01       	movw	r24, r0
    1a52:	65 9f       	mul	r22, r21
    1a54:	90 0d       	add	r25, r0
    1a56:	74 9f       	mul	r23, r20
    1a58:	90 0d       	add	r25, r0
    1a5a:	11 24       	eor	r1, r1
    1a5c:	28 0f       	add	r18, r24
    1a5e:	39 1f       	adc	r19, r25
    1a60:	89 81       	ldd	r24, Y+1	; 0x01
    1a62:	9a 81       	ldd	r25, Y+2	; 0x02
    1a64:	fc 01       	movw	r30, r24
    1a66:	33 83       	std	Z+3, r19	; 0x03
    1a68:	22 83       	std	Z+2, r18	; 0x02
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1a6a:	89 81       	ldd	r24, Y+1	; 0x01
    1a6c:	9a 81       	ldd	r25, Y+2	; 0x02
    1a6e:	fc 01       	movw	r30, r24
    1a70:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1a72:	89 81       	ldd	r24, Y+1	; 0x01
    1a74:	9a 81       	ldd	r25, Y+2	; 0x02
    1a76:	fc 01       	movw	r30, r24
    1a78:	20 81       	ld	r18, Z
    1a7a:	31 81       	ldd	r19, Z+1	; 0x01
    1a7c:	89 81       	ldd	r24, Y+1	; 0x01
    1a7e:	9a 81       	ldd	r25, Y+2	; 0x02
    1a80:	fc 01       	movw	r30, r24
    1a82:	35 83       	std	Z+5, r19	; 0x05
    1a84:	24 83       	std	Z+4, r18	; 0x04
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
    1a86:	89 81       	ldd	r24, Y+1	; 0x01
    1a88:	9a 81       	ldd	r25, Y+2	; 0x02
    1a8a:	fc 01       	movw	r30, r24
    1a8c:	20 81       	ld	r18, Z
    1a8e:	31 81       	ldd	r19, Z+1	; 0x01
    1a90:	89 81       	ldd	r24, Y+1	; 0x01
    1a92:	9a 81       	ldd	r25, Y+2	; 0x02
    1a94:	fc 01       	movw	r30, r24
    1a96:	83 8d       	ldd	r24, Z+27	; 0x1b
    1a98:	88 2f       	mov	r24, r24
    1a9a:	90 e0       	ldi	r25, 0x00	; 0
    1a9c:	bc 01       	movw	r22, r24
    1a9e:	61 50       	subi	r22, 0x01	; 1
    1aa0:	71 09       	sbc	r23, r1
    1aa2:	89 81       	ldd	r24, Y+1	; 0x01
    1aa4:	9a 81       	ldd	r25, Y+2	; 0x02
    1aa6:	fc 01       	movw	r30, r24
    1aa8:	84 8d       	ldd	r24, Z+28	; 0x1c
    1aaa:	48 2f       	mov	r20, r24
    1aac:	50 e0       	ldi	r21, 0x00	; 0
    1aae:	64 9f       	mul	r22, r20
    1ab0:	c0 01       	movw	r24, r0
    1ab2:	65 9f       	mul	r22, r21
    1ab4:	90 0d       	add	r25, r0
    1ab6:	74 9f       	mul	r23, r20
    1ab8:	90 0d       	add	r25, r0
    1aba:	11 24       	eor	r1, r1
    1abc:	28 0f       	add	r18, r24
    1abe:	39 1f       	adc	r19, r25
    1ac0:	89 81       	ldd	r24, Y+1	; 0x01
    1ac2:	9a 81       	ldd	r25, Y+2	; 0x02
    1ac4:	fc 01       	movw	r30, r24
    1ac6:	37 83       	std	Z+7, r19	; 0x07
    1ac8:	26 83       	std	Z+6, r18	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    1aca:	89 81       	ldd	r24, Y+1	; 0x01
    1acc:	9a 81       	ldd	r25, Y+2	; 0x02
    1ace:	2f ef       	ldi	r18, 0xFF	; 255
    1ad0:	fc 01       	movw	r30, r24
    1ad2:	25 8f       	std	Z+29, r18	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    1ad4:	89 81       	ldd	r24, Y+1	; 0x01
    1ad6:	9a 81       	ldd	r25, Y+2	; 0x02
    1ad8:	2f ef       	ldi	r18, 0xFF	; 255
    1ada:	fc 01       	movw	r30, r24
    1adc:	26 8f       	std	Z+30, r18	; 0x1e

		if( xNewQueue == pdFALSE )
    1ade:	8b 81       	ldd	r24, Y+3	; 0x03
    1ae0:	88 23       	and	r24, r24
    1ae2:	81 f4       	brne	.+32     	; 0x1b04 <xQueueGenericReset+0xee>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to	write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1ae4:	89 81       	ldd	r24, Y+1	; 0x01
    1ae6:	9a 81       	ldd	r25, Y+2	; 0x02
    1ae8:	fc 01       	movw	r30, r24
    1aea:	80 85       	ldd	r24, Z+8	; 0x08
    1aec:	88 23       	and	r24, r24
    1aee:	a1 f0       	breq	.+40     	; 0x1b18 <xQueueGenericReset+0x102>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1af0:	89 81       	ldd	r24, Y+1	; 0x01
    1af2:	9a 81       	ldd	r25, Y+2	; 0x02
    1af4:	08 96       	adiw	r24, 0x08	; 8
    1af6:	0e 94 65 09 	call	0x12ca	; 0x12ca <xTaskRemoveFromEventList>
    1afa:	81 30       	cpi	r24, 0x01	; 1
    1afc:	69 f4       	brne	.+26     	; 0x1b18 <xQueueGenericReset+0x102>
				{
					portYIELD_WITHIN_API();
    1afe:	0e 94 92 19 	call	0x3324	; 0x3324 <vPortYield>
    1b02:	0a c0       	rjmp	.+20     	; 0x1b18 <xQueueGenericReset+0x102>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1b04:	89 81       	ldd	r24, Y+1	; 0x01
    1b06:	9a 81       	ldd	r25, Y+2	; 0x02
    1b08:	08 96       	adiw	r24, 0x08	; 8
    1b0a:	0e 94 b8 12 	call	0x2570	; 0x2570 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1b0e:	89 81       	ldd	r24, Y+1	; 0x01
    1b10:	9a 81       	ldd	r25, Y+2	; 0x02
    1b12:	41 96       	adiw	r24, 0x11	; 17
    1b14:	0e 94 b8 12 	call	0x2570	; 0x2570 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1b18:	0f 90       	pop	r0
    1b1a:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    1b1c:	81 e0       	ldi	r24, 0x01	; 1
}
    1b1e:	0f 90       	pop	r0
    1b20:	0f 90       	pop	r0
    1b22:	0f 90       	pop	r0
    1b24:	df 91       	pop	r29
    1b26:	cf 91       	pop	r28
    1b28:	08 95       	ret

00001b2a <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
    1b2a:	cf 93       	push	r28
    1b2c:	df 93       	push	r29
    1b2e:	cd b7       	in	r28, 0x3d	; 61
    1b30:	de b7       	in	r29, 0x3e	; 62
    1b32:	29 97       	sbiw	r28, 0x09	; 9
    1b34:	0f b6       	in	r0, 0x3f	; 63
    1b36:	f8 94       	cli
    1b38:	de bf       	out	0x3e, r29	; 62
    1b3a:	0f be       	out	0x3f, r0	; 63
    1b3c:	cd bf       	out	0x3d, r28	; 61
    1b3e:	8f 83       	std	Y+7, r24	; 0x07
    1b40:	68 87       	std	Y+8, r22	; 0x08
    1b42:	49 87       	std	Y+9, r20	; 0x09
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    1b44:	1a 82       	std	Y+2, r1	; 0x02
    1b46:	19 82       	std	Y+1, r1	; 0x01
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    1b48:	8f 81       	ldd	r24, Y+7	; 0x07
    1b4a:	88 23       	and	r24, r24
    1b4c:	09 f4       	brne	.+2      	; 0x1b50 <xQueueGenericCreate+0x26>
    1b4e:	43 c0       	rjmp	.+134    	; 0x1bd6 <xQueueGenericCreate+0xac>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    1b50:	8f e1       	ldi	r24, 0x1F	; 31
    1b52:	90 e0       	ldi	r25, 0x00	; 0
    1b54:	0e 94 1f 17 	call	0x2e3e	; 0x2e3e <pvPortMalloc>
    1b58:	9c 83       	std	Y+4, r25	; 0x04
    1b5a:	8b 83       	std	Y+3, r24	; 0x03
		if( pxNewQueue != NULL )
    1b5c:	8b 81       	ldd	r24, Y+3	; 0x03
    1b5e:	9c 81       	ldd	r25, Y+4	; 0x04
    1b60:	00 97       	sbiw	r24, 0x00	; 0
    1b62:	c9 f1       	breq	.+114    	; 0x1bd6 <xQueueGenericCreate+0xac>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    1b64:	8f 81       	ldd	r24, Y+7	; 0x07
    1b66:	48 2f       	mov	r20, r24
    1b68:	50 e0       	ldi	r21, 0x00	; 0
    1b6a:	88 85       	ldd	r24, Y+8	; 0x08
    1b6c:	28 2f       	mov	r18, r24
    1b6e:	30 e0       	ldi	r19, 0x00	; 0
    1b70:	42 9f       	mul	r20, r18
    1b72:	c0 01       	movw	r24, r0
    1b74:	43 9f       	mul	r20, r19
    1b76:	90 0d       	add	r25, r0
    1b78:	52 9f       	mul	r21, r18
    1b7a:	90 0d       	add	r25, r0
    1b7c:	11 24       	eor	r1, r1
    1b7e:	01 96       	adiw	r24, 0x01	; 1
    1b80:	9e 83       	std	Y+6, r25	; 0x06
    1b82:	8d 83       	std	Y+5, r24	; 0x05

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    1b84:	8d 81       	ldd	r24, Y+5	; 0x05
    1b86:	9e 81       	ldd	r25, Y+6	; 0x06
    1b88:	0e 94 1f 17 	call	0x2e3e	; 0x2e3e <pvPortMalloc>
    1b8c:	9c 01       	movw	r18, r24
    1b8e:	8b 81       	ldd	r24, Y+3	; 0x03
    1b90:	9c 81       	ldd	r25, Y+4	; 0x04
    1b92:	fc 01       	movw	r30, r24
    1b94:	31 83       	std	Z+1, r19	; 0x01
    1b96:	20 83       	st	Z, r18
			if( pxNewQueue->pcHead != NULL )
    1b98:	8b 81       	ldd	r24, Y+3	; 0x03
    1b9a:	9c 81       	ldd	r25, Y+4	; 0x04
    1b9c:	fc 01       	movw	r30, r24
    1b9e:	80 81       	ld	r24, Z
    1ba0:	91 81       	ldd	r25, Z+1	; 0x01
    1ba2:	00 97       	sbiw	r24, 0x00	; 0
    1ba4:	a1 f0       	breq	.+40     	; 0x1bce <xQueueGenericCreate+0xa4>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    1ba6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ba8:	9c 81       	ldd	r25, Y+4	; 0x04
    1baa:	2f 81       	ldd	r18, Y+7	; 0x07
    1bac:	fc 01       	movw	r30, r24
    1bae:	23 8f       	std	Z+27, r18	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1bb0:	8b 81       	ldd	r24, Y+3	; 0x03
    1bb2:	9c 81       	ldd	r25, Y+4	; 0x04
    1bb4:	28 85       	ldd	r18, Y+8	; 0x08
    1bb6:	fc 01       	movw	r30, r24
    1bb8:	24 8f       	std	Z+28, r18	; 0x1c
				xQueueGenericReset( pxNewQueue, pdTRUE );
    1bba:	8b 81       	ldd	r24, Y+3	; 0x03
    1bbc:	9c 81       	ldd	r25, Y+4	; 0x04
    1bbe:	61 e0       	ldi	r22, 0x01	; 1
    1bc0:	0e 94 0b 0d 	call	0x1a16	; 0x1a16 <xQueueGenericReset>
					pxNewQueue->ucQueueType = ucQueueType;
				}
				#endif /* configUSE_TRACE_FACILITY */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    1bc4:	8b 81       	ldd	r24, Y+3	; 0x03
    1bc6:	9c 81       	ldd	r25, Y+4	; 0x04
    1bc8:	9a 83       	std	Y+2, r25	; 0x02
    1bca:	89 83       	std	Y+1, r24	; 0x01
    1bcc:	04 c0       	rjmp	.+8      	; 0x1bd6 <xQueueGenericCreate+0xac>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    1bce:	8b 81       	ldd	r24, Y+3	; 0x03
    1bd0:	9c 81       	ldd	r25, Y+4	; 0x04
    1bd2:	0e 94 65 17 	call	0x2eca	; 0x2eca <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    1bd6:	89 81       	ldd	r24, Y+1	; 0x01
    1bd8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1bda:	29 96       	adiw	r28, 0x09	; 9
    1bdc:	0f b6       	in	r0, 0x3f	; 63
    1bde:	f8 94       	cli
    1be0:	de bf       	out	0x3e, r29	; 62
    1be2:	0f be       	out	0x3f, r0	; 63
    1be4:	cd bf       	out	0x3d, r28	; 61
    1be6:	df 91       	pop	r29
    1be8:	cf 91       	pop	r28
    1bea:	08 95       	ret

00001bec <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
	{
    1bec:	cf 93       	push	r28
    1bee:	df 93       	push	r29
    1bf0:	00 d0       	rcall	.+0      	; 0x1bf2 <xQueueCreateMutex+0x6>
    1bf2:	cd b7       	in	r28, 0x3d	; 61
    1bf4:	de b7       	in	r29, 0x3e	; 62
    1bf6:	8b 83       	std	Y+3, r24	; 0x03
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    1bf8:	8f e1       	ldi	r24, 0x1F	; 31
    1bfa:	90 e0       	ldi	r25, 0x00	; 0
    1bfc:	0e 94 1f 17 	call	0x2e3e	; 0x2e3e <pvPortMalloc>
    1c00:	9a 83       	std	Y+2, r25	; 0x02
    1c02:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    1c04:	89 81       	ldd	r24, Y+1	; 0x01
    1c06:	9a 81       	ldd	r25, Y+2	; 0x02
    1c08:	00 97       	sbiw	r24, 0x00	; 0
    1c0a:	f1 f1       	breq	.+124    	; 0x1c88 <xQueueCreateMutex+0x9c>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    1c0c:	89 81       	ldd	r24, Y+1	; 0x01
    1c0e:	9a 81       	ldd	r25, Y+2	; 0x02
    1c10:	fc 01       	movw	r30, r24
    1c12:	13 82       	std	Z+3, r1	; 0x03
    1c14:	12 82       	std	Z+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    1c16:	89 81       	ldd	r24, Y+1	; 0x01
    1c18:	9a 81       	ldd	r25, Y+2	; 0x02
    1c1a:	fc 01       	movw	r30, r24
    1c1c:	11 82       	std	Z+1, r1	; 0x01
    1c1e:	10 82       	st	Z, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    1c20:	89 81       	ldd	r24, Y+1	; 0x01
    1c22:	9a 81       	ldd	r25, Y+2	; 0x02
    1c24:	fc 01       	movw	r30, r24
    1c26:	15 82       	std	Z+5, r1	; 0x05
    1c28:	14 82       	std	Z+4, r1	; 0x04
			pxNewQueue->pcReadFrom = NULL;
    1c2a:	89 81       	ldd	r24, Y+1	; 0x01
    1c2c:	9a 81       	ldd	r25, Y+2	; 0x02
    1c2e:	fc 01       	movw	r30, r24
    1c30:	17 82       	std	Z+7, r1	; 0x07
    1c32:	16 82       	std	Z+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1c34:	89 81       	ldd	r24, Y+1	; 0x01
    1c36:	9a 81       	ldd	r25, Y+2	; 0x02
    1c38:	fc 01       	movw	r30, r24
    1c3a:	12 8e       	std	Z+26, r1	; 0x1a
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
    1c3c:	89 81       	ldd	r24, Y+1	; 0x01
    1c3e:	9a 81       	ldd	r25, Y+2	; 0x02
    1c40:	21 e0       	ldi	r18, 0x01	; 1
    1c42:	fc 01       	movw	r30, r24
    1c44:	23 8f       	std	Z+27, r18	; 0x1b
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
    1c46:	89 81       	ldd	r24, Y+1	; 0x01
    1c48:	9a 81       	ldd	r25, Y+2	; 0x02
    1c4a:	fc 01       	movw	r30, r24
    1c4c:	14 8e       	std	Z+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    1c4e:	89 81       	ldd	r24, Y+1	; 0x01
    1c50:	9a 81       	ldd	r25, Y+2	; 0x02
    1c52:	2f ef       	ldi	r18, 0xFF	; 255
    1c54:	fc 01       	movw	r30, r24
    1c56:	25 8f       	std	Z+29, r18	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    1c58:	89 81       	ldd	r24, Y+1	; 0x01
    1c5a:	9a 81       	ldd	r25, Y+2	; 0x02
    1c5c:	2f ef       	ldi	r18, 0xFF	; 255
    1c5e:	fc 01       	movw	r30, r24
    1c60:	26 8f       	std	Z+30, r18	; 0x1e
				pxNewQueue->ucQueueType = ucQueueType;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1c62:	89 81       	ldd	r24, Y+1	; 0x01
    1c64:	9a 81       	ldd	r25, Y+2	; 0x02
    1c66:	08 96       	adiw	r24, 0x08	; 8
    1c68:	0e 94 b8 12 	call	0x2570	; 0x2570 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1c6c:	89 81       	ldd	r24, Y+1	; 0x01
    1c6e:	9a 81       	ldd	r25, Y+2	; 0x02
    1c70:	41 96       	adiw	r24, 0x11	; 17
    1c72:	0e 94 b8 12 	call	0x2570	; 0x2570 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
    1c76:	89 81       	ldd	r24, Y+1	; 0x01
    1c78:	9a 81       	ldd	r25, Y+2	; 0x02
    1c7a:	20 e0       	ldi	r18, 0x00	; 0
    1c7c:	40 e0       	ldi	r20, 0x00	; 0
    1c7e:	50 e0       	ldi	r21, 0x00	; 0
    1c80:	60 e0       	ldi	r22, 0x00	; 0
    1c82:	70 e0       	ldi	r23, 0x00	; 0
    1c84:	0e 94 4c 0e 	call	0x1c98	; 0x1c98 <xQueueGenericSend>
		{
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
    1c88:	89 81       	ldd	r24, Y+1	; 0x01
    1c8a:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    1c8c:	0f 90       	pop	r0
    1c8e:	0f 90       	pop	r0
    1c90:	0f 90       	pop	r0
    1c92:	df 91       	pop	r29
    1c94:	cf 91       	pop	r28
    1c96:	08 95       	ret

00001c98 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    1c98:	cf 93       	push	r28
    1c9a:	df 93       	push	r29
    1c9c:	cd b7       	in	r28, 0x3d	; 61
    1c9e:	de b7       	in	r29, 0x3e	; 62
    1ca0:	2b 97       	sbiw	r28, 0x0b	; 11
    1ca2:	0f b6       	in	r0, 0x3f	; 63
    1ca4:	f8 94       	cli
    1ca6:	de bf       	out	0x3e, r29	; 62
    1ca8:	0f be       	out	0x3f, r0	; 63
    1caa:	cd bf       	out	0x3d, r28	; 61
    1cac:	9e 83       	std	Y+6, r25	; 0x06
    1cae:	8d 83       	std	Y+5, r24	; 0x05
    1cb0:	78 87       	std	Y+8, r23	; 0x08
    1cb2:	6f 83       	std	Y+7, r22	; 0x07
    1cb4:	5a 87       	std	Y+10, r21	; 0x0a
    1cb6:	49 87       	std	Y+9, r20	; 0x09
    1cb8:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1cba:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1cbc:	0f b6       	in	r0, 0x3f	; 63
    1cbe:	f8 94       	cli
    1cc0:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1cc2:	8d 81       	ldd	r24, Y+5	; 0x05
    1cc4:	9e 81       	ldd	r25, Y+6	; 0x06
    1cc6:	fc 01       	movw	r30, r24
    1cc8:	22 8d       	ldd	r18, Z+26	; 0x1a
    1cca:	8d 81       	ldd	r24, Y+5	; 0x05
    1ccc:	9e 81       	ldd	r25, Y+6	; 0x06
    1cce:	fc 01       	movw	r30, r24
    1cd0:	83 8d       	ldd	r24, Z+27	; 0x1b
    1cd2:	28 17       	cp	r18, r24
    1cd4:	d8 f4       	brcc	.+54     	; 0x1d0c <xQueueGenericSend+0x74>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1cd6:	2f 81       	ldd	r18, Y+7	; 0x07
    1cd8:	38 85       	ldd	r19, Y+8	; 0x08
    1cda:	8d 81       	ldd	r24, Y+5	; 0x05
    1cdc:	9e 81       	ldd	r25, Y+6	; 0x06
    1cde:	4b 85       	ldd	r20, Y+11	; 0x0b
    1ce0:	b9 01       	movw	r22, r18
    1ce2:	0e 94 d6 10 	call	0x21ac	; 0x21ac <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1ce6:	8d 81       	ldd	r24, Y+5	; 0x05
    1ce8:	9e 81       	ldd	r25, Y+6	; 0x06
    1cea:	fc 01       	movw	r30, r24
    1cec:	81 89       	ldd	r24, Z+17	; 0x11
    1cee:	88 23       	and	r24, r24
    1cf0:	49 f0       	breq	.+18     	; 0x1d04 <xQueueGenericSend+0x6c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1cf2:	8d 81       	ldd	r24, Y+5	; 0x05
    1cf4:	9e 81       	ldd	r25, Y+6	; 0x06
    1cf6:	41 96       	adiw	r24, 0x11	; 17
    1cf8:	0e 94 65 09 	call	0x12ca	; 0x12ca <xTaskRemoveFromEventList>
    1cfc:	81 30       	cpi	r24, 0x01	; 1
    1cfe:	11 f4       	brne	.+4      	; 0x1d04 <xQueueGenericSend+0x6c>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    1d00:	0e 94 92 19 	call	0x3324	; 0x3324 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    1d04:	0f 90       	pop	r0
    1d06:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    1d08:	81 e0       	ldi	r24, 0x01	; 1
    1d0a:	61 c0       	rjmp	.+194    	; 0x1dce <xQueueGenericSend+0x136>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1d0c:	89 85       	ldd	r24, Y+9	; 0x09
    1d0e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1d10:	00 97       	sbiw	r24, 0x00	; 0
    1d12:	21 f4       	brne	.+8      	; 0x1d1c <xQueueGenericSend+0x84>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1d14:	0f 90       	pop	r0
    1d16:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1d18:	80 e0       	ldi	r24, 0x00	; 0
    1d1a:	59 c0       	rjmp	.+178    	; 0x1dce <xQueueGenericSend+0x136>
				}
				else if( xEntryTimeSet == pdFALSE )
    1d1c:	89 81       	ldd	r24, Y+1	; 0x01
    1d1e:	88 23       	and	r24, r24
    1d20:	31 f4       	brne	.+12     	; 0x1d2e <xQueueGenericSend+0x96>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1d22:	ce 01       	movw	r24, r28
    1d24:	02 96       	adiw	r24, 0x02	; 2
    1d26:	0e 94 cf 09 	call	0x139e	; 0x139e <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1d2a:	81 e0       	ldi	r24, 0x01	; 1
    1d2c:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    1d2e:	0f 90       	pop	r0
    1d30:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1d32:	0e 94 f1 06 	call	0xde2	; 0xde2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1d36:	0f b6       	in	r0, 0x3f	; 63
    1d38:	f8 94       	cli
    1d3a:	0f 92       	push	r0
    1d3c:	8d 81       	ldd	r24, Y+5	; 0x05
    1d3e:	9e 81       	ldd	r25, Y+6	; 0x06
    1d40:	fc 01       	movw	r30, r24
    1d42:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d44:	8f 3f       	cpi	r24, 0xFF	; 255
    1d46:	21 f4       	brne	.+8      	; 0x1d50 <xQueueGenericSend+0xb8>
    1d48:	8d 81       	ldd	r24, Y+5	; 0x05
    1d4a:	9e 81       	ldd	r25, Y+6	; 0x06
    1d4c:	fc 01       	movw	r30, r24
    1d4e:	15 8e       	std	Z+29, r1	; 0x1d
    1d50:	8d 81       	ldd	r24, Y+5	; 0x05
    1d52:	9e 81       	ldd	r25, Y+6	; 0x06
    1d54:	fc 01       	movw	r30, r24
    1d56:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d58:	8f 3f       	cpi	r24, 0xFF	; 255
    1d5a:	21 f4       	brne	.+8      	; 0x1d64 <xQueueGenericSend+0xcc>
    1d5c:	8d 81       	ldd	r24, Y+5	; 0x05
    1d5e:	9e 81       	ldd	r25, Y+6	; 0x06
    1d60:	fc 01       	movw	r30, r24
    1d62:	16 8e       	std	Z+30, r1	; 0x1e
    1d64:	0f 90       	pop	r0
    1d66:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1d68:	9e 01       	movw	r18, r28
    1d6a:	27 5f       	subi	r18, 0xF7	; 247
    1d6c:	3f 4f       	sbci	r19, 0xFF	; 255
    1d6e:	ce 01       	movw	r24, r28
    1d70:	02 96       	adiw	r24, 0x02	; 2
    1d72:	b9 01       	movw	r22, r18
    1d74:	0e 94 eb 09 	call	0x13d6	; 0x13d6 <xTaskCheckForTimeOut>
    1d78:	88 23       	and	r24, r24
    1d7a:	01 f5       	brne	.+64     	; 0x1dbc <xQueueGenericSend+0x124>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1d7c:	8d 81       	ldd	r24, Y+5	; 0x05
    1d7e:	9e 81       	ldd	r25, Y+6	; 0x06
    1d80:	0e 94 7d 12 	call	0x24fa	; 0x24fa <prvIsQueueFull>
    1d84:	88 23       	and	r24, r24
    1d86:	99 f0       	breq	.+38     	; 0x1dae <xQueueGenericSend+0x116>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1d88:	29 85       	ldd	r18, Y+9	; 0x09
    1d8a:	3a 85       	ldd	r19, Y+10	; 0x0a
    1d8c:	8d 81       	ldd	r24, Y+5	; 0x05
    1d8e:	9e 81       	ldd	r25, Y+6	; 0x06
    1d90:	08 96       	adiw	r24, 0x08	; 8
    1d92:	b9 01       	movw	r22, r18
    1d94:	0e 94 20 09 	call	0x1240	; 0x1240 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1d98:	8d 81       	ldd	r24, Y+5	; 0x05
    1d9a:	9e 81       	ldd	r25, Y+6	; 0x06
    1d9c:	0e 94 e5 11 	call	0x23ca	; 0x23ca <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1da0:	0e 94 fd 06 	call	0xdfa	; 0xdfa <xTaskResumeAll>
    1da4:	88 23       	and	r24, r24
    1da6:	91 f4       	brne	.+36     	; 0x1dcc <xQueueGenericSend+0x134>
				{
					portYIELD_WITHIN_API();
    1da8:	0e 94 92 19 	call	0x3324	; 0x3324 <vPortYield>
    1dac:	0f c0       	rjmp	.+30     	; 0x1dcc <xQueueGenericSend+0x134>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1dae:	8d 81       	ldd	r24, Y+5	; 0x05
    1db0:	9e 81       	ldd	r25, Y+6	; 0x06
    1db2:	0e 94 e5 11 	call	0x23ca	; 0x23ca <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1db6:	0e 94 fd 06 	call	0xdfa	; 0xdfa <xTaskResumeAll>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
    1dba:	80 cf       	rjmp	.-256    	; 0x1cbc <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1dbc:	8d 81       	ldd	r24, Y+5	; 0x05
    1dbe:	9e 81       	ldd	r25, Y+6	; 0x06
    1dc0:	0e 94 e5 11 	call	0x23ca	; 0x23ca <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1dc4:	0e 94 fd 06 	call	0xdfa	; 0xdfa <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1dc8:	80 e0       	ldi	r24, 0x00	; 0
    1dca:	01 c0       	rjmp	.+2      	; 0x1dce <xQueueGenericSend+0x136>
		}
	}
    1dcc:	77 cf       	rjmp	.-274    	; 0x1cbc <xQueueGenericSend+0x24>
}
    1dce:	2b 96       	adiw	r28, 0x0b	; 11
    1dd0:	0f b6       	in	r0, 0x3f	; 63
    1dd2:	f8 94       	cli
    1dd4:	de bf       	out	0x3e, r29	; 62
    1dd6:	0f be       	out	0x3f, r0	; 63
    1dd8:	cd bf       	out	0x3d, r28	; 61
    1dda:	df 91       	pop	r29
    1ddc:	cf 91       	pop	r28
    1dde:	08 95       	ret

00001de0 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1de0:	cf 93       	push	r28
    1de2:	df 93       	push	r29
    1de4:	cd b7       	in	r28, 0x3d	; 61
    1de6:	de b7       	in	r29, 0x3e	; 62
    1de8:	29 97       	sbiw	r28, 0x09	; 9
    1dea:	0f b6       	in	r0, 0x3f	; 63
    1dec:	f8 94       	cli
    1dee:	de bf       	out	0x3e, r29	; 62
    1df0:	0f be       	out	0x3f, r0	; 63
    1df2:	cd bf       	out	0x3d, r28	; 61
    1df4:	9c 83       	std	Y+4, r25	; 0x04
    1df6:	8b 83       	std	Y+3, r24	; 0x03
    1df8:	7e 83       	std	Y+6, r23	; 0x06
    1dfa:	6d 83       	std	Y+5, r22	; 0x05
    1dfc:	58 87       	std	Y+8, r21	; 0x08
    1dfe:	4f 83       	std	Y+7, r20	; 0x07
    1e00:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1e02:	1a 82       	std	Y+2, r1	; 0x02
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1e04:	8b 81       	ldd	r24, Y+3	; 0x03
    1e06:	9c 81       	ldd	r25, Y+4	; 0x04
    1e08:	fc 01       	movw	r30, r24
    1e0a:	22 8d       	ldd	r18, Z+26	; 0x1a
    1e0c:	8b 81       	ldd	r24, Y+3	; 0x03
    1e0e:	9c 81       	ldd	r25, Y+4	; 0x04
    1e10:	fc 01       	movw	r30, r24
    1e12:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e14:	28 17       	cp	r18, r24
    1e16:	90 f5       	brcc	.+100    	; 0x1e7c <xQueueGenericSendFromISR+0x9c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1e18:	2d 81       	ldd	r18, Y+5	; 0x05
    1e1a:	3e 81       	ldd	r19, Y+6	; 0x06
    1e1c:	8b 81       	ldd	r24, Y+3	; 0x03
    1e1e:	9c 81       	ldd	r25, Y+4	; 0x04
    1e20:	49 85       	ldd	r20, Y+9	; 0x09
    1e22:	b9 01       	movw	r22, r18
    1e24:	0e 94 d6 10 	call	0x21ac	; 0x21ac <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1e28:	8b 81       	ldd	r24, Y+3	; 0x03
    1e2a:	9c 81       	ldd	r25, Y+4	; 0x04
    1e2c:	fc 01       	movw	r30, r24
    1e2e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e30:	8f 3f       	cpi	r24, 0xFF	; 255
    1e32:	b9 f4       	brne	.+46     	; 0x1e62 <xQueueGenericSendFromISR+0x82>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1e34:	8b 81       	ldd	r24, Y+3	; 0x03
    1e36:	9c 81       	ldd	r25, Y+4	; 0x04
    1e38:	fc 01       	movw	r30, r24
    1e3a:	81 89       	ldd	r24, Z+17	; 0x11
    1e3c:	88 23       	and	r24, r24
    1e3e:	d9 f0       	breq	.+54     	; 0x1e76 <xQueueGenericSendFromISR+0x96>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1e40:	8b 81       	ldd	r24, Y+3	; 0x03
    1e42:	9c 81       	ldd	r25, Y+4	; 0x04
    1e44:	41 96       	adiw	r24, 0x11	; 17
    1e46:	0e 94 65 09 	call	0x12ca	; 0x12ca <xTaskRemoveFromEventList>
    1e4a:	88 23       	and	r24, r24
    1e4c:	a1 f0       	breq	.+40     	; 0x1e76 <xQueueGenericSendFromISR+0x96>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						if( pxHigherPriorityTaskWoken != NULL )
    1e4e:	8f 81       	ldd	r24, Y+7	; 0x07
    1e50:	98 85       	ldd	r25, Y+8	; 0x08
    1e52:	00 97       	sbiw	r24, 0x00	; 0
    1e54:	81 f0       	breq	.+32     	; 0x1e76 <xQueueGenericSendFromISR+0x96>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1e56:	8f 81       	ldd	r24, Y+7	; 0x07
    1e58:	98 85       	ldd	r25, Y+8	; 0x08
    1e5a:	21 e0       	ldi	r18, 0x01	; 1
    1e5c:	fc 01       	movw	r30, r24
    1e5e:	20 83       	st	Z, r18
    1e60:	0a c0       	rjmp	.+20     	; 0x1e76 <xQueueGenericSendFromISR+0x96>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1e62:	8b 81       	ldd	r24, Y+3	; 0x03
    1e64:	9c 81       	ldd	r25, Y+4	; 0x04
    1e66:	fc 01       	movw	r30, r24
    1e68:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e6a:	21 e0       	ldi	r18, 0x01	; 1
    1e6c:	28 0f       	add	r18, r24
    1e6e:	8b 81       	ldd	r24, Y+3	; 0x03
    1e70:	9c 81       	ldd	r25, Y+4	; 0x04
    1e72:	fc 01       	movw	r30, r24
    1e74:	26 8f       	std	Z+30, r18	; 0x1e
			}

			xReturn = pdPASS;
    1e76:	81 e0       	ldi	r24, 0x01	; 1
    1e78:	89 83       	std	Y+1, r24	; 0x01
    1e7a:	01 c0       	rjmp	.+2      	; 0x1e7e <xQueueGenericSendFromISR+0x9e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1e7c:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1e7e:	89 81       	ldd	r24, Y+1	; 0x01
}
    1e80:	29 96       	adiw	r28, 0x09	; 9
    1e82:	0f b6       	in	r0, 0x3f	; 63
    1e84:	f8 94       	cli
    1e86:	de bf       	out	0x3e, r29	; 62
    1e88:	0f be       	out	0x3f, r0	; 63
    1e8a:	cd bf       	out	0x3d, r28	; 61
    1e8c:	df 91       	pop	r29
    1e8e:	cf 91       	pop	r28
    1e90:	08 95       	ret

00001e92 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1e92:	cf 93       	push	r28
    1e94:	df 93       	push	r29
    1e96:	cd b7       	in	r28, 0x3d	; 61
    1e98:	de b7       	in	r29, 0x3e	; 62
    1e9a:	2d 97       	sbiw	r28, 0x0d	; 13
    1e9c:	0f b6       	in	r0, 0x3f	; 63
    1e9e:	f8 94       	cli
    1ea0:	de bf       	out	0x3e, r29	; 62
    1ea2:	0f be       	out	0x3f, r0	; 63
    1ea4:	cd bf       	out	0x3d, r28	; 61
    1ea6:	98 87       	std	Y+8, r25	; 0x08
    1ea8:	8f 83       	std	Y+7, r24	; 0x07
    1eaa:	7a 87       	std	Y+10, r23	; 0x0a
    1eac:	69 87       	std	Y+9, r22	; 0x09
    1eae:	5c 87       	std	Y+12, r21	; 0x0c
    1eb0:	4b 87       	std	Y+11, r20	; 0x0b
    1eb2:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1eb4:	19 82       	std	Y+1, r1	; 0x01
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1eb6:	0f b6       	in	r0, 0x3f	; 63
    1eb8:	f8 94       	cli
    1eba:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1ebc:	8f 81       	ldd	r24, Y+7	; 0x07
    1ebe:	98 85       	ldd	r25, Y+8	; 0x08
    1ec0:	fc 01       	movw	r30, r24
    1ec2:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ec4:	88 23       	and	r24, r24
    1ec6:	09 f4       	brne	.+2      	; 0x1eca <xQueueGenericReceive+0x38>
    1ec8:	54 c0       	rjmp	.+168    	; 0x1f72 <xQueueGenericReceive+0xe0>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1eca:	8f 81       	ldd	r24, Y+7	; 0x07
    1ecc:	98 85       	ldd	r25, Y+8	; 0x08
    1ece:	fc 01       	movw	r30, r24
    1ed0:	86 81       	ldd	r24, Z+6	; 0x06
    1ed2:	97 81       	ldd	r25, Z+7	; 0x07
    1ed4:	9b 83       	std	Y+3, r25	; 0x03
    1ed6:	8a 83       	std	Y+2, r24	; 0x02

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1ed8:	29 85       	ldd	r18, Y+9	; 0x09
    1eda:	3a 85       	ldd	r19, Y+10	; 0x0a
    1edc:	8f 81       	ldd	r24, Y+7	; 0x07
    1ede:	98 85       	ldd	r25, Y+8	; 0x08
    1ee0:	b9 01       	movw	r22, r18
    1ee2:	0e 94 94 11 	call	0x2328	; 0x2328 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1ee6:	8d 85       	ldd	r24, Y+13	; 0x0d
    1ee8:	88 23       	and	r24, r24
    1eea:	49 f5       	brne	.+82     	; 0x1f3e <xQueueGenericReceive+0xac>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1eec:	8f 81       	ldd	r24, Y+7	; 0x07
    1eee:	98 85       	ldd	r25, Y+8	; 0x08
    1ef0:	fc 01       	movw	r30, r24
    1ef2:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ef4:	2f ef       	ldi	r18, 0xFF	; 255
    1ef6:	28 0f       	add	r18, r24
    1ef8:	8f 81       	ldd	r24, Y+7	; 0x07
    1efa:	98 85       	ldd	r25, Y+8	; 0x08
    1efc:	fc 01       	movw	r30, r24
    1efe:	22 8f       	std	Z+26, r18	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1f00:	8f 81       	ldd	r24, Y+7	; 0x07
    1f02:	98 85       	ldd	r25, Y+8	; 0x08
    1f04:	fc 01       	movw	r30, r24
    1f06:	80 81       	ld	r24, Z
    1f08:	91 81       	ldd	r25, Z+1	; 0x01
    1f0a:	00 97       	sbiw	r24, 0x00	; 0
    1f0c:	41 f4       	brne	.+16     	; 0x1f1e <xQueueGenericReceive+0x8c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    1f0e:	0e 94 02 0c 	call	0x1804	; 0x1804 <xTaskGetCurrentTaskHandle>
    1f12:	9c 01       	movw	r18, r24
    1f14:	8f 81       	ldd	r24, Y+7	; 0x07
    1f16:	98 85       	ldd	r25, Y+8	; 0x08
    1f18:	fc 01       	movw	r30, r24
    1f1a:	33 83       	std	Z+3, r19	; 0x03
    1f1c:	22 83       	std	Z+2, r18	; 0x02
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1f1e:	8f 81       	ldd	r24, Y+7	; 0x07
    1f20:	98 85       	ldd	r25, Y+8	; 0x08
    1f22:	fc 01       	movw	r30, r24
    1f24:	80 85       	ldd	r24, Z+8	; 0x08
    1f26:	88 23       	and	r24, r24
    1f28:	01 f1       	breq	.+64     	; 0x1f6a <xQueueGenericReceive+0xd8>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1f2a:	8f 81       	ldd	r24, Y+7	; 0x07
    1f2c:	98 85       	ldd	r25, Y+8	; 0x08
    1f2e:	08 96       	adiw	r24, 0x08	; 8
    1f30:	0e 94 65 09 	call	0x12ca	; 0x12ca <xTaskRemoveFromEventList>
    1f34:	81 30       	cpi	r24, 0x01	; 1
    1f36:	c9 f4       	brne	.+50     	; 0x1f6a <xQueueGenericReceive+0xd8>
						{
							portYIELD_WITHIN_API();
    1f38:	0e 94 92 19 	call	0x3324	; 0x3324 <vPortYield>
    1f3c:	16 c0       	rjmp	.+44     	; 0x1f6a <xQueueGenericReceive+0xd8>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1f3e:	8f 81       	ldd	r24, Y+7	; 0x07
    1f40:	98 85       	ldd	r25, Y+8	; 0x08
    1f42:	2a 81       	ldd	r18, Y+2	; 0x02
    1f44:	3b 81       	ldd	r19, Y+3	; 0x03
    1f46:	fc 01       	movw	r30, r24
    1f48:	37 83       	std	Z+7, r19	; 0x07
    1f4a:	26 83       	std	Z+6, r18	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1f4c:	8f 81       	ldd	r24, Y+7	; 0x07
    1f4e:	98 85       	ldd	r25, Y+8	; 0x08
    1f50:	fc 01       	movw	r30, r24
    1f52:	81 89       	ldd	r24, Z+17	; 0x11
    1f54:	88 23       	and	r24, r24
    1f56:	49 f0       	breq	.+18     	; 0x1f6a <xQueueGenericReceive+0xd8>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1f58:	8f 81       	ldd	r24, Y+7	; 0x07
    1f5a:	98 85       	ldd	r25, Y+8	; 0x08
    1f5c:	41 96       	adiw	r24, 0x11	; 17
    1f5e:	0e 94 65 09 	call	0x12ca	; 0x12ca <xTaskRemoveFromEventList>
    1f62:	88 23       	and	r24, r24
    1f64:	11 f0       	breq	.+4      	; 0x1f6a <xQueueGenericReceive+0xd8>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1f66:	0e 94 92 19 	call	0x3324	; 0x3324 <vPortYield>
						}
					}
				}

				taskEXIT_CRITICAL();
    1f6a:	0f 90       	pop	r0
    1f6c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1f6e:	81 e0       	ldi	r24, 0x01	; 1
    1f70:	74 c0       	rjmp	.+232    	; 0x205a <xQueueGenericReceive+0x1c8>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1f72:	8b 85       	ldd	r24, Y+11	; 0x0b
    1f74:	9c 85       	ldd	r25, Y+12	; 0x0c
    1f76:	00 97       	sbiw	r24, 0x00	; 0
    1f78:	21 f4       	brne	.+8      	; 0x1f82 <xQueueGenericReceive+0xf0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1f7a:	0f 90       	pop	r0
    1f7c:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1f7e:	80 e0       	ldi	r24, 0x00	; 0
    1f80:	6c c0       	rjmp	.+216    	; 0x205a <xQueueGenericReceive+0x1c8>
				}
				else if( xEntryTimeSet == pdFALSE )
    1f82:	89 81       	ldd	r24, Y+1	; 0x01
    1f84:	88 23       	and	r24, r24
    1f86:	31 f4       	brne	.+12     	; 0x1f94 <xQueueGenericReceive+0x102>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1f88:	ce 01       	movw	r24, r28
    1f8a:	04 96       	adiw	r24, 0x04	; 4
    1f8c:	0e 94 cf 09 	call	0x139e	; 0x139e <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1f90:	81 e0       	ldi	r24, 0x01	; 1
    1f92:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    1f94:	0f 90       	pop	r0
    1f96:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1f98:	0e 94 f1 06 	call	0xde2	; 0xde2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1f9c:	0f b6       	in	r0, 0x3f	; 63
    1f9e:	f8 94       	cli
    1fa0:	0f 92       	push	r0
    1fa2:	8f 81       	ldd	r24, Y+7	; 0x07
    1fa4:	98 85       	ldd	r25, Y+8	; 0x08
    1fa6:	fc 01       	movw	r30, r24
    1fa8:	85 8d       	ldd	r24, Z+29	; 0x1d
    1faa:	8f 3f       	cpi	r24, 0xFF	; 255
    1fac:	21 f4       	brne	.+8      	; 0x1fb6 <xQueueGenericReceive+0x124>
    1fae:	8f 81       	ldd	r24, Y+7	; 0x07
    1fb0:	98 85       	ldd	r25, Y+8	; 0x08
    1fb2:	fc 01       	movw	r30, r24
    1fb4:	15 8e       	std	Z+29, r1	; 0x1d
    1fb6:	8f 81       	ldd	r24, Y+7	; 0x07
    1fb8:	98 85       	ldd	r25, Y+8	; 0x08
    1fba:	fc 01       	movw	r30, r24
    1fbc:	86 8d       	ldd	r24, Z+30	; 0x1e
    1fbe:	8f 3f       	cpi	r24, 0xFF	; 255
    1fc0:	21 f4       	brne	.+8      	; 0x1fca <xQueueGenericReceive+0x138>
    1fc2:	8f 81       	ldd	r24, Y+7	; 0x07
    1fc4:	98 85       	ldd	r25, Y+8	; 0x08
    1fc6:	fc 01       	movw	r30, r24
    1fc8:	16 8e       	std	Z+30, r1	; 0x1e
    1fca:	0f 90       	pop	r0
    1fcc:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1fce:	9e 01       	movw	r18, r28
    1fd0:	25 5f       	subi	r18, 0xF5	; 245
    1fd2:	3f 4f       	sbci	r19, 0xFF	; 255
    1fd4:	ce 01       	movw	r24, r28
    1fd6:	04 96       	adiw	r24, 0x04	; 4
    1fd8:	b9 01       	movw	r22, r18
    1fda:	0e 94 eb 09 	call	0x13d6	; 0x13d6 <xTaskCheckForTimeOut>
    1fde:	88 23       	and	r24, r24
    1fe0:	99 f5       	brne	.+102    	; 0x2048 <xQueueGenericReceive+0x1b6>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1fe2:	8f 81       	ldd	r24, Y+7	; 0x07
    1fe4:	98 85       	ldd	r25, Y+8	; 0x08
    1fe6:	0e 94 4a 12 	call	0x2494	; 0x2494 <prvIsQueueEmpty>
    1fea:	88 23       	and	r24, r24
    1fec:	31 f1       	breq	.+76     	; 0x203a <xQueueGenericReceive+0x1a8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1fee:	8f 81       	ldd	r24, Y+7	; 0x07
    1ff0:	98 85       	ldd	r25, Y+8	; 0x08
    1ff2:	fc 01       	movw	r30, r24
    1ff4:	80 81       	ld	r24, Z
    1ff6:	91 81       	ldd	r25, Z+1	; 0x01
    1ff8:	00 97       	sbiw	r24, 0x00	; 0
    1ffa:	61 f4       	brne	.+24     	; 0x2014 <xQueueGenericReceive+0x182>
					{
						portENTER_CRITICAL();
    1ffc:	0f b6       	in	r0, 0x3f	; 63
    1ffe:	f8 94       	cli
    2000:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    2002:	8f 81       	ldd	r24, Y+7	; 0x07
    2004:	98 85       	ldd	r25, Y+8	; 0x08
    2006:	fc 01       	movw	r30, r24
    2008:	82 81       	ldd	r24, Z+2	; 0x02
    200a:	93 81       	ldd	r25, Z+3	; 0x03
    200c:	0e 94 15 0c 	call	0x182a	; 0x182a <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    2010:	0f 90       	pop	r0
    2012:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2014:	2b 85       	ldd	r18, Y+11	; 0x0b
    2016:	3c 85       	ldd	r19, Y+12	; 0x0c
    2018:	8f 81       	ldd	r24, Y+7	; 0x07
    201a:	98 85       	ldd	r25, Y+8	; 0x08
    201c:	41 96       	adiw	r24, 0x11	; 17
    201e:	b9 01       	movw	r22, r18
    2020:	0e 94 20 09 	call	0x1240	; 0x1240 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2024:	8f 81       	ldd	r24, Y+7	; 0x07
    2026:	98 85       	ldd	r25, Y+8	; 0x08
    2028:	0e 94 e5 11 	call	0x23ca	; 0x23ca <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    202c:	0e 94 fd 06 	call	0xdfa	; 0xdfa <xTaskResumeAll>
    2030:	88 23       	and	r24, r24
    2032:	91 f4       	brne	.+36     	; 0x2058 <xQueueGenericReceive+0x1c6>
				{
					portYIELD_WITHIN_API();
    2034:	0e 94 92 19 	call	0x3324	; 0x3324 <vPortYield>
    2038:	0f c0       	rjmp	.+30     	; 0x2058 <xQueueGenericReceive+0x1c6>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    203a:	8f 81       	ldd	r24, Y+7	; 0x07
    203c:	98 85       	ldd	r25, Y+8	; 0x08
    203e:	0e 94 e5 11 	call	0x23ca	; 0x23ca <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2042:	0e 94 fd 06 	call	0xdfa	; 0xdfa <xTaskResumeAll>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
    2046:	37 cf       	rjmp	.-402    	; 0x1eb6 <xQueueGenericReceive+0x24>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    2048:	8f 81       	ldd	r24, Y+7	; 0x07
    204a:	98 85       	ldd	r25, Y+8	; 0x08
    204c:	0e 94 e5 11 	call	0x23ca	; 0x23ca <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2050:	0e 94 fd 06 	call	0xdfa	; 0xdfa <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    2054:	80 e0       	ldi	r24, 0x00	; 0
    2056:	01 c0       	rjmp	.+2      	; 0x205a <xQueueGenericReceive+0x1c8>
		}
	}
    2058:	2e cf       	rjmp	.-420    	; 0x1eb6 <xQueueGenericReceive+0x24>
}
    205a:	2d 96       	adiw	r28, 0x0d	; 13
    205c:	0f b6       	in	r0, 0x3f	; 63
    205e:	f8 94       	cli
    2060:	de bf       	out	0x3e, r29	; 62
    2062:	0f be       	out	0x3f, r0	; 63
    2064:	cd bf       	out	0x3d, r28	; 61
    2066:	df 91       	pop	r29
    2068:	cf 91       	pop	r28
    206a:	08 95       	ret

0000206c <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
{
    206c:	cf 93       	push	r28
    206e:	df 93       	push	r29
    2070:	cd b7       	in	r28, 0x3d	; 61
    2072:	de b7       	in	r29, 0x3e	; 62
    2074:	28 97       	sbiw	r28, 0x08	; 8
    2076:	0f b6       	in	r0, 0x3f	; 63
    2078:	f8 94       	cli
    207a:	de bf       	out	0x3e, r29	; 62
    207c:	0f be       	out	0x3f, r0	; 63
    207e:	cd bf       	out	0x3d, r28	; 61
    2080:	9c 83       	std	Y+4, r25	; 0x04
    2082:	8b 83       	std	Y+3, r24	; 0x03
    2084:	7e 83       	std	Y+6, r23	; 0x06
    2086:	6d 83       	std	Y+5, r22	; 0x05
    2088:	58 87       	std	Y+8, r21	; 0x08
    208a:	4f 83       	std	Y+7, r20	; 0x07
unsigned portBASE_TYPE uxSavedInterruptStatus;

	configASSERT( pxQueue );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    208c:	1a 82       	std	Y+2, r1	; 0x02
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    208e:	8b 81       	ldd	r24, Y+3	; 0x03
    2090:	9c 81       	ldd	r25, Y+4	; 0x04
    2092:	fc 01       	movw	r30, r24
    2094:	82 8d       	ldd	r24, Z+26	; 0x1a
    2096:	88 23       	and	r24, r24
    2098:	d9 f1       	breq	.+118    	; 0x2110 <xQueueReceiveFromISR+0xa4>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    209a:	2d 81       	ldd	r18, Y+5	; 0x05
    209c:	3e 81       	ldd	r19, Y+6	; 0x06
    209e:	8b 81       	ldd	r24, Y+3	; 0x03
    20a0:	9c 81       	ldd	r25, Y+4	; 0x04
    20a2:	b9 01       	movw	r22, r18
    20a4:	0e 94 94 11 	call	0x2328	; 0x2328 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    20a8:	8b 81       	ldd	r24, Y+3	; 0x03
    20aa:	9c 81       	ldd	r25, Y+4	; 0x04
    20ac:	fc 01       	movw	r30, r24
    20ae:	82 8d       	ldd	r24, Z+26	; 0x1a
    20b0:	2f ef       	ldi	r18, 0xFF	; 255
    20b2:	28 0f       	add	r18, r24
    20b4:	8b 81       	ldd	r24, Y+3	; 0x03
    20b6:	9c 81       	ldd	r25, Y+4	; 0x04
    20b8:	fc 01       	movw	r30, r24
    20ba:	22 8f       	std	Z+26, r18	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    20bc:	8b 81       	ldd	r24, Y+3	; 0x03
    20be:	9c 81       	ldd	r25, Y+4	; 0x04
    20c0:	fc 01       	movw	r30, r24
    20c2:	85 8d       	ldd	r24, Z+29	; 0x1d
    20c4:	8f 3f       	cpi	r24, 0xFF	; 255
    20c6:	b9 f4       	brne	.+46     	; 0x20f6 <xQueueReceiveFromISR+0x8a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    20c8:	8b 81       	ldd	r24, Y+3	; 0x03
    20ca:	9c 81       	ldd	r25, Y+4	; 0x04
    20cc:	fc 01       	movw	r30, r24
    20ce:	80 85       	ldd	r24, Z+8	; 0x08
    20d0:	88 23       	and	r24, r24
    20d2:	d9 f0       	breq	.+54     	; 0x210a <xQueueReceiveFromISR+0x9e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    20d4:	8b 81       	ldd	r24, Y+3	; 0x03
    20d6:	9c 81       	ldd	r25, Y+4	; 0x04
    20d8:	08 96       	adiw	r24, 0x08	; 8
    20da:	0e 94 65 09 	call	0x12ca	; 0x12ca <xTaskRemoveFromEventList>
    20de:	88 23       	and	r24, r24
    20e0:	a1 f0       	breq	.+40     	; 0x210a <xQueueReceiveFromISR+0x9e>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    20e2:	8f 81       	ldd	r24, Y+7	; 0x07
    20e4:	98 85       	ldd	r25, Y+8	; 0x08
    20e6:	00 97       	sbiw	r24, 0x00	; 0
    20e8:	81 f0       	breq	.+32     	; 0x210a <xQueueReceiveFromISR+0x9e>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    20ea:	8f 81       	ldd	r24, Y+7	; 0x07
    20ec:	98 85       	ldd	r25, Y+8	; 0x08
    20ee:	21 e0       	ldi	r18, 0x01	; 1
    20f0:	fc 01       	movw	r30, r24
    20f2:	20 83       	st	Z, r18
    20f4:	0a c0       	rjmp	.+20     	; 0x210a <xQueueReceiveFromISR+0x9e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    20f6:	8b 81       	ldd	r24, Y+3	; 0x03
    20f8:	9c 81       	ldd	r25, Y+4	; 0x04
    20fa:	fc 01       	movw	r30, r24
    20fc:	85 8d       	ldd	r24, Z+29	; 0x1d
    20fe:	21 e0       	ldi	r18, 0x01	; 1
    2100:	28 0f       	add	r18, r24
    2102:	8b 81       	ldd	r24, Y+3	; 0x03
    2104:	9c 81       	ldd	r25, Y+4	; 0x04
    2106:	fc 01       	movw	r30, r24
    2108:	25 8f       	std	Z+29, r18	; 0x1d
			}

			xReturn = pdPASS;
    210a:	81 e0       	ldi	r24, 0x01	; 1
    210c:	89 83       	std	Y+1, r24	; 0x01
    210e:	01 c0       	rjmp	.+2      	; 0x2112 <xQueueReceiveFromISR+0xa6>
		}
		else
		{
			xReturn = pdFAIL;
    2110:	19 82       	std	Y+1, r1	; 0x01
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2112:	89 81       	ldd	r24, Y+1	; 0x01
}
    2114:	28 96       	adiw	r28, 0x08	; 8
    2116:	0f b6       	in	r0, 0x3f	; 63
    2118:	f8 94       	cli
    211a:	de bf       	out	0x3e, r29	; 62
    211c:	0f be       	out	0x3f, r0	; 63
    211e:	cd bf       	out	0x3d, r28	; 61
    2120:	df 91       	pop	r29
    2122:	cf 91       	pop	r28
    2124:	08 95       	ret

00002126 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    2126:	cf 93       	push	r28
    2128:	df 93       	push	r29
    212a:	00 d0       	rcall	.+0      	; 0x212c <uxQueueMessagesWaiting+0x6>
    212c:	cd b7       	in	r28, 0x3d	; 61
    212e:	de b7       	in	r29, 0x3e	; 62
    2130:	9b 83       	std	Y+3, r25	; 0x03
    2132:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2134:	0f b6       	in	r0, 0x3f	; 63
    2136:	f8 94       	cli
    2138:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    213a:	8a 81       	ldd	r24, Y+2	; 0x02
    213c:	9b 81       	ldd	r25, Y+3	; 0x03
    213e:	fc 01       	movw	r30, r24
    2140:	82 8d       	ldd	r24, Z+26	; 0x1a
    2142:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    2144:	0f 90       	pop	r0
    2146:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2148:	89 81       	ldd	r24, Y+1	; 0x01
}
    214a:	0f 90       	pop	r0
    214c:	0f 90       	pop	r0
    214e:	0f 90       	pop	r0
    2150:	df 91       	pop	r29
    2152:	cf 91       	pop	r28
    2154:	08 95       	ret

00002156 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    2156:	cf 93       	push	r28
    2158:	df 93       	push	r29
    215a:	00 d0       	rcall	.+0      	; 0x215c <uxQueueMessagesWaitingFromISR+0x6>
    215c:	cd b7       	in	r28, 0x3d	; 61
    215e:	de b7       	in	r29, 0x3e	; 62
    2160:	9b 83       	std	Y+3, r25	; 0x03
    2162:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    2164:	8a 81       	ldd	r24, Y+2	; 0x02
    2166:	9b 81       	ldd	r25, Y+3	; 0x03
    2168:	fc 01       	movw	r30, r24
    216a:	82 8d       	ldd	r24, Z+26	; 0x1a
    216c:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    216e:	89 81       	ldd	r24, Y+1	; 0x01
}
    2170:	0f 90       	pop	r0
    2172:	0f 90       	pop	r0
    2174:	0f 90       	pop	r0
    2176:	df 91       	pop	r29
    2178:	cf 91       	pop	r28
    217a:	08 95       	ret

0000217c <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    217c:	cf 93       	push	r28
    217e:	df 93       	push	r29
    2180:	1f 92       	push	r1
    2182:	1f 92       	push	r1
    2184:	cd b7       	in	r28, 0x3d	; 61
    2186:	de b7       	in	r29, 0x3e	; 62
    2188:	9a 83       	std	Y+2, r25	; 0x02
    218a:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    218c:	89 81       	ldd	r24, Y+1	; 0x01
    218e:	9a 81       	ldd	r25, Y+2	; 0x02
    2190:	fc 01       	movw	r30, r24
    2192:	80 81       	ld	r24, Z
    2194:	91 81       	ldd	r25, Z+1	; 0x01
    2196:	0e 94 65 17 	call	0x2eca	; 0x2eca <vPortFree>
	vPortFree( pxQueue );
    219a:	89 81       	ldd	r24, Y+1	; 0x01
    219c:	9a 81       	ldd	r25, Y+2	; 0x02
    219e:	0e 94 65 17 	call	0x2eca	; 0x2eca <vPortFree>
}
    21a2:	0f 90       	pop	r0
    21a4:	0f 90       	pop	r0
    21a6:	df 91       	pop	r29
    21a8:	cf 91       	pop	r28
    21aa:	08 95       	ret

000021ac <prvCopyDataToQueue>:

#endif
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    21ac:	cf 93       	push	r28
    21ae:	df 93       	push	r29
    21b0:	00 d0       	rcall	.+0      	; 0x21b2 <prvCopyDataToQueue+0x6>
    21b2:	1f 92       	push	r1
    21b4:	1f 92       	push	r1
    21b6:	cd b7       	in	r28, 0x3d	; 61
    21b8:	de b7       	in	r29, 0x3e	; 62
    21ba:	9a 83       	std	Y+2, r25	; 0x02
    21bc:	89 83       	std	Y+1, r24	; 0x01
    21be:	7c 83       	std	Y+4, r23	; 0x04
    21c0:	6b 83       	std	Y+3, r22	; 0x03
    21c2:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    21c4:	89 81       	ldd	r24, Y+1	; 0x01
    21c6:	9a 81       	ldd	r25, Y+2	; 0x02
    21c8:	fc 01       	movw	r30, r24
    21ca:	84 8d       	ldd	r24, Z+28	; 0x1c
    21cc:	88 23       	and	r24, r24
    21ce:	a9 f4       	brne	.+42     	; 0x21fa <prvCopyDataToQueue+0x4e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    21d0:	89 81       	ldd	r24, Y+1	; 0x01
    21d2:	9a 81       	ldd	r25, Y+2	; 0x02
    21d4:	fc 01       	movw	r30, r24
    21d6:	80 81       	ld	r24, Z
    21d8:	91 81       	ldd	r25, Z+1	; 0x01
    21da:	00 97       	sbiw	r24, 0x00	; 0
    21dc:	09 f0       	breq	.+2      	; 0x21e0 <prvCopyDataToQueue+0x34>
    21de:	92 c0       	rjmp	.+292    	; 0x2304 <__stack+0x105>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    21e0:	89 81       	ldd	r24, Y+1	; 0x01
    21e2:	9a 81       	ldd	r25, Y+2	; 0x02
    21e4:	fc 01       	movw	r30, r24
    21e6:	82 81       	ldd	r24, Z+2	; 0x02
    21e8:	93 81       	ldd	r25, Z+3	; 0x03
    21ea:	0e 94 a5 0c 	call	0x194a	; 0x194a <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    21ee:	89 81       	ldd	r24, Y+1	; 0x01
    21f0:	9a 81       	ldd	r25, Y+2	; 0x02
    21f2:	fc 01       	movw	r30, r24
    21f4:	13 82       	std	Z+3, r1	; 0x03
    21f6:	12 82       	std	Z+2, r1	; 0x02
    21f8:	85 c0       	rjmp	.+266    	; 0x2304 <__stack+0x105>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    21fa:	8d 81       	ldd	r24, Y+5	; 0x05
    21fc:	88 23       	and	r24, r24
    21fe:	d9 f5       	brne	.+118    	; 0x2276 <__stack+0x77>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    2200:	89 81       	ldd	r24, Y+1	; 0x01
    2202:	9a 81       	ldd	r25, Y+2	; 0x02
    2204:	fc 01       	movw	r30, r24
    2206:	84 8d       	ldd	r24, Z+28	; 0x1c
    2208:	48 2f       	mov	r20, r24
    220a:	50 e0       	ldi	r21, 0x00	; 0
    220c:	89 81       	ldd	r24, Y+1	; 0x01
    220e:	9a 81       	ldd	r25, Y+2	; 0x02
    2210:	fc 01       	movw	r30, r24
    2212:	84 81       	ldd	r24, Z+4	; 0x04
    2214:	95 81       	ldd	r25, Z+5	; 0x05
    2216:	2b 81       	ldd	r18, Y+3	; 0x03
    2218:	3c 81       	ldd	r19, Y+4	; 0x04
    221a:	b9 01       	movw	r22, r18
    221c:	0e 94 8d 29 	call	0x531a	; 0x531a <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    2220:	89 81       	ldd	r24, Y+1	; 0x01
    2222:	9a 81       	ldd	r25, Y+2	; 0x02
    2224:	fc 01       	movw	r30, r24
    2226:	24 81       	ldd	r18, Z+4	; 0x04
    2228:	35 81       	ldd	r19, Z+5	; 0x05
    222a:	89 81       	ldd	r24, Y+1	; 0x01
    222c:	9a 81       	ldd	r25, Y+2	; 0x02
    222e:	fc 01       	movw	r30, r24
    2230:	84 8d       	ldd	r24, Z+28	; 0x1c
    2232:	88 2f       	mov	r24, r24
    2234:	90 e0       	ldi	r25, 0x00	; 0
    2236:	28 0f       	add	r18, r24
    2238:	39 1f       	adc	r19, r25
    223a:	89 81       	ldd	r24, Y+1	; 0x01
    223c:	9a 81       	ldd	r25, Y+2	; 0x02
    223e:	fc 01       	movw	r30, r24
    2240:	35 83       	std	Z+5, r19	; 0x05
    2242:	24 83       	std	Z+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    2244:	89 81       	ldd	r24, Y+1	; 0x01
    2246:	9a 81       	ldd	r25, Y+2	; 0x02
    2248:	fc 01       	movw	r30, r24
    224a:	24 81       	ldd	r18, Z+4	; 0x04
    224c:	35 81       	ldd	r19, Z+5	; 0x05
    224e:	89 81       	ldd	r24, Y+1	; 0x01
    2250:	9a 81       	ldd	r25, Y+2	; 0x02
    2252:	fc 01       	movw	r30, r24
    2254:	82 81       	ldd	r24, Z+2	; 0x02
    2256:	93 81       	ldd	r25, Z+3	; 0x03
    2258:	28 17       	cp	r18, r24
    225a:	39 07       	cpc	r19, r25
    225c:	08 f4       	brcc	.+2      	; 0x2260 <__stack+0x61>
    225e:	52 c0       	rjmp	.+164    	; 0x2304 <__stack+0x105>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    2260:	89 81       	ldd	r24, Y+1	; 0x01
    2262:	9a 81       	ldd	r25, Y+2	; 0x02
    2264:	fc 01       	movw	r30, r24
    2266:	20 81       	ld	r18, Z
    2268:	31 81       	ldd	r19, Z+1	; 0x01
    226a:	89 81       	ldd	r24, Y+1	; 0x01
    226c:	9a 81       	ldd	r25, Y+2	; 0x02
    226e:	fc 01       	movw	r30, r24
    2270:	35 83       	std	Z+5, r19	; 0x05
    2272:	24 83       	std	Z+4, r18	; 0x04
    2274:	47 c0       	rjmp	.+142    	; 0x2304 <__stack+0x105>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    2276:	89 81       	ldd	r24, Y+1	; 0x01
    2278:	9a 81       	ldd	r25, Y+2	; 0x02
    227a:	fc 01       	movw	r30, r24
    227c:	84 8d       	ldd	r24, Z+28	; 0x1c
    227e:	48 2f       	mov	r20, r24
    2280:	50 e0       	ldi	r21, 0x00	; 0
    2282:	89 81       	ldd	r24, Y+1	; 0x01
    2284:	9a 81       	ldd	r25, Y+2	; 0x02
    2286:	fc 01       	movw	r30, r24
    2288:	86 81       	ldd	r24, Z+6	; 0x06
    228a:	97 81       	ldd	r25, Z+7	; 0x07
    228c:	2b 81       	ldd	r18, Y+3	; 0x03
    228e:	3c 81       	ldd	r19, Y+4	; 0x04
    2290:	b9 01       	movw	r22, r18
    2292:	0e 94 8d 29 	call	0x531a	; 0x531a <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    2296:	89 81       	ldd	r24, Y+1	; 0x01
    2298:	9a 81       	ldd	r25, Y+2	; 0x02
    229a:	fc 01       	movw	r30, r24
    229c:	26 81       	ldd	r18, Z+6	; 0x06
    229e:	37 81       	ldd	r19, Z+7	; 0x07
    22a0:	89 81       	ldd	r24, Y+1	; 0x01
    22a2:	9a 81       	ldd	r25, Y+2	; 0x02
    22a4:	fc 01       	movw	r30, r24
    22a6:	84 8d       	ldd	r24, Z+28	; 0x1c
    22a8:	88 2f       	mov	r24, r24
    22aa:	90 e0       	ldi	r25, 0x00	; 0
    22ac:	91 95       	neg	r25
    22ae:	81 95       	neg	r24
    22b0:	91 09       	sbc	r25, r1
    22b2:	28 0f       	add	r18, r24
    22b4:	39 1f       	adc	r19, r25
    22b6:	89 81       	ldd	r24, Y+1	; 0x01
    22b8:	9a 81       	ldd	r25, Y+2	; 0x02
    22ba:	fc 01       	movw	r30, r24
    22bc:	37 83       	std	Z+7, r19	; 0x07
    22be:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    22c0:	89 81       	ldd	r24, Y+1	; 0x01
    22c2:	9a 81       	ldd	r25, Y+2	; 0x02
    22c4:	fc 01       	movw	r30, r24
    22c6:	26 81       	ldd	r18, Z+6	; 0x06
    22c8:	37 81       	ldd	r19, Z+7	; 0x07
    22ca:	89 81       	ldd	r24, Y+1	; 0x01
    22cc:	9a 81       	ldd	r25, Y+2	; 0x02
    22ce:	fc 01       	movw	r30, r24
    22d0:	80 81       	ld	r24, Z
    22d2:	91 81       	ldd	r25, Z+1	; 0x01
    22d4:	28 17       	cp	r18, r24
    22d6:	39 07       	cpc	r19, r25
    22d8:	a8 f4       	brcc	.+42     	; 0x2304 <__stack+0x105>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    22da:	89 81       	ldd	r24, Y+1	; 0x01
    22dc:	9a 81       	ldd	r25, Y+2	; 0x02
    22de:	fc 01       	movw	r30, r24
    22e0:	22 81       	ldd	r18, Z+2	; 0x02
    22e2:	33 81       	ldd	r19, Z+3	; 0x03
    22e4:	89 81       	ldd	r24, Y+1	; 0x01
    22e6:	9a 81       	ldd	r25, Y+2	; 0x02
    22e8:	fc 01       	movw	r30, r24
    22ea:	84 8d       	ldd	r24, Z+28	; 0x1c
    22ec:	88 2f       	mov	r24, r24
    22ee:	90 e0       	ldi	r25, 0x00	; 0
    22f0:	91 95       	neg	r25
    22f2:	81 95       	neg	r24
    22f4:	91 09       	sbc	r25, r1
    22f6:	28 0f       	add	r18, r24
    22f8:	39 1f       	adc	r19, r25
    22fa:	89 81       	ldd	r24, Y+1	; 0x01
    22fc:	9a 81       	ldd	r25, Y+2	; 0x02
    22fe:	fc 01       	movw	r30, r24
    2300:	37 83       	std	Z+7, r19	; 0x07
    2302:	26 83       	std	Z+6, r18	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    2304:	89 81       	ldd	r24, Y+1	; 0x01
    2306:	9a 81       	ldd	r25, Y+2	; 0x02
    2308:	fc 01       	movw	r30, r24
    230a:	82 8d       	ldd	r24, Z+26	; 0x1a
    230c:	21 e0       	ldi	r18, 0x01	; 1
    230e:	28 0f       	add	r18, r24
    2310:	89 81       	ldd	r24, Y+1	; 0x01
    2312:	9a 81       	ldd	r25, Y+2	; 0x02
    2314:	fc 01       	movw	r30, r24
    2316:	22 8f       	std	Z+26, r18	; 0x1a
}
    2318:	0f 90       	pop	r0
    231a:	0f 90       	pop	r0
    231c:	0f 90       	pop	r0
    231e:	0f 90       	pop	r0
    2320:	0f 90       	pop	r0
    2322:	df 91       	pop	r29
    2324:	cf 91       	pop	r28
    2326:	08 95       	ret

00002328 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    2328:	cf 93       	push	r28
    232a:	df 93       	push	r29
    232c:	00 d0       	rcall	.+0      	; 0x232e <prvCopyDataFromQueue+0x6>
    232e:	1f 92       	push	r1
    2330:	cd b7       	in	r28, 0x3d	; 61
    2332:	de b7       	in	r29, 0x3e	; 62
    2334:	9a 83       	std	Y+2, r25	; 0x02
    2336:	89 83       	std	Y+1, r24	; 0x01
    2338:	7c 83       	std	Y+4, r23	; 0x04
    233a:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    233c:	89 81       	ldd	r24, Y+1	; 0x01
    233e:	9a 81       	ldd	r25, Y+2	; 0x02
    2340:	fc 01       	movw	r30, r24
    2342:	80 81       	ld	r24, Z
    2344:	91 81       	ldd	r25, Z+1	; 0x01
    2346:	00 97       	sbiw	r24, 0x00	; 0
    2348:	c9 f1       	breq	.+114    	; 0x23bc <prvCopyDataFromQueue+0x94>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    234a:	89 81       	ldd	r24, Y+1	; 0x01
    234c:	9a 81       	ldd	r25, Y+2	; 0x02
    234e:	fc 01       	movw	r30, r24
    2350:	26 81       	ldd	r18, Z+6	; 0x06
    2352:	37 81       	ldd	r19, Z+7	; 0x07
    2354:	89 81       	ldd	r24, Y+1	; 0x01
    2356:	9a 81       	ldd	r25, Y+2	; 0x02
    2358:	fc 01       	movw	r30, r24
    235a:	84 8d       	ldd	r24, Z+28	; 0x1c
    235c:	88 2f       	mov	r24, r24
    235e:	90 e0       	ldi	r25, 0x00	; 0
    2360:	28 0f       	add	r18, r24
    2362:	39 1f       	adc	r19, r25
    2364:	89 81       	ldd	r24, Y+1	; 0x01
    2366:	9a 81       	ldd	r25, Y+2	; 0x02
    2368:	fc 01       	movw	r30, r24
    236a:	37 83       	std	Z+7, r19	; 0x07
    236c:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    236e:	89 81       	ldd	r24, Y+1	; 0x01
    2370:	9a 81       	ldd	r25, Y+2	; 0x02
    2372:	fc 01       	movw	r30, r24
    2374:	26 81       	ldd	r18, Z+6	; 0x06
    2376:	37 81       	ldd	r19, Z+7	; 0x07
    2378:	89 81       	ldd	r24, Y+1	; 0x01
    237a:	9a 81       	ldd	r25, Y+2	; 0x02
    237c:	fc 01       	movw	r30, r24
    237e:	82 81       	ldd	r24, Z+2	; 0x02
    2380:	93 81       	ldd	r25, Z+3	; 0x03
    2382:	28 17       	cp	r18, r24
    2384:	39 07       	cpc	r19, r25
    2386:	50 f0       	brcs	.+20     	; 0x239c <prvCopyDataFromQueue+0x74>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    2388:	89 81       	ldd	r24, Y+1	; 0x01
    238a:	9a 81       	ldd	r25, Y+2	; 0x02
    238c:	fc 01       	movw	r30, r24
    238e:	20 81       	ld	r18, Z
    2390:	31 81       	ldd	r19, Z+1	; 0x01
    2392:	89 81       	ldd	r24, Y+1	; 0x01
    2394:	9a 81       	ldd	r25, Y+2	; 0x02
    2396:	fc 01       	movw	r30, r24
    2398:	37 83       	std	Z+7, r19	; 0x07
    239a:	26 83       	std	Z+6, r18	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    239c:	89 81       	ldd	r24, Y+1	; 0x01
    239e:	9a 81       	ldd	r25, Y+2	; 0x02
    23a0:	fc 01       	movw	r30, r24
    23a2:	84 8d       	ldd	r24, Z+28	; 0x1c
    23a4:	48 2f       	mov	r20, r24
    23a6:	50 e0       	ldi	r21, 0x00	; 0
    23a8:	89 81       	ldd	r24, Y+1	; 0x01
    23aa:	9a 81       	ldd	r25, Y+2	; 0x02
    23ac:	fc 01       	movw	r30, r24
    23ae:	26 81       	ldd	r18, Z+6	; 0x06
    23b0:	37 81       	ldd	r19, Z+7	; 0x07
    23b2:	8b 81       	ldd	r24, Y+3	; 0x03
    23b4:	9c 81       	ldd	r25, Y+4	; 0x04
    23b6:	b9 01       	movw	r22, r18
    23b8:	0e 94 8d 29 	call	0x531a	; 0x531a <memcpy>
	}
}
    23bc:	0f 90       	pop	r0
    23be:	0f 90       	pop	r0
    23c0:	0f 90       	pop	r0
    23c2:	0f 90       	pop	r0
    23c4:	df 91       	pop	r29
    23c6:	cf 91       	pop	r28
    23c8:	08 95       	ret

000023ca <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    23ca:	cf 93       	push	r28
    23cc:	df 93       	push	r29
    23ce:	1f 92       	push	r1
    23d0:	1f 92       	push	r1
    23d2:	cd b7       	in	r28, 0x3d	; 61
    23d4:	de b7       	in	r29, 0x3e	; 62
    23d6:	9a 83       	std	Y+2, r25	; 0x02
    23d8:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    23da:	0f b6       	in	r0, 0x3f	; 63
    23dc:	f8 94       	cli
    23de:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    23e0:	1b c0       	rjmp	.+54     	; 0x2418 <prvUnlockQueue+0x4e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    23e2:	89 81       	ldd	r24, Y+1	; 0x01
    23e4:	9a 81       	ldd	r25, Y+2	; 0x02
    23e6:	fc 01       	movw	r30, r24
    23e8:	81 89       	ldd	r24, Z+17	; 0x11
    23ea:	88 23       	and	r24, r24
    23ec:	a1 f0       	breq	.+40     	; 0x2416 <prvUnlockQueue+0x4c>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    23ee:	89 81       	ldd	r24, Y+1	; 0x01
    23f0:	9a 81       	ldd	r25, Y+2	; 0x02
    23f2:	41 96       	adiw	r24, 0x11	; 17
    23f4:	0e 94 65 09 	call	0x12ca	; 0x12ca <xTaskRemoveFromEventList>
    23f8:	88 23       	and	r24, r24
    23fa:	11 f0       	breq	.+4      	; 0x2400 <prvUnlockQueue+0x36>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    23fc:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    2400:	89 81       	ldd	r24, Y+1	; 0x01
    2402:	9a 81       	ldd	r25, Y+2	; 0x02
    2404:	fc 01       	movw	r30, r24
    2406:	86 8d       	ldd	r24, Z+30	; 0x1e
    2408:	2f ef       	ldi	r18, 0xFF	; 255
    240a:	28 0f       	add	r18, r24
    240c:	89 81       	ldd	r24, Y+1	; 0x01
    240e:	9a 81       	ldd	r25, Y+2	; 0x02
    2410:	fc 01       	movw	r30, r24
    2412:	26 8f       	std	Z+30, r18	; 0x1e
    2414:	01 c0       	rjmp	.+2      	; 0x2418 <prvUnlockQueue+0x4e>
			}
			else
			{
				break;
    2416:	06 c0       	rjmp	.+12     	; 0x2424 <prvUnlockQueue+0x5a>
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2418:	89 81       	ldd	r24, Y+1	; 0x01
    241a:	9a 81       	ldd	r25, Y+2	; 0x02
    241c:	fc 01       	movw	r30, r24
    241e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2420:	18 16       	cp	r1, r24
    2422:	fc f2       	brlt	.-66     	; 0x23e2 <prvUnlockQueue+0x18>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    2424:	89 81       	ldd	r24, Y+1	; 0x01
    2426:	9a 81       	ldd	r25, Y+2	; 0x02
    2428:	2f ef       	ldi	r18, 0xFF	; 255
    242a:	fc 01       	movw	r30, r24
    242c:	26 8f       	std	Z+30, r18	; 0x1e
	}
	taskEXIT_CRITICAL();
    242e:	0f 90       	pop	r0
    2430:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2432:	0f b6       	in	r0, 0x3f	; 63
    2434:	f8 94       	cli
    2436:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2438:	1b c0       	rjmp	.+54     	; 0x2470 <prvUnlockQueue+0xa6>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    243a:	89 81       	ldd	r24, Y+1	; 0x01
    243c:	9a 81       	ldd	r25, Y+2	; 0x02
    243e:	fc 01       	movw	r30, r24
    2440:	80 85       	ldd	r24, Z+8	; 0x08
    2442:	88 23       	and	r24, r24
    2444:	a1 f0       	breq	.+40     	; 0x246e <prvUnlockQueue+0xa4>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2446:	89 81       	ldd	r24, Y+1	; 0x01
    2448:	9a 81       	ldd	r25, Y+2	; 0x02
    244a:	08 96       	adiw	r24, 0x08	; 8
    244c:	0e 94 65 09 	call	0x12ca	; 0x12ca <xTaskRemoveFromEventList>
    2450:	88 23       	and	r24, r24
    2452:	11 f0       	breq	.+4      	; 0x2458 <prvUnlockQueue+0x8e>
				{
					vTaskMissedYield();
    2454:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    2458:	89 81       	ldd	r24, Y+1	; 0x01
    245a:	9a 81       	ldd	r25, Y+2	; 0x02
    245c:	fc 01       	movw	r30, r24
    245e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2460:	2f ef       	ldi	r18, 0xFF	; 255
    2462:	28 0f       	add	r18, r24
    2464:	89 81       	ldd	r24, Y+1	; 0x01
    2466:	9a 81       	ldd	r25, Y+2	; 0x02
    2468:	fc 01       	movw	r30, r24
    246a:	25 8f       	std	Z+29, r18	; 0x1d
    246c:	01 c0       	rjmp	.+2      	; 0x2470 <prvUnlockQueue+0xa6>
			}
			else
			{
				break;
    246e:	06 c0       	rjmp	.+12     	; 0x247c <prvUnlockQueue+0xb2>
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2470:	89 81       	ldd	r24, Y+1	; 0x01
    2472:	9a 81       	ldd	r25, Y+2	; 0x02
    2474:	fc 01       	movw	r30, r24
    2476:	85 8d       	ldd	r24, Z+29	; 0x1d
    2478:	18 16       	cp	r1, r24
    247a:	fc f2       	brlt	.-66     	; 0x243a <prvUnlockQueue+0x70>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    247c:	89 81       	ldd	r24, Y+1	; 0x01
    247e:	9a 81       	ldd	r25, Y+2	; 0x02
    2480:	2f ef       	ldi	r18, 0xFF	; 255
    2482:	fc 01       	movw	r30, r24
    2484:	25 8f       	std	Z+29, r18	; 0x1d
	}
	taskEXIT_CRITICAL();
    2486:	0f 90       	pop	r0
    2488:	0f be       	out	0x3f, r0	; 63
}
    248a:	0f 90       	pop	r0
    248c:	0f 90       	pop	r0
    248e:	df 91       	pop	r29
    2490:	cf 91       	pop	r28
    2492:	08 95       	ret

00002494 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    2494:	cf 93       	push	r28
    2496:	df 93       	push	r29
    2498:	00 d0       	rcall	.+0      	; 0x249a <prvIsQueueEmpty+0x6>
    249a:	cd b7       	in	r28, 0x3d	; 61
    249c:	de b7       	in	r29, 0x3e	; 62
    249e:	9b 83       	std	Y+3, r25	; 0x03
    24a0:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    24a2:	0f b6       	in	r0, 0x3f	; 63
    24a4:	f8 94       	cli
    24a6:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    24a8:	8a 81       	ldd	r24, Y+2	; 0x02
    24aa:	9b 81       	ldd	r25, Y+3	; 0x03
    24ac:	fc 01       	movw	r30, r24
    24ae:	92 8d       	ldd	r25, Z+26	; 0x1a
    24b0:	81 e0       	ldi	r24, 0x01	; 1
    24b2:	99 23       	and	r25, r25
    24b4:	09 f0       	breq	.+2      	; 0x24b8 <prvIsQueueEmpty+0x24>
    24b6:	80 e0       	ldi	r24, 0x00	; 0
    24b8:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    24ba:	0f 90       	pop	r0
    24bc:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    24be:	89 81       	ldd	r24, Y+1	; 0x01
}
    24c0:	0f 90       	pop	r0
    24c2:	0f 90       	pop	r0
    24c4:	0f 90       	pop	r0
    24c6:	df 91       	pop	r29
    24c8:	cf 91       	pop	r28
    24ca:	08 95       	ret

000024cc <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    24cc:	cf 93       	push	r28
    24ce:	df 93       	push	r29
    24d0:	00 d0       	rcall	.+0      	; 0x24d2 <xQueueIsQueueEmptyFromISR+0x6>
    24d2:	cd b7       	in	r28, 0x3d	; 61
    24d4:	de b7       	in	r29, 0x3e	; 62
    24d6:	9b 83       	std	Y+3, r25	; 0x03
    24d8:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    24da:	8a 81       	ldd	r24, Y+2	; 0x02
    24dc:	9b 81       	ldd	r25, Y+3	; 0x03
    24de:	fc 01       	movw	r30, r24
    24e0:	92 8d       	ldd	r25, Z+26	; 0x1a
    24e2:	81 e0       	ldi	r24, 0x01	; 1
    24e4:	99 23       	and	r25, r25
    24e6:	09 f0       	breq	.+2      	; 0x24ea <xQueueIsQueueEmptyFromISR+0x1e>
    24e8:	80 e0       	ldi	r24, 0x00	; 0
    24ea:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    24ec:	89 81       	ldd	r24, Y+1	; 0x01
}
    24ee:	0f 90       	pop	r0
    24f0:	0f 90       	pop	r0
    24f2:	0f 90       	pop	r0
    24f4:	df 91       	pop	r29
    24f6:	cf 91       	pop	r28
    24f8:	08 95       	ret

000024fa <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    24fa:	cf 93       	push	r28
    24fc:	df 93       	push	r29
    24fe:	00 d0       	rcall	.+0      	; 0x2500 <prvIsQueueFull+0x6>
    2500:	cd b7       	in	r28, 0x3d	; 61
    2502:	de b7       	in	r29, 0x3e	; 62
    2504:	9b 83       	std	Y+3, r25	; 0x03
    2506:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    2508:	0f b6       	in	r0, 0x3f	; 63
    250a:	f8 94       	cli
    250c:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    250e:	8a 81       	ldd	r24, Y+2	; 0x02
    2510:	9b 81       	ldd	r25, Y+3	; 0x03
    2512:	fc 01       	movw	r30, r24
    2514:	22 8d       	ldd	r18, Z+26	; 0x1a
    2516:	8a 81       	ldd	r24, Y+2	; 0x02
    2518:	9b 81       	ldd	r25, Y+3	; 0x03
    251a:	fc 01       	movw	r30, r24
    251c:	93 8d       	ldd	r25, Z+27	; 0x1b
    251e:	81 e0       	ldi	r24, 0x01	; 1
    2520:	29 17       	cp	r18, r25
    2522:	09 f0       	breq	.+2      	; 0x2526 <prvIsQueueFull+0x2c>
    2524:	80 e0       	ldi	r24, 0x00	; 0
    2526:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    2528:	0f 90       	pop	r0
    252a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    252c:	89 81       	ldd	r24, Y+1	; 0x01
}
    252e:	0f 90       	pop	r0
    2530:	0f 90       	pop	r0
    2532:	0f 90       	pop	r0
    2534:	df 91       	pop	r29
    2536:	cf 91       	pop	r28
    2538:	08 95       	ret

0000253a <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    253a:	cf 93       	push	r28
    253c:	df 93       	push	r29
    253e:	00 d0       	rcall	.+0      	; 0x2540 <xQueueIsQueueFullFromISR+0x6>
    2540:	cd b7       	in	r28, 0x3d	; 61
    2542:	de b7       	in	r29, 0x3e	; 62
    2544:	9b 83       	std	Y+3, r25	; 0x03
    2546:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    2548:	8a 81       	ldd	r24, Y+2	; 0x02
    254a:	9b 81       	ldd	r25, Y+3	; 0x03
    254c:	fc 01       	movw	r30, r24
    254e:	22 8d       	ldd	r18, Z+26	; 0x1a
    2550:	8a 81       	ldd	r24, Y+2	; 0x02
    2552:	9b 81       	ldd	r25, Y+3	; 0x03
    2554:	fc 01       	movw	r30, r24
    2556:	93 8d       	ldd	r25, Z+27	; 0x1b
    2558:	81 e0       	ldi	r24, 0x01	; 1
    255a:	29 17       	cp	r18, r25
    255c:	09 f0       	breq	.+2      	; 0x2560 <xQueueIsQueueFullFromISR+0x26>
    255e:	80 e0       	ldi	r24, 0x00	; 0
    2560:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    2562:	89 81       	ldd	r24, Y+1	; 0x01
}
    2564:	0f 90       	pop	r0
    2566:	0f 90       	pop	r0
    2568:	0f 90       	pop	r0
    256a:	df 91       	pop	r29
    256c:	cf 91       	pop	r28
    256e:	08 95       	ret

00002570 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    2570:	cf 93       	push	r28
    2572:	df 93       	push	r29
    2574:	1f 92       	push	r1
    2576:	1f 92       	push	r1
    2578:	cd b7       	in	r28, 0x3d	; 61
    257a:	de b7       	in	r29, 0x3e	; 62
    257c:	9a 83       	std	Y+2, r25	; 0x02
    257e:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    2580:	89 81       	ldd	r24, Y+1	; 0x01
    2582:	9a 81       	ldd	r25, Y+2	; 0x02
    2584:	9c 01       	movw	r18, r24
    2586:	2d 5f       	subi	r18, 0xFD	; 253
    2588:	3f 4f       	sbci	r19, 0xFF	; 255
    258a:	89 81       	ldd	r24, Y+1	; 0x01
    258c:	9a 81       	ldd	r25, Y+2	; 0x02
    258e:	fc 01       	movw	r30, r24
    2590:	32 83       	std	Z+2, r19	; 0x02
    2592:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2594:	89 81       	ldd	r24, Y+1	; 0x01
    2596:	9a 81       	ldd	r25, Y+2	; 0x02
    2598:	2f ef       	ldi	r18, 0xFF	; 255
    259a:	3f ef       	ldi	r19, 0xFF	; 255
    259c:	fc 01       	movw	r30, r24
    259e:	34 83       	std	Z+4, r19	; 0x04
    25a0:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    25a2:	89 81       	ldd	r24, Y+1	; 0x01
    25a4:	9a 81       	ldd	r25, Y+2	; 0x02
    25a6:	9c 01       	movw	r18, r24
    25a8:	2d 5f       	subi	r18, 0xFD	; 253
    25aa:	3f 4f       	sbci	r19, 0xFF	; 255
    25ac:	89 81       	ldd	r24, Y+1	; 0x01
    25ae:	9a 81       	ldd	r25, Y+2	; 0x02
    25b0:	fc 01       	movw	r30, r24
    25b2:	36 83       	std	Z+6, r19	; 0x06
    25b4:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    25b6:	89 81       	ldd	r24, Y+1	; 0x01
    25b8:	9a 81       	ldd	r25, Y+2	; 0x02
    25ba:	9c 01       	movw	r18, r24
    25bc:	2d 5f       	subi	r18, 0xFD	; 253
    25be:	3f 4f       	sbci	r19, 0xFF	; 255
    25c0:	89 81       	ldd	r24, Y+1	; 0x01
    25c2:	9a 81       	ldd	r25, Y+2	; 0x02
    25c4:	fc 01       	movw	r30, r24
    25c6:	30 87       	std	Z+8, r19	; 0x08
    25c8:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    25ca:	89 81       	ldd	r24, Y+1	; 0x01
    25cc:	9a 81       	ldd	r25, Y+2	; 0x02
    25ce:	fc 01       	movw	r30, r24
    25d0:	10 82       	st	Z, r1
}
    25d2:	0f 90       	pop	r0
    25d4:	0f 90       	pop	r0
    25d6:	df 91       	pop	r29
    25d8:	cf 91       	pop	r28
    25da:	08 95       	ret

000025dc <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    25dc:	cf 93       	push	r28
    25de:	df 93       	push	r29
    25e0:	1f 92       	push	r1
    25e2:	1f 92       	push	r1
    25e4:	cd b7       	in	r28, 0x3d	; 61
    25e6:	de b7       	in	r29, 0x3e	; 62
    25e8:	9a 83       	std	Y+2, r25	; 0x02
    25ea:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    25ec:	89 81       	ldd	r24, Y+1	; 0x01
    25ee:	9a 81       	ldd	r25, Y+2	; 0x02
    25f0:	fc 01       	movw	r30, r24
    25f2:	11 86       	std	Z+9, r1	; 0x09
    25f4:	10 86       	std	Z+8, r1	; 0x08
}
    25f6:	0f 90       	pop	r0
    25f8:	0f 90       	pop	r0
    25fa:	df 91       	pop	r29
    25fc:	cf 91       	pop	r28
    25fe:	08 95       	ret

00002600 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    2600:	cf 93       	push	r28
    2602:	df 93       	push	r29
    2604:	00 d0       	rcall	.+0      	; 0x2606 <vListInsertEnd+0x6>
    2606:	00 d0       	rcall	.+0      	; 0x2608 <vListInsertEnd+0x8>
    2608:	cd b7       	in	r28, 0x3d	; 61
    260a:	de b7       	in	r29, 0x3e	; 62
    260c:	9c 83       	std	Y+4, r25	; 0x04
    260e:	8b 83       	std	Y+3, r24	; 0x03
    2610:	7e 83       	std	Y+6, r23	; 0x06
    2612:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    2614:	8b 81       	ldd	r24, Y+3	; 0x03
    2616:	9c 81       	ldd	r25, Y+4	; 0x04
    2618:	fc 01       	movw	r30, r24
    261a:	81 81       	ldd	r24, Z+1	; 0x01
    261c:	92 81       	ldd	r25, Z+2	; 0x02
    261e:	9a 83       	std	Y+2, r25	; 0x02
    2620:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    2622:	89 81       	ldd	r24, Y+1	; 0x01
    2624:	9a 81       	ldd	r25, Y+2	; 0x02
    2626:	fc 01       	movw	r30, r24
    2628:	22 81       	ldd	r18, Z+2	; 0x02
    262a:	33 81       	ldd	r19, Z+3	; 0x03
    262c:	8d 81       	ldd	r24, Y+5	; 0x05
    262e:	9e 81       	ldd	r25, Y+6	; 0x06
    2630:	fc 01       	movw	r30, r24
    2632:	33 83       	std	Z+3, r19	; 0x03
    2634:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    2636:	8b 81       	ldd	r24, Y+3	; 0x03
    2638:	9c 81       	ldd	r25, Y+4	; 0x04
    263a:	fc 01       	movw	r30, r24
    263c:	21 81       	ldd	r18, Z+1	; 0x01
    263e:	32 81       	ldd	r19, Z+2	; 0x02
    2640:	8d 81       	ldd	r24, Y+5	; 0x05
    2642:	9e 81       	ldd	r25, Y+6	; 0x06
    2644:	fc 01       	movw	r30, r24
    2646:	35 83       	std	Z+5, r19	; 0x05
    2648:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    264a:	89 81       	ldd	r24, Y+1	; 0x01
    264c:	9a 81       	ldd	r25, Y+2	; 0x02
    264e:	fc 01       	movw	r30, r24
    2650:	82 81       	ldd	r24, Z+2	; 0x02
    2652:	93 81       	ldd	r25, Z+3	; 0x03
    2654:	2d 81       	ldd	r18, Y+5	; 0x05
    2656:	3e 81       	ldd	r19, Y+6	; 0x06
    2658:	fc 01       	movw	r30, r24
    265a:	35 83       	std	Z+5, r19	; 0x05
    265c:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    265e:	89 81       	ldd	r24, Y+1	; 0x01
    2660:	9a 81       	ldd	r25, Y+2	; 0x02
    2662:	2d 81       	ldd	r18, Y+5	; 0x05
    2664:	3e 81       	ldd	r19, Y+6	; 0x06
    2666:	fc 01       	movw	r30, r24
    2668:	33 83       	std	Z+3, r19	; 0x03
    266a:	22 83       	std	Z+2, r18	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    266c:	8b 81       	ldd	r24, Y+3	; 0x03
    266e:	9c 81       	ldd	r25, Y+4	; 0x04
    2670:	2d 81       	ldd	r18, Y+5	; 0x05
    2672:	3e 81       	ldd	r19, Y+6	; 0x06
    2674:	fc 01       	movw	r30, r24
    2676:	32 83       	std	Z+2, r19	; 0x02
    2678:	21 83       	std	Z+1, r18	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    267a:	8d 81       	ldd	r24, Y+5	; 0x05
    267c:	9e 81       	ldd	r25, Y+6	; 0x06
    267e:	2b 81       	ldd	r18, Y+3	; 0x03
    2680:	3c 81       	ldd	r19, Y+4	; 0x04
    2682:	fc 01       	movw	r30, r24
    2684:	31 87       	std	Z+9, r19	; 0x09
    2686:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    2688:	8b 81       	ldd	r24, Y+3	; 0x03
    268a:	9c 81       	ldd	r25, Y+4	; 0x04
    268c:	fc 01       	movw	r30, r24
    268e:	80 81       	ld	r24, Z
    2690:	21 e0       	ldi	r18, 0x01	; 1
    2692:	28 0f       	add	r18, r24
    2694:	8b 81       	ldd	r24, Y+3	; 0x03
    2696:	9c 81       	ldd	r25, Y+4	; 0x04
    2698:	fc 01       	movw	r30, r24
    269a:	20 83       	st	Z, r18
}
    269c:	26 96       	adiw	r28, 0x06	; 6
    269e:	0f b6       	in	r0, 0x3f	; 63
    26a0:	f8 94       	cli
    26a2:	de bf       	out	0x3e, r29	; 62
    26a4:	0f be       	out	0x3f, r0	; 63
    26a6:	cd bf       	out	0x3d, r28	; 61
    26a8:	df 91       	pop	r29
    26aa:	cf 91       	pop	r28
    26ac:	08 95       	ret

000026ae <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    26ae:	cf 93       	push	r28
    26b0:	df 93       	push	r29
    26b2:	cd b7       	in	r28, 0x3d	; 61
    26b4:	de b7       	in	r29, 0x3e	; 62
    26b6:	28 97       	sbiw	r28, 0x08	; 8
    26b8:	0f b6       	in	r0, 0x3f	; 63
    26ba:	f8 94       	cli
    26bc:	de bf       	out	0x3e, r29	; 62
    26be:	0f be       	out	0x3f, r0	; 63
    26c0:	cd bf       	out	0x3d, r28	; 61
    26c2:	9e 83       	std	Y+6, r25	; 0x06
    26c4:	8d 83       	std	Y+5, r24	; 0x05
    26c6:	78 87       	std	Y+8, r23	; 0x08
    26c8:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    26ca:	8f 81       	ldd	r24, Y+7	; 0x07
    26cc:	98 85       	ldd	r25, Y+8	; 0x08
    26ce:	fc 01       	movw	r30, r24
    26d0:	80 81       	ld	r24, Z
    26d2:	91 81       	ldd	r25, Z+1	; 0x01
    26d4:	9c 83       	std	Y+4, r25	; 0x04
    26d6:	8b 83       	std	Y+3, r24	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    26d8:	8b 81       	ldd	r24, Y+3	; 0x03
    26da:	9c 81       	ldd	r25, Y+4	; 0x04
    26dc:	8f 3f       	cpi	r24, 0xFF	; 255
    26de:	ff ef       	ldi	r31, 0xFF	; 255
    26e0:	9f 07       	cpc	r25, r31
    26e2:	41 f4       	brne	.+16     	; 0x26f4 <vListInsert+0x46>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    26e4:	8d 81       	ldd	r24, Y+5	; 0x05
    26e6:	9e 81       	ldd	r25, Y+6	; 0x06
    26e8:	fc 01       	movw	r30, r24
    26ea:	87 81       	ldd	r24, Z+7	; 0x07
    26ec:	90 85       	ldd	r25, Z+8	; 0x08
    26ee:	9a 83       	std	Y+2, r25	; 0x02
    26f0:	89 83       	std	Y+1, r24	; 0x01
    26f2:	1a c0       	rjmp	.+52     	; 0x2728 <vListInsert+0x7a>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    26f4:	8d 81       	ldd	r24, Y+5	; 0x05
    26f6:	9e 81       	ldd	r25, Y+6	; 0x06
    26f8:	03 96       	adiw	r24, 0x03	; 3
    26fa:	9a 83       	std	Y+2, r25	; 0x02
    26fc:	89 83       	std	Y+1, r24	; 0x01
    26fe:	07 c0       	rjmp	.+14     	; 0x270e <vListInsert+0x60>
    2700:	89 81       	ldd	r24, Y+1	; 0x01
    2702:	9a 81       	ldd	r25, Y+2	; 0x02
    2704:	fc 01       	movw	r30, r24
    2706:	82 81       	ldd	r24, Z+2	; 0x02
    2708:	93 81       	ldd	r25, Z+3	; 0x03
    270a:	9a 83       	std	Y+2, r25	; 0x02
    270c:	89 83       	std	Y+1, r24	; 0x01
    270e:	89 81       	ldd	r24, Y+1	; 0x01
    2710:	9a 81       	ldd	r25, Y+2	; 0x02
    2712:	fc 01       	movw	r30, r24
    2714:	82 81       	ldd	r24, Z+2	; 0x02
    2716:	93 81       	ldd	r25, Z+3	; 0x03
    2718:	fc 01       	movw	r30, r24
    271a:	20 81       	ld	r18, Z
    271c:	31 81       	ldd	r19, Z+1	; 0x01
    271e:	8b 81       	ldd	r24, Y+3	; 0x03
    2720:	9c 81       	ldd	r25, Y+4	; 0x04
    2722:	82 17       	cp	r24, r18
    2724:	93 07       	cpc	r25, r19
    2726:	60 f7       	brcc	.-40     	; 0x2700 <vListInsert+0x52>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2728:	89 81       	ldd	r24, Y+1	; 0x01
    272a:	9a 81       	ldd	r25, Y+2	; 0x02
    272c:	fc 01       	movw	r30, r24
    272e:	22 81       	ldd	r18, Z+2	; 0x02
    2730:	33 81       	ldd	r19, Z+3	; 0x03
    2732:	8f 81       	ldd	r24, Y+7	; 0x07
    2734:	98 85       	ldd	r25, Y+8	; 0x08
    2736:	fc 01       	movw	r30, r24
    2738:	33 83       	std	Z+3, r19	; 0x03
    273a:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    273c:	8f 81       	ldd	r24, Y+7	; 0x07
    273e:	98 85       	ldd	r25, Y+8	; 0x08
    2740:	fc 01       	movw	r30, r24
    2742:	82 81       	ldd	r24, Z+2	; 0x02
    2744:	93 81       	ldd	r25, Z+3	; 0x03
    2746:	2f 81       	ldd	r18, Y+7	; 0x07
    2748:	38 85       	ldd	r19, Y+8	; 0x08
    274a:	fc 01       	movw	r30, r24
    274c:	35 83       	std	Z+5, r19	; 0x05
    274e:	24 83       	std	Z+4, r18	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    2750:	8f 81       	ldd	r24, Y+7	; 0x07
    2752:	98 85       	ldd	r25, Y+8	; 0x08
    2754:	29 81       	ldd	r18, Y+1	; 0x01
    2756:	3a 81       	ldd	r19, Y+2	; 0x02
    2758:	fc 01       	movw	r30, r24
    275a:	35 83       	std	Z+5, r19	; 0x05
    275c:	24 83       	std	Z+4, r18	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    275e:	89 81       	ldd	r24, Y+1	; 0x01
    2760:	9a 81       	ldd	r25, Y+2	; 0x02
    2762:	2f 81       	ldd	r18, Y+7	; 0x07
    2764:	38 85       	ldd	r19, Y+8	; 0x08
    2766:	fc 01       	movw	r30, r24
    2768:	33 83       	std	Z+3, r19	; 0x03
    276a:	22 83       	std	Z+2, r18	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    276c:	8f 81       	ldd	r24, Y+7	; 0x07
    276e:	98 85       	ldd	r25, Y+8	; 0x08
    2770:	2d 81       	ldd	r18, Y+5	; 0x05
    2772:	3e 81       	ldd	r19, Y+6	; 0x06
    2774:	fc 01       	movw	r30, r24
    2776:	31 87       	std	Z+9, r19	; 0x09
    2778:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    277a:	8d 81       	ldd	r24, Y+5	; 0x05
    277c:	9e 81       	ldd	r25, Y+6	; 0x06
    277e:	fc 01       	movw	r30, r24
    2780:	80 81       	ld	r24, Z
    2782:	21 e0       	ldi	r18, 0x01	; 1
    2784:	28 0f       	add	r18, r24
    2786:	8d 81       	ldd	r24, Y+5	; 0x05
    2788:	9e 81       	ldd	r25, Y+6	; 0x06
    278a:	fc 01       	movw	r30, r24
    278c:	20 83       	st	Z, r18
}
    278e:	28 96       	adiw	r28, 0x08	; 8
    2790:	0f b6       	in	r0, 0x3f	; 63
    2792:	f8 94       	cli
    2794:	de bf       	out	0x3e, r29	; 62
    2796:	0f be       	out	0x3f, r0	; 63
    2798:	cd bf       	out	0x3d, r28	; 61
    279a:	df 91       	pop	r29
    279c:	cf 91       	pop	r28
    279e:	08 95       	ret

000027a0 <uxListRemove>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
{
    27a0:	cf 93       	push	r28
    27a2:	df 93       	push	r29
    27a4:	00 d0       	rcall	.+0      	; 0x27a6 <uxListRemove+0x6>
    27a6:	1f 92       	push	r1
    27a8:	cd b7       	in	r28, 0x3d	; 61
    27aa:	de b7       	in	r29, 0x3e	; 62
    27ac:	9c 83       	std	Y+4, r25	; 0x04
    27ae:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    27b0:	8b 81       	ldd	r24, Y+3	; 0x03
    27b2:	9c 81       	ldd	r25, Y+4	; 0x04
    27b4:	fc 01       	movw	r30, r24
    27b6:	82 81       	ldd	r24, Z+2	; 0x02
    27b8:	93 81       	ldd	r25, Z+3	; 0x03
    27ba:	2b 81       	ldd	r18, Y+3	; 0x03
    27bc:	3c 81       	ldd	r19, Y+4	; 0x04
    27be:	f9 01       	movw	r30, r18
    27c0:	24 81       	ldd	r18, Z+4	; 0x04
    27c2:	35 81       	ldd	r19, Z+5	; 0x05
    27c4:	fc 01       	movw	r30, r24
    27c6:	35 83       	std	Z+5, r19	; 0x05
    27c8:	24 83       	std	Z+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    27ca:	8b 81       	ldd	r24, Y+3	; 0x03
    27cc:	9c 81       	ldd	r25, Y+4	; 0x04
    27ce:	fc 01       	movw	r30, r24
    27d0:	84 81       	ldd	r24, Z+4	; 0x04
    27d2:	95 81       	ldd	r25, Z+5	; 0x05
    27d4:	2b 81       	ldd	r18, Y+3	; 0x03
    27d6:	3c 81       	ldd	r19, Y+4	; 0x04
    27d8:	f9 01       	movw	r30, r18
    27da:	22 81       	ldd	r18, Z+2	; 0x02
    27dc:	33 81       	ldd	r19, Z+3	; 0x03
    27de:	fc 01       	movw	r30, r24
    27e0:	33 83       	std	Z+3, r19	; 0x03
    27e2:	22 83       	std	Z+2, r18	; 0x02

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    27e4:	8b 81       	ldd	r24, Y+3	; 0x03
    27e6:	9c 81       	ldd	r25, Y+4	; 0x04
    27e8:	fc 01       	movw	r30, r24
    27ea:	80 85       	ldd	r24, Z+8	; 0x08
    27ec:	91 85       	ldd	r25, Z+9	; 0x09
    27ee:	9a 83       	std	Y+2, r25	; 0x02
    27f0:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    27f2:	89 81       	ldd	r24, Y+1	; 0x01
    27f4:	9a 81       	ldd	r25, Y+2	; 0x02
    27f6:	fc 01       	movw	r30, r24
    27f8:	21 81       	ldd	r18, Z+1	; 0x01
    27fa:	32 81       	ldd	r19, Z+2	; 0x02
    27fc:	8b 81       	ldd	r24, Y+3	; 0x03
    27fe:	9c 81       	ldd	r25, Y+4	; 0x04
    2800:	28 17       	cp	r18, r24
    2802:	39 07       	cpc	r19, r25
    2804:	51 f4       	brne	.+20     	; 0x281a <uxListRemove+0x7a>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2806:	8b 81       	ldd	r24, Y+3	; 0x03
    2808:	9c 81       	ldd	r25, Y+4	; 0x04
    280a:	fc 01       	movw	r30, r24
    280c:	24 81       	ldd	r18, Z+4	; 0x04
    280e:	35 81       	ldd	r19, Z+5	; 0x05
    2810:	89 81       	ldd	r24, Y+1	; 0x01
    2812:	9a 81       	ldd	r25, Y+2	; 0x02
    2814:	fc 01       	movw	r30, r24
    2816:	32 83       	std	Z+2, r19	; 0x02
    2818:	21 83       	std	Z+1, r18	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    281a:	8b 81       	ldd	r24, Y+3	; 0x03
    281c:	9c 81       	ldd	r25, Y+4	; 0x04
    281e:	fc 01       	movw	r30, r24
    2820:	11 86       	std	Z+9, r1	; 0x09
    2822:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    2824:	89 81       	ldd	r24, Y+1	; 0x01
    2826:	9a 81       	ldd	r25, Y+2	; 0x02
    2828:	fc 01       	movw	r30, r24
    282a:	80 81       	ld	r24, Z
    282c:	2f ef       	ldi	r18, 0xFF	; 255
    282e:	28 0f       	add	r18, r24
    2830:	89 81       	ldd	r24, Y+1	; 0x01
    2832:	9a 81       	ldd	r25, Y+2	; 0x02
    2834:	fc 01       	movw	r30, r24
    2836:	20 83       	st	Z, r18

	return pxList->uxNumberOfItems;
    2838:	89 81       	ldd	r24, Y+1	; 0x01
    283a:	9a 81       	ldd	r25, Y+2	; 0x02
    283c:	fc 01       	movw	r30, r24
    283e:	80 81       	ld	r24, Z
}
    2840:	0f 90       	pop	r0
    2842:	0f 90       	pop	r0
    2844:	0f 90       	pop	r0
    2846:	0f 90       	pop	r0
    2848:	df 91       	pop	r29
    284a:	cf 91       	pop	r28
    284c:	08 95       	ret

0000284e <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    284e:	cf 93       	push	r28
    2850:	df 93       	push	r29
    2852:	cd b7       	in	r28, 0x3d	; 61
    2854:	de b7       	in	r29, 0x3e	; 62
    2856:	27 97       	sbiw	r28, 0x07	; 7
    2858:	0f b6       	in	r0, 0x3f	; 63
    285a:	f8 94       	cli
    285c:	de bf       	out	0x3e, r29	; 62
    285e:	0f be       	out	0x3f, r0	; 63
    2860:	cd bf       	out	0x3d, r28	; 61
    2862:	9d 83       	std	Y+5, r25	; 0x05
    2864:	8c 83       	std	Y+4, r24	; 0x04
    2866:	6e 83       	std	Y+6, r22	; 0x06
    2868:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    286a:	8a e1       	ldi	r24, 0x1A	; 26
    286c:	90 e0       	ldi	r25, 0x00	; 0
    286e:	0e 94 1f 17 	call	0x2e3e	; 0x2e3e <pvPortMalloc>
    2872:	9b 83       	std	Y+3, r25	; 0x03
    2874:	8a 83       	std	Y+2, r24	; 0x02
	if( pxCoRoutine )
    2876:	8a 81       	ldd	r24, Y+2	; 0x02
    2878:	9b 81       	ldd	r25, Y+3	; 0x03
    287a:	00 97       	sbiw	r24, 0x00	; 0
    287c:	09 f4       	brne	.+2      	; 0x2880 <xCoRoutineCreate+0x32>
    287e:	77 c0       	rjmp	.+238    	; 0x296e <xCoRoutineCreate+0x120>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    2880:	80 91 89 02 	lds	r24, 0x0289
    2884:	90 91 8a 02 	lds	r25, 0x028A
    2888:	00 97       	sbiw	r24, 0x00	; 0
    288a:	41 f4       	brne	.+16     	; 0x289c <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    288c:	8a 81       	ldd	r24, Y+2	; 0x02
    288e:	9b 81       	ldd	r25, Y+3	; 0x03
    2890:	90 93 8a 02 	sts	0x028A, r25
    2894:	80 93 89 02 	sts	0x0289, r24
			prvInitialiseCoRoutineLists();
    2898:	0e 94 ad 16 	call	0x2d5a	; 0x2d5a <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    289c:	8e 81       	ldd	r24, Y+6	; 0x06
    289e:	82 30       	cpi	r24, 0x02	; 2
    28a0:	10 f0       	brcs	.+4      	; 0x28a6 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    28a2:	81 e0       	ldi	r24, 0x01	; 1
    28a4:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    28a6:	8a 81       	ldd	r24, Y+2	; 0x02
    28a8:	9b 81       	ldd	r25, Y+3	; 0x03
    28aa:	fc 01       	movw	r30, r24
    28ac:	11 8e       	std	Z+25, r1	; 0x19
    28ae:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    28b0:	8a 81       	ldd	r24, Y+2	; 0x02
    28b2:	9b 81       	ldd	r25, Y+3	; 0x03
    28b4:	2e 81       	ldd	r18, Y+6	; 0x06
    28b6:	fc 01       	movw	r30, r24
    28b8:	26 8b       	std	Z+22, r18	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    28ba:	8a 81       	ldd	r24, Y+2	; 0x02
    28bc:	9b 81       	ldd	r25, Y+3	; 0x03
    28be:	2f 81       	ldd	r18, Y+7	; 0x07
    28c0:	fc 01       	movw	r30, r24
    28c2:	27 8b       	std	Z+23, r18	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    28c4:	8a 81       	ldd	r24, Y+2	; 0x02
    28c6:	9b 81       	ldd	r25, Y+3	; 0x03
    28c8:	2c 81       	ldd	r18, Y+4	; 0x04
    28ca:	3d 81       	ldd	r19, Y+5	; 0x05
    28cc:	fc 01       	movw	r30, r24
    28ce:	31 83       	std	Z+1, r19	; 0x01
    28d0:	20 83       	st	Z, r18

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    28d2:	8a 81       	ldd	r24, Y+2	; 0x02
    28d4:	9b 81       	ldd	r25, Y+3	; 0x03
    28d6:	02 96       	adiw	r24, 0x02	; 2
    28d8:	0e 94 ee 12 	call	0x25dc	; 0x25dc <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    28dc:	8a 81       	ldd	r24, Y+2	; 0x02
    28de:	9b 81       	ldd	r25, Y+3	; 0x03
    28e0:	0c 96       	adiw	r24, 0x0c	; 12
    28e2:	0e 94 ee 12 	call	0x25dc	; 0x25dc <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    28e6:	8a 81       	ldd	r24, Y+2	; 0x02
    28e8:	9b 81       	ldd	r25, Y+3	; 0x03
    28ea:	2a 81       	ldd	r18, Y+2	; 0x02
    28ec:	3b 81       	ldd	r19, Y+3	; 0x03
    28ee:	fc 01       	movw	r30, r24
    28f0:	31 87       	std	Z+9, r19	; 0x09
    28f2:	20 87       	std	Z+8, r18	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    28f4:	8a 81       	ldd	r24, Y+2	; 0x02
    28f6:	9b 81       	ldd	r25, Y+3	; 0x03
    28f8:	2a 81       	ldd	r18, Y+2	; 0x02
    28fa:	3b 81       	ldd	r19, Y+3	; 0x03
    28fc:	fc 01       	movw	r30, r24
    28fe:	33 8b       	std	Z+19, r19	; 0x13
    2900:	22 8b       	std	Z+18, r18	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    2902:	8e 81       	ldd	r24, Y+6	; 0x06
    2904:	88 2f       	mov	r24, r24
    2906:	90 e0       	ldi	r25, 0x00	; 0
    2908:	24 e0       	ldi	r18, 0x04	; 4
    290a:	30 e0       	ldi	r19, 0x00	; 0
    290c:	28 1b       	sub	r18, r24
    290e:	39 0b       	sbc	r19, r25
    2910:	8a 81       	ldd	r24, Y+2	; 0x02
    2912:	9b 81       	ldd	r25, Y+3	; 0x03
    2914:	fc 01       	movw	r30, r24
    2916:	35 87       	std	Z+13, r19	; 0x0d
    2918:	24 87       	std	Z+12, r18	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    291a:	8a 81       	ldd	r24, Y+2	; 0x02
    291c:	9b 81       	ldd	r25, Y+3	; 0x03
    291e:	fc 01       	movw	r30, r24
    2920:	96 89       	ldd	r25, Z+22	; 0x16
    2922:	80 91 bc 02 	lds	r24, 0x02BC
    2926:	89 17       	cp	r24, r25
    2928:	30 f4       	brcc	.+12     	; 0x2936 <xCoRoutineCreate+0xe8>
    292a:	8a 81       	ldd	r24, Y+2	; 0x02
    292c:	9b 81       	ldd	r25, Y+3	; 0x03
    292e:	fc 01       	movw	r30, r24
    2930:	86 89       	ldd	r24, Z+22	; 0x16
    2932:	80 93 bc 02 	sts	0x02BC, r24
    2936:	8a 81       	ldd	r24, Y+2	; 0x02
    2938:	9b 81       	ldd	r25, Y+3	; 0x03
    293a:	ac 01       	movw	r20, r24
    293c:	4e 5f       	subi	r20, 0xFE	; 254
    293e:	5f 4f       	sbci	r21, 0xFF	; 255
    2940:	8a 81       	ldd	r24, Y+2	; 0x02
    2942:	9b 81       	ldd	r25, Y+3	; 0x03
    2944:	fc 01       	movw	r30, r24
    2946:	86 89       	ldd	r24, Z+22	; 0x16
    2948:	28 2f       	mov	r18, r24
    294a:	30 e0       	ldi	r19, 0x00	; 0
    294c:	c9 01       	movw	r24, r18
    294e:	88 0f       	add	r24, r24
    2950:	99 1f       	adc	r25, r25
    2952:	88 0f       	add	r24, r24
    2954:	99 1f       	adc	r25, r25
    2956:	88 0f       	add	r24, r24
    2958:	99 1f       	adc	r25, r25
    295a:	82 0f       	add	r24, r18
    295c:	93 1f       	adc	r25, r19
    295e:	85 57       	subi	r24, 0x75	; 117
    2960:	9d 4f       	sbci	r25, 0xFD	; 253
    2962:	ba 01       	movw	r22, r20
    2964:	0e 94 00 13 	call	0x2600	; 0x2600 <vListInsertEnd>

		xReturn = pdPASS;
    2968:	81 e0       	ldi	r24, 0x01	; 1
    296a:	89 83       	std	Y+1, r24	; 0x01
    296c:	02 c0       	rjmp	.+4      	; 0x2972 <xCoRoutineCreate+0x124>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    296e:	8f ef       	ldi	r24, 0xFF	; 255
    2970:	89 83       	std	Y+1, r24	; 0x01
	}
	
	return xReturn;	
    2972:	89 81       	ldd	r24, Y+1	; 0x01
}
    2974:	27 96       	adiw	r28, 0x07	; 7
    2976:	0f b6       	in	r0, 0x3f	; 63
    2978:	f8 94       	cli
    297a:	de bf       	out	0x3e, r29	; 62
    297c:	0f be       	out	0x3f, r0	; 63
    297e:	cd bf       	out	0x3d, r28	; 61
    2980:	df 91       	pop	r29
    2982:	cf 91       	pop	r28
    2984:	08 95       	ret

00002986 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    2986:	cf 93       	push	r28
    2988:	df 93       	push	r29
    298a:	00 d0       	rcall	.+0      	; 0x298c <vCoRoutineAddToDelayedList+0x6>
    298c:	00 d0       	rcall	.+0      	; 0x298e <vCoRoutineAddToDelayedList+0x8>
    298e:	cd b7       	in	r28, 0x3d	; 61
    2990:	de b7       	in	r29, 0x3e	; 62
    2992:	9c 83       	std	Y+4, r25	; 0x04
    2994:	8b 83       	std	Y+3, r24	; 0x03
    2996:	7e 83       	std	Y+6, r23	; 0x06
    2998:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    299a:	20 91 bd 02 	lds	r18, 0x02BD
    299e:	30 91 be 02 	lds	r19, 0x02BE
    29a2:	8b 81       	ldd	r24, Y+3	; 0x03
    29a4:	9c 81       	ldd	r25, Y+4	; 0x04
    29a6:	82 0f       	add	r24, r18
    29a8:	93 1f       	adc	r25, r19
    29aa:	9a 83       	std	Y+2, r25	; 0x02
    29ac:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    29ae:	80 91 89 02 	lds	r24, 0x0289
    29b2:	90 91 8a 02 	lds	r25, 0x028A
    29b6:	02 96       	adiw	r24, 0x02	; 2
    29b8:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    29bc:	80 91 89 02 	lds	r24, 0x0289
    29c0:	90 91 8a 02 	lds	r25, 0x028A
    29c4:	29 81       	ldd	r18, Y+1	; 0x01
    29c6:	3a 81       	ldd	r19, Y+2	; 0x02
    29c8:	fc 01       	movw	r30, r24
    29ca:	33 83       	std	Z+3, r19	; 0x03
    29cc:	22 83       	std	Z+2, r18	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    29ce:	80 91 bd 02 	lds	r24, 0x02BD
    29d2:	90 91 be 02 	lds	r25, 0x02BE
    29d6:	29 81       	ldd	r18, Y+1	; 0x01
    29d8:	3a 81       	ldd	r19, Y+2	; 0x02
    29da:	28 17       	cp	r18, r24
    29dc:	39 07       	cpc	r19, r25
    29de:	78 f4       	brcc	.+30     	; 0x29fe <vCoRoutineAddToDelayedList+0x78>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    29e0:	80 91 89 02 	lds	r24, 0x0289
    29e4:	90 91 8a 02 	lds	r25, 0x028A
    29e8:	9c 01       	movw	r18, r24
    29ea:	2e 5f       	subi	r18, 0xFE	; 254
    29ec:	3f 4f       	sbci	r19, 0xFF	; 255
    29ee:	80 91 b1 02 	lds	r24, 0x02B1
    29f2:	90 91 b2 02 	lds	r25, 0x02B2
    29f6:	b9 01       	movw	r22, r18
    29f8:	0e 94 57 13 	call	0x26ae	; 0x26ae <vListInsert>
    29fc:	0e c0       	rjmp	.+28     	; 0x2a1a <vCoRoutineAddToDelayedList+0x94>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    29fe:	80 91 89 02 	lds	r24, 0x0289
    2a02:	90 91 8a 02 	lds	r25, 0x028A
    2a06:	9c 01       	movw	r18, r24
    2a08:	2e 5f       	subi	r18, 0xFE	; 254
    2a0a:	3f 4f       	sbci	r19, 0xFF	; 255
    2a0c:	80 91 af 02 	lds	r24, 0x02AF
    2a10:	90 91 b0 02 	lds	r25, 0x02B0
    2a14:	b9 01       	movw	r22, r18
    2a16:	0e 94 57 13 	call	0x26ae	; 0x26ae <vListInsert>
	}

	if( pxEventList )
    2a1a:	8d 81       	ldd	r24, Y+5	; 0x05
    2a1c:	9e 81       	ldd	r25, Y+6	; 0x06
    2a1e:	00 97       	sbiw	r24, 0x00	; 0
    2a20:	61 f0       	breq	.+24     	; 0x2a3a <vCoRoutineAddToDelayedList+0xb4>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    2a22:	80 91 89 02 	lds	r24, 0x0289
    2a26:	90 91 8a 02 	lds	r25, 0x028A
    2a2a:	9c 01       	movw	r18, r24
    2a2c:	24 5f       	subi	r18, 0xF4	; 244
    2a2e:	3f 4f       	sbci	r19, 0xFF	; 255
    2a30:	8d 81       	ldd	r24, Y+5	; 0x05
    2a32:	9e 81       	ldd	r25, Y+6	; 0x06
    2a34:	b9 01       	movw	r22, r18
    2a36:	0e 94 57 13 	call	0x26ae	; 0x26ae <vListInsert>
	}
}
    2a3a:	26 96       	adiw	r28, 0x06	; 6
    2a3c:	0f b6       	in	r0, 0x3f	; 63
    2a3e:	f8 94       	cli
    2a40:	de bf       	out	0x3e, r29	; 62
    2a42:	0f be       	out	0x3f, r0	; 63
    2a44:	cd bf       	out	0x3d, r28	; 61
    2a46:	df 91       	pop	r29
    2a48:	cf 91       	pop	r28
    2a4a:	08 95       	ret

00002a4c <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    2a4c:	cf 93       	push	r28
    2a4e:	df 93       	push	r29
    2a50:	1f 92       	push	r1
    2a52:	1f 92       	push	r1
    2a54:	cd b7       	in	r28, 0x3d	; 61
    2a56:	de b7       	in	r29, 0x3e	; 62
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    2a58:	3c c0       	rjmp	.+120    	; 0x2ad2 <prvCheckPendingReadyList+0x86>
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    2a5a:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    2a5c:	80 91 b8 02 	lds	r24, 0x02B8
    2a60:	90 91 b9 02 	lds	r25, 0x02B9
    2a64:	fc 01       	movw	r30, r24
    2a66:	86 81       	ldd	r24, Z+6	; 0x06
    2a68:	97 81       	ldd	r25, Z+7	; 0x07
    2a6a:	9a 83       	std	Y+2, r25	; 0x02
    2a6c:	89 83       	std	Y+1, r24	; 0x01
			uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2a6e:	89 81       	ldd	r24, Y+1	; 0x01
    2a70:	9a 81       	ldd	r25, Y+2	; 0x02
    2a72:	0c 96       	adiw	r24, 0x0c	; 12
    2a74:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    2a78:	78 94       	sei

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    2a7a:	89 81       	ldd	r24, Y+1	; 0x01
    2a7c:	9a 81       	ldd	r25, Y+2	; 0x02
    2a7e:	02 96       	adiw	r24, 0x02	; 2
    2a80:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    2a84:	89 81       	ldd	r24, Y+1	; 0x01
    2a86:	9a 81       	ldd	r25, Y+2	; 0x02
    2a88:	fc 01       	movw	r30, r24
    2a8a:	96 89       	ldd	r25, Z+22	; 0x16
    2a8c:	80 91 bc 02 	lds	r24, 0x02BC
    2a90:	89 17       	cp	r24, r25
    2a92:	30 f4       	brcc	.+12     	; 0x2aa0 <prvCheckPendingReadyList+0x54>
    2a94:	89 81       	ldd	r24, Y+1	; 0x01
    2a96:	9a 81       	ldd	r25, Y+2	; 0x02
    2a98:	fc 01       	movw	r30, r24
    2a9a:	86 89       	ldd	r24, Z+22	; 0x16
    2a9c:	80 93 bc 02 	sts	0x02BC, r24
    2aa0:	89 81       	ldd	r24, Y+1	; 0x01
    2aa2:	9a 81       	ldd	r25, Y+2	; 0x02
    2aa4:	ac 01       	movw	r20, r24
    2aa6:	4e 5f       	subi	r20, 0xFE	; 254
    2aa8:	5f 4f       	sbci	r21, 0xFF	; 255
    2aaa:	89 81       	ldd	r24, Y+1	; 0x01
    2aac:	9a 81       	ldd	r25, Y+2	; 0x02
    2aae:	fc 01       	movw	r30, r24
    2ab0:	86 89       	ldd	r24, Z+22	; 0x16
    2ab2:	28 2f       	mov	r18, r24
    2ab4:	30 e0       	ldi	r19, 0x00	; 0
    2ab6:	c9 01       	movw	r24, r18
    2ab8:	88 0f       	add	r24, r24
    2aba:	99 1f       	adc	r25, r25
    2abc:	88 0f       	add	r24, r24
    2abe:	99 1f       	adc	r25, r25
    2ac0:	88 0f       	add	r24, r24
    2ac2:	99 1f       	adc	r25, r25
    2ac4:	82 0f       	add	r24, r18
    2ac6:	93 1f       	adc	r25, r19
    2ac8:	85 57       	subi	r24, 0x75	; 117
    2aca:	9d 4f       	sbci	r25, 0xFD	; 253
    2acc:	ba 01       	movw	r22, r20
    2ace:	0e 94 00 13 	call	0x2600	; 0x2600 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    2ad2:	80 91 b3 02 	lds	r24, 0x02B3
    2ad6:	88 23       	and	r24, r24
    2ad8:	09 f0       	breq	.+2      	; 0x2adc <prvCheckPendingReadyList+0x90>
    2ada:	bf cf       	rjmp	.-130    	; 0x2a5a <prvCheckPendingReadyList+0xe>
		portENABLE_INTERRUPTS();

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    2adc:	0f 90       	pop	r0
    2ade:	0f 90       	pop	r0
    2ae0:	df 91       	pop	r29
    2ae2:	cf 91       	pop	r28
    2ae4:	08 95       	ret

00002ae6 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    2ae6:	cf 93       	push	r28
    2ae8:	df 93       	push	r29
    2aea:	00 d0       	rcall	.+0      	; 0x2aec <prvCheckDelayedList+0x6>
    2aec:	1f 92       	push	r1
    2aee:	cd b7       	in	r28, 0x3d	; 61
    2af0:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    2af2:	0e 94 81 07 	call	0xf02	; 0xf02 <xTaskGetTickCount>
    2af6:	9c 01       	movw	r18, r24
    2af8:	80 91 bf 02 	lds	r24, 0x02BF
    2afc:	90 91 c0 02 	lds	r25, 0x02C0
    2b00:	a9 01       	movw	r20, r18
    2b02:	48 1b       	sub	r20, r24
    2b04:	59 0b       	sbc	r21, r25
    2b06:	ca 01       	movw	r24, r20
    2b08:	90 93 c2 02 	sts	0x02C2, r25
    2b0c:	80 93 c1 02 	sts	0x02C1, r24
	while( xPassedTicks )
    2b10:	8a c0       	rjmp	.+276    	; 0x2c26 <prvCheckDelayedList+0x140>
	{
		xCoRoutineTickCount++;
    2b12:	80 91 bd 02 	lds	r24, 0x02BD
    2b16:	90 91 be 02 	lds	r25, 0x02BE
    2b1a:	01 96       	adiw	r24, 0x01	; 1
    2b1c:	90 93 be 02 	sts	0x02BE, r25
    2b20:	80 93 bd 02 	sts	0x02BD, r24
		xPassedTicks--;
    2b24:	80 91 c1 02 	lds	r24, 0x02C1
    2b28:	90 91 c2 02 	lds	r25, 0x02C2
    2b2c:	01 97       	sbiw	r24, 0x01	; 1
    2b2e:	90 93 c2 02 	sts	0x02C2, r25
    2b32:	80 93 c1 02 	sts	0x02C1, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    2b36:	80 91 bd 02 	lds	r24, 0x02BD
    2b3a:	90 91 be 02 	lds	r25, 0x02BE
    2b3e:	00 97       	sbiw	r24, 0x00	; 0
    2b40:	a9 f4       	brne	.+42     	; 0x2b6c <prvCheckDelayedList+0x86>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    2b42:	80 91 af 02 	lds	r24, 0x02AF
    2b46:	90 91 b0 02 	lds	r25, 0x02B0
    2b4a:	9a 83       	std	Y+2, r25	; 0x02
    2b4c:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    2b4e:	80 91 b1 02 	lds	r24, 0x02B1
    2b52:	90 91 b2 02 	lds	r25, 0x02B2
    2b56:	90 93 b0 02 	sts	0x02B0, r25
    2b5a:	80 93 af 02 	sts	0x02AF, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    2b5e:	89 81       	ldd	r24, Y+1	; 0x01
    2b60:	9a 81       	ldd	r25, Y+2	; 0x02
    2b62:	90 93 b2 02 	sts	0x02B2, r25
    2b66:	80 93 b1 02 	sts	0x02B1, r24
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    2b6a:	54 c0       	rjmp	.+168    	; 0x2c14 <prvCheckDelayedList+0x12e>
    2b6c:	53 c0       	rjmp	.+166    	; 0x2c14 <prvCheckDelayedList+0x12e>
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    2b6e:	80 91 af 02 	lds	r24, 0x02AF
    2b72:	90 91 b0 02 	lds	r25, 0x02B0
    2b76:	fc 01       	movw	r30, r24
    2b78:	85 81       	ldd	r24, Z+5	; 0x05
    2b7a:	96 81       	ldd	r25, Z+6	; 0x06
    2b7c:	fc 01       	movw	r30, r24
    2b7e:	86 81       	ldd	r24, Z+6	; 0x06
    2b80:	97 81       	ldd	r25, Z+7	; 0x07
    2b82:	9c 83       	std	Y+4, r25	; 0x04
    2b84:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    2b86:	8b 81       	ldd	r24, Y+3	; 0x03
    2b88:	9c 81       	ldd	r25, Y+4	; 0x04
    2b8a:	fc 01       	movw	r30, r24
    2b8c:	22 81       	ldd	r18, Z+2	; 0x02
    2b8e:	33 81       	ldd	r19, Z+3	; 0x03
    2b90:	80 91 bd 02 	lds	r24, 0x02BD
    2b94:	90 91 be 02 	lds	r25, 0x02BE
    2b98:	82 17       	cp	r24, r18
    2b9a:	93 07       	cpc	r25, r19
    2b9c:	08 f4       	brcc	.+2      	; 0x2ba0 <prvCheckDelayedList+0xba>
			{			
				/* Timeout not yet expired. */																			
				break;																				
    2b9e:	43 c0       	rjmp	.+134    	; 0x2c26 <prvCheckDelayedList+0x140>
			}																						

			portDISABLE_INTERRUPTS();
    2ba0:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				uxListRemove( &( pxCRCB->xGenericListItem ) );											
    2ba2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ba4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ba6:	02 96       	adiw	r24, 0x02	; 2
    2ba8:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <uxListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    2bac:	8b 81       	ldd	r24, Y+3	; 0x03
    2bae:	9c 81       	ldd	r25, Y+4	; 0x04
    2bb0:	fc 01       	movw	r30, r24
    2bb2:	84 89       	ldd	r24, Z+20	; 0x14
    2bb4:	95 89       	ldd	r25, Z+21	; 0x15
    2bb6:	00 97       	sbiw	r24, 0x00	; 0
    2bb8:	29 f0       	breq	.+10     	; 0x2bc4 <prvCheckDelayedList+0xde>
				{															
					uxListRemove( &( pxCRCB->xEventListItem ) );											
    2bba:	8b 81       	ldd	r24, Y+3	; 0x03
    2bbc:	9c 81       	ldd	r25, Y+4	; 0x04
    2bbe:	0c 96       	adiw	r24, 0x0c	; 12
    2bc0:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    2bc4:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    2bc6:	8b 81       	ldd	r24, Y+3	; 0x03
    2bc8:	9c 81       	ldd	r25, Y+4	; 0x04
    2bca:	fc 01       	movw	r30, r24
    2bcc:	96 89       	ldd	r25, Z+22	; 0x16
    2bce:	80 91 bc 02 	lds	r24, 0x02BC
    2bd2:	89 17       	cp	r24, r25
    2bd4:	30 f4       	brcc	.+12     	; 0x2be2 <prvCheckDelayedList+0xfc>
    2bd6:	8b 81       	ldd	r24, Y+3	; 0x03
    2bd8:	9c 81       	ldd	r25, Y+4	; 0x04
    2bda:	fc 01       	movw	r30, r24
    2bdc:	86 89       	ldd	r24, Z+22	; 0x16
    2bde:	80 93 bc 02 	sts	0x02BC, r24
    2be2:	8b 81       	ldd	r24, Y+3	; 0x03
    2be4:	9c 81       	ldd	r25, Y+4	; 0x04
    2be6:	ac 01       	movw	r20, r24
    2be8:	4e 5f       	subi	r20, 0xFE	; 254
    2bea:	5f 4f       	sbci	r21, 0xFF	; 255
    2bec:	8b 81       	ldd	r24, Y+3	; 0x03
    2bee:	9c 81       	ldd	r25, Y+4	; 0x04
    2bf0:	fc 01       	movw	r30, r24
    2bf2:	86 89       	ldd	r24, Z+22	; 0x16
    2bf4:	28 2f       	mov	r18, r24
    2bf6:	30 e0       	ldi	r19, 0x00	; 0
    2bf8:	c9 01       	movw	r24, r18
    2bfa:	88 0f       	add	r24, r24
    2bfc:	99 1f       	adc	r25, r25
    2bfe:	88 0f       	add	r24, r24
    2c00:	99 1f       	adc	r25, r25
    2c02:	88 0f       	add	r24, r24
    2c04:	99 1f       	adc	r25, r25
    2c06:	82 0f       	add	r24, r18
    2c08:	93 1f       	adc	r25, r19
    2c0a:	85 57       	subi	r24, 0x75	; 117
    2c0c:	9d 4f       	sbci	r25, 0xFD	; 253
    2c0e:	ba 01       	movw	r22, r20
    2c10:	0e 94 00 13 	call	0x2600	; 0x2600 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    2c14:	80 91 af 02 	lds	r24, 0x02AF
    2c18:	90 91 b0 02 	lds	r25, 0x02B0
    2c1c:	fc 01       	movw	r30, r24
    2c1e:	80 81       	ld	r24, Z
    2c20:	88 23       	and	r24, r24
    2c22:	09 f0       	breq	.+2      	; 0x2c26 <prvCheckDelayedList+0x140>
    2c24:	a4 cf       	rjmp	.-184    	; 0x2b6e <prvCheckDelayedList+0x88>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    2c26:	80 91 c1 02 	lds	r24, 0x02C1
    2c2a:	90 91 c2 02 	lds	r25, 0x02C2
    2c2e:	00 97       	sbiw	r24, 0x00	; 0
    2c30:	09 f0       	breq	.+2      	; 0x2c34 <prvCheckDelayedList+0x14e>
    2c32:	6f cf       	rjmp	.-290    	; 0x2b12 <prvCheckDelayedList+0x2c>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    2c34:	80 91 bd 02 	lds	r24, 0x02BD
    2c38:	90 91 be 02 	lds	r25, 0x02BE
    2c3c:	90 93 c0 02 	sts	0x02C0, r25
    2c40:	80 93 bf 02 	sts	0x02BF, r24
}
    2c44:	0f 90       	pop	r0
    2c46:	0f 90       	pop	r0
    2c48:	0f 90       	pop	r0
    2c4a:	0f 90       	pop	r0
    2c4c:	df 91       	pop	r29
    2c4e:	cf 91       	pop	r28
    2c50:	08 95       	ret

00002c52 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    2c52:	cf 93       	push	r28
    2c54:	df 93       	push	r29
    2c56:	1f 92       	push	r1
    2c58:	1f 92       	push	r1
    2c5a:	cd b7       	in	r28, 0x3d	; 61
    2c5c:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    2c5e:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    2c62:	0e 94 73 15 	call	0x2ae6	; 0x2ae6 <prvCheckDelayedList>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2c66:	0a c0       	rjmp	.+20     	; 0x2c7c <vCoRoutineSchedule+0x2a>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    2c68:	80 91 bc 02 	lds	r24, 0x02BC
    2c6c:	88 23       	and	r24, r24
    2c6e:	09 f4       	brne	.+2      	; 0x2c72 <vCoRoutineSchedule+0x20>
		{
			/* No more co-routines to check. */
			return;
    2c70:	6f c0       	rjmp	.+222    	; 0x2d50 <vCoRoutineSchedule+0xfe>
		}
		--uxTopCoRoutineReadyPriority;
    2c72:	80 91 bc 02 	lds	r24, 0x02BC
    2c76:	81 50       	subi	r24, 0x01	; 1
    2c78:	80 93 bc 02 	sts	0x02BC, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2c7c:	80 91 bc 02 	lds	r24, 0x02BC
    2c80:	28 2f       	mov	r18, r24
    2c82:	30 e0       	ldi	r19, 0x00	; 0
    2c84:	c9 01       	movw	r24, r18
    2c86:	88 0f       	add	r24, r24
    2c88:	99 1f       	adc	r25, r25
    2c8a:	88 0f       	add	r24, r24
    2c8c:	99 1f       	adc	r25, r25
    2c8e:	88 0f       	add	r24, r24
    2c90:	99 1f       	adc	r25, r25
    2c92:	82 0f       	add	r24, r18
    2c94:	93 1f       	adc	r25, r19
    2c96:	85 57       	subi	r24, 0x75	; 117
    2c98:	9d 4f       	sbci	r25, 0xFD	; 253
    2c9a:	fc 01       	movw	r30, r24
    2c9c:	80 81       	ld	r24, Z
    2c9e:	88 23       	and	r24, r24
    2ca0:	19 f3       	breq	.-58     	; 0x2c68 <vCoRoutineSchedule+0x16>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    2ca2:	80 91 bc 02 	lds	r24, 0x02BC
    2ca6:	28 2f       	mov	r18, r24
    2ca8:	30 e0       	ldi	r19, 0x00	; 0
    2caa:	c9 01       	movw	r24, r18
    2cac:	88 0f       	add	r24, r24
    2cae:	99 1f       	adc	r25, r25
    2cb0:	88 0f       	add	r24, r24
    2cb2:	99 1f       	adc	r25, r25
    2cb4:	88 0f       	add	r24, r24
    2cb6:	99 1f       	adc	r25, r25
    2cb8:	82 0f       	add	r24, r18
    2cba:	93 1f       	adc	r25, r19
    2cbc:	85 57       	subi	r24, 0x75	; 117
    2cbe:	9d 4f       	sbci	r25, 0xFD	; 253
    2cc0:	9a 83       	std	Y+2, r25	; 0x02
    2cc2:	89 83       	std	Y+1, r24	; 0x01
    2cc4:	89 81       	ldd	r24, Y+1	; 0x01
    2cc6:	9a 81       	ldd	r25, Y+2	; 0x02
    2cc8:	fc 01       	movw	r30, r24
    2cca:	81 81       	ldd	r24, Z+1	; 0x01
    2ccc:	92 81       	ldd	r25, Z+2	; 0x02
    2cce:	fc 01       	movw	r30, r24
    2cd0:	22 81       	ldd	r18, Z+2	; 0x02
    2cd2:	33 81       	ldd	r19, Z+3	; 0x03
    2cd4:	89 81       	ldd	r24, Y+1	; 0x01
    2cd6:	9a 81       	ldd	r25, Y+2	; 0x02
    2cd8:	fc 01       	movw	r30, r24
    2cda:	32 83       	std	Z+2, r19	; 0x02
    2cdc:	21 83       	std	Z+1, r18	; 0x01
    2cde:	89 81       	ldd	r24, Y+1	; 0x01
    2ce0:	9a 81       	ldd	r25, Y+2	; 0x02
    2ce2:	fc 01       	movw	r30, r24
    2ce4:	21 81       	ldd	r18, Z+1	; 0x01
    2ce6:	32 81       	ldd	r19, Z+2	; 0x02
    2ce8:	89 81       	ldd	r24, Y+1	; 0x01
    2cea:	9a 81       	ldd	r25, Y+2	; 0x02
    2cec:	03 96       	adiw	r24, 0x03	; 3
    2cee:	28 17       	cp	r18, r24
    2cf0:	39 07       	cpc	r19, r25
    2cf2:	69 f4       	brne	.+26     	; 0x2d0e <vCoRoutineSchedule+0xbc>
    2cf4:	89 81       	ldd	r24, Y+1	; 0x01
    2cf6:	9a 81       	ldd	r25, Y+2	; 0x02
    2cf8:	fc 01       	movw	r30, r24
    2cfa:	81 81       	ldd	r24, Z+1	; 0x01
    2cfc:	92 81       	ldd	r25, Z+2	; 0x02
    2cfe:	fc 01       	movw	r30, r24
    2d00:	22 81       	ldd	r18, Z+2	; 0x02
    2d02:	33 81       	ldd	r19, Z+3	; 0x03
    2d04:	89 81       	ldd	r24, Y+1	; 0x01
    2d06:	9a 81       	ldd	r25, Y+2	; 0x02
    2d08:	fc 01       	movw	r30, r24
    2d0a:	32 83       	std	Z+2, r19	; 0x02
    2d0c:	21 83       	std	Z+1, r18	; 0x01
    2d0e:	89 81       	ldd	r24, Y+1	; 0x01
    2d10:	9a 81       	ldd	r25, Y+2	; 0x02
    2d12:	fc 01       	movw	r30, r24
    2d14:	81 81       	ldd	r24, Z+1	; 0x01
    2d16:	92 81       	ldd	r25, Z+2	; 0x02
    2d18:	fc 01       	movw	r30, r24
    2d1a:	86 81       	ldd	r24, Z+6	; 0x06
    2d1c:	97 81       	ldd	r25, Z+7	; 0x07
    2d1e:	90 93 8a 02 	sts	0x028A, r25
    2d22:	80 93 89 02 	sts	0x0289, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2d26:	80 91 89 02 	lds	r24, 0x0289
    2d2a:	90 91 8a 02 	lds	r25, 0x028A
    2d2e:	fc 01       	movw	r30, r24
    2d30:	20 81       	ld	r18, Z
    2d32:	31 81       	ldd	r19, Z+1	; 0x01
    2d34:	80 91 89 02 	lds	r24, 0x0289
    2d38:	90 91 8a 02 	lds	r25, 0x028A
    2d3c:	fc 01       	movw	r30, r24
    2d3e:	47 89       	ldd	r20, Z+23	; 0x17
    2d40:	80 91 89 02 	lds	r24, 0x0289
    2d44:	90 91 8a 02 	lds	r25, 0x028A
    2d48:	64 2f       	mov	r22, r20
    2d4a:	f9 01       	movw	r30, r18
    2d4c:	19 95       	eicall

	return;
    2d4e:	00 00       	nop
}
    2d50:	0f 90       	pop	r0
    2d52:	0f 90       	pop	r0
    2d54:	df 91       	pop	r29
    2d56:	cf 91       	pop	r28
    2d58:	08 95       	ret

00002d5a <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    2d5a:	cf 93       	push	r28
    2d5c:	df 93       	push	r29
    2d5e:	1f 92       	push	r1
    2d60:	cd b7       	in	r28, 0x3d	; 61
    2d62:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2d64:	19 82       	std	Y+1, r1	; 0x01
    2d66:	13 c0       	rjmp	.+38     	; 0x2d8e <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    2d68:	89 81       	ldd	r24, Y+1	; 0x01
    2d6a:	28 2f       	mov	r18, r24
    2d6c:	30 e0       	ldi	r19, 0x00	; 0
    2d6e:	c9 01       	movw	r24, r18
    2d70:	88 0f       	add	r24, r24
    2d72:	99 1f       	adc	r25, r25
    2d74:	88 0f       	add	r24, r24
    2d76:	99 1f       	adc	r25, r25
    2d78:	88 0f       	add	r24, r24
    2d7a:	99 1f       	adc	r25, r25
    2d7c:	82 0f       	add	r24, r18
    2d7e:	93 1f       	adc	r25, r19
    2d80:	85 57       	subi	r24, 0x75	; 117
    2d82:	9d 4f       	sbci	r25, 0xFD	; 253
    2d84:	0e 94 b8 12 	call	0x2570	; 0x2570 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2d88:	89 81       	ldd	r24, Y+1	; 0x01
    2d8a:	8f 5f       	subi	r24, 0xFF	; 255
    2d8c:	89 83       	std	Y+1, r24	; 0x01
    2d8e:	89 81       	ldd	r24, Y+1	; 0x01
    2d90:	82 30       	cpi	r24, 0x02	; 2
    2d92:	50 f3       	brcs	.-44     	; 0x2d68 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    2d94:	8d e9       	ldi	r24, 0x9D	; 157
    2d96:	92 e0       	ldi	r25, 0x02	; 2
    2d98:	0e 94 b8 12 	call	0x2570	; 0x2570 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    2d9c:	86 ea       	ldi	r24, 0xA6	; 166
    2d9e:	92 e0       	ldi	r25, 0x02	; 2
    2da0:	0e 94 b8 12 	call	0x2570	; 0x2570 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    2da4:	83 eb       	ldi	r24, 0xB3	; 179
    2da6:	92 e0       	ldi	r25, 0x02	; 2
    2da8:	0e 94 b8 12 	call	0x2570	; 0x2570 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    2dac:	8d e9       	ldi	r24, 0x9D	; 157
    2dae:	92 e0       	ldi	r25, 0x02	; 2
    2db0:	90 93 b0 02 	sts	0x02B0, r25
    2db4:	80 93 af 02 	sts	0x02AF, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    2db8:	86 ea       	ldi	r24, 0xA6	; 166
    2dba:	92 e0       	ldi	r25, 0x02	; 2
    2dbc:	90 93 b2 02 	sts	0x02B2, r25
    2dc0:	80 93 b1 02 	sts	0x02B1, r24
}
    2dc4:	0f 90       	pop	r0
    2dc6:	df 91       	pop	r29
    2dc8:	cf 91       	pop	r28
    2dca:	08 95       	ret

00002dcc <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    2dcc:	cf 93       	push	r28
    2dce:	df 93       	push	r29
    2dd0:	00 d0       	rcall	.+0      	; 0x2dd2 <xCoRoutineRemoveFromEventList+0x6>
    2dd2:	1f 92       	push	r1
    2dd4:	1f 92       	push	r1
    2dd6:	cd b7       	in	r28, 0x3d	; 61
    2dd8:	de b7       	in	r29, 0x3e	; 62
    2dda:	9d 83       	std	Y+5, r25	; 0x05
    2ddc:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2dde:	8c 81       	ldd	r24, Y+4	; 0x04
    2de0:	9d 81       	ldd	r25, Y+5	; 0x05
    2de2:	fc 01       	movw	r30, r24
    2de4:	85 81       	ldd	r24, Z+5	; 0x05
    2de6:	96 81       	ldd	r25, Z+6	; 0x06
    2de8:	fc 01       	movw	r30, r24
    2dea:	86 81       	ldd	r24, Z+6	; 0x06
    2dec:	97 81       	ldd	r25, Z+7	; 0x07
    2dee:	9b 83       	std	Y+3, r25	; 0x03
    2df0:	8a 83       	std	Y+2, r24	; 0x02
	uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2df2:	8a 81       	ldd	r24, Y+2	; 0x02
    2df4:	9b 81       	ldd	r25, Y+3	; 0x03
    2df6:	0c 96       	adiw	r24, 0x0c	; 12
    2df8:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <uxListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    2dfc:	8a 81       	ldd	r24, Y+2	; 0x02
    2dfe:	9b 81       	ldd	r25, Y+3	; 0x03
    2e00:	0c 96       	adiw	r24, 0x0c	; 12
    2e02:	bc 01       	movw	r22, r24
    2e04:	83 eb       	ldi	r24, 0xB3	; 179
    2e06:	92 e0       	ldi	r25, 0x02	; 2
    2e08:	0e 94 00 13 	call	0x2600	; 0x2600 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    2e0c:	8a 81       	ldd	r24, Y+2	; 0x02
    2e0e:	9b 81       	ldd	r25, Y+3	; 0x03
    2e10:	fc 01       	movw	r30, r24
    2e12:	26 89       	ldd	r18, Z+22	; 0x16
    2e14:	80 91 89 02 	lds	r24, 0x0289
    2e18:	90 91 8a 02 	lds	r25, 0x028A
    2e1c:	fc 01       	movw	r30, r24
    2e1e:	86 89       	ldd	r24, Z+22	; 0x16
    2e20:	28 17       	cp	r18, r24
    2e22:	18 f0       	brcs	.+6      	; 0x2e2a <xCoRoutineRemoveFromEventList+0x5e>
	{
		xReturn = pdTRUE;
    2e24:	81 e0       	ldi	r24, 0x01	; 1
    2e26:	89 83       	std	Y+1, r24	; 0x01
    2e28:	01 c0       	rjmp	.+2      	; 0x2e2c <xCoRoutineRemoveFromEventList+0x60>
	}
	else
	{
		xReturn = pdFALSE;
    2e2a:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2e2c:	89 81       	ldd	r24, Y+1	; 0x01
}
    2e2e:	0f 90       	pop	r0
    2e30:	0f 90       	pop	r0
    2e32:	0f 90       	pop	r0
    2e34:	0f 90       	pop	r0
    2e36:	0f 90       	pop	r0
    2e38:	df 91       	pop	r29
    2e3a:	cf 91       	pop	r28
    2e3c:	08 95       	ret

00002e3e <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2e3e:	cf 93       	push	r28
    2e40:	df 93       	push	r29
    2e42:	00 d0       	rcall	.+0      	; 0x2e44 <pvPortMalloc+0x6>
    2e44:	1f 92       	push	r1
    2e46:	cd b7       	in	r28, 0x3d	; 61
    2e48:	de b7       	in	r29, 0x3e	; 62
    2e4a:	9c 83       	std	Y+4, r25	; 0x04
    2e4c:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    2e4e:	1a 82       	std	Y+2, r1	; 0x02
    2e50:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    2e52:	0e 94 f1 06 	call	0xde2	; 0xde2 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    2e56:	20 91 c3 1a 	lds	r18, 0x1AC3
    2e5a:	30 91 c4 1a 	lds	r19, 0x1AC4
    2e5e:	8b 81       	ldd	r24, Y+3	; 0x03
    2e60:	9c 81       	ldd	r25, Y+4	; 0x04
    2e62:	82 0f       	add	r24, r18
    2e64:	93 1f       	adc	r25, r19
    2e66:	81 15       	cp	r24, r1
    2e68:	28 e1       	ldi	r18, 0x18	; 24
    2e6a:	92 07       	cpc	r25, r18
    2e6c:	18 f5       	brcc	.+70     	; 0x2eb4 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
    2e6e:	20 91 c3 1a 	lds	r18, 0x1AC3
    2e72:	30 91 c4 1a 	lds	r19, 0x1AC4
    2e76:	8b 81       	ldd	r24, Y+3	; 0x03
    2e78:	9c 81       	ldd	r25, Y+4	; 0x04
    2e7a:	28 0f       	add	r18, r24
    2e7c:	39 1f       	adc	r19, r25
    2e7e:	80 91 c3 1a 	lds	r24, 0x1AC3
    2e82:	90 91 c4 1a 	lds	r25, 0x1AC4
	#endif

	vTaskSuspendAll();
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    2e86:	82 17       	cp	r24, r18
    2e88:	93 07       	cpc	r25, r19
    2e8a:	a0 f4       	brcc	.+40     	; 0x2eb4 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    2e8c:	80 91 c3 1a 	lds	r24, 0x1AC3
    2e90:	90 91 c4 1a 	lds	r25, 0x1AC4
    2e94:	8d 53       	subi	r24, 0x3D	; 61
    2e96:	9d 4f       	sbci	r25, 0xFD	; 253
    2e98:	9a 83       	std	Y+2, r25	; 0x02
    2e9a:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    2e9c:	20 91 c3 1a 	lds	r18, 0x1AC3
    2ea0:	30 91 c4 1a 	lds	r19, 0x1AC4
    2ea4:	8b 81       	ldd	r24, Y+3	; 0x03
    2ea6:	9c 81       	ldd	r25, Y+4	; 0x04
    2ea8:	82 0f       	add	r24, r18
    2eaa:	93 1f       	adc	r25, r19
    2eac:	90 93 c4 1a 	sts	0x1AC4, r25
    2eb0:	80 93 c3 1a 	sts	0x1AC3, r24
		}
	}
	xTaskResumeAll();
    2eb4:	0e 94 fd 06 	call	0xdfa	; 0xdfa <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    2eb8:	89 81       	ldd	r24, Y+1	; 0x01
    2eba:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2ebc:	0f 90       	pop	r0
    2ebe:	0f 90       	pop	r0
    2ec0:	0f 90       	pop	r0
    2ec2:	0f 90       	pop	r0
    2ec4:	df 91       	pop	r29
    2ec6:	cf 91       	pop	r28
    2ec8:	08 95       	ret

00002eca <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2eca:	cf 93       	push	r28
    2ecc:	df 93       	push	r29
    2ece:	1f 92       	push	r1
    2ed0:	1f 92       	push	r1
    2ed2:	cd b7       	in	r28, 0x3d	; 61
    2ed4:	de b7       	in	r29, 0x3e	; 62
    2ed6:	9a 83       	std	Y+2, r25	; 0x02
    2ed8:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    2eda:	0f 90       	pop	r0
    2edc:	0f 90       	pop	r0
    2ede:	df 91       	pop	r29
    2ee0:	cf 91       	pop	r28
    2ee2:	08 95       	ret

00002ee4 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    2ee4:	cf 93       	push	r28
    2ee6:	df 93       	push	r29
    2ee8:	cd b7       	in	r28, 0x3d	; 61
    2eea:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    2eec:	10 92 c4 1a 	sts	0x1AC4, r1
    2ef0:	10 92 c3 1a 	sts	0x1AC3, r1
}
    2ef4:	df 91       	pop	r29
    2ef6:	cf 91       	pop	r28
    2ef8:	08 95       	ret

00002efa <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    2efa:	cf 93       	push	r28
    2efc:	df 93       	push	r29
    2efe:	cd b7       	in	r28, 0x3d	; 61
    2f00:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    2f02:	80 91 c3 1a 	lds	r24, 0x1AC3
    2f06:	90 91 c4 1a 	lds	r25, 0x1AC4
    2f0a:	20 e0       	ldi	r18, 0x00	; 0
    2f0c:	38 e1       	ldi	r19, 0x18	; 24
    2f0e:	a9 01       	movw	r20, r18
    2f10:	48 1b       	sub	r20, r24
    2f12:	59 0b       	sbc	r21, r25
    2f14:	ca 01       	movw	r24, r20
}
    2f16:	df 91       	pop	r29
    2f18:	cf 91       	pop	r28
    2f1a:	08 95       	ret

00002f1c <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    2f1c:	cf 93       	push	r28
    2f1e:	df 93       	push	r29
    2f20:	cd b7       	in	r28, 0x3d	; 61
    2f22:	de b7       	in	r29, 0x3e	; 62
    2f24:	28 97       	sbiw	r28, 0x08	; 8
    2f26:	0f b6       	in	r0, 0x3f	; 63
    2f28:	f8 94       	cli
    2f2a:	de bf       	out	0x3e, r29	; 62
    2f2c:	0f be       	out	0x3f, r0	; 63
    2f2e:	cd bf       	out	0x3d, r28	; 61
    2f30:	9c 83       	std	Y+4, r25	; 0x04
    2f32:	8b 83       	std	Y+3, r24	; 0x03
    2f34:	7e 83       	std	Y+6, r23	; 0x06
    2f36:	6d 83       	std	Y+5, r22	; 0x05
    2f38:	58 87       	std	Y+8, r21	; 0x08
    2f3a:	4f 83       	std	Y+7, r20	; 0x07
#endif

	/* Place a few bytes of known values on the bottom of the stack.
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2f3c:	8b 81       	ldd	r24, Y+3	; 0x03
    2f3e:	9c 81       	ldd	r25, Y+4	; 0x04
    2f40:	21 e1       	ldi	r18, 0x11	; 17
    2f42:	fc 01       	movw	r30, r24
    2f44:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f46:	8b 81       	ldd	r24, Y+3	; 0x03
    2f48:	9c 81       	ldd	r25, Y+4	; 0x04
    2f4a:	01 97       	sbiw	r24, 0x01	; 1
    2f4c:	9c 83       	std	Y+4, r25	; 0x04
    2f4e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    2f50:	8b 81       	ldd	r24, Y+3	; 0x03
    2f52:	9c 81       	ldd	r25, Y+4	; 0x04
    2f54:	22 e2       	ldi	r18, 0x22	; 34
    2f56:	fc 01       	movw	r30, r24
    2f58:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f5a:	8b 81       	ldd	r24, Y+3	; 0x03
    2f5c:	9c 81       	ldd	r25, Y+4	; 0x04
    2f5e:	01 97       	sbiw	r24, 0x01	; 1
    2f60:	9c 83       	std	Y+4, r25	; 0x04
    2f62:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    2f64:	8b 81       	ldd	r24, Y+3	; 0x03
    2f66:	9c 81       	ldd	r25, Y+4	; 0x04
    2f68:	23 e3       	ldi	r18, 0x33	; 51
    2f6a:	fc 01       	movw	r30, r24
    2f6c:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f6e:	8b 81       	ldd	r24, Y+3	; 0x03
    2f70:	9c 81       	ldd	r25, Y+4	; 0x04
    2f72:	01 97       	sbiw	r24, 0x01	; 1
    2f74:	9c 83       	std	Y+4, r25	; 0x04
    2f76:	8b 83       	std	Y+3, r24	; 0x03
	 * of flash. We do this by adding the .task label in the linker script.
	 *
	 * In order to do this properly, we would need to get a full 3-byte pointer to
	 * pxCode.  That requires a change to GCC.  Not likely to happen any time soon.
	 */
	usAddress = ( unsigned portSHORT ) pxCode;
    2f78:	8d 81       	ldd	r24, Y+5	; 0x05
    2f7a:	9e 81       	ldd	r25, Y+6	; 0x06
    2f7c:	9a 83       	std	Y+2, r25	; 0x02
    2f7e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    2f80:	29 81       	ldd	r18, Y+1	; 0x01
    2f82:	8b 81       	ldd	r24, Y+3	; 0x03
    2f84:	9c 81       	ldd	r25, Y+4	; 0x04
    2f86:	fc 01       	movw	r30, r24
    2f88:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f8a:	8b 81       	ldd	r24, Y+3	; 0x03
    2f8c:	9c 81       	ldd	r25, Y+4	; 0x04
    2f8e:	01 97       	sbiw	r24, 0x01	; 1
    2f90:	9c 83       	std	Y+4, r25	; 0x04
    2f92:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2f94:	89 81       	ldd	r24, Y+1	; 0x01
    2f96:	9a 81       	ldd	r25, Y+2	; 0x02
    2f98:	89 2f       	mov	r24, r25
    2f9a:	99 27       	eor	r25, r25
    2f9c:	9a 83       	std	Y+2, r25	; 0x02
    2f9e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    2fa0:	29 81       	ldd	r18, Y+1	; 0x01
    2fa2:	8b 81       	ldd	r24, Y+3	; 0x03
    2fa4:	9c 81       	ldd	r25, Y+4	; 0x04
    2fa6:	fc 01       	movw	r30, r24
    2fa8:	20 83       	st	Z, r18
	pxTopOfStack--;
    2faa:	8b 81       	ldd	r24, Y+3	; 0x03
    2fac:	9c 81       	ldd	r25, Y+4	; 0x04
    2fae:	01 97       	sbiw	r24, 0x01	; 1
    2fb0:	9c 83       	std	Y+4, r25	; 0x04
    2fb2:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = 0;
    2fb4:	8b 81       	ldd	r24, Y+3	; 0x03
    2fb6:	9c 81       	ldd	r25, Y+4	; 0x04
    2fb8:	fc 01       	movw	r30, r24
    2fba:	10 82       	st	Z, r1
	pxTopOfStack--;
    2fbc:	8b 81       	ldd	r24, Y+3	; 0x03
    2fbe:	9c 81       	ldd	r25, Y+4	; 0x04
    2fc0:	01 97       	sbiw	r24, 0x01	; 1
    2fc2:	9c 83       	std	Y+4, r25	; 0x04
    2fc4:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    2fc6:	8b 81       	ldd	r24, Y+3	; 0x03
    2fc8:	9c 81       	ldd	r25, Y+4	; 0x04
    2fca:	fc 01       	movw	r30, r24
    2fcc:	10 82       	st	Z, r1
	pxTopOfStack--;
    2fce:	8b 81       	ldd	r24, Y+3	; 0x03
    2fd0:	9c 81       	ldd	r25, Y+4	; 0x04
    2fd2:	01 97       	sbiw	r24, 0x01	; 1
    2fd4:	9c 83       	std	Y+4, r25	; 0x04
    2fd6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2fd8:	8b 81       	ldd	r24, Y+3	; 0x03
    2fda:	9c 81       	ldd	r25, Y+4	; 0x04
    2fdc:	20 e8       	ldi	r18, 0x80	; 128
    2fde:	fc 01       	movw	r30, r24
    2fe0:	20 83       	st	Z, r18
	pxTopOfStack--;
    2fe2:	8b 81       	ldd	r24, Y+3	; 0x03
    2fe4:	9c 81       	ldd	r25, Y+4	; 0x04
    2fe6:	01 97       	sbiw	r24, 0x01	; 1
    2fe8:	9c 83       	std	Y+4, r25	; 0x04
    2fea:	8b 83       	std	Y+3, r24	; 0x03
#if defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

	/* If we have an ATmega256x, we are also saving the RAMPZ and EIND registers.
	 * We should default those to 0.
	 */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* EIND */
    2fec:	8b 81       	ldd	r24, Y+3	; 0x03
    2fee:	9c 81       	ldd	r25, Y+4	; 0x04
    2ff0:	fc 01       	movw	r30, r24
    2ff2:	10 82       	st	Z, r1
	pxTopOfStack--;
    2ff4:	8b 81       	ldd	r24, Y+3	; 0x03
    2ff6:	9c 81       	ldd	r25, Y+4	; 0x04
    2ff8:	01 97       	sbiw	r24, 0x01	; 1
    2ffa:	9c 83       	std	Y+4, r25	; 0x04
    2ffc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* RAMPZ */
    2ffe:	8b 81       	ldd	r24, Y+3	; 0x03
    3000:	9c 81       	ldd	r25, Y+4	; 0x04
    3002:	fc 01       	movw	r30, r24
    3004:	10 82       	st	Z, r1
	pxTopOfStack--;
    3006:	8b 81       	ldd	r24, Y+3	; 0x03
    3008:	9c 81       	ldd	r25, Y+4	; 0x04
    300a:	01 97       	sbiw	r24, 0x01	; 1
    300c:	9c 83       	std	Y+4, r25	; 0x04
    300e:	8b 83       	std	Y+3, r24	; 0x03

#endif

	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    3010:	8b 81       	ldd	r24, Y+3	; 0x03
    3012:	9c 81       	ldd	r25, Y+4	; 0x04
    3014:	fc 01       	movw	r30, r24
    3016:	10 82       	st	Z, r1
	pxTopOfStack--;
    3018:	8b 81       	ldd	r24, Y+3	; 0x03
    301a:	9c 81       	ldd	r25, Y+4	; 0x04
    301c:	01 97       	sbiw	r24, 0x01	; 1
    301e:	9c 83       	std	Y+4, r25	; 0x04
    3020:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    3022:	8b 81       	ldd	r24, Y+3	; 0x03
    3024:	9c 81       	ldd	r25, Y+4	; 0x04
    3026:	22 e0       	ldi	r18, 0x02	; 2
    3028:	fc 01       	movw	r30, r24
    302a:	20 83       	st	Z, r18
	pxTopOfStack--;
    302c:	8b 81       	ldd	r24, Y+3	; 0x03
    302e:	9c 81       	ldd	r25, Y+4	; 0x04
    3030:	01 97       	sbiw	r24, 0x01	; 1
    3032:	9c 83       	std	Y+4, r25	; 0x04
    3034:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    3036:	8b 81       	ldd	r24, Y+3	; 0x03
    3038:	9c 81       	ldd	r25, Y+4	; 0x04
    303a:	23 e0       	ldi	r18, 0x03	; 3
    303c:	fc 01       	movw	r30, r24
    303e:	20 83       	st	Z, r18
	pxTopOfStack--;
    3040:	8b 81       	ldd	r24, Y+3	; 0x03
    3042:	9c 81       	ldd	r25, Y+4	; 0x04
    3044:	01 97       	sbiw	r24, 0x01	; 1
    3046:	9c 83       	std	Y+4, r25	; 0x04
    3048:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    304a:	8b 81       	ldd	r24, Y+3	; 0x03
    304c:	9c 81       	ldd	r25, Y+4	; 0x04
    304e:	24 e0       	ldi	r18, 0x04	; 4
    3050:	fc 01       	movw	r30, r24
    3052:	20 83       	st	Z, r18
	pxTopOfStack--;
    3054:	8b 81       	ldd	r24, Y+3	; 0x03
    3056:	9c 81       	ldd	r25, Y+4	; 0x04
    3058:	01 97       	sbiw	r24, 0x01	; 1
    305a:	9c 83       	std	Y+4, r25	; 0x04
    305c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    305e:	8b 81       	ldd	r24, Y+3	; 0x03
    3060:	9c 81       	ldd	r25, Y+4	; 0x04
    3062:	25 e0       	ldi	r18, 0x05	; 5
    3064:	fc 01       	movw	r30, r24
    3066:	20 83       	st	Z, r18
	pxTopOfStack--;
    3068:	8b 81       	ldd	r24, Y+3	; 0x03
    306a:	9c 81       	ldd	r25, Y+4	; 0x04
    306c:	01 97       	sbiw	r24, 0x01	; 1
    306e:	9c 83       	std	Y+4, r25	; 0x04
    3070:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    3072:	8b 81       	ldd	r24, Y+3	; 0x03
    3074:	9c 81       	ldd	r25, Y+4	; 0x04
    3076:	26 e0       	ldi	r18, 0x06	; 6
    3078:	fc 01       	movw	r30, r24
    307a:	20 83       	st	Z, r18
	pxTopOfStack--;
    307c:	8b 81       	ldd	r24, Y+3	; 0x03
    307e:	9c 81       	ldd	r25, Y+4	; 0x04
    3080:	01 97       	sbiw	r24, 0x01	; 1
    3082:	9c 83       	std	Y+4, r25	; 0x04
    3084:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    3086:	8b 81       	ldd	r24, Y+3	; 0x03
    3088:	9c 81       	ldd	r25, Y+4	; 0x04
    308a:	27 e0       	ldi	r18, 0x07	; 7
    308c:	fc 01       	movw	r30, r24
    308e:	20 83       	st	Z, r18
	pxTopOfStack--;
    3090:	8b 81       	ldd	r24, Y+3	; 0x03
    3092:	9c 81       	ldd	r25, Y+4	; 0x04
    3094:	01 97       	sbiw	r24, 0x01	; 1
    3096:	9c 83       	std	Y+4, r25	; 0x04
    3098:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    309a:	8b 81       	ldd	r24, Y+3	; 0x03
    309c:	9c 81       	ldd	r25, Y+4	; 0x04
    309e:	28 e0       	ldi	r18, 0x08	; 8
    30a0:	fc 01       	movw	r30, r24
    30a2:	20 83       	st	Z, r18
	pxTopOfStack--;
    30a4:	8b 81       	ldd	r24, Y+3	; 0x03
    30a6:	9c 81       	ldd	r25, Y+4	; 0x04
    30a8:	01 97       	sbiw	r24, 0x01	; 1
    30aa:	9c 83       	std	Y+4, r25	; 0x04
    30ac:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    30ae:	8b 81       	ldd	r24, Y+3	; 0x03
    30b0:	9c 81       	ldd	r25, Y+4	; 0x04
    30b2:	29 e0       	ldi	r18, 0x09	; 9
    30b4:	fc 01       	movw	r30, r24
    30b6:	20 83       	st	Z, r18
	pxTopOfStack--;
    30b8:	8b 81       	ldd	r24, Y+3	; 0x03
    30ba:	9c 81       	ldd	r25, Y+4	; 0x04
    30bc:	01 97       	sbiw	r24, 0x01	; 1
    30be:	9c 83       	std	Y+4, r25	; 0x04
    30c0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    30c2:	8b 81       	ldd	r24, Y+3	; 0x03
    30c4:	9c 81       	ldd	r25, Y+4	; 0x04
    30c6:	20 e1       	ldi	r18, 0x10	; 16
    30c8:	fc 01       	movw	r30, r24
    30ca:	20 83       	st	Z, r18
	pxTopOfStack--;
    30cc:	8b 81       	ldd	r24, Y+3	; 0x03
    30ce:	9c 81       	ldd	r25, Y+4	; 0x04
    30d0:	01 97       	sbiw	r24, 0x01	; 1
    30d2:	9c 83       	std	Y+4, r25	; 0x04
    30d4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    30d6:	8b 81       	ldd	r24, Y+3	; 0x03
    30d8:	9c 81       	ldd	r25, Y+4	; 0x04
    30da:	21 e1       	ldi	r18, 0x11	; 17
    30dc:	fc 01       	movw	r30, r24
    30de:	20 83       	st	Z, r18
	pxTopOfStack--;
    30e0:	8b 81       	ldd	r24, Y+3	; 0x03
    30e2:	9c 81       	ldd	r25, Y+4	; 0x04
    30e4:	01 97       	sbiw	r24, 0x01	; 1
    30e6:	9c 83       	std	Y+4, r25	; 0x04
    30e8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    30ea:	8b 81       	ldd	r24, Y+3	; 0x03
    30ec:	9c 81       	ldd	r25, Y+4	; 0x04
    30ee:	22 e1       	ldi	r18, 0x12	; 18
    30f0:	fc 01       	movw	r30, r24
    30f2:	20 83       	st	Z, r18
	pxTopOfStack--;
    30f4:	8b 81       	ldd	r24, Y+3	; 0x03
    30f6:	9c 81       	ldd	r25, Y+4	; 0x04
    30f8:	01 97       	sbiw	r24, 0x01	; 1
    30fa:	9c 83       	std	Y+4, r25	; 0x04
    30fc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    30fe:	8b 81       	ldd	r24, Y+3	; 0x03
    3100:	9c 81       	ldd	r25, Y+4	; 0x04
    3102:	23 e1       	ldi	r18, 0x13	; 19
    3104:	fc 01       	movw	r30, r24
    3106:	20 83       	st	Z, r18
	pxTopOfStack--;
    3108:	8b 81       	ldd	r24, Y+3	; 0x03
    310a:	9c 81       	ldd	r25, Y+4	; 0x04
    310c:	01 97       	sbiw	r24, 0x01	; 1
    310e:	9c 83       	std	Y+4, r25	; 0x04
    3110:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    3112:	8b 81       	ldd	r24, Y+3	; 0x03
    3114:	9c 81       	ldd	r25, Y+4	; 0x04
    3116:	24 e1       	ldi	r18, 0x14	; 20
    3118:	fc 01       	movw	r30, r24
    311a:	20 83       	st	Z, r18
	pxTopOfStack--;
    311c:	8b 81       	ldd	r24, Y+3	; 0x03
    311e:	9c 81       	ldd	r25, Y+4	; 0x04
    3120:	01 97       	sbiw	r24, 0x01	; 1
    3122:	9c 83       	std	Y+4, r25	; 0x04
    3124:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    3126:	8b 81       	ldd	r24, Y+3	; 0x03
    3128:	9c 81       	ldd	r25, Y+4	; 0x04
    312a:	25 e1       	ldi	r18, 0x15	; 21
    312c:	fc 01       	movw	r30, r24
    312e:	20 83       	st	Z, r18
	pxTopOfStack--;
    3130:	8b 81       	ldd	r24, Y+3	; 0x03
    3132:	9c 81       	ldd	r25, Y+4	; 0x04
    3134:	01 97       	sbiw	r24, 0x01	; 1
    3136:	9c 83       	std	Y+4, r25	; 0x04
    3138:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    313a:	8b 81       	ldd	r24, Y+3	; 0x03
    313c:	9c 81       	ldd	r25, Y+4	; 0x04
    313e:	26 e1       	ldi	r18, 0x16	; 22
    3140:	fc 01       	movw	r30, r24
    3142:	20 83       	st	Z, r18
	pxTopOfStack--;
    3144:	8b 81       	ldd	r24, Y+3	; 0x03
    3146:	9c 81       	ldd	r25, Y+4	; 0x04
    3148:	01 97       	sbiw	r24, 0x01	; 1
    314a:	9c 83       	std	Y+4, r25	; 0x04
    314c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    314e:	8b 81       	ldd	r24, Y+3	; 0x03
    3150:	9c 81       	ldd	r25, Y+4	; 0x04
    3152:	27 e1       	ldi	r18, 0x17	; 23
    3154:	fc 01       	movw	r30, r24
    3156:	20 83       	st	Z, r18
	pxTopOfStack--;
    3158:	8b 81       	ldd	r24, Y+3	; 0x03
    315a:	9c 81       	ldd	r25, Y+4	; 0x04
    315c:	01 97       	sbiw	r24, 0x01	; 1
    315e:	9c 83       	std	Y+4, r25	; 0x04
    3160:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    3162:	8b 81       	ldd	r24, Y+3	; 0x03
    3164:	9c 81       	ldd	r25, Y+4	; 0x04
    3166:	28 e1       	ldi	r18, 0x18	; 24
    3168:	fc 01       	movw	r30, r24
    316a:	20 83       	st	Z, r18
	pxTopOfStack--;
    316c:	8b 81       	ldd	r24, Y+3	; 0x03
    316e:	9c 81       	ldd	r25, Y+4	; 0x04
    3170:	01 97       	sbiw	r24, 0x01	; 1
    3172:	9c 83       	std	Y+4, r25	; 0x04
    3174:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    3176:	8b 81       	ldd	r24, Y+3	; 0x03
    3178:	9c 81       	ldd	r25, Y+4	; 0x04
    317a:	29 e1       	ldi	r18, 0x19	; 25
    317c:	fc 01       	movw	r30, r24
    317e:	20 83       	st	Z, r18
	pxTopOfStack--;
    3180:	8b 81       	ldd	r24, Y+3	; 0x03
    3182:	9c 81       	ldd	r25, Y+4	; 0x04
    3184:	01 97       	sbiw	r24, 0x01	; 1
    3186:	9c 83       	std	Y+4, r25	; 0x04
    3188:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    318a:	8b 81       	ldd	r24, Y+3	; 0x03
    318c:	9c 81       	ldd	r25, Y+4	; 0x04
    318e:	20 e2       	ldi	r18, 0x20	; 32
    3190:	fc 01       	movw	r30, r24
    3192:	20 83       	st	Z, r18
	pxTopOfStack--;
    3194:	8b 81       	ldd	r24, Y+3	; 0x03
    3196:	9c 81       	ldd	r25, Y+4	; 0x04
    3198:	01 97       	sbiw	r24, 0x01	; 1
    319a:	9c 83       	std	Y+4, r25	; 0x04
    319c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    319e:	8b 81       	ldd	r24, Y+3	; 0x03
    31a0:	9c 81       	ldd	r25, Y+4	; 0x04
    31a2:	21 e2       	ldi	r18, 0x21	; 33
    31a4:	fc 01       	movw	r30, r24
    31a6:	20 83       	st	Z, r18
	pxTopOfStack--;
    31a8:	8b 81       	ldd	r24, Y+3	; 0x03
    31aa:	9c 81       	ldd	r25, Y+4	; 0x04
    31ac:	01 97       	sbiw	r24, 0x01	; 1
    31ae:	9c 83       	std	Y+4, r25	; 0x04
    31b0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    31b2:	8b 81       	ldd	r24, Y+3	; 0x03
    31b4:	9c 81       	ldd	r25, Y+4	; 0x04
    31b6:	22 e2       	ldi	r18, 0x22	; 34
    31b8:	fc 01       	movw	r30, r24
    31ba:	20 83       	st	Z, r18
	pxTopOfStack--;
    31bc:	8b 81       	ldd	r24, Y+3	; 0x03
    31be:	9c 81       	ldd	r25, Y+4	; 0x04
    31c0:	01 97       	sbiw	r24, 0x01	; 1
    31c2:	9c 83       	std	Y+4, r25	; 0x04
    31c4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    31c6:	8b 81       	ldd	r24, Y+3	; 0x03
    31c8:	9c 81       	ldd	r25, Y+4	; 0x04
    31ca:	23 e2       	ldi	r18, 0x23	; 35
    31cc:	fc 01       	movw	r30, r24
    31ce:	20 83       	st	Z, r18
	pxTopOfStack--;
    31d0:	8b 81       	ldd	r24, Y+3	; 0x03
    31d2:	9c 81       	ldd	r25, Y+4	; 0x04
    31d4:	01 97       	sbiw	r24, 0x01	; 1
    31d6:	9c 83       	std	Y+4, r25	; 0x04
    31d8:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    31da:	8f 81       	ldd	r24, Y+7	; 0x07
    31dc:	98 85       	ldd	r25, Y+8	; 0x08
    31de:	9a 83       	std	Y+2, r25	; 0x02
    31e0:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    31e2:	29 81       	ldd	r18, Y+1	; 0x01
    31e4:	8b 81       	ldd	r24, Y+3	; 0x03
    31e6:	9c 81       	ldd	r25, Y+4	; 0x04
    31e8:	fc 01       	movw	r30, r24
    31ea:	20 83       	st	Z, r18
	pxTopOfStack--;
    31ec:	8b 81       	ldd	r24, Y+3	; 0x03
    31ee:	9c 81       	ldd	r25, Y+4	; 0x04
    31f0:	01 97       	sbiw	r24, 0x01	; 1
    31f2:	9c 83       	std	Y+4, r25	; 0x04
    31f4:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    31f6:	89 81       	ldd	r24, Y+1	; 0x01
    31f8:	9a 81       	ldd	r25, Y+2	; 0x02
    31fa:	89 2f       	mov	r24, r25
    31fc:	99 27       	eor	r25, r25
    31fe:	9a 83       	std	Y+2, r25	; 0x02
    3200:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    3202:	29 81       	ldd	r18, Y+1	; 0x01
    3204:	8b 81       	ldd	r24, Y+3	; 0x03
    3206:	9c 81       	ldd	r25, Y+4	; 0x04
    3208:	fc 01       	movw	r30, r24
    320a:	20 83       	st	Z, r18
	pxTopOfStack--;
    320c:	8b 81       	ldd	r24, Y+3	; 0x03
    320e:	9c 81       	ldd	r25, Y+4	; 0x04
    3210:	01 97       	sbiw	r24, 0x01	; 1
    3212:	9c 83       	std	Y+4, r25	; 0x04
    3214:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    3216:	8b 81       	ldd	r24, Y+3	; 0x03
    3218:	9c 81       	ldd	r25, Y+4	; 0x04
    321a:	26 e2       	ldi	r18, 0x26	; 38
    321c:	fc 01       	movw	r30, r24
    321e:	20 83       	st	Z, r18
	pxTopOfStack--;
    3220:	8b 81       	ldd	r24, Y+3	; 0x03
    3222:	9c 81       	ldd	r25, Y+4	; 0x04
    3224:	01 97       	sbiw	r24, 0x01	; 1
    3226:	9c 83       	std	Y+4, r25	; 0x04
    3228:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    322a:	8b 81       	ldd	r24, Y+3	; 0x03
    322c:	9c 81       	ldd	r25, Y+4	; 0x04
    322e:	27 e2       	ldi	r18, 0x27	; 39
    3230:	fc 01       	movw	r30, r24
    3232:	20 83       	st	Z, r18
	pxTopOfStack--;
    3234:	8b 81       	ldd	r24, Y+3	; 0x03
    3236:	9c 81       	ldd	r25, Y+4	; 0x04
    3238:	01 97       	sbiw	r24, 0x01	; 1
    323a:	9c 83       	std	Y+4, r25	; 0x04
    323c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    323e:	8b 81       	ldd	r24, Y+3	; 0x03
    3240:	9c 81       	ldd	r25, Y+4	; 0x04
    3242:	28 e2       	ldi	r18, 0x28	; 40
    3244:	fc 01       	movw	r30, r24
    3246:	20 83       	st	Z, r18
	pxTopOfStack--;
    3248:	8b 81       	ldd	r24, Y+3	; 0x03
    324a:	9c 81       	ldd	r25, Y+4	; 0x04
    324c:	01 97       	sbiw	r24, 0x01	; 1
    324e:	9c 83       	std	Y+4, r25	; 0x04
    3250:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    3252:	8b 81       	ldd	r24, Y+3	; 0x03
    3254:	9c 81       	ldd	r25, Y+4	; 0x04
    3256:	29 e2       	ldi	r18, 0x29	; 41
    3258:	fc 01       	movw	r30, r24
    325a:	20 83       	st	Z, r18
	pxTopOfStack--;
    325c:	8b 81       	ldd	r24, Y+3	; 0x03
    325e:	9c 81       	ldd	r25, Y+4	; 0x04
    3260:	01 97       	sbiw	r24, 0x01	; 1
    3262:	9c 83       	std	Y+4, r25	; 0x04
    3264:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    3266:	8b 81       	ldd	r24, Y+3	; 0x03
    3268:	9c 81       	ldd	r25, Y+4	; 0x04
    326a:	20 e3       	ldi	r18, 0x30	; 48
    326c:	fc 01       	movw	r30, r24
    326e:	20 83       	st	Z, r18
	pxTopOfStack--;
    3270:	8b 81       	ldd	r24, Y+3	; 0x03
    3272:	9c 81       	ldd	r25, Y+4	; 0x04
    3274:	01 97       	sbiw	r24, 0x01	; 1
    3276:	9c 83       	std	Y+4, r25	; 0x04
    3278:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    327a:	8b 81       	ldd	r24, Y+3	; 0x03
    327c:	9c 81       	ldd	r25, Y+4	; 0x04
    327e:	21 e3       	ldi	r18, 0x31	; 49
    3280:	fc 01       	movw	r30, r24
    3282:	20 83       	st	Z, r18
	pxTopOfStack--;
    3284:	8b 81       	ldd	r24, Y+3	; 0x03
    3286:	9c 81       	ldd	r25, Y+4	; 0x04
    3288:	01 97       	sbiw	r24, 0x01	; 1
    328a:	9c 83       	std	Y+4, r25	; 0x04
    328c:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    328e:	8b 81       	ldd	r24, Y+3	; 0x03
    3290:	9c 81       	ldd	r25, Y+4	; 0x04
}
    3292:	28 96       	adiw	r28, 0x08	; 8
    3294:	0f b6       	in	r0, 0x3f	; 63
    3296:	f8 94       	cli
    3298:	de bf       	out	0x3e, r29	; 62
    329a:	0f be       	out	0x3f, r0	; 63
    329c:	cd bf       	out	0x3d, r28	; 61
    329e:	df 91       	pop	r29
    32a0:	cf 91       	pop	r28
    32a2:	08 95       	ret

000032a4 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    32a4:	cf 93       	push	r28
    32a6:	df 93       	push	r29
    32a8:	cd b7       	in	r28, 0x3d	; 61
    32aa:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    32ac:	0e 94 56 1a 	call	0x34ac	; 0x34ac <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    32b0:	a0 91 30 02 	lds	r26, 0x0230
    32b4:	b0 91 31 02 	lds	r27, 0x0231
    32b8:	cd 91       	ld	r28, X+
    32ba:	cd bf       	out	0x3d, r28	; 61
    32bc:	dd 91       	ld	r29, X+
    32be:	de bf       	out	0x3e, r29	; 62
    32c0:	ff 91       	pop	r31
    32c2:	ef 91       	pop	r30
    32c4:	df 91       	pop	r29
    32c6:	cf 91       	pop	r28
    32c8:	bf 91       	pop	r27
    32ca:	af 91       	pop	r26
    32cc:	9f 91       	pop	r25
    32ce:	8f 91       	pop	r24
    32d0:	7f 91       	pop	r23
    32d2:	6f 91       	pop	r22
    32d4:	5f 91       	pop	r21
    32d6:	4f 91       	pop	r20
    32d8:	3f 91       	pop	r19
    32da:	2f 91       	pop	r18
    32dc:	1f 91       	pop	r17
    32de:	0f 91       	pop	r16
    32e0:	ff 90       	pop	r15
    32e2:	ef 90       	pop	r14
    32e4:	df 90       	pop	r13
    32e6:	cf 90       	pop	r12
    32e8:	bf 90       	pop	r11
    32ea:	af 90       	pop	r10
    32ec:	9f 90       	pop	r9
    32ee:	8f 90       	pop	r8
    32f0:	7f 90       	pop	r7
    32f2:	6f 90       	pop	r6
    32f4:	5f 90       	pop	r5
    32f6:	4f 90       	pop	r4
    32f8:	3f 90       	pop	r3
    32fa:	2f 90       	pop	r2
    32fc:	1f 90       	pop	r1
    32fe:	0f 90       	pop	r0
    3300:	0c be       	out	0x3c, r0	; 60
    3302:	0f 90       	pop	r0
    3304:	0b be       	out	0x3b, r0	; 59
    3306:	0f 90       	pop	r0
    3308:	0f be       	out	0x3f, r0	; 63
    330a:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    330c:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    330e:	81 e0       	ldi	r24, 0x01	; 1
}
    3310:	df 91       	pop	r29
    3312:	cf 91       	pop	r28
    3314:	08 95       	ret

00003316 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    3316:	cf 93       	push	r28
    3318:	df 93       	push	r29
    331a:	cd b7       	in	r28, 0x3d	; 61
    331c:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    331e:	df 91       	pop	r29
    3320:	cf 91       	pop	r28
    3322:	08 95       	ret

00003324 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    3324:	0f 92       	push	r0
    3326:	0f b6       	in	r0, 0x3f	; 63
    3328:	f8 94       	cli
    332a:	0f 92       	push	r0
    332c:	0b b6       	in	r0, 0x3b	; 59
    332e:	0f 92       	push	r0
    3330:	0c b6       	in	r0, 0x3c	; 60
    3332:	0f 92       	push	r0
    3334:	1f 92       	push	r1
    3336:	11 24       	eor	r1, r1
    3338:	2f 92       	push	r2
    333a:	3f 92       	push	r3
    333c:	4f 92       	push	r4
    333e:	5f 92       	push	r5
    3340:	6f 92       	push	r6
    3342:	7f 92       	push	r7
    3344:	8f 92       	push	r8
    3346:	9f 92       	push	r9
    3348:	af 92       	push	r10
    334a:	bf 92       	push	r11
    334c:	cf 92       	push	r12
    334e:	df 92       	push	r13
    3350:	ef 92       	push	r14
    3352:	ff 92       	push	r15
    3354:	0f 93       	push	r16
    3356:	1f 93       	push	r17
    3358:	2f 93       	push	r18
    335a:	3f 93       	push	r19
    335c:	4f 93       	push	r20
    335e:	5f 93       	push	r21
    3360:	6f 93       	push	r22
    3362:	7f 93       	push	r23
    3364:	8f 93       	push	r24
    3366:	9f 93       	push	r25
    3368:	af 93       	push	r26
    336a:	bf 93       	push	r27
    336c:	cf 93       	push	r28
    336e:	df 93       	push	r29
    3370:	ef 93       	push	r30
    3372:	ff 93       	push	r31
    3374:	a0 91 30 02 	lds	r26, 0x0230
    3378:	b0 91 31 02 	lds	r27, 0x0231
    337c:	0d b6       	in	r0, 0x3d	; 61
    337e:	0d 92       	st	X+, r0
    3380:	0e b6       	in	r0, 0x3e	; 62
    3382:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    3384:	0e 94 93 08 	call	0x1126	; 0x1126 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3388:	a0 91 30 02 	lds	r26, 0x0230
    338c:	b0 91 31 02 	lds	r27, 0x0231
    3390:	cd 91       	ld	r28, X+
    3392:	cd bf       	out	0x3d, r28	; 61
    3394:	dd 91       	ld	r29, X+
    3396:	de bf       	out	0x3e, r29	; 62
    3398:	ff 91       	pop	r31
    339a:	ef 91       	pop	r30
    339c:	df 91       	pop	r29
    339e:	cf 91       	pop	r28
    33a0:	bf 91       	pop	r27
    33a2:	af 91       	pop	r26
    33a4:	9f 91       	pop	r25
    33a6:	8f 91       	pop	r24
    33a8:	7f 91       	pop	r23
    33aa:	6f 91       	pop	r22
    33ac:	5f 91       	pop	r21
    33ae:	4f 91       	pop	r20
    33b0:	3f 91       	pop	r19
    33b2:	2f 91       	pop	r18
    33b4:	1f 91       	pop	r17
    33b6:	0f 91       	pop	r16
    33b8:	ff 90       	pop	r15
    33ba:	ef 90       	pop	r14
    33bc:	df 90       	pop	r13
    33be:	cf 90       	pop	r12
    33c0:	bf 90       	pop	r11
    33c2:	af 90       	pop	r10
    33c4:	9f 90       	pop	r9
    33c6:	8f 90       	pop	r8
    33c8:	7f 90       	pop	r7
    33ca:	6f 90       	pop	r6
    33cc:	5f 90       	pop	r5
    33ce:	4f 90       	pop	r4
    33d0:	3f 90       	pop	r3
    33d2:	2f 90       	pop	r2
    33d4:	1f 90       	pop	r1
    33d6:	0f 90       	pop	r0
    33d8:	0c be       	out	0x3c, r0	; 60
    33da:	0f 90       	pop	r0
    33dc:	0b be       	out	0x3b, r0	; 59
    33de:	0f 90       	pop	r0
    33e0:	0f be       	out	0x3f, r0	; 63
    33e2:	0f 90       	pop	r0

	asm volatile ( "ret" );
    33e4:	08 95       	ret

000033e6 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    33e6:	0f 92       	push	r0
    33e8:	0f b6       	in	r0, 0x3f	; 63
    33ea:	f8 94       	cli
    33ec:	0f 92       	push	r0
    33ee:	0b b6       	in	r0, 0x3b	; 59
    33f0:	0f 92       	push	r0
    33f2:	0c b6       	in	r0, 0x3c	; 60
    33f4:	0f 92       	push	r0
    33f6:	1f 92       	push	r1
    33f8:	11 24       	eor	r1, r1
    33fa:	2f 92       	push	r2
    33fc:	3f 92       	push	r3
    33fe:	4f 92       	push	r4
    3400:	5f 92       	push	r5
    3402:	6f 92       	push	r6
    3404:	7f 92       	push	r7
    3406:	8f 92       	push	r8
    3408:	9f 92       	push	r9
    340a:	af 92       	push	r10
    340c:	bf 92       	push	r11
    340e:	cf 92       	push	r12
    3410:	df 92       	push	r13
    3412:	ef 92       	push	r14
    3414:	ff 92       	push	r15
    3416:	0f 93       	push	r16
    3418:	1f 93       	push	r17
    341a:	2f 93       	push	r18
    341c:	3f 93       	push	r19
    341e:	4f 93       	push	r20
    3420:	5f 93       	push	r21
    3422:	6f 93       	push	r22
    3424:	7f 93       	push	r23
    3426:	8f 93       	push	r24
    3428:	9f 93       	push	r25
    342a:	af 93       	push	r26
    342c:	bf 93       	push	r27
    342e:	cf 93       	push	r28
    3430:	df 93       	push	r29
    3432:	ef 93       	push	r30
    3434:	ff 93       	push	r31
    3436:	a0 91 30 02 	lds	r26, 0x0230
    343a:	b0 91 31 02 	lds	r27, 0x0231
    343e:	0d b6       	in	r0, 0x3d	; 61
    3440:	0d 92       	st	X+, r0
    3442:	0e b6       	in	r0, 0x3e	; 62
    3444:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    3446:	0e 94 b6 07 	call	0xf6c	; 0xf6c <vTaskIncrementTick>
	vTaskSwitchContext();
    344a:	0e 94 93 08 	call	0x1126	; 0x1126 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    344e:	a0 91 30 02 	lds	r26, 0x0230
    3452:	b0 91 31 02 	lds	r27, 0x0231
    3456:	cd 91       	ld	r28, X+
    3458:	cd bf       	out	0x3d, r28	; 61
    345a:	dd 91       	ld	r29, X+
    345c:	de bf       	out	0x3e, r29	; 62
    345e:	ff 91       	pop	r31
    3460:	ef 91       	pop	r30
    3462:	df 91       	pop	r29
    3464:	cf 91       	pop	r28
    3466:	bf 91       	pop	r27
    3468:	af 91       	pop	r26
    346a:	9f 91       	pop	r25
    346c:	8f 91       	pop	r24
    346e:	7f 91       	pop	r23
    3470:	6f 91       	pop	r22
    3472:	5f 91       	pop	r21
    3474:	4f 91       	pop	r20
    3476:	3f 91       	pop	r19
    3478:	2f 91       	pop	r18
    347a:	1f 91       	pop	r17
    347c:	0f 91       	pop	r16
    347e:	ff 90       	pop	r15
    3480:	ef 90       	pop	r14
    3482:	df 90       	pop	r13
    3484:	cf 90       	pop	r12
    3486:	bf 90       	pop	r11
    3488:	af 90       	pop	r10
    348a:	9f 90       	pop	r9
    348c:	8f 90       	pop	r8
    348e:	7f 90       	pop	r7
    3490:	6f 90       	pop	r6
    3492:	5f 90       	pop	r5
    3494:	4f 90       	pop	r4
    3496:	3f 90       	pop	r3
    3498:	2f 90       	pop	r2
    349a:	1f 90       	pop	r1
    349c:	0f 90       	pop	r0
    349e:	0c be       	out	0x3c, r0	; 60
    34a0:	0f 90       	pop	r0
    34a2:	0b be       	out	0x3b, r0	; 59
    34a4:	0f 90       	pop	r0
    34a6:	0f be       	out	0x3f, r0	; 63
    34a8:	0f 90       	pop	r0

	asm volatile ( "ret" );
    34aa:	08 95       	ret

000034ac <prvSetupTimerInterrupt>:

/*
 * Setup timer 0 or 3 or 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    34ac:	cf 93       	push	r28
    34ae:	df 93       	push	r29
    34b0:	00 d0       	rcall	.+0      	; 0x34b2 <prvSetupTimerInterrupt+0x6>
    34b2:	00 d0       	rcall	.+0      	; 0x34b4 <prvSetupTimerInterrupt+0x8>
    34b4:	cd b7       	in	r28, 0x3d	; 61
    34b6:	de b7       	in	r29, 0x3e	; 62

    /* Using 8bit Timer0 or 16bit Timer1 or Timer3 to generate the tick. */

    // ulCompareMatch 40,000 = 20,000,000 / 500; 20MHz
    // ulCompareMatch 110,592 = 22,118,400 / 200; 22.1184 MHz
    ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    34b8:	80 e0       	ldi	r24, 0x00	; 0
    34ba:	9d e7       	ldi	r25, 0x7D	; 125
    34bc:	a0 e0       	ldi	r26, 0x00	; 0
    34be:	b0 e0       	ldi	r27, 0x00	; 0
    34c0:	89 83       	std	Y+1, r24	; 0x01
    34c2:	9a 83       	std	Y+2, r25	; 0x02
    34c4:	ab 83       	std	Y+3, r26	; 0x03
    34c6:	bc 83       	std	Y+4, r27	; 0x04

    /* We only have 8 or 16 bits so have to scale 64 or 256 to get our required tick rate. */
    //ulCompareMatch = 625 /= portCLOCK_PRESCALER; 20MHz with 64 prescale
    //ulCompareMatch = 108 /= portCLOCK_PRESCALER; 22.1184 MHz with 1024 prescale
    ulCompareMatch /= portCLOCK_PRESCALER;
    34c8:	89 81       	ldd	r24, Y+1	; 0x01
    34ca:	9a 81       	ldd	r25, Y+2	; 0x02
    34cc:	ab 81       	ldd	r26, Y+3	; 0x03
    34ce:	bc 81       	ldd	r27, Y+4	; 0x04
    34d0:	68 94       	set
    34d2:	15 f8       	bld	r1, 5
    34d4:	b6 95       	lsr	r27
    34d6:	a7 95       	ror	r26
    34d8:	97 95       	ror	r25
    34da:	87 95       	ror	r24
    34dc:	16 94       	lsr	r1
    34de:	d1 f7       	brne	.-12     	; 0x34d4 <prvSetupTimerInterrupt+0x28>
    34e0:	89 83       	std	Y+1, r24	; 0x01
    34e2:	9a 83       	std	Y+2, r25	; 0x02
    34e4:	ab 83       	std	Y+3, r26	; 0x03
    34e6:	bc 83       	std	Y+4, r27	; 0x04

    /* Adjust for correct value. */
    ulCompareMatch -= ( unsigned portLONG ) 1;
    34e8:	89 81       	ldd	r24, Y+1	; 0x01
    34ea:	9a 81       	ldd	r25, Y+2	; 0x02
    34ec:	ab 81       	ldd	r26, Y+3	; 0x03
    34ee:	bc 81       	ldd	r27, Y+4	; 0x04
    34f0:	01 97       	sbiw	r24, 0x01	; 1
    34f2:	a1 09       	sbc	r26, r1
    34f4:	b1 09       	sbc	r27, r1
    34f6:	89 83       	std	Y+1, r24	; 0x01
    34f8:	9a 83       	std	Y+2, r25	; 0x02
    34fa:	ab 83       	std	Y+3, r26	; 0x03
    34fc:	bc 83       	std	Y+4, r27	; 0x04

    /* Setup compare match value for compare match A.  Interrupts are disabled
    before this is called so we need not worry here. */
    ucLowByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
    34fe:	89 81       	ldd	r24, Y+1	; 0x01
    3500:	8d 83       	std	Y+5, r24	; 0x05
    //  OCR3AL = ucLowByte;

    // the HiByte is only needed, if a 16 Bit counter is being utilized
#ifdef portOCRH

    ulCompareMatch >>= 8;
    3502:	89 81       	ldd	r24, Y+1	; 0x01
    3504:	9a 81       	ldd	r25, Y+2	; 0x02
    3506:	ab 81       	ldd	r26, Y+3	; 0x03
    3508:	bc 81       	ldd	r27, Y+4	; 0x04
    350a:	89 2f       	mov	r24, r25
    350c:	9a 2f       	mov	r25, r26
    350e:	ab 2f       	mov	r26, r27
    3510:	bb 27       	eor	r27, r27
    3512:	89 83       	std	Y+1, r24	; 0x01
    3514:	9a 83       	std	Y+2, r25	; 0x02
    3516:	ab 83       	std	Y+3, r26	; 0x03
    3518:	bc 83       	std	Y+4, r27	; 0x04
    ucHighByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
    351a:	89 81       	ldd	r24, Y+1	; 0x01
    351c:	8e 83       	std	Y+6, r24	; 0x06
    portOCRH = ucHighByte;
    351e:	89 e9       	ldi	r24, 0x99	; 153
    3520:	90 e0       	ldi	r25, 0x00	; 0
    3522:	2e 81       	ldd	r18, Y+6	; 0x06
    3524:	fc 01       	movw	r30, r24
    3526:	20 83       	st	Z, r18

#endif

    portOCRL = ucLowByte;
    3528:	88 e9       	ldi	r24, 0x98	; 152
    352a:	90 e0       	ldi	r25, 0x00	; 0
    352c:	2d 81       	ldd	r18, Y+5	; 0x05
    352e:	fc 01       	movw	r30, r24
    3530:	20 83       	st	Z, r18
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	portTCCRb = ucLowByte;

#elif defined( portUSE_TIMER3 )
	/* Setup clock source and compare match behaviour. Assuming  640 / 1280 /1281 / 1284p / 2560 / 2561 (with Timer3) */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    3532:	8b e0       	ldi	r24, 0x0B	; 11
    3534:	8d 83       	std	Y+5, r24	; 0x05
	portTCCRb = ucLowByte;
    3536:	81 e9       	ldi	r24, 0x91	; 145
    3538:	90 e0       	ldi	r25, 0x00	; 0
    353a:	2d 81       	ldd	r18, Y+5	; 0x05
    353c:	fc 01       	movw	r30, r24
    353e:	20 83       	st	Z, r18
#endif

    /* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
    ucLowByte = portTIMSK;
    3540:	81 e7       	ldi	r24, 0x71	; 113
    3542:	90 e0       	ldi	r25, 0x00	; 0
    3544:	fc 01       	movw	r30, r24
    3546:	80 81       	ld	r24, Z
    3548:	8d 83       	std	Y+5, r24	; 0x05
    ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    354a:	8d 81       	ldd	r24, Y+5	; 0x05
    354c:	82 60       	ori	r24, 0x02	; 2
    354e:	8d 83       	std	Y+5, r24	; 0x05
    portTIMSK = ucLowByte;
    3550:	81 e7       	ldi	r24, 0x71	; 113
    3552:	90 e0       	ldi	r25, 0x00	; 0
    3554:	2d 81       	ldd	r18, Y+5	; 0x05
    3556:	fc 01       	movw	r30, r24
    3558:	20 83       	st	Z, r18

}
    355a:	26 96       	adiw	r28, 0x06	; 6
    355c:	0f b6       	in	r0, 0x3f	; 63
    355e:	f8 94       	cli
    3560:	de bf       	out	0x3e, r29	; 62
    3562:	0f be       	out	0x3f, r0	; 63
    3564:	cd bf       	out	0x3d, r28	; 61
    3566:	df 91       	pop	r29
    3568:	cf 91       	pop	r28
    356a:	08 95       	ret

0000356c <__vector_32>:

	#elif defined( portUSE_TIMER3 )
		#warning "Timer3 used for PRE-EMPTIVE scheduler."
		ISR(TIMER3_COMPA_vect, ISR_NAKED)
		{
			vPortYieldFromTick();
    356c:	0e 94 f3 19 	call	0x33e6	; 0x33e6 <vPortYieldFromTick>
			asm volatile ( "reti" );
    3570:	18 95       	reti

00003572 <USART_Init>:
*  the specified baud rate and clk speed.
*
* Param buadin: The desired Baud rate.
* Param clk_seedin: The clk speed of the ATmega328p
************************************/
void USART_Init(uint16_t baudin, uint32_t clk_speedin) {
    3572:	cf 93       	push	r28
    3574:	df 93       	push	r29
    3576:	00 d0       	rcall	.+0      	; 0x3578 <USART_Init+0x6>
    3578:	00 d0       	rcall	.+0      	; 0x357a <USART_Init+0x8>
    357a:	cd b7       	in	r28, 0x3d	; 61
    357c:	de b7       	in	r29, 0x3e	; 62
    357e:	9a 83       	std	Y+2, r25	; 0x02
    3580:	89 83       	std	Y+1, r24	; 0x01
    3582:	4b 83       	std	Y+3, r20	; 0x03
    3584:	5c 83       	std	Y+4, r21	; 0x04
    3586:	6d 83       	std	Y+5, r22	; 0x05
    3588:	7e 83       	std	Y+6, r23	; 0x06
    USART_WriteQueue = xQueueCreate(64,sizeof(uint8_t));
    358a:	40 e0       	ldi	r20, 0x00	; 0
    358c:	61 e0       	ldi	r22, 0x01	; 1
    358e:	80 e4       	ldi	r24, 0x40	; 64
    3590:	0e 94 95 0d 	call	0x1b2a	; 0x1b2a <xQueueGenericCreate>
    3594:	90 93 6a 1b 	sts	0x1B6A, r25
    3598:	80 93 69 1b 	sts	0x1B69, r24
    USART_ReadQueue = xQueueCreate(8,sizeof(uint8_t));
    359c:	40 e0       	ldi	r20, 0x00	; 0
    359e:	61 e0       	ldi	r22, 0x01	; 1
    35a0:	88 e0       	ldi	r24, 0x08	; 8
    35a2:	0e 94 95 0d 	call	0x1b2a	; 0x1b2a <xQueueGenericCreate>
    35a6:	90 93 66 1b 	sts	0x1B66, r25
    35aa:	80 93 65 1b 	sts	0x1B65, r24

    //uint32_t ubrr = clk_speedin/(16UL)/baudin-1;
    //UBRR1H = (unsigned char)(ubrr>>8) ;// & 0x7F;
    //UBRR1L = (unsigned char)ubrr;
    
    UBRR0H = 0; //115200
    35ae:	85 ec       	ldi	r24, 0xC5	; 197
    35b0:	90 e0       	ldi	r25, 0x00	; 0
    35b2:	fc 01       	movw	r30, r24
    35b4:	10 82       	st	Z, r1
    UBRR0L = 8;
    35b6:	84 ec       	ldi	r24, 0xC4	; 196
    35b8:	90 e0       	ldi	r25, 0x00	; 0
    35ba:	28 e0       	ldi	r18, 0x08	; 8
    35bc:	fc 01       	movw	r30, r24
    35be:	20 83       	st	Z, r18

    /* Enable receiver and transmitter */
    UCSR0B = (1<<RXEN0)|(1<<TXEN0);//|(1<<RXCIE1);
    35c0:	81 ec       	ldi	r24, 0xC1	; 193
    35c2:	90 e0       	ldi	r25, 0x00	; 0
    35c4:	28 e1       	ldi	r18, 0x18	; 24
    35c6:	fc 01       	movw	r30, r24
    35c8:	20 83       	st	Z, r18
    /* Set frame format: 8data, 1stop bit */
    UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);
    35ca:	82 ec       	ldi	r24, 0xC2	; 194
    35cc:	90 e0       	ldi	r25, 0x00	; 0
    35ce:	26 e0       	ldi	r18, 0x06	; 6
    35d0:	fc 01       	movw	r30, r24
    35d2:	20 83       	st	Z, r18
	 // clear U2X0 for Synchronous operation
    UCSR0A &= ~(1<<U2X0);
    35d4:	80 ec       	ldi	r24, 0xC0	; 192
    35d6:	90 e0       	ldi	r25, 0x00	; 0
    35d8:	20 ec       	ldi	r18, 0xC0	; 192
    35da:	30 e0       	ldi	r19, 0x00	; 0
    35dc:	f9 01       	movw	r30, r18
    35de:	20 81       	ld	r18, Z
    35e0:	2d 7f       	andi	r18, 0xFD	; 253
    35e2:	fc 01       	movw	r30, r24
    35e4:	20 83       	st	Z, r18
    /* Set frame format: 8data, 1stop bit */
    //UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);
    // clear U2X0 for Synchronous operation
    //UCSR0A &= ~(1<<U2X0);*/

}
    35e6:	26 96       	adiw	r28, 0x06	; 6
    35e8:	0f b6       	in	r0, 0x3f	; 63
    35ea:	f8 94       	cli
    35ec:	de bf       	out	0x3e, r29	; 62
    35ee:	0f be       	out	0x3f, r0	; 63
    35f0:	cd bf       	out	0x3d, r28	; 61
    35f2:	df 91       	pop	r29
    35f4:	cf 91       	pop	r28
    35f6:	08 95       	ret

000035f8 <USART_Write>:

/*the send function will put 8bits on the trans line. */
void USART_Write(uint8_t data) {
    35f8:	cf 93       	push	r28
    35fa:	df 93       	push	r29
    35fc:	1f 92       	push	r1
    35fe:	cd b7       	in	r28, 0x3d	; 61
    3600:	de b7       	in	r29, 0x3e	; 62
    3602:	89 83       	std	Y+1, r24	; 0x01
		/* Wait for empty transmit buffer */
		while ( !( UCSR0A & (1<<UDRE0)) )
    3604:	00 00       	nop
    3606:	80 ec       	ldi	r24, 0xC0	; 192
    3608:	90 e0       	ldi	r25, 0x00	; 0
    360a:	fc 01       	movw	r30, r24
    360c:	80 81       	ld	r24, Z
    360e:	88 2f       	mov	r24, r24
    3610:	90 e0       	ldi	r25, 0x00	; 0
    3612:	80 72       	andi	r24, 0x20	; 32
    3614:	99 27       	eor	r25, r25
    3616:	00 97       	sbiw	r24, 0x00	; 0
    3618:	b1 f3       	breq	.-20     	; 0x3606 <USART_Write+0xe>
		;
		/* Put data into buffer, sends the data */
		UDR0 = data;
    361a:	86 ec       	ldi	r24, 0xC6	; 198
    361c:	90 e0       	ldi	r25, 0x00	; 0
    361e:	29 81       	ldd	r18, Y+1	; 0x01
    3620:	fc 01       	movw	r30, r24
    3622:	20 83       	st	Z, r18
}
    3624:	0f 90       	pop	r0
    3626:	df 91       	pop	r29
    3628:	cf 91       	pop	r28
    362a:	08 95       	ret

0000362c <USART_Write_Unprotected>:

/*the send function will put 8bits on the trans line. */
void USART_Write_Unprotected(uint8_t data) {
    362c:	cf 93       	push	r28
    362e:	df 93       	push	r29
    3630:	1f 92       	push	r1
    3632:	cd b7       	in	r28, 0x3d	; 61
    3634:	de b7       	in	r29, 0x3e	; 62
    3636:	89 83       	std	Y+1, r24	; 0x01
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)) )
    3638:	00 00       	nop
    363a:	80 ec       	ldi	r24, 0xC0	; 192
    363c:	90 e0       	ldi	r25, 0x00	; 0
    363e:	fc 01       	movw	r30, r24
    3640:	80 81       	ld	r24, Z
    3642:	88 2f       	mov	r24, r24
    3644:	90 e0       	ldi	r25, 0x00	; 0
    3646:	80 72       	andi	r24, 0x20	; 32
    3648:	99 27       	eor	r25, r25
    364a:	00 97       	sbiw	r24, 0x00	; 0
    364c:	b1 f3       	breq	.-20     	; 0x363a <USART_Write_Unprotected+0xe>
	;
	/* Put data into buffer, sends the data */
	UDR0 = data;
    364e:	86 ec       	ldi	r24, 0xC6	; 198
    3650:	90 e0       	ldi	r25, 0x00	; 0
    3652:	29 81       	ldd	r18, Y+1	; 0x01
    3654:	fc 01       	movw	r30, r24
    3656:	20 83       	st	Z, r18
}
    3658:	0f 90       	pop	r0
    365a:	df 91       	pop	r29
    365c:	cf 91       	pop	r28
    365e:	08 95       	ret

00003660 <USART_Read>:
Therefore you may not get control back after this is called 
until a much later time. It may be helpful to use the 
istheredata() function to check before calling this function
        @return 8bit data packet from sender
*/
uint8_t USART_Read(void) {
    3660:	cf 93       	push	r28
    3662:	df 93       	push	r29
    3664:	cd b7       	in	r28, 0x3d	; 61
    3666:	de b7       	in	r29, 0x3e	; 62
    /* Wait for data to be received */
    while ( !(UCSR2A & (1<<RXC2)) )
    3668:	00 00       	nop
    366a:	80 ed       	ldi	r24, 0xD0	; 208
    366c:	90 e0       	ldi	r25, 0x00	; 0
    366e:	fc 01       	movw	r30, r24
    3670:	80 81       	ld	r24, Z
    3672:	88 23       	and	r24, r24
    3674:	d4 f7       	brge	.-12     	; 0x366a <USART_Read+0xa>
        ;
    /* Get and return received data from buffer */
    return UDR2;
    3676:	86 ed       	ldi	r24, 0xD6	; 214
    3678:	90 e0       	ldi	r25, 0x00	; 0
    367a:	fc 01       	movw	r30, r24
    367c:	80 81       	ld	r24, Z
}
    367e:	df 91       	pop	r29
    3680:	cf 91       	pop	r28
    3682:	08 95       	ret

00003684 <__vector_36>:


ISR(USART1_RX_vect){
    3684:	1f 92       	push	r1
    3686:	0f 92       	push	r0
    3688:	00 90 5f 00 	lds	r0, 0x005F
    368c:	0f 92       	push	r0
    368e:	11 24       	eor	r1, r1
    3690:	00 90 5b 00 	lds	r0, 0x005B
    3694:	0f 92       	push	r0
    3696:	8f 93       	push	r24
    3698:	9f 93       	push	r25
    369a:	ef 93       	push	r30
    369c:	ff 93       	push	r31
    369e:	cf 93       	push	r28
    36a0:	df 93       	push	r29
    36a2:	1f 92       	push	r1
    36a4:	cd b7       	in	r28, 0x3d	; 61
    36a6:	de b7       	in	r29, 0x3e	; 62
    uint8_t data;
    data = UDR1;
    36a8:	8e ec       	ldi	r24, 0xCE	; 206
    36aa:	90 e0       	ldi	r25, 0x00	; 0
    36ac:	fc 01       	movw	r30, r24
    36ae:	80 81       	ld	r24, Z
    36b0:	89 83       	std	Y+1, r24	; 0x01
    //UDR1 = data;
    

  //  USART_AddToQueue(data);
    //xQueueSendToBackFromISR(USART_ReadQueue,&data,NULL);
}
    36b2:	0f 90       	pop	r0
    36b4:	df 91       	pop	r29
    36b6:	cf 91       	pop	r28
    36b8:	ff 91       	pop	r31
    36ba:	ef 91       	pop	r30
    36bc:	9f 91       	pop	r25
    36be:	8f 91       	pop	r24
    36c0:	0f 90       	pop	r0
    36c2:	00 92 5b 00 	sts	0x005B, r0
    36c6:	0f 90       	pop	r0
    36c8:	00 92 5f 00 	sts	0x005F, r0
    36cc:	0f 90       	pop	r0
    36ce:	1f 90       	pop	r1
    36d0:	18 95       	reti

000036d2 <USART_AddToQueue>:

void USART_AddToQueue(uint8_t data){
    36d2:	cf 93       	push	r28
    36d4:	df 93       	push	r29
    36d6:	1f 92       	push	r1
    36d8:	cd b7       	in	r28, 0x3d	; 61
    36da:	de b7       	in	r29, 0x3e	; 62
    36dc:	89 83       	std	Y+1, r24	; 0x01
    
    xQueueSendToBack(USART_WriteQueue,&data,portMAX_DELAY);
    36de:	80 91 69 1b 	lds	r24, 0x1B69
    36e2:	90 91 6a 1b 	lds	r25, 0x1B6A
    36e6:	20 e0       	ldi	r18, 0x00	; 0
    36e8:	4f ef       	ldi	r20, 0xFF	; 255
    36ea:	5f ef       	ldi	r21, 0xFF	; 255
    36ec:	be 01       	movw	r22, r28
    36ee:	6f 5f       	subi	r22, 0xFF	; 255
    36f0:	7f 4f       	sbci	r23, 0xFF	; 255
    36f2:	0e 94 4c 0e 	call	0x1c98	; 0x1c98 <xQueueGenericSend>

}
    36f6:	0f 90       	pop	r0
    36f8:	df 91       	pop	r29
    36fa:	cf 91       	pop	r28
    36fc:	08 95       	ret

000036fe <USART_TransmitString>:

void USART_TransmitString(char* str){
    36fe:	cf 93       	push	r28
    3700:	df 93       	push	r29
    3702:	1f 92       	push	r1
    3704:	1f 92       	push	r1
    3706:	cd b7       	in	r28, 0x3d	; 61
    3708:	de b7       	in	r29, 0x3e	; 62
    370a:	9a 83       	std	Y+2, r25	; 0x02
    370c:	89 83       	std	Y+1, r24	; 0x01
    while(*str) {
    370e:	0b c0       	rjmp	.+22     	; 0x3726 <USART_TransmitString+0x28>
        USART_AddToQueue(*str);
    3710:	89 81       	ldd	r24, Y+1	; 0x01
    3712:	9a 81       	ldd	r25, Y+2	; 0x02
    3714:	fc 01       	movw	r30, r24
    3716:	80 81       	ld	r24, Z
    3718:	0e 94 69 1b 	call	0x36d2	; 0x36d2 <USART_AddToQueue>
        str++;
    371c:	89 81       	ldd	r24, Y+1	; 0x01
    371e:	9a 81       	ldd	r25, Y+2	; 0x02
    3720:	01 96       	adiw	r24, 0x01	; 1
    3722:	9a 83       	std	Y+2, r25	; 0x02
    3724:	89 83       	std	Y+1, r24	; 0x01
    xQueueSendToBack(USART_WriteQueue,&data,portMAX_DELAY);

}

void USART_TransmitString(char* str){
    while(*str) {
    3726:	89 81       	ldd	r24, Y+1	; 0x01
    3728:	9a 81       	ldd	r25, Y+2	; 0x02
    372a:	fc 01       	movw	r30, r24
    372c:	80 81       	ld	r24, Z
    372e:	88 23       	and	r24, r24
    3730:	79 f7       	brne	.-34     	; 0x3710 <USART_TransmitString+0x12>
        USART_AddToQueue(*str);
        str++;
    }
}
    3732:	0f 90       	pop	r0
    3734:	0f 90       	pop	r0
    3736:	df 91       	pop	r29
    3738:	cf 91       	pop	r28
    373a:	08 95       	ret

0000373c <vTaskUSARTWrite>:

void vTaskUSARTWrite(void *pvParameters){
    373c:	cf 93       	push	r28
    373e:	df 93       	push	r29
    3740:	00 d0       	rcall	.+0      	; 0x3742 <vTaskUSARTWrite+0x6>
    3742:	cd b7       	in	r28, 0x3d	; 61
    3744:	de b7       	in	r29, 0x3e	; 62
    3746:	9b 83       	std	Y+3, r25	; 0x03
    3748:	8a 83       	std	Y+2, r24	; 0x02
    uint8_t data;
    while(1){
    xQueueReceive(USART_WriteQueue,&data,portMAX_DELAY);
    374a:	80 91 69 1b 	lds	r24, 0x1B69
    374e:	90 91 6a 1b 	lds	r25, 0x1B6A
    3752:	20 e0       	ldi	r18, 0x00	; 0
    3754:	4f ef       	ldi	r20, 0xFF	; 255
    3756:	5f ef       	ldi	r21, 0xFF	; 255
    3758:	be 01       	movw	r22, r28
    375a:	6f 5f       	subi	r22, 0xFF	; 255
    375c:	7f 4f       	sbci	r23, 0xFF	; 255
    375e:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <xQueueGenericReceive>

        while(!(UCSR1A & (1<<UDRE1)));
    3762:	00 00       	nop
    3764:	88 ec       	ldi	r24, 0xC8	; 200
    3766:	90 e0       	ldi	r25, 0x00	; 0
    3768:	fc 01       	movw	r30, r24
    376a:	80 81       	ld	r24, Z
    376c:	88 2f       	mov	r24, r24
    376e:	90 e0       	ldi	r25, 0x00	; 0
    3770:	80 72       	andi	r24, 0x20	; 32
    3772:	99 27       	eor	r25, r25
    3774:	00 97       	sbiw	r24, 0x00	; 0
    3776:	b1 f3       	breq	.-20     	; 0x3764 <vTaskUSARTWrite+0x28>
        UDR1 = data;
    3778:	8e ec       	ldi	r24, 0xCE	; 206
    377a:	90 e0       	ldi	r25, 0x00	; 0
    377c:	29 81       	ldd	r18, Y+1	; 0x01
    377e:	fc 01       	movw	r30, r24
    3780:	20 83       	st	Z, r18

    }
    3782:	e3 cf       	rjmp	.-58     	; 0x374a <vTaskUSARTWrite+0xe>

00003784 <USART_LogChar>:
}

void USART_LogChar(uint8_t data){
    3784:	cf 93       	push	r28
    3786:	df 93       	push	r29
    3788:	1f 92       	push	r1
    378a:	cd b7       	in	r28, 0x3d	; 61
    378c:	de b7       	in	r29, 0x3e	; 62
    378e:	89 83       	std	Y+1, r24	; 0x01
    xQueueSendToBack(USART_WriteQueueLog,&data,portMAX_DELAY);
    3790:	80 91 67 1b 	lds	r24, 0x1B67
    3794:	90 91 68 1b 	lds	r25, 0x1B68
    3798:	20 e0       	ldi	r18, 0x00	; 0
    379a:	4f ef       	ldi	r20, 0xFF	; 255
    379c:	5f ef       	ldi	r21, 0xFF	; 255
    379e:	be 01       	movw	r22, r28
    37a0:	6f 5f       	subi	r22, 0xFF	; 255
    37a2:	7f 4f       	sbci	r23, 0xFF	; 255
    37a4:	0e 94 4c 0e 	call	0x1c98	; 0x1c98 <xQueueGenericSend>
}
    37a8:	0f 90       	pop	r0
    37aa:	df 91       	pop	r29
    37ac:	cf 91       	pop	r28
    37ae:	08 95       	ret

000037b0 <USART_LogString>:

void USART_LogString(char* str){
    37b0:	cf 93       	push	r28
    37b2:	df 93       	push	r29
    37b4:	1f 92       	push	r1
    37b6:	1f 92       	push	r1
    37b8:	cd b7       	in	r28, 0x3d	; 61
    37ba:	de b7       	in	r29, 0x3e	; 62
    37bc:	9a 83       	std	Y+2, r25	; 0x02
    37be:	89 83       	std	Y+1, r24	; 0x01
    while(*str){
    37c0:	0b c0       	rjmp	.+22     	; 0x37d8 <USART_LogString+0x28>
        USART_LogChar(*str);
    37c2:	89 81       	ldd	r24, Y+1	; 0x01
    37c4:	9a 81       	ldd	r25, Y+2	; 0x02
    37c6:	fc 01       	movw	r30, r24
    37c8:	80 81       	ld	r24, Z
    37ca:	0e 94 c2 1b 	call	0x3784	; 0x3784 <USART_LogChar>
        str++;
    37ce:	89 81       	ldd	r24, Y+1	; 0x01
    37d0:	9a 81       	ldd	r25, Y+2	; 0x02
    37d2:	01 96       	adiw	r24, 0x01	; 1
    37d4:	9a 83       	std	Y+2, r25	; 0x02
    37d6:	89 83       	std	Y+1, r24	; 0x01
void USART_LogChar(uint8_t data){
    xQueueSendToBack(USART_WriteQueueLog,&data,portMAX_DELAY);
}

void USART_LogString(char* str){
    while(*str){
    37d8:	89 81       	ldd	r24, Y+1	; 0x01
    37da:	9a 81       	ldd	r25, Y+2	; 0x02
    37dc:	fc 01       	movw	r30, r24
    37de:	80 81       	ld	r24, Z
    37e0:	88 23       	and	r24, r24
    37e2:	79 f7       	brne	.-34     	; 0x37c2 <USART_LogString+0x12>
        USART_LogChar(*str);
        str++;
    }
}
    37e4:	0f 90       	pop	r0
    37e6:	0f 90       	pop	r0
    37e8:	df 91       	pop	r29
    37ea:	cf 91       	pop	r28
    37ec:	08 95       	ret

000037ee <vTaskUSARTLog>:

void vTaskUSARTLog(void *pvParameters){
    37ee:	cf 93       	push	r28
    37f0:	df 93       	push	r29
    37f2:	00 d0       	rcall	.+0      	; 0x37f4 <vTaskUSARTLog+0x6>
    37f4:	cd b7       	in	r28, 0x3d	; 61
    37f6:	de b7       	in	r29, 0x3e	; 62
    37f8:	9b 83       	std	Y+3, r25	; 0x03
    37fa:	8a 83       	std	Y+2, r24	; 0x02
    uint8_t data;
    while(1){
        xQueueReceive(USART_WriteQueueLog,&data,portMAX_DELAY);
    37fc:	80 91 67 1b 	lds	r24, 0x1B67
    3800:	90 91 68 1b 	lds	r25, 0x1B68
    3804:	20 e0       	ldi	r18, 0x00	; 0
    3806:	4f ef       	ldi	r20, 0xFF	; 255
    3808:	5f ef       	ldi	r21, 0xFF	; 255
    380a:	be 01       	movw	r22, r28
    380c:	6f 5f       	subi	r22, 0xFF	; 255
    380e:	7f 4f       	sbci	r23, 0xFF	; 255
    3810:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <xQueueGenericReceive>

        while(!(UCSR0A & (1<<UDRE0)));
    3814:	00 00       	nop
    3816:	80 ec       	ldi	r24, 0xC0	; 192
    3818:	90 e0       	ldi	r25, 0x00	; 0
    381a:	fc 01       	movw	r30, r24
    381c:	80 81       	ld	r24, Z
    381e:	88 2f       	mov	r24, r24
    3820:	90 e0       	ldi	r25, 0x00	; 0
    3822:	80 72       	andi	r24, 0x20	; 32
    3824:	99 27       	eor	r25, r25
    3826:	00 97       	sbiw	r24, 0x00	; 0
    3828:	b1 f3       	breq	.-20     	; 0x3816 <vTaskUSARTLog+0x28>
        UDR0 = data;
    382a:	86 ec       	ldi	r24, 0xC6	; 198
    382c:	90 e0       	ldi	r25, 0x00	; 0
    382e:	29 81       	ldd	r18, Y+1	; 0x01
    3830:	fc 01       	movw	r30, r24
    3832:	20 83       	st	Z, r18

    }
    3834:	e3 cf       	rjmp	.-58     	; 0x37fc <vTaskUSARTLog+0xe>

00003836 <USART_GetChar>:

}

uint8_t USART_GetChar(){
    3836:	cf 93       	push	r28
    3838:	df 93       	push	r29
    383a:	1f 92       	push	r1
    383c:	cd b7       	in	r28, 0x3d	; 61
    383e:	de b7       	in	r29, 0x3e	; 62
    uint8_t data;
    if(xQueueReceive(USART_ReadQueue,&data,1) == pdTRUE){
    3840:	80 91 65 1b 	lds	r24, 0x1B65
    3844:	90 91 66 1b 	lds	r25, 0x1B66
    3848:	20 e0       	ldi	r18, 0x00	; 0
    384a:	41 e0       	ldi	r20, 0x01	; 1
    384c:	50 e0       	ldi	r21, 0x00	; 0
    384e:	be 01       	movw	r22, r28
    3850:	6f 5f       	subi	r22, 0xFF	; 255
    3852:	7f 4f       	sbci	r23, 0xFF	; 255
    3854:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <xQueueGenericReceive>
    3858:	81 30       	cpi	r24, 0x01	; 1
    385a:	11 f4       	brne	.+4      	; 0x3860 <USART_GetChar+0x2a>
        //USART_AddToQueue('~');
        return data;
    385c:	89 81       	ldd	r24, Y+1	; 0x01
    385e:	01 c0       	rjmp	.+2      	; 0x3862 <USART_GetChar+0x2c>
    } else {
        return 255;
    3860:	8f ef       	ldi	r24, 0xFF	; 255
    }
}
    3862:	0f 90       	pop	r0
    3864:	df 91       	pop	r29
    3866:	cf 91       	pop	r28
    3868:	08 95       	ret

0000386a <delay>:

void delay(int a){
    386a:	cf 93       	push	r28
    386c:	df 93       	push	r29
    386e:	00 d0       	rcall	.+0      	; 0x3870 <delay+0x6>
    3870:	1f 92       	push	r1
    3872:	cd b7       	in	r28, 0x3d	; 61
    3874:	de b7       	in	r29, 0x3e	; 62
    3876:	9c 83       	std	Y+4, r25	; 0x04
    3878:	8b 83       	std	Y+3, r24	; 0x03
	int i;
	for(i = 0;i < a;i++);
    387a:	1a 82       	std	Y+2, r1	; 0x02
    387c:	19 82       	std	Y+1, r1	; 0x01
    387e:	05 c0       	rjmp	.+10     	; 0x388a <delay+0x20>
    3880:	89 81       	ldd	r24, Y+1	; 0x01
    3882:	9a 81       	ldd	r25, Y+2	; 0x02
    3884:	01 96       	adiw	r24, 0x01	; 1
    3886:	9a 83       	std	Y+2, r25	; 0x02
    3888:	89 83       	std	Y+1, r24	; 0x01
    388a:	29 81       	ldd	r18, Y+1	; 0x01
    388c:	3a 81       	ldd	r19, Y+2	; 0x02
    388e:	8b 81       	ldd	r24, Y+3	; 0x03
    3890:	9c 81       	ldd	r25, Y+4	; 0x04
    3892:	28 17       	cp	r18, r24
    3894:	39 07       	cpc	r19, r25
    3896:	a4 f3       	brlt	.-24     	; 0x3880 <delay+0x16>
}
    3898:	0f 90       	pop	r0
    389a:	0f 90       	pop	r0
    389c:	0f 90       	pop	r0
    389e:	0f 90       	pop	r0
    38a0:	df 91       	pop	r29
    38a2:	cf 91       	pop	r28
    38a4:	08 95       	ret

000038a6 <sendACK>:

void sendACK(){
    38a6:	cf 93       	push	r28
    38a8:	df 93       	push	r29
    38aa:	cd b7       	in	r28, 0x3d	; 61
    38ac:	de b7       	in	r29, 0x3e	; 62
    USART_Write(ACK_BYTE);
    38ae:	80 e8       	ldi	r24, 0x80	; 128
    38b0:	0e 94 fc 1a 	call	0x35f8	; 0x35f8 <USART_Write>
}
    38b4:	df 91       	pop	r29
    38b6:	cf 91       	pop	r28
    38b8:	08 95       	ret

000038ba <sendNACK>:

void sendNACK(){
    38ba:	cf 93       	push	r28
    38bc:	df 93       	push	r29
    38be:	cd b7       	in	r28, 0x3d	; 61
    38c0:	de b7       	in	r29, 0x3e	; 62
    USART_Write(NACK_BYTE);
    38c2:	80 e0       	ldi	r24, 0x00	; 0
    38c4:	0e 94 fc 1a 	call	0x35f8	; 0x35f8 <USART_Write>
}
    38c8:	df 91       	pop	r29
    38ca:	cf 91       	pop	r28
    38cc:	08 95       	ret

000038ce <recievePayload>:

int recievePayload(int size,unsigned char *buffer){
    38ce:	cf 93       	push	r28
    38d0:	df 93       	push	r29
    38d2:	cd b7       	in	r28, 0x3d	; 61
    38d4:	de b7       	in	r29, 0x3e	; 62
    38d6:	2d 97       	sbiw	r28, 0x0d	; 13
    38d8:	0f b6       	in	r0, 0x3f	; 63
    38da:	f8 94       	cli
    38dc:	de bf       	out	0x3e, r29	; 62
    38de:	0f be       	out	0x3f, r0	; 63
    38e0:	cd bf       	out	0x3d, r28	; 61
    38e2:	9b 87       	std	Y+11, r25	; 0x0b
    38e4:	8a 87       	std	Y+10, r24	; 0x0a
    38e6:	7d 87       	std	Y+13, r23	; 0x0d
    38e8:	6c 87       	std	Y+12, r22	; 0x0c

	int bytesRecieved = 0;
    38ea:	1a 82       	std	Y+2, r1	; 0x02
    38ec:	19 82       	std	Y+1, r1	; 0x01
	int numTries = 0;
    38ee:	1c 82       	std	Y+4, r1	; 0x04
    38f0:	1b 82       	std	Y+3, r1	; 0x03
	const int maxNumTries = 3;
    38f2:	83 e0       	ldi	r24, 0x03	; 3
    38f4:	90 e0       	ldi	r25, 0x00	; 0
    38f6:	98 87       	std	Y+8, r25	; 0x08
    38f8:	8f 83       	std	Y+7, r24	; 0x07
	unsigned char data;
	int timeout;

	while(numTries < maxNumTries){
    38fa:	6d c0       	rjmp	.+218    	; 0x39d6 <recievePayload+0x108>
		while(bytesRecieved < size){
    38fc:	2e c0       	rjmp	.+92     	; 0x395a <recievePayload+0x8c>
			timeout = 50;
    38fe:	82 e3       	ldi	r24, 0x32	; 50
    3900:	90 e0       	ldi	r25, 0x00	; 0
    3902:	9e 83       	std	Y+6, r25	; 0x06
    3904:	8d 83       	std	Y+5, r24	; 0x05
			while ( !(UCSR0A & (1<<RXC0)) ){
    3906:	10 c0       	rjmp	.+32     	; 0x3928 <recievePayload+0x5a>
  				timeout--;
    3908:	8d 81       	ldd	r24, Y+5	; 0x05
    390a:	9e 81       	ldd	r25, Y+6	; 0x06
    390c:	01 97       	sbiw	r24, 0x01	; 1
    390e:	9e 83       	std	Y+6, r25	; 0x06
    3910:	8d 83       	std	Y+5, r24	; 0x05
     			if(timeout == 0){
    3912:	8d 81       	ldd	r24, Y+5	; 0x05
    3914:	9e 81       	ldd	r25, Y+6	; 0x06
    3916:	00 97       	sbiw	r24, 0x00	; 0
    3918:	19 f4       	brne	.+6      	; 0x3920 <recievePayload+0x52>
					return -1;
    391a:	8f ef       	ldi	r24, 0xFF	; 255
    391c:	9f ef       	ldi	r25, 0xFF	; 255
    391e:	65 c0       	rjmp	.+202    	; 0x39ea <recievePayload+0x11c>
     			}
     			vTaskDelay(1);
    3920:	81 e0       	ldi	r24, 0x01	; 1
    3922:	90 e0       	ldi	r25, 0x00	; 0
    3924:	0e 94 1d 05 	call	0xa3a	; 0xa3a <vTaskDelay>
	int timeout;

	while(numTries < maxNumTries){
		while(bytesRecieved < size){
			timeout = 50;
			while ( !(UCSR0A & (1<<RXC0)) ){
    3928:	80 ec       	ldi	r24, 0xC0	; 192
    392a:	90 e0       	ldi	r25, 0x00	; 0
    392c:	fc 01       	movw	r30, r24
    392e:	80 81       	ld	r24, Z
    3930:	88 23       	and	r24, r24
    3932:	54 f7       	brge	.-44     	; 0x3908 <recievePayload+0x3a>
     			if(timeout == 0){
					return -1;
     			}
     			vTaskDelay(1);
   		}
			data = UDR0;
    3934:	86 ec       	ldi	r24, 0xC6	; 198
    3936:	90 e0       	ldi	r25, 0x00	; 0
    3938:	fc 01       	movw	r30, r24
    393a:	80 81       	ld	r24, Z
    393c:	89 87       	std	Y+9, r24	; 0x09
			buffer[bytesRecieved] = data;
    393e:	89 81       	ldd	r24, Y+1	; 0x01
    3940:	9a 81       	ldd	r25, Y+2	; 0x02
    3942:	2c 85       	ldd	r18, Y+12	; 0x0c
    3944:	3d 85       	ldd	r19, Y+13	; 0x0d
    3946:	82 0f       	add	r24, r18
    3948:	93 1f       	adc	r25, r19
    394a:	29 85       	ldd	r18, Y+9	; 0x09
    394c:	fc 01       	movw	r30, r24
    394e:	20 83       	st	Z, r18
			bytesRecieved++;
    3950:	89 81       	ldd	r24, Y+1	; 0x01
    3952:	9a 81       	ldd	r25, Y+2	; 0x02
    3954:	01 96       	adiw	r24, 0x01	; 1
    3956:	9a 83       	std	Y+2, r25	; 0x02
    3958:	89 83       	std	Y+1, r24	; 0x01
	const int maxNumTries = 3;
	unsigned char data;
	int timeout;

	while(numTries < maxNumTries){
		while(bytesRecieved < size){
    395a:	29 81       	ldd	r18, Y+1	; 0x01
    395c:	3a 81       	ldd	r19, Y+2	; 0x02
    395e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3960:	9b 85       	ldd	r25, Y+11	; 0x0b
    3962:	28 17       	cp	r18, r24
    3964:	39 07       	cpc	r19, r25
    3966:	5c f2       	brlt	.-106    	; 0x38fe <recievePayload+0x30>
			data = UDR0;
			buffer[bytesRecieved] = data;
			bytesRecieved++;
		}
		
		timeout = 50;
    3968:	82 e3       	ldi	r24, 0x32	; 50
    396a:	90 e0       	ldi	r25, 0x00	; 0
    396c:	9e 83       	std	Y+6, r25	; 0x06
    396e:	8d 83       	std	Y+5, r24	; 0x05
		while ( !(UCSR0A & (1<<RXC0)) ){
    3970:	10 c0       	rjmp	.+32     	; 0x3992 <recievePayload+0xc4>
  			timeout--;
    3972:	8d 81       	ldd	r24, Y+5	; 0x05
    3974:	9e 81       	ldd	r25, Y+6	; 0x06
    3976:	01 97       	sbiw	r24, 0x01	; 1
    3978:	9e 83       	std	Y+6, r25	; 0x06
    397a:	8d 83       	std	Y+5, r24	; 0x05
     		if(timeout == 0){
    397c:	8d 81       	ldd	r24, Y+5	; 0x05
    397e:	9e 81       	ldd	r25, Y+6	; 0x06
    3980:	00 97       	sbiw	r24, 0x00	; 0
    3982:	19 f4       	brne	.+6      	; 0x398a <recievePayload+0xbc>
				return -1;
    3984:	8f ef       	ldi	r24, 0xFF	; 255
    3986:	9f ef       	ldi	r25, 0xFF	; 255
    3988:	30 c0       	rjmp	.+96     	; 0x39ea <recievePayload+0x11c>
     		}
     		vTaskDelay(1);
    398a:	81 e0       	ldi	r24, 0x01	; 1
    398c:	90 e0       	ldi	r25, 0x00	; 0
    398e:	0e 94 1d 05 	call	0xa3a	; 0xa3a <vTaskDelay>
			buffer[bytesRecieved] = data;
			bytesRecieved++;
		}
		
		timeout = 50;
		while ( !(UCSR0A & (1<<RXC0)) ){
    3992:	80 ec       	ldi	r24, 0xC0	; 192
    3994:	90 e0       	ldi	r25, 0x00	; 0
    3996:	fc 01       	movw	r30, r24
    3998:	80 81       	ld	r24, Z
    399a:	88 23       	and	r24, r24
    399c:	54 f7       	brge	.-44     	; 0x3972 <recievePayload+0xa4>
     		if(timeout == 0){
				return -1;
     		}
     		vTaskDelay(1);
   	}	
		data = UDR0;
    399e:	86 ec       	ldi	r24, 0xC6	; 198
    39a0:	90 e0       	ldi	r25, 0x00	; 0
    39a2:	fc 01       	movw	r30, r24
    39a4:	80 81       	ld	r24, Z
    39a6:	89 87       	std	Y+9, r24	; 0x09
		if(data != calcChecksum(buffer,size)){
    39a8:	2a 85       	ldd	r18, Y+10	; 0x0a
    39aa:	8c 85       	ldd	r24, Y+12	; 0x0c
    39ac:	9d 85       	ldd	r25, Y+13	; 0x0d
    39ae:	62 2f       	mov	r22, r18
    39b0:	0e 94 3e 1e 	call	0x3c7c	; 0x3c7c <calcChecksum>
    39b4:	98 2f       	mov	r25, r24
    39b6:	89 85       	ldd	r24, Y+9	; 0x09
    39b8:	98 17       	cp	r25, r24
    39ba:	41 f0       	breq	.+16     	; 0x39cc <recievePayload+0xfe>
			sendNACK();
    39bc:	0e 94 5d 1c 	call	0x38ba	; 0x38ba <sendNACK>
			numTries++;
    39c0:	8b 81       	ldd	r24, Y+3	; 0x03
    39c2:	9c 81       	ldd	r25, Y+4	; 0x04
    39c4:	01 96       	adiw	r24, 0x01	; 1
    39c6:	9c 83       	std	Y+4, r25	; 0x04
    39c8:	8b 83       	std	Y+3, r24	; 0x03
    39ca:	05 c0       	rjmp	.+10     	; 0x39d6 <recievePayload+0x108>
		} else {
			sendACK();
    39cc:	0e 94 53 1c 	call	0x38a6	; 0x38a6 <sendACK>
			return 0;
    39d0:	80 e0       	ldi	r24, 0x00	; 0
    39d2:	90 e0       	ldi	r25, 0x00	; 0
    39d4:	0a c0       	rjmp	.+20     	; 0x39ea <recievePayload+0x11c>
	int numTries = 0;
	const int maxNumTries = 3;
	unsigned char data;
	int timeout;

	while(numTries < maxNumTries){
    39d6:	2b 81       	ldd	r18, Y+3	; 0x03
    39d8:	3c 81       	ldd	r19, Y+4	; 0x04
    39da:	8f 81       	ldd	r24, Y+7	; 0x07
    39dc:	98 85       	ldd	r25, Y+8	; 0x08
    39de:	28 17       	cp	r18, r24
    39e0:	39 07       	cpc	r19, r25
    39e2:	0c f4       	brge	.+2      	; 0x39e6 <recievePayload+0x118>
    39e4:	8b cf       	rjmp	.-234    	; 0x38fc <recievePayload+0x2e>
		} else {
			sendACK();
			return 0;
		}
	}
	return -1;
    39e6:	8f ef       	ldi	r24, 0xFF	; 255
    39e8:	9f ef       	ldi	r25, 0xFF	; 255
}
    39ea:	2d 96       	adiw	r28, 0x0d	; 13
    39ec:	0f b6       	in	r0, 0x3f	; 63
    39ee:	f8 94       	cli
    39f0:	de bf       	out	0x3e, r29	; 62
    39f2:	0f be       	out	0x3f, r0	; 63
    39f4:	cd bf       	out	0x3d, r28	; 61
    39f6:	df 91       	pop	r29
    39f8:	cf 91       	pop	r28
    39fa:	08 95       	ret

000039fc <vTaskUSARTRead>:

void vTaskUSARTRead(void *pvParameters){
    39fc:	cf 93       	push	r28
    39fe:	df 93       	push	r29
    3a00:	cd b7       	in	r28, 0x3d	; 61
    3a02:	de b7       	in	r29, 0x3e	; 62
    3a04:	cc 55       	subi	r28, 0x5C	; 92
    3a06:	d1 09       	sbc	r29, r1
    3a08:	0f b6       	in	r0, 0x3f	; 63
    3a0a:	f8 94       	cli
    3a0c:	de bf       	out	0x3e, r29	; 62
    3a0e:	0f be       	out	0x3f, r0	; 63
    3a10:	cd bf       	out	0x3d, r28	; 61
    3a12:	9e 01       	movw	r18, r28
    3a14:	25 5a       	subi	r18, 0xA5	; 165
    3a16:	3f 4f       	sbci	r19, 0xFF	; 255
    3a18:	f9 01       	movw	r30, r18
    3a1a:	91 83       	std	Z+1, r25	; 0x01
    3a1c:	80 83       	st	Z, r24
    unsigned char size;
    char groupID;
    char cmd;
    unsigned int timeout;

	DDRB = 0xFF;
    3a1e:	84 e2       	ldi	r24, 0x24	; 36
    3a20:	90 e0       	ldi	r25, 0x00	; 0
    3a22:	2f ef       	ldi	r18, 0xFF	; 255
    3a24:	fc 01       	movw	r30, r24
    3a26:	20 83       	st	Z, r18

    Command command;
    Response response;
    while(1){
        bytesRecieved = 0;
    3a28:	19 82       	std	Y+1, r1	; 0x01
        int timeout = 30;
    3a2a:	8e e1       	ldi	r24, 0x1E	; 30
    3a2c:	90 e0       	ldi	r25, 0x00	; 0
    3a2e:	9b 83       	std	Y+3, r25	; 0x03
    3a30:	8a 83       	std	Y+2, r24	; 0x02
        while(bytesRecieved < 4){
    3a32:	2d c0       	rjmp	.+90     	; 0x3a8e <vTaskUSARTRead+0x92>
            
            while ( !(UCSR0A & (1<<RXC0)) ){
    3a34:	12 c0       	rjmp	.+36     	; 0x3a5a <vTaskUSARTRead+0x5e>
                timeout--;
    3a36:	8a 81       	ldd	r24, Y+2	; 0x02
    3a38:	9b 81       	ldd	r25, Y+3	; 0x03
    3a3a:	01 97       	sbiw	r24, 0x01	; 1
    3a3c:	9b 83       	std	Y+3, r25	; 0x03
    3a3e:	8a 83       	std	Y+2, r24	; 0x02
                if(timeout == 0){
    3a40:	8a 81       	ldd	r24, Y+2	; 0x02
    3a42:	9b 81       	ldd	r25, Y+3	; 0x03
    3a44:	00 97       	sbiw	r24, 0x00	; 0
    3a46:	29 f4       	brne	.+10     	; 0x3a52 <vTaskUSARTRead+0x56>
                    bytesRecieved = 0;
    3a48:	19 82       	std	Y+1, r1	; 0x01
                    timeout = 30;
    3a4a:	8e e1       	ldi	r24, 0x1E	; 30
    3a4c:	90 e0       	ldi	r25, 0x00	; 0
    3a4e:	9b 83       	std	Y+3, r25	; 0x03
    3a50:	8a 83       	std	Y+2, r24	; 0x02
                }
                vTaskDelay(1);
    3a52:	81 e0       	ldi	r24, 0x01	; 1
    3a54:	90 e0       	ldi	r25, 0x00	; 0
    3a56:	0e 94 1d 05 	call	0xa3a	; 0xa3a <vTaskDelay>
    while(1){
        bytesRecieved = 0;
        int timeout = 30;
        while(bytesRecieved < 4){
            
            while ( !(UCSR0A & (1<<RXC0)) ){
    3a5a:	80 ec       	ldi	r24, 0xC0	; 192
    3a5c:	90 e0       	ldi	r25, 0x00	; 0
    3a5e:	fc 01       	movw	r30, r24
    3a60:	80 81       	ld	r24, Z
    3a62:	88 23       	and	r24, r24
    3a64:	44 f7       	brge	.-48     	; 0x3a36 <vTaskUSARTRead+0x3a>
                    bytesRecieved = 0;
                    timeout = 30;
                }
                vTaskDelay(1);
            }
            data = UDR0;
    3a66:	86 ec       	ldi	r24, 0xC6	; 198
    3a68:	90 e0       	ldi	r25, 0x00	; 0
    3a6a:	fc 01       	movw	r30, r24
    3a6c:	80 81       	ld	r24, Z
    3a6e:	8c 83       	std	Y+4, r24	; 0x04
            buffer[bytesRecieved] = data;
    3a70:	89 81       	ldd	r24, Y+1	; 0x01
    3a72:	99 27       	eor	r25, r25
    3a74:	87 fd       	sbrc	r24, 7
    3a76:	90 95       	com	r25
    3a78:	9e 01       	movw	r18, r28
    3a7a:	2a 5f       	subi	r18, 0xFA	; 250
    3a7c:	3f 4f       	sbci	r19, 0xFF	; 255
    3a7e:	82 0f       	add	r24, r18
    3a80:	93 1f       	adc	r25, r19
    3a82:	2c 81       	ldd	r18, Y+4	; 0x04
    3a84:	fc 01       	movw	r30, r24
    3a86:	20 83       	st	Z, r18
            bytesRecieved++;        
    3a88:	89 81       	ldd	r24, Y+1	; 0x01
    3a8a:	8f 5f       	subi	r24, 0xFF	; 255
    3a8c:	89 83       	std	Y+1, r24	; 0x01
    Command command;
    Response response;
    while(1){
        bytesRecieved = 0;
        int timeout = 30;
        while(bytesRecieved < 4){
    3a8e:	89 81       	ldd	r24, Y+1	; 0x01
    3a90:	84 30       	cpi	r24, 0x04	; 4
    3a92:	84 f2       	brlt	.-96     	; 0x3a34 <vTaskUSARTRead+0x38>
            data = UDR0;
            buffer[bytesRecieved] = data;
            bytesRecieved++;        
        }

        if(calcChecksum(buffer,3) != buffer[3]){
    3a94:	ce 01       	movw	r24, r28
    3a96:	06 96       	adiw	r24, 0x06	; 6
    3a98:	63 e0       	ldi	r22, 0x03	; 3
    3a9a:	0e 94 3e 1e 	call	0x3c7c	; 0x3c7c <calcChecksum>
    3a9e:	98 2f       	mov	r25, r24
    3aa0:	89 85       	ldd	r24, Y+9	; 0x09
    3aa2:	98 17       	cp	r25, r24
    3aa4:	21 f0       	breq	.+8      	; 0x3aae <vTaskUSARTRead+0xb2>
            sendNACK();
    3aa6:	0e 94 5d 1c 	call	0x38ba	; 0x38ba <sendNACK>
            bytesRecieved = 0;
    3aaa:	19 82       	std	Y+1, r1	; 0x01
    3aac:	29 c0       	rjmp	.+82     	; 0x3b00 <vTaskUSARTRead+0x104>
        } else {
            sendACK();
    3aae:	0e 94 53 1c 	call	0x38a6	; 0x38a6 <sendACK>
            bytesRecieved = 0;
    3ab2:	19 82       	std	Y+1, r1	; 0x01
				command.groupID = buffer[0];
    3ab4:	8e 81       	ldd	r24, Y+6	; 0x06
    3ab6:	8e 8b       	std	Y+22, r24	; 0x16
				command.cmd = buffer[1];
    3ab8:	8f 81       	ldd	r24, Y+7	; 0x07
    3aba:	8f 8b       	std	Y+23, r24	; 0x17
				size = buffer[2];
    3abc:	88 85       	ldd	r24, Y+8	; 0x08
    3abe:	8d 83       	std	Y+5, r24	; 0x05

				if(size > 0){ //No dynamic memory allocations. 16 is the size of the buffer
    3ac0:	8d 81       	ldd	r24, Y+5	; 0x05
    3ac2:	88 23       	and	r24, r24
    3ac4:	81 f0       	breq	.+32     	; 0x3ae6 <vTaskUSARTRead+0xea>
					if(recievePayload(size,command.payload) == -1){
    3ac6:	8d 81       	ldd	r24, Y+5	; 0x05
    3ac8:	88 2f       	mov	r24, r24
    3aca:	90 e0       	ldi	r25, 0x00	; 0
    3acc:	9e 01       	movw	r18, r28
    3ace:	2a 5e       	subi	r18, 0xEA	; 234
    3ad0:	3f 4f       	sbci	r19, 0xFF	; 255
    3ad2:	2d 5f       	subi	r18, 0xFD	; 253
    3ad4:	3f 4f       	sbci	r19, 0xFF	; 255
    3ad6:	b9 01       	movw	r22, r18
    3ad8:	0e 94 67 1c 	call	0x38ce	; 0x38ce <recievePayload>
    3adc:	8f 3f       	cpi	r24, 0xFF	; 255
    3ade:	ff ef       	ldi	r31, 0xFF	; 255
    3ae0:	9f 07       	cpc	r25, r31
    3ae2:	09 f4       	brne	.+2      	; 0x3ae6 <vTaskUSARTRead+0xea>
						continue;	//Restart comms
    3ae4:	0d c0       	rjmp	.+26     	; 0x3b00 <vTaskUSARTRead+0x104>
					}
				}
				
 
            processCommand(&command,&response);
    3ae6:	9e 01       	movw	r18, r28
    3ae8:	27 5c       	subi	r18, 0xC7	; 199
    3aea:	3f 4f       	sbci	r19, 0xFF	; 255
    3aec:	ce 01       	movw	r24, r28
    3aee:	46 96       	adiw	r24, 0x16	; 22
    3af0:	b9 01       	movw	r22, r18
    3af2:	0e 94 15 20 	call	0x402a	; 0x402a <processCommand>
            sendResponse(&response);
    3af6:	ce 01       	movw	r24, r28
    3af8:	c9 96       	adiw	r24, 0x39	; 57
    3afa:	0e 94 81 1d 	call	0x3b02	; 0x3b02 <sendResponse>

        }

    }
    3afe:	94 cf       	rjmp	.-216    	; 0x3a28 <vTaskUSARTRead+0x2c>
    3b00:	93 cf       	rjmp	.-218    	; 0x3a28 <vTaskUSARTRead+0x2c>

00003b02 <sendResponse>:

}

int sendResponse(Response* response){
    3b02:	cf 93       	push	r28
    3b04:	df 93       	push	r29
    3b06:	cd b7       	in	r28, 0x3d	; 61
    3b08:	de b7       	in	r29, 0x3e	; 62
    3b0a:	28 97       	sbiw	r28, 0x08	; 8
    3b0c:	0f b6       	in	r0, 0x3f	; 63
    3b0e:	f8 94       	cli
    3b10:	de bf       	out	0x3e, r29	; 62
    3b12:	0f be       	out	0x3f, r0	; 63
    3b14:	cd bf       	out	0x3d, r28	; 61
    3b16:	98 87       	std	Y+8, r25	; 0x08
    3b18:	8f 83       	std	Y+7, r24	; 0x07
    char checksumBuffer[2];
    int i;
    int timeout = 50;
    3b1a:	82 e3       	ldi	r24, 0x32	; 50
    3b1c:	90 e0       	ldi	r25, 0x00	; 0
    3b1e:	9c 83       	std	Y+4, r25	; 0x04
    3b20:	8b 83       	std	Y+3, r24	; 0x03
    while(1){
        	USART_Write(response->commandBack);
    3b22:	8f 81       	ldd	r24, Y+7	; 0x07
    3b24:	98 85       	ldd	r25, Y+8	; 0x08
    3b26:	fc 01       	movw	r30, r24
    3b28:	80 81       	ld	r24, Z
    3b2a:	0e 94 fc 1a 	call	0x35f8	; 0x35f8 <USART_Write>
			vTaskDelay(1);
    3b2e:	81 e0       	ldi	r24, 0x01	; 1
    3b30:	90 e0       	ldi	r25, 0x00	; 0
    3b32:	0e 94 1d 05 	call	0xa3a	; 0xa3a <vTaskDelay>
        	USART_Write(response->size);
    3b36:	8f 81       	ldd	r24, Y+7	; 0x07
    3b38:	98 85       	ldd	r25, Y+8	; 0x08
    3b3a:	fc 01       	movw	r30, r24
    3b3c:	81 81       	ldd	r24, Z+1	; 0x01
    3b3e:	0e 94 fc 1a 	call	0x35f8	; 0x35f8 <USART_Write>
			vTaskDelay(1);
    3b42:	81 e0       	ldi	r24, 0x01	; 1
    3b44:	90 e0       	ldi	r25, 0x00	; 0
    3b46:	0e 94 1d 05 	call	0xa3a	; 0xa3a <vTaskDelay>
        	checksumBuffer[0] = response->commandBack;
    3b4a:	8f 81       	ldd	r24, Y+7	; 0x07
    3b4c:	98 85       	ldd	r25, Y+8	; 0x08
    3b4e:	fc 01       	movw	r30, r24
    3b50:	80 81       	ld	r24, Z
    3b52:	8d 83       	std	Y+5, r24	; 0x05
        	checksumBuffer[1] = response->size;
    3b54:	8f 81       	ldd	r24, Y+7	; 0x07
    3b56:	98 85       	ldd	r25, Y+8	; 0x08
    3b58:	fc 01       	movw	r30, r24
    3b5a:	81 81       	ldd	r24, Z+1	; 0x01
    3b5c:	8e 83       	std	Y+6, r24	; 0x06
        	USART_Write(calcChecksum(checksumBuffer,2));
    3b5e:	ce 01       	movw	r24, r28
    3b60:	05 96       	adiw	r24, 0x05	; 5
    3b62:	62 e0       	ldi	r22, 0x02	; 2
    3b64:	0e 94 3e 1e 	call	0x3c7c	; 0x3c7c <calcChecksum>
    3b68:	0e 94 fc 1a 	call	0x35f8	; 0x35f8 <USART_Write>
        	switch(waitForAck()){
    3b6c:	0e 94 14 1e 	call	0x3c28	; 0x3c28 <waitForAck>
    3b70:	99 27       	eor	r25, r25
    3b72:	87 fd       	sbrc	r24, 7
    3b74:	90 95       	com	r25
    3b76:	00 97       	sbiw	r24, 0x00	; 0
    3b78:	59 f0       	breq	.+22     	; 0x3b90 <sendResponse+0x8e>
    3b7a:	81 30       	cpi	r24, 0x01	; 1
    3b7c:	91 05       	cpc	r25, r1
    3b7e:	a9 f0       	breq	.+42     	; 0x3baa <sendResponse+0xa8>
    3b80:	8f 3f       	cpi	r24, 0xFF	; 255
    3b82:	ff ef       	ldi	r31, 0xFF	; 255
    3b84:	9f 07       	cpc	r25, r31
    3b86:	09 f0       	breq	.+2      	; 0x3b8a <sendResponse+0x88>
           	timeout--;
           	if(!timeout){
              	return -1;
           	}
        	}
    }
    3b88:	cc cf       	rjmp	.-104    	; 0x3b22 <sendResponse+0x20>
        	USART_Write(calcChecksum(checksumBuffer,2));
        	switch(waitForAck()){
        	case 1:
           	goto outOfWhile;
        	case -1:
           	return -1;
    3b8a:	8f ef       	ldi	r24, 0xFF	; 255
    3b8c:	9f ef       	ldi	r25, 0xFF	; 255
    3b8e:	43 c0       	rjmp	.+134    	; 0x3c16 <sendResponse+0x114>
        	case 0:
           	timeout--;
    3b90:	8b 81       	ldd	r24, Y+3	; 0x03
    3b92:	9c 81       	ldd	r25, Y+4	; 0x04
    3b94:	01 97       	sbiw	r24, 0x01	; 1
    3b96:	9c 83       	std	Y+4, r25	; 0x04
    3b98:	8b 83       	std	Y+3, r24	; 0x03
           	if(!timeout){
    3b9a:	8b 81       	ldd	r24, Y+3	; 0x03
    3b9c:	9c 81       	ldd	r25, Y+4	; 0x04
    3b9e:	00 97       	sbiw	r24, 0x00	; 0
    3ba0:	19 f4       	brne	.+6      	; 0x3ba8 <sendResponse+0xa6>
              	return -1;
    3ba2:	8f ef       	ldi	r24, 0xFF	; 255
    3ba4:	9f ef       	ldi	r25, 0xFF	; 255
    3ba6:	37 c0       	rjmp	.+110    	; 0x3c16 <sendResponse+0x114>
           	}
        	}
    }
    3ba8:	bc cf       	rjmp	.-136    	; 0x3b22 <sendResponse+0x20>
        	checksumBuffer[0] = response->commandBack;
        	checksumBuffer[1] = response->size;
        	USART_Write(calcChecksum(checksumBuffer,2));
        	switch(waitForAck()){
        	case 1:
           	goto outOfWhile;
    3baa:	00 00       	nop
    }

    outOfWhile:


    for(i=0;i<response->size;i++){
    3bac:	1a 82       	std	Y+2, r1	; 0x02
    3bae:	19 82       	std	Y+1, r1	; 0x01
    3bb0:	14 c0       	rjmp	.+40     	; 0x3bda <sendResponse+0xd8>
        USART_Write(response->payload[i]);
    3bb2:	2f 81       	ldd	r18, Y+7	; 0x07
    3bb4:	38 85       	ldd	r19, Y+8	; 0x08
    3bb6:	89 81       	ldd	r24, Y+1	; 0x01
    3bb8:	9a 81       	ldd	r25, Y+2	; 0x02
    3bba:	82 0f       	add	r24, r18
    3bbc:	93 1f       	adc	r25, r19
    3bbe:	02 96       	adiw	r24, 0x02	; 2
    3bc0:	fc 01       	movw	r30, r24
    3bc2:	80 81       	ld	r24, Z
    3bc4:	0e 94 fc 1a 	call	0x35f8	; 0x35f8 <USART_Write>
			vTaskDelay(1);
    3bc8:	81 e0       	ldi	r24, 0x01	; 1
    3bca:	90 e0       	ldi	r25, 0x00	; 0
    3bcc:	0e 94 1d 05 	call	0xa3a	; 0xa3a <vTaskDelay>
    }

    outOfWhile:


    for(i=0;i<response->size;i++){
    3bd0:	89 81       	ldd	r24, Y+1	; 0x01
    3bd2:	9a 81       	ldd	r25, Y+2	; 0x02
    3bd4:	01 96       	adiw	r24, 0x01	; 1
    3bd6:	9a 83       	std	Y+2, r25	; 0x02
    3bd8:	89 83       	std	Y+1, r24	; 0x01
    3bda:	8f 81       	ldd	r24, Y+7	; 0x07
    3bdc:	98 85       	ldd	r25, Y+8	; 0x08
    3bde:	fc 01       	movw	r30, r24
    3be0:	81 81       	ldd	r24, Z+1	; 0x01
    3be2:	28 2f       	mov	r18, r24
    3be4:	33 27       	eor	r19, r19
    3be6:	27 fd       	sbrc	r18, 7
    3be8:	30 95       	com	r19
    3bea:	89 81       	ldd	r24, Y+1	; 0x01
    3bec:	9a 81       	ldd	r25, Y+2	; 0x02
    3bee:	82 17       	cp	r24, r18
    3bf0:	93 07       	cpc	r25, r19
    3bf2:	fc f2       	brlt	.-66     	; 0x3bb2 <sendResponse+0xb0>
        USART_Write(response->payload[i]);
			vTaskDelay(1);
		  //USART_AddToQueue(0x30 | (i + 2));
        //USART_AddToQueue()
    }
    USART_Write(calcChecksum((uint8_t*)response->payload,response->size));
    3bf4:	8f 81       	ldd	r24, Y+7	; 0x07
    3bf6:	98 85       	ldd	r25, Y+8	; 0x08
    3bf8:	fc 01       	movw	r30, r24
    3bfa:	81 81       	ldd	r24, Z+1	; 0x01
    3bfc:	28 2f       	mov	r18, r24
    3bfe:	8f 81       	ldd	r24, Y+7	; 0x07
    3c00:	98 85       	ldd	r25, Y+8	; 0x08
    3c02:	02 96       	adiw	r24, 0x02	; 2
    3c04:	62 2f       	mov	r22, r18
    3c06:	0e 94 3e 1e 	call	0x3c7c	; 0x3c7c <calcChecksum>
    3c0a:	0e 94 fc 1a 	call	0x35f8	; 0x35f8 <USART_Write>
	 

    waitForAck();
    3c0e:	0e 94 14 1e 	call	0x3c28	; 0x3c28 <waitForAck>

    return 0;
    3c12:	80 e0       	ldi	r24, 0x00	; 0
    3c14:	90 e0       	ldi	r25, 0x00	; 0

}
    3c16:	28 96       	adiw	r28, 0x08	; 8
    3c18:	0f b6       	in	r0, 0x3f	; 63
    3c1a:	f8 94       	cli
    3c1c:	de bf       	out	0x3e, r29	; 62
    3c1e:	0f be       	out	0x3f, r0	; 63
    3c20:	cd bf       	out	0x3d, r28	; 61
    3c22:	df 91       	pop	r29
    3c24:	cf 91       	pop	r28
    3c26:	08 95       	ret

00003c28 <waitForAck>:

char waitForAck(){
    3c28:	cf 93       	push	r28
    3c2a:	df 93       	push	r29
    3c2c:	1f 92       	push	r1
    3c2e:	1f 92       	push	r1
    3c30:	cd b7       	in	r28, 0x3d	; 61
    3c32:	de b7       	in	r29, 0x3e	; 62
    int timeout = 5000;
    3c34:	88 e8       	ldi	r24, 0x88	; 136
    3c36:	93 e1       	ldi	r25, 0x13	; 19
    3c38:	9a 83       	std	Y+2, r25	; 0x02
    3c3a:	89 83       	std	Y+1, r24	; 0x01
    while ( !(UCSR2A & (1<<RXC2)) ){
    3c3c:	0b c0       	rjmp	.+22     	; 0x3c54 <waitForAck+0x2c>
        timeout--;
    3c3e:	89 81       	ldd	r24, Y+1	; 0x01
    3c40:	9a 81       	ldd	r25, Y+2	; 0x02
    3c42:	01 97       	sbiw	r24, 0x01	; 1
    3c44:	9a 83       	std	Y+2, r25	; 0x02
    3c46:	89 83       	std	Y+1, r24	; 0x01
        if(!timeout){
    3c48:	89 81       	ldd	r24, Y+1	; 0x01
    3c4a:	9a 81       	ldd	r25, Y+2	; 0x02
    3c4c:	00 97       	sbiw	r24, 0x00	; 0
    3c4e:	11 f4       	brne	.+4      	; 0x3c54 <waitForAck+0x2c>
            return -1;
    3c50:	8f ef       	ldi	r24, 0xFF	; 255
    3c52:	0f c0       	rjmp	.+30     	; 0x3c72 <waitForAck+0x4a>

}

char waitForAck(){
    int timeout = 5000;
    while ( !(UCSR2A & (1<<RXC2)) ){
    3c54:	80 ed       	ldi	r24, 0xD0	; 208
    3c56:	90 e0       	ldi	r25, 0x00	; 0
    3c58:	fc 01       	movw	r30, r24
    3c5a:	80 81       	ld	r24, Z
    3c5c:	88 23       	and	r24, r24
    3c5e:	7c f7       	brge	.-34     	; 0x3c3e <waitForAck+0x16>
        timeout--;
        if(!timeout){
            return -1;
        }
    }
    if(UDR2 == ACK_BYTE){
    3c60:	86 ed       	ldi	r24, 0xD6	; 214
    3c62:	90 e0       	ldi	r25, 0x00	; 0
    3c64:	fc 01       	movw	r30, r24
    3c66:	80 81       	ld	r24, Z
    3c68:	80 38       	cpi	r24, 0x80	; 128
    3c6a:	11 f4       	brne	.+4      	; 0x3c70 <waitForAck+0x48>
        return 1;
    3c6c:	81 e0       	ldi	r24, 0x01	; 1
    3c6e:	01 c0       	rjmp	.+2      	; 0x3c72 <waitForAck+0x4a>
    } else {
        return 0;
    3c70:	80 e0       	ldi	r24, 0x00	; 0
    }
}
    3c72:	0f 90       	pop	r0
    3c74:	0f 90       	pop	r0
    3c76:	df 91       	pop	r29
    3c78:	cf 91       	pop	r28
    3c7a:	08 95       	ret

00003c7c <calcChecksum>:

uint8_t calcChecksum(uint8_t* buffer,uint8_t size){
    3c7c:	cf 93       	push	r28
    3c7e:	df 93       	push	r29
    3c80:	00 d0       	rcall	.+0      	; 0x3c82 <calcChecksum+0x6>
    3c82:	00 d0       	rcall	.+0      	; 0x3c84 <calcChecksum+0x8>
    3c84:	cd b7       	in	r28, 0x3d	; 61
    3c86:	de b7       	in	r29, 0x3e	; 62
    3c88:	9d 83       	std	Y+5, r25	; 0x05
    3c8a:	8c 83       	std	Y+4, r24	; 0x04
    3c8c:	6e 83       	std	Y+6, r22	; 0x06
    uint8_t checksum = 0;
    3c8e:	19 82       	std	Y+1, r1	; 0x01
    for(int i = 0; i < size; i++) {
    3c90:	1b 82       	std	Y+3, r1	; 0x03
    3c92:	1a 82       	std	Y+2, r1	; 0x02
    3c94:	11 c0       	rjmp	.+34     	; 0x3cb8 <calcChecksum+0x3c>
        checksum += *(buffer++);
    3c96:	8c 81       	ldd	r24, Y+4	; 0x04
    3c98:	9d 81       	ldd	r25, Y+5	; 0x05
    3c9a:	9c 01       	movw	r18, r24
    3c9c:	2f 5f       	subi	r18, 0xFF	; 255
    3c9e:	3f 4f       	sbci	r19, 0xFF	; 255
    3ca0:	3d 83       	std	Y+5, r19	; 0x05
    3ca2:	2c 83       	std	Y+4, r18	; 0x04
    3ca4:	fc 01       	movw	r30, r24
    3ca6:	80 81       	ld	r24, Z
    3ca8:	99 81       	ldd	r25, Y+1	; 0x01
    3caa:	89 0f       	add	r24, r25
    3cac:	89 83       	std	Y+1, r24	; 0x01
    }
}

uint8_t calcChecksum(uint8_t* buffer,uint8_t size){
    uint8_t checksum = 0;
    for(int i = 0; i < size; i++) {
    3cae:	8a 81       	ldd	r24, Y+2	; 0x02
    3cb0:	9b 81       	ldd	r25, Y+3	; 0x03
    3cb2:	01 96       	adiw	r24, 0x01	; 1
    3cb4:	9b 83       	std	Y+3, r25	; 0x03
    3cb6:	8a 83       	std	Y+2, r24	; 0x02
    3cb8:	8e 81       	ldd	r24, Y+6	; 0x06
    3cba:	28 2f       	mov	r18, r24
    3cbc:	30 e0       	ldi	r19, 0x00	; 0
    3cbe:	8a 81       	ldd	r24, Y+2	; 0x02
    3cc0:	9b 81       	ldd	r25, Y+3	; 0x03
    3cc2:	82 17       	cp	r24, r18
    3cc4:	93 07       	cpc	r25, r19
    3cc6:	3c f3       	brlt	.-50     	; 0x3c96 <calcChecksum+0x1a>
        checksum += *(buffer++);
    }
    return checksum;
    3cc8:	89 81       	ldd	r24, Y+1	; 0x01
}
    3cca:	26 96       	adiw	r28, 0x06	; 6
    3ccc:	0f b6       	in	r0, 0x3f	; 63
    3cce:	f8 94       	cli
    3cd0:	de bf       	out	0x3e, r29	; 62
    3cd2:	0f be       	out	0x3f, r0	; 63
    3cd4:	cd bf       	out	0x3d, r28	; 61
    3cd6:	df 91       	pop	r29
    3cd8:	cf 91       	pop	r28
    3cda:	08 95       	ret

00003cdc <commandIntegCheck>:
#include "protocol.h"
#include "Components/Sonar/Sonar.h"


//function to CRC the command structure
char commandIntegCheck(Command *command) {
    3cdc:	cf 93       	push	r28
    3cde:	df 93       	push	r29
    3ce0:	1f 92       	push	r1
    3ce2:	1f 92       	push	r1
    3ce4:	cd b7       	in	r28, 0x3d	; 61
    3ce6:	de b7       	in	r29, 0x3e	; 62
    3ce8:	9a 83       	std	Y+2, r25	; 0x02
    3cea:	89 83       	std	Y+1, r24	; 0x01
   //CRC the command with 0x00 in place of the CRC
   //return success for now
   return 1;
    3cec:	81 e0       	ldi	r24, 0x01	; 1
}
    3cee:	0f 90       	pop	r0
    3cf0:	0f 90       	pop	r0
    3cf2:	df 91       	pop	r29
    3cf4:	cf 91       	pop	r28
    3cf6:	08 95       	ret

00003cf8 <processUltrasonicCommand>:

char processUltrasonicCommand(char commandCode, void* commandData,char* size, void* responseData) {
    3cf8:	cf 93       	push	r28
    3cfa:	df 93       	push	r29
    3cfc:	cd b7       	in	r28, 0x3d	; 61
    3cfe:	de b7       	in	r29, 0x3e	; 62
    3d00:	27 97       	sbiw	r28, 0x07	; 7
    3d02:	0f b6       	in	r0, 0x3f	; 63
    3d04:	f8 94       	cli
    3d06:	de bf       	out	0x3e, r29	; 62
    3d08:	0f be       	out	0x3f, r0	; 63
    3d0a:	cd bf       	out	0x3d, r28	; 61
    3d0c:	89 83       	std	Y+1, r24	; 0x01
    3d0e:	7b 83       	std	Y+3, r23	; 0x03
    3d10:	6a 83       	std	Y+2, r22	; 0x02
    3d12:	5d 83       	std	Y+5, r21	; 0x05
    3d14:	4c 83       	std	Y+4, r20	; 0x04
    3d16:	3f 83       	std	Y+7, r19	; 0x07
    3d18:	2e 83       	std	Y+6, r18	; 0x06
   switch(commandCode) {
    3d1a:	89 81       	ldd	r24, Y+1	; 0x01
    3d1c:	99 27       	eor	r25, r25
    3d1e:	87 fd       	sbrc	r24, 7
    3d20:	90 95       	com	r25
    3d22:	82 30       	cpi	r24, 0x02	; 2
    3d24:	91 05       	cpc	r25, r1
    3d26:	81 f0       	breq	.+32     	; 0x3d48 <processUltrasonicCommand+0x50>
    3d28:	83 30       	cpi	r24, 0x03	; 3
    3d2a:	91 05       	cpc	r25, r1
    3d2c:	c1 f0       	breq	.+48     	; 0x3d5e <processUltrasonicCommand+0x66>
    3d2e:	81 30       	cpi	r24, 0x01	; 1
    3d30:	91 05       	cpc	r25, r1
    3d32:	01 f5       	brne	.+64     	; 0x3d74 <processUltrasonicCommand+0x7c>
      case GET_ALL_SENSORS:
         getAllSensors((int*) responseData);
    3d34:	8e 81       	ldd	r24, Y+6	; 0x06
    3d36:	9f 81       	ldd	r25, Y+7	; 0x07
    3d38:	0e 94 9b 22 	call	0x4536	; 0x4536 <getAllSensors>
         *size = 12;
    3d3c:	8c 81       	ldd	r24, Y+4	; 0x04
    3d3e:	9d 81       	ldd	r25, Y+5	; 0x05
    3d40:	2c e0       	ldi	r18, 0x0C	; 12
    3d42:	fc 01       	movw	r30, r24
    3d44:	20 83       	st	Z, r18
         break;
    3d46:	16 c0       	rjmp	.+44     	; 0x3d74 <processUltrasonicCommand+0x7c>
      case GET_CERTAIN_SENSORS:
         getCertainSensor(((char*)commandData)[0], (int*) responseData);
    3d48:	8a 81       	ldd	r24, Y+2	; 0x02
    3d4a:	9b 81       	ldd	r25, Y+3	; 0x03
    3d4c:	fc 01       	movw	r30, r24
    3d4e:	20 81       	ld	r18, Z
    3d50:	8e 81       	ldd	r24, Y+6	; 0x06
    3d52:	9f 81       	ldd	r25, Y+7	; 0x07
    3d54:	bc 01       	movw	r22, r24
    3d56:	82 2f       	mov	r24, r18
    3d58:	0e 94 c6 22 	call	0x458c	; 0x458c <getCertainSensor>
         break;
    3d5c:	0b c0       	rjmp	.+22     	; 0x3d74 <processUltrasonicCommand+0x7c>
      case GET_SENSOR_GROUP:
         getSensorGroup(((char*)commandData)[0], (int*) responseData);
    3d5e:	8a 81       	ldd	r24, Y+2	; 0x02
    3d60:	9b 81       	ldd	r25, Y+3	; 0x03
    3d62:	fc 01       	movw	r30, r24
    3d64:	20 81       	ld	r18, Z
    3d66:	8e 81       	ldd	r24, Y+6	; 0x06
    3d68:	9f 81       	ldd	r25, Y+7	; 0x07
    3d6a:	bc 01       	movw	r22, r24
    3d6c:	82 2f       	mov	r24, r18
    3d6e:	0e 94 ef 22 	call	0x45de	; 0x45de <getSensorGroup>
         break;
    3d72:	00 00       	nop
   }
   //return success for now...
   return 1;
    3d74:	81 e0       	ldi	r24, 0x01	; 1
}
    3d76:	27 96       	adiw	r28, 0x07	; 7
    3d78:	0f b6       	in	r0, 0x3f	; 63
    3d7a:	f8 94       	cli
    3d7c:	de bf       	out	0x3e, r29	; 62
    3d7e:	0f be       	out	0x3f, r0	; 63
    3d80:	cd bf       	out	0x3d, r28	; 61
    3d82:	df 91       	pop	r29
    3d84:	cf 91       	pop	r28
    3d86:	08 95       	ret

00003d88 <processSpeedCommand>:

char processSpeedCommand(char commandCode, void* commandData, Response* responseData) {
    3d88:	cf 93       	push	r28
    3d8a:	df 93       	push	r29
    3d8c:	00 d0       	rcall	.+0      	; 0x3d8e <processSpeedCommand+0x6>
    3d8e:	1f 92       	push	r1
    3d90:	1f 92       	push	r1
    3d92:	cd b7       	in	r28, 0x3d	; 61
    3d94:	de b7       	in	r29, 0x3e	; 62
    3d96:	89 83       	std	Y+1, r24	; 0x01
    3d98:	7b 83       	std	Y+3, r23	; 0x03
    3d9a:	6a 83       	std	Y+2, r22	; 0x02
    3d9c:	5d 83       	std	Y+5, r21	; 0x05
    3d9e:	4c 83       	std	Y+4, r20	; 0x04
   switch(commandCode) {
    3da0:	89 81       	ldd	r24, Y+1	; 0x01
    3da2:	99 27       	eor	r25, r25
    3da4:	87 fd       	sbrc	r24, 7
    3da6:	90 95       	com	r25
    3da8:	00 97       	sbiw	r24, 0x00	; 0
    3daa:	21 f0       	breq	.+8      	; 0x3db4 <processSpeedCommand+0x2c>
    3dac:	81 30       	cpi	r24, 0x01	; 1
    3dae:	91 05       	cpc	r25, r1
    3db0:	31 f0       	breq	.+12     	; 0x3dbe <processSpeedCommand+0x36>
    3db2:	13 c0       	rjmp	.+38     	; 0x3dda <processSpeedCommand+0x52>
      case GET_SPEED:
         getSpeed((char*) responseData);
    3db4:	8c 81       	ldd	r24, Y+4	; 0x04
    3db6:	9d 81       	ldd	r25, Y+5	; 0x05
    3db8:	0e 94 8e 23 	call	0x471c	; 0x471c <getSpeed>
         break;
    3dbc:	0e c0       	rjmp	.+28     	; 0x3dda <processSpeedCommand+0x52>
      case SET_SPEED:
			responseData->size = 0;
    3dbe:	8c 81       	ldd	r24, Y+4	; 0x04
    3dc0:	9d 81       	ldd	r25, Y+5	; 0x05
    3dc2:	fc 01       	movw	r30, r24
    3dc4:	11 82       	std	Z+1, r1	; 0x01
         setSpeed(((char*)commandData)[0]);
    3dc6:	8a 81       	ldd	r24, Y+2	; 0x02
    3dc8:	9b 81       	ldd	r25, Y+3	; 0x03
    3dca:	fc 01       	movw	r30, r24
    3dcc:	80 81       	ld	r24, Z
    3dce:	99 27       	eor	r25, r25
    3dd0:	87 fd       	sbrc	r24, 7
    3dd2:	90 95       	com	r25
    3dd4:	0e 94 a0 23 	call	0x4740	; 0x4740 <setSpeed>
         break;
    3dd8:	00 00       	nop
   }
   //return success for now
   return 1;
    3dda:	81 e0       	ldi	r24, 0x01	; 1
}
    3ddc:	0f 90       	pop	r0
    3dde:	0f 90       	pop	r0
    3de0:	0f 90       	pop	r0
    3de2:	0f 90       	pop	r0
    3de4:	0f 90       	pop	r0
    3de6:	df 91       	pop	r29
    3de8:	cf 91       	pop	r28
    3dea:	08 95       	ret

00003dec <processSteeringCommand>:

char processSteeringCommand(char commandCode, void* commandData, void* responseData) {
    3dec:	cf 93       	push	r28
    3dee:	df 93       	push	r29
    3df0:	00 d0       	rcall	.+0      	; 0x3df2 <processSteeringCommand+0x6>
    3df2:	1f 92       	push	r1
    3df4:	1f 92       	push	r1
    3df6:	cd b7       	in	r28, 0x3d	; 61
    3df8:	de b7       	in	r29, 0x3e	; 62
    3dfa:	89 83       	std	Y+1, r24	; 0x01
    3dfc:	7b 83       	std	Y+3, r23	; 0x03
    3dfe:	6a 83       	std	Y+2, r22	; 0x02
    3e00:	5d 83       	std	Y+5, r21	; 0x05
    3e02:	4c 83       	std	Y+4, r20	; 0x04
   switch(commandCode) {
    3e04:	89 81       	ldd	r24, Y+1	; 0x01
    3e06:	99 27       	eor	r25, r25
    3e08:	87 fd       	sbrc	r24, 7
    3e0a:	90 95       	com	r25
    3e0c:	82 30       	cpi	r24, 0x02	; 2
    3e0e:	91 05       	cpc	r25, r1
    3e10:	f9 f0       	breq	.+62     	; 0x3e50 <processSteeringCommand+0x64>
    3e12:	83 30       	cpi	r24, 0x03	; 3
    3e14:	91 05       	cpc	r25, r1
    3e16:	34 f4       	brge	.+12     	; 0x3e24 <processSteeringCommand+0x38>
    3e18:	00 97       	sbiw	r24, 0x00	; 0
    3e1a:	59 f0       	breq	.+22     	; 0x3e32 <processSteeringCommand+0x46>
    3e1c:	81 30       	cpi	r24, 0x01	; 1
    3e1e:	91 05       	cpc	r25, r1
    3e20:	91 f0       	breq	.+36     	; 0x3e46 <processSteeringCommand+0x5a>
    3e22:	4c c0       	rjmp	.+152    	; 0x3ebc <processSteeringCommand+0xd0>
    3e24:	83 30       	cpi	r24, 0x03	; 3
    3e26:	91 05       	cpc	r25, r1
    3e28:	c1 f0       	breq	.+48     	; 0x3e5a <processSteeringCommand+0x6e>
    3e2a:	84 30       	cpi	r24, 0x04	; 4
    3e2c:	91 05       	cpc	r25, r1
    3e2e:	91 f1       	breq	.+100    	; 0x3e94 <processSteeringCommand+0xa8>
    3e30:	45 c0       	rjmp	.+138    	; 0x3ebc <processSteeringCommand+0xd0>
      case SET_ANGLE:
         setAngle(*((char*)commandData));
    3e32:	8a 81       	ldd	r24, Y+2	; 0x02
    3e34:	9b 81       	ldd	r25, Y+3	; 0x03
    3e36:	fc 01       	movw	r30, r24
    3e38:	80 81       	ld	r24, Z
    3e3a:	99 27       	eor	r25, r25
    3e3c:	87 fd       	sbrc	r24, 7
    3e3e:	90 95       	com	r25
    3e40:	0e 94 db 24 	call	0x49b6	; 0x49b6 <setAngle>
         break;
    3e44:	3b c0       	rjmp	.+118    	; 0x3ebc <processSteeringCommand+0xd0>
      case GET_ANGLE:
         getAngle((char*) responseData);
    3e46:	8c 81       	ldd	r24, Y+4	; 0x04
    3e48:	9d 81       	ldd	r25, Y+5	; 0x05
    3e4a:	0e 94 ee 24 	call	0x49dc	; 0x49dc <getAngle>
         break;
    3e4e:	36 c0       	rjmp	.+108    	; 0x3ebc <processSteeringCommand+0xd0>
      case GET_DESIRED_ANGLE:
         getDesiredAngle((char*) responseData);
    3e50:	8c 81       	ldd	r24, Y+4	; 0x04
    3e52:	9d 81       	ldd	r25, Y+5	; 0x05
    3e54:	0e 94 00 25 	call	0x4a00	; 0x4a00 <getDesiredAngle>
         break;
    3e58:	31 c0       	rjmp	.+98     	; 0x3ebc <processSteeringCommand+0xd0>
      case CHANGE_PID:
         changePID(((char*)commandData)[0], ((char*)commandData)[1], ((char*)commandData)[2]);
    3e5a:	8a 81       	ldd	r24, Y+2	; 0x02
    3e5c:	9b 81       	ldd	r25, Y+3	; 0x03
    3e5e:	02 96       	adiw	r24, 0x02	; 2
    3e60:	fc 01       	movw	r30, r24
    3e62:	80 81       	ld	r24, Z
    3e64:	48 2f       	mov	r20, r24
    3e66:	55 27       	eor	r21, r21
    3e68:	47 fd       	sbrc	r20, 7
    3e6a:	50 95       	com	r21
    3e6c:	8a 81       	ldd	r24, Y+2	; 0x02
    3e6e:	9b 81       	ldd	r25, Y+3	; 0x03
    3e70:	01 96       	adiw	r24, 0x01	; 1
    3e72:	fc 01       	movw	r30, r24
    3e74:	80 81       	ld	r24, Z
    3e76:	28 2f       	mov	r18, r24
    3e78:	33 27       	eor	r19, r19
    3e7a:	27 fd       	sbrc	r18, 7
    3e7c:	30 95       	com	r19
    3e7e:	8a 81       	ldd	r24, Y+2	; 0x02
    3e80:	9b 81       	ldd	r25, Y+3	; 0x03
    3e82:	fc 01       	movw	r30, r24
    3e84:	80 81       	ld	r24, Z
    3e86:	99 27       	eor	r25, r25
    3e88:	87 fd       	sbrc	r24, 7
    3e8a:	90 95       	com	r25
    3e8c:	b9 01       	movw	r22, r18
    3e8e:	0e 94 12 25 	call	0x4a24	; 0x4a24 <changePID>
         break;
    3e92:	14 c0       	rjmp	.+40     	; 0x3ebc <processSteeringCommand+0xd0>
      case SET_LIMITS:
         setLimits(((char*)commandData)[0], ((char*)commandData)[1]);
    3e94:	8a 81       	ldd	r24, Y+2	; 0x02
    3e96:	9b 81       	ldd	r25, Y+3	; 0x03
    3e98:	01 96       	adiw	r24, 0x01	; 1
    3e9a:	fc 01       	movw	r30, r24
    3e9c:	80 81       	ld	r24, Z
    3e9e:	28 2f       	mov	r18, r24
    3ea0:	33 27       	eor	r19, r19
    3ea2:	27 fd       	sbrc	r18, 7
    3ea4:	30 95       	com	r19
    3ea6:	8a 81       	ldd	r24, Y+2	; 0x02
    3ea8:	9b 81       	ldd	r25, Y+3	; 0x03
    3eaa:	fc 01       	movw	r30, r24
    3eac:	80 81       	ld	r24, Z
    3eae:	99 27       	eor	r25, r25
    3eb0:	87 fd       	sbrc	r24, 7
    3eb2:	90 95       	com	r25
    3eb4:	b9 01       	movw	r22, r18
    3eb6:	0e 94 21 25 	call	0x4a42	; 0x4a42 <setLimits>
         break;
    3eba:	00 00       	nop
   }
   //return success for now
   return 1;
    3ebc:	81 e0       	ldi	r24, 0x01	; 1
}
    3ebe:	0f 90       	pop	r0
    3ec0:	0f 90       	pop	r0
    3ec2:	0f 90       	pop	r0
    3ec4:	0f 90       	pop	r0
    3ec6:	0f 90       	pop	r0
    3ec8:	df 91       	pop	r29
    3eca:	cf 91       	pop	r28
    3ecc:	08 95       	ret

00003ece <processFNRCommand>:

char processFNRCommand(char commandCode, void* commandData, Response* responseData) {
    3ece:	cf 93       	push	r28
    3ed0:	df 93       	push	r29
    3ed2:	00 d0       	rcall	.+0      	; 0x3ed4 <processFNRCommand+0x6>
    3ed4:	1f 92       	push	r1
    3ed6:	1f 92       	push	r1
    3ed8:	cd b7       	in	r28, 0x3d	; 61
    3eda:	de b7       	in	r29, 0x3e	; 62
    3edc:	89 83       	std	Y+1, r24	; 0x01
    3ede:	7b 83       	std	Y+3, r23	; 0x03
    3ee0:	6a 83       	std	Y+2, r22	; 0x02
    3ee2:	5d 83       	std	Y+5, r21	; 0x05
    3ee4:	4c 83       	std	Y+4, r20	; 0x04
	responseData->size = 0;	
    3ee6:	8c 81       	ldd	r24, Y+4	; 0x04
    3ee8:	9d 81       	ldd	r25, Y+5	; 0x05
    3eea:	fc 01       	movw	r30, r24
    3eec:	11 82       	std	Z+1, r1	; 0x01
   switch(commandCode) {
    3eee:	89 81       	ldd	r24, Y+1	; 0x01
    3ef0:	99 27       	eor	r25, r25
    3ef2:	87 fd       	sbrc	r24, 7
    3ef4:	90 95       	com	r25
    3ef6:	00 97       	sbiw	r24, 0x00	; 0
    3ef8:	21 f0       	breq	.+8      	; 0x3f02 <processFNRCommand+0x34>
    3efa:	81 30       	cpi	r24, 0x01	; 1
    3efc:	91 05       	cpc	r25, r1
    3efe:	59 f0       	breq	.+22     	; 0x3f16 <processFNRCommand+0x48>
    3f00:	0f c0       	rjmp	.+30     	; 0x3f20 <processFNRCommand+0x52>
      case SET_FNR:
         setFNR(*((char*)commandData));
    3f02:	8a 81       	ldd	r24, Y+2	; 0x02
    3f04:	9b 81       	ldd	r25, Y+3	; 0x03
    3f06:	fc 01       	movw	r30, r24
    3f08:	80 81       	ld	r24, Z
    3f0a:	99 27       	eor	r25, r25
    3f0c:	87 fd       	sbrc	r24, 7
    3f0e:	90 95       	com	r25
    3f10:	0e 94 6f 21 	call	0x42de	; 0x42de <setFNR>
         break;
    3f14:	05 c0       	rjmp	.+10     	; 0x3f20 <processFNRCommand+0x52>
      case GET_FNR:
         getFNR((char*) responseData);
    3f16:	8c 81       	ldd	r24, Y+4	; 0x04
    3f18:	9d 81       	ldd	r25, Y+5	; 0x05
    3f1a:	0e 94 8b 21 	call	0x4316	; 0x4316 <getFNR>
         break;
    3f1e:	00 00       	nop
   }
}
    3f20:	0f 90       	pop	r0
    3f22:	0f 90       	pop	r0
    3f24:	0f 90       	pop	r0
    3f26:	0f 90       	pop	r0
    3f28:	0f 90       	pop	r0
    3f2a:	df 91       	pop	r29
    3f2c:	cf 91       	pop	r28
    3f2e:	08 95       	ret

00003f30 <processBrakeCommand>:

char processBrakeCommand(char commandCode, void* commandData, void* responseData) {
    3f30:	cf 93       	push	r28
    3f32:	df 93       	push	r29
    3f34:	00 d0       	rcall	.+0      	; 0x3f36 <processBrakeCommand+0x6>
    3f36:	1f 92       	push	r1
    3f38:	1f 92       	push	r1
    3f3a:	cd b7       	in	r28, 0x3d	; 61
    3f3c:	de b7       	in	r29, 0x3e	; 62
    3f3e:	89 83       	std	Y+1, r24	; 0x01
    3f40:	7b 83       	std	Y+3, r23	; 0x03
    3f42:	6a 83       	std	Y+2, r22	; 0x02
    3f44:	5d 83       	std	Y+5, r21	; 0x05
    3f46:	4c 83       	std	Y+4, r20	; 0x04
   switch(commandCode) {
    3f48:	89 81       	ldd	r24, Y+1	; 0x01
    3f4a:	99 27       	eor	r25, r25
    3f4c:	87 fd       	sbrc	r24, 7
    3f4e:	90 95       	com	r25
    3f50:	00 97       	sbiw	r24, 0x00	; 0
    3f52:	21 f0       	breq	.+8      	; 0x3f5c <processBrakeCommand+0x2c>
    3f54:	81 30       	cpi	r24, 0x01	; 1
    3f56:	91 05       	cpc	r25, r1
    3f58:	59 f0       	breq	.+22     	; 0x3f70 <processBrakeCommand+0x40>
    3f5a:	0f c0       	rjmp	.+30     	; 0x3f7a <processBrakeCommand+0x4a>
      case SET_BRAKE:
	 setBrake(*((char*)commandData));
    3f5c:	8a 81       	ldd	r24, Y+2	; 0x02
    3f5e:	9b 81       	ldd	r25, Y+3	; 0x03
    3f60:	fc 01       	movw	r30, r24
    3f62:	80 81       	ld	r24, Z
    3f64:	99 27       	eor	r25, r25
    3f66:	87 fd       	sbrc	r24, 7
    3f68:	90 95       	com	r25
    3f6a:	0e 94 b6 20 	call	0x416c	; 0x416c <setBrake>
	 break;
    3f6e:	05 c0       	rjmp	.+10     	; 0x3f7a <processBrakeCommand+0x4a>
      case GET_BRAKE:
	 getBrake((char*) responseData);
    3f70:	8c 81       	ldd	r24, Y+4	; 0x04
    3f72:	9d 81       	ldd	r25, Y+5	; 0x05
    3f74:	0e 94 c1 20 	call	0x4182	; 0x4182 <getBrake>
	 break; 
    3f78:	00 00       	nop
   }
}
    3f7a:	0f 90       	pop	r0
    3f7c:	0f 90       	pop	r0
    3f7e:	0f 90       	pop	r0
    3f80:	0f 90       	pop	r0
    3f82:	0f 90       	pop	r0
    3f84:	df 91       	pop	r29
    3f86:	cf 91       	pop	r28
    3f88:	08 95       	ret

00003f8a <processBatteryCommand>:

char processBatteryCommand(char commandCode, void* commandData, void* responseData) {
    3f8a:	cf 93       	push	r28
    3f8c:	df 93       	push	r29
    3f8e:	00 d0       	rcall	.+0      	; 0x3f90 <processBatteryCommand+0x6>
    3f90:	1f 92       	push	r1
    3f92:	1f 92       	push	r1
    3f94:	cd b7       	in	r28, 0x3d	; 61
    3f96:	de b7       	in	r29, 0x3e	; 62
    3f98:	89 83       	std	Y+1, r24	; 0x01
    3f9a:	7b 83       	std	Y+3, r23	; 0x03
    3f9c:	6a 83       	std	Y+2, r22	; 0x02
    3f9e:	5d 83       	std	Y+5, r21	; 0x05
    3fa0:	4c 83       	std	Y+4, r20	; 0x04
   switch(commandCode) {
    3fa2:	89 81       	ldd	r24, Y+1	; 0x01
    3fa4:	99 27       	eor	r25, r25
    3fa6:	87 fd       	sbrc	r24, 7
    3fa8:	90 95       	com	r25
    3faa:	00 97       	sbiw	r24, 0x00	; 0
    3fac:	21 f0       	breq	.+8      	; 0x3fb6 <processBatteryCommand+0x2c>
    3fae:	81 30       	cpi	r24, 0x01	; 1
    3fb0:	91 05       	cpc	r25, r1
    3fb2:	31 f0       	breq	.+12     	; 0x3fc0 <processBatteryCommand+0x36>
    3fb4:	0a c0       	rjmp	.+20     	; 0x3fca <processBatteryCommand+0x40>
      case GET_BATTERY_VOLTAGE:
         getBatteryVoltage((char*) responseData);
    3fb6:	8c 81       	ldd	r24, Y+4	; 0x04
    3fb8:	9d 81       	ldd	r25, Y+5	; 0x05
    3fba:	0e 94 92 20 	call	0x4124	; 0x4124 <getBatteryVoltage>
         break;
    3fbe:	05 c0       	rjmp	.+10     	; 0x3fca <processBatteryCommand+0x40>
      case GET_STEERING_VOLTAGE:
         getSteeringVoltage((char*) responseData);
    3fc0:	8c 81       	ldd	r24, Y+4	; 0x04
    3fc2:	9d 81       	ldd	r25, Y+5	; 0x05
    3fc4:	0e 94 a4 20 	call	0x4148	; 0x4148 <getSteeringVoltage>
         break;
    3fc8:	00 00       	nop
   }
}
    3fca:	0f 90       	pop	r0
    3fcc:	0f 90       	pop	r0
    3fce:	0f 90       	pop	r0
    3fd0:	0f 90       	pop	r0
    3fd2:	0f 90       	pop	r0
    3fd4:	df 91       	pop	r29
    3fd6:	cf 91       	pop	r28
    3fd8:	08 95       	ret

00003fda <processLightCommand>:

char processLightCommand(char commandCode, void* commandData, Response* responseData) {
    3fda:	cf 93       	push	r28
    3fdc:	df 93       	push	r29
    3fde:	00 d0       	rcall	.+0      	; 0x3fe0 <processLightCommand+0x6>
    3fe0:	1f 92       	push	r1
    3fe2:	1f 92       	push	r1
    3fe4:	cd b7       	in	r28, 0x3d	; 61
    3fe6:	de b7       	in	r29, 0x3e	; 62
    3fe8:	89 83       	std	Y+1, r24	; 0x01
    3fea:	7b 83       	std	Y+3, r23	; 0x03
    3fec:	6a 83       	std	Y+2, r22	; 0x02
    3fee:	5d 83       	std	Y+5, r21	; 0x05
    3ff0:	4c 83       	std	Y+4, r20	; 0x04
	responseData->size = 0;
    3ff2:	8c 81       	ldd	r24, Y+4	; 0x04
    3ff4:	9d 81       	ldd	r25, Y+5	; 0x05
    3ff6:	fc 01       	movw	r30, r24
    3ff8:	11 82       	std	Z+1, r1	; 0x01
   switch(commandCode) {
    3ffa:	89 81       	ldd	r24, Y+1	; 0x01
    3ffc:	99 27       	eor	r25, r25
    3ffe:	87 fd       	sbrc	r24, 7
    4000:	90 95       	com	r25
    4002:	00 97       	sbiw	r24, 0x00	; 0
    4004:	51 f4       	brne	.+20     	; 0x401a <processLightCommand+0x40>
   case SET_LIGHT:
	 	setLight(*((char*)commandData));
    4006:	8a 81       	ldd	r24, Y+2	; 0x02
    4008:	9b 81       	ldd	r25, Y+3	; 0x03
    400a:	fc 01       	movw	r30, r24
    400c:	80 81       	ld	r24, Z
    400e:	99 27       	eor	r25, r25
    4010:	87 fd       	sbrc	r24, 7
    4012:	90 95       	com	r25
    4014:	0e 94 9d 21 	call	0x433a	; 0x433a <setLight>
      break;
    4018:	00 00       	nop
   }
}
    401a:	0f 90       	pop	r0
    401c:	0f 90       	pop	r0
    401e:	0f 90       	pop	r0
    4020:	0f 90       	pop	r0
    4022:	0f 90       	pop	r0
    4024:	df 91       	pop	r29
    4026:	cf 91       	pop	r28
    4028:	08 95       	ret

0000402a <processCommand>:



//Function that will take in a command (as char array) and process it into a
//correct response to be stored into response
char processCommand(Command *command, Response *response) {
    402a:	cf 93       	push	r28
    402c:	df 93       	push	r29
    402e:	00 d0       	rcall	.+0      	; 0x4030 <processCommand+0x6>
    4030:	1f 92       	push	r1
    4032:	cd b7       	in	r28, 0x3d	; 61
    4034:	de b7       	in	r29, 0x3e	; 62
    4036:	9a 83       	std	Y+2, r25	; 0x02
    4038:	89 83       	std	Y+1, r24	; 0x01
    403a:	7c 83       	std	Y+4, r23	; 0x04
    403c:	6b 83       	std	Y+3, r22	; 0x03
	response->commandBack = command->cmd;
    403e:	89 81       	ldd	r24, Y+1	; 0x01
    4040:	9a 81       	ldd	r25, Y+2	; 0x02
    4042:	dc 01       	movw	r26, r24
    4044:	11 96       	adiw	r26, 0x01	; 1
    4046:	2c 91       	ld	r18, X
    4048:	8b 81       	ldd	r24, Y+3	; 0x03
    404a:	9c 81       	ldd	r25, Y+4	; 0x04
    404c:	fc 01       	movw	r30, r24
    404e:	20 83       	st	Z, r18
   switch(command->groupID) {
    4050:	89 81       	ldd	r24, Y+1	; 0x01
    4052:	9a 81       	ldd	r25, Y+2	; 0x02
    4054:	dc 01       	movw	r26, r24
    4056:	8c 91       	ld	r24, X
    4058:	99 27       	eor	r25, r25
    405a:	87 fd       	sbrc	r24, 7
    405c:	90 95       	com	r25
    405e:	aa 27       	eor	r26, r26
    4060:	97 fd       	sbrc	r25, 7
    4062:	a0 95       	com	r26
    4064:	ba 2f       	mov	r27, r26
    4066:	41 e0       	ldi	r20, 0x01	; 1
    4068:	50 e0       	ldi	r21, 0x00	; 0
    406a:	27 e0       	ldi	r18, 0x07	; 7
    406c:	30 e0       	ldi	r19, 0x00	; 0
    406e:	84 1b       	sub	r24, r20
    4070:	95 0b       	sbc	r25, r21
    4072:	28 17       	cp	r18, r24
    4074:	39 07       	cpc	r19, r25
    4076:	08 f4       	brcc	.+2      	; 0x407a <processCommand+0x50>
    4078:	4d c0       	rjmp	.+154    	; 0x4114 <processCommand+0xea>
    407a:	8e 58       	subi	r24, 0x8E	; 142
    407c:	9f 4f       	sbci	r25, 0xFF	; 255
    407e:	fc 01       	movw	r30, r24
    4080:	0c 94 87 29 	jmp	0x530e	; 0x530e <__tablejump2__>
      case ULTRASONIC_GROUP:
         processUltrasonicCommand(command->cmd, command->payload,&response->size, response->payload);
    4084:	8b 81       	ldd	r24, Y+3	; 0x03
    4086:	9c 81       	ldd	r25, Y+4	; 0x04
    4088:	9c 01       	movw	r18, r24
    408a:	2e 5f       	subi	r18, 0xFE	; 254
    408c:	3f 4f       	sbci	r19, 0xFF	; 255
    408e:	8b 81       	ldd	r24, Y+3	; 0x03
    4090:	9c 81       	ldd	r25, Y+4	; 0x04
    4092:	ac 01       	movw	r20, r24
    4094:	4f 5f       	subi	r20, 0xFF	; 255
    4096:	5f 4f       	sbci	r21, 0xFF	; 255
    4098:	89 81       	ldd	r24, Y+1	; 0x01
    409a:	9a 81       	ldd	r25, Y+2	; 0x02
    409c:	03 96       	adiw	r24, 0x03	; 3
    409e:	69 81       	ldd	r22, Y+1	; 0x01
    40a0:	7a 81       	ldd	r23, Y+2	; 0x02
    40a2:	db 01       	movw	r26, r22
    40a4:	11 96       	adiw	r26, 0x01	; 1
    40a6:	ec 91       	ld	r30, X
    40a8:	bc 01       	movw	r22, r24
    40aa:	8e 2f       	mov	r24, r30
    40ac:	0e 94 7c 1e 	call	0x3cf8	; 0x3cf8 <processUltrasonicCommand>
         break;
    40b0:	31 c0       	rjmp	.+98     	; 0x4114 <processCommand+0xea>
      case SPEED_GROUP:
			processSpeedCommand(command->cmd,command->payload,response);
    40b2:	89 81       	ldd	r24, Y+1	; 0x01
    40b4:	9a 81       	ldd	r25, Y+2	; 0x02
    40b6:	03 96       	adiw	r24, 0x03	; 3
    40b8:	29 81       	ldd	r18, Y+1	; 0x01
    40ba:	3a 81       	ldd	r19, Y+2	; 0x02
    40bc:	d9 01       	movw	r26, r18
    40be:	11 96       	adiw	r26, 0x01	; 1
    40c0:	ec 91       	ld	r30, X
    40c2:	2b 81       	ldd	r18, Y+3	; 0x03
    40c4:	3c 81       	ldd	r19, Y+4	; 0x04
    40c6:	a9 01       	movw	r20, r18
    40c8:	bc 01       	movw	r22, r24
    40ca:	8e 2f       	mov	r24, r30
    40cc:	0e 94 c4 1e 	call	0x3d88	; 0x3d88 <processSpeedCommand>
         break;
    40d0:	21 c0       	rjmp	.+66     	; 0x4114 <processCommand+0xea>
      case STEERING_GROUP:
         /*do steering things*/
         break;
      case FNR_GROUP:
			processFNRCommand(command->cmd,command->payload,response);
    40d2:	89 81       	ldd	r24, Y+1	; 0x01
    40d4:	9a 81       	ldd	r25, Y+2	; 0x02
    40d6:	03 96       	adiw	r24, 0x03	; 3
    40d8:	29 81       	ldd	r18, Y+1	; 0x01
    40da:	3a 81       	ldd	r19, Y+2	; 0x02
    40dc:	d9 01       	movw	r26, r18
    40de:	11 96       	adiw	r26, 0x01	; 1
    40e0:	ec 91       	ld	r30, X
    40e2:	2b 81       	ldd	r18, Y+3	; 0x03
    40e4:	3c 81       	ldd	r19, Y+4	; 0x04
    40e6:	a9 01       	movw	r20, r18
    40e8:	bc 01       	movw	r22, r24
    40ea:	8e 2f       	mov	r24, r30
    40ec:	0e 94 67 1f 	call	0x3ece	; 0x3ece <processFNRCommand>
         break;
    40f0:	11 c0       	rjmp	.+34     	; 0x4114 <processCommand+0xea>
         break;
      case BATTERY_GROUP:
         /*do battery things*/
         break;
      case LIGHTS_GROUP:
	      processLightCommand(command->cmd,command->payload,response);
    40f2:	89 81       	ldd	r24, Y+1	; 0x01
    40f4:	9a 81       	ldd	r25, Y+2	; 0x02
    40f6:	03 96       	adiw	r24, 0x03	; 3
    40f8:	29 81       	ldd	r18, Y+1	; 0x01
    40fa:	3a 81       	ldd	r19, Y+2	; 0x02
    40fc:	d9 01       	movw	r26, r18
    40fe:	11 96       	adiw	r26, 0x01	; 1
    4100:	ec 91       	ld	r30, X
    4102:	2b 81       	ldd	r18, Y+3	; 0x03
    4104:	3c 81       	ldd	r19, Y+4	; 0x04
    4106:	a9 01       	movw	r20, r18
    4108:	bc 01       	movw	r22, r24
    410a:	8e 2f       	mov	r24, r30
    410c:	0e 94 ed 1f 	call	0x3fda	; 0x3fda <processLightCommand>
         break;
    4110:	01 c0       	rjmp	.+2      	; 0x4114 <processCommand+0xea>
      case ERROR_GROUP:
         /*do error things*/
         break;
    4112:	00 00       	nop
   }
   //return a dummy success for now
   return 1;
    4114:	81 e0       	ldi	r24, 0x01	; 1
}
    4116:	0f 90       	pop	r0
    4118:	0f 90       	pop	r0
    411a:	0f 90       	pop	r0
    411c:	0f 90       	pop	r0
    411e:	df 91       	pop	r29
    4120:	cf 91       	pop	r28
    4122:	08 95       	ret

00004124 <getBatteryVoltage>:

//battery controller functions

//read battery strength in a char. Might need to be unsigned, specs don't say
//anything regarding that.
char getBatteryVoltage(char *sensorResponse) {
    4124:	cf 93       	push	r28
    4126:	df 93       	push	r29
    4128:	1f 92       	push	r1
    412a:	1f 92       	push	r1
    412c:	cd b7       	in	r28, 0x3d	; 61
    412e:	de b7       	in	r29, 0x3e	; 62
    4130:	9a 83       	std	Y+2, r25	; 0x02
    4132:	89 83       	std	Y+1, r24	; 0x01
   //fake battery reading
   *sensorResponse = 0;
    4134:	89 81       	ldd	r24, Y+1	; 0x01
    4136:	9a 81       	ldd	r25, Y+2	; 0x02
    4138:	fc 01       	movw	r30, r24
    413a:	10 82       	st	Z, r1
   //return success
   return 1;
    413c:	81 e0       	ldi	r24, 0x01	; 1
}
    413e:	0f 90       	pop	r0
    4140:	0f 90       	pop	r0
    4142:	df 91       	pop	r29
    4144:	cf 91       	pop	r28
    4146:	08 95       	ret

00004148 <getSteeringVoltage>:

//gets voltage from steering?
char getSteeringVoltage(char *sensorResponse) {
    4148:	cf 93       	push	r28
    414a:	df 93       	push	r29
    414c:	1f 92       	push	r1
    414e:	1f 92       	push	r1
    4150:	cd b7       	in	r28, 0x3d	; 61
    4152:	de b7       	in	r29, 0x3e	; 62
    4154:	9a 83       	std	Y+2, r25	; 0x02
    4156:	89 83       	std	Y+1, r24	; 0x01
   //fake steering voltage reading
   *sensorResponse = 0;
    4158:	89 81       	ldd	r24, Y+1	; 0x01
    415a:	9a 81       	ldd	r25, Y+2	; 0x02
    415c:	fc 01       	movw	r30, r24
    415e:	10 82       	st	Z, r1
   //return success
   return 1;
    4160:	81 e0       	ldi	r24, 0x01	; 1
}
    4162:	0f 90       	pop	r0
    4164:	0f 90       	pop	r0
    4166:	df 91       	pop	r29
    4168:	cf 91       	pop	r28
    416a:	08 95       	ret

0000416c <setBrake>:
//Brake controller functions. THERE IS CURRENTLY NO WAY TO GET THE DESIRED
//BRAKE TARGET IN THE SPECS

//set brake target
char setBrake(char gainTarget) {
    416c:	cf 93       	push	r28
    416e:	df 93       	push	r29
    4170:	1f 92       	push	r1
    4172:	cd b7       	in	r28, 0x3d	; 61
    4174:	de b7       	in	r29, 0x3e	; 62
    4176:	89 83       	std	Y+1, r24	; 0x01
   //dummy function, nothing happens
   //return success
   return 1;
    4178:	81 e0       	ldi	r24, 0x01	; 1
}
    417a:	0f 90       	pop	r0
    417c:	df 91       	pop	r29
    417e:	cf 91       	pop	r28
    4180:	08 95       	ret

00004182 <getBrake>:

//get what is assumed to be the current brake value?
char getBrake(char* sensorResponse) {
    4182:	cf 93       	push	r28
    4184:	df 93       	push	r29
    4186:	1f 92       	push	r1
    4188:	1f 92       	push	r1
    418a:	cd b7       	in	r28, 0x3d	; 61
    418c:	de b7       	in	r29, 0x3e	; 62
    418e:	9a 83       	std	Y+2, r25	; 0x02
    4190:	89 83       	std	Y+1, r24	; 0x01
   //fake brake reading
   *sensorResponse = 0;
    4192:	89 81       	ldd	r24, Y+1	; 0x01
    4194:	9a 81       	ldd	r25, Y+2	; 0x02
    4196:	fc 01       	movw	r30, r24
    4198:	10 82       	st	Z, r1
   //return success
   return 1;
    419a:	81 e0       	ldi	r24, 0x01	; 1
}
    419c:	0f 90       	pop	r0
    419e:	0f 90       	pop	r0
    41a0:	df 91       	pop	r29
    41a2:	cf 91       	pop	r28
    41a4:	08 95       	ret

000041a6 <FNRForward>:

#define clearABit(x) \
PORTA &= ~(1 << (x));


void FNRForward(){
    41a6:	cf 93       	push	r28
    41a8:	df 93       	push	r29
    41aa:	cd b7       	in	r28, 0x3d	; 61
    41ac:	de b7       	in	r29, 0x3e	; 62
	clearABit(1);
    41ae:	82 e2       	ldi	r24, 0x22	; 34
    41b0:	90 e0       	ldi	r25, 0x00	; 0
    41b2:	22 e2       	ldi	r18, 0x22	; 34
    41b4:	30 e0       	ldi	r19, 0x00	; 0
    41b6:	f9 01       	movw	r30, r18
    41b8:	20 81       	ld	r18, Z
    41ba:	2d 7f       	andi	r18, 0xFD	; 253
    41bc:	fc 01       	movw	r30, r24
    41be:	20 83       	st	Z, r18
	while((PORTA & 0x2) != 0){
    41c0:	0d c0       	rjmp	.+26     	; 0x41dc <FNRForward+0x36>
		clearABit(1);
    41c2:	82 e2       	ldi	r24, 0x22	; 34
    41c4:	90 e0       	ldi	r25, 0x00	; 0
    41c6:	22 e2       	ldi	r18, 0x22	; 34
    41c8:	30 e0       	ldi	r19, 0x00	; 0
    41ca:	f9 01       	movw	r30, r18
    41cc:	20 81       	ld	r18, Z
    41ce:	2d 7f       	andi	r18, 0xFD	; 253
    41d0:	fc 01       	movw	r30, r24
    41d2:	20 83       	st	Z, r18
		vTaskDelay(1);
    41d4:	81 e0       	ldi	r24, 0x01	; 1
    41d6:	90 e0       	ldi	r25, 0x00	; 0
    41d8:	0e 94 1d 05 	call	0xa3a	; 0xa3a <vTaskDelay>
PORTA &= ~(1 << (x));


void FNRForward(){
	clearABit(1);
	while((PORTA & 0x2) != 0){
    41dc:	82 e2       	ldi	r24, 0x22	; 34
    41de:	90 e0       	ldi	r25, 0x00	; 0
    41e0:	fc 01       	movw	r30, r24
    41e2:	80 81       	ld	r24, Z
    41e4:	88 2f       	mov	r24, r24
    41e6:	90 e0       	ldi	r25, 0x00	; 0
    41e8:	82 70       	andi	r24, 0x02	; 2
    41ea:	99 27       	eor	r25, r25
    41ec:	00 97       	sbiw	r24, 0x00	; 0
    41ee:	49 f7       	brne	.-46     	; 0x41c2 <FNRForward+0x1c>
		clearABit(1);
		vTaskDelay(1);
	}
	setABit(0);
    41f0:	82 e2       	ldi	r24, 0x22	; 34
    41f2:	90 e0       	ldi	r25, 0x00	; 0
    41f4:	22 e2       	ldi	r18, 0x22	; 34
    41f6:	30 e0       	ldi	r19, 0x00	; 0
    41f8:	f9 01       	movw	r30, r18
    41fa:	20 81       	ld	r18, Z
    41fc:	21 60       	ori	r18, 0x01	; 1
    41fe:	fc 01       	movw	r30, r24
    4200:	20 83       	st	Z, r18

	//PORTL &= ~0x30;
}
    4202:	df 91       	pop	r29
    4204:	cf 91       	pop	r28
    4206:	08 95       	ret

00004208 <FNRReverse>:

void FNRReverse(){
    4208:	cf 93       	push	r28
    420a:	df 93       	push	r29
    420c:	cd b7       	in	r28, 0x3d	; 61
    420e:	de b7       	in	r29, 0x3e	; 62
	clearABit(0);
    4210:	82 e2       	ldi	r24, 0x22	; 34
    4212:	90 e0       	ldi	r25, 0x00	; 0
    4214:	22 e2       	ldi	r18, 0x22	; 34
    4216:	30 e0       	ldi	r19, 0x00	; 0
    4218:	f9 01       	movw	r30, r18
    421a:	20 81       	ld	r18, Z
    421c:	2e 7f       	andi	r18, 0xFE	; 254
    421e:	fc 01       	movw	r30, r24
    4220:	20 83       	st	Z, r18
	while((PORTA & 0x1) != 0){
    4222:	0d c0       	rjmp	.+26     	; 0x423e <FNRReverse+0x36>
		clearABit(0);
    4224:	82 e2       	ldi	r24, 0x22	; 34
    4226:	90 e0       	ldi	r25, 0x00	; 0
    4228:	22 e2       	ldi	r18, 0x22	; 34
    422a:	30 e0       	ldi	r19, 0x00	; 0
    422c:	f9 01       	movw	r30, r18
    422e:	20 81       	ld	r18, Z
    4230:	2e 7f       	andi	r18, 0xFE	; 254
    4232:	fc 01       	movw	r30, r24
    4234:	20 83       	st	Z, r18
		vTaskDelay(1);
    4236:	81 e0       	ldi	r24, 0x01	; 1
    4238:	90 e0       	ldi	r25, 0x00	; 0
    423a:	0e 94 1d 05 	call	0xa3a	; 0xa3a <vTaskDelay>
	//PORTL &= ~0x30;
}

void FNRReverse(){
	clearABit(0);
	while((PORTA & 0x1) != 0){
    423e:	82 e2       	ldi	r24, 0x22	; 34
    4240:	90 e0       	ldi	r25, 0x00	; 0
    4242:	fc 01       	movw	r30, r24
    4244:	80 81       	ld	r24, Z
    4246:	88 2f       	mov	r24, r24
    4248:	90 e0       	ldi	r25, 0x00	; 0
    424a:	81 70       	andi	r24, 0x01	; 1
    424c:	99 27       	eor	r25, r25
    424e:	00 97       	sbiw	r24, 0x00	; 0
    4250:	49 f7       	brne	.-46     	; 0x4224 <FNRReverse+0x1c>
		clearABit(0);
		vTaskDelay(1);
	}
	setABit(1);
    4252:	82 e2       	ldi	r24, 0x22	; 34
    4254:	90 e0       	ldi	r25, 0x00	; 0
    4256:	22 e2       	ldi	r18, 0x22	; 34
    4258:	30 e0       	ldi	r19, 0x00	; 0
    425a:	f9 01       	movw	r30, r18
    425c:	20 81       	ld	r18, Z
    425e:	22 60       	ori	r18, 0x02	; 2
    4260:	fc 01       	movw	r30, r24
    4262:	20 83       	st	Z, r18

	//PORTL |= 0x30;
}
    4264:	df 91       	pop	r29
    4266:	cf 91       	pop	r28
    4268:	08 95       	ret

0000426a <FNRNeutral>:

void FNRNeutral(){
    426a:	cf 93       	push	r28
    426c:	df 93       	push	r29
    426e:	cd b7       	in	r28, 0x3d	; 61
    4270:	de b7       	in	r29, 0x3e	; 62
	clearABit(0);
    4272:	82 e2       	ldi	r24, 0x22	; 34
    4274:	90 e0       	ldi	r25, 0x00	; 0
    4276:	22 e2       	ldi	r18, 0x22	; 34
    4278:	30 e0       	ldi	r19, 0x00	; 0
    427a:	f9 01       	movw	r30, r18
    427c:	20 81       	ld	r18, Z
    427e:	2e 7f       	andi	r18, 0xFE	; 254
    4280:	fc 01       	movw	r30, r24
    4282:	20 83       	st	Z, r18
	clearABit(1);
    4284:	82 e2       	ldi	r24, 0x22	; 34
    4286:	90 e0       	ldi	r25, 0x00	; 0
    4288:	22 e2       	ldi	r18, 0x22	; 34
    428a:	30 e0       	ldi	r19, 0x00	; 0
    428c:	f9 01       	movw	r30, r18
    428e:	20 81       	ld	r18, Z
    4290:	2d 7f       	andi	r18, 0xFD	; 253
    4292:	fc 01       	movw	r30, r24
    4294:	20 83       	st	Z, r18
	while((PORTA & 0x3) != 0){
    4296:	16 c0       	rjmp	.+44     	; 0x42c4 <FNRNeutral+0x5a>
		clearABit(0);
    4298:	82 e2       	ldi	r24, 0x22	; 34
    429a:	90 e0       	ldi	r25, 0x00	; 0
    429c:	22 e2       	ldi	r18, 0x22	; 34
    429e:	30 e0       	ldi	r19, 0x00	; 0
    42a0:	f9 01       	movw	r30, r18
    42a2:	20 81       	ld	r18, Z
    42a4:	2e 7f       	andi	r18, 0xFE	; 254
    42a6:	fc 01       	movw	r30, r24
    42a8:	20 83       	st	Z, r18
		clearABit(1);
    42aa:	82 e2       	ldi	r24, 0x22	; 34
    42ac:	90 e0       	ldi	r25, 0x00	; 0
    42ae:	22 e2       	ldi	r18, 0x22	; 34
    42b0:	30 e0       	ldi	r19, 0x00	; 0
    42b2:	f9 01       	movw	r30, r18
    42b4:	20 81       	ld	r18, Z
    42b6:	2d 7f       	andi	r18, 0xFD	; 253
    42b8:	fc 01       	movw	r30, r24
    42ba:	20 83       	st	Z, r18
		vTaskDelay(1);
    42bc:	81 e0       	ldi	r24, 0x01	; 1
    42be:	90 e0       	ldi	r25, 0x00	; 0
    42c0:	0e 94 1d 05 	call	0xa3a	; 0xa3a <vTaskDelay>
}

void FNRNeutral(){
	clearABit(0);
	clearABit(1);
	while((PORTA & 0x3) != 0){
    42c4:	82 e2       	ldi	r24, 0x22	; 34
    42c6:	90 e0       	ldi	r25, 0x00	; 0
    42c8:	fc 01       	movw	r30, r24
    42ca:	80 81       	ld	r24, Z
    42cc:	88 2f       	mov	r24, r24
    42ce:	90 e0       	ldi	r25, 0x00	; 0
    42d0:	83 70       	andi	r24, 0x03	; 3
    42d2:	99 27       	eor	r25, r25
    42d4:	00 97       	sbiw	r24, 0x00	; 0
    42d6:	01 f7       	brne	.-64     	; 0x4298 <FNRNeutral+0x2e>
		clearABit(0);
		clearABit(1);
		vTaskDelay(1);
	}
	//PORTL &= ~0x30;
}
    42d8:	df 91       	pop	r29
    42da:	cf 91       	pop	r28
    42dc:	08 95       	ret

000042de <setFNR>:

//set the FNR controller, inputs are either -1, 0, or 1.
char setFNR(char FNR) {
    42de:	cf 93       	push	r28
    42e0:	df 93       	push	r29
    42e2:	1f 92       	push	r1
    42e4:	cd b7       	in	r28, 0x3d	; 61
    42e6:	de b7       	in	r29, 0x3e	; 62
    42e8:	89 83       	std	Y+1, r24	; 0x01
   //dummy function, nothing happens
   //return success
	if(FNR == 0){
    42ea:	89 81       	ldd	r24, Y+1	; 0x01
    42ec:	88 23       	and	r24, r24
    42ee:	19 f4       	brne	.+6      	; 0x42f6 <setFNR+0x18>
		FNRNeutral();
    42f0:	0e 94 35 21 	call	0x426a	; 0x426a <FNRNeutral>
    42f4:	0b c0       	rjmp	.+22     	; 0x430c <setFNR+0x2e>
	} else if(FNR == 1){
    42f6:	89 81       	ldd	r24, Y+1	; 0x01
    42f8:	81 30       	cpi	r24, 0x01	; 1
    42fa:	19 f4       	brne	.+6      	; 0x4302 <setFNR+0x24>
		FNRForward();
    42fc:	0e 94 d3 20 	call	0x41a6	; 0x41a6 <FNRForward>
    4300:	05 c0       	rjmp	.+10     	; 0x430c <setFNR+0x2e>
	} else if(FNR == -1){
    4302:	89 81       	ldd	r24, Y+1	; 0x01
    4304:	8f 3f       	cpi	r24, 0xFF	; 255
    4306:	11 f4       	brne	.+4      	; 0x430c <setFNR+0x2e>
		FNRReverse();
    4308:	0e 94 04 21 	call	0x4208	; 0x4208 <FNRReverse>
	}

   return 1;
    430c:	81 e0       	ldi	r24, 0x01	; 1
}
    430e:	0f 90       	pop	r0
    4310:	df 91       	pop	r29
    4312:	cf 91       	pop	r28
    4314:	08 95       	ret

00004316 <getFNR>:

//get the current FNR state. Function follows same format for consistancy
char getFNR(char *sensorResponse) {
    4316:	cf 93       	push	r28
    4318:	df 93       	push	r29
    431a:	1f 92       	push	r1
    431c:	1f 92       	push	r1
    431e:	cd b7       	in	r28, 0x3d	; 61
    4320:	de b7       	in	r29, 0x3e	; 62
    4322:	9a 83       	std	Y+2, r25	; 0x02
    4324:	89 83       	std	Y+1, r24	; 0x01
   //fake reading
   *sensorResponse = 0;
    4326:	89 81       	ldd	r24, Y+1	; 0x01
    4328:	9a 81       	ldd	r25, Y+2	; 0x02
    432a:	fc 01       	movw	r30, r24
    432c:	10 82       	st	Z, r1
   //return success
   return 1;
    432e:	81 e0       	ldi	r24, 0x01	; 1
}
    4330:	0f 90       	pop	r0
    4332:	0f 90       	pop	r0
    4334:	df 91       	pop	r29
    4336:	cf 91       	pop	r28
    4338:	08 95       	ret

0000433a <setLight>:
//light controller functions
#include <avr/io.h>

//turn lights on and off
char setLight(unsigned char lightTarget) {
    433a:	cf 93       	push	r28
    433c:	df 93       	push	r29
    433e:	1f 92       	push	r1
    4340:	cd b7       	in	r28, 0x3d	; 61
    4342:	de b7       	in	r29, 0x3e	; 62
    4344:	89 83       	std	Y+1, r24	; 0x01
   //dummy function, nothing happens
	//PORTB ^= 0x80;
	if(lightTarget == 1){
    4346:	89 81       	ldd	r24, Y+1	; 0x01
    4348:	81 30       	cpi	r24, 0x01	; 1
    434a:	51 f4       	brne	.+20     	; 0x4360 <setLight+0x26>
		PORTB |= 0x80;
    434c:	85 e2       	ldi	r24, 0x25	; 37
    434e:	90 e0       	ldi	r25, 0x00	; 0
    4350:	25 e2       	ldi	r18, 0x25	; 37
    4352:	30 e0       	ldi	r19, 0x00	; 0
    4354:	f9 01       	movw	r30, r18
    4356:	20 81       	ld	r18, Z
    4358:	20 68       	ori	r18, 0x80	; 128
    435a:	fc 01       	movw	r30, r24
    435c:	20 83       	st	Z, r18
    435e:	09 c0       	rjmp	.+18     	; 0x4372 <setLight+0x38>
	} else {
		PORTB &= ~0x80;
    4360:	85 e2       	ldi	r24, 0x25	; 37
    4362:	90 e0       	ldi	r25, 0x00	; 0
    4364:	25 e2       	ldi	r18, 0x25	; 37
    4366:	30 e0       	ldi	r19, 0x00	; 0
    4368:	f9 01       	movw	r30, r18
    436a:	20 81       	ld	r18, Z
    436c:	2f 77       	andi	r18, 0x7F	; 127
    436e:	fc 01       	movw	r30, r24
    4370:	20 83       	st	Z, r18
	}
   return 1;
    4372:	81 e0       	ldi	r24, 0x01	; 1
}
    4374:	0f 90       	pop	r0
    4376:	df 91       	pop	r29
    4378:	cf 91       	pop	r28
    437a:	08 95       	ret

0000437c <setSonarData>:
	USART_Write(hex[(i&0xF0) >> 4]);
	USART_Write(hex[i&0xF]);

}   */

void setSonarData(int i,int data){
    437c:	cf 93       	push	r28
    437e:	df 93       	push	r29
    4380:	00 d0       	rcall	.+0      	; 0x4382 <setSonarData+0x6>
    4382:	1f 92       	push	r1
    4384:	cd b7       	in	r28, 0x3d	; 61
    4386:	de b7       	in	r29, 0x3e	; 62
    4388:	9a 83       	std	Y+2, r25	; 0x02
    438a:	89 83       	std	Y+1, r24	; 0x01
    438c:	7c 83       	std	Y+4, r23	; 0x04
    438e:	6b 83       	std	Y+3, r22	; 0x03
// xSemaphoreTake(sonarDataMutex[i],portMAX_DELAY);
   sonarData[i] = data;
    4390:	89 81       	ldd	r24, Y+1	; 0x01
    4392:	9a 81       	ldd	r25, Y+2	; 0x02
    4394:	88 0f       	add	r24, r24
    4396:	99 1f       	adc	r25, r25
    4398:	8b 53       	subi	r24, 0x3B	; 59
    439a:	95 4e       	sbci	r25, 0xE5	; 229
    439c:	2b 81       	ldd	r18, Y+3	; 0x03
    439e:	3c 81       	ldd	r19, Y+4	; 0x04
    43a0:	fc 01       	movw	r30, r24
    43a2:	31 83       	std	Z+1, r19	; 0x01
    43a4:	20 83       	st	Z, r18
   //xSemaphoreGive(sonarDataMutex[i]);
}
    43a6:	0f 90       	pop	r0
    43a8:	0f 90       	pop	r0
    43aa:	0f 90       	pop	r0
    43ac:	0f 90       	pop	r0
    43ae:	df 91       	pop	r29
    43b0:	cf 91       	pop	r28
    43b2:	08 95       	ret

000043b4 <getSonarData>:

int getSonarData(int i){
    43b4:	cf 93       	push	r28
    43b6:	df 93       	push	r29
    43b8:	1f 92       	push	r1
    43ba:	1f 92       	push	r1
    43bc:	cd b7       	in	r28, 0x3d	; 61
    43be:	de b7       	in	r29, 0x3e	; 62
    43c0:	9a 83       	std	Y+2, r25	; 0x02
    43c2:	89 83       	std	Y+1, r24	; 0x01
   //xSemaphoreTake(sonarDataMutex[i],portMAX_DELAY);
   return sonarData[i];
    43c4:	89 81       	ldd	r24, Y+1	; 0x01
    43c6:	9a 81       	ldd	r25, Y+2	; 0x02
    43c8:	88 0f       	add	r24, r24
    43ca:	99 1f       	adc	r25, r25
    43cc:	8b 53       	subi	r24, 0x3B	; 59
    43ce:	95 4e       	sbci	r25, 0xE5	; 229
    43d0:	fc 01       	movw	r30, r24
    43d2:	80 81       	ld	r24, Z
    43d4:	91 81       	ldd	r25, Z+1	; 0x01
   //xSemaphoreGive(sonarDataMutex[i]);
}
    43d6:	0f 90       	pop	r0
    43d8:	0f 90       	pop	r0
    43da:	df 91       	pop	r29
    43dc:	cf 91       	pop	r28
    43de:	08 95       	ret

000043e0 <getTimerCount>:

unsigned char getTimerCount(){
    43e0:	cf 93       	push	r28
    43e2:	df 93       	push	r29
    43e4:	cd b7       	in	r28, 0x3d	; 61
    43e6:	de b7       	in	r29, 0x3e	; 62
   return TCNT0;
    43e8:	86 e4       	ldi	r24, 0x46	; 70
    43ea:	90 e0       	ldi	r25, 0x00	; 0
    43ec:	fc 01       	movw	r30, r24
    43ee:	80 81       	ld	r24, Z
}
    43f0:	df 91       	pop	r29
    43f2:	cf 91       	pop	r28
    43f4:	08 95       	ret

000043f6 <__vector_11>:

inline void setTimerCount(unsigned char i){
   TCNT0 = i;
}

ISR(PCINT2_vect) {
    43f6:	1f 92       	push	r1
    43f8:	0f 92       	push	r0
    43fa:	00 90 5f 00 	lds	r0, 0x005F
    43fe:	0f 92       	push	r0
    4400:	11 24       	eor	r1, r1
    4402:	00 90 5b 00 	lds	r0, 0x005B
    4406:	0f 92       	push	r0
    4408:	2f 93       	push	r18
    440a:	3f 93       	push	r19
    440c:	4f 93       	push	r20
    440e:	5f 93       	push	r21
    4410:	6f 93       	push	r22
    4412:	7f 93       	push	r23
    4414:	8f 93       	push	r24
    4416:	9f 93       	push	r25
    4418:	af 93       	push	r26
    441a:	bf 93       	push	r27
    441c:	ef 93       	push	r30
    441e:	ff 93       	push	r31
    4420:	cf 93       	push	r28
    4422:	df 93       	push	r29
    4424:	00 d0       	rcall	.+0      	; 0x4426 <__vector_11+0x30>
    4426:	cd b7       	in	r28, 0x3d	; 61
    4428:	de b7       	in	r29, 0x3e	; 62

   unsigned char beginCount;
   unsigned char currCount;
   char i=0;   
    442a:	19 82       	std	Y+1, r1	; 0x01

   if(PINK&(1<<currSonar)){
    442c:	86 e0       	ldi	r24, 0x06	; 6
    442e:	91 e0       	ldi	r25, 0x01	; 1
    4430:	fc 01       	movw	r30, r24
    4432:	80 81       	ld	r24, Z
    4434:	88 2f       	mov	r24, r24
    4436:	90 e0       	ldi	r25, 0x00	; 0
    4438:	20 91 d3 1a 	lds	r18, 0x1AD3
    443c:	22 2f       	mov	r18, r18
    443e:	30 e0       	ldi	r19, 0x00	; 0
    4440:	02 2e       	mov	r0, r18
    4442:	02 c0       	rjmp	.+4      	; 0x4448 <__vector_11+0x52>
    4444:	95 95       	asr	r25
    4446:	87 95       	ror	r24
    4448:	0a 94       	dec	r0
    444a:	e2 f7       	brpl	.-8      	; 0x4444 <__vector_11+0x4e>
    444c:	81 70       	andi	r24, 0x01	; 1
    444e:	99 27       	eor	r25, r25
    4450:	00 97       	sbiw	r24, 0x00	; 0
    4452:	49 f0       	breq	.+18     	; 0x4466 <__vector_11+0x70>
      //USART_AddToQueue('U');
      beginCount = getTimerCount();
    4454:	0e 94 f0 21 	call	0x43e0	; 0x43e0 <getTimerCount>
    4458:	8a 83       	std	Y+2, r24	; 0x02
      PORTE = 0xFF;
    445a:	8e e2       	ldi	r24, 0x2E	; 46
    445c:	90 e0       	ldi	r25, 0x00	; 0
    445e:	2f ef       	ldi	r18, 0xFF	; 255
    4460:	fc 01       	movw	r30, r24
    4462:	20 83       	st	Z, r18
    4464:	1d c0       	rjmp	.+58     	; 0x44a0 <__vector_11+0xaa>
   } else {
      //USART_AddToQueue('D');
      currCount = getTimerCount();
    4466:	0e 94 f0 21 	call	0x43e0	; 0x43e0 <getTimerCount>
    446a:	8b 83       	std	Y+3, r24	; 0x03
      if(currCount > beginCount){
    446c:	9b 81       	ldd	r25, Y+3	; 0x03
    446e:	8a 81       	ldd	r24, Y+2	; 0x02
    4470:	89 17       	cp	r24, r25
    4472:	38 f4       	brcc	.+14     	; 0x4482 <__vector_11+0x8c>
         lastSonarData = currCount - beginCount;
    4474:	9b 81       	ldd	r25, Y+3	; 0x03
    4476:	8a 81       	ldd	r24, Y+2	; 0x02
    4478:	f9 2f       	mov	r31, r25
    447a:	f8 1b       	sub	r31, r24
    447c:	8f 2f       	mov	r24, r31
    447e:	80 93 d4 1a 	sts	0x1AD4, r24
      }
      PORTE = 0;
    4482:	8e e2       	ldi	r24, 0x2E	; 46
    4484:	90 e0       	ldi	r25, 0x00	; 0
    4486:	fc 01       	movw	r30, r24
    4488:	10 82       	st	Z, r1
      xSemaphoreGiveFromISR(sonarSemaphore,0);
    448a:	80 91 6b 1b 	lds	r24, 0x1B6B
    448e:	90 91 6c 1b 	lds	r25, 0x1B6C
    4492:	20 e0       	ldi	r18, 0x00	; 0
    4494:	40 e0       	ldi	r20, 0x00	; 0
    4496:	50 e0       	ldi	r21, 0x00	; 0
    4498:	60 e0       	ldi	r22, 0x00	; 0
    449a:	70 e0       	ldi	r23, 0x00	; 0
    449c:	0e 94 f0 0e 	call	0x1de0	; 0x1de0 <xQueueGenericSendFromISR>
   }

}
    44a0:	0f 90       	pop	r0
    44a2:	0f 90       	pop	r0
    44a4:	0f 90       	pop	r0
    44a6:	df 91       	pop	r29
    44a8:	cf 91       	pop	r28
    44aa:	ff 91       	pop	r31
    44ac:	ef 91       	pop	r30
    44ae:	bf 91       	pop	r27
    44b0:	af 91       	pop	r26
    44b2:	9f 91       	pop	r25
    44b4:	8f 91       	pop	r24
    44b6:	7f 91       	pop	r23
    44b8:	6f 91       	pop	r22
    44ba:	5f 91       	pop	r21
    44bc:	4f 91       	pop	r20
    44be:	3f 91       	pop	r19
    44c0:	2f 91       	pop	r18
    44c2:	0f 90       	pop	r0
    44c4:	00 92 5b 00 	sts	0x005B, r0
    44c8:	0f 90       	pop	r0
    44ca:	00 92 5f 00 	sts	0x005F, r0
    44ce:	0f 90       	pop	r0
    44d0:	1f 90       	pop	r1
    44d2:	18 95       	reti

000044d4 <sonarADCHandler>:

void sonarADCHandler(int result,void *sonarNum){
    44d4:	cf 93       	push	r28
    44d6:	df 93       	push	r29
    44d8:	00 d0       	rcall	.+0      	; 0x44da <sonarADCHandler+0x6>
    44da:	1f 92       	push	r1
    44dc:	cd b7       	in	r28, 0x3d	; 61
    44de:	de b7       	in	r29, 0x3e	; 62
    44e0:	9a 83       	std	Y+2, r25	; 0x02
    44e2:	89 83       	std	Y+1, r24	; 0x01
    44e4:	7c 83       	std	Y+4, r23	; 0x04
    44e6:	6b 83       	std	Y+3, r22	; 0x03

	/*printHex(*((int *)sonarNum));
	USART_Write('\n');
	USART_Write('\r');*/

	setSonarData(*((int *)sonarNum),result);
    44e8:	8b 81       	ldd	r24, Y+3	; 0x03
    44ea:	9c 81       	ldd	r25, Y+4	; 0x04
    44ec:	fc 01       	movw	r30, r24
    44ee:	80 81       	ld	r24, Z
    44f0:	91 81       	ldd	r25, Z+1	; 0x01
    44f2:	29 81       	ldd	r18, Y+1	; 0x01
    44f4:	3a 81       	ldd	r19, Y+2	; 0x02
    44f6:	b9 01       	movw	r22, r18
    44f8:	0e 94 be 21 	call	0x437c	; 0x437c <setSonarData>

}
    44fc:	0f 90       	pop	r0
    44fe:	0f 90       	pop	r0
    4500:	0f 90       	pop	r0
    4502:	0f 90       	pop	r0
    4504:	df 91       	pop	r29
    4506:	cf 91       	pop	r28
    4508:	08 95       	ret

0000450a <initializeSonarSensors>:

void initializeSonarSensors(){
    450a:	cf 93       	push	r28
    450c:	df 93       	push	r29
    450e:	cd b7       	in	r28, 0x3d	; 61
    4510:	de b7       	in	r29, 0x3e	; 62

	//addADCDevice(0,ADC_OPT_PRECISION_HIGH,sonarADCHandler,&sonarNum0);			
	//addADCDevice(12,ADC_OPT_PRECISION_HIGH,sonarADCHandler,&sonarNum1);			
	//addADCDevice(15,ADC_OPT_PRECISION_HIGH,sonarADCHandler,&sonarNum2);			

}
    4512:	df 91       	pop	r29
    4514:	cf 91       	pop	r28
    4516:	08 95       	ret

00004518 <vTaskSonar>:

void vTaskSonar(void* parameter){
    4518:	cf 93       	push	r28
    451a:	df 93       	push	r29
    451c:	1f 92       	push	r1
    451e:	1f 92       	push	r1
    4520:	cd b7       	in	r28, 0x3d	; 61
    4522:	de b7       	in	r29, 0x3e	; 62
    4524:	9a 83       	std	Y+2, r25	; 0x02
    4526:	89 83       	std	Y+1, r24	; 0x01

   int i;
   initializeSonarSensors();
    4528:	0e 94 85 22 	call	0x450a	; 0x450a <initializeSonarSensors>
	for(;;){
		vTaskDelay(300);
    452c:	8c e2       	ldi	r24, 0x2C	; 44
    452e:	91 e0       	ldi	r25, 0x01	; 1
    4530:	0e 94 1d 05 	call	0xa3a	; 0xa3a <vTaskDelay>
	}
    4534:	fb cf       	rjmp	.-10     	; 0x452c <vTaskSonar+0x14>

00004536 <getAllSensors>:
      }
   }
            
} 

char getAllSensors(unsigned short* responseData){
    4536:	cf 93       	push	r28
    4538:	df 93       	push	r29
    453a:	00 d0       	rcall	.+0      	; 0x453c <getAllSensors+0x6>
    453c:	1f 92       	push	r1
    453e:	cd b7       	in	r28, 0x3d	; 61
    4540:	de b7       	in	r29, 0x3e	; 62
    4542:	9c 83       	std	Y+4, r25	; 0x04
    4544:	8b 83       	std	Y+3, r24	; 0x03
   unsigned short i;
   for(i=0;i<6;i++){
    4546:	1a 82       	std	Y+2, r1	; 0x02
    4548:	19 82       	std	Y+1, r1	; 0x01
    454a:	14 c0       	rjmp	.+40     	; 0x4574 <getAllSensors+0x3e>
      //responseData[i] = getSonarData(i);
      responseData[i] = i+1;
    454c:	89 81       	ldd	r24, Y+1	; 0x01
    454e:	9a 81       	ldd	r25, Y+2	; 0x02
    4550:	88 0f       	add	r24, r24
    4552:	99 1f       	adc	r25, r25
    4554:	2b 81       	ldd	r18, Y+3	; 0x03
    4556:	3c 81       	ldd	r19, Y+4	; 0x04
    4558:	82 0f       	add	r24, r18
    455a:	93 1f       	adc	r25, r19
    455c:	29 81       	ldd	r18, Y+1	; 0x01
    455e:	3a 81       	ldd	r19, Y+2	; 0x02
    4560:	2f 5f       	subi	r18, 0xFF	; 255
    4562:	3f 4f       	sbci	r19, 0xFF	; 255
    4564:	fc 01       	movw	r30, r24
    4566:	31 83       	std	Z+1, r19	; 0x01
    4568:	20 83       	st	Z, r18
            
} 

char getAllSensors(unsigned short* responseData){
   unsigned short i;
   for(i=0;i<6;i++){
    456a:	89 81       	ldd	r24, Y+1	; 0x01
    456c:	9a 81       	ldd	r25, Y+2	; 0x02
    456e:	01 96       	adiw	r24, 0x01	; 1
    4570:	9a 83       	std	Y+2, r25	; 0x02
    4572:	89 83       	std	Y+1, r24	; 0x01
    4574:	89 81       	ldd	r24, Y+1	; 0x01
    4576:	9a 81       	ldd	r25, Y+2	; 0x02
    4578:	86 30       	cpi	r24, 0x06	; 6
    457a:	91 05       	cpc	r25, r1
    457c:	38 f3       	brcs	.-50     	; 0x454c <getAllSensors+0x16>
      //responseData[i] = getSonarData(i);
      responseData[i] = i+1;
   }
}
    457e:	0f 90       	pop	r0
    4580:	0f 90       	pop	r0
    4582:	0f 90       	pop	r0
    4584:	0f 90       	pop	r0
    4586:	df 91       	pop	r29
    4588:	cf 91       	pop	r28
    458a:	08 95       	ret

0000458c <getCertainSensor>:

char getCertainSensor(char commandData,int* responseData){
    458c:	0f 93       	push	r16
    458e:	1f 93       	push	r17
    4590:	cf 93       	push	r28
    4592:	df 93       	push	r29
    4594:	00 d0       	rcall	.+0      	; 0x4596 <getCertainSensor+0xa>
    4596:	cd b7       	in	r28, 0x3d	; 61
    4598:	de b7       	in	r29, 0x3e	; 62
    459a:	89 83       	std	Y+1, r24	; 0x01
    459c:	7b 83       	std	Y+3, r23	; 0x03
    459e:	6a 83       	std	Y+2, r22	; 0x02
   if(commandData < 6){
    45a0:	89 81       	ldd	r24, Y+1	; 0x01
    45a2:	86 30       	cpi	r24, 0x06	; 6
    45a4:	a4 f4       	brge	.+40     	; 0x45ce <getCertainSensor+0x42>
      responseData[commandData] = getSonarData(commandData);
    45a6:	89 81       	ldd	r24, Y+1	; 0x01
    45a8:	99 27       	eor	r25, r25
    45aa:	87 fd       	sbrc	r24, 7
    45ac:	90 95       	com	r25
    45ae:	88 0f       	add	r24, r24
    45b0:	99 1f       	adc	r25, r25
    45b2:	2a 81       	ldd	r18, Y+2	; 0x02
    45b4:	3b 81       	ldd	r19, Y+3	; 0x03
    45b6:	89 01       	movw	r16, r18
    45b8:	08 0f       	add	r16, r24
    45ba:	19 1f       	adc	r17, r25
    45bc:	89 81       	ldd	r24, Y+1	; 0x01
    45be:	99 27       	eor	r25, r25
    45c0:	87 fd       	sbrc	r24, 7
    45c2:	90 95       	com	r25
    45c4:	0e 94 da 21 	call	0x43b4	; 0x43b4 <getSonarData>
    45c8:	f8 01       	movw	r30, r16
    45ca:	91 83       	std	Z+1, r25	; 0x01
    45cc:	80 83       	st	Z, r24
   }
}
    45ce:	0f 90       	pop	r0
    45d0:	0f 90       	pop	r0
    45d2:	0f 90       	pop	r0
    45d4:	df 91       	pop	r29
    45d6:	cf 91       	pop	r28
    45d8:	1f 91       	pop	r17
    45da:	0f 91       	pop	r16
    45dc:	08 95       	ret

000045de <getSensorGroup>:

char getSensorGroup(char commandData,int* responseData){
    45de:	0f 93       	push	r16
    45e0:	1f 93       	push	r17
    45e2:	cf 93       	push	r28
    45e4:	df 93       	push	r29
    45e6:	00 d0       	rcall	.+0      	; 0x45e8 <getSensorGroup+0xa>
    45e8:	cd b7       	in	r28, 0x3d	; 61
    45ea:	de b7       	in	r29, 0x3e	; 62
    45ec:	89 83       	std	Y+1, r24	; 0x01
    45ee:	7b 83       	std	Y+3, r23	; 0x03
    45f0:	6a 83       	std	Y+2, r22	; 0x02

   switch(commandData){
    45f2:	89 81       	ldd	r24, Y+1	; 0x01
    45f4:	99 27       	eor	r25, r25
    45f6:	87 fd       	sbrc	r24, 7
    45f8:	90 95       	com	r25
    45fa:	81 30       	cpi	r24, 0x01	; 1
    45fc:	91 05       	cpc	r25, r1
    45fe:	e9 f0       	breq	.+58     	; 0x463a <getSensorGroup+0x5c>
    4600:	82 30       	cpi	r24, 0x02	; 2
    4602:	91 05       	cpc	r25, r1
    4604:	89 f1       	breq	.+98     	; 0x4668 <getSensorGroup+0x8a>
    4606:	00 97       	sbiw	r24, 0x00	; 0
    4608:	09 f0       	breq	.+2      	; 0x460c <getSensorGroup+0x2e>
    460a:	45 c0       	rjmp	.+138    	; 0x4696 <getSensorGroup+0xb8>
      case SONAR_GROUP_LEFT:
         responseData[0] = getSonarData(0);
    460c:	80 e0       	ldi	r24, 0x00	; 0
    460e:	90 e0       	ldi	r25, 0x00	; 0
    4610:	0e 94 da 21 	call	0x43b4	; 0x43b4 <getSonarData>
    4614:	9c 01       	movw	r18, r24
    4616:	8a 81       	ldd	r24, Y+2	; 0x02
    4618:	9b 81       	ldd	r25, Y+3	; 0x03
    461a:	fc 01       	movw	r30, r24
    461c:	31 83       	std	Z+1, r19	; 0x01
    461e:	20 83       	st	Z, r18
         responseData[1] = getSonarData(1);
    4620:	8a 81       	ldd	r24, Y+2	; 0x02
    4622:	9b 81       	ldd	r25, Y+3	; 0x03
    4624:	8c 01       	movw	r16, r24
    4626:	0e 5f       	subi	r16, 0xFE	; 254
    4628:	1f 4f       	sbci	r17, 0xFF	; 255
    462a:	81 e0       	ldi	r24, 0x01	; 1
    462c:	90 e0       	ldi	r25, 0x00	; 0
    462e:	0e 94 da 21 	call	0x43b4	; 0x43b4 <getSonarData>
    4632:	f8 01       	movw	r30, r16
    4634:	91 83       	std	Z+1, r25	; 0x01
    4636:	80 83       	st	Z, r24
         break;
    4638:	2e c0       	rjmp	.+92     	; 0x4696 <getSensorGroup+0xb8>
      case SONAR_GROUP_FRONT:
         responseData[0] = getSonarData(2);
    463a:	82 e0       	ldi	r24, 0x02	; 2
    463c:	90 e0       	ldi	r25, 0x00	; 0
    463e:	0e 94 da 21 	call	0x43b4	; 0x43b4 <getSonarData>
    4642:	9c 01       	movw	r18, r24
    4644:	8a 81       	ldd	r24, Y+2	; 0x02
    4646:	9b 81       	ldd	r25, Y+3	; 0x03
    4648:	fc 01       	movw	r30, r24
    464a:	31 83       	std	Z+1, r19	; 0x01
    464c:	20 83       	st	Z, r18
         responseData[1] = getSonarData(3);
    464e:	8a 81       	ldd	r24, Y+2	; 0x02
    4650:	9b 81       	ldd	r25, Y+3	; 0x03
    4652:	8c 01       	movw	r16, r24
    4654:	0e 5f       	subi	r16, 0xFE	; 254
    4656:	1f 4f       	sbci	r17, 0xFF	; 255
    4658:	83 e0       	ldi	r24, 0x03	; 3
    465a:	90 e0       	ldi	r25, 0x00	; 0
    465c:	0e 94 da 21 	call	0x43b4	; 0x43b4 <getSonarData>
    4660:	f8 01       	movw	r30, r16
    4662:	91 83       	std	Z+1, r25	; 0x01
    4664:	80 83       	st	Z, r24
         break;
    4666:	17 c0       	rjmp	.+46     	; 0x4696 <getSensorGroup+0xb8>
      case SONAR_GROUP_RIGHT:
         responseData[0] = getSonarData(4);
    4668:	84 e0       	ldi	r24, 0x04	; 4
    466a:	90 e0       	ldi	r25, 0x00	; 0
    466c:	0e 94 da 21 	call	0x43b4	; 0x43b4 <getSonarData>
    4670:	9c 01       	movw	r18, r24
    4672:	8a 81       	ldd	r24, Y+2	; 0x02
    4674:	9b 81       	ldd	r25, Y+3	; 0x03
    4676:	fc 01       	movw	r30, r24
    4678:	31 83       	std	Z+1, r19	; 0x01
    467a:	20 83       	st	Z, r18
         responseData[1] = getSonarData(5);
    467c:	8a 81       	ldd	r24, Y+2	; 0x02
    467e:	9b 81       	ldd	r25, Y+3	; 0x03
    4680:	8c 01       	movw	r16, r24
    4682:	0e 5f       	subi	r16, 0xFE	; 254
    4684:	1f 4f       	sbci	r17, 0xFF	; 255
    4686:	85 e0       	ldi	r24, 0x05	; 5
    4688:	90 e0       	ldi	r25, 0x00	; 0
    468a:	0e 94 da 21 	call	0x43b4	; 0x43b4 <getSonarData>
    468e:	f8 01       	movw	r30, r16
    4690:	91 83       	std	Z+1, r25	; 0x01
    4692:	80 83       	st	Z, r24
         break;
    4694:	00 00       	nop
   }

}
    4696:	0f 90       	pop	r0
    4698:	0f 90       	pop	r0
    469a:	0f 90       	pop	r0
    469c:	df 91       	pop	r29
    469e:	cf 91       	pop	r28
    46a0:	1f 91       	pop	r17
    46a2:	0f 91       	pop	r16
    46a4:	08 95       	ret

000046a6 <initSpeedController>:
//Speed Sensor group
#include <avr/io.h>
#include "spi.h"

void initSpeedController(){
    46a6:	cf 93       	push	r28
    46a8:	df 93       	push	r29
    46aa:	cd b7       	in	r28, 0x3d	; 61
    46ac:	de b7       	in	r29, 0x3e	; 62
	SPIsendShort(0x400F);
    46ae:	8f e0       	ldi	r24, 0x0F	; 15
    46b0:	90 e4       	ldi	r25, 0x40	; 64
    46b2:	0e 94 7f 26 	call	0x4cfe	; 0x4cfe <SPIsendShort>
}
    46b6:	df 91       	pop	r29
    46b8:	cf 91       	pop	r28
    46ba:	08 95       	ret

000046bc <setPot>:

void setPot(int value){
    46bc:	cf 93       	push	r28
    46be:	df 93       	push	r29
    46c0:	00 d0       	rcall	.+0      	; 0x46c2 <setPot+0x6>
    46c2:	1f 92       	push	r1
    46c4:	cd b7       	in	r28, 0x3d	; 61
    46c6:	de b7       	in	r29, 0x3e	; 62
    46c8:	9c 83       	std	Y+4, r25	; 0x04
    46ca:	8b 83       	std	Y+3, r24	; 0x03
	unsigned short data = 0;
    46cc:	1a 82       	std	Y+2, r1	; 0x02
    46ce:	19 82       	std	Y+1, r1	; 0x01
	data = value & 0xFF;
    46d0:	8b 81       	ldd	r24, Y+3	; 0x03
    46d2:	9c 81       	ldd	r25, Y+4	; 0x04
    46d4:	99 27       	eor	r25, r25
    46d6:	9a 83       	std	Y+2, r25	; 0x02
    46d8:	89 83       	std	Y+1, r24	; 0x01

	SPIsendShort(data);
    46da:	89 81       	ldd	r24, Y+1	; 0x01
    46dc:	9a 81       	ldd	r25, Y+2	; 0x02
    46de:	0e 94 7f 26 	call	0x4cfe	; 0x4cfe <SPIsendShort>
}
    46e2:	0f 90       	pop	r0
    46e4:	0f 90       	pop	r0
    46e6:	0f 90       	pop	r0
    46e8:	0f 90       	pop	r0
    46ea:	df 91       	pop	r29
    46ec:	cf 91       	pop	r28
    46ee:	08 95       	ret

000046f0 <decrementPot>:

void decrementPot(){
    46f0:	cf 93       	push	r28
    46f2:	df 93       	push	r29
    46f4:	cd b7       	in	r28, 0x3d	; 61
    46f6:	de b7       	in	r29, 0x3e	; 62
	SPIsendByte(0x06);
    46f8:	86 e0       	ldi	r24, 0x06	; 6
    46fa:	90 e0       	ldi	r25, 0x00	; 0
    46fc:	0e 94 39 26 	call	0x4c72	; 0x4c72 <SPIsendByte>
}
    4700:	df 91       	pop	r29
    4702:	cf 91       	pop	r28
    4704:	08 95       	ret

00004706 <incrementPot>:

void incrementPot(){
    4706:	cf 93       	push	r28
    4708:	df 93       	push	r29
    470a:	cd b7       	in	r28, 0x3d	; 61
    470c:	de b7       	in	r29, 0x3e	; 62
	SPIsendByte(0x0A);
    470e:	8a e0       	ldi	r24, 0x0A	; 10
    4710:	90 e0       	ldi	r25, 0x00	; 0
    4712:	0e 94 39 26 	call	0x4c72	; 0x4c72 <SPIsendByte>
}
    4716:	df 91       	pop	r29
    4718:	cf 91       	pop	r28
    471a:	08 95       	ret

0000471c <getSpeed>:

//get the speed of the vehicle
char getSpeed(char* sensorResponse) {
    471c:	cf 93       	push	r28
    471e:	df 93       	push	r29
    4720:	1f 92       	push	r1
    4722:	1f 92       	push	r1
    4724:	cd b7       	in	r28, 0x3d	; 61
    4726:	de b7       	in	r29, 0x3e	; 62
    4728:	9a 83       	std	Y+2, r25	; 0x02
    472a:	89 83       	std	Y+1, r24	; 0x01
   //store dummy speed value
   *sensorResponse = 0;
    472c:	89 81       	ldd	r24, Y+1	; 0x01
    472e:	9a 81       	ldd	r25, Y+2	; 0x02
    4730:	fc 01       	movw	r30, r24
    4732:	10 82       	st	Z, r1
   //return success
   return 1;
    4734:	81 e0       	ldi	r24, 0x01	; 1
}
    4736:	0f 90       	pop	r0
    4738:	0f 90       	pop	r0
    473a:	df 91       	pop	r29
    473c:	cf 91       	pop	r28
    473e:	08 95       	ret

00004740 <setSpeed>:

//will set just the speed of the wheels of the car
char setSpeed(unsigned char speedTarget) {
    4740:	cf 93       	push	r28
    4742:	df 93       	push	r29
    4744:	1f 92       	push	r1
    4746:	cd b7       	in	r28, 0x3d	; 61
    4748:	de b7       	in	r29, 0x3e	; 62
    474a:	89 83       	std	Y+1, r24	; 0x01
   //nothing done down here
   //return success
	if(speedTarget == 0){
    474c:	89 81       	ldd	r24, Y+1	; 0x01
    474e:	88 23       	and	r24, r24
    4750:	51 f4       	brne	.+20     	; 0x4766 <setSpeed+0x26>
		PORTA &= ~4;
    4752:	82 e2       	ldi	r24, 0x22	; 34
    4754:	90 e0       	ldi	r25, 0x00	; 0
    4756:	22 e2       	ldi	r18, 0x22	; 34
    4758:	30 e0       	ldi	r19, 0x00	; 0
    475a:	f9 01       	movw	r30, r18
    475c:	20 81       	ld	r18, Z
    475e:	2b 7f       	andi	r18, 0xFB	; 251
    4760:	fc 01       	movw	r30, r24
    4762:	20 83       	st	Z, r18
    4764:	09 c0       	rjmp	.+18     	; 0x4778 <setSpeed+0x38>
	} else {
		PORTA |= 4;
    4766:	82 e2       	ldi	r24, 0x22	; 34
    4768:	90 e0       	ldi	r25, 0x00	; 0
    476a:	22 e2       	ldi	r18, 0x22	; 34
    476c:	30 e0       	ldi	r19, 0x00	; 0
    476e:	f9 01       	movw	r30, r18
    4770:	20 81       	ld	r18, Z
    4772:	24 60       	ori	r18, 0x04	; 4
    4774:	fc 01       	movw	r30, r24
    4776:	20 83       	st	Z, r18
	}
	setPot(speedTarget);
    4778:	89 81       	ldd	r24, Y+1	; 0x01
    477a:	88 2f       	mov	r24, r24
    477c:	90 e0       	ldi	r25, 0x00	; 0
    477e:	0e 94 5e 23 	call	0x46bc	; 0x46bc <setPot>
   return 1;
    4782:	81 e0       	ldi	r24, 0x01	; 1
}
    4784:	0f 90       	pop	r0
    4786:	df 91       	pop	r29
    4788:	cf 91       	pop	r28
    478a:	08 95       	ret

0000478c <getLinearPotCallback>:

void printHex(int a);
void printNum(int a);
void USART_Write(char a);

void getLinearPotCallback(int data,void *parameters){
    478c:	cf 93       	push	r28
    478e:	df 93       	push	r29
    4790:	00 d0       	rcall	.+0      	; 0x4792 <getLinearPotCallback+0x6>
    4792:	1f 92       	push	r1
    4794:	cd b7       	in	r28, 0x3d	; 61
    4796:	de b7       	in	r29, 0x3e	; 62
    4798:	9a 83       	std	Y+2, r25	; 0x02
    479a:	89 83       	std	Y+1, r24	; 0x01
    479c:	7c 83       	std	Y+4, r23	; 0x04
    479e:	6b 83       	std	Y+3, r22	; 0x03
	wheelAngle = data / -4 + 74;
    47a0:	89 81       	ldd	r24, Y+1	; 0x01
    47a2:	9a 81       	ldd	r25, Y+2	; 0x02
    47a4:	99 23       	and	r25, r25
    47a6:	0c f4       	brge	.+2      	; 0x47aa <getLinearPotCallback+0x1e>
    47a8:	03 96       	adiw	r24, 0x03	; 3
    47aa:	95 95       	asr	r25
    47ac:	87 95       	ror	r24
    47ae:	95 95       	asr	r25
    47b0:	87 95       	ror	r24
    47b2:	91 95       	neg	r25
    47b4:	81 95       	neg	r24
    47b6:	91 09       	sbc	r25, r1
    47b8:	86 5b       	subi	r24, 0xB6	; 182
    47ba:	9f 4f       	sbci	r25, 0xFF	; 255
    47bc:	90 93 d8 1a 	sts	0x1AD8, r25
    47c0:	80 93 d7 1a 	sts	0x1AD7, r24
   //wheelAngle = data;
}
    47c4:	0f 90       	pop	r0
    47c6:	0f 90       	pop	r0
    47c8:	0f 90       	pop	r0
    47ca:	0f 90       	pop	r0
    47cc:	df 91       	pop	r29
    47ce:	cf 91       	pop	r28
    47d0:	08 95       	ret

000047d2 <initializeSteeringTimer>:

void initializeSteeringTimer(){
    47d2:	cf 93       	push	r28
    47d4:	df 93       	push	r29
    47d6:	cd b7       	in	r28, 0x3d	; 61
    47d8:	de b7       	in	r29, 0x3e	; 62
	
	//TCCR1A = (1 << COM1A1)|(1 << WGM11);
   TCCR5A = (1 << WGM51);
    47da:	80 e2       	ldi	r24, 0x20	; 32
    47dc:	91 e0       	ldi	r25, 0x01	; 1
    47de:	22 e0       	ldi	r18, 0x02	; 2
    47e0:	fc 01       	movw	r30, r24
    47e2:	20 83       	st	Z, r18
	TCCR5B = (1 << WGM52)|(1 << CS50);
    47e4:	81 e2       	ldi	r24, 0x21	; 33
    47e6:	91 e0       	ldi	r25, 0x01	; 1
    47e8:	29 e0       	ldi	r18, 0x09	; 9
    47ea:	fc 01       	movw	r30, r24
    47ec:	20 83       	st	Z, r18
	TCCR5C = 0;
    47ee:	82 e2       	ldi	r24, 0x22	; 34
    47f0:	91 e0       	ldi	r25, 0x01	; 1
    47f2:	fc 01       	movw	r30, r24
    47f4:	10 82       	st	Z, r1

   OCR5AH = 0xFF;
    47f6:	89 e2       	ldi	r24, 0x29	; 41
    47f8:	91 e0       	ldi	r25, 0x01	; 1
    47fa:	2f ef       	ldi	r18, 0xFF	; 255
    47fc:	fc 01       	movw	r30, r24
    47fe:	20 83       	st	Z, r18
   OCR5AL = 0xFF;
    4800:	88 e2       	ldi	r24, 0x28	; 40
    4802:	91 e0       	ldi	r25, 0x01	; 1
    4804:	2f ef       	ldi	r18, 0xFF	; 255
    4806:	fc 01       	movw	r30, r24
    4808:	20 83       	st	Z, r18

   TIMSK5 = (1 << OCIE5A)|(1 << TOIE5);
    480a:	83 e7       	ldi	r24, 0x73	; 115
    480c:	90 e0       	ldi	r25, 0x00	; 0
    480e:	23 e0       	ldi	r18, 0x03	; 3
    4810:	fc 01       	movw	r30, r24
    4812:	20 83       	st	Z, r18

}
    4814:	df 91       	pop	r29
    4816:	cf 91       	pop	r28
    4818:	08 95       	ret

0000481a <__vector_50>:

ISR(TIMER5_OVF_vect) {
    481a:	1f 92       	push	r1
    481c:	0f 92       	push	r0
    481e:	00 90 5f 00 	lds	r0, 0x005F
    4822:	0f 92       	push	r0
    4824:	11 24       	eor	r1, r1
    4826:	00 90 5b 00 	lds	r0, 0x005B
    482a:	0f 92       	push	r0
    482c:	2f 93       	push	r18
    482e:	3f 93       	push	r19
    4830:	8f 93       	push	r24
    4832:	9f 93       	push	r25
    4834:	ef 93       	push	r30
    4836:	ff 93       	push	r31
    4838:	cf 93       	push	r28
    483a:	df 93       	push	r29
    483c:	cd b7       	in	r28, 0x3d	; 61
    483e:	de b7       	in	r29, 0x3e	; 62

   if(steeringDir == -1) {
    4840:	80 91 d9 1a 	lds	r24, 0x1AD9
    4844:	90 91 da 1a 	lds	r25, 0x1ADA
    4848:	8f 3f       	cpi	r24, 0xFF	; 255
    484a:	2f ef       	ldi	r18, 0xFF	; 255
    484c:	92 07       	cpc	r25, r18
    484e:	99 f4       	brne	.+38     	; 0x4876 <__vector_50+0x5c>
      PORTB &= ~(1 << PB5);
    4850:	85 e2       	ldi	r24, 0x25	; 37
    4852:	90 e0       	ldi	r25, 0x00	; 0
    4854:	25 e2       	ldi	r18, 0x25	; 37
    4856:	30 e0       	ldi	r19, 0x00	; 0
    4858:	f9 01       	movw	r30, r18
    485a:	20 81       	ld	r18, Z
    485c:	2f 7d       	andi	r18, 0xDF	; 223
    485e:	fc 01       	movw	r30, r24
    4860:	20 83       	st	Z, r18
      PORTB |= (1 << PB4);
    4862:	85 e2       	ldi	r24, 0x25	; 37
    4864:	90 e0       	ldi	r25, 0x00	; 0
    4866:	25 e2       	ldi	r18, 0x25	; 37
    4868:	30 e0       	ldi	r19, 0x00	; 0
    486a:	f9 01       	movw	r30, r18
    486c:	20 81       	ld	r18, Z
    486e:	20 61       	ori	r18, 0x10	; 16
    4870:	fc 01       	movw	r30, r24
    4872:	20 83       	st	Z, r18
    4874:	23 c0       	rjmp	.+70     	; 0x48bc <__vector_50+0xa2>
   } else if(steeringDir == 1) {
    4876:	80 91 d9 1a 	lds	r24, 0x1AD9
    487a:	90 91 da 1a 	lds	r25, 0x1ADA
    487e:	81 30       	cpi	r24, 0x01	; 1
    4880:	91 05       	cpc	r25, r1
    4882:	99 f4       	brne	.+38     	; 0x48aa <__vector_50+0x90>
      PORTB &= ~(1 << PB4);
    4884:	85 e2       	ldi	r24, 0x25	; 37
    4886:	90 e0       	ldi	r25, 0x00	; 0
    4888:	25 e2       	ldi	r18, 0x25	; 37
    488a:	30 e0       	ldi	r19, 0x00	; 0
    488c:	f9 01       	movw	r30, r18
    488e:	20 81       	ld	r18, Z
    4890:	2f 7e       	andi	r18, 0xEF	; 239
    4892:	fc 01       	movw	r30, r24
    4894:	20 83       	st	Z, r18
      PORTB |= (1 << PB5);
    4896:	85 e2       	ldi	r24, 0x25	; 37
    4898:	90 e0       	ldi	r25, 0x00	; 0
    489a:	25 e2       	ldi	r18, 0x25	; 37
    489c:	30 e0       	ldi	r19, 0x00	; 0
    489e:	f9 01       	movw	r30, r18
    48a0:	20 81       	ld	r18, Z
    48a2:	20 62       	ori	r18, 0x20	; 32
    48a4:	fc 01       	movw	r30, r24
    48a6:	20 83       	st	Z, r18
    48a8:	09 c0       	rjmp	.+18     	; 0x48bc <__vector_50+0xa2>
   } else {
      PORTB &= ~((1 << PB4) | (1 << PB5));
    48aa:	85 e2       	ldi	r24, 0x25	; 37
    48ac:	90 e0       	ldi	r25, 0x00	; 0
    48ae:	25 e2       	ldi	r18, 0x25	; 37
    48b0:	30 e0       	ldi	r19, 0x00	; 0
    48b2:	f9 01       	movw	r30, r18
    48b4:	20 81       	ld	r18, Z
    48b6:	2f 7c       	andi	r18, 0xCF	; 207
    48b8:	fc 01       	movw	r30, r24
    48ba:	20 83       	st	Z, r18
   }
}
    48bc:	df 91       	pop	r29
    48be:	cf 91       	pop	r28
    48c0:	ff 91       	pop	r31
    48c2:	ef 91       	pop	r30
    48c4:	9f 91       	pop	r25
    48c6:	8f 91       	pop	r24
    48c8:	3f 91       	pop	r19
    48ca:	2f 91       	pop	r18
    48cc:	0f 90       	pop	r0
    48ce:	00 92 5b 00 	sts	0x005B, r0
    48d2:	0f 90       	pop	r0
    48d4:	00 92 5f 00 	sts	0x005F, r0
    48d8:	0f 90       	pop	r0
    48da:	1f 90       	pop	r1
    48dc:	18 95       	reti

000048de <__vector_47>:

ISR(TIMER5_COMPA_vect) {
    48de:	1f 92       	push	r1
    48e0:	0f 92       	push	r0
    48e2:	00 90 5f 00 	lds	r0, 0x005F
    48e6:	0f 92       	push	r0
    48e8:	11 24       	eor	r1, r1
    48ea:	00 90 5b 00 	lds	r0, 0x005B
    48ee:	0f 92       	push	r0
    48f0:	2f 93       	push	r18
    48f2:	3f 93       	push	r19
    48f4:	8f 93       	push	r24
    48f6:	9f 93       	push	r25
    48f8:	ef 93       	push	r30
    48fa:	ff 93       	push	r31
    48fc:	cf 93       	push	r28
    48fe:	df 93       	push	r29
    4900:	cd b7       	in	r28, 0x3d	; 61
    4902:	de b7       	in	r29, 0x3e	; 62
   PORTB &= ~((1 << PB4)|(1 << PB5));
    4904:	85 e2       	ldi	r24, 0x25	; 37
    4906:	90 e0       	ldi	r25, 0x00	; 0
    4908:	25 e2       	ldi	r18, 0x25	; 37
    490a:	30 e0       	ldi	r19, 0x00	; 0
    490c:	f9 01       	movw	r30, r18
    490e:	20 81       	ld	r18, Z
    4910:	2f 7c       	andi	r18, 0xCF	; 207
    4912:	fc 01       	movw	r30, r24
    4914:	20 83       	st	Z, r18
}
    4916:	df 91       	pop	r29
    4918:	cf 91       	pop	r28
    491a:	ff 91       	pop	r31
    491c:	ef 91       	pop	r30
    491e:	9f 91       	pop	r25
    4920:	8f 91       	pop	r24
    4922:	3f 91       	pop	r19
    4924:	2f 91       	pop	r18
    4926:	0f 90       	pop	r0
    4928:	00 92 5b 00 	sts	0x005B, r0
    492c:	0f 90       	pop	r0
    492e:	00 92 5f 00 	sts	0x005F, r0
    4932:	0f 90       	pop	r0
    4934:	1f 90       	pop	r1
    4936:	18 95       	reti

00004938 <setSteeringPWMSpeed>:

void setSteeringPWMSpeed(int spd){
    4938:	cf 93       	push	r28
    493a:	df 93       	push	r29
    493c:	1f 92       	push	r1
    493e:	1f 92       	push	r1
    4940:	cd b7       	in	r28, 0x3d	; 61
    4942:	de b7       	in	r29, 0x3e	; 62
    4944:	9a 83       	std	Y+2, r25	; 0x02
    4946:	89 83       	std	Y+1, r24	; 0x01
   steeringSpd = spd * steeringDir;
    4948:	40 91 d9 1a 	lds	r20, 0x1AD9
    494c:	50 91 da 1a 	lds	r21, 0x1ADA
    4950:	29 81       	ldd	r18, Y+1	; 0x01
    4952:	3a 81       	ldd	r19, Y+2	; 0x02
    4954:	42 9f       	mul	r20, r18
    4956:	c0 01       	movw	r24, r0
    4958:	43 9f       	mul	r20, r19
    495a:	90 0d       	add	r25, r0
    495c:	52 9f       	mul	r21, r18
    495e:	90 0d       	add	r25, r0
    4960:	11 24       	eor	r1, r1
    4962:	90 93 dc 1a 	sts	0x1ADC, r25
    4966:	80 93 db 1a 	sts	0x1ADB, r24

   OCR5AH = spd >> 8;
    496a:	89 e2       	ldi	r24, 0x29	; 41
    496c:	91 e0       	ldi	r25, 0x01	; 1
    496e:	29 81       	ldd	r18, Y+1	; 0x01
    4970:	3a 81       	ldd	r19, Y+2	; 0x02
    4972:	23 2f       	mov	r18, r19
    4974:	33 0f       	add	r19, r19
    4976:	33 0b       	sbc	r19, r19
    4978:	fc 01       	movw	r30, r24
    497a:	20 83       	st	Z, r18
   OCR5AL = spd & 0xFF;
    497c:	88 e2       	ldi	r24, 0x28	; 40
    497e:	91 e0       	ldi	r25, 0x01	; 1
    4980:	29 81       	ldd	r18, Y+1	; 0x01
    4982:	fc 01       	movw	r30, r24
    4984:	20 83       	st	Z, r18
      STEERING_LEFT_CMPH = 0;
      STEERING_LEFT_CMPL = 0;
      STEERING_RIGHT_CMPH = 0;
      STEERING_RIGHT_CMPL = 0;
   }*/
}
    4986:	0f 90       	pop	r0
    4988:	0f 90       	pop	r0
    498a:	df 91       	pop	r29
    498c:	cf 91       	pop	r28
    498e:	08 95       	ret

00004990 <setSteeringDirection>:



void setSteeringDirection(int dir){
    4990:	cf 93       	push	r28
    4992:	df 93       	push	r29
    4994:	1f 92       	push	r1
    4996:	1f 92       	push	r1
    4998:	cd b7       	in	r28, 0x3d	; 61
    499a:	de b7       	in	r29, 0x3e	; 62
    499c:	9a 83       	std	Y+2, r25	; 0x02
    499e:	89 83       	std	Y+1, r24	; 0x01
	case -1:
		STEERING_PORT &= ~STEERING_RIGHT;
		STEERING_PORT |= STEERING_LEFT;
		break;
	}*/
   steeringDir = dir;
    49a0:	89 81       	ldd	r24, Y+1	; 0x01
    49a2:	9a 81       	ldd	r25, Y+2	; 0x02
    49a4:	90 93 da 1a 	sts	0x1ADA, r25
    49a8:	80 93 d9 1a 	sts	0x1AD9, r24
}
    49ac:	0f 90       	pop	r0
    49ae:	0f 90       	pop	r0
    49b0:	df 91       	pop	r29
    49b2:	cf 91       	pop	r28
    49b4:	08 95       	ret

000049b6 <setAngle>:

//JUST SETS ANGLE TARGET. Actual angle changing is lower level
char setAngle(char angleTarget) {
    49b6:	cf 93       	push	r28
    49b8:	df 93       	push	r29
    49ba:	1f 92       	push	r1
    49bc:	cd b7       	in	r28, 0x3d	; 61
    49be:	de b7       	in	r29, 0x3e	; 62
    49c0:	89 83       	std	Y+1, r24	; 0x01
   //dummy function, nothing will happen for now...
   //return success
	steeringTarget = angleTarget;
    49c2:	89 81       	ldd	r24, Y+1	; 0x01
    49c4:	99 27       	eor	r25, r25
    49c6:	87 fd       	sbrc	r24, 7
    49c8:	90 95       	com	r25
    49ca:	90 93 d6 1a 	sts	0x1AD6, r25
    49ce:	80 93 d5 1a 	sts	0x1AD5, r24
   return 1;
    49d2:	81 e0       	ldi	r24, 0x01	; 1
}
    49d4:	0f 90       	pop	r0
    49d6:	df 91       	pop	r29
    49d8:	cf 91       	pop	r28
    49da:	08 95       	ret

000049dc <getAngle>:

//get the current angle of the steering system
char getAngle(char* sensorResponse) {
    49dc:	cf 93       	push	r28
    49de:	df 93       	push	r29
    49e0:	1f 92       	push	r1
    49e2:	1f 92       	push	r1
    49e4:	cd b7       	in	r28, 0x3d	; 61
    49e6:	de b7       	in	r29, 0x3e	; 62
    49e8:	9a 83       	std	Y+2, r25	; 0x02
    49ea:	89 83       	std	Y+1, r24	; 0x01
   //store fake angle reading
   *sensorResponse = 0;
    49ec:	89 81       	ldd	r24, Y+1	; 0x01
    49ee:	9a 81       	ldd	r25, Y+2	; 0x02
    49f0:	fc 01       	movw	r30, r24
    49f2:	10 82       	st	Z, r1
   //return success
   return 1;
    49f4:	81 e0       	ldi	r24, 0x01	; 1
}
    49f6:	0f 90       	pop	r0
    49f8:	0f 90       	pop	r0
    49fa:	df 91       	pop	r29
    49fc:	cf 91       	pop	r28
    49fe:	08 95       	ret

00004a00 <getDesiredAngle>:

//get the angle target. argument name is sensorResponse for the sake of consistancy
char getDesiredAngle(char* sensorResponse) {
    4a00:	cf 93       	push	r28
    4a02:	df 93       	push	r29
    4a04:	1f 92       	push	r1
    4a06:	1f 92       	push	r1
    4a08:	cd b7       	in	r28, 0x3d	; 61
    4a0a:	de b7       	in	r29, 0x3e	; 62
    4a0c:	9a 83       	std	Y+2, r25	; 0x02
    4a0e:	89 83       	std	Y+1, r24	; 0x01
   //fake response
   *sensorResponse = 0;
    4a10:	89 81       	ldd	r24, Y+1	; 0x01
    4a12:	9a 81       	ldd	r25, Y+2	; 0x02
    4a14:	fc 01       	movw	r30, r24
    4a16:	10 82       	st	Z, r1
   //return success
   return 1;
    4a18:	81 e0       	ldi	r24, 0x01	; 1
}
    4a1a:	0f 90       	pop	r0
    4a1c:	0f 90       	pop	r0
    4a1e:	df 91       	pop	r29
    4a20:	cf 91       	pop	r28
    4a22:	08 95       	ret

00004a24 <changePID>:

//change the PID controller
char changePID(char P, char I, char D) {
    4a24:	cf 93       	push	r28
    4a26:	df 93       	push	r29
    4a28:	00 d0       	rcall	.+0      	; 0x4a2a <changePID+0x6>
    4a2a:	cd b7       	in	r28, 0x3d	; 61
    4a2c:	de b7       	in	r29, 0x3e	; 62
    4a2e:	89 83       	std	Y+1, r24	; 0x01
    4a30:	6a 83       	std	Y+2, r22	; 0x02
    4a32:	4b 83       	std	Y+3, r20	; 0x03
   //dummy function, nothing happens
   //return success
   return 1;
    4a34:	81 e0       	ldi	r24, 0x01	; 1
}
    4a36:	0f 90       	pop	r0
    4a38:	0f 90       	pop	r0
    4a3a:	0f 90       	pop	r0
    4a3c:	df 91       	pop	r29
    4a3e:	cf 91       	pop	r28
    4a40:	08 95       	ret

00004a42 <setLimits>:

//not sure what this does. Also not sure why upper and lower are separated
//but its in the specs so...
char setLimits(char upper, char lower) {
    4a42:	cf 93       	push	r28
    4a44:	df 93       	push	r29
    4a46:	1f 92       	push	r1
    4a48:	1f 92       	push	r1
    4a4a:	cd b7       	in	r28, 0x3d	; 61
    4a4c:	de b7       	in	r29, 0x3e	; 62
    4a4e:	89 83       	std	Y+1, r24	; 0x01
    4a50:	6a 83       	std	Y+2, r22	; 0x02
   //dummy function, nothing happens
   //return success
   return 1;
    4a52:	81 e0       	ldi	r24, 0x01	; 1
}
    4a54:	0f 90       	pop	r0
    4a56:	0f 90       	pop	r0
    4a58:	df 91       	pop	r29
    4a5a:	cf 91       	pop	r28
    4a5c:	08 95       	ret

00004a5e <printWheelAngle>:

void printWheelAngle() {
    4a5e:	cf 93       	push	r28
    4a60:	df 93       	push	r29
    4a62:	cd b7       	in	r28, 0x3d	; 61
    4a64:	de b7       	in	r29, 0x3e	; 62
   if(wheelAngle & 0x1000) {
    4a66:	80 91 d7 1a 	lds	r24, 0x1AD7
    4a6a:	90 91 d8 1a 	lds	r25, 0x1AD8
    4a6e:	88 27       	eor	r24, r24
    4a70:	90 71       	andi	r25, 0x10	; 16
    4a72:	00 97       	sbiw	r24, 0x00	; 0
    4a74:	71 f0       	breq	.+28     	; 0x4a92 <printWheelAngle+0x34>
      USART_Write('-');
    4a76:	8d e2       	ldi	r24, 0x2D	; 45
    4a78:	0e 94 fc 1a 	call	0x35f8	; 0x35f8 <USART_Write>
      wheelAngle *= -1;
    4a7c:	80 91 d7 1a 	lds	r24, 0x1AD7
    4a80:	90 91 d8 1a 	lds	r25, 0x1AD8
    4a84:	91 95       	neg	r25
    4a86:	81 95       	neg	r24
    4a88:	91 09       	sbc	r25, r1
    4a8a:	90 93 d8 1a 	sts	0x1AD8, r25
    4a8e:	80 93 d7 1a 	sts	0x1AD7, r24
   }      
   printNum(wheelAngle);
    4a92:	80 91 d7 1a 	lds	r24, 0x1AD7
    4a96:	90 91 d8 1a 	lds	r25, 0x1AD8
    4a9a:	0e 94 bc 01 	call	0x378	; 0x378 <printNum>
   USART_Write('\r');
    4a9e:	8d e0       	ldi	r24, 0x0D	; 13
    4aa0:	0e 94 fc 1a 	call	0x35f8	; 0x35f8 <USART_Write>
   USART_Write('\n');
    4aa4:	8a e0       	ldi	r24, 0x0A	; 10
    4aa6:	0e 94 fc 1a 	call	0x35f8	; 0x35f8 <USART_Write>
}
    4aaa:	df 91       	pop	r29
    4aac:	cf 91       	pop	r28
    4aae:	08 95       	ret

00004ab0 <vTaskSteer>:

void vTaskSteer(void* parameters){
    4ab0:	cf 93       	push	r28
    4ab2:	df 93       	push	r29
    4ab4:	00 d0       	rcall	.+0      	; 0x4ab6 <vTaskSteer+0x6>
    4ab6:	00 d0       	rcall	.+0      	; 0x4ab8 <vTaskSteer+0x8>
    4ab8:	cd b7       	in	r28, 0x3d	; 61
    4aba:	de b7       	in	r29, 0x3e	; 62
    4abc:	9e 83       	std	Y+6, r25	; 0x06
    4abe:	8d 83       	std	Y+5, r24	; 0x05


	addADCDevice(0,ADC_OPT_PRECISION_HIGH,getLinearPotCallback,0);
    4ac0:	20 e0       	ldi	r18, 0x00	; 0
    4ac2:	30 e0       	ldi	r19, 0x00	; 0
    4ac4:	46 ec       	ldi	r20, 0xC6	; 198
    4ac6:	53 e2       	ldi	r21, 0x23	; 35
    4ac8:	60 e0       	ldi	r22, 0x00	; 0
    4aca:	70 e0       	ldi	r23, 0x00	; 0
    4acc:	80 e0       	ldi	r24, 0x00	; 0
    4ace:	90 e0       	ldi	r25, 0x00	; 0
    4ad0:	0e 94 b6 28 	call	0x516c	; 0x516c <addADCDevice>

	int pConst = 40;
    4ad4:	88 e2       	ldi	r24, 0x28	; 40
    4ad6:	90 e0       	ldi	r25, 0x00	; 0
    4ad8:	9c 83       	std	Y+4, r25	; 0x04
    4ada:	8b 83       	std	Y+3, r24	; 0x03
	int adjust;

	steeringTarget = 0;
    4adc:	10 92 d6 1a 	sts	0x1AD6, r1
    4ae0:	10 92 d5 1a 	sts	0x1AD5, r1
	while(1){
      
	   adjust = pConst * (steeringTarget - wheelAngle);
    4ae4:	20 91 d5 1a 	lds	r18, 0x1AD5
    4ae8:	30 91 d6 1a 	lds	r19, 0x1AD6
    4aec:	80 91 d7 1a 	lds	r24, 0x1AD7
    4af0:	90 91 d8 1a 	lds	r25, 0x1AD8
    4af4:	a9 01       	movw	r20, r18
    4af6:	48 1b       	sub	r20, r24
    4af8:	59 0b       	sbc	r21, r25
    4afa:	2b 81       	ldd	r18, Y+3	; 0x03
    4afc:	3c 81       	ldd	r19, Y+4	; 0x04
    4afe:	42 9f       	mul	r20, r18
    4b00:	c0 01       	movw	r24, r0
    4b02:	43 9f       	mul	r20, r19
    4b04:	90 0d       	add	r25, r0
    4b06:	52 9f       	mul	r21, r18
    4b08:	90 0d       	add	r25, r0
    4b0a:	11 24       	eor	r1, r1
    4b0c:	9a 83       	std	Y+2, r25	; 0x02
    4b0e:	89 83       	std	Y+1, r24	; 0x01
	   if(adjust < steeringTarget - 5){
    4b10:	80 91 d5 1a 	lds	r24, 0x1AD5
    4b14:	90 91 d6 1a 	lds	r25, 0x1AD6
    4b18:	9c 01       	movw	r18, r24
    4b1a:	25 50       	subi	r18, 0x05	; 5
    4b1c:	31 09       	sbc	r19, r1
    4b1e:	89 81       	ldd	r24, Y+1	; 0x01
    4b20:	9a 81       	ldd	r25, Y+2	; 0x02
    4b22:	82 17       	cp	r24, r18
    4b24:	93 07       	cpc	r25, r19
    4b26:	64 f4       	brge	.+24     	; 0x4b40 <vTaskSteer+0x90>
	      setSteeringDirection(-1);
    4b28:	8f ef       	ldi	r24, 0xFF	; 255
    4b2a:	9f ef       	ldi	r25, 0xFF	; 255
    4b2c:	0e 94 c8 24 	call	0x4990	; 0x4990 <setSteeringDirection>
         adjust *= -1;
    4b30:	89 81       	ldd	r24, Y+1	; 0x01
    4b32:	9a 81       	ldd	r25, Y+2	; 0x02
    4b34:	91 95       	neg	r25
    4b36:	81 95       	neg	r24
    4b38:	91 09       	sbc	r25, r1
    4b3a:	9a 83       	std	Y+2, r25	; 0x02
    4b3c:	89 83       	std	Y+1, r24	; 0x01
    4b3e:	15 c0       	rjmp	.+42     	; 0x4b6a <vTaskSteer+0xba>
	   } else if (adjust > steeringTarget + 5){
    4b40:	80 91 d5 1a 	lds	r24, 0x1AD5
    4b44:	90 91 d6 1a 	lds	r25, 0x1AD6
    4b48:	9c 01       	movw	r18, r24
    4b4a:	2b 5f       	subi	r18, 0xFB	; 251
    4b4c:	3f 4f       	sbci	r19, 0xFF	; 255
    4b4e:	89 81       	ldd	r24, Y+1	; 0x01
    4b50:	9a 81       	ldd	r25, Y+2	; 0x02
    4b52:	28 17       	cp	r18, r24
    4b54:	39 07       	cpc	r19, r25
    4b56:	2c f4       	brge	.+10     	; 0x4b62 <vTaskSteer+0xb2>
	      setSteeringDirection(1);
    4b58:	81 e0       	ldi	r24, 0x01	; 1
    4b5a:	90 e0       	ldi	r25, 0x00	; 0
    4b5c:	0e 94 c8 24 	call	0x4990	; 0x4990 <setSteeringDirection>
    4b60:	04 c0       	rjmp	.+8      	; 0x4b6a <vTaskSteer+0xba>
	   } else {
	      setSteeringDirection(0);
    4b62:	80 e0       	ldi	r24, 0x00	; 0
    4b64:	90 e0       	ldi	r25, 0x00	; 0
    4b66:	0e 94 c8 24 	call	0x4990	; 0x4990 <setSteeringDirection>
	      //steeringTarget = wheelAngle;
	   }
      setSteeringPWMSpeed(adjust + 50);
    4b6a:	89 81       	ldd	r24, Y+1	; 0x01
    4b6c:	9a 81       	ldd	r25, Y+2	; 0x02
    4b6e:	c2 96       	adiw	r24, 0x32	; 50
    4b70:	0e 94 9c 24 	call	0x4938	; 0x4938 <setSteeringPWMSpeed>
      printNum(adjust + 50);
    4b74:	89 81       	ldd	r24, Y+1	; 0x01
    4b76:	9a 81       	ldd	r25, Y+2	; 0x02
    4b78:	c2 96       	adiw	r24, 0x32	; 50
    4b7a:	0e 94 bc 01 	call	0x378	; 0x378 <printNum>
      USART_Write(' ');
    4b7e:	80 e2       	ldi	r24, 0x20	; 32
    4b80:	0e 94 fc 1a 	call	0x35f8	; 0x35f8 <USART_Write>
      printWheelAngle();
    4b84:	0e 94 2f 25 	call	0x4a5e	; 0x4a5e <printWheelAngle>
 
	   vTaskDelay(10);
    4b88:	8a e0       	ldi	r24, 0x0A	; 10
    4b8a:	90 e0       	ldi	r25, 0x00	; 0
    4b8c:	0e 94 1d 05 	call	0xa3a	; 0xa3a <vTaskDelay>
	}
    4b90:	a9 cf       	rjmp	.-174    	; 0x4ae4 <vTaskSteer+0x34>

00004b92 <initializeSPI>:
const static int mosi_pin = 2;
const static int miso_pin = 3;
const static int sck_pin = 1;
const static int ss_pin = 0; 

void initializeSPI(){
    4b92:	cf 93       	push	r28
    4b94:	df 93       	push	r29
    4b96:	cd b7       	in	r28, 0x3d	; 61
    4b98:	de b7       	in	r29, 0x3e	; 62
	SPCR = (1 << SPE)|(1 << MSTR)|(1 << SPR1)|(1 << SPR0);
    4b9a:	8c e4       	ldi	r24, 0x4C	; 76
    4b9c:	90 e0       	ldi	r25, 0x00	; 0
    4b9e:	23 e5       	ldi	r18, 0x53	; 83
    4ba0:	fc 01       	movw	r30, r24
    4ba2:	20 83       	st	Z, r18
	DDRB |= (1 << ss_pin)|(1 << sck_pin)|(1 << mosi_pin);
    4ba4:	84 e2       	ldi	r24, 0x24	; 36
    4ba6:	90 e0       	ldi	r25, 0x00	; 0
    4ba8:	24 e2       	ldi	r18, 0x24	; 36
    4baa:	30 e0       	ldi	r19, 0x00	; 0
    4bac:	f9 01       	movw	r30, r18
    4bae:	20 81       	ld	r18, Z
    4bb0:	62 2f       	mov	r22, r18
    4bb2:	40 e0       	ldi	r20, 0x00	; 0
    4bb4:	50 e0       	ldi	r21, 0x00	; 0
    4bb6:	21 e0       	ldi	r18, 0x01	; 1
    4bb8:	30 e0       	ldi	r19, 0x00	; 0
    4bba:	02 c0       	rjmp	.+4      	; 0x4bc0 <initializeSPI+0x2e>
    4bbc:	22 0f       	add	r18, r18
    4bbe:	33 1f       	adc	r19, r19
    4bc0:	4a 95       	dec	r20
    4bc2:	e2 f7       	brpl	.-8      	; 0x4bbc <initializeSPI+0x2a>
    4bc4:	72 2f       	mov	r23, r18
    4bc6:	41 e0       	ldi	r20, 0x01	; 1
    4bc8:	50 e0       	ldi	r21, 0x00	; 0
    4bca:	21 e0       	ldi	r18, 0x01	; 1
    4bcc:	30 e0       	ldi	r19, 0x00	; 0
    4bce:	02 c0       	rjmp	.+4      	; 0x4bd4 <initializeSPI+0x42>
    4bd0:	22 0f       	add	r18, r18
    4bd2:	33 1f       	adc	r19, r19
    4bd4:	4a 95       	dec	r20
    4bd6:	e2 f7       	brpl	.-8      	; 0x4bd0 <initializeSPI+0x3e>
    4bd8:	72 2b       	or	r23, r18
    4bda:	42 e0       	ldi	r20, 0x02	; 2
    4bdc:	50 e0       	ldi	r21, 0x00	; 0
    4bde:	21 e0       	ldi	r18, 0x01	; 1
    4be0:	30 e0       	ldi	r19, 0x00	; 0
    4be2:	02 c0       	rjmp	.+4      	; 0x4be8 <initializeSPI+0x56>
    4be4:	22 0f       	add	r18, r18
    4be6:	33 1f       	adc	r19, r19
    4be8:	4a 95       	dec	r20
    4bea:	e2 f7       	brpl	.-8      	; 0x4be4 <initializeSPI+0x52>
    4bec:	27 2b       	or	r18, r23
    4bee:	26 2b       	or	r18, r22
    4bf0:	fc 01       	movw	r30, r24
    4bf2:	20 83       	st	Z, r18
	DDRB &= ~(1 << miso_pin);
    4bf4:	84 e2       	ldi	r24, 0x24	; 36
    4bf6:	90 e0       	ldi	r25, 0x00	; 0
    4bf8:	24 e2       	ldi	r18, 0x24	; 36
    4bfa:	30 e0       	ldi	r19, 0x00	; 0
    4bfc:	f9 01       	movw	r30, r18
    4bfe:	20 81       	ld	r18, Z
    4c00:	62 2f       	mov	r22, r18
    4c02:	43 e0       	ldi	r20, 0x03	; 3
    4c04:	50 e0       	ldi	r21, 0x00	; 0
    4c06:	21 e0       	ldi	r18, 0x01	; 1
    4c08:	30 e0       	ldi	r19, 0x00	; 0
    4c0a:	02 c0       	rjmp	.+4      	; 0x4c10 <initializeSPI+0x7e>
    4c0c:	22 0f       	add	r18, r18
    4c0e:	33 1f       	adc	r19, r19
    4c10:	4a 95       	dec	r20
    4c12:	e2 f7       	brpl	.-8      	; 0x4c0c <initializeSPI+0x7a>
    4c14:	20 95       	com	r18
    4c16:	26 23       	and	r18, r22
    4c18:	fc 01       	movw	r30, r24
    4c1a:	20 83       	st	Z, r18
	PORTB |= 1 << ss_pin;
    4c1c:	85 e2       	ldi	r24, 0x25	; 37
    4c1e:	90 e0       	ldi	r25, 0x00	; 0
    4c20:	25 e2       	ldi	r18, 0x25	; 37
    4c22:	30 e0       	ldi	r19, 0x00	; 0
    4c24:	f9 01       	movw	r30, r18
    4c26:	20 81       	ld	r18, Z
    4c28:	62 2f       	mov	r22, r18
    4c2a:	40 e0       	ldi	r20, 0x00	; 0
    4c2c:	50 e0       	ldi	r21, 0x00	; 0
    4c2e:	21 e0       	ldi	r18, 0x01	; 1
    4c30:	30 e0       	ldi	r19, 0x00	; 0
    4c32:	02 c0       	rjmp	.+4      	; 0x4c38 <initializeSPI+0xa6>
    4c34:	22 0f       	add	r18, r18
    4c36:	33 1f       	adc	r19, r19
    4c38:	4a 95       	dec	r20
    4c3a:	e2 f7       	brpl	.-8      	; 0x4c34 <initializeSPI+0xa2>
    4c3c:	26 2b       	or	r18, r22
    4c3e:	fc 01       	movw	r30, r24
    4c40:	20 83       	st	Z, r18
	PORTB &= ~(1 << sck_pin);
    4c42:	85 e2       	ldi	r24, 0x25	; 37
    4c44:	90 e0       	ldi	r25, 0x00	; 0
    4c46:	25 e2       	ldi	r18, 0x25	; 37
    4c48:	30 e0       	ldi	r19, 0x00	; 0
    4c4a:	f9 01       	movw	r30, r18
    4c4c:	20 81       	ld	r18, Z
    4c4e:	62 2f       	mov	r22, r18
    4c50:	41 e0       	ldi	r20, 0x01	; 1
    4c52:	50 e0       	ldi	r21, 0x00	; 0
    4c54:	21 e0       	ldi	r18, 0x01	; 1
    4c56:	30 e0       	ldi	r19, 0x00	; 0
    4c58:	04 2e       	mov	r0, r20
    4c5a:	02 c0       	rjmp	.+4      	; 0x4c60 <initializeSPI+0xce>
    4c5c:	22 0f       	add	r18, r18
    4c5e:	33 1f       	adc	r19, r19
    4c60:	0a 94       	dec	r0
    4c62:	e2 f7       	brpl	.-8      	; 0x4c5c <initializeSPI+0xca>
    4c64:	20 95       	com	r18
    4c66:	26 23       	and	r18, r22
    4c68:	fc 01       	movw	r30, r24
    4c6a:	20 83       	st	Z, r18
}
    4c6c:	df 91       	pop	r29
    4c6e:	cf 91       	pop	r28
    4c70:	08 95       	ret

00004c72 <SPIsendByte>:

void SPIsendByte(unsigned char byte){
    4c72:	cf 93       	push	r28
    4c74:	df 93       	push	r29
    4c76:	1f 92       	push	r1
    4c78:	cd b7       	in	r28, 0x3d	; 61
    4c7a:	de b7       	in	r29, 0x3e	; 62
    4c7c:	89 83       	std	Y+1, r24	; 0x01
	PORTB &= ~(1 << ss_pin);
    4c7e:	85 e2       	ldi	r24, 0x25	; 37
    4c80:	90 e0       	ldi	r25, 0x00	; 0
    4c82:	25 e2       	ldi	r18, 0x25	; 37
    4c84:	30 e0       	ldi	r19, 0x00	; 0
    4c86:	f9 01       	movw	r30, r18
    4c88:	20 81       	ld	r18, Z
    4c8a:	62 2f       	mov	r22, r18
    4c8c:	40 e0       	ldi	r20, 0x00	; 0
    4c8e:	50 e0       	ldi	r21, 0x00	; 0
    4c90:	21 e0       	ldi	r18, 0x01	; 1
    4c92:	30 e0       	ldi	r19, 0x00	; 0
    4c94:	02 c0       	rjmp	.+4      	; 0x4c9a <SPIsendByte+0x28>
    4c96:	22 0f       	add	r18, r18
    4c98:	33 1f       	adc	r19, r19
    4c9a:	4a 95       	dec	r20
    4c9c:	e2 f7       	brpl	.-8      	; 0x4c96 <SPIsendByte+0x24>
    4c9e:	20 95       	com	r18
    4ca0:	26 23       	and	r18, r22
    4ca2:	fc 01       	movw	r30, r24
    4ca4:	20 83       	st	Z, r18
	vTaskDelay(1);
    4ca6:	81 e0       	ldi	r24, 0x01	; 1
    4ca8:	90 e0       	ldi	r25, 0x00	; 0
    4caa:	0e 94 1d 05 	call	0xa3a	; 0xa3a <vTaskDelay>
	SPDR = byte;
    4cae:	8e e4       	ldi	r24, 0x4E	; 78
    4cb0:	90 e0       	ldi	r25, 0x00	; 0
    4cb2:	29 81       	ldd	r18, Y+1	; 0x01
    4cb4:	fc 01       	movw	r30, r24
    4cb6:	20 83       	st	Z, r18
	while((SPSR & (1 << SPIF)) == 0)
    4cb8:	00 00       	nop
    4cba:	8d e4       	ldi	r24, 0x4D	; 77
    4cbc:	90 e0       	ldi	r25, 0x00	; 0
    4cbe:	fc 01       	movw	r30, r24
    4cc0:	80 81       	ld	r24, Z
    4cc2:	88 23       	and	r24, r24
    4cc4:	d4 f7       	brge	.-12     	; 0x4cba <SPIsendByte+0x48>
	;
	vTaskDelay(1);
    4cc6:	81 e0       	ldi	r24, 0x01	; 1
    4cc8:	90 e0       	ldi	r25, 0x00	; 0
    4cca:	0e 94 1d 05 	call	0xa3a	; 0xa3a <vTaskDelay>
	PORTB |= (1 << ss_pin);
    4cce:	85 e2       	ldi	r24, 0x25	; 37
    4cd0:	90 e0       	ldi	r25, 0x00	; 0
    4cd2:	25 e2       	ldi	r18, 0x25	; 37
    4cd4:	30 e0       	ldi	r19, 0x00	; 0
    4cd6:	f9 01       	movw	r30, r18
    4cd8:	20 81       	ld	r18, Z
    4cda:	62 2f       	mov	r22, r18
    4cdc:	40 e0       	ldi	r20, 0x00	; 0
    4cde:	50 e0       	ldi	r21, 0x00	; 0
    4ce0:	21 e0       	ldi	r18, 0x01	; 1
    4ce2:	30 e0       	ldi	r19, 0x00	; 0
    4ce4:	04 2e       	mov	r0, r20
    4ce6:	02 c0       	rjmp	.+4      	; 0x4cec <SPIsendByte+0x7a>
    4ce8:	22 0f       	add	r18, r18
    4cea:	33 1f       	adc	r19, r19
    4cec:	0a 94       	dec	r0
    4cee:	e2 f7       	brpl	.-8      	; 0x4ce8 <SPIsendByte+0x76>
    4cf0:	26 2b       	or	r18, r22
    4cf2:	fc 01       	movw	r30, r24
    4cf4:	20 83       	st	Z, r18

}
    4cf6:	0f 90       	pop	r0
    4cf8:	df 91       	pop	r29
    4cfa:	cf 91       	pop	r28
    4cfc:	08 95       	ret

00004cfe <SPIsendShort>:

void SPIsendShort(unsigned short data){
    4cfe:	cf 93       	push	r28
    4d00:	df 93       	push	r29
    4d02:	1f 92       	push	r1
    4d04:	1f 92       	push	r1
    4d06:	cd b7       	in	r28, 0x3d	; 61
    4d08:	de b7       	in	r29, 0x3e	; 62
    4d0a:	9a 83       	std	Y+2, r25	; 0x02
    4d0c:	89 83       	std	Y+1, r24	; 0x01
	PORTB &= ~(1 << ss_pin);
    4d0e:	85 e2       	ldi	r24, 0x25	; 37
    4d10:	90 e0       	ldi	r25, 0x00	; 0
    4d12:	25 e2       	ldi	r18, 0x25	; 37
    4d14:	30 e0       	ldi	r19, 0x00	; 0
    4d16:	f9 01       	movw	r30, r18
    4d18:	20 81       	ld	r18, Z
    4d1a:	62 2f       	mov	r22, r18
    4d1c:	40 e0       	ldi	r20, 0x00	; 0
    4d1e:	50 e0       	ldi	r21, 0x00	; 0
    4d20:	21 e0       	ldi	r18, 0x01	; 1
    4d22:	30 e0       	ldi	r19, 0x00	; 0
    4d24:	02 c0       	rjmp	.+4      	; 0x4d2a <SPIsendShort+0x2c>
    4d26:	22 0f       	add	r18, r18
    4d28:	33 1f       	adc	r19, r19
    4d2a:	4a 95       	dec	r20
    4d2c:	e2 f7       	brpl	.-8      	; 0x4d26 <SPIsendShort+0x28>
    4d2e:	20 95       	com	r18
    4d30:	26 23       	and	r18, r22
    4d32:	fc 01       	movw	r30, r24
    4d34:	20 83       	st	Z, r18
	vTaskDelay(2);
    4d36:	82 e0       	ldi	r24, 0x02	; 2
    4d38:	90 e0       	ldi	r25, 0x00	; 0
    4d3a:	0e 94 1d 05 	call	0xa3a	; 0xa3a <vTaskDelay>
	SPDR = (data >> 8);
    4d3e:	8e e4       	ldi	r24, 0x4E	; 78
    4d40:	90 e0       	ldi	r25, 0x00	; 0
    4d42:	29 81       	ldd	r18, Y+1	; 0x01
    4d44:	3a 81       	ldd	r19, Y+2	; 0x02
    4d46:	23 2f       	mov	r18, r19
    4d48:	33 27       	eor	r19, r19
    4d4a:	fc 01       	movw	r30, r24
    4d4c:	20 83       	st	Z, r18
	while((SPSR & (1 << SPIF)) == 0)
    4d4e:	00 00       	nop
    4d50:	8d e4       	ldi	r24, 0x4D	; 77
    4d52:	90 e0       	ldi	r25, 0x00	; 0
    4d54:	fc 01       	movw	r30, r24
    4d56:	80 81       	ld	r24, Z
    4d58:	88 23       	and	r24, r24
    4d5a:	d4 f7       	brge	.-12     	; 0x4d50 <SPIsendShort+0x52>
	;
	SPDR = data & 0xFF;
    4d5c:	8e e4       	ldi	r24, 0x4E	; 78
    4d5e:	90 e0       	ldi	r25, 0x00	; 0
    4d60:	29 81       	ldd	r18, Y+1	; 0x01
    4d62:	fc 01       	movw	r30, r24
    4d64:	20 83       	st	Z, r18
	while((SPSR & (1 << SPIF)) == 0)
    4d66:	00 00       	nop
    4d68:	8d e4       	ldi	r24, 0x4D	; 77
    4d6a:	90 e0       	ldi	r25, 0x00	; 0
    4d6c:	fc 01       	movw	r30, r24
    4d6e:	80 81       	ld	r24, Z
    4d70:	88 23       	and	r24, r24
    4d72:	d4 f7       	brge	.-12     	; 0x4d68 <SPIsendShort+0x6a>
	;
	vTaskDelay(2);
    4d74:	82 e0       	ldi	r24, 0x02	; 2
    4d76:	90 e0       	ldi	r25, 0x00	; 0
    4d78:	0e 94 1d 05 	call	0xa3a	; 0xa3a <vTaskDelay>
	PORTB |= (1 << ss_pin);
    4d7c:	85 e2       	ldi	r24, 0x25	; 37
    4d7e:	90 e0       	ldi	r25, 0x00	; 0
    4d80:	25 e2       	ldi	r18, 0x25	; 37
    4d82:	30 e0       	ldi	r19, 0x00	; 0
    4d84:	f9 01       	movw	r30, r18
    4d86:	20 81       	ld	r18, Z
    4d88:	62 2f       	mov	r22, r18
    4d8a:	40 e0       	ldi	r20, 0x00	; 0
    4d8c:	50 e0       	ldi	r21, 0x00	; 0
    4d8e:	21 e0       	ldi	r18, 0x01	; 1
    4d90:	30 e0       	ldi	r19, 0x00	; 0
    4d92:	04 2e       	mov	r0, r20
    4d94:	02 c0       	rjmp	.+4      	; 0x4d9a <SPIsendShort+0x9c>
    4d96:	22 0f       	add	r18, r18
    4d98:	33 1f       	adc	r19, r19
    4d9a:	0a 94       	dec	r0
    4d9c:	e2 f7       	brpl	.-8      	; 0x4d96 <SPIsendShort+0x98>
    4d9e:	26 2b       	or	r18, r22
    4da0:	fc 01       	movw	r30, r24
    4da2:	20 83       	st	Z, r18
}
    4da4:	0f 90       	pop	r0
    4da6:	0f 90       	pop	r0
    4da8:	df 91       	pop	r29
    4daa:	cf 91       	pop	r28
    4dac:	08 95       	ret

00004dae <initADC>:
static ADCDevice devices[16];
static int currDevice = 0;
static int ADCinitialized = 0;

//Initialize ADC registers
void initADC(){
    4dae:	cf 93       	push	r28
    4db0:	df 93       	push	r29
    4db2:	cd b7       	in	r28, 0x3d	; 61
    4db4:	de b7       	in	r29, 0x3e	; 62
	ADCSRA = _BV(ADEN);
    4db6:	8a e7       	ldi	r24, 0x7A	; 122
    4db8:	90 e0       	ldi	r25, 0x00	; 0
    4dba:	20 e8       	ldi	r18, 0x80	; 128
    4dbc:	fc 01       	movw	r30, r24
    4dbe:	20 83       	st	Z, r18
	ADMUX = _BV(REFS0)|(1);
    4dc0:	8c e7       	ldi	r24, 0x7C	; 124
    4dc2:	90 e0       	ldi	r25, 0x00	; 0
    4dc4:	21 e4       	ldi	r18, 0x41	; 65
    4dc6:	fc 01       	movw	r30, r24
    4dc8:	20 83       	st	Z, r18

	ADCSRB = (1 << MUX5);
    4dca:	8b e7       	ldi	r24, 0x7B	; 123
    4dcc:	90 e0       	ldi	r25, 0x00	; 0
    4dce:	28 e0       	ldi	r18, 0x08	; 8
    4dd0:	fc 01       	movw	r30, r24
    4dd2:	20 83       	st	Z, r18
	
	//DIDR2 = 0xFF;
}
    4dd4:	df 91       	pop	r29
    4dd6:	cf 91       	pop	r28
    4dd8:	08 95       	ret

00004dda <ADCStart>:

//If the ADC isn't running, start it
void ADCStart(ADCDevice* nextDevice) {
    4dda:	cf 93       	push	r28
    4ddc:	df 93       	push	r29
    4dde:	1f 92       	push	r1
    4de0:	1f 92       	push	r1
    4de2:	cd b7       	in	r28, 0x3d	; 61
    4de4:	de b7       	in	r29, 0x3e	; 62
    4de6:	9a 83       	std	Y+2, r25	; 0x02
    4de8:	89 83       	std	Y+1, r24	; 0x01

		
	if(!(ADCSRA & _BV(ADSC))){
    4dea:	8a e7       	ldi	r24, 0x7A	; 122
    4dec:	90 e0       	ldi	r25, 0x00	; 0
    4dee:	fc 01       	movw	r30, r24
    4df0:	80 81       	ld	r24, Z
    4df2:	88 2f       	mov	r24, r24
    4df4:	90 e0       	ldi	r25, 0x00	; 0
    4df6:	80 74       	andi	r24, 0x40	; 64
    4df8:	99 27       	eor	r25, r25
    4dfa:	00 97       	sbiw	r24, 0x00	; 0
    4dfc:	09 f0       	breq	.+2      	; 0x4e00 <ADCStart+0x26>
    4dfe:	90 c0       	rjmp	.+288    	; 0x4f20 <ADCStart+0x146>
		ADCSRA &= ~((1 << ADPS2)|(1 << ADPS1)|(1 << ADPS0));
    4e00:	8a e7       	ldi	r24, 0x7A	; 122
    4e02:	90 e0       	ldi	r25, 0x00	; 0
    4e04:	2a e7       	ldi	r18, 0x7A	; 122
    4e06:	30 e0       	ldi	r19, 0x00	; 0
    4e08:	f9 01       	movw	r30, r18
    4e0a:	20 81       	ld	r18, Z
    4e0c:	28 7f       	andi	r18, 0xF8	; 248
    4e0e:	fc 01       	movw	r30, r24
    4e10:	20 83       	st	Z, r18
		switch(nextDevice->options & ADC_OPT_PRECISION_MASK){
    4e12:	89 81       	ldd	r24, Y+1	; 0x01
    4e14:	9a 81       	ldd	r25, Y+2	; 0x02
    4e16:	fc 01       	movw	r30, r24
    4e18:	82 81       	ldd	r24, Z+2	; 0x02
    4e1a:	93 81       	ldd	r25, Z+3	; 0x03
    4e1c:	83 70       	andi	r24, 0x03	; 3
    4e1e:	99 27       	eor	r25, r25
    4e20:	81 30       	cpi	r24, 0x01	; 1
    4e22:	91 05       	cpc	r25, r1
    4e24:	a1 f0       	breq	.+40     	; 0x4e4e <ADCStart+0x74>
    4e26:	82 30       	cpi	r24, 0x02	; 2
    4e28:	91 05       	cpc	r25, r1
    4e2a:	1c f4       	brge	.+6      	; 0x4e32 <ADCStart+0x58>
    4e2c:	00 97       	sbiw	r24, 0x00	; 0
    4e2e:	29 f0       	breq	.+10     	; 0x4e3a <ADCStart+0x60>
    4e30:	22 c0       	rjmp	.+68     	; 0x4e76 <ADCStart+0x9c>
    4e32:	82 30       	cpi	r24, 0x02	; 2
    4e34:	91 05       	cpc	r25, r1
    4e36:	a9 f0       	breq	.+42     	; 0x4e62 <ADCStart+0x88>
			break;
		case ADC_OPT_PRECISION_MED:
			ADCSRA |= (1 << ADPS1)|(1 << ADPS0);
			break;
		case ADC_OPT_PRECISION_LOW:
			break;
    4e38:	1e c0       	rjmp	.+60     	; 0x4e76 <ADCStart+0x9c>
		
	if(!(ADCSRA & _BV(ADSC))){
		ADCSRA &= ~((1 << ADPS2)|(1 << ADPS1)|(1 << ADPS0));
		switch(nextDevice->options & ADC_OPT_PRECISION_MASK){
		case ADC_OPT_PRECISION_HIGH:
			ADCSRA |= (1 << ADPS2)|(1 << ADPS1)|(1 << ADPS0);
    4e3a:	8a e7       	ldi	r24, 0x7A	; 122
    4e3c:	90 e0       	ldi	r25, 0x00	; 0
    4e3e:	2a e7       	ldi	r18, 0x7A	; 122
    4e40:	30 e0       	ldi	r19, 0x00	; 0
    4e42:	f9 01       	movw	r30, r18
    4e44:	20 81       	ld	r18, Z
    4e46:	27 60       	ori	r18, 0x07	; 7
    4e48:	fc 01       	movw	r30, r24
    4e4a:	20 83       	st	Z, r18
			break;
    4e4c:	14 c0       	rjmp	.+40     	; 0x4e76 <ADCStart+0x9c>
		case ADC_OPT_PRECISION_MED_HIGH:
			ADCSRA |= (1 << ADPS2)|(1 << ADPS0);
    4e4e:	8a e7       	ldi	r24, 0x7A	; 122
    4e50:	90 e0       	ldi	r25, 0x00	; 0
    4e52:	2a e7       	ldi	r18, 0x7A	; 122
    4e54:	30 e0       	ldi	r19, 0x00	; 0
    4e56:	f9 01       	movw	r30, r18
    4e58:	20 81       	ld	r18, Z
    4e5a:	25 60       	ori	r18, 0x05	; 5
    4e5c:	fc 01       	movw	r30, r24
    4e5e:	20 83       	st	Z, r18
			break;
    4e60:	0a c0       	rjmp	.+20     	; 0x4e76 <ADCStart+0x9c>
		case ADC_OPT_PRECISION_MED:
			ADCSRA |= (1 << ADPS1)|(1 << ADPS0);
    4e62:	8a e7       	ldi	r24, 0x7A	; 122
    4e64:	90 e0       	ldi	r25, 0x00	; 0
    4e66:	2a e7       	ldi	r18, 0x7A	; 122
    4e68:	30 e0       	ldi	r19, 0x00	; 0
    4e6a:	f9 01       	movw	r30, r18
    4e6c:	20 81       	ld	r18, Z
    4e6e:	23 60       	ori	r18, 0x03	; 3
    4e70:	fc 01       	movw	r30, r24
    4e72:	20 83       	st	Z, r18
			break;
    4e74:	00 00       	nop
		case ADC_OPT_PRECISION_LOW:
			break;
		}
		ADMUX &= ~((1 << MUX0)|(1 << MUX1)|(1 << MUX2)|(1 << MUX3));
    4e76:	8c e7       	ldi	r24, 0x7C	; 124
    4e78:	90 e0       	ldi	r25, 0x00	; 0
    4e7a:	2c e7       	ldi	r18, 0x7C	; 124
    4e7c:	30 e0       	ldi	r19, 0x00	; 0
    4e7e:	f9 01       	movw	r30, r18
    4e80:	20 81       	ld	r18, Z
    4e82:	20 7f       	andi	r18, 0xF0	; 240
    4e84:	fc 01       	movw	r30, r24
    4e86:	20 83       	st	Z, r18
		if(nextDevice->port < 8){
    4e88:	89 81       	ldd	r24, Y+1	; 0x01
    4e8a:	9a 81       	ldd	r25, Y+2	; 0x02
    4e8c:	fc 01       	movw	r30, r24
    4e8e:	80 81       	ld	r24, Z
    4e90:	91 81       	ldd	r25, Z+1	; 0x01
    4e92:	88 30       	cpi	r24, 0x08	; 8
    4e94:	91 05       	cpc	r25, r1
    4e96:	cc f4       	brge	.+50     	; 0x4eca <ADCStart+0xf0>
			ADCSRB &= ~(1 << MUX5);
    4e98:	8b e7       	ldi	r24, 0x7B	; 123
    4e9a:	90 e0       	ldi	r25, 0x00	; 0
    4e9c:	2b e7       	ldi	r18, 0x7B	; 123
    4e9e:	30 e0       	ldi	r19, 0x00	; 0
    4ea0:	f9 01       	movw	r30, r18
    4ea2:	20 81       	ld	r18, Z
    4ea4:	27 7f       	andi	r18, 0xF7	; 247
    4ea6:	fc 01       	movw	r30, r24
    4ea8:	20 83       	st	Z, r18
			ADMUX |= nextDevice->port;
    4eaa:	8c e7       	ldi	r24, 0x7C	; 124
    4eac:	90 e0       	ldi	r25, 0x00	; 0
    4eae:	2c e7       	ldi	r18, 0x7C	; 124
    4eb0:	30 e0       	ldi	r19, 0x00	; 0
    4eb2:	f9 01       	movw	r30, r18
    4eb4:	20 81       	ld	r18, Z
    4eb6:	42 2f       	mov	r20, r18
    4eb8:	29 81       	ldd	r18, Y+1	; 0x01
    4eba:	3a 81       	ldd	r19, Y+2	; 0x02
    4ebc:	f9 01       	movw	r30, r18
    4ebe:	20 81       	ld	r18, Z
    4ec0:	31 81       	ldd	r19, Z+1	; 0x01
    4ec2:	24 2b       	or	r18, r20
    4ec4:	fc 01       	movw	r30, r24
    4ec6:	20 83       	st	Z, r18
    4ec8:	19 c0       	rjmp	.+50     	; 0x4efc <ADCStart+0x122>
		} else {
			ADCSRB |= (1 << MUX5);
    4eca:	8b e7       	ldi	r24, 0x7B	; 123
    4ecc:	90 e0       	ldi	r25, 0x00	; 0
    4ece:	2b e7       	ldi	r18, 0x7B	; 123
    4ed0:	30 e0       	ldi	r19, 0x00	; 0
    4ed2:	f9 01       	movw	r30, r18
    4ed4:	20 81       	ld	r18, Z
    4ed6:	28 60       	ori	r18, 0x08	; 8
    4ed8:	fc 01       	movw	r30, r24
    4eda:	20 83       	st	Z, r18
			ADMUX |= nextDevice->port - 8;
    4edc:	8c e7       	ldi	r24, 0x7C	; 124
    4ede:	90 e0       	ldi	r25, 0x00	; 0
    4ee0:	2c e7       	ldi	r18, 0x7C	; 124
    4ee2:	30 e0       	ldi	r19, 0x00	; 0
    4ee4:	f9 01       	movw	r30, r18
    4ee6:	20 81       	ld	r18, Z
    4ee8:	42 2f       	mov	r20, r18
    4eea:	29 81       	ldd	r18, Y+1	; 0x01
    4eec:	3a 81       	ldd	r19, Y+2	; 0x02
    4eee:	f9 01       	movw	r30, r18
    4ef0:	20 81       	ld	r18, Z
    4ef2:	31 81       	ldd	r19, Z+1	; 0x01
    4ef4:	28 50       	subi	r18, 0x08	; 8
    4ef6:	24 2b       	or	r18, r20
    4ef8:	fc 01       	movw	r30, r24
    4efa:	20 83       	st	Z, r18
		}
		
		ADCSRA |= _BV(ADIE);
    4efc:	8a e7       	ldi	r24, 0x7A	; 122
    4efe:	90 e0       	ldi	r25, 0x00	; 0
    4f00:	2a e7       	ldi	r18, 0x7A	; 122
    4f02:	30 e0       	ldi	r19, 0x00	; 0
    4f04:	f9 01       	movw	r30, r18
    4f06:	20 81       	ld	r18, Z
    4f08:	28 60       	ori	r18, 0x08	; 8
    4f0a:	fc 01       	movw	r30, r24
    4f0c:	20 83       	st	Z, r18
		ADCSRA |= _BV(ADSC);
    4f0e:	8a e7       	ldi	r24, 0x7A	; 122
    4f10:	90 e0       	ldi	r25, 0x00	; 0
    4f12:	2a e7       	ldi	r18, 0x7A	; 122
    4f14:	30 e0       	ldi	r19, 0x00	; 0
    4f16:	f9 01       	movw	r30, r18
    4f18:	20 81       	ld	r18, Z
    4f1a:	20 64       	ori	r18, 0x40	; 64
    4f1c:	fc 01       	movw	r30, r24
    4f1e:	20 83       	st	Z, r18
	}
}
    4f20:	0f 90       	pop	r0
    4f22:	0f 90       	pop	r0
    4f24:	df 91       	pop	r29
    4f26:	cf 91       	pop	r28
    4f28:	08 95       	ret

00004f2a <__vector_29>:

//Read the finished value of the ADC and store it
ISR(ADC_vect) {
    4f2a:	1f 92       	push	r1
    4f2c:	0f 92       	push	r0
    4f2e:	00 90 5f 00 	lds	r0, 0x005F
    4f32:	0f 92       	push	r0
    4f34:	11 24       	eor	r1, r1
    4f36:	00 90 5b 00 	lds	r0, 0x005B
    4f3a:	0f 92       	push	r0
    4f3c:	2f 93       	push	r18
    4f3e:	3f 93       	push	r19
    4f40:	4f 93       	push	r20
    4f42:	5f 93       	push	r21
    4f44:	6f 93       	push	r22
    4f46:	7f 93       	push	r23
    4f48:	8f 93       	push	r24
    4f4a:	9f 93       	push	r25
    4f4c:	af 93       	push	r26
    4f4e:	bf 93       	push	r27
    4f50:	ef 93       	push	r30
    4f52:	ff 93       	push	r31
    4f54:	cf 93       	push	r28
    4f56:	df 93       	push	r29
    4f58:	00 d0       	rcall	.+0      	; 0x4f5a <__vector_29+0x30>
    4f5a:	00 d0       	rcall	.+0      	; 0x4f5c <__vector_29+0x32>
    4f5c:	cd b7       	in	r28, 0x3d	; 61
    4f5e:	de b7       	in	r29, 0x3e	; 62
	int result = ADCL;
    4f60:	88 e7       	ldi	r24, 0x78	; 120
    4f62:	90 e0       	ldi	r25, 0x00	; 0
    4f64:	fc 01       	movw	r30, r24
    4f66:	80 81       	ld	r24, Z
    4f68:	88 2f       	mov	r24, r24
    4f6a:	90 e0       	ldi	r25, 0x00	; 0
    4f6c:	9a 83       	std	Y+2, r25	; 0x02
    4f6e:	89 83       	std	Y+1, r24	; 0x01
	result |= (ADCH << 8);
    4f70:	89 e7       	ldi	r24, 0x79	; 121
    4f72:	90 e0       	ldi	r25, 0x00	; 0
    4f74:	fc 01       	movw	r30, r24
    4f76:	80 81       	ld	r24, Z
    4f78:	88 2f       	mov	r24, r24
    4f7a:	90 e0       	ldi	r25, 0x00	; 0
    4f7c:	98 2f       	mov	r25, r24
    4f7e:	88 27       	eor	r24, r24
    4f80:	29 81       	ldd	r18, Y+1	; 0x01
    4f82:	3a 81       	ldd	r19, Y+2	; 0x02
    4f84:	82 2b       	or	r24, r18
    4f86:	93 2b       	or	r25, r19
    4f88:	9a 83       	std	Y+2, r25	; 0x02
    4f8a:	89 83       	std	Y+1, r24	; 0x01
	
	ADCHandler handler = devices[currDevice].handler;
    4f8c:	80 91 5f 1b 	lds	r24, 0x1B5F
    4f90:	90 91 60 1b 	lds	r25, 0x1B60
    4f94:	88 0f       	add	r24, r24
    4f96:	99 1f       	adc	r25, r25
    4f98:	88 0f       	add	r24, r24
    4f9a:	99 1f       	adc	r25, r25
    4f9c:	88 0f       	add	r24, r24
    4f9e:	99 1f       	adc	r25, r25
    4fa0:	8b 51       	subi	r24, 0x1B	; 27
    4fa2:	95 4e       	sbci	r25, 0xE5	; 229
    4fa4:	fc 01       	movw	r30, r24
    4fa6:	80 81       	ld	r24, Z
    4fa8:	91 81       	ldd	r25, Z+1	; 0x01
    4faa:	9c 83       	std	Y+4, r25	; 0x04
    4fac:	8b 83       	std	Y+3, r24	; 0x03
	void *parameters = devices[currDevice].parameters;
    4fae:	80 91 5f 1b 	lds	r24, 0x1B5F
    4fb2:	90 91 60 1b 	lds	r25, 0x1B60
    4fb6:	88 0f       	add	r24, r24
    4fb8:	99 1f       	adc	r25, r25
    4fba:	88 0f       	add	r24, r24
    4fbc:	99 1f       	adc	r25, r25
    4fbe:	88 0f       	add	r24, r24
    4fc0:	99 1f       	adc	r25, r25
    4fc2:	8d 51       	subi	r24, 0x1D	; 29
    4fc4:	95 4e       	sbci	r25, 0xE5	; 229
    4fc6:	fc 01       	movw	r30, r24
    4fc8:	80 81       	ld	r24, Z
    4fca:	91 81       	ldd	r25, Z+1	; 0x01
    4fcc:	9e 83       	std	Y+6, r25	; 0x06
    4fce:	8d 83       	std	Y+5, r24	; 0x05
	
	handler(result,parameters);
    4fd0:	4d 81       	ldd	r20, Y+5	; 0x05
    4fd2:	5e 81       	ldd	r21, Y+6	; 0x06
    4fd4:	89 81       	ldd	r24, Y+1	; 0x01
    4fd6:	9a 81       	ldd	r25, Y+2	; 0x02
    4fd8:	2b 81       	ldd	r18, Y+3	; 0x03
    4fda:	3c 81       	ldd	r19, Y+4	; 0x04
    4fdc:	ba 01       	movw	r22, r20
    4fde:	f9 01       	movw	r30, r18
    4fe0:	19 95       	eicall
	
	ADCSRA &= ~(_BV(ADIE));
    4fe2:	8a e7       	ldi	r24, 0x7A	; 122
    4fe4:	90 e0       	ldi	r25, 0x00	; 0
    4fe6:	2a e7       	ldi	r18, 0x7A	; 122
    4fe8:	30 e0       	ldi	r19, 0x00	; 0
    4fea:	f9 01       	movw	r30, r18
    4fec:	20 81       	ld	r18, Z
    4fee:	27 7f       	andi	r18, 0xF7	; 247
    4ff0:	fc 01       	movw	r30, r24
    4ff2:	20 83       	st	Z, r18
	
	xSemaphoreGiveFromISR(adcSemaphore,0);
    4ff4:	80 91 dd 1a 	lds	r24, 0x1ADD
    4ff8:	90 91 de 1a 	lds	r25, 0x1ADE
    4ffc:	20 e0       	ldi	r18, 0x00	; 0
    4ffe:	40 e0       	ldi	r20, 0x00	; 0
    5000:	50 e0       	ldi	r21, 0x00	; 0
    5002:	60 e0       	ldi	r22, 0x00	; 0
    5004:	70 e0       	ldi	r23, 0x00	; 0
    5006:	0e 94 f0 0e 	call	0x1de0	; 0x1de0 <xQueueGenericSendFromISR>
}
    500a:	26 96       	adiw	r28, 0x06	; 6
    500c:	0f b6       	in	r0, 0x3f	; 63
    500e:	f8 94       	cli
    5010:	de bf       	out	0x3e, r29	; 62
    5012:	0f be       	out	0x3f, r0	; 63
    5014:	cd bf       	out	0x3d, r28	; 61
    5016:	df 91       	pop	r29
    5018:	cf 91       	pop	r28
    501a:	ff 91       	pop	r31
    501c:	ef 91       	pop	r30
    501e:	bf 91       	pop	r27
    5020:	af 91       	pop	r26
    5022:	9f 91       	pop	r25
    5024:	8f 91       	pop	r24
    5026:	7f 91       	pop	r23
    5028:	6f 91       	pop	r22
    502a:	5f 91       	pop	r21
    502c:	4f 91       	pop	r20
    502e:	3f 91       	pop	r19
    5030:	2f 91       	pop	r18
    5032:	0f 90       	pop	r0
    5034:	00 92 5b 00 	sts	0x005B, r0
    5038:	0f 90       	pop	r0
    503a:	00 92 5f 00 	sts	0x005F, r0
    503e:	0f 90       	pop	r0
    5040:	1f 90       	pop	r1
    5042:	18 95       	reti

00005044 <vTaskADC>:

void vTaskADC(void *parameters){
    5044:	cf 93       	push	r28
    5046:	df 93       	push	r29
    5048:	00 d0       	rcall	.+0      	; 0x504a <vTaskADC+0x6>
    504a:	1f 92       	push	r1
    504c:	cd b7       	in	r28, 0x3d	; 61
    504e:	de b7       	in	r29, 0x3e	; 62
    5050:	9c 83       	std	Y+4, r25	; 0x04
    5052:	8b 83       	std	Y+3, r24	; 0x03
	
	int i;

	for(i = 0;i < 16; i++){
    5054:	1a 82       	std	Y+2, r1	; 0x02
    5056:	19 82       	std	Y+1, r1	; 0x01
    5058:	14 c0       	rjmp	.+40     	; 0x5082 <vTaskADC+0x3e>
		devices[i].port = -1;
    505a:	89 81       	ldd	r24, Y+1	; 0x01
    505c:	9a 81       	ldd	r25, Y+2	; 0x02
    505e:	88 0f       	add	r24, r24
    5060:	99 1f       	adc	r25, r25
    5062:	88 0f       	add	r24, r24
    5064:	99 1f       	adc	r25, r25
    5066:	88 0f       	add	r24, r24
    5068:	99 1f       	adc	r25, r25
    506a:	81 52       	subi	r24, 0x21	; 33
    506c:	95 4e       	sbci	r25, 0xE5	; 229
    506e:	2f ef       	ldi	r18, 0xFF	; 255
    5070:	3f ef       	ldi	r19, 0xFF	; 255
    5072:	fc 01       	movw	r30, r24
    5074:	31 83       	std	Z+1, r19	; 0x01
    5076:	20 83       	st	Z, r18

void vTaskADC(void *parameters){
	
	int i;

	for(i = 0;i < 16; i++){
    5078:	89 81       	ldd	r24, Y+1	; 0x01
    507a:	9a 81       	ldd	r25, Y+2	; 0x02
    507c:	01 96       	adiw	r24, 0x01	; 1
    507e:	9a 83       	std	Y+2, r25	; 0x02
    5080:	89 83       	std	Y+1, r24	; 0x01
    5082:	89 81       	ldd	r24, Y+1	; 0x01
    5084:	9a 81       	ldd	r25, Y+2	; 0x02
    5086:	80 31       	cpi	r24, 0x10	; 16
    5088:	91 05       	cpc	r25, r1
    508a:	3c f3       	brlt	.-50     	; 0x505a <vTaskADC+0x16>
		devices[i].port = -1;
	}

	initADC();
    508c:	0e 94 d7 26 	call	0x4dae	; 0x4dae <initADC>

	vSemaphoreCreateBinary(adcSemaphore);
    5090:	43 e0       	ldi	r20, 0x03	; 3
    5092:	60 e0       	ldi	r22, 0x00	; 0
    5094:	81 e0       	ldi	r24, 0x01	; 1
    5096:	0e 94 95 0d 	call	0x1b2a	; 0x1b2a <xQueueGenericCreate>
    509a:	90 93 de 1a 	sts	0x1ADE, r25
    509e:	80 93 dd 1a 	sts	0x1ADD, r24
    50a2:	80 91 dd 1a 	lds	r24, 0x1ADD
    50a6:	90 91 de 1a 	lds	r25, 0x1ADE
    50aa:	00 97       	sbiw	r24, 0x00	; 0
    50ac:	59 f0       	breq	.+22     	; 0x50c4 <vTaskADC+0x80>
    50ae:	80 91 dd 1a 	lds	r24, 0x1ADD
    50b2:	90 91 de 1a 	lds	r25, 0x1ADE
    50b6:	20 e0       	ldi	r18, 0x00	; 0
    50b8:	40 e0       	ldi	r20, 0x00	; 0
    50ba:	50 e0       	ldi	r21, 0x00	; 0
    50bc:	60 e0       	ldi	r22, 0x00	; 0
    50be:	70 e0       	ldi	r23, 0x00	; 0
    50c0:	0e 94 4c 0e 	call	0x1c98	; 0x1c98 <xQueueGenericSend>
	
	ADCinitialized = 1;
    50c4:	81 e0       	ldi	r24, 0x01	; 1
    50c6:	90 e0       	ldi	r25, 0x00	; 0
    50c8:	90 93 62 1b 	sts	0x1B62, r25
    50cc:	80 93 61 1b 	sts	0x1B61, r24
	while(devices[0].port == -1){
    50d0:	04 c0       	rjmp	.+8      	; 0x50da <vTaskADC+0x96>
		vTaskDelay(10);
    50d2:	8a e0       	ldi	r24, 0x0A	; 10
    50d4:	90 e0       	ldi	r25, 0x00	; 0
    50d6:	0e 94 1d 05 	call	0xa3a	; 0xa3a <vTaskDelay>
	initADC();

	vSemaphoreCreateBinary(adcSemaphore);
	
	ADCinitialized = 1;
	while(devices[0].port == -1){
    50da:	80 91 df 1a 	lds	r24, 0x1ADF
    50de:	90 91 e0 1a 	lds	r25, 0x1AE0
    50e2:	8f 3f       	cpi	r24, 0xFF	; 255
    50e4:	ff ef       	ldi	r31, 0xFF	; 255
    50e6:	9f 07       	cpc	r25, r31
    50e8:	a1 f3       	breq	.-24     	; 0x50d2 <vTaskADC+0x8e>
		vTaskDelay(10);
	}
	
	while(1){
		ADCStart(&devices[currDevice]);
    50ea:	80 91 5f 1b 	lds	r24, 0x1B5F
    50ee:	90 91 60 1b 	lds	r25, 0x1B60
    50f2:	88 0f       	add	r24, r24
    50f4:	99 1f       	adc	r25, r25
    50f6:	88 0f       	add	r24, r24
    50f8:	99 1f       	adc	r25, r25
    50fa:	88 0f       	add	r24, r24
    50fc:	99 1f       	adc	r25, r25
    50fe:	81 52       	subi	r24, 0x21	; 33
    5100:	95 4e       	sbci	r25, 0xE5	; 229
    5102:	0e 94 ed 26 	call	0x4dda	; 0x4dda <ADCStart>
		currDevice++;
    5106:	80 91 5f 1b 	lds	r24, 0x1B5F
    510a:	90 91 60 1b 	lds	r25, 0x1B60
    510e:	01 96       	adiw	r24, 0x01	; 1
    5110:	90 93 60 1b 	sts	0x1B60, r25
    5114:	80 93 5f 1b 	sts	0x1B5F, r24
		if(currDevice >= 16 || devices[currDevice].port == -1){
    5118:	80 91 5f 1b 	lds	r24, 0x1B5F
    511c:	90 91 60 1b 	lds	r25, 0x1B60
    5120:	80 31       	cpi	r24, 0x10	; 16
    5122:	91 05       	cpc	r25, r1
    5124:	9c f4       	brge	.+38     	; 0x514c <vTaskADC+0x108>
    5126:	80 91 5f 1b 	lds	r24, 0x1B5F
    512a:	90 91 60 1b 	lds	r25, 0x1B60
    512e:	88 0f       	add	r24, r24
    5130:	99 1f       	adc	r25, r25
    5132:	88 0f       	add	r24, r24
    5134:	99 1f       	adc	r25, r25
    5136:	88 0f       	add	r24, r24
    5138:	99 1f       	adc	r25, r25
    513a:	81 52       	subi	r24, 0x21	; 33
    513c:	95 4e       	sbci	r25, 0xE5	; 229
    513e:	fc 01       	movw	r30, r24
    5140:	80 81       	ld	r24, Z
    5142:	91 81       	ldd	r25, Z+1	; 0x01
    5144:	8f 3f       	cpi	r24, 0xFF	; 255
    5146:	ff ef       	ldi	r31, 0xFF	; 255
    5148:	9f 07       	cpc	r25, r31
    514a:	21 f4       	brne	.+8      	; 0x5154 <vTaskADC+0x110>
			currDevice = 0;
    514c:	10 92 60 1b 	sts	0x1B60, r1
    5150:	10 92 5f 1b 	sts	0x1B5F, r1
		}
		xSemaphoreTake(adcSemaphore,portMAX_DELAY);
    5154:	80 91 dd 1a 	lds	r24, 0x1ADD
    5158:	90 91 de 1a 	lds	r25, 0x1ADE
    515c:	20 e0       	ldi	r18, 0x00	; 0
    515e:	4f ef       	ldi	r20, 0xFF	; 255
    5160:	5f ef       	ldi	r21, 0xFF	; 255
    5162:	60 e0       	ldi	r22, 0x00	; 0
    5164:	70 e0       	ldi	r23, 0x00	; 0
    5166:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <xQueueGenericReceive>
	}
    516a:	bf cf       	rjmp	.-130    	; 0x50ea <vTaskADC+0xa6>

0000516c <addADCDevice>:
}

void addADCDevice(int port,int options,ADCHandler handler,void* parameters){
    516c:	cf 93       	push	r28
    516e:	df 93       	push	r29
    5170:	cd b7       	in	r28, 0x3d	; 61
    5172:	de b7       	in	r29, 0x3e	; 62
    5174:	2a 97       	sbiw	r28, 0x0a	; 10
    5176:	0f b6       	in	r0, 0x3f	; 63
    5178:	f8 94       	cli
    517a:	de bf       	out	0x3e, r29	; 62
    517c:	0f be       	out	0x3f, r0	; 63
    517e:	cd bf       	out	0x3d, r28	; 61
    5180:	9c 83       	std	Y+4, r25	; 0x04
    5182:	8b 83       	std	Y+3, r24	; 0x03
    5184:	7e 83       	std	Y+6, r23	; 0x06
    5186:	6d 83       	std	Y+5, r22	; 0x05
    5188:	58 87       	std	Y+8, r21	; 0x08
    518a:	4f 83       	std	Y+7, r20	; 0x07
    518c:	3a 87       	std	Y+10, r19	; 0x0a
    518e:	29 87       	std	Y+9, r18	; 0x09
	int i;
	
	//Creating a device before all the structures are initialized
	//could lead to race conditions.
	while(ADCinitialized == 0) vTaskDelay(3);
    5190:	04 c0       	rjmp	.+8      	; 0x519a <addADCDevice+0x2e>
    5192:	83 e0       	ldi	r24, 0x03	; 3
    5194:	90 e0       	ldi	r25, 0x00	; 0
    5196:	0e 94 1d 05 	call	0xa3a	; 0xa3a <vTaskDelay>
    519a:	80 91 61 1b 	lds	r24, 0x1B61
    519e:	90 91 62 1b 	lds	r25, 0x1B62
    51a2:	00 97       	sbiw	r24, 0x00	; 0
    51a4:	b1 f3       	breq	.-20     	; 0x5192 <addADCDevice+0x26>

	for(i = 0; i < 16 && devices[i].port != -1; i++)
    51a6:	1a 82       	std	Y+2, r1	; 0x02
    51a8:	19 82       	std	Y+1, r1	; 0x01
    51aa:	05 c0       	rjmp	.+10     	; 0x51b6 <addADCDevice+0x4a>
    51ac:	89 81       	ldd	r24, Y+1	; 0x01
    51ae:	9a 81       	ldd	r25, Y+2	; 0x02
    51b0:	01 96       	adiw	r24, 0x01	; 1
    51b2:	9a 83       	std	Y+2, r25	; 0x02
    51b4:	89 83       	std	Y+1, r24	; 0x01
    51b6:	89 81       	ldd	r24, Y+1	; 0x01
    51b8:	9a 81       	ldd	r25, Y+2	; 0x02
    51ba:	80 31       	cpi	r24, 0x10	; 16
    51bc:	91 05       	cpc	r25, r1
    51be:	8c f4       	brge	.+34     	; 0x51e2 <addADCDevice+0x76>
    51c0:	89 81       	ldd	r24, Y+1	; 0x01
    51c2:	9a 81       	ldd	r25, Y+2	; 0x02
    51c4:	88 0f       	add	r24, r24
    51c6:	99 1f       	adc	r25, r25
    51c8:	88 0f       	add	r24, r24
    51ca:	99 1f       	adc	r25, r25
    51cc:	88 0f       	add	r24, r24
    51ce:	99 1f       	adc	r25, r25
    51d0:	81 52       	subi	r24, 0x21	; 33
    51d2:	95 4e       	sbci	r25, 0xE5	; 229
    51d4:	fc 01       	movw	r30, r24
    51d6:	80 81       	ld	r24, Z
    51d8:	91 81       	ldd	r25, Z+1	; 0x01
    51da:	8f 3f       	cpi	r24, 0xFF	; 255
    51dc:	ff ef       	ldi	r31, 0xFF	; 255
    51de:	9f 07       	cpc	r25, r31
    51e0:	29 f7       	brne	.-54     	; 0x51ac <addADCDevice+0x40>
	;
	
	if(port < 8){
    51e2:	8b 81       	ldd	r24, Y+3	; 0x03
    51e4:	9c 81       	ldd	r25, Y+4	; 0x04
    51e6:	88 30       	cpi	r24, 0x08	; 8
    51e8:	91 05       	cpc	r25, r1
    51ea:	a4 f4       	brge	.+40     	; 0x5214 <addADCDevice+0xa8>
		DIDR0 &= ~(1 << port);
    51ec:	8e e7       	ldi	r24, 0x7E	; 126
    51ee:	90 e0       	ldi	r25, 0x00	; 0
    51f0:	2e e7       	ldi	r18, 0x7E	; 126
    51f2:	30 e0       	ldi	r19, 0x00	; 0
    51f4:	f9 01       	movw	r30, r18
    51f6:	20 81       	ld	r18, Z
    51f8:	42 2f       	mov	r20, r18
    51fa:	21 e0       	ldi	r18, 0x01	; 1
    51fc:	30 e0       	ldi	r19, 0x00	; 0
    51fe:	0b 80       	ldd	r0, Y+3	; 0x03
    5200:	02 c0       	rjmp	.+4      	; 0x5206 <addADCDevice+0x9a>
    5202:	22 0f       	add	r18, r18
    5204:	33 1f       	adc	r19, r19
    5206:	0a 94       	dec	r0
    5208:	e2 f7       	brpl	.-8      	; 0x5202 <addADCDevice+0x96>
    520a:	20 95       	com	r18
    520c:	24 23       	and	r18, r20
    520e:	fc 01       	movw	r30, r24
    5210:	20 83       	st	Z, r18
    5212:	18 c0       	rjmp	.+48     	; 0x5244 <addADCDevice+0xd8>
	} else {
		DIDR2 &= ~(1 << (port - 8));
    5214:	8d e7       	ldi	r24, 0x7D	; 125
    5216:	90 e0       	ldi	r25, 0x00	; 0
    5218:	2d e7       	ldi	r18, 0x7D	; 125
    521a:	30 e0       	ldi	r19, 0x00	; 0
    521c:	f9 01       	movw	r30, r18
    521e:	20 81       	ld	r18, Z
    5220:	62 2f       	mov	r22, r18
    5222:	2b 81       	ldd	r18, Y+3	; 0x03
    5224:	3c 81       	ldd	r19, Y+4	; 0x04
    5226:	a9 01       	movw	r20, r18
    5228:	48 50       	subi	r20, 0x08	; 8
    522a:	51 09       	sbc	r21, r1
    522c:	21 e0       	ldi	r18, 0x01	; 1
    522e:	30 e0       	ldi	r19, 0x00	; 0
    5230:	04 2e       	mov	r0, r20
    5232:	02 c0       	rjmp	.+4      	; 0x5238 <addADCDevice+0xcc>
    5234:	22 0f       	add	r18, r18
    5236:	33 1f       	adc	r19, r19
    5238:	0a 94       	dec	r0
    523a:	e2 f7       	brpl	.-8      	; 0x5234 <addADCDevice+0xc8>
    523c:	20 95       	com	r18
    523e:	26 23       	and	r18, r22
    5240:	fc 01       	movw	r30, r24
    5242:	20 83       	st	Z, r18
	}

	if(devices[i].port == -1){
    5244:	89 81       	ldd	r24, Y+1	; 0x01
    5246:	9a 81       	ldd	r25, Y+2	; 0x02
    5248:	88 0f       	add	r24, r24
    524a:	99 1f       	adc	r25, r25
    524c:	88 0f       	add	r24, r24
    524e:	99 1f       	adc	r25, r25
    5250:	88 0f       	add	r24, r24
    5252:	99 1f       	adc	r25, r25
    5254:	81 52       	subi	r24, 0x21	; 33
    5256:	95 4e       	sbci	r25, 0xE5	; 229
    5258:	fc 01       	movw	r30, r24
    525a:	80 81       	ld	r24, Z
    525c:	91 81       	ldd	r25, Z+1	; 0x01
    525e:	8f 3f       	cpi	r24, 0xFF	; 255
    5260:	ff ef       	ldi	r31, 0xFF	; 255
    5262:	9f 07       	cpc	r25, r31
    5264:	e1 f5       	brne	.+120    	; 0x52de <addADCDevice+0x172>
		devices[i].port = port;
    5266:	89 81       	ldd	r24, Y+1	; 0x01
    5268:	9a 81       	ldd	r25, Y+2	; 0x02
    526a:	88 0f       	add	r24, r24
    526c:	99 1f       	adc	r25, r25
    526e:	88 0f       	add	r24, r24
    5270:	99 1f       	adc	r25, r25
    5272:	88 0f       	add	r24, r24
    5274:	99 1f       	adc	r25, r25
    5276:	81 52       	subi	r24, 0x21	; 33
    5278:	95 4e       	sbci	r25, 0xE5	; 229
    527a:	2b 81       	ldd	r18, Y+3	; 0x03
    527c:	3c 81       	ldd	r19, Y+4	; 0x04
    527e:	fc 01       	movw	r30, r24
    5280:	31 83       	std	Z+1, r19	; 0x01
    5282:	20 83       	st	Z, r18
		devices[i].options = options;
    5284:	89 81       	ldd	r24, Y+1	; 0x01
    5286:	9a 81       	ldd	r25, Y+2	; 0x02
    5288:	88 0f       	add	r24, r24
    528a:	99 1f       	adc	r25, r25
    528c:	88 0f       	add	r24, r24
    528e:	99 1f       	adc	r25, r25
    5290:	88 0f       	add	r24, r24
    5292:	99 1f       	adc	r25, r25
    5294:	8f 51       	subi	r24, 0x1F	; 31
    5296:	95 4e       	sbci	r25, 0xE5	; 229
    5298:	2d 81       	ldd	r18, Y+5	; 0x05
    529a:	3e 81       	ldd	r19, Y+6	; 0x06
    529c:	fc 01       	movw	r30, r24
    529e:	31 83       	std	Z+1, r19	; 0x01
    52a0:	20 83       	st	Z, r18
		devices[i].handler = handler;
    52a2:	89 81       	ldd	r24, Y+1	; 0x01
    52a4:	9a 81       	ldd	r25, Y+2	; 0x02
    52a6:	88 0f       	add	r24, r24
    52a8:	99 1f       	adc	r25, r25
    52aa:	88 0f       	add	r24, r24
    52ac:	99 1f       	adc	r25, r25
    52ae:	88 0f       	add	r24, r24
    52b0:	99 1f       	adc	r25, r25
    52b2:	8b 51       	subi	r24, 0x1B	; 27
    52b4:	95 4e       	sbci	r25, 0xE5	; 229
    52b6:	2f 81       	ldd	r18, Y+7	; 0x07
    52b8:	38 85       	ldd	r19, Y+8	; 0x08
    52ba:	fc 01       	movw	r30, r24
    52bc:	31 83       	std	Z+1, r19	; 0x01
    52be:	20 83       	st	Z, r18
		devices[i].parameters = parameters;
    52c0:	89 81       	ldd	r24, Y+1	; 0x01
    52c2:	9a 81       	ldd	r25, Y+2	; 0x02
    52c4:	88 0f       	add	r24, r24
    52c6:	99 1f       	adc	r25, r25
    52c8:	88 0f       	add	r24, r24
    52ca:	99 1f       	adc	r25, r25
    52cc:	88 0f       	add	r24, r24
    52ce:	99 1f       	adc	r25, r25
    52d0:	8d 51       	subi	r24, 0x1D	; 29
    52d2:	95 4e       	sbci	r25, 0xE5	; 229
    52d4:	29 85       	ldd	r18, Y+9	; 0x09
    52d6:	3a 85       	ldd	r19, Y+10	; 0x0a
    52d8:	fc 01       	movw	r30, r24
    52da:	31 83       	std	Z+1, r19	; 0x01
    52dc:	20 83       	st	Z, r18
	}
}
    52de:	2a 96       	adiw	r28, 0x0a	; 10
    52e0:	0f b6       	in	r0, 0x3f	; 63
    52e2:	f8 94       	cli
    52e4:	de bf       	out	0x3e, r29	; 62
    52e6:	0f be       	out	0x3f, r0	; 63
    52e8:	cd bf       	out	0x3d, r28	; 61
    52ea:	df 91       	pop	r29
    52ec:	cf 91       	pop	r28
    52ee:	08 95       	ret

000052f0 <__umulhisi3>:
    52f0:	a2 9f       	mul	r26, r18
    52f2:	b0 01       	movw	r22, r0
    52f4:	b3 9f       	mul	r27, r19
    52f6:	c0 01       	movw	r24, r0
    52f8:	a3 9f       	mul	r26, r19
    52fa:	70 0d       	add	r23, r0
    52fc:	81 1d       	adc	r24, r1
    52fe:	11 24       	eor	r1, r1
    5300:	91 1d       	adc	r25, r1
    5302:	b2 9f       	mul	r27, r18
    5304:	70 0d       	add	r23, r0
    5306:	81 1d       	adc	r24, r1
    5308:	11 24       	eor	r1, r1
    530a:	91 1d       	adc	r25, r1
    530c:	08 95       	ret

0000530e <__tablejump2__>:
    530e:	ee 0f       	add	r30, r30
    5310:	ff 1f       	adc	r31, r31

00005312 <__tablejump__>:
    5312:	05 90       	lpm	r0, Z+
    5314:	f4 91       	lpm	r31, Z
    5316:	e0 2d       	mov	r30, r0
    5318:	19 94       	eijmp

0000531a <memcpy>:
    531a:	fb 01       	movw	r30, r22
    531c:	dc 01       	movw	r26, r24
    531e:	02 c0       	rjmp	.+4      	; 0x5324 <memcpy+0xa>
    5320:	01 90       	ld	r0, Z+
    5322:	0d 92       	st	X+, r0
    5324:	41 50       	subi	r20, 0x01	; 1
    5326:	50 40       	sbci	r21, 0x00	; 0
    5328:	d8 f7       	brcc	.-10     	; 0x5320 <memcpy+0x6>
    532a:	08 95       	ret

0000532c <memset>:
    532c:	dc 01       	movw	r26, r24
    532e:	01 c0       	rjmp	.+2      	; 0x5332 <memset+0x6>
    5330:	6d 93       	st	X+, r22
    5332:	41 50       	subi	r20, 0x01	; 1
    5334:	50 40       	sbci	r21, 0x00	; 0
    5336:	e0 f7       	brcc	.-8      	; 0x5330 <memset+0x4>
    5338:	08 95       	ret

0000533a <strncpy>:
    533a:	fb 01       	movw	r30, r22
    533c:	dc 01       	movw	r26, r24
    533e:	41 50       	subi	r20, 0x01	; 1
    5340:	50 40       	sbci	r21, 0x00	; 0
    5342:	48 f0       	brcs	.+18     	; 0x5356 <strncpy+0x1c>
    5344:	01 90       	ld	r0, Z+
    5346:	0d 92       	st	X+, r0
    5348:	00 20       	and	r0, r0
    534a:	c9 f7       	brne	.-14     	; 0x533e <strncpy+0x4>
    534c:	01 c0       	rjmp	.+2      	; 0x5350 <strncpy+0x16>
    534e:	1d 92       	st	X+, r1
    5350:	41 50       	subi	r20, 0x01	; 1
    5352:	50 40       	sbci	r21, 0x00	; 0
    5354:	e0 f7       	brcc	.-8      	; 0x534e <strncpy+0x14>
    5356:	08 95       	ret

00005358 <_exit>:
    5358:	f8 94       	cli

0000535a <__stop_program>:
    535a:	ff cf       	rjmp	.-2      	; 0x535a <__stop_program>
