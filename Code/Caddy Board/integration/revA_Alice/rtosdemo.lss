
rtosdemo.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000002c  00800200  000048a0  00004934  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000048a0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000018b5  0080022c  0080022c  00004960  2**0
                  ALLOC
  3 .stab         0000b760  00000000  00000000  00004960  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000434e  00000000  00000000  000100c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  0001440e  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__ctors_end>
       4:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
       8:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
       c:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      10:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      14:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      18:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      1c:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      20:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      24:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      28:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      2c:	0c 94 87 20 	jmp	0x410e	; 0x410e <__vector_11>
      30:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      34:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      38:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      3c:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      40:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      44:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      48:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      4c:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      50:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      54:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      58:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      5c:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      60:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      64:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      68:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      6c:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      70:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      74:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      78:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      7c:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      80:	0c 94 fa 19 	jmp	0x33f4	; 0x33f4 <__vector_32>
      84:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      88:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      8c:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      90:	0c 94 86 1a 	jmp	0x350c	; 0x350c <__vector_36>
      94:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      98:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      9c:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      a0:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      a4:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      a8:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      ac:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      b0:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      b4:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      b8:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      bc:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      c0:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      c4:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      c8:	0c 94 ec 01 	jmp	0x3d8	; 0x3d8 <__vector_50>
      cc:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      d0:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      d4:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      d8:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      dc:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      e0:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>

000000e4 <__trampolines_start>:
      e4:	0c 94 2e 02 	jmp	0x45c	; 0x45c <vTaskFunction_1>
      e8:	0c 94 f0 1a 	jmp	0x35e0	; 0x35e0 <vTaskUSARTWrite>
      ec:	0c 94 a8 09 	jmp	0x1350	; 0x1350 <prvIdleTask>
      f0:	0c 94 20 21 	jmp	0x4240	; 0x4240 <vTaskSonar>
      f4:	0c 94 76 1c 	jmp	0x38ec	; 0x38ec <vTaskUSARTRead>

000000f8 <__ctors_end>:
      f8:	11 24       	eor	r1, r1
      fa:	1f be       	out	0x3f, r1	; 63
      fc:	cf ef       	ldi	r28, 0xFF	; 255
      fe:	d1 e2       	ldi	r29, 0x21	; 33
     100:	de bf       	out	0x3e, r29	; 62
     102:	cd bf       	out	0x3d, r28	; 61
     104:	00 e0       	ldi	r16, 0x00	; 0
     106:	0c bf       	out	0x3c, r16	; 60

00000108 <__do_copy_data>:
     108:	12 e0       	ldi	r17, 0x02	; 2
     10a:	a0 e0       	ldi	r26, 0x00	; 0
     10c:	b2 e0       	ldi	r27, 0x02	; 2
     10e:	e0 ea       	ldi	r30, 0xA0	; 160
     110:	f8 e4       	ldi	r31, 0x48	; 72
     112:	00 e0       	ldi	r16, 0x00	; 0
     114:	0b bf       	out	0x3b, r16	; 59
     116:	02 c0       	rjmp	.+4      	; 0x11c <__do_copy_data+0x14>
     118:	07 90       	elpm	r0, Z+
     11a:	0d 92       	st	X+, r0
     11c:	ac 32       	cpi	r26, 0x2C	; 44
     11e:	b1 07       	cpc	r27, r17
     120:	d9 f7       	brne	.-10     	; 0x118 <__do_copy_data+0x10>

00000122 <__do_clear_bss>:
     122:	1a e1       	ldi	r17, 0x1A	; 26
     124:	ac e2       	ldi	r26, 0x2C	; 44
     126:	b2 e0       	ldi	r27, 0x02	; 2
     128:	01 c0       	rjmp	.+2      	; 0x12c <.do_clear_bss_start>

0000012a <.do_clear_bss_loop>:
     12a:	1d 92       	st	X+, r1

0000012c <.do_clear_bss_start>:
     12c:	a1 3e       	cpi	r26, 0xE1	; 225
     12e:	b1 07       	cpc	r27, r17
     130:	e1 f7       	brne	.-8      	; 0x12a <.do_clear_bss_loop>
     132:	0e 94 b7 00 	call	0x16e	; 0x16e <main>
     136:	0c 94 4e 24 	jmp	0x489c	; 0x489c <_exit>

0000013a <__bad_interrupt>:
     13a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000013e <vApplicationTickHook>:
int count = 0;

int sonarTime;

void vApplicationTickHook()
{
     13e:	cf 93       	push	r28
     140:	df 93       	push	r29
     142:	cd b7       	in	r28, 0x3d	; 61
     144:	de b7       	in	r29, 0x3e	; 62
    count++;
     146:	80 91 2c 02 	lds	r24, 0x022C
     14a:	90 91 2d 02 	lds	r25, 0x022D
     14e:	01 96       	adiw	r24, 0x01	; 1
     150:	90 93 2d 02 	sts	0x022D, r25
     154:	80 93 2c 02 	sts	0x022C, r24
}
     158:	df 91       	pop	r29
     15a:	cf 91       	pop	r28
     15c:	08 95       	ret

0000015e <vApplicationStackOverflowHook>:

void vApplicationStackOverflowHook(){
     15e:	cf 93       	push	r28
     160:	df 93       	push	r29
     162:	cd b7       	in	r28, 0x3d	; 61
     164:	de b7       	in	r29, 0x3e	; 62
	return;
     166:	00 00       	nop
}
     168:	df 91       	pop	r29
     16a:	cf 91       	pop	r28
     16c:	08 95       	ret

0000016e <main>:
/*-----------------------------------------------------------*/

int main( void )
{
     16e:	af 92       	push	r10
     170:	bf 92       	push	r11
     172:	cf 92       	push	r12
     174:	df 92       	push	r13
     176:	ef 92       	push	r14
     178:	ff 92       	push	r15
     17a:	0f 93       	push	r16
     17c:	cf 93       	push	r28
     17e:	df 93       	push	r29
     180:	00 d0       	rcall	.+0      	; 0x182 <main+0x14>
     182:	00 d0       	rcall	.+0      	; 0x184 <main+0x16>
     184:	cd b7       	in	r28, 0x3d	; 61
     186:	de b7       	in	r29, 0x3e	; 62
    
    //- wimpy variable defs
	uint8_t val[2] = {0x3F, 0xFE};
     188:	8f e3       	ldi	r24, 0x3F	; 63
     18a:	8d 83       	std	Y+5, r24	; 0x05
     18c:	8e ef       	ldi	r24, 0xFE	; 254
     18e:	8e 83       	std	Y+6, r24	; 0x06
    uint8_t *val0, *val1;
    
	//- avoid pesky warnings...
	val0 = val + 0;
     190:	ce 01       	movw	r24, r28
     192:	05 96       	adiw	r24, 0x05	; 5
     194:	9a 83       	std	Y+2, r25	; 0x02
     196:	89 83       	std	Y+1, r24	; 0x01
	val1 = val + 1;
     198:	ce 01       	movw	r24, r28
     19a:	05 96       	adiw	r24, 0x05	; 5
     19c:	01 96       	adiw	r24, 0x01	; 1
     19e:	9c 83       	std	Y+4, r25	; 0x04
     1a0:	8b 83       	std	Y+3, r24	; 0x03
    
	DDRD = 0xFF;
     1a2:	8a e2       	ldi	r24, 0x2A	; 42
     1a4:	90 e0       	ldi	r25, 0x00	; 0
     1a6:	2f ef       	ldi	r18, 0xFF	; 255
     1a8:	fc 01       	movw	r30, r24
     1aa:	20 83       	st	Z, r18
	DDRE = 0xFF;
     1ac:	8d e2       	ldi	r24, 0x2D	; 45
     1ae:	90 e0       	ldi	r25, 0x00	; 0
     1b0:	2f ef       	ldi	r18, 0xFF	; 255
     1b2:	fc 01       	movw	r30, r24
     1b4:	20 83       	st	Z, r18
	DDRB = 0xFF; 
     1b6:	84 e2       	ldi	r24, 0x24	; 36
     1b8:	90 e0       	ldi	r25, 0x00	; 0
     1ba:	2f ef       	ldi	r18, 0xFF	; 255
     1bc:	fc 01       	movw	r30, r24
     1be:	20 83       	st	Z, r18
	DDRK = 0;
     1c0:	87 e0       	ldi	r24, 0x07	; 7
     1c2:	91 e0       	ldi	r25, 0x01	; 1
     1c4:	fc 01       	movw	r30, r24
     1c6:	10 82       	st	Z, r1

	PORTD = 0;
     1c8:	8b e2       	ldi	r24, 0x2B	; 43
     1ca:	90 e0       	ldi	r25, 0x00	; 0
     1cc:	fc 01       	movw	r30, r24
     1ce:	10 82       	st	Z, r1
	PORTE = 0;
     1d0:	8e e2       	ldi	r24, 0x2E	; 46
     1d2:	90 e0       	ldi	r25, 0x00	; 0
     1d4:	fc 01       	movw	r30, r24
     1d6:	10 82       	st	Z, r1
	PORTK = 2;
     1d8:	88 e0       	ldi	r24, 0x08	; 8
     1da:	91 e0       	ldi	r25, 0x01	; 1
     1dc:	22 e0       	ldi	r18, 0x02	; 2
     1de:	fc 01       	movw	r30, r24
     1e0:	20 83       	st	Z, r18

    //- init IO with goodness
	vIO_init();
     1e2:	0e 94 e4 02 	call	0x5c8	; 0x5c8 <vIO_init>

	//- Create a 
	xTaskCreate( (pdTASK_CODE) vTaskFunction_1, (signed char *) "T0", configMINIMAL_STACK_SIZE+1000,
     1e6:	8b 81       	ldd	r24, Y+3	; 0x03
     1e8:	9c 81       	ldd	r25, Y+4	; 0x04
     1ea:	a1 2c       	mov	r10, r1
     1ec:	b1 2c       	mov	r11, r1
     1ee:	c1 2c       	mov	r12, r1
     1f0:	d1 2c       	mov	r13, r1
     1f2:	e1 2c       	mov	r14, r1
     1f4:	f1 2c       	mov	r15, r1
     1f6:	01 e0       	ldi	r16, 0x01	; 1
     1f8:	9c 01       	movw	r18, r24
     1fa:	4d e3       	ldi	r20, 0x3D	; 61
     1fc:	54 e0       	ldi	r21, 0x04	; 4
     1fe:	62 e0       	ldi	r22, 0x02	; 2
     200:	72 e0       	ldi	r23, 0x02	; 2
     202:	8e e2       	ldi	r24, 0x2E	; 46
     204:	92 e0       	ldi	r25, 0x02	; 2
     206:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <xTaskGenericCreate>
                (void *) val1, 1, NULL );
	xTaskCreate( (pdTASK_CODE) vTaskPot, (signed char *) "T0", configMINIMAL_STACK_SIZE+1000,
                (void *) val1, 1, NULL );*/

 
   xTaskCreate( (pdTASK_CODE) vTaskSonar, (signed char *) "T1", configMINIMAL_STACK_SIZE+1000,
     20a:	8b 81       	ldd	r24, Y+3	; 0x03
     20c:	9c 81       	ldd	r25, Y+4	; 0x04
     20e:	a1 2c       	mov	r10, r1
     210:	b1 2c       	mov	r11, r1
     212:	c1 2c       	mov	r12, r1
     214:	d1 2c       	mov	r13, r1
     216:	e1 2c       	mov	r14, r1
     218:	f1 2c       	mov	r15, r1
     21a:	01 e0       	ldi	r16, 0x01	; 1
     21c:	9c 01       	movw	r18, r24
     21e:	4d e3       	ldi	r20, 0x3D	; 61
     220:	54 e0       	ldi	r21, 0x04	; 4
     222:	65 e0       	ldi	r22, 0x05	; 5
     224:	72 e0       	ldi	r23, 0x02	; 2
     226:	80 e2       	ldi	r24, 0x20	; 32
     228:	91 e2       	ldi	r25, 0x21	; 33
     22a:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <xTaskGenericCreate>
                (void *) val1, 1, NULL );

   xTaskCreate( (pdTASK_CODE) vTaskUSARTWrite, (signed char *) "T2", configMINIMAL_STACK_SIZE+1000,
     22e:	8b 81       	ldd	r24, Y+3	; 0x03
     230:	9c 81       	ldd	r25, Y+4	; 0x04
     232:	a1 2c       	mov	r10, r1
     234:	b1 2c       	mov	r11, r1
     236:	c1 2c       	mov	r12, r1
     238:	d1 2c       	mov	r13, r1
     23a:	e1 2c       	mov	r14, r1
     23c:	f1 2c       	mov	r15, r1
     23e:	01 e0       	ldi	r16, 0x01	; 1
     240:	9c 01       	movw	r18, r24
     242:	4d e3       	ldi	r20, 0x3D	; 61
     244:	54 e0       	ldi	r21, 0x04	; 4
     246:	68 e0       	ldi	r22, 0x08	; 8
     248:	72 e0       	ldi	r23, 0x02	; 2
     24a:	80 ef       	ldi	r24, 0xF0	; 240
     24c:	9a e1       	ldi	r25, 0x1A	; 26
     24e:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <xTaskGenericCreate>
   				(void *) val1, 1, NULL);

   xTaskCreate( (pdTASK_CODE) vTaskUSARTRead, (signed char *) "T3", configMINIMAL_STACK_SIZE+1000,
     252:	8b 81       	ldd	r24, Y+3	; 0x03
     254:	9c 81       	ldd	r25, Y+4	; 0x04
     256:	a1 2c       	mov	r10, r1
     258:	b1 2c       	mov	r11, r1
     25a:	c1 2c       	mov	r12, r1
     25c:	d1 2c       	mov	r13, r1
     25e:	e1 2c       	mov	r14, r1
     260:	f1 2c       	mov	r15, r1
     262:	01 e0       	ldi	r16, 0x01	; 1
     264:	9c 01       	movw	r18, r24
     266:	4d e3       	ldi	r20, 0x3D	; 61
     268:	54 e0       	ldi	r21, 0x04	; 4
     26a:	6b e0       	ldi	r22, 0x0B	; 11
     26c:	72 e0       	ldi	r23, 0x02	; 2
     26e:	86 e7       	ldi	r24, 0x76	; 118
     270:	9c e1       	ldi	r25, 0x1C	; 28
     272:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <xTaskGenericCreate>

//   xTaskCreate( (pdTASK_CODE) vTaskUSARTLog, (signed char *) "T4", configMINIMAL_STACK_SIZE+1000,
//   				(void *) val1, 1, NULL);
    
    //- kick off the scheduler
	vTaskStartScheduler();
     276:	0e 94 f3 05 	call	0xbe6	; 0xbe6 <vTaskStartScheduler>
    
	return 0;
     27a:	80 e0       	ldi	r24, 0x00	; 0
     27c:	90 e0       	ldi	r25, 0x00	; 0
}
     27e:	26 96       	adiw	r28, 0x06	; 6
     280:	0f b6       	in	r0, 0x3f	; 63
     282:	f8 94       	cli
     284:	de bf       	out	0x3e, r29	; 62
     286:	0f be       	out	0x3f, r0	; 63
     288:	cd bf       	out	0x3d, r28	; 61
     28a:	df 91       	pop	r29
     28c:	cf 91       	pop	r28
     28e:	0f 91       	pop	r16
     290:	ff 90       	pop	r15
     292:	ef 90       	pop	r14
     294:	df 90       	pop	r13
     296:	cf 90       	pop	r12
     298:	bf 90       	pop	r11
     29a:	af 90       	pop	r10
     29c:	08 95       	ret

0000029e <printHex>:
/*-----------------------------------------------------------*/

void printHex(int i){
     29e:	cf 93       	push	r28
     2a0:	df 93       	push	r29
     2a2:	cd b7       	in	r28, 0x3d	; 61
     2a4:	de b7       	in	r29, 0x3e	; 62
     2a6:	62 97       	sbiw	r28, 0x12	; 18
     2a8:	0f b6       	in	r0, 0x3f	; 63
     2aa:	f8 94       	cli
     2ac:	de bf       	out	0x3e, r29	; 62
     2ae:	0f be       	out	0x3f, r0	; 63
     2b0:	cd bf       	out	0x3d, r28	; 61
     2b2:	9a 8b       	std	Y+18, r25	; 0x12
     2b4:	89 8b       	std	Y+17, r24	; 0x11
	char hex[] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
     2b6:	20 e1       	ldi	r18, 0x10	; 16
     2b8:	ee e0       	ldi	r30, 0x0E	; 14
     2ba:	f2 e0       	ldi	r31, 0x02	; 2
     2bc:	ce 01       	movw	r24, r28
     2be:	01 96       	adiw	r24, 0x01	; 1
     2c0:	dc 01       	movw	r26, r24
     2c2:	01 90       	ld	r0, Z+
     2c4:	0d 92       	st	X+, r0
     2c6:	2a 95       	dec	r18
     2c8:	e1 f7       	brne	.-8      	; 0x2c2 <printHex+0x24>

	USART_Write(hex[(i&0xF000) >> 12]);
     2ca:	89 89       	ldd	r24, Y+17	; 0x11
     2cc:	9a 89       	ldd	r25, Y+18	; 0x12
     2ce:	89 2f       	mov	r24, r25
     2d0:	99 27       	eor	r25, r25
     2d2:	82 95       	swap	r24
     2d4:	8f 70       	andi	r24, 0x0F	; 15
     2d6:	9e 01       	movw	r18, r28
     2d8:	2f 5f       	subi	r18, 0xFF	; 255
     2da:	3f 4f       	sbci	r19, 0xFF	; 255
     2dc:	82 0f       	add	r24, r18
     2de:	93 1f       	adc	r25, r19
     2e0:	fc 01       	movw	r30, r24
     2e2:	80 81       	ld	r24, Z
     2e4:	0e 94 40 1a 	call	0x3480	; 0x3480 <USART_Write>
	USART_Write(hex[(i&0xF00) >> 8]);
     2e8:	89 89       	ldd	r24, Y+17	; 0x11
     2ea:	9a 89       	ldd	r25, Y+18	; 0x12
     2ec:	88 27       	eor	r24, r24
     2ee:	9f 70       	andi	r25, 0x0F	; 15
     2f0:	89 2f       	mov	r24, r25
     2f2:	99 0f       	add	r25, r25
     2f4:	99 0b       	sbc	r25, r25
     2f6:	9e 01       	movw	r18, r28
     2f8:	2f 5f       	subi	r18, 0xFF	; 255
     2fa:	3f 4f       	sbci	r19, 0xFF	; 255
     2fc:	82 0f       	add	r24, r18
     2fe:	93 1f       	adc	r25, r19
     300:	fc 01       	movw	r30, r24
     302:	80 81       	ld	r24, Z
     304:	0e 94 40 1a 	call	0x3480	; 0x3480 <USART_Write>
	USART_Write(hex[(i&0xF0) >> 4]);
     308:	89 89       	ldd	r24, Y+17	; 0x11
     30a:	9a 89       	ldd	r25, Y+18	; 0x12
     30c:	80 7f       	andi	r24, 0xF0	; 240
     30e:	99 27       	eor	r25, r25
     310:	95 95       	asr	r25
     312:	87 95       	ror	r24
     314:	95 95       	asr	r25
     316:	87 95       	ror	r24
     318:	95 95       	asr	r25
     31a:	87 95       	ror	r24
     31c:	95 95       	asr	r25
     31e:	87 95       	ror	r24
     320:	9e 01       	movw	r18, r28
     322:	2f 5f       	subi	r18, 0xFF	; 255
     324:	3f 4f       	sbci	r19, 0xFF	; 255
     326:	82 0f       	add	r24, r18
     328:	93 1f       	adc	r25, r19
     32a:	fc 01       	movw	r30, r24
     32c:	80 81       	ld	r24, Z
     32e:	0e 94 40 1a 	call	0x3480	; 0x3480 <USART_Write>
	USART_Write(hex[i&0xF]);
     332:	89 89       	ldd	r24, Y+17	; 0x11
     334:	9a 89       	ldd	r25, Y+18	; 0x12
     336:	8f 70       	andi	r24, 0x0F	; 15
     338:	99 27       	eor	r25, r25
     33a:	9e 01       	movw	r18, r28
     33c:	2f 5f       	subi	r18, 0xFF	; 255
     33e:	3f 4f       	sbci	r19, 0xFF	; 255
     340:	82 0f       	add	r24, r18
     342:	93 1f       	adc	r25, r19
     344:	fc 01       	movw	r30, r24
     346:	80 81       	ld	r24, Z
     348:	0e 94 40 1a 	call	0x3480	; 0x3480 <USART_Write>

}
     34c:	62 96       	adiw	r28, 0x12	; 18
     34e:	0f b6       	in	r0, 0x3f	; 63
     350:	f8 94       	cli
     352:	de bf       	out	0x3e, r29	; 62
     354:	0f be       	out	0x3f, r0	; 63
     356:	cd bf       	out	0x3d, r28	; 61
     358:	df 91       	pop	r29
     35a:	cf 91       	pop	r28
     35c:	08 95       	ret

0000035e <printNum>:

void printNum(unsigned char i){
     35e:	cf 93       	push	r28
     360:	df 93       	push	r29
     362:	cd b7       	in	r28, 0x3d	; 61
     364:	de b7       	in	r29, 0x3e	; 62
     366:	2d 97       	sbiw	r28, 0x0d	; 13
     368:	0f b6       	in	r0, 0x3f	; 63
     36a:	f8 94       	cli
     36c:	de bf       	out	0x3e, r29	; 62
     36e:	0f be       	out	0x3f, r0	; 63
     370:	cd bf       	out	0x3d, r28	; 61
     372:	8d 87       	std	Y+13, r24	; 0x0d
    
    char str[10];
    memset(str,0,10);
     374:	ce 01       	movw	r24, r28
     376:	03 96       	adiw	r24, 0x03	; 3
     378:	4a e0       	ldi	r20, 0x0A	; 10
     37a:	50 e0       	ldi	r21, 0x00	; 0
     37c:	60 e0       	ldi	r22, 0x00	; 0
     37e:	70 e0       	ldi	r23, 0x00	; 0
     380:	0e 94 f3 23 	call	0x47e6	; 0x47e6 <memset>
    itoa(i,str,10);
     384:	8d 85       	ldd	r24, Y+13	; 0x0d
     386:	88 2f       	mov	r24, r24
     388:	90 e0       	ldi	r25, 0x00	; 0
     38a:	9e 01       	movw	r18, r28
     38c:	2d 5f       	subi	r18, 0xFD	; 253
     38e:	3f 4f       	sbci	r19, 0xFF	; 255
     390:	4a e0       	ldi	r20, 0x0A	; 10
     392:	50 e0       	ldi	r21, 0x00	; 0
     394:	b9 01       	movw	r22, r18
     396:	0e 94 09 24 	call	0x4812	; 0x4812 <itoa>
    char * irr = str;
     39a:	ce 01       	movw	r24, r28
     39c:	03 96       	adiw	r24, 0x03	; 3
     39e:	9a 83       	std	Y+2, r25	; 0x02
     3a0:	89 83       	std	Y+1, r24	; 0x01
    while(*irr){
     3a2:	0b c0       	rjmp	.+22     	; 0x3ba <printNum+0x5c>
        USART_AddToQueue((unsigned char )*irr);
     3a4:	89 81       	ldd	r24, Y+1	; 0x01
     3a6:	9a 81       	ldd	r25, Y+2	; 0x02
     3a8:	fc 01       	movw	r30, r24
     3aa:	80 81       	ld	r24, Z
     3ac:	0e 94 bb 1a 	call	0x3576	; 0x3576 <USART_AddToQueue>
        irr++;
     3b0:	89 81       	ldd	r24, Y+1	; 0x01
     3b2:	9a 81       	ldd	r25, Y+2	; 0x02
     3b4:	01 96       	adiw	r24, 0x01	; 1
     3b6:	9a 83       	std	Y+2, r25	; 0x02
     3b8:	89 83       	std	Y+1, r24	; 0x01
    
    char str[10];
    memset(str,0,10);
    itoa(i,str,10);
    char * irr = str;
    while(*irr){
     3ba:	89 81       	ldd	r24, Y+1	; 0x01
     3bc:	9a 81       	ldd	r25, Y+2	; 0x02
     3be:	fc 01       	movw	r30, r24
     3c0:	80 81       	ld	r24, Z
     3c2:	88 23       	and	r24, r24
     3c4:	79 f7       	brne	.-34     	; 0x3a4 <printNum+0x46>
        USART_AddToQueue((unsigned char )*irr);
        irr++;
    }
    
}
     3c6:	2d 96       	adiw	r28, 0x0d	; 13
     3c8:	0f b6       	in	r0, 0x3f	; 63
     3ca:	f8 94       	cli
     3cc:	de bf       	out	0x3e, r29	; 62
     3ce:	0f be       	out	0x3f, r0	; 63
     3d0:	cd bf       	out	0x3d, r28	; 61
     3d2:	df 91       	pop	r29
     3d4:	cf 91       	pop	r28
     3d6:	08 95       	ret

000003d8 <__vector_50>:

ISR(TIMER5_OVF_vect){
     3d8:	1f 92       	push	r1
     3da:	0f 92       	push	r0
     3dc:	00 90 5f 00 	lds	r0, 0x005F
     3e0:	0f 92       	push	r0
     3e2:	11 24       	eor	r1, r1
     3e4:	00 90 5b 00 	lds	r0, 0x005B
     3e8:	0f 92       	push	r0
     3ea:	2f 93       	push	r18
     3ec:	3f 93       	push	r19
     3ee:	8f 93       	push	r24
     3f0:	9f 93       	push	r25
     3f2:	ef 93       	push	r30
     3f4:	ff 93       	push	r31
     3f6:	cf 93       	push	r28
     3f8:	df 93       	push	r29
     3fa:	cd b7       	in	r28, 0x3d	; 61
     3fc:	de b7       	in	r29, 0x3e	; 62

	PORTB ^= 0xFF;
     3fe:	85 e2       	ldi	r24, 0x25	; 37
     400:	90 e0       	ldi	r25, 0x00	; 0
     402:	25 e2       	ldi	r18, 0x25	; 37
     404:	30 e0       	ldi	r19, 0x00	; 0
     406:	f9 01       	movw	r30, r18
     408:	20 81       	ld	r18, Z
     40a:	20 95       	com	r18
     40c:	fc 01       	movw	r30, r24
     40e:	20 83       	st	Z, r18
	TCNT3L = 0;
     410:	84 e9       	ldi	r24, 0x94	; 148
     412:	90 e0       	ldi	r25, 0x00	; 0
     414:	fc 01       	movw	r30, r24
     416:	10 82       	st	Z, r1
	TCNT3H = 0;
     418:	85 e9       	ldi	r24, 0x95	; 149
     41a:	90 e0       	ldi	r25, 0x00	; 0
     41c:	fc 01       	movw	r30, r24
     41e:	10 82       	st	Z, r1

}
     420:	df 91       	pop	r29
     422:	cf 91       	pop	r28
     424:	ff 91       	pop	r31
     426:	ef 91       	pop	r30
     428:	9f 91       	pop	r25
     42a:	8f 91       	pop	r24
     42c:	3f 91       	pop	r19
     42e:	2f 91       	pop	r18
     430:	0f 90       	pop	r0
     432:	00 92 5b 00 	sts	0x005B, r0
     436:	0f 90       	pop	r0
     438:	00 92 5f 00 	sts	0x005F, r0
     43c:	0f 90       	pop	r0
     43e:	1f 90       	pop	r1
     440:	18 95       	reti

00000442 <getTimerCount2>:

unsigned int getTimerCount2(){
     442:	cf 93       	push	r28
     444:	df 93       	push	r29
     446:	cd b7       	in	r28, 0x3d	; 61
     448:	de b7       	in	r29, 0x3e	; 62

	//volatile char timerLow = TCNT3L;

	return TCNT0;
     44a:	86 e4       	ldi	r24, 0x46	; 70
     44c:	90 e0       	ldi	r25, 0x00	; 0
     44e:	fc 01       	movw	r30, r24
     450:	80 81       	ld	r24, Z
     452:	88 2f       	mov	r24, r24
     454:	90 e0       	ldi	r25, 0x00	; 0

}
     456:	df 91       	pop	r29
     458:	cf 91       	pop	r28
     45a:	08 95       	ret

0000045c <vTaskFunction_1>:

void vTaskFunction_1(void *pvParameters)
{	
     45c:	cf 93       	push	r28
     45e:	df 93       	push	r29
     460:	1f 92       	push	r1
     462:	1f 92       	push	r1
     464:	cd b7       	in	r28, 0x3d	; 61
     466:	de b7       	in	r29, 0x3e	; 62
     468:	9a 83       	std	Y+2, r25	; 0x02
     46a:	89 83       	std	Y+1, r24	; 0x01
   USART_Init(9600, 16000000);
     46c:	40 e0       	ldi	r20, 0x00	; 0
     46e:	54 e2       	ldi	r21, 0x24	; 36
     470:	64 ef       	ldi	r22, 0xF4	; 244
     472:	70 e0       	ldi	r23, 0x00	; 0
     474:	80 e8       	ldi	r24, 0x80	; 128
     476:	95 e2       	ldi	r25, 0x25	; 37
     478:	0e 94 fd 19 	call	0x33fa	; 0x33fa <USART_Init>
	for(;;);
     47c:	ff cf       	rjmp	.-2      	; 0x47c <vTaskFunction_1+0x20>

0000047e <vTaskFunction_2>:
		PORTL = 0x80;
		vTaskDelay(200);
	}
}

void vTaskFunction_2(void *pvParameters){
     47e:	cf 93       	push	r28
     480:	df 93       	push	r29
     482:	1f 92       	push	r1
     484:	1f 92       	push	r1
     486:	cd b7       	in	r28, 0x3d	; 61
     488:	de b7       	in	r29, 0x3e	; 62
     48a:	9a 83       	std	Y+2, r25	; 0x02
     48c:	89 83       	std	Y+1, r24	; 0x01
	DDRA = ~(1 << 3);
     48e:	81 e2       	ldi	r24, 0x21	; 33
     490:	90 e0       	ldi	r25, 0x00	; 0
     492:	27 ef       	ldi	r18, 0xF7	; 247
     494:	fc 01       	movw	r30, r24
     496:	20 83       	st	Z, r18
	PORTA |= 3;
     498:	82 e2       	ldi	r24, 0x22	; 34
     49a:	90 e0       	ldi	r25, 0x00	; 0
     49c:	22 e2       	ldi	r18, 0x22	; 34
     49e:	30 e0       	ldi	r19, 0x00	; 0
     4a0:	f9 01       	movw	r30, r18
     4a2:	20 81       	ld	r18, Z
     4a4:	23 60       	ori	r18, 0x03	; 3
     4a6:	fc 01       	movw	r30, r24
     4a8:	20 83       	st	Z, r18
	for(;;){
		PORTA &= ~3;
     4aa:	82 e2       	ldi	r24, 0x22	; 34
     4ac:	90 e0       	ldi	r25, 0x00	; 0
     4ae:	22 e2       	ldi	r18, 0x22	; 34
     4b0:	30 e0       	ldi	r19, 0x00	; 0
     4b2:	f9 01       	movw	r30, r18
     4b4:	20 81       	ld	r18, Z
     4b6:	2c 7f       	andi	r18, 0xFC	; 252
     4b8:	fc 01       	movw	r30, r24
     4ba:	20 83       	st	Z, r18
		vTaskDelay(200); 
     4bc:	88 ec       	ldi	r24, 0xC8	; 200
     4be:	90 e0       	ldi	r25, 0x00	; 0
     4c0:	0e 94 61 04 	call	0x8c2	; 0x8c2 <vTaskDelay>
		PORTA &= ~3;
     4c4:	82 e2       	ldi	r24, 0x22	; 34
     4c6:	90 e0       	ldi	r25, 0x00	; 0
     4c8:	22 e2       	ldi	r18, 0x22	; 34
     4ca:	30 e0       	ldi	r19, 0x00	; 0
     4cc:	f9 01       	movw	r30, r18
     4ce:	20 81       	ld	r18, Z
     4d0:	2c 7f       	andi	r18, 0xFC	; 252
     4d2:	fc 01       	movw	r30, r24
     4d4:	20 83       	st	Z, r18
		PORTA |= 1;
     4d6:	82 e2       	ldi	r24, 0x22	; 34
     4d8:	90 e0       	ldi	r25, 0x00	; 0
     4da:	22 e2       	ldi	r18, 0x22	; 34
     4dc:	30 e0       	ldi	r19, 0x00	; 0
     4de:	f9 01       	movw	r30, r18
     4e0:	20 81       	ld	r18, Z
     4e2:	21 60       	ori	r18, 0x01	; 1
     4e4:	fc 01       	movw	r30, r24
     4e6:	20 83       	st	Z, r18
		vTaskDelay(200); 
     4e8:	88 ec       	ldi	r24, 0xC8	; 200
     4ea:	90 e0       	ldi	r25, 0x00	; 0
     4ec:	0e 94 61 04 	call	0x8c2	; 0x8c2 <vTaskDelay>
		PORTA &= ~3;
     4f0:	82 e2       	ldi	r24, 0x22	; 34
     4f2:	90 e0       	ldi	r25, 0x00	; 0
     4f4:	22 e2       	ldi	r18, 0x22	; 34
     4f6:	30 e0       	ldi	r19, 0x00	; 0
     4f8:	f9 01       	movw	r30, r18
     4fa:	20 81       	ld	r18, Z
     4fc:	2c 7f       	andi	r18, 0xFC	; 252
     4fe:	fc 01       	movw	r30, r24
     500:	20 83       	st	Z, r18
		PORTA |= 2;
     502:	82 e2       	ldi	r24, 0x22	; 34
     504:	90 e0       	ldi	r25, 0x00	; 0
     506:	22 e2       	ldi	r18, 0x22	; 34
     508:	30 e0       	ldi	r19, 0x00	; 0
     50a:	f9 01       	movw	r30, r18
     50c:	20 81       	ld	r18, Z
     50e:	22 60       	ori	r18, 0x02	; 2
     510:	fc 01       	movw	r30, r24
     512:	20 83       	st	Z, r18
		vTaskDelay(200);
     514:	88 ec       	ldi	r24, 0xC8	; 200
     516:	90 e0       	ldi	r25, 0x00	; 0
     518:	0e 94 61 04 	call	0x8c2	; 0x8c2 <vTaskDelay>
	}	
     51c:	c6 cf       	rjmp	.-116    	; 0x4aa <vTaskFunction_2+0x2c>

0000051e <vTaskFunction_3>:
}

void vTaskFunction_3(void *pvParameters){
     51e:	cf 93       	push	r28
     520:	df 93       	push	r29
     522:	1f 92       	push	r1
     524:	1f 92       	push	r1
     526:	cd b7       	in	r28, 0x3d	; 61
     528:	de b7       	in	r29, 0x3e	; 62
     52a:	9a 83       	std	Y+2, r25	; 0x02
     52c:	89 83       	std	Y+1, r24	; 0x01

	for(;;){
		if(PINA & 0x08){
     52e:	80 e2       	ldi	r24, 0x20	; 32
     530:	90 e0       	ldi	r25, 0x00	; 0
     532:	fc 01       	movw	r30, r24
     534:	80 81       	ld	r24, Z
     536:	88 2f       	mov	r24, r24
     538:	90 e0       	ldi	r25, 0x00	; 0
     53a:	88 70       	andi	r24, 0x08	; 8
     53c:	99 27       	eor	r25, r25
     53e:	00 97       	sbiw	r24, 0x00	; 0
     540:	51 f0       	breq	.+20     	; 0x556 <vTaskFunction_3+0x38>
			PORTA |= 0x80;
     542:	82 e2       	ldi	r24, 0x22	; 34
     544:	90 e0       	ldi	r25, 0x00	; 0
     546:	22 e2       	ldi	r18, 0x22	; 34
     548:	30 e0       	ldi	r19, 0x00	; 0
     54a:	f9 01       	movw	r30, r18
     54c:	20 81       	ld	r18, Z
     54e:	20 68       	ori	r18, 0x80	; 128
     550:	fc 01       	movw	r30, r24
     552:	20 83       	st	Z, r18
		} else {
			PORTA &= ~0x80;
		}
	}
     554:	ec cf       	rjmp	.-40     	; 0x52e <vTaskFunction_3+0x10>

	for(;;){
		if(PINA & 0x08){
			PORTA |= 0x80;
		} else {
			PORTA &= ~0x80;
     556:	82 e2       	ldi	r24, 0x22	; 34
     558:	90 e0       	ldi	r25, 0x00	; 0
     55a:	22 e2       	ldi	r18, 0x22	; 34
     55c:	30 e0       	ldi	r19, 0x00	; 0
     55e:	f9 01       	movw	r30, r18
     560:	20 81       	ld	r18, Z
     562:	2f 77       	andi	r18, 0x7F	; 127
     564:	fc 01       	movw	r30, r24
     566:	20 83       	st	Z, r18
		}
	}
     568:	e2 cf       	rjmp	.-60     	; 0x52e <vTaskFunction_3+0x10>

0000056a <vTaskPot>:

}

void vTaskPot(void *pvParameters){
     56a:	cf 93       	push	r28
     56c:	df 93       	push	r29
     56e:	00 d0       	rcall	.+0      	; 0x570 <vTaskPot+0x6>
     570:	1f 92       	push	r1
     572:	cd b7       	in	r28, 0x3d	; 61
     574:	de b7       	in	r29, 0x3e	; 62
     576:	9c 83       	std	Y+4, r25	; 0x04
     578:	8b 83       	std	Y+3, r24	; 0x03
	initializeSPI();
     57a:	0e 94 dc 22 	call	0x45b8	; 0x45b8 <initializeSPI>
	int a = 0;
     57e:	1a 82       	std	Y+2, r1	; 0x02
     580:	19 82       	std	Y+1, r1	; 0x01
	initSpeedController();
     582:	0e 94 38 22 	call	0x4470	; 0x4470 <initSpeedController>
		setPot(a);
		vTaskDelay(80);
		a++;
	}*/
	for(;;){
		setPot(1);
     586:	81 e0       	ldi	r24, 0x01	; 1
     588:	90 e0       	ldi	r25, 0x00	; 0
     58a:	0e 94 43 22 	call	0x4486	; 0x4486 <setPot>
		vTaskDelay(500);
     58e:	84 ef       	ldi	r24, 0xF4	; 244
     590:	91 e0       	ldi	r25, 0x01	; 1
     592:	0e 94 61 04 	call	0x8c2	; 0x8c2 <vTaskDelay>
		setPot(0x40);
     596:	80 e4       	ldi	r24, 0x40	; 64
     598:	90 e0       	ldi	r25, 0x00	; 0
     59a:	0e 94 43 22 	call	0x4486	; 0x4486 <setPot>
		vTaskDelay(500);
     59e:	84 ef       	ldi	r24, 0xF4	; 244
     5a0:	91 e0       	ldi	r25, 0x01	; 1
     5a2:	0e 94 61 04 	call	0x8c2	; 0x8c2 <vTaskDelay>
		setPot(0x7F);
     5a6:	8f e7       	ldi	r24, 0x7F	; 127
     5a8:	90 e0       	ldi	r25, 0x00	; 0
     5aa:	0e 94 43 22 	call	0x4486	; 0x4486 <setPot>
		vTaskDelay(500);
     5ae:	84 ef       	ldi	r24, 0xF4	; 244
     5b0:	91 e0       	ldi	r25, 0x01	; 1
     5b2:	0e 94 61 04 	call	0x8c2	; 0x8c2 <vTaskDelay>
		setPot(0x40);
     5b6:	80 e4       	ldi	r24, 0x40	; 64
     5b8:	90 e0       	ldi	r25, 0x00	; 0
     5ba:	0e 94 43 22 	call	0x4486	; 0x4486 <setPot>
		vTaskDelay(500);
     5be:	84 ef       	ldi	r24, 0xF4	; 244
     5c0:	91 e0       	ldi	r25, 0x01	; 1
     5c2:	0e 94 61 04 	call	0x8c2	; 0x8c2 <vTaskDelay>
	}
     5c6:	df cf       	rjmp	.-66     	; 0x586 <vTaskPot+0x1c>

000005c8 <vIO_init>:
}


void vIO_init(void)
{
     5c8:	cf 93       	push	r28
     5ca:	df 93       	push	r29
     5cc:	cd b7       	in	r28, 0x3d	; 61
     5ce:	de b7       	in	r29, 0x3e	; 62
    //- set PortB as output
	DDRB = 0xFF; 
     5d0:	84 e2       	ldi	r24, 0x24	; 36
     5d2:	90 e0       	ldi	r25, 0x00	; 0
     5d4:	2f ef       	ldi	r18, 0xFF	; 255
     5d6:	fc 01       	movw	r30, r24
     5d8:	20 83       	st	Z, r18
    PORTB = 0; 
     5da:	85 e2       	ldi	r24, 0x25	; 37
     5dc:	90 e0       	ldi	r25, 0x00	; 0
     5de:	fc 01       	movw	r30, r24
     5e0:	10 82       	st	Z, r1
}
     5e2:	df 91       	pop	r29
     5e4:	cf 91       	pop	r28
     5e6:	08 95       	ret

000005e8 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
     5e8:	af 92       	push	r10
     5ea:	bf 92       	push	r11
     5ec:	cf 92       	push	r12
     5ee:	df 92       	push	r13
     5f0:	ef 92       	push	r14
     5f2:	ff 92       	push	r15
     5f4:	0f 93       	push	r16
     5f6:	1f 93       	push	r17
     5f8:	cf 93       	push	r28
     5fa:	df 93       	push	r29
     5fc:	cd b7       	in	r28, 0x3d	; 61
     5fe:	de b7       	in	r29, 0x3e	; 62
     600:	64 97       	sbiw	r28, 0x14	; 20
     602:	0f b6       	in	r0, 0x3f	; 63
     604:	f8 94       	cli
     606:	de bf       	out	0x3e, r29	; 62
     608:	0f be       	out	0x3f, r0	; 63
     60a:	cd bf       	out	0x3d, r28	; 61
     60c:	9f 83       	std	Y+7, r25	; 0x07
     60e:	8e 83       	std	Y+6, r24	; 0x06
     610:	79 87       	std	Y+9, r23	; 0x09
     612:	68 87       	std	Y+8, r22	; 0x08
     614:	5b 87       	std	Y+11, r21	; 0x0b
     616:	4a 87       	std	Y+10, r20	; 0x0a
     618:	3d 87       	std	Y+13, r19	; 0x0d
     61a:	2c 87       	std	Y+12, r18	; 0x0c
     61c:	0e 87       	std	Y+14, r16	; 0x0e
     61e:	f8 8a       	std	Y+16, r15	; 0x10
     620:	ef 86       	std	Y+15, r14	; 0x0f
     622:	da 8a       	std	Y+18, r13	; 0x12
     624:	c9 8a       	std	Y+17, r12	; 0x11
     626:	bc 8a       	std	Y+20, r11	; 0x14
     628:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
     62a:	29 89       	ldd	r18, Y+17	; 0x11
     62c:	3a 89       	ldd	r19, Y+18	; 0x12
     62e:	8a 85       	ldd	r24, Y+10	; 0x0a
     630:	9b 85       	ldd	r25, Y+11	; 0x0b
     632:	b9 01       	movw	r22, r18
     634:	0e 94 aa 0a 	call	0x1554	; 0x1554 <prvAllocateTCBAndStack>
     638:	9b 83       	std	Y+3, r25	; 0x03
     63a:	8a 83       	std	Y+2, r24	; 0x02

	if( pxNewTCB != NULL )
     63c:	8a 81       	ldd	r24, Y+2	; 0x02
     63e:	9b 81       	ldd	r25, Y+3	; 0x03
     640:	00 97       	sbiw	r24, 0x00	; 0
     642:	09 f4       	brne	.+2      	; 0x646 <xTaskGenericCreate+0x5e>
     644:	9f c0       	rjmp	.+318    	; 0x784 <xTaskGenericCreate+0x19c>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
     646:	8a 81       	ldd	r24, Y+2	; 0x02
     648:	9b 81       	ldd	r25, Y+3	; 0x03
     64a:	fc 01       	movw	r30, r24
     64c:	27 89       	ldd	r18, Z+23	; 0x17
     64e:	30 8d       	ldd	r19, Z+24	; 0x18
     650:	8a 85       	ldd	r24, Y+10	; 0x0a
     652:	9b 85       	ldd	r25, Y+11	; 0x0b
     654:	01 97       	sbiw	r24, 0x01	; 1
     656:	82 0f       	add	r24, r18
     658:	93 1f       	adc	r25, r19
     65a:	9d 83       	std	Y+5, r25	; 0x05
     65c:	8c 83       	std	Y+4, r24	; 0x04
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
     65e:	4a 85       	ldd	r20, Y+10	; 0x0a
     660:	5b 85       	ldd	r21, Y+11	; 0x0b
     662:	2b 89       	ldd	r18, Y+19	; 0x13
     664:	3c 89       	ldd	r19, Y+20	; 0x14
     666:	68 85       	ldd	r22, Y+8	; 0x08
     668:	79 85       	ldd	r23, Y+9	; 0x09
     66a:	8a 81       	ldd	r24, Y+2	; 0x02
     66c:	9b 81       	ldd	r25, Y+3	; 0x03
     66e:	8a 01       	movw	r16, r20
     670:	4e 85       	ldd	r20, Y+14	; 0x0e
     672:	0e 94 ba 09 	call	0x1374	; 0x1374 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     676:	4c 85       	ldd	r20, Y+12	; 0x0c
     678:	5d 85       	ldd	r21, Y+13	; 0x0d
     67a:	2e 81       	ldd	r18, Y+6	; 0x06
     67c:	3f 81       	ldd	r19, Y+7	; 0x07
     67e:	8c 81       	ldd	r24, Y+4	; 0x04
     680:	9d 81       	ldd	r25, Y+5	; 0x05
     682:	b9 01       	movw	r22, r18
     684:	0e 94 d2 16 	call	0x2da4	; 0x2da4 <pxPortInitialiseStack>
     688:	9c 01       	movw	r18, r24
     68a:	8a 81       	ldd	r24, Y+2	; 0x02
     68c:	9b 81       	ldd	r25, Y+3	; 0x03
     68e:	fc 01       	movw	r30, r24
     690:	31 83       	std	Z+1, r19	; 0x01
     692:	20 83       	st	Z, r18
		#endif

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
     694:	8f 85       	ldd	r24, Y+15	; 0x0f
     696:	98 89       	ldd	r25, Y+16	; 0x10
     698:	00 97       	sbiw	r24, 0x00	; 0
     69a:	39 f0       	breq	.+14     	; 0x6aa <xTaskGenericCreate+0xc2>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
     69c:	8f 85       	ldd	r24, Y+15	; 0x0f
     69e:	98 89       	ldd	r25, Y+16	; 0x10
     6a0:	2a 81       	ldd	r18, Y+2	; 0x02
     6a2:	3b 81       	ldd	r19, Y+3	; 0x03
     6a4:	fc 01       	movw	r30, r24
     6a6:	31 83       	std	Z+1, r19	; 0x01
     6a8:	20 83       	st	Z, r18
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
     6aa:	0f b6       	in	r0, 0x3f	; 63
     6ac:	f8 94       	cli
     6ae:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
     6b0:	80 91 7c 02 	lds	r24, 0x027C
     6b4:	8f 5f       	subi	r24, 0xFF	; 255
     6b6:	80 93 7c 02 	sts	0x027C, r24
			if( pxCurrentTCB == NULL )
     6ba:	80 91 2e 02 	lds	r24, 0x022E
     6be:	90 91 2f 02 	lds	r25, 0x022F
     6c2:	00 97       	sbiw	r24, 0x00	; 0
     6c4:	69 f4       	brne	.+26     	; 0x6e0 <xTaskGenericCreate+0xf8>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
     6c6:	8a 81       	ldd	r24, Y+2	; 0x02
     6c8:	9b 81       	ldd	r25, Y+3	; 0x03
     6ca:	90 93 2f 02 	sts	0x022F, r25
     6ce:	80 93 2e 02 	sts	0x022E, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
     6d2:	80 91 7c 02 	lds	r24, 0x027C
     6d6:	81 30       	cpi	r24, 0x01	; 1
     6d8:	b1 f4       	brne	.+44     	; 0x706 <xTaskGenericCreate+0x11e>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
     6da:	0e 94 1b 0a 	call	0x1436	; 0x1436 <prvInitialiseTaskLists>
     6de:	13 c0       	rjmp	.+38     	; 0x706 <xTaskGenericCreate+0x11e>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
     6e0:	80 91 81 02 	lds	r24, 0x0281
     6e4:	88 23       	and	r24, r24
     6e6:	79 f4       	brne	.+30     	; 0x706 <xTaskGenericCreate+0x11e>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
     6e8:	80 91 2e 02 	lds	r24, 0x022E
     6ec:	90 91 2f 02 	lds	r25, 0x022F
     6f0:	fc 01       	movw	r30, r24
     6f2:	96 89       	ldd	r25, Z+22	; 0x16
     6f4:	8e 85       	ldd	r24, Y+14	; 0x0e
     6f6:	89 17       	cp	r24, r25
     6f8:	30 f0       	brcs	.+12     	; 0x706 <xTaskGenericCreate+0x11e>
					{
						pxCurrentTCB = pxNewTCB;
     6fa:	8a 81       	ldd	r24, Y+2	; 0x02
     6fc:	9b 81       	ldd	r25, Y+3	; 0x03
     6fe:	90 93 2f 02 	sts	0x022F, r25
     702:	80 93 2e 02 	sts	0x022E, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
     706:	8a 81       	ldd	r24, Y+2	; 0x02
     708:	9b 81       	ldd	r25, Y+3	; 0x03
     70a:	fc 01       	movw	r30, r24
     70c:	96 89       	ldd	r25, Z+22	; 0x16
     70e:	80 91 7f 02 	lds	r24, 0x027F
     712:	89 17       	cp	r24, r25
     714:	30 f4       	brcc	.+12     	; 0x722 <xTaskGenericCreate+0x13a>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
     716:	8a 81       	ldd	r24, Y+2	; 0x02
     718:	9b 81       	ldd	r25, Y+3	; 0x03
     71a:	fc 01       	movw	r30, r24
     71c:	86 89       	ldd	r24, Z+22	; 0x16
     71e:	80 93 7f 02 	sts	0x027F, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
     722:	80 91 86 02 	lds	r24, 0x0286
     726:	8f 5f       	subi	r24, 0xFF	; 255
     728:	80 93 86 02 	sts	0x0286, r24

			prvAddTaskToReadyQueue( pxNewTCB );
     72c:	8a 81       	ldd	r24, Y+2	; 0x02
     72e:	9b 81       	ldd	r25, Y+3	; 0x03
     730:	fc 01       	movw	r30, r24
     732:	96 89       	ldd	r25, Z+22	; 0x16
     734:	80 91 80 02 	lds	r24, 0x0280
     738:	89 17       	cp	r24, r25
     73a:	30 f4       	brcc	.+12     	; 0x748 <xTaskGenericCreate+0x160>
     73c:	8a 81       	ldd	r24, Y+2	; 0x02
     73e:	9b 81       	ldd	r25, Y+3	; 0x03
     740:	fc 01       	movw	r30, r24
     742:	86 89       	ldd	r24, Z+22	; 0x16
     744:	80 93 80 02 	sts	0x0280, r24
     748:	8a 81       	ldd	r24, Y+2	; 0x02
     74a:	9b 81       	ldd	r25, Y+3	; 0x03
     74c:	ac 01       	movw	r20, r24
     74e:	4e 5f       	subi	r20, 0xFE	; 254
     750:	5f 4f       	sbci	r21, 0xFF	; 255
     752:	8a 81       	ldd	r24, Y+2	; 0x02
     754:	9b 81       	ldd	r25, Y+3	; 0x03
     756:	fc 01       	movw	r30, r24
     758:	86 89       	ldd	r24, Z+22	; 0x16
     75a:	28 2f       	mov	r18, r24
     75c:	30 e0       	ldi	r19, 0x00	; 0
     75e:	c9 01       	movw	r24, r18
     760:	88 0f       	add	r24, r24
     762:	99 1f       	adc	r25, r25
     764:	88 0f       	add	r24, r24
     766:	99 1f       	adc	r25, r25
     768:	88 0f       	add	r24, r24
     76a:	99 1f       	adc	r25, r25
     76c:	82 0f       	add	r24, r18
     76e:	93 1f       	adc	r25, r19
     770:	80 5d       	subi	r24, 0xD0	; 208
     772:	9d 4f       	sbci	r25, 0xFD	; 253
     774:	ba 01       	movw	r22, r20
     776:	0e 94 44 12 	call	0x2488	; 0x2488 <vListInsertEnd>

			xReturn = pdPASS;
     77a:	81 e0       	ldi	r24, 0x01	; 1
     77c:	89 83       	std	Y+1, r24	; 0x01
			portSETUP_TCB( pxNewTCB );
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
     77e:	0f 90       	pop	r0
     780:	0f be       	out	0x3f, r0	; 63
     782:	02 c0       	rjmp	.+4      	; 0x788 <xTaskGenericCreate+0x1a0>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     784:	8f ef       	ldi	r24, 0xFF	; 255
     786:	89 83       	std	Y+1, r24	; 0x01
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
     788:	89 81       	ldd	r24, Y+1	; 0x01
     78a:	81 30       	cpi	r24, 0x01	; 1
     78c:	79 f4       	brne	.+30     	; 0x7ac <xTaskGenericCreate+0x1c4>
	{
		if( xSchedulerRunning != pdFALSE )
     78e:	80 91 81 02 	lds	r24, 0x0281
     792:	88 23       	and	r24, r24
     794:	59 f0       	breq	.+22     	; 0x7ac <xTaskGenericCreate+0x1c4>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
     796:	80 91 2e 02 	lds	r24, 0x022E
     79a:	90 91 2f 02 	lds	r25, 0x022F
     79e:	fc 01       	movw	r30, r24
     7a0:	96 89       	ldd	r25, Z+22	; 0x16
     7a2:	8e 85       	ldd	r24, Y+14	; 0x0e
     7a4:	98 17       	cp	r25, r24
     7a6:	10 f4       	brcc	.+4      	; 0x7ac <xTaskGenericCreate+0x1c4>
			{
				portYIELD_WITHIN_API();
     7a8:	0e 94 d6 18 	call	0x31ac	; 0x31ac <vPortYield>
			}
		}
	}

	return xReturn;
     7ac:	89 81       	ldd	r24, Y+1	; 0x01
}
     7ae:	64 96       	adiw	r28, 0x14	; 20
     7b0:	0f b6       	in	r0, 0x3f	; 63
     7b2:	f8 94       	cli
     7b4:	de bf       	out	0x3e, r29	; 62
     7b6:	0f be       	out	0x3f, r0	; 63
     7b8:	cd bf       	out	0x3d, r28	; 61
     7ba:	df 91       	pop	r29
     7bc:	cf 91       	pop	r28
     7be:	1f 91       	pop	r17
     7c0:	0f 91       	pop	r16
     7c2:	ff 90       	pop	r15
     7c4:	ef 90       	pop	r14
     7c6:	df 90       	pop	r13
     7c8:	cf 90       	pop	r12
     7ca:	bf 90       	pop	r11
     7cc:	af 90       	pop	r10
     7ce:	08 95       	ret

000007d0 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
     7d0:	cf 93       	push	r28
     7d2:	df 93       	push	r29
     7d4:	cd b7       	in	r28, 0x3d	; 61
     7d6:	de b7       	in	r29, 0x3e	; 62
     7d8:	28 97       	sbiw	r28, 0x08	; 8
     7da:	0f b6       	in	r0, 0x3f	; 63
     7dc:	f8 94       	cli
     7de:	de bf       	out	0x3e, r29	; 62
     7e0:	0f be       	out	0x3f, r0	; 63
     7e2:	cd bf       	out	0x3d, r28	; 61
     7e4:	9e 83       	std	Y+6, r25	; 0x06
     7e6:	8d 83       	std	Y+5, r24	; 0x05
     7e8:	78 87       	std	Y+8, r23	; 0x08
     7ea:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
     7ec:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
     7ee:	0e 94 35 06 	call	0xc6a	; 0xc6a <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     7f2:	8d 81       	ldd	r24, Y+5	; 0x05
     7f4:	9e 81       	ldd	r25, Y+6	; 0x06
     7f6:	fc 01       	movw	r30, r24
     7f8:	20 81       	ld	r18, Z
     7fa:	31 81       	ldd	r19, Z+1	; 0x01
     7fc:	8f 81       	ldd	r24, Y+7	; 0x07
     7fe:	98 85       	ldd	r25, Y+8	; 0x08
     800:	82 0f       	add	r24, r18
     802:	93 1f       	adc	r25, r19
     804:	9b 83       	std	Y+3, r25	; 0x03
     806:	8a 83       	std	Y+2, r24	; 0x02

			if( xTickCount < *pxPreviousWakeTime )
     808:	8d 81       	ldd	r24, Y+5	; 0x05
     80a:	9e 81       	ldd	r25, Y+6	; 0x06
     80c:	fc 01       	movw	r30, r24
     80e:	20 81       	ld	r18, Z
     810:	31 81       	ldd	r19, Z+1	; 0x01
     812:	80 91 7d 02 	lds	r24, 0x027D
     816:	90 91 7e 02 	lds	r25, 0x027E
     81a:	82 17       	cp	r24, r18
     81c:	93 07       	cpc	r25, r19
     81e:	b0 f4       	brcc	.+44     	; 0x84c <vTaskDelayUntil+0x7c>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
     820:	8d 81       	ldd	r24, Y+5	; 0x05
     822:	9e 81       	ldd	r25, Y+6	; 0x06
     824:	fc 01       	movw	r30, r24
     826:	20 81       	ld	r18, Z
     828:	31 81       	ldd	r19, Z+1	; 0x01
     82a:	8a 81       	ldd	r24, Y+2	; 0x02
     82c:	9b 81       	ldd	r25, Y+3	; 0x03
     82e:	82 17       	cp	r24, r18
     830:	93 07       	cpc	r25, r19
     832:	08 f5       	brcc	.+66     	; 0x876 <vTaskDelayUntil+0xa6>
     834:	80 91 7d 02 	lds	r24, 0x027D
     838:	90 91 7e 02 	lds	r25, 0x027E
     83c:	2a 81       	ldd	r18, Y+2	; 0x02
     83e:	3b 81       	ldd	r19, Y+3	; 0x03
     840:	82 17       	cp	r24, r18
     842:	93 07       	cpc	r25, r19
     844:	c0 f4       	brcc	.+48     	; 0x876 <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
     846:	81 e0       	ldi	r24, 0x01	; 1
     848:	89 83       	std	Y+1, r24	; 0x01
     84a:	15 c0       	rjmp	.+42     	; 0x876 <vTaskDelayUntil+0xa6>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
     84c:	8d 81       	ldd	r24, Y+5	; 0x05
     84e:	9e 81       	ldd	r25, Y+6	; 0x06
     850:	fc 01       	movw	r30, r24
     852:	20 81       	ld	r18, Z
     854:	31 81       	ldd	r19, Z+1	; 0x01
     856:	8a 81       	ldd	r24, Y+2	; 0x02
     858:	9b 81       	ldd	r25, Y+3	; 0x03
     85a:	82 17       	cp	r24, r18
     85c:	93 07       	cpc	r25, r19
     85e:	48 f0       	brcs	.+18     	; 0x872 <vTaskDelayUntil+0xa2>
     860:	80 91 7d 02 	lds	r24, 0x027D
     864:	90 91 7e 02 	lds	r25, 0x027E
     868:	2a 81       	ldd	r18, Y+2	; 0x02
     86a:	3b 81       	ldd	r19, Y+3	; 0x03
     86c:	82 17       	cp	r24, r18
     86e:	93 07       	cpc	r25, r19
     870:	10 f4       	brcc	.+4      	; 0x876 <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
     872:	81 e0       	ldi	r24, 0x01	; 1
     874:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     876:	8d 81       	ldd	r24, Y+5	; 0x05
     878:	9e 81       	ldd	r25, Y+6	; 0x06
     87a:	2a 81       	ldd	r18, Y+2	; 0x02
     87c:	3b 81       	ldd	r19, Y+3	; 0x03
     87e:	fc 01       	movw	r30, r24
     880:	31 83       	std	Z+1, r19	; 0x01
     882:	20 83       	st	Z, r18

			if( xShouldDelay != pdFALSE )
     884:	89 81       	ldd	r24, Y+1	; 0x01
     886:	88 23       	and	r24, r24
     888:	59 f0       	breq	.+22     	; 0x8a0 <vTaskDelayUntil+0xd0>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
     88a:	80 91 2e 02 	lds	r24, 0x022E
     88e:	90 91 2f 02 	lds	r25, 0x022F
     892:	02 96       	adiw	r24, 0x02	; 2
     894:	0e 94 14 13 	call	0x2628	; 0x2628 <uxListRemove>
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
     898:	8a 81       	ldd	r24, Y+2	; 0x02
     89a:	9b 81       	ldd	r25, Y+3	; 0x03
     89c:	0e 94 5f 0a 	call	0x14be	; 0x14be <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     8a0:	0e 94 41 06 	call	0xc82	; 0xc82 <xTaskResumeAll>
     8a4:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     8a6:	8c 81       	ldd	r24, Y+4	; 0x04
     8a8:	88 23       	and	r24, r24
     8aa:	11 f4       	brne	.+4      	; 0x8b0 <vTaskDelayUntil+0xe0>
		{
			portYIELD_WITHIN_API();
     8ac:	0e 94 d6 18 	call	0x31ac	; 0x31ac <vPortYield>
		}
	}
     8b0:	28 96       	adiw	r28, 0x08	; 8
     8b2:	0f b6       	in	r0, 0x3f	; 63
     8b4:	f8 94       	cli
     8b6:	de bf       	out	0x3e, r29	; 62
     8b8:	0f be       	out	0x3f, r0	; 63
     8ba:	cd bf       	out	0x3d, r28	; 61
     8bc:	df 91       	pop	r29
     8be:	cf 91       	pop	r28
     8c0:	08 95       	ret

000008c2 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
     8c2:	cf 93       	push	r28
     8c4:	df 93       	push	r29
     8c6:	00 d0       	rcall	.+0      	; 0x8c8 <vTaskDelay+0x6>
     8c8:	1f 92       	push	r1
     8ca:	1f 92       	push	r1
     8cc:	cd b7       	in	r28, 0x3d	; 61
     8ce:	de b7       	in	r29, 0x3e	; 62
     8d0:	9d 83       	std	Y+5, r25	; 0x05
     8d2:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
     8d4:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
     8d6:	8c 81       	ldd	r24, Y+4	; 0x04
     8d8:	9d 81       	ldd	r25, Y+5	; 0x05
     8da:	00 97       	sbiw	r24, 0x00	; 0
     8dc:	d1 f0       	breq	.+52     	; 0x912 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
     8de:	0e 94 35 06 	call	0xc6a	; 0xc6a <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
     8e2:	20 91 7d 02 	lds	r18, 0x027D
     8e6:	30 91 7e 02 	lds	r19, 0x027E
     8ea:	8c 81       	ldd	r24, Y+4	; 0x04
     8ec:	9d 81       	ldd	r25, Y+5	; 0x05
     8ee:	82 0f       	add	r24, r18
     8f0:	93 1f       	adc	r25, r19
     8f2:	9b 83       	std	Y+3, r25	; 0x03
     8f4:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
     8f6:	80 91 2e 02 	lds	r24, 0x022E
     8fa:	90 91 2f 02 	lds	r25, 0x022F
     8fe:	02 96       	adiw	r24, 0x02	; 2
     900:	0e 94 14 13 	call	0x2628	; 0x2628 <uxListRemove>
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
     904:	8a 81       	ldd	r24, Y+2	; 0x02
     906:	9b 81       	ldd	r25, Y+3	; 0x03
     908:	0e 94 5f 0a 	call	0x14be	; 0x14be <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     90c:	0e 94 41 06 	call	0xc82	; 0xc82 <xTaskResumeAll>
     910:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     912:	89 81       	ldd	r24, Y+1	; 0x01
     914:	88 23       	and	r24, r24
     916:	11 f4       	brne	.+4      	; 0x91c <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
     918:	0e 94 d6 18 	call	0x31ac	; 0x31ac <vPortYield>
		}
	}
     91c:	0f 90       	pop	r0
     91e:	0f 90       	pop	r0
     920:	0f 90       	pop	r0
     922:	0f 90       	pop	r0
     924:	0f 90       	pop	r0
     926:	df 91       	pop	r29
     928:	cf 91       	pop	r28
     92a:	08 95       	ret

0000092c <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
     92c:	cf 93       	push	r28
     92e:	df 93       	push	r29
     930:	00 d0       	rcall	.+0      	; 0x932 <vTaskSuspend+0x6>
     932:	1f 92       	push	r1
     934:	cd b7       	in	r28, 0x3d	; 61
     936:	de b7       	in	r29, 0x3e	; 62
     938:	9c 83       	std	Y+4, r25	; 0x04
     93a:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
     93c:	0f b6       	in	r0, 0x3f	; 63
     93e:	f8 94       	cli
     940:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
     942:	80 91 2e 02 	lds	r24, 0x022E
     946:	90 91 2f 02 	lds	r25, 0x022F
     94a:	2b 81       	ldd	r18, Y+3	; 0x03
     94c:	3c 81       	ldd	r19, Y+4	; 0x04
     94e:	28 17       	cp	r18, r24
     950:	39 07       	cpc	r19, r25
     952:	11 f4       	brne	.+4      	; 0x958 <vTaskSuspend+0x2c>
			{
				pxTaskToSuspend = NULL;
     954:	1c 82       	std	Y+4, r1	; 0x04
     956:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
     958:	8b 81       	ldd	r24, Y+3	; 0x03
     95a:	9c 81       	ldd	r25, Y+4	; 0x04
     95c:	00 97       	sbiw	r24, 0x00	; 0
     95e:	29 f4       	brne	.+10     	; 0x96a <vTaskSuspend+0x3e>
     960:	80 91 2e 02 	lds	r24, 0x022E
     964:	90 91 2f 02 	lds	r25, 0x022F
     968:	02 c0       	rjmp	.+4      	; 0x96e <vTaskSuspend+0x42>
     96a:	8b 81       	ldd	r24, Y+3	; 0x03
     96c:	9c 81       	ldd	r25, Y+4	; 0x04
     96e:	9a 83       	std	Y+2, r25	; 0x02
     970:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
     972:	89 81       	ldd	r24, Y+1	; 0x01
     974:	9a 81       	ldd	r25, Y+2	; 0x02
     976:	02 96       	adiw	r24, 0x02	; 2
     978:	0e 94 14 13 	call	0x2628	; 0x2628 <uxListRemove>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
			}

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
     97c:	89 81       	ldd	r24, Y+1	; 0x01
     97e:	9a 81       	ldd	r25, Y+2	; 0x02
     980:	fc 01       	movw	r30, r24
     982:	84 89       	ldd	r24, Z+20	; 0x14
     984:	95 89       	ldd	r25, Z+21	; 0x15
     986:	00 97       	sbiw	r24, 0x00	; 0
     988:	29 f0       	breq	.+10     	; 0x994 <vTaskSuspend+0x68>
			{
				uxListRemove( &( pxTCB->xEventListItem ) );
     98a:	89 81       	ldd	r24, Y+1	; 0x01
     98c:	9a 81       	ldd	r25, Y+2	; 0x02
     98e:	0c 96       	adiw	r24, 0x0c	; 12
     990:	0e 94 14 13 	call	0x2628	; 0x2628 <uxListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
     994:	89 81       	ldd	r24, Y+1	; 0x01
     996:	9a 81       	ldd	r25, Y+2	; 0x02
     998:	02 96       	adiw	r24, 0x02	; 2
     99a:	bc 01       	movw	r22, r24
     99c:	83 e7       	ldi	r24, 0x73	; 115
     99e:	92 e0       	ldi	r25, 0x02	; 2
     9a0:	0e 94 44 12 	call	0x2488	; 0x2488 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
     9a4:	0f 90       	pop	r0
     9a6:	0f be       	out	0x3f, r0	; 63

		if( ( void * ) pxTaskToSuspend == NULL )
     9a8:	8b 81       	ldd	r24, Y+3	; 0x03
     9aa:	9c 81       	ldd	r25, Y+4	; 0x04
     9ac:	00 97       	sbiw	r24, 0x00	; 0
     9ae:	a1 f4       	brne	.+40     	; 0x9d8 <vTaskSuspend+0xac>
		{
			if( xSchedulerRunning != pdFALSE )
     9b0:	80 91 81 02 	lds	r24, 0x0281
     9b4:	88 23       	and	r24, r24
     9b6:	19 f0       	breq	.+6      	; 0x9be <vTaskSuspend+0x92>
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
     9b8:	0e 94 d6 18 	call	0x31ac	; 0x31ac <vPortYield>
     9bc:	0d c0       	rjmp	.+26     	; 0x9d8 <vTaskSuspend+0xac>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
     9be:	90 91 73 02 	lds	r25, 0x0273
     9c2:	80 91 7c 02 	lds	r24, 0x027C
     9c6:	98 17       	cp	r25, r24
     9c8:	29 f4       	brne	.+10     	; 0x9d4 <vTaskSuspend+0xa8>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
     9ca:	10 92 2f 02 	sts	0x022F, r1
     9ce:	10 92 2e 02 	sts	0x022E, r1
     9d2:	02 c0       	rjmp	.+4      	; 0x9d8 <vTaskSuspend+0xac>
				}
				else
				{
					vTaskSwitchContext();
     9d4:	0e 94 d7 07 	call	0xfae	; 0xfae <vTaskSwitchContext>
				}
			}
		}
	}
     9d8:	0f 90       	pop	r0
     9da:	0f 90       	pop	r0
     9dc:	0f 90       	pop	r0
     9de:	0f 90       	pop	r0
     9e0:	df 91       	pop	r29
     9e2:	cf 91       	pop	r28
     9e4:	08 95       	ret

000009e6 <xTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
     9e6:	cf 93       	push	r28
     9e8:	df 93       	push	r29
     9ea:	00 d0       	rcall	.+0      	; 0x9ec <xTaskIsTaskSuspended+0x6>
     9ec:	1f 92       	push	r1
     9ee:	1f 92       	push	r1
     9f0:	cd b7       	in	r28, 0x3d	; 61
     9f2:	de b7       	in	r29, 0x3e	; 62
     9f4:	9d 83       	std	Y+5, r25	; 0x05
     9f6:	8c 83       	std	Y+4, r24	; 0x04
	portBASE_TYPE xReturn = pdFALSE;
     9f8:	19 82       	std	Y+1, r1	; 0x01
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
     9fa:	8c 81       	ldd	r24, Y+4	; 0x04
     9fc:	9d 81       	ldd	r25, Y+5	; 0x05
     9fe:	9b 83       	std	Y+3, r25	; 0x03
     a00:	8a 83       	std	Y+2, r24	; 0x02
		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
     a02:	8a 81       	ldd	r24, Y+2	; 0x02
     a04:	9b 81       	ldd	r25, Y+3	; 0x03
     a06:	fc 01       	movw	r30, r24
     a08:	82 85       	ldd	r24, Z+10	; 0x0a
     a0a:	93 85       	ldd	r25, Z+11	; 0x0b
     a0c:	f2 e0       	ldi	r31, 0x02	; 2
     a0e:	83 37       	cpi	r24, 0x73	; 115
     a10:	9f 07       	cpc	r25, r31
     a12:	91 f4       	brne	.+36     	; 0xa38 <xTaskIsTaskSuspended+0x52>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
     a14:	8a 81       	ldd	r24, Y+2	; 0x02
     a16:	9b 81       	ldd	r25, Y+3	; 0x03
     a18:	fc 01       	movw	r30, r24
     a1a:	84 89       	ldd	r24, Z+20	; 0x14
     a1c:	95 89       	ldd	r25, Z+21	; 0x15
     a1e:	f2 e0       	ldi	r31, 0x02	; 2
     a20:	8a 36       	cpi	r24, 0x6A	; 106
     a22:	9f 07       	cpc	r25, r31
     a24:	49 f0       	breq	.+18     	; 0xa38 <xTaskIsTaskSuspended+0x52>
			{
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
     a26:	8a 81       	ldd	r24, Y+2	; 0x02
     a28:	9b 81       	ldd	r25, Y+3	; 0x03
     a2a:	fc 01       	movw	r30, r24
     a2c:	84 89       	ldd	r24, Z+20	; 0x14
     a2e:	95 89       	ldd	r25, Z+21	; 0x15
     a30:	00 97       	sbiw	r24, 0x00	; 0
     a32:	11 f4       	brne	.+4      	; 0xa38 <xTaskIsTaskSuspended+0x52>
				{
					xReturn = pdTRUE;
     a34:	81 e0       	ldi	r24, 0x01	; 1
     a36:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}

		return xReturn;
     a38:	89 81       	ldd	r24, Y+1	; 0x01
	}
     a3a:	0f 90       	pop	r0
     a3c:	0f 90       	pop	r0
     a3e:	0f 90       	pop	r0
     a40:	0f 90       	pop	r0
     a42:	0f 90       	pop	r0
     a44:	df 91       	pop	r29
     a46:	cf 91       	pop	r28
     a48:	08 95       	ret

00000a4a <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
     a4a:	cf 93       	push	r28
     a4c:	df 93       	push	r29
     a4e:	00 d0       	rcall	.+0      	; 0xa50 <vTaskResume+0x6>
     a50:	1f 92       	push	r1
     a52:	cd b7       	in	r28, 0x3d	; 61
     a54:	de b7       	in	r29, 0x3e	; 62
     a56:	9c 83       	std	Y+4, r25	; 0x04
     a58:	8b 83       	std	Y+3, r24	; 0x03
		/* It does not make sense to resume the calling task. */
		configASSERT( pxTaskToResume );

		/* Remove the task from whichever list it is currently in, and place
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;
     a5a:	8b 81       	ldd	r24, Y+3	; 0x03
     a5c:	9c 81       	ldd	r25, Y+4	; 0x04
     a5e:	9a 83       	std	Y+2, r25	; 0x02
     a60:	89 83       	std	Y+1, r24	; 0x01

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
     a62:	89 81       	ldd	r24, Y+1	; 0x01
     a64:	9a 81       	ldd	r25, Y+2	; 0x02
     a66:	00 97       	sbiw	r24, 0x00	; 0
     a68:	09 f4       	brne	.+2      	; 0xa6c <vTaskResume+0x22>
     a6a:	4f c0       	rjmp	.+158    	; 0xb0a <vTaskResume+0xc0>
     a6c:	80 91 2e 02 	lds	r24, 0x022E
     a70:	90 91 2f 02 	lds	r25, 0x022F
     a74:	29 81       	ldd	r18, Y+1	; 0x01
     a76:	3a 81       	ldd	r19, Y+2	; 0x02
     a78:	28 17       	cp	r18, r24
     a7a:	39 07       	cpc	r19, r25
     a7c:	09 f4       	brne	.+2      	; 0xa80 <vTaskResume+0x36>
     a7e:	45 c0       	rjmp	.+138    	; 0xb0a <vTaskResume+0xc0>
		{
			taskENTER_CRITICAL();
     a80:	0f b6       	in	r0, 0x3f	; 63
     a82:	f8 94       	cli
     a84:	0f 92       	push	r0
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
     a86:	89 81       	ldd	r24, Y+1	; 0x01
     a88:	9a 81       	ldd	r25, Y+2	; 0x02
     a8a:	0e 94 f3 04 	call	0x9e6	; 0x9e6 <xTaskIsTaskSuspended>
     a8e:	81 30       	cpi	r24, 0x01	; 1
     a90:	d1 f5       	brne	.+116    	; 0xb06 <vTaskResume+0xbc>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					uxListRemove(  &( pxTCB->xGenericListItem ) );
     a92:	89 81       	ldd	r24, Y+1	; 0x01
     a94:	9a 81       	ldd	r25, Y+2	; 0x02
     a96:	02 96       	adiw	r24, 0x02	; 2
     a98:	0e 94 14 13 	call	0x2628	; 0x2628 <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
     a9c:	89 81       	ldd	r24, Y+1	; 0x01
     a9e:	9a 81       	ldd	r25, Y+2	; 0x02
     aa0:	fc 01       	movw	r30, r24
     aa2:	96 89       	ldd	r25, Z+22	; 0x16
     aa4:	80 91 80 02 	lds	r24, 0x0280
     aa8:	89 17       	cp	r24, r25
     aaa:	30 f4       	brcc	.+12     	; 0xab8 <vTaskResume+0x6e>
     aac:	89 81       	ldd	r24, Y+1	; 0x01
     aae:	9a 81       	ldd	r25, Y+2	; 0x02
     ab0:	fc 01       	movw	r30, r24
     ab2:	86 89       	ldd	r24, Z+22	; 0x16
     ab4:	80 93 80 02 	sts	0x0280, r24
     ab8:	89 81       	ldd	r24, Y+1	; 0x01
     aba:	9a 81       	ldd	r25, Y+2	; 0x02
     abc:	ac 01       	movw	r20, r24
     abe:	4e 5f       	subi	r20, 0xFE	; 254
     ac0:	5f 4f       	sbci	r21, 0xFF	; 255
     ac2:	89 81       	ldd	r24, Y+1	; 0x01
     ac4:	9a 81       	ldd	r25, Y+2	; 0x02
     ac6:	fc 01       	movw	r30, r24
     ac8:	86 89       	ldd	r24, Z+22	; 0x16
     aca:	28 2f       	mov	r18, r24
     acc:	30 e0       	ldi	r19, 0x00	; 0
     ace:	c9 01       	movw	r24, r18
     ad0:	88 0f       	add	r24, r24
     ad2:	99 1f       	adc	r25, r25
     ad4:	88 0f       	add	r24, r24
     ad6:	99 1f       	adc	r25, r25
     ad8:	88 0f       	add	r24, r24
     ada:	99 1f       	adc	r25, r25
     adc:	82 0f       	add	r24, r18
     ade:	93 1f       	adc	r25, r19
     ae0:	80 5d       	subi	r24, 0xD0	; 208
     ae2:	9d 4f       	sbci	r25, 0xFD	; 253
     ae4:	ba 01       	movw	r22, r20
     ae6:	0e 94 44 12 	call	0x2488	; 0x2488 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     aea:	89 81       	ldd	r24, Y+1	; 0x01
     aec:	9a 81       	ldd	r25, Y+2	; 0x02
     aee:	fc 01       	movw	r30, r24
     af0:	26 89       	ldd	r18, Z+22	; 0x16
     af2:	80 91 2e 02 	lds	r24, 0x022E
     af6:	90 91 2f 02 	lds	r25, 0x022F
     afa:	fc 01       	movw	r30, r24
     afc:	86 89       	ldd	r24, Z+22	; 0x16
     afe:	28 17       	cp	r18, r24
     b00:	10 f0       	brcs	.+4      	; 0xb06 <vTaskResume+0xbc>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
     b02:	0e 94 d6 18 	call	0x31ac	; 0x31ac <vPortYield>
					}
				}
			}
			taskEXIT_CRITICAL();
     b06:	0f 90       	pop	r0
     b08:	0f be       	out	0x3f, r0	; 63
		}
	}
     b0a:	0f 90       	pop	r0
     b0c:	0f 90       	pop	r0
     b0e:	0f 90       	pop	r0
     b10:	0f 90       	pop	r0
     b12:	df 91       	pop	r29
     b14:	cf 91       	pop	r28
     b16:	08 95       	ret

00000b18 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
     b18:	cf 93       	push	r28
     b1a:	df 93       	push	r29
     b1c:	00 d0       	rcall	.+0      	; 0xb1e <xTaskResumeFromISR+0x6>
     b1e:	00 d0       	rcall	.+0      	; 0xb20 <xTaskResumeFromISR+0x8>
     b20:	cd b7       	in	r28, 0x3d	; 61
     b22:	de b7       	in	r29, 0x3e	; 62
     b24:	9e 83       	std	Y+6, r25	; 0x06
     b26:	8d 83       	std	Y+5, r24	; 0x05
	portBASE_TYPE xYieldRequired = pdFALSE;
     b28:	19 82       	std	Y+1, r1	; 0x01
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxSavedInterruptStatus;

		configASSERT( pxTaskToResume );

		pxTCB = ( tskTCB * ) pxTaskToResume;
     b2a:	8d 81       	ldd	r24, Y+5	; 0x05
     b2c:	9e 81       	ldd	r25, Y+6	; 0x06
     b2e:	9b 83       	std	Y+3, r25	; 0x03
     b30:	8a 83       	std	Y+2, r24	; 0x02

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     b32:	1c 82       	std	Y+4, r1	; 0x04
		{
			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
     b34:	8a 81       	ldd	r24, Y+2	; 0x02
     b36:	9b 81       	ldd	r25, Y+3	; 0x03
     b38:	0e 94 f3 04 	call	0x9e6	; 0x9e6 <xTaskIsTaskSuspended>
     b3c:	81 30       	cpi	r24, 0x01	; 1
     b3e:	09 f0       	breq	.+2      	; 0xb42 <xTaskResumeFromISR+0x2a>
     b40:	48 c0       	rjmp	.+144    	; 0xbd2 <xTaskResumeFromISR+0xba>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     b42:	80 91 82 02 	lds	r24, 0x0282
     b46:	88 23       	and	r24, r24
     b48:	e1 f5       	brne	.+120    	; 0xbc2 <xTaskResumeFromISR+0xaa>
				{
					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
     b4a:	8a 81       	ldd	r24, Y+2	; 0x02
     b4c:	9b 81       	ldd	r25, Y+3	; 0x03
     b4e:	fc 01       	movw	r30, r24
     b50:	26 89       	ldd	r18, Z+22	; 0x16
     b52:	80 91 2e 02 	lds	r24, 0x022E
     b56:	90 91 2f 02 	lds	r25, 0x022F
     b5a:	fc 01       	movw	r30, r24
     b5c:	96 89       	ldd	r25, Z+22	; 0x16
     b5e:	81 e0       	ldi	r24, 0x01	; 1
     b60:	29 17       	cp	r18, r25
     b62:	08 f4       	brcc	.+2      	; 0xb66 <xTaskResumeFromISR+0x4e>
     b64:	80 e0       	ldi	r24, 0x00	; 0
     b66:	89 83       	std	Y+1, r24	; 0x01
					uxListRemove(  &( pxTCB->xGenericListItem ) );
     b68:	8a 81       	ldd	r24, Y+2	; 0x02
     b6a:	9b 81       	ldd	r25, Y+3	; 0x03
     b6c:	02 96       	adiw	r24, 0x02	; 2
     b6e:	0e 94 14 13 	call	0x2628	; 0x2628 <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
     b72:	8a 81       	ldd	r24, Y+2	; 0x02
     b74:	9b 81       	ldd	r25, Y+3	; 0x03
     b76:	fc 01       	movw	r30, r24
     b78:	96 89       	ldd	r25, Z+22	; 0x16
     b7a:	80 91 80 02 	lds	r24, 0x0280
     b7e:	89 17       	cp	r24, r25
     b80:	30 f4       	brcc	.+12     	; 0xb8e <xTaskResumeFromISR+0x76>
     b82:	8a 81       	ldd	r24, Y+2	; 0x02
     b84:	9b 81       	ldd	r25, Y+3	; 0x03
     b86:	fc 01       	movw	r30, r24
     b88:	86 89       	ldd	r24, Z+22	; 0x16
     b8a:	80 93 80 02 	sts	0x0280, r24
     b8e:	8a 81       	ldd	r24, Y+2	; 0x02
     b90:	9b 81       	ldd	r25, Y+3	; 0x03
     b92:	ac 01       	movw	r20, r24
     b94:	4e 5f       	subi	r20, 0xFE	; 254
     b96:	5f 4f       	sbci	r21, 0xFF	; 255
     b98:	8a 81       	ldd	r24, Y+2	; 0x02
     b9a:	9b 81       	ldd	r25, Y+3	; 0x03
     b9c:	fc 01       	movw	r30, r24
     b9e:	86 89       	ldd	r24, Z+22	; 0x16
     ba0:	28 2f       	mov	r18, r24
     ba2:	30 e0       	ldi	r19, 0x00	; 0
     ba4:	c9 01       	movw	r24, r18
     ba6:	88 0f       	add	r24, r24
     ba8:	99 1f       	adc	r25, r25
     baa:	88 0f       	add	r24, r24
     bac:	99 1f       	adc	r25, r25
     bae:	88 0f       	add	r24, r24
     bb0:	99 1f       	adc	r25, r25
     bb2:	82 0f       	add	r24, r18
     bb4:	93 1f       	adc	r25, r19
     bb6:	80 5d       	subi	r24, 0xD0	; 208
     bb8:	9d 4f       	sbci	r25, 0xFD	; 253
     bba:	ba 01       	movw	r22, r20
     bbc:	0e 94 44 12 	call	0x2488	; 0x2488 <vListInsertEnd>
     bc0:	08 c0       	rjmp	.+16     	; 0xbd2 <xTaskResumeFromISR+0xba>
				else
				{
					/* We cannot access the delayed or ready lists, so will hold this
					task pending until the scheduler is resumed, at which point a
					yield will be performed if necessary. */
					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
     bc2:	8a 81       	ldd	r24, Y+2	; 0x02
     bc4:	9b 81       	ldd	r25, Y+3	; 0x03
     bc6:	0c 96       	adiw	r24, 0x0c	; 12
     bc8:	bc 01       	movw	r22, r24
     bca:	8a e6       	ldi	r24, 0x6A	; 106
     bcc:	92 e0       	ldi	r25, 0x02	; 2
     bce:	0e 94 44 12 	call	0x2488	; 0x2488 <vListInsertEnd>
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
     bd2:	89 81       	ldd	r24, Y+1	; 0x01
	}
     bd4:	26 96       	adiw	r28, 0x06	; 6
     bd6:	0f b6       	in	r0, 0x3f	; 63
     bd8:	f8 94       	cli
     bda:	de bf       	out	0x3e, r29	; 62
     bdc:	0f be       	out	0x3f, r0	; 63
     bde:	cd bf       	out	0x3d, r28	; 61
     be0:	df 91       	pop	r29
     be2:	cf 91       	pop	r28
     be4:	08 95       	ret

00000be6 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
     be6:	af 92       	push	r10
     be8:	bf 92       	push	r11
     bea:	cf 92       	push	r12
     bec:	df 92       	push	r13
     bee:	ef 92       	push	r14
     bf0:	ff 92       	push	r15
     bf2:	0f 93       	push	r16
     bf4:	cf 93       	push	r28
     bf6:	df 93       	push	r29
     bf8:	1f 92       	push	r1
     bfa:	cd b7       	in	r28, 0x3d	; 61
     bfc:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
     bfe:	a1 2c       	mov	r10, r1
     c00:	b1 2c       	mov	r11, r1
     c02:	c1 2c       	mov	r12, r1
     c04:	d1 2c       	mov	r13, r1
     c06:	e1 2c       	mov	r14, r1
     c08:	f1 2c       	mov	r15, r1
     c0a:	00 e0       	ldi	r16, 0x00	; 0
     c0c:	20 e0       	ldi	r18, 0x00	; 0
     c0e:	30 e0       	ldi	r19, 0x00	; 0
     c10:	45 e5       	ldi	r20, 0x55	; 85
     c12:	50 e0       	ldi	r21, 0x00	; 0
     c14:	6e e1       	ldi	r22, 0x1E	; 30
     c16:	72 e0       	ldi	r23, 0x02	; 2
     c18:	88 ea       	ldi	r24, 0xA8	; 168
     c1a:	99 e0       	ldi	r25, 0x09	; 9
     c1c:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <xTaskGenericCreate>
     c20:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
     c22:	89 81       	ldd	r24, Y+1	; 0x01
     c24:	81 30       	cpi	r24, 0x01	; 1
     c26:	51 f4       	brne	.+20     	; 0xc3c <vTaskStartScheduler+0x56>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
     c28:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
     c2a:	81 e0       	ldi	r24, 0x01	; 1
     c2c:	80 93 81 02 	sts	0x0281, r24
		xTickCount = ( portTickType ) 0U;
     c30:	10 92 7e 02 	sts	0x027E, r1
     c34:	10 92 7d 02 	sts	0x027D, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     c38:	0e 94 96 18 	call	0x312c	; 0x312c <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
     c3c:	0f 90       	pop	r0
     c3e:	df 91       	pop	r29
     c40:	cf 91       	pop	r28
     c42:	0f 91       	pop	r16
     c44:	ff 90       	pop	r15
     c46:	ef 90       	pop	r14
     c48:	df 90       	pop	r13
     c4a:	cf 90       	pop	r12
     c4c:	bf 90       	pop	r11
     c4e:	af 90       	pop	r10
     c50:	08 95       	ret

00000c52 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
     c52:	cf 93       	push	r28
     c54:	df 93       	push	r29
     c56:	cd b7       	in	r28, 0x3d	; 61
     c58:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
     c5a:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
     c5c:	10 92 81 02 	sts	0x0281, r1
	vPortEndScheduler();
     c60:	0e 94 cf 18 	call	0x319e	; 0x319e <vPortEndScheduler>
}
     c64:	df 91       	pop	r29
     c66:	cf 91       	pop	r28
     c68:	08 95       	ret

00000c6a <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
     c6a:	cf 93       	push	r28
     c6c:	df 93       	push	r29
     c6e:	cd b7       	in	r28, 0x3d	; 61
     c70:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
     c72:	80 91 82 02 	lds	r24, 0x0282
     c76:	8f 5f       	subi	r24, 0xFF	; 255
     c78:	80 93 82 02 	sts	0x0282, r24
}
     c7c:	df 91       	pop	r29
     c7e:	cf 91       	pop	r28
     c80:	08 95       	ret

00000c82 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE != 0  */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
     c82:	0f 93       	push	r16
     c84:	1f 93       	push	r17
     c86:	cf 93       	push	r28
     c88:	df 93       	push	r29
     c8a:	1f 92       	push	r1
     c8c:	1f 92       	push	r1
     c8e:	cd b7       	in	r28, 0x3d	; 61
     c90:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
     c92:	19 82       	std	Y+1, r1	; 0x01
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     c94:	0f b6       	in	r0, 0x3f	; 63
     c96:	f8 94       	cli
     c98:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     c9a:	80 91 82 02 	lds	r24, 0x0282
     c9e:	81 50       	subi	r24, 0x01	; 1
     ca0:	80 93 82 02 	sts	0x0282, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     ca4:	80 91 82 02 	lds	r24, 0x0282
     ca8:	88 23       	and	r24, r24
     caa:	09 f0       	breq	.+2      	; 0xcae <xTaskResumeAll+0x2c>
     cac:	64 c0       	rjmp	.+200    	; 0xd76 <xTaskResumeAll+0xf4>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
     cae:	80 91 7c 02 	lds	r24, 0x027C
     cb2:	88 23       	and	r24, r24
     cb4:	09 f4       	brne	.+2      	; 0xcb8 <xTaskResumeAll+0x36>
     cb6:	5f c0       	rjmp	.+190    	; 0xd76 <xTaskResumeAll+0xf4>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
     cb8:	1a 82       	std	Y+2, r1	; 0x02

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
     cba:	3a c0       	rjmp	.+116    	; 0xd30 <xTaskResumeAll+0xae>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
     cbc:	80 91 6f 02 	lds	r24, 0x026F
     cc0:	90 91 70 02 	lds	r25, 0x0270
     cc4:	fc 01       	movw	r30, r24
     cc6:	06 81       	ldd	r16, Z+6	; 0x06
     cc8:	17 81       	ldd	r17, Z+7	; 0x07
					uxListRemove( &( pxTCB->xEventListItem ) );
     cca:	c8 01       	movw	r24, r16
     ccc:	0c 96       	adiw	r24, 0x0c	; 12
     cce:	0e 94 14 13 	call	0x2628	; 0x2628 <uxListRemove>
					uxListRemove( &( pxTCB->xGenericListItem ) );
     cd2:	c8 01       	movw	r24, r16
     cd4:	02 96       	adiw	r24, 0x02	; 2
     cd6:	0e 94 14 13 	call	0x2628	; 0x2628 <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
     cda:	f8 01       	movw	r30, r16
     cdc:	96 89       	ldd	r25, Z+22	; 0x16
     cde:	80 91 80 02 	lds	r24, 0x0280
     ce2:	89 17       	cp	r24, r25
     ce4:	20 f4       	brcc	.+8      	; 0xcee <xTaskResumeAll+0x6c>
     ce6:	f8 01       	movw	r30, r16
     ce8:	86 89       	ldd	r24, Z+22	; 0x16
     cea:	80 93 80 02 	sts	0x0280, r24
     cee:	a8 01       	movw	r20, r16
     cf0:	4e 5f       	subi	r20, 0xFE	; 254
     cf2:	5f 4f       	sbci	r21, 0xFF	; 255
     cf4:	f8 01       	movw	r30, r16
     cf6:	86 89       	ldd	r24, Z+22	; 0x16
     cf8:	28 2f       	mov	r18, r24
     cfa:	30 e0       	ldi	r19, 0x00	; 0
     cfc:	c9 01       	movw	r24, r18
     cfe:	88 0f       	add	r24, r24
     d00:	99 1f       	adc	r25, r25
     d02:	88 0f       	add	r24, r24
     d04:	99 1f       	adc	r25, r25
     d06:	88 0f       	add	r24, r24
     d08:	99 1f       	adc	r25, r25
     d0a:	82 0f       	add	r24, r18
     d0c:	93 1f       	adc	r25, r19
     d0e:	80 5d       	subi	r24, 0xD0	; 208
     d10:	9d 4f       	sbci	r25, 0xFD	; 253
     d12:	ba 01       	movw	r22, r20
     d14:	0e 94 44 12 	call	0x2488	; 0x2488 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     d18:	f8 01       	movw	r30, r16
     d1a:	26 89       	ldd	r18, Z+22	; 0x16
     d1c:	80 91 2e 02 	lds	r24, 0x022E
     d20:	90 91 2f 02 	lds	r25, 0x022F
     d24:	fc 01       	movw	r30, r24
     d26:	86 89       	ldd	r24, Z+22	; 0x16
     d28:	28 17       	cp	r18, r24
     d2a:	10 f0       	brcs	.+4      	; 0xd30 <xTaskResumeAll+0xae>
					{
						xYieldRequired = pdTRUE;
     d2c:	81 e0       	ldi	r24, 0x01	; 1
     d2e:	8a 83       	std	Y+2, r24	; 0x02
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
     d30:	80 91 6a 02 	lds	r24, 0x026A
     d34:	88 23       	and	r24, r24
     d36:	11 f6       	brne	.-124    	; 0xcbc <xTaskResumeAll+0x3a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
     d38:	80 91 83 02 	lds	r24, 0x0283
     d3c:	88 23       	and	r24, r24
     d3e:	71 f0       	breq	.+28     	; 0xd5c <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
     d40:	07 c0       	rjmp	.+14     	; 0xd50 <xTaskResumeAll+0xce>
					{
						vTaskIncrementTick();
     d42:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <vTaskIncrementTick>
						--uxMissedTicks;
     d46:	80 91 83 02 	lds	r24, 0x0283
     d4a:	81 50       	subi	r24, 0x01	; 1
     d4c:	80 93 83 02 	sts	0x0283, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
     d50:	80 91 83 02 	lds	r24, 0x0283
     d54:	88 23       	and	r24, r24
     d56:	a9 f7       	brne	.-22     	; 0xd42 <xTaskResumeAll+0xc0>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
     d58:	81 e0       	ldi	r24, 0x01	; 1
     d5a:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
     d5c:	8a 81       	ldd	r24, Y+2	; 0x02
     d5e:	81 30       	cpi	r24, 0x01	; 1
     d60:	21 f0       	breq	.+8      	; 0xd6a <xTaskResumeAll+0xe8>
     d62:	80 91 84 02 	lds	r24, 0x0284
     d66:	81 30       	cpi	r24, 0x01	; 1
     d68:	31 f4       	brne	.+12     	; 0xd76 <xTaskResumeAll+0xf4>
				{
					xAlreadyYielded = pdTRUE;
     d6a:	81 e0       	ldi	r24, 0x01	; 1
     d6c:	89 83       	std	Y+1, r24	; 0x01
					xMissedYield = pdFALSE;
     d6e:	10 92 84 02 	sts	0x0284, r1
					portYIELD_WITHIN_API();
     d72:	0e 94 d6 18 	call	0x31ac	; 0x31ac <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
     d76:	0f 90       	pop	r0
     d78:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
     d7a:	89 81       	ldd	r24, Y+1	; 0x01
}
     d7c:	0f 90       	pop	r0
     d7e:	0f 90       	pop	r0
     d80:	df 91       	pop	r29
     d82:	cf 91       	pop	r28
     d84:	1f 91       	pop	r17
     d86:	0f 91       	pop	r16
     d88:	08 95       	ret

00000d8a <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
     d8a:	cf 93       	push	r28
     d8c:	df 93       	push	r29
     d8e:	1f 92       	push	r1
     d90:	1f 92       	push	r1
     d92:	cd b7       	in	r28, 0x3d	; 61
     d94:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
     d96:	0f b6       	in	r0, 0x3f	; 63
     d98:	f8 94       	cli
     d9a:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     d9c:	80 91 7d 02 	lds	r24, 0x027D
     da0:	90 91 7e 02 	lds	r25, 0x027E
     da4:	9a 83       	std	Y+2, r25	; 0x02
     da6:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
     da8:	0f 90       	pop	r0
     daa:	0f be       	out	0x3f, r0	; 63

	return xTicks;
     dac:	89 81       	ldd	r24, Y+1	; 0x01
     dae:	9a 81       	ldd	r25, Y+2	; 0x02
}
     db0:	0f 90       	pop	r0
     db2:	0f 90       	pop	r0
     db4:	df 91       	pop	r29
     db6:	cf 91       	pop	r28
     db8:	08 95       	ret

00000dba <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
     dba:	cf 93       	push	r28
     dbc:	df 93       	push	r29
     dbe:	00 d0       	rcall	.+0      	; 0xdc0 <xTaskGetTickCountFromISR+0x6>
     dc0:	cd b7       	in	r28, 0x3d	; 61
     dc2:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     dc4:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
     dc6:	80 91 7d 02 	lds	r24, 0x027D
     dca:	90 91 7e 02 	lds	r25, 0x027E
     dce:	9b 83       	std	Y+3, r25	; 0x03
     dd0:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
     dd2:	8a 81       	ldd	r24, Y+2	; 0x02
     dd4:	9b 81       	ldd	r25, Y+3	; 0x03
}
     dd6:	0f 90       	pop	r0
     dd8:	0f 90       	pop	r0
     dda:	0f 90       	pop	r0
     ddc:	df 91       	pop	r29
     dde:	cf 91       	pop	r28
     de0:	08 95       	ret

00000de2 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
     de2:	cf 93       	push	r28
     de4:	df 93       	push	r29
     de6:	cd b7       	in	r28, 0x3d	; 61
     de8:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
     dea:	80 91 7c 02 	lds	r24, 0x027C
}
     dee:	df 91       	pop	r29
     df0:	cf 91       	pop	r28
     df2:	08 95       	ret

00000df4 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
     df4:	cf 93       	push	r28
     df6:	df 93       	push	r29
     df8:	00 d0       	rcall	.+0      	; 0xdfa <vTaskIncrementTick+0x6>
     dfa:	00 d0       	rcall	.+0      	; 0xdfc <vTaskIncrementTick+0x8>
     dfc:	cd b7       	in	r28, 0x3d	; 61
     dfe:	de b7       	in	r29, 0x3e	; 62

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     e00:	80 91 82 02 	lds	r24, 0x0282
     e04:	88 23       	and	r24, r24
     e06:	09 f0       	breq	.+2      	; 0xe0a <vTaskIncrementTick+0x16>
     e08:	c4 c0       	rjmp	.+392    	; 0xf92 <vTaskIncrementTick+0x19e>
	{
		++xTickCount;
     e0a:	80 91 7d 02 	lds	r24, 0x027D
     e0e:	90 91 7e 02 	lds	r25, 0x027E
     e12:	01 96       	adiw	r24, 0x01	; 1
     e14:	90 93 7e 02 	sts	0x027E, r25
     e18:	80 93 7d 02 	sts	0x027D, r24
		if( xTickCount == ( portTickType ) 0U )
     e1c:	80 91 7d 02 	lds	r24, 0x027D
     e20:	90 91 7e 02 	lds	r25, 0x027E
     e24:	00 97       	sbiw	r24, 0x00	; 0
     e26:	e9 f5       	brne	.+122    	; 0xea2 <vTaskIncrementTick+0xae>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
     e28:	80 91 66 02 	lds	r24, 0x0266
     e2c:	90 91 67 02 	lds	r25, 0x0267
     e30:	9a 83       	std	Y+2, r25	; 0x02
     e32:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedTaskList = pxOverflowDelayedTaskList;
     e34:	80 91 68 02 	lds	r24, 0x0268
     e38:	90 91 69 02 	lds	r25, 0x0269
     e3c:	90 93 67 02 	sts	0x0267, r25
     e40:	80 93 66 02 	sts	0x0266, r24
			pxOverflowDelayedTaskList = pxTemp;
     e44:	89 81       	ldd	r24, Y+1	; 0x01
     e46:	9a 81       	ldd	r25, Y+2	; 0x02
     e48:	90 93 69 02 	sts	0x0269, r25
     e4c:	80 93 68 02 	sts	0x0268, r24
			xNumOfOverflows++;
     e50:	80 91 85 02 	lds	r24, 0x0285
     e54:	8f 5f       	subi	r24, 0xFF	; 255
     e56:	80 93 85 02 	sts	0x0285, r24

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     e5a:	80 91 66 02 	lds	r24, 0x0266
     e5e:	90 91 67 02 	lds	r25, 0x0267
     e62:	fc 01       	movw	r30, r24
     e64:	80 81       	ld	r24, Z
     e66:	88 23       	and	r24, r24
     e68:	39 f4       	brne	.+14     	; 0xe78 <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
     e6a:	8f ef       	ldi	r24, 0xFF	; 255
     e6c:	9f ef       	ldi	r25, 0xFF	; 255
     e6e:	90 93 01 02 	sts	0x0201, r25
     e72:	80 93 00 02 	sts	0x0200, r24
     e76:	15 c0       	rjmp	.+42     	; 0xea2 <vTaskIncrementTick+0xae>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     e78:	80 91 66 02 	lds	r24, 0x0266
     e7c:	90 91 67 02 	lds	r25, 0x0267
     e80:	fc 01       	movw	r30, r24
     e82:	85 81       	ldd	r24, Z+5	; 0x05
     e84:	96 81       	ldd	r25, Z+6	; 0x06
     e86:	fc 01       	movw	r30, r24
     e88:	86 81       	ldd	r24, Z+6	; 0x06
     e8a:	97 81       	ldd	r25, Z+7	; 0x07
     e8c:	9c 83       	std	Y+4, r25	; 0x04
     e8e:	8b 83       	std	Y+3, r24	; 0x03
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
     e90:	8b 81       	ldd	r24, Y+3	; 0x03
     e92:	9c 81       	ldd	r25, Y+4	; 0x04
     e94:	fc 01       	movw	r30, r24
     e96:	82 81       	ldd	r24, Z+2	; 0x02
     e98:	93 81       	ldd	r25, Z+3	; 0x03
     e9a:	90 93 01 02 	sts	0x0201, r25
     e9e:	80 93 00 02 	sts	0x0200, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
     ea2:	20 91 7d 02 	lds	r18, 0x027D
     ea6:	30 91 7e 02 	lds	r19, 0x027E
     eaa:	80 91 00 02 	lds	r24, 0x0200
     eae:	90 91 01 02 	lds	r25, 0x0201
     eb2:	28 17       	cp	r18, r24
     eb4:	39 07       	cpc	r19, r25
     eb6:	08 f4       	brcc	.+2      	; 0xeba <vTaskIncrementTick+0xc6>
     eb8:	6b c0       	rjmp	.+214    	; 0xf90 <vTaskIncrementTick+0x19c>
     eba:	80 91 66 02 	lds	r24, 0x0266
     ebe:	90 91 67 02 	lds	r25, 0x0267
     ec2:	fc 01       	movw	r30, r24
     ec4:	80 81       	ld	r24, Z
     ec6:	88 23       	and	r24, r24
     ec8:	39 f4       	brne	.+14     	; 0xed8 <vTaskIncrementTick+0xe4>
     eca:	8f ef       	ldi	r24, 0xFF	; 255
     ecc:	9f ef       	ldi	r25, 0xFF	; 255
     ece:	90 93 01 02 	sts	0x0201, r25
     ed2:	80 93 00 02 	sts	0x0200, r24
     ed6:	5c c0       	rjmp	.+184    	; 0xf90 <vTaskIncrementTick+0x19c>
     ed8:	80 91 66 02 	lds	r24, 0x0266
     edc:	90 91 67 02 	lds	r25, 0x0267
     ee0:	fc 01       	movw	r30, r24
     ee2:	85 81       	ldd	r24, Z+5	; 0x05
     ee4:	96 81       	ldd	r25, Z+6	; 0x06
     ee6:	fc 01       	movw	r30, r24
     ee8:	86 81       	ldd	r24, Z+6	; 0x06
     eea:	97 81       	ldd	r25, Z+7	; 0x07
     eec:	9c 83       	std	Y+4, r25	; 0x04
     eee:	8b 83       	std	Y+3, r24	; 0x03
     ef0:	8b 81       	ldd	r24, Y+3	; 0x03
     ef2:	9c 81       	ldd	r25, Y+4	; 0x04
     ef4:	fc 01       	movw	r30, r24
     ef6:	82 81       	ldd	r24, Z+2	; 0x02
     ef8:	93 81       	ldd	r25, Z+3	; 0x03
     efa:	9e 83       	std	Y+6, r25	; 0x06
     efc:	8d 83       	std	Y+5, r24	; 0x05
     efe:	20 91 7d 02 	lds	r18, 0x027D
     f02:	30 91 7e 02 	lds	r19, 0x027E
     f06:	8d 81       	ldd	r24, Y+5	; 0x05
     f08:	9e 81       	ldd	r25, Y+6	; 0x06
     f0a:	28 17       	cp	r18, r24
     f0c:	39 07       	cpc	r19, r25
     f0e:	38 f4       	brcc	.+14     	; 0xf1e <vTaskIncrementTick+0x12a>
     f10:	8d 81       	ldd	r24, Y+5	; 0x05
     f12:	9e 81       	ldd	r25, Y+6	; 0x06
     f14:	90 93 01 02 	sts	0x0201, r25
     f18:	80 93 00 02 	sts	0x0200, r24
     f1c:	39 c0       	rjmp	.+114    	; 0xf90 <vTaskIncrementTick+0x19c>
     f1e:	8b 81       	ldd	r24, Y+3	; 0x03
     f20:	9c 81       	ldd	r25, Y+4	; 0x04
     f22:	02 96       	adiw	r24, 0x02	; 2
     f24:	0e 94 14 13 	call	0x2628	; 0x2628 <uxListRemove>
     f28:	8b 81       	ldd	r24, Y+3	; 0x03
     f2a:	9c 81       	ldd	r25, Y+4	; 0x04
     f2c:	fc 01       	movw	r30, r24
     f2e:	84 89       	ldd	r24, Z+20	; 0x14
     f30:	95 89       	ldd	r25, Z+21	; 0x15
     f32:	00 97       	sbiw	r24, 0x00	; 0
     f34:	29 f0       	breq	.+10     	; 0xf40 <vTaskIncrementTick+0x14c>
     f36:	8b 81       	ldd	r24, Y+3	; 0x03
     f38:	9c 81       	ldd	r25, Y+4	; 0x04
     f3a:	0c 96       	adiw	r24, 0x0c	; 12
     f3c:	0e 94 14 13 	call	0x2628	; 0x2628 <uxListRemove>
     f40:	8b 81       	ldd	r24, Y+3	; 0x03
     f42:	9c 81       	ldd	r25, Y+4	; 0x04
     f44:	fc 01       	movw	r30, r24
     f46:	96 89       	ldd	r25, Z+22	; 0x16
     f48:	80 91 80 02 	lds	r24, 0x0280
     f4c:	89 17       	cp	r24, r25
     f4e:	30 f4       	brcc	.+12     	; 0xf5c <vTaskIncrementTick+0x168>
     f50:	8b 81       	ldd	r24, Y+3	; 0x03
     f52:	9c 81       	ldd	r25, Y+4	; 0x04
     f54:	fc 01       	movw	r30, r24
     f56:	86 89       	ldd	r24, Z+22	; 0x16
     f58:	80 93 80 02 	sts	0x0280, r24
     f5c:	8b 81       	ldd	r24, Y+3	; 0x03
     f5e:	9c 81       	ldd	r25, Y+4	; 0x04
     f60:	ac 01       	movw	r20, r24
     f62:	4e 5f       	subi	r20, 0xFE	; 254
     f64:	5f 4f       	sbci	r21, 0xFF	; 255
     f66:	8b 81       	ldd	r24, Y+3	; 0x03
     f68:	9c 81       	ldd	r25, Y+4	; 0x04
     f6a:	fc 01       	movw	r30, r24
     f6c:	86 89       	ldd	r24, Z+22	; 0x16
     f6e:	28 2f       	mov	r18, r24
     f70:	30 e0       	ldi	r19, 0x00	; 0
     f72:	c9 01       	movw	r24, r18
     f74:	88 0f       	add	r24, r24
     f76:	99 1f       	adc	r25, r25
     f78:	88 0f       	add	r24, r24
     f7a:	99 1f       	adc	r25, r25
     f7c:	88 0f       	add	r24, r24
     f7e:	99 1f       	adc	r25, r25
     f80:	82 0f       	add	r24, r18
     f82:	93 1f       	adc	r25, r19
     f84:	80 5d       	subi	r24, 0xD0	; 208
     f86:	9d 4f       	sbci	r25, 0xFD	; 253
     f88:	ba 01       	movw	r22, r20
     f8a:	0e 94 44 12 	call	0x2488	; 0x2488 <vListInsertEnd>
     f8e:	95 cf       	rjmp	.-214    	; 0xeba <vTaskIncrementTick+0xc6>
     f90:	05 c0       	rjmp	.+10     	; 0xf9c <vTaskIncrementTick+0x1a8>
	}
	else
	{
		++uxMissedTicks;
     f92:	80 91 83 02 	lds	r24, 0x0283
     f96:	8f 5f       	subi	r24, 0xFF	; 255
     f98:	80 93 83 02 	sts	0x0283, r24
		{
			vApplicationTickHook();
		}
	}
	#endif
}
     f9c:	26 96       	adiw	r28, 0x06	; 6
     f9e:	0f b6       	in	r0, 0x3f	; 63
     fa0:	f8 94       	cli
     fa2:	de bf       	out	0x3e, r29	; 62
     fa4:	0f be       	out	0x3f, r0	; 63
     fa6:	cd bf       	out	0x3d, r28	; 61
     fa8:	df 91       	pop	r29
     faa:	cf 91       	pop	r28
     fac:	08 95       	ret

00000fae <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
     fae:	cf 93       	push	r28
     fb0:	df 93       	push	r29
     fb2:	1f 92       	push	r1
     fb4:	1f 92       	push	r1
     fb6:	cd b7       	in	r28, 0x3d	; 61
     fb8:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
     fba:	80 91 82 02 	lds	r24, 0x0282
     fbe:	88 23       	and	r24, r24
     fc0:	21 f0       	breq	.+8      	; 0xfca <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
     fc2:	81 e0       	ldi	r24, 0x01	; 1
     fc4:	80 93 84 02 	sts	0x0284, r24
     fc8:	7a c0       	rjmp	.+244    	; 0x10be <vTaskSwitchContext+0x110>
				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
				ulTaskSwitchedInTime = ulTempCounter;
		}
		#endif

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
     fca:	80 91 2e 02 	lds	r24, 0x022E
     fce:	90 91 2f 02 	lds	r25, 0x022F
     fd2:	fc 01       	movw	r30, r24
     fd4:	20 81       	ld	r18, Z
     fd6:	31 81       	ldd	r19, Z+1	; 0x01
     fd8:	80 91 2e 02 	lds	r24, 0x022E
     fdc:	90 91 2f 02 	lds	r25, 0x022F
     fe0:	fc 01       	movw	r30, r24
     fe2:	87 89       	ldd	r24, Z+23	; 0x17
     fe4:	90 8d       	ldd	r25, Z+24	; 0x18
     fe6:	82 17       	cp	r24, r18
     fe8:	93 07       	cpc	r25, r19
     fea:	70 f0       	brcs	.+28     	; 0x1008 <vTaskSwitchContext+0x5a>
     fec:	80 91 2e 02 	lds	r24, 0x022E
     ff0:	90 91 2f 02 	lds	r25, 0x022F
     ff4:	9c 01       	movw	r18, r24
     ff6:	27 5e       	subi	r18, 0xE7	; 231
     ff8:	3f 4f       	sbci	r19, 0xFF	; 255
     ffa:	80 91 2e 02 	lds	r24, 0x022E
     ffe:	90 91 2f 02 	lds	r25, 0x022F
    1002:	b9 01       	movw	r22, r18
    1004:	0e 94 af 00 	call	0x15e	; 0x15e <vApplicationStackOverflowHook>
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
    1008:	05 c0       	rjmp	.+10     	; 0x1014 <vTaskSwitchContext+0x66>
    100a:	80 91 80 02 	lds	r24, 0x0280
    100e:	81 50       	subi	r24, 0x01	; 1
    1010:	80 93 80 02 	sts	0x0280, r24
    1014:	80 91 80 02 	lds	r24, 0x0280
    1018:	28 2f       	mov	r18, r24
    101a:	30 e0       	ldi	r19, 0x00	; 0
    101c:	c9 01       	movw	r24, r18
    101e:	88 0f       	add	r24, r24
    1020:	99 1f       	adc	r25, r25
    1022:	88 0f       	add	r24, r24
    1024:	99 1f       	adc	r25, r25
    1026:	88 0f       	add	r24, r24
    1028:	99 1f       	adc	r25, r25
    102a:	82 0f       	add	r24, r18
    102c:	93 1f       	adc	r25, r19
    102e:	80 5d       	subi	r24, 0xD0	; 208
    1030:	9d 4f       	sbci	r25, 0xFD	; 253
    1032:	fc 01       	movw	r30, r24
    1034:	80 81       	ld	r24, Z
    1036:	88 23       	and	r24, r24
    1038:	41 f3       	breq	.-48     	; 0x100a <vTaskSwitchContext+0x5c>
    103a:	80 91 80 02 	lds	r24, 0x0280
    103e:	28 2f       	mov	r18, r24
    1040:	30 e0       	ldi	r19, 0x00	; 0
    1042:	c9 01       	movw	r24, r18
    1044:	88 0f       	add	r24, r24
    1046:	99 1f       	adc	r25, r25
    1048:	88 0f       	add	r24, r24
    104a:	99 1f       	adc	r25, r25
    104c:	88 0f       	add	r24, r24
    104e:	99 1f       	adc	r25, r25
    1050:	82 0f       	add	r24, r18
    1052:	93 1f       	adc	r25, r19
    1054:	80 5d       	subi	r24, 0xD0	; 208
    1056:	9d 4f       	sbci	r25, 0xFD	; 253
    1058:	9a 83       	std	Y+2, r25	; 0x02
    105a:	89 83       	std	Y+1, r24	; 0x01
    105c:	89 81       	ldd	r24, Y+1	; 0x01
    105e:	9a 81       	ldd	r25, Y+2	; 0x02
    1060:	fc 01       	movw	r30, r24
    1062:	81 81       	ldd	r24, Z+1	; 0x01
    1064:	92 81       	ldd	r25, Z+2	; 0x02
    1066:	fc 01       	movw	r30, r24
    1068:	22 81       	ldd	r18, Z+2	; 0x02
    106a:	33 81       	ldd	r19, Z+3	; 0x03
    106c:	89 81       	ldd	r24, Y+1	; 0x01
    106e:	9a 81       	ldd	r25, Y+2	; 0x02
    1070:	fc 01       	movw	r30, r24
    1072:	32 83       	std	Z+2, r19	; 0x02
    1074:	21 83       	std	Z+1, r18	; 0x01
    1076:	89 81       	ldd	r24, Y+1	; 0x01
    1078:	9a 81       	ldd	r25, Y+2	; 0x02
    107a:	fc 01       	movw	r30, r24
    107c:	21 81       	ldd	r18, Z+1	; 0x01
    107e:	32 81       	ldd	r19, Z+2	; 0x02
    1080:	89 81       	ldd	r24, Y+1	; 0x01
    1082:	9a 81       	ldd	r25, Y+2	; 0x02
    1084:	03 96       	adiw	r24, 0x03	; 3
    1086:	28 17       	cp	r18, r24
    1088:	39 07       	cpc	r19, r25
    108a:	69 f4       	brne	.+26     	; 0x10a6 <vTaskSwitchContext+0xf8>
    108c:	89 81       	ldd	r24, Y+1	; 0x01
    108e:	9a 81       	ldd	r25, Y+2	; 0x02
    1090:	fc 01       	movw	r30, r24
    1092:	81 81       	ldd	r24, Z+1	; 0x01
    1094:	92 81       	ldd	r25, Z+2	; 0x02
    1096:	fc 01       	movw	r30, r24
    1098:	22 81       	ldd	r18, Z+2	; 0x02
    109a:	33 81       	ldd	r19, Z+3	; 0x03
    109c:	89 81       	ldd	r24, Y+1	; 0x01
    109e:	9a 81       	ldd	r25, Y+2	; 0x02
    10a0:	fc 01       	movw	r30, r24
    10a2:	32 83       	std	Z+2, r19	; 0x02
    10a4:	21 83       	std	Z+1, r18	; 0x01
    10a6:	89 81       	ldd	r24, Y+1	; 0x01
    10a8:	9a 81       	ldd	r25, Y+2	; 0x02
    10aa:	fc 01       	movw	r30, r24
    10ac:	81 81       	ldd	r24, Z+1	; 0x01
    10ae:	92 81       	ldd	r25, Z+2	; 0x02
    10b0:	fc 01       	movw	r30, r24
    10b2:	86 81       	ldd	r24, Z+6	; 0x06
    10b4:	97 81       	ldd	r25, Z+7	; 0x07
    10b6:	90 93 2f 02 	sts	0x022F, r25
    10ba:	80 93 2e 02 	sts	0x022E, r24

		traceTASK_SWITCHED_IN();
	}
}
    10be:	0f 90       	pop	r0
    10c0:	0f 90       	pop	r0
    10c2:	df 91       	pop	r29
    10c4:	cf 91       	pop	r28
    10c6:	08 95       	ret

000010c8 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    10c8:	cf 93       	push	r28
    10ca:	df 93       	push	r29
    10cc:	00 d0       	rcall	.+0      	; 0x10ce <vTaskPlaceOnEventList+0x6>
    10ce:	00 d0       	rcall	.+0      	; 0x10d0 <vTaskPlaceOnEventList+0x8>
    10d0:	cd b7       	in	r28, 0x3d	; 61
    10d2:	de b7       	in	r29, 0x3e	; 62
    10d4:	9c 83       	std	Y+4, r25	; 0x04
    10d6:	8b 83       	std	Y+3, r24	; 0x03
    10d8:	7e 83       	std	Y+6, r23	; 0x06
    10da:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    10dc:	80 91 2e 02 	lds	r24, 0x022E
    10e0:	90 91 2f 02 	lds	r25, 0x022F
    10e4:	9c 01       	movw	r18, r24
    10e6:	24 5f       	subi	r18, 0xF4	; 244
    10e8:	3f 4f       	sbci	r19, 0xFF	; 255
    10ea:	8b 81       	ldd	r24, Y+3	; 0x03
    10ec:	9c 81       	ldd	r25, Y+4	; 0x04
    10ee:	b9 01       	movw	r22, r18
    10f0:	0e 94 9b 12 	call	0x2536	; 0x2536 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    10f4:	80 91 2e 02 	lds	r24, 0x022E
    10f8:	90 91 2f 02 	lds	r25, 0x022F
    10fc:	02 96       	adiw	r24, 0x02	; 2
    10fe:	0e 94 14 13 	call	0x2628	; 0x2628 <uxListRemove>
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    1102:	8d 81       	ldd	r24, Y+5	; 0x05
    1104:	9e 81       	ldd	r25, Y+6	; 0x06
    1106:	8f 3f       	cpi	r24, 0xFF	; 255
    1108:	2f ef       	ldi	r18, 0xFF	; 255
    110a:	92 07       	cpc	r25, r18
    110c:	59 f4       	brne	.+22     	; 0x1124 <vTaskPlaceOnEventList+0x5c>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    110e:	80 91 2e 02 	lds	r24, 0x022E
    1112:	90 91 2f 02 	lds	r25, 0x022F
    1116:	02 96       	adiw	r24, 0x02	; 2
    1118:	bc 01       	movw	r22, r24
    111a:	83 e7       	ldi	r24, 0x73	; 115
    111c:	92 e0       	ldi	r25, 0x02	; 2
    111e:	0e 94 44 12 	call	0x2488	; 0x2488 <vListInsertEnd>
    1122:	0e c0       	rjmp	.+28     	; 0x1140 <vTaskPlaceOnEventList+0x78>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    1124:	20 91 7d 02 	lds	r18, 0x027D
    1128:	30 91 7e 02 	lds	r19, 0x027E
    112c:	8d 81       	ldd	r24, Y+5	; 0x05
    112e:	9e 81       	ldd	r25, Y+6	; 0x06
    1130:	82 0f       	add	r24, r18
    1132:	93 1f       	adc	r25, r19
    1134:	9a 83       	std	Y+2, r25	; 0x02
    1136:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    1138:	89 81       	ldd	r24, Y+1	; 0x01
    113a:	9a 81       	ldd	r25, Y+2	; 0x02
    113c:	0e 94 5f 0a 	call	0x14be	; 0x14be <prvAddCurrentTaskToDelayedList>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
    1140:	26 96       	adiw	r28, 0x06	; 6
    1142:	0f b6       	in	r0, 0x3f	; 63
    1144:	f8 94       	cli
    1146:	de bf       	out	0x3e, r29	; 62
    1148:	0f be       	out	0x3f, r0	; 63
    114a:	cd bf       	out	0x3d, r28	; 61
    114c:	df 91       	pop	r29
    114e:	cf 91       	pop	r28
    1150:	08 95       	ret

00001152 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    1152:	cf 93       	push	r28
    1154:	df 93       	push	r29
    1156:	00 d0       	rcall	.+0      	; 0x1158 <xTaskRemoveFromEventList+0x6>
    1158:	1f 92       	push	r1
    115a:	1f 92       	push	r1
    115c:	cd b7       	in	r28, 0x3d	; 61
    115e:	de b7       	in	r29, 0x3e	; 62
    1160:	9d 83       	std	Y+5, r25	; 0x05
    1162:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1164:	8c 81       	ldd	r24, Y+4	; 0x04
    1166:	9d 81       	ldd	r25, Y+5	; 0x05
    1168:	fc 01       	movw	r30, r24
    116a:	85 81       	ldd	r24, Z+5	; 0x05
    116c:	96 81       	ldd	r25, Z+6	; 0x06
    116e:	fc 01       	movw	r30, r24
    1170:	86 81       	ldd	r24, Z+6	; 0x06
    1172:	97 81       	ldd	r25, Z+7	; 0x07
    1174:	9b 83       	std	Y+3, r25	; 0x03
    1176:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1178:	8a 81       	ldd	r24, Y+2	; 0x02
    117a:	9b 81       	ldd	r25, Y+3	; 0x03
    117c:	0c 96       	adiw	r24, 0x0c	; 12
    117e:	0e 94 14 13 	call	0x2628	; 0x2628 <uxListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1182:	80 91 82 02 	lds	r24, 0x0282
    1186:	88 23       	and	r24, r24
    1188:	69 f5       	brne	.+90     	; 0x11e4 <xTaskRemoveFromEventList+0x92>
	{
		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    118a:	8a 81       	ldd	r24, Y+2	; 0x02
    118c:	9b 81       	ldd	r25, Y+3	; 0x03
    118e:	02 96       	adiw	r24, 0x02	; 2
    1190:	0e 94 14 13 	call	0x2628	; 0x2628 <uxListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    1194:	8a 81       	ldd	r24, Y+2	; 0x02
    1196:	9b 81       	ldd	r25, Y+3	; 0x03
    1198:	fc 01       	movw	r30, r24
    119a:	96 89       	ldd	r25, Z+22	; 0x16
    119c:	80 91 80 02 	lds	r24, 0x0280
    11a0:	89 17       	cp	r24, r25
    11a2:	30 f4       	brcc	.+12     	; 0x11b0 <xTaskRemoveFromEventList+0x5e>
    11a4:	8a 81       	ldd	r24, Y+2	; 0x02
    11a6:	9b 81       	ldd	r25, Y+3	; 0x03
    11a8:	fc 01       	movw	r30, r24
    11aa:	86 89       	ldd	r24, Z+22	; 0x16
    11ac:	80 93 80 02 	sts	0x0280, r24
    11b0:	8a 81       	ldd	r24, Y+2	; 0x02
    11b2:	9b 81       	ldd	r25, Y+3	; 0x03
    11b4:	ac 01       	movw	r20, r24
    11b6:	4e 5f       	subi	r20, 0xFE	; 254
    11b8:	5f 4f       	sbci	r21, 0xFF	; 255
    11ba:	8a 81       	ldd	r24, Y+2	; 0x02
    11bc:	9b 81       	ldd	r25, Y+3	; 0x03
    11be:	fc 01       	movw	r30, r24
    11c0:	86 89       	ldd	r24, Z+22	; 0x16
    11c2:	28 2f       	mov	r18, r24
    11c4:	30 e0       	ldi	r19, 0x00	; 0
    11c6:	c9 01       	movw	r24, r18
    11c8:	88 0f       	add	r24, r24
    11ca:	99 1f       	adc	r25, r25
    11cc:	88 0f       	add	r24, r24
    11ce:	99 1f       	adc	r25, r25
    11d0:	88 0f       	add	r24, r24
    11d2:	99 1f       	adc	r25, r25
    11d4:	82 0f       	add	r24, r18
    11d6:	93 1f       	adc	r25, r19
    11d8:	80 5d       	subi	r24, 0xD0	; 208
    11da:	9d 4f       	sbci	r25, 0xFD	; 253
    11dc:	ba 01       	movw	r22, r20
    11de:	0e 94 44 12 	call	0x2488	; 0x2488 <vListInsertEnd>
    11e2:	08 c0       	rjmp	.+16     	; 0x11f4 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    11e4:	8a 81       	ldd	r24, Y+2	; 0x02
    11e6:	9b 81       	ldd	r25, Y+3	; 0x03
    11e8:	0c 96       	adiw	r24, 0x0c	; 12
    11ea:	bc 01       	movw	r22, r24
    11ec:	8a e6       	ldi	r24, 0x6A	; 106
    11ee:	92 e0       	ldi	r25, 0x02	; 2
    11f0:	0e 94 44 12 	call	0x2488	; 0x2488 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    11f4:	8a 81       	ldd	r24, Y+2	; 0x02
    11f6:	9b 81       	ldd	r25, Y+3	; 0x03
    11f8:	fc 01       	movw	r30, r24
    11fa:	26 89       	ldd	r18, Z+22	; 0x16
    11fc:	80 91 2e 02 	lds	r24, 0x022E
    1200:	90 91 2f 02 	lds	r25, 0x022F
    1204:	fc 01       	movw	r30, r24
    1206:	86 89       	ldd	r24, Z+22	; 0x16
    1208:	28 17       	cp	r18, r24
    120a:	18 f0       	brcs	.+6      	; 0x1212 <xTaskRemoveFromEventList+0xc0>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    120c:	81 e0       	ldi	r24, 0x01	; 1
    120e:	89 83       	std	Y+1, r24	; 0x01
    1210:	01 c0       	rjmp	.+2      	; 0x1214 <xTaskRemoveFromEventList+0xc2>
	}
	else
	{
		xReturn = pdFALSE;
    1212:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    1214:	89 81       	ldd	r24, Y+1	; 0x01
}
    1216:	0f 90       	pop	r0
    1218:	0f 90       	pop	r0
    121a:	0f 90       	pop	r0
    121c:	0f 90       	pop	r0
    121e:	0f 90       	pop	r0
    1220:	df 91       	pop	r29
    1222:	cf 91       	pop	r28
    1224:	08 95       	ret

00001226 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    1226:	cf 93       	push	r28
    1228:	df 93       	push	r29
    122a:	1f 92       	push	r1
    122c:	1f 92       	push	r1
    122e:	cd b7       	in	r28, 0x3d	; 61
    1230:	de b7       	in	r29, 0x3e	; 62
    1232:	9a 83       	std	Y+2, r25	; 0x02
    1234:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1236:	20 91 85 02 	lds	r18, 0x0285
    123a:	89 81       	ldd	r24, Y+1	; 0x01
    123c:	9a 81       	ldd	r25, Y+2	; 0x02
    123e:	fc 01       	movw	r30, r24
    1240:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    1242:	20 91 7d 02 	lds	r18, 0x027D
    1246:	30 91 7e 02 	lds	r19, 0x027E
    124a:	89 81       	ldd	r24, Y+1	; 0x01
    124c:	9a 81       	ldd	r25, Y+2	; 0x02
    124e:	fc 01       	movw	r30, r24
    1250:	32 83       	std	Z+2, r19	; 0x02
    1252:	21 83       	std	Z+1, r18	; 0x01
}
    1254:	0f 90       	pop	r0
    1256:	0f 90       	pop	r0
    1258:	df 91       	pop	r29
    125a:	cf 91       	pop	r28
    125c:	08 95       	ret

0000125e <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    125e:	cf 93       	push	r28
    1260:	df 93       	push	r29
    1262:	00 d0       	rcall	.+0      	; 0x1264 <xTaskCheckForTimeOut+0x6>
    1264:	1f 92       	push	r1
    1266:	1f 92       	push	r1
    1268:	cd b7       	in	r28, 0x3d	; 61
    126a:	de b7       	in	r29, 0x3e	; 62
    126c:	9b 83       	std	Y+3, r25	; 0x03
    126e:	8a 83       	std	Y+2, r24	; 0x02
    1270:	7d 83       	std	Y+5, r23	; 0x05
    1272:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1274:	0f b6       	in	r0, 0x3f	; 63
    1276:	f8 94       	cli
    1278:	0f 92       	push	r0
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    127a:	8c 81       	ldd	r24, Y+4	; 0x04
    127c:	9d 81       	ldd	r25, Y+5	; 0x05
    127e:	fc 01       	movw	r30, r24
    1280:	80 81       	ld	r24, Z
    1282:	91 81       	ldd	r25, Z+1	; 0x01
    1284:	8f 3f       	cpi	r24, 0xFF	; 255
    1286:	ff ef       	ldi	r31, 0xFF	; 255
    1288:	9f 07       	cpc	r25, r31
    128a:	11 f4       	brne	.+4      	; 0x1290 <xTaskCheckForTimeOut+0x32>
			{
				xReturn = pdFALSE;
    128c:	19 82       	std	Y+1, r1	; 0x01
    128e:	4b c0       	rjmp	.+150    	; 0x1326 <xTaskCheckForTimeOut+0xc8>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    1290:	8a 81       	ldd	r24, Y+2	; 0x02
    1292:	9b 81       	ldd	r25, Y+3	; 0x03
    1294:	fc 01       	movw	r30, r24
    1296:	90 81       	ld	r25, Z
    1298:	80 91 85 02 	lds	r24, 0x0285
    129c:	98 17       	cp	r25, r24
    129e:	79 f0       	breq	.+30     	; 0x12be <xTaskCheckForTimeOut+0x60>
    12a0:	8a 81       	ldd	r24, Y+2	; 0x02
    12a2:	9b 81       	ldd	r25, Y+3	; 0x03
    12a4:	fc 01       	movw	r30, r24
    12a6:	21 81       	ldd	r18, Z+1	; 0x01
    12a8:	32 81       	ldd	r19, Z+2	; 0x02
    12aa:	80 91 7d 02 	lds	r24, 0x027D
    12ae:	90 91 7e 02 	lds	r25, 0x027E
    12b2:	82 17       	cp	r24, r18
    12b4:	93 07       	cpc	r25, r19
    12b6:	18 f0       	brcs	.+6      	; 0x12be <xTaskCheckForTimeOut+0x60>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    12b8:	81 e0       	ldi	r24, 0x01	; 1
    12ba:	89 83       	std	Y+1, r24	; 0x01
    12bc:	34 c0       	rjmp	.+104    	; 0x1326 <xTaskCheckForTimeOut+0xc8>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    12be:	20 91 7d 02 	lds	r18, 0x027D
    12c2:	30 91 7e 02 	lds	r19, 0x027E
    12c6:	8a 81       	ldd	r24, Y+2	; 0x02
    12c8:	9b 81       	ldd	r25, Y+3	; 0x03
    12ca:	fc 01       	movw	r30, r24
    12cc:	81 81       	ldd	r24, Z+1	; 0x01
    12ce:	92 81       	ldd	r25, Z+2	; 0x02
    12d0:	28 1b       	sub	r18, r24
    12d2:	39 0b       	sbc	r19, r25
    12d4:	8c 81       	ldd	r24, Y+4	; 0x04
    12d6:	9d 81       	ldd	r25, Y+5	; 0x05
    12d8:	fc 01       	movw	r30, r24
    12da:	80 81       	ld	r24, Z
    12dc:	91 81       	ldd	r25, Z+1	; 0x01
    12de:	28 17       	cp	r18, r24
    12e0:	39 07       	cpc	r19, r25
    12e2:	f8 f4       	brcc	.+62     	; 0x1322 <xTaskCheckForTimeOut+0xc4>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    12e4:	8c 81       	ldd	r24, Y+4	; 0x04
    12e6:	9d 81       	ldd	r25, Y+5	; 0x05
    12e8:	fc 01       	movw	r30, r24
    12ea:	20 81       	ld	r18, Z
    12ec:	31 81       	ldd	r19, Z+1	; 0x01
    12ee:	8a 81       	ldd	r24, Y+2	; 0x02
    12f0:	9b 81       	ldd	r25, Y+3	; 0x03
    12f2:	fc 01       	movw	r30, r24
    12f4:	41 81       	ldd	r20, Z+1	; 0x01
    12f6:	52 81       	ldd	r21, Z+2	; 0x02
    12f8:	80 91 7d 02 	lds	r24, 0x027D
    12fc:	90 91 7e 02 	lds	r25, 0x027E
    1300:	ba 01       	movw	r22, r20
    1302:	68 1b       	sub	r22, r24
    1304:	79 0b       	sbc	r23, r25
    1306:	cb 01       	movw	r24, r22
    1308:	28 0f       	add	r18, r24
    130a:	39 1f       	adc	r19, r25
    130c:	8c 81       	ldd	r24, Y+4	; 0x04
    130e:	9d 81       	ldd	r25, Y+5	; 0x05
    1310:	fc 01       	movw	r30, r24
    1312:	31 83       	std	Z+1, r19	; 0x01
    1314:	20 83       	st	Z, r18
			vTaskSetTimeOutState( pxTimeOut );
    1316:	8a 81       	ldd	r24, Y+2	; 0x02
    1318:	9b 81       	ldd	r25, Y+3	; 0x03
    131a:	0e 94 13 09 	call	0x1226	; 0x1226 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    131e:	19 82       	std	Y+1, r1	; 0x01
    1320:	02 c0       	rjmp	.+4      	; 0x1326 <xTaskCheckForTimeOut+0xc8>
		}
		else
		{
			xReturn = pdTRUE;
    1322:	81 e0       	ldi	r24, 0x01	; 1
    1324:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    1326:	0f 90       	pop	r0
    1328:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    132a:	89 81       	ldd	r24, Y+1	; 0x01
}
    132c:	0f 90       	pop	r0
    132e:	0f 90       	pop	r0
    1330:	0f 90       	pop	r0
    1332:	0f 90       	pop	r0
    1334:	0f 90       	pop	r0
    1336:	df 91       	pop	r29
    1338:	cf 91       	pop	r28
    133a:	08 95       	ret

0000133c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    133c:	cf 93       	push	r28
    133e:	df 93       	push	r29
    1340:	cd b7       	in	r28, 0x3d	; 61
    1342:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    1344:	81 e0       	ldi	r24, 0x01	; 1
    1346:	80 93 84 02 	sts	0x0284, r24
}
    134a:	df 91       	pop	r29
    134c:	cf 91       	pop	r28
    134e:	08 95       	ret

00001350 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    1350:	cf 93       	push	r28
    1352:	df 93       	push	r29
    1354:	1f 92       	push	r1
    1356:	1f 92       	push	r1
    1358:	cd b7       	in	r28, 0x3d	; 61
    135a:	de b7       	in	r29, 0x3e	; 62
    135c:	9a 83       	std	Y+2, r25	; 0x02
    135e:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    1360:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    1364:	80 91 30 02 	lds	r24, 0x0230
    1368:	82 30       	cpi	r24, 0x02	; 2
    136a:	18 f0       	brcs	.+6      	; 0x1372 <prvIdleTask+0x22>
			{
				taskYIELD();
    136c:	0e 94 d6 18 	call	0x31ac	; 0x31ac <vPortYield>
				}
				xTaskResumeAll();
			}
		}
		#endif
	}
    1370:	f7 cf       	rjmp	.-18     	; 0x1360 <prvIdleTask+0x10>
    1372:	f6 cf       	rjmp	.-20     	; 0x1360 <prvIdleTask+0x10>

00001374 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    1374:	0f 93       	push	r16
    1376:	1f 93       	push	r17
    1378:	cf 93       	push	r28
    137a:	df 93       	push	r29
    137c:	cd b7       	in	r28, 0x3d	; 61
    137e:	de b7       	in	r29, 0x3e	; 62
    1380:	29 97       	sbiw	r28, 0x09	; 9
    1382:	0f b6       	in	r0, 0x3f	; 63
    1384:	f8 94       	cli
    1386:	de bf       	out	0x3e, r29	; 62
    1388:	0f be       	out	0x3f, r0	; 63
    138a:	cd bf       	out	0x3d, r28	; 61
    138c:	9a 83       	std	Y+2, r25	; 0x02
    138e:	89 83       	std	Y+1, r24	; 0x01
    1390:	7c 83       	std	Y+4, r23	; 0x04
    1392:	6b 83       	std	Y+3, r22	; 0x03
    1394:	4d 83       	std	Y+5, r20	; 0x05
    1396:	3f 83       	std	Y+7, r19	; 0x07
    1398:	2e 83       	std	Y+6, r18	; 0x06
    139a:	19 87       	std	Y+9, r17	; 0x09
    139c:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    139e:	89 81       	ldd	r24, Y+1	; 0x01
    13a0:	9a 81       	ldd	r25, Y+2	; 0x02
    13a2:	49 96       	adiw	r24, 0x19	; 25
    13a4:	2b 81       	ldd	r18, Y+3	; 0x03
    13a6:	3c 81       	ldd	r19, Y+4	; 0x04
    13a8:	40 e1       	ldi	r20, 0x10	; 16
    13aa:	50 e0       	ldi	r21, 0x00	; 0
    13ac:	b9 01       	movw	r22, r18
    13ae:	0e 94 fa 23 	call	0x47f4	; 0x47f4 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    13b2:	89 81       	ldd	r24, Y+1	; 0x01
    13b4:	9a 81       	ldd	r25, Y+2	; 0x02
    13b6:	fc 01       	movw	r30, r24
    13b8:	10 a6       	std	Z+40, r1	; 0x28

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    13ba:	8d 81       	ldd	r24, Y+5	; 0x05
    13bc:	84 30       	cpi	r24, 0x04	; 4
    13be:	10 f0       	brcs	.+4      	; 0x13c4 <prvInitialiseTCBVariables+0x50>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    13c0:	83 e0       	ldi	r24, 0x03	; 3
    13c2:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    13c4:	89 81       	ldd	r24, Y+1	; 0x01
    13c6:	9a 81       	ldd	r25, Y+2	; 0x02
    13c8:	2d 81       	ldd	r18, Y+5	; 0x05
    13ca:	fc 01       	movw	r30, r24
    13cc:	26 8b       	std	Z+22, r18	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    13ce:	89 81       	ldd	r24, Y+1	; 0x01
    13d0:	9a 81       	ldd	r25, Y+2	; 0x02
    13d2:	2d 81       	ldd	r18, Y+5	; 0x05
    13d4:	fc 01       	movw	r30, r24
    13d6:	21 a7       	std	Z+41, r18	; 0x29
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    13d8:	89 81       	ldd	r24, Y+1	; 0x01
    13da:	9a 81       	ldd	r25, Y+2	; 0x02
    13dc:	02 96       	adiw	r24, 0x02	; 2
    13de:	0e 94 32 12 	call	0x2464	; 0x2464 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    13e2:	89 81       	ldd	r24, Y+1	; 0x01
    13e4:	9a 81       	ldd	r25, Y+2	; 0x02
    13e6:	0c 96       	adiw	r24, 0x0c	; 12
    13e8:	0e 94 32 12 	call	0x2464	; 0x2464 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    13ec:	89 81       	ldd	r24, Y+1	; 0x01
    13ee:	9a 81       	ldd	r25, Y+2	; 0x02
    13f0:	29 81       	ldd	r18, Y+1	; 0x01
    13f2:	3a 81       	ldd	r19, Y+2	; 0x02
    13f4:	fc 01       	movw	r30, r24
    13f6:	31 87       	std	Z+9, r19	; 0x09
    13f8:	20 87       	std	Z+8, r18	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    13fa:	8d 81       	ldd	r24, Y+5	; 0x05
    13fc:	88 2f       	mov	r24, r24
    13fe:	90 e0       	ldi	r25, 0x00	; 0
    1400:	24 e0       	ldi	r18, 0x04	; 4
    1402:	30 e0       	ldi	r19, 0x00	; 0
    1404:	28 1b       	sub	r18, r24
    1406:	39 0b       	sbc	r19, r25
    1408:	89 81       	ldd	r24, Y+1	; 0x01
    140a:	9a 81       	ldd	r25, Y+2	; 0x02
    140c:	fc 01       	movw	r30, r24
    140e:	35 87       	std	Z+13, r19	; 0x0d
    1410:	24 87       	std	Z+12, r18	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    1412:	89 81       	ldd	r24, Y+1	; 0x01
    1414:	9a 81       	ldd	r25, Y+2	; 0x02
    1416:	29 81       	ldd	r18, Y+1	; 0x01
    1418:	3a 81       	ldd	r19, Y+2	; 0x02
    141a:	fc 01       	movw	r30, r24
    141c:	33 8b       	std	Z+19, r19	; 0x13
    141e:	22 8b       	std	Z+18, r18	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    1420:	29 96       	adiw	r28, 0x09	; 9
    1422:	0f b6       	in	r0, 0x3f	; 63
    1424:	f8 94       	cli
    1426:	de bf       	out	0x3e, r29	; 62
    1428:	0f be       	out	0x3f, r0	; 63
    142a:	cd bf       	out	0x3d, r28	; 61
    142c:	df 91       	pop	r29
    142e:	cf 91       	pop	r28
    1430:	1f 91       	pop	r17
    1432:	0f 91       	pop	r16
    1434:	08 95       	ret

00001436 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    1436:	cf 93       	push	r28
    1438:	df 93       	push	r29
    143a:	1f 92       	push	r1
    143c:	cd b7       	in	r28, 0x3d	; 61
    143e:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    1440:	19 82       	std	Y+1, r1	; 0x01
    1442:	13 c0       	rjmp	.+38     	; 0x146a <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    1444:	89 81       	ldd	r24, Y+1	; 0x01
    1446:	28 2f       	mov	r18, r24
    1448:	30 e0       	ldi	r19, 0x00	; 0
    144a:	c9 01       	movw	r24, r18
    144c:	88 0f       	add	r24, r24
    144e:	99 1f       	adc	r25, r25
    1450:	88 0f       	add	r24, r24
    1452:	99 1f       	adc	r25, r25
    1454:	88 0f       	add	r24, r24
    1456:	99 1f       	adc	r25, r25
    1458:	82 0f       	add	r24, r18
    145a:	93 1f       	adc	r25, r19
    145c:	80 5d       	subi	r24, 0xD0	; 208
    145e:	9d 4f       	sbci	r25, 0xFD	; 253
    1460:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    1464:	89 81       	ldd	r24, Y+1	; 0x01
    1466:	8f 5f       	subi	r24, 0xFF	; 255
    1468:	89 83       	std	Y+1, r24	; 0x01
    146a:	89 81       	ldd	r24, Y+1	; 0x01
    146c:	84 30       	cpi	r24, 0x04	; 4
    146e:	50 f3       	brcs	.-44     	; 0x1444 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    1470:	84 e5       	ldi	r24, 0x54	; 84
    1472:	92 e0       	ldi	r25, 0x02	; 2
    1474:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    1478:	8d e5       	ldi	r24, 0x5D	; 93
    147a:	92 e0       	ldi	r25, 0x02	; 2
    147c:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    1480:	8a e6       	ldi	r24, 0x6A	; 106
    1482:	92 e0       	ldi	r25, 0x02	; 2
    1484:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
    1488:	83 e7       	ldi	r24, 0x73	; 115
    148a:	92 e0       	ldi	r25, 0x02	; 2
    148c:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1490:	84 e5       	ldi	r24, 0x54	; 84
    1492:	92 e0       	ldi	r25, 0x02	; 2
    1494:	90 93 67 02 	sts	0x0267, r25
    1498:	80 93 66 02 	sts	0x0266, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    149c:	8d e5       	ldi	r24, 0x5D	; 93
    149e:	92 e0       	ldi	r25, 0x02	; 2
    14a0:	90 93 69 02 	sts	0x0269, r25
    14a4:	80 93 68 02 	sts	0x0268, r24
}
    14a8:	0f 90       	pop	r0
    14aa:	df 91       	pop	r29
    14ac:	cf 91       	pop	r28
    14ae:	08 95       	ret

000014b0 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    14b0:	cf 93       	push	r28
    14b2:	df 93       	push	r29
    14b4:	cd b7       	in	r28, 0x3d	; 61
    14b6:	de b7       	in	r29, 0x3e	; 62
				prvDeleteTCB( pxTCB );
			}
		}
	}
	#endif
}
    14b8:	df 91       	pop	r29
    14ba:	cf 91       	pop	r28
    14bc:	08 95       	ret

000014be <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    14be:	cf 93       	push	r28
    14c0:	df 93       	push	r29
    14c2:	1f 92       	push	r1
    14c4:	1f 92       	push	r1
    14c6:	cd b7       	in	r28, 0x3d	; 61
    14c8:	de b7       	in	r29, 0x3e	; 62
    14ca:	9a 83       	std	Y+2, r25	; 0x02
    14cc:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    14ce:	80 91 2e 02 	lds	r24, 0x022E
    14d2:	90 91 2f 02 	lds	r25, 0x022F
    14d6:	29 81       	ldd	r18, Y+1	; 0x01
    14d8:	3a 81       	ldd	r19, Y+2	; 0x02
    14da:	fc 01       	movw	r30, r24
    14dc:	33 83       	std	Z+3, r19	; 0x03
    14de:	22 83       	std	Z+2, r18	; 0x02

	if( xTimeToWake < xTickCount )
    14e0:	80 91 7d 02 	lds	r24, 0x027D
    14e4:	90 91 7e 02 	lds	r25, 0x027E
    14e8:	29 81       	ldd	r18, Y+1	; 0x01
    14ea:	3a 81       	ldd	r19, Y+2	; 0x02
    14ec:	28 17       	cp	r18, r24
    14ee:	39 07       	cpc	r19, r25
    14f0:	78 f4       	brcc	.+30     	; 0x1510 <prvAddCurrentTaskToDelayedList+0x52>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    14f2:	80 91 2e 02 	lds	r24, 0x022E
    14f6:	90 91 2f 02 	lds	r25, 0x022F
    14fa:	9c 01       	movw	r18, r24
    14fc:	2e 5f       	subi	r18, 0xFE	; 254
    14fe:	3f 4f       	sbci	r19, 0xFF	; 255
    1500:	80 91 68 02 	lds	r24, 0x0268
    1504:	90 91 69 02 	lds	r25, 0x0269
    1508:	b9 01       	movw	r22, r18
    150a:	0e 94 9b 12 	call	0x2536	; 0x2536 <vListInsert>
    150e:	1d c0       	rjmp	.+58     	; 0x154a <prvAddCurrentTaskToDelayedList+0x8c>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1510:	80 91 2e 02 	lds	r24, 0x022E
    1514:	90 91 2f 02 	lds	r25, 0x022F
    1518:	9c 01       	movw	r18, r24
    151a:	2e 5f       	subi	r18, 0xFE	; 254
    151c:	3f 4f       	sbci	r19, 0xFF	; 255
    151e:	80 91 66 02 	lds	r24, 0x0266
    1522:	90 91 67 02 	lds	r25, 0x0267
    1526:	b9 01       	movw	r22, r18
    1528:	0e 94 9b 12 	call	0x2536	; 0x2536 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    152c:	80 91 00 02 	lds	r24, 0x0200
    1530:	90 91 01 02 	lds	r25, 0x0201
    1534:	29 81       	ldd	r18, Y+1	; 0x01
    1536:	3a 81       	ldd	r19, Y+2	; 0x02
    1538:	28 17       	cp	r18, r24
    153a:	39 07       	cpc	r19, r25
    153c:	30 f4       	brcc	.+12     	; 0x154a <prvAddCurrentTaskToDelayedList+0x8c>
		{
			xNextTaskUnblockTime = xTimeToWake;
    153e:	89 81       	ldd	r24, Y+1	; 0x01
    1540:	9a 81       	ldd	r25, Y+2	; 0x02
    1542:	90 93 01 02 	sts	0x0201, r25
    1546:	80 93 00 02 	sts	0x0200, r24
		}
	}
}
    154a:	0f 90       	pop	r0
    154c:	0f 90       	pop	r0
    154e:	df 91       	pop	r29
    1550:	cf 91       	pop	r28
    1552:	08 95       	ret

00001554 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    1554:	cf 93       	push	r28
    1556:	df 93       	push	r29
    1558:	00 d0       	rcall	.+0      	; 0x155a <prvAllocateTCBAndStack+0x6>
    155a:	00 d0       	rcall	.+0      	; 0x155c <prvAllocateTCBAndStack+0x8>
    155c:	cd b7       	in	r28, 0x3d	; 61
    155e:	de b7       	in	r29, 0x3e	; 62
    1560:	9c 83       	std	Y+4, r25	; 0x04
    1562:	8b 83       	std	Y+3, r24	; 0x03
    1564:	7e 83       	std	Y+6, r23	; 0x06
    1566:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    1568:	8a e2       	ldi	r24, 0x2A	; 42
    156a:	90 e0       	ldi	r25, 0x00	; 0
    156c:	0e 94 63 16 	call	0x2cc6	; 0x2cc6 <pvPortMalloc>
    1570:	9a 83       	std	Y+2, r25	; 0x02
    1572:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    1574:	89 81       	ldd	r24, Y+1	; 0x01
    1576:	9a 81       	ldd	r25, Y+2	; 0x02
    1578:	00 97       	sbiw	r24, 0x00	; 0
    157a:	51 f1       	breq	.+84     	; 0x15d0 <prvAllocateTCBAndStack+0x7c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    157c:	8d 81       	ldd	r24, Y+5	; 0x05
    157e:	9e 81       	ldd	r25, Y+6	; 0x06
    1580:	00 97       	sbiw	r24, 0x00	; 0
    1582:	29 f4       	brne	.+10     	; 0x158e <prvAllocateTCBAndStack+0x3a>
    1584:	8b 81       	ldd	r24, Y+3	; 0x03
    1586:	9c 81       	ldd	r25, Y+4	; 0x04
    1588:	0e 94 63 16 	call	0x2cc6	; 0x2cc6 <pvPortMalloc>
    158c:	02 c0       	rjmp	.+4      	; 0x1592 <prvAllocateTCBAndStack+0x3e>
    158e:	8d 81       	ldd	r24, Y+5	; 0x05
    1590:	9e 81       	ldd	r25, Y+6	; 0x06
    1592:	29 81       	ldd	r18, Y+1	; 0x01
    1594:	3a 81       	ldd	r19, Y+2	; 0x02
    1596:	f9 01       	movw	r30, r18
    1598:	90 8f       	std	Z+24, r25	; 0x18
    159a:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    159c:	89 81       	ldd	r24, Y+1	; 0x01
    159e:	9a 81       	ldd	r25, Y+2	; 0x02
    15a0:	fc 01       	movw	r30, r24
    15a2:	87 89       	ldd	r24, Z+23	; 0x17
    15a4:	90 8d       	ldd	r25, Z+24	; 0x18
    15a6:	00 97       	sbiw	r24, 0x00	; 0
    15a8:	39 f4       	brne	.+14     	; 0x15b8 <prvAllocateTCBAndStack+0x64>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    15aa:	89 81       	ldd	r24, Y+1	; 0x01
    15ac:	9a 81       	ldd	r25, Y+2	; 0x02
    15ae:	0e 94 a9 16 	call	0x2d52	; 0x2d52 <vPortFree>
			pxNewTCB = NULL;
    15b2:	1a 82       	std	Y+2, r1	; 0x02
    15b4:	19 82       	std	Y+1, r1	; 0x01
    15b6:	0c c0       	rjmp	.+24     	; 0x15d0 <prvAllocateTCBAndStack+0x7c>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    15b8:	89 81       	ldd	r24, Y+1	; 0x01
    15ba:	9a 81       	ldd	r25, Y+2	; 0x02
    15bc:	fc 01       	movw	r30, r24
    15be:	87 89       	ldd	r24, Z+23	; 0x17
    15c0:	90 8d       	ldd	r25, Z+24	; 0x18
    15c2:	2b 81       	ldd	r18, Y+3	; 0x03
    15c4:	3c 81       	ldd	r19, Y+4	; 0x04
    15c6:	a9 01       	movw	r20, r18
    15c8:	65 ea       	ldi	r22, 0xA5	; 165
    15ca:	70 e0       	ldi	r23, 0x00	; 0
    15cc:	0e 94 f3 23 	call	0x47e6	; 0x47e6 <memset>
		}
	}

	return pxNewTCB;
    15d0:	89 81       	ldd	r24, Y+1	; 0x01
    15d2:	9a 81       	ldd	r25, Y+2	; 0x02
}
    15d4:	26 96       	adiw	r28, 0x06	; 6
    15d6:	0f b6       	in	r0, 0x3f	; 63
    15d8:	f8 94       	cli
    15da:	de bf       	out	0x3e, r29	; 62
    15dc:	0f be       	out	0x3f, r0	; 63
    15de:	cd bf       	out	0x3d, r28	; 61
    15e0:	df 91       	pop	r29
    15e2:	cf 91       	pop	r28
    15e4:	08 95       	ret

000015e6 <usTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
    15e6:	0f 93       	push	r16
    15e8:	1f 93       	push	r17
    15ea:	cf 93       	push	r28
    15ec:	df 93       	push	r29
    15ee:	1f 92       	push	r1
    15f0:	1f 92       	push	r1
    15f2:	cd b7       	in	r28, 0x3d	; 61
    15f4:	de b7       	in	r29, 0x3e	; 62
    15f6:	9a 83       	std	Y+2, r25	; 0x02
    15f8:	89 83       	std	Y+1, r24	; 0x01
	register unsigned short usCount = 0U;
    15fa:	00 e0       	ldi	r16, 0x00	; 0
    15fc:	10 e0       	ldi	r17, 0x00	; 0

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    15fe:	09 c0       	rjmp	.+18     	; 0x1612 <usTaskCheckFreeStackSpace+0x2c>
		{
			pucStackByte -= portSTACK_GROWTH;
    1600:	89 81       	ldd	r24, Y+1	; 0x01
    1602:	9a 81       	ldd	r25, Y+2	; 0x02
    1604:	01 96       	adiw	r24, 0x01	; 1
    1606:	9a 83       	std	Y+2, r25	; 0x02
    1608:	89 83       	std	Y+1, r24	; 0x01
			usCount++;
    160a:	c8 01       	movw	r24, r16
    160c:	8c 01       	movw	r16, r24
    160e:	0f 5f       	subi	r16, 0xFF	; 255
    1610:	1f 4f       	sbci	r17, 0xFF	; 255

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    1612:	89 81       	ldd	r24, Y+1	; 0x01
    1614:	9a 81       	ldd	r25, Y+2	; 0x02
    1616:	fc 01       	movw	r30, r24
    1618:	80 81       	ld	r24, Z
    161a:	85 3a       	cpi	r24, 0xA5	; 165
    161c:	89 f3       	breq	.-30     	; 0x1600 <usTaskCheckFreeStackSpace+0x1a>
			usCount++;
		}

		usCount /= sizeof( portSTACK_TYPE );

		return usCount;
    161e:	c8 01       	movw	r24, r16
	}
    1620:	0f 90       	pop	r0
    1622:	0f 90       	pop	r0
    1624:	df 91       	pop	r29
    1626:	cf 91       	pop	r28
    1628:	1f 91       	pop	r17
    162a:	0f 91       	pop	r16
    162c:	08 95       	ret

0000162e <uxTaskGetStackHighWaterMark>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
	{
    162e:	cf 93       	push	r28
    1630:	df 93       	push	r29
    1632:	cd b7       	in	r28, 0x3d	; 61
    1634:	de b7       	in	r29, 0x3e	; 62
    1636:	27 97       	sbiw	r28, 0x07	; 7
    1638:	0f b6       	in	r0, 0x3f	; 63
    163a:	f8 94       	cli
    163c:	de bf       	out	0x3e, r29	; 62
    163e:	0f be       	out	0x3f, r0	; 63
    1640:	cd bf       	out	0x3d, r28	; 61
    1642:	9f 83       	std	Y+7, r25	; 0x07
    1644:	8e 83       	std	Y+6, r24	; 0x06
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    1646:	8e 81       	ldd	r24, Y+6	; 0x06
    1648:	9f 81       	ldd	r25, Y+7	; 0x07
    164a:	00 97       	sbiw	r24, 0x00	; 0
    164c:	29 f4       	brne	.+10     	; 0x1658 <uxTaskGetStackHighWaterMark+0x2a>
    164e:	80 91 2e 02 	lds	r24, 0x022E
    1652:	90 91 2f 02 	lds	r25, 0x022F
    1656:	02 c0       	rjmp	.+4      	; 0x165c <uxTaskGetStackHighWaterMark+0x2e>
    1658:	8e 81       	ldd	r24, Y+6	; 0x06
    165a:	9f 81       	ldd	r25, Y+7	; 0x07
    165c:	9a 83       	std	Y+2, r25	; 0x02
    165e:	89 83       	std	Y+1, r24	; 0x01

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    1660:	89 81       	ldd	r24, Y+1	; 0x01
    1662:	9a 81       	ldd	r25, Y+2	; 0x02
    1664:	fc 01       	movw	r30, r24
    1666:	87 89       	ldd	r24, Z+23	; 0x17
    1668:	90 8d       	ldd	r25, Z+24	; 0x18
    166a:	9c 83       	std	Y+4, r25	; 0x04
    166c:	8b 83       	std	Y+3, r24	; 0x03
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
		}
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
    166e:	8b 81       	ldd	r24, Y+3	; 0x03
    1670:	9c 81       	ldd	r25, Y+4	; 0x04
    1672:	0e 94 f3 0a 	call	0x15e6	; 0x15e6 <usTaskCheckFreeStackSpace>
    1676:	8d 83       	std	Y+5, r24	; 0x05

		return uxReturn;
    1678:	8d 81       	ldd	r24, Y+5	; 0x05
	}
    167a:	27 96       	adiw	r28, 0x07	; 7
    167c:	0f b6       	in	r0, 0x3f	; 63
    167e:	f8 94       	cli
    1680:	de bf       	out	0x3e, r29	; 62
    1682:	0f be       	out	0x3f, r0	; 63
    1684:	cd bf       	out	0x3d, r28	; 61
    1686:	df 91       	pop	r29
    1688:	cf 91       	pop	r28
    168a:	08 95       	ret

0000168c <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	xTaskHandle xTaskGetCurrentTaskHandle( void )
	{
    168c:	cf 93       	push	r28
    168e:	df 93       	push	r29
    1690:	1f 92       	push	r1
    1692:	1f 92       	push	r1
    1694:	cd b7       	in	r28, 0x3d	; 61
    1696:	de b7       	in	r29, 0x3e	; 62
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    1698:	80 91 2e 02 	lds	r24, 0x022E
    169c:	90 91 2f 02 	lds	r25, 0x022F
    16a0:	9a 83       	std	Y+2, r25	; 0x02
    16a2:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    16a4:	89 81       	ldd	r24, Y+1	; 0x01
    16a6:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    16a8:	0f 90       	pop	r0
    16aa:	0f 90       	pop	r0
    16ac:	df 91       	pop	r29
    16ae:	cf 91       	pop	r28
    16b0:	08 95       	ret

000016b2 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    16b2:	cf 93       	push	r28
    16b4:	df 93       	push	r29
    16b6:	00 d0       	rcall	.+0      	; 0x16b8 <vTaskPriorityInherit+0x6>
    16b8:	1f 92       	push	r1
    16ba:	cd b7       	in	r28, 0x3d	; 61
    16bc:	de b7       	in	r29, 0x3e	; 62
    16be:	9c 83       	std	Y+4, r25	; 0x04
    16c0:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
    16c2:	8b 81       	ldd	r24, Y+3	; 0x03
    16c4:	9c 81       	ldd	r25, Y+4	; 0x04
    16c6:	9a 83       	std	Y+2, r25	; 0x02
    16c8:	89 83       	std	Y+1, r24	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    16ca:	8b 81       	ldd	r24, Y+3	; 0x03
    16cc:	9c 81       	ldd	r25, Y+4	; 0x04
    16ce:	00 97       	sbiw	r24, 0x00	; 0
    16d0:	09 f4       	brne	.+2      	; 0x16d4 <vTaskPriorityInherit+0x22>
    16d2:	78 c0       	rjmp	.+240    	; 0x17c4 <vTaskPriorityInherit+0x112>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    16d4:	89 81       	ldd	r24, Y+1	; 0x01
    16d6:	9a 81       	ldd	r25, Y+2	; 0x02
    16d8:	fc 01       	movw	r30, r24
    16da:	26 89       	ldd	r18, Z+22	; 0x16
    16dc:	80 91 2e 02 	lds	r24, 0x022E
    16e0:	90 91 2f 02 	lds	r25, 0x022F
    16e4:	fc 01       	movw	r30, r24
    16e6:	86 89       	ldd	r24, Z+22	; 0x16
    16e8:	28 17       	cp	r18, r24
    16ea:	08 f0       	brcs	.+2      	; 0x16ee <vTaskPriorityInherit+0x3c>
    16ec:	6b c0       	rjmp	.+214    	; 0x17c4 <vTaskPriorityInherit+0x112>
			{
				/* Adjust the mutex holder state to account for its new priority. */
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    16ee:	80 91 2e 02 	lds	r24, 0x022E
    16f2:	90 91 2f 02 	lds	r25, 0x022F
    16f6:	fc 01       	movw	r30, r24
    16f8:	86 89       	ldd	r24, Z+22	; 0x16
    16fa:	88 2f       	mov	r24, r24
    16fc:	90 e0       	ldi	r25, 0x00	; 0
    16fe:	24 e0       	ldi	r18, 0x04	; 4
    1700:	30 e0       	ldi	r19, 0x00	; 0
    1702:	28 1b       	sub	r18, r24
    1704:	39 0b       	sbc	r19, r25
    1706:	89 81       	ldd	r24, Y+1	; 0x01
    1708:	9a 81       	ldd	r25, Y+2	; 0x02
    170a:	fc 01       	movw	r30, r24
    170c:	35 87       	std	Z+13, r19	; 0x0d
    170e:	24 87       	std	Z+12, r18	; 0x0c

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    1710:	89 81       	ldd	r24, Y+1	; 0x01
    1712:	9a 81       	ldd	r25, Y+2	; 0x02
    1714:	fc 01       	movw	r30, r24
    1716:	42 85       	ldd	r20, Z+10	; 0x0a
    1718:	53 85       	ldd	r21, Z+11	; 0x0b
    171a:	89 81       	ldd	r24, Y+1	; 0x01
    171c:	9a 81       	ldd	r25, Y+2	; 0x02
    171e:	fc 01       	movw	r30, r24
    1720:	86 89       	ldd	r24, Z+22	; 0x16
    1722:	28 2f       	mov	r18, r24
    1724:	30 e0       	ldi	r19, 0x00	; 0
    1726:	c9 01       	movw	r24, r18
    1728:	88 0f       	add	r24, r24
    172a:	99 1f       	adc	r25, r25
    172c:	88 0f       	add	r24, r24
    172e:	99 1f       	adc	r25, r25
    1730:	88 0f       	add	r24, r24
    1732:	99 1f       	adc	r25, r25
    1734:	82 0f       	add	r24, r18
    1736:	93 1f       	adc	r25, r19
    1738:	80 5d       	subi	r24, 0xD0	; 208
    173a:	9d 4f       	sbci	r25, 0xFD	; 253
    173c:	48 17       	cp	r20, r24
    173e:	59 07       	cpc	r21, r25
    1740:	b9 f5       	brne	.+110    	; 0x17b0 <vTaskPriorityInherit+0xfe>
				{
					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    1742:	89 81       	ldd	r24, Y+1	; 0x01
    1744:	9a 81       	ldd	r25, Y+2	; 0x02
    1746:	02 96       	adiw	r24, 0x02	; 2
    1748:	0e 94 14 13 	call	0x2628	; 0x2628 <uxListRemove>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    174c:	80 91 2e 02 	lds	r24, 0x022E
    1750:	90 91 2f 02 	lds	r25, 0x022F
    1754:	fc 01       	movw	r30, r24
    1756:	26 89       	ldd	r18, Z+22	; 0x16
    1758:	89 81       	ldd	r24, Y+1	; 0x01
    175a:	9a 81       	ldd	r25, Y+2	; 0x02
    175c:	fc 01       	movw	r30, r24
    175e:	26 8b       	std	Z+22, r18	; 0x16
					prvAddTaskToReadyQueue( pxTCB );
    1760:	89 81       	ldd	r24, Y+1	; 0x01
    1762:	9a 81       	ldd	r25, Y+2	; 0x02
    1764:	fc 01       	movw	r30, r24
    1766:	96 89       	ldd	r25, Z+22	; 0x16
    1768:	80 91 80 02 	lds	r24, 0x0280
    176c:	89 17       	cp	r24, r25
    176e:	30 f4       	brcc	.+12     	; 0x177c <vTaskPriorityInherit+0xca>
    1770:	89 81       	ldd	r24, Y+1	; 0x01
    1772:	9a 81       	ldd	r25, Y+2	; 0x02
    1774:	fc 01       	movw	r30, r24
    1776:	86 89       	ldd	r24, Z+22	; 0x16
    1778:	80 93 80 02 	sts	0x0280, r24
    177c:	89 81       	ldd	r24, Y+1	; 0x01
    177e:	9a 81       	ldd	r25, Y+2	; 0x02
    1780:	ac 01       	movw	r20, r24
    1782:	4e 5f       	subi	r20, 0xFE	; 254
    1784:	5f 4f       	sbci	r21, 0xFF	; 255
    1786:	89 81       	ldd	r24, Y+1	; 0x01
    1788:	9a 81       	ldd	r25, Y+2	; 0x02
    178a:	fc 01       	movw	r30, r24
    178c:	86 89       	ldd	r24, Z+22	; 0x16
    178e:	28 2f       	mov	r18, r24
    1790:	30 e0       	ldi	r19, 0x00	; 0
    1792:	c9 01       	movw	r24, r18
    1794:	88 0f       	add	r24, r24
    1796:	99 1f       	adc	r25, r25
    1798:	88 0f       	add	r24, r24
    179a:	99 1f       	adc	r25, r25
    179c:	88 0f       	add	r24, r24
    179e:	99 1f       	adc	r25, r25
    17a0:	82 0f       	add	r24, r18
    17a2:	93 1f       	adc	r25, r19
    17a4:	80 5d       	subi	r24, 0xD0	; 208
    17a6:	9d 4f       	sbci	r25, 0xFD	; 253
    17a8:	ba 01       	movw	r22, r20
    17aa:	0e 94 44 12 	call	0x2488	; 0x2488 <vListInsertEnd>
    17ae:	0a c0       	rjmp	.+20     	; 0x17c4 <vTaskPriorityInherit+0x112>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    17b0:	80 91 2e 02 	lds	r24, 0x022E
    17b4:	90 91 2f 02 	lds	r25, 0x022F
    17b8:	fc 01       	movw	r30, r24
    17ba:	26 89       	ldd	r18, Z+22	; 0x16
    17bc:	89 81       	ldd	r24, Y+1	; 0x01
    17be:	9a 81       	ldd	r25, Y+2	; 0x02
    17c0:	fc 01       	movw	r30, r24
    17c2:	26 8b       	std	Z+22, r18	; 0x16
				}

				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
			}
		}
	}
    17c4:	0f 90       	pop	r0
    17c6:	0f 90       	pop	r0
    17c8:	0f 90       	pop	r0
    17ca:	0f 90       	pop	r0
    17cc:	df 91       	pop	r29
    17ce:	cf 91       	pop	r28
    17d0:	08 95       	ret

000017d2 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    17d2:	cf 93       	push	r28
    17d4:	df 93       	push	r29
    17d6:	00 d0       	rcall	.+0      	; 0x17d8 <vTaskPriorityDisinherit+0x6>
    17d8:	1f 92       	push	r1
    17da:	cd b7       	in	r28, 0x3d	; 61
    17dc:	de b7       	in	r29, 0x3e	; 62
    17de:	9c 83       	std	Y+4, r25	; 0x04
    17e0:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
    17e2:	8b 81       	ldd	r24, Y+3	; 0x03
    17e4:	9c 81       	ldd	r25, Y+4	; 0x04
    17e6:	9a 83       	std	Y+2, r25	; 0x02
    17e8:	89 83       	std	Y+1, r24	; 0x01

		if( pxMutexHolder != NULL )
    17ea:	8b 81       	ldd	r24, Y+3	; 0x03
    17ec:	9c 81       	ldd	r25, Y+4	; 0x04
    17ee:	00 97       	sbiw	r24, 0x00	; 0
    17f0:	09 f4       	brne	.+2      	; 0x17f4 <vTaskPriorityDisinherit+0x22>
    17f2:	4e c0       	rjmp	.+156    	; 0x1890 <vTaskPriorityDisinherit+0xbe>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    17f4:	89 81       	ldd	r24, Y+1	; 0x01
    17f6:	9a 81       	ldd	r25, Y+2	; 0x02
    17f8:	fc 01       	movw	r30, r24
    17fa:	26 89       	ldd	r18, Z+22	; 0x16
    17fc:	89 81       	ldd	r24, Y+1	; 0x01
    17fe:	9a 81       	ldd	r25, Y+2	; 0x02
    1800:	fc 01       	movw	r30, r24
    1802:	81 a5       	ldd	r24, Z+41	; 0x29
    1804:	28 17       	cp	r18, r24
    1806:	09 f4       	brne	.+2      	; 0x180a <vTaskPriorityDisinherit+0x38>
    1808:	43 c0       	rjmp	.+134    	; 0x1890 <vTaskPriorityDisinherit+0xbe>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    180a:	89 81       	ldd	r24, Y+1	; 0x01
    180c:	9a 81       	ldd	r25, Y+2	; 0x02
    180e:	02 96       	adiw	r24, 0x02	; 2
    1810:	0e 94 14 13 	call	0x2628	; 0x2628 <uxListRemove>
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    1814:	89 81       	ldd	r24, Y+1	; 0x01
    1816:	9a 81       	ldd	r25, Y+2	; 0x02
    1818:	fc 01       	movw	r30, r24
    181a:	21 a5       	ldd	r18, Z+41	; 0x29
    181c:	89 81       	ldd	r24, Y+1	; 0x01
    181e:	9a 81       	ldd	r25, Y+2	; 0x02
    1820:	fc 01       	movw	r30, r24
    1822:	26 8b       	std	Z+22, r18	; 0x16
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    1824:	89 81       	ldd	r24, Y+1	; 0x01
    1826:	9a 81       	ldd	r25, Y+2	; 0x02
    1828:	fc 01       	movw	r30, r24
    182a:	86 89       	ldd	r24, Z+22	; 0x16
    182c:	88 2f       	mov	r24, r24
    182e:	90 e0       	ldi	r25, 0x00	; 0
    1830:	24 e0       	ldi	r18, 0x04	; 4
    1832:	30 e0       	ldi	r19, 0x00	; 0
    1834:	28 1b       	sub	r18, r24
    1836:	39 0b       	sbc	r19, r25
    1838:	89 81       	ldd	r24, Y+1	; 0x01
    183a:	9a 81       	ldd	r25, Y+2	; 0x02
    183c:	fc 01       	movw	r30, r24
    183e:	35 87       	std	Z+13, r19	; 0x0d
    1840:	24 87       	std	Z+12, r18	; 0x0c
				prvAddTaskToReadyQueue( pxTCB );
    1842:	89 81       	ldd	r24, Y+1	; 0x01
    1844:	9a 81       	ldd	r25, Y+2	; 0x02
    1846:	fc 01       	movw	r30, r24
    1848:	96 89       	ldd	r25, Z+22	; 0x16
    184a:	80 91 80 02 	lds	r24, 0x0280
    184e:	89 17       	cp	r24, r25
    1850:	30 f4       	brcc	.+12     	; 0x185e <vTaskPriorityDisinherit+0x8c>
    1852:	89 81       	ldd	r24, Y+1	; 0x01
    1854:	9a 81       	ldd	r25, Y+2	; 0x02
    1856:	fc 01       	movw	r30, r24
    1858:	86 89       	ldd	r24, Z+22	; 0x16
    185a:	80 93 80 02 	sts	0x0280, r24
    185e:	89 81       	ldd	r24, Y+1	; 0x01
    1860:	9a 81       	ldd	r25, Y+2	; 0x02
    1862:	ac 01       	movw	r20, r24
    1864:	4e 5f       	subi	r20, 0xFE	; 254
    1866:	5f 4f       	sbci	r21, 0xFF	; 255
    1868:	89 81       	ldd	r24, Y+1	; 0x01
    186a:	9a 81       	ldd	r25, Y+2	; 0x02
    186c:	fc 01       	movw	r30, r24
    186e:	86 89       	ldd	r24, Z+22	; 0x16
    1870:	28 2f       	mov	r18, r24
    1872:	30 e0       	ldi	r19, 0x00	; 0
    1874:	c9 01       	movw	r24, r18
    1876:	88 0f       	add	r24, r24
    1878:	99 1f       	adc	r25, r25
    187a:	88 0f       	add	r24, r24
    187c:	99 1f       	adc	r25, r25
    187e:	88 0f       	add	r24, r24
    1880:	99 1f       	adc	r25, r25
    1882:	82 0f       	add	r24, r18
    1884:	93 1f       	adc	r25, r19
    1886:	80 5d       	subi	r24, 0xD0	; 208
    1888:	9d 4f       	sbci	r25, 0xFD	; 253
    188a:	ba 01       	movw	r22, r20
    188c:	0e 94 44 12 	call	0x2488	; 0x2488 <vListInsertEnd>
			}
		}
	}
    1890:	0f 90       	pop	r0
    1892:	0f 90       	pop	r0
    1894:	0f 90       	pop	r0
    1896:	0f 90       	pop	r0
    1898:	df 91       	pop	r29
    189a:	cf 91       	pop	r28
    189c:	08 95       	ret

0000189e <xQueueGenericReset>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle pxQueue, portBASE_TYPE xNewQueue )
{
    189e:	cf 93       	push	r28
    18a0:	df 93       	push	r29
    18a2:	00 d0       	rcall	.+0      	; 0x18a4 <xQueueGenericReset+0x6>
    18a4:	cd b7       	in	r28, 0x3d	; 61
    18a6:	de b7       	in	r29, 0x3e	; 62
    18a8:	9a 83       	std	Y+2, r25	; 0x02
    18aa:	89 83       	std	Y+1, r24	; 0x01
    18ac:	6b 83       	std	Y+3, r22	; 0x03
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    18ae:	0f b6       	in	r0, 0x3f	; 63
    18b0:	f8 94       	cli
    18b2:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    18b4:	89 81       	ldd	r24, Y+1	; 0x01
    18b6:	9a 81       	ldd	r25, Y+2	; 0x02
    18b8:	fc 01       	movw	r30, r24
    18ba:	20 81       	ld	r18, Z
    18bc:	31 81       	ldd	r19, Z+1	; 0x01
    18be:	89 81       	ldd	r24, Y+1	; 0x01
    18c0:	9a 81       	ldd	r25, Y+2	; 0x02
    18c2:	fc 01       	movw	r30, r24
    18c4:	83 8d       	ldd	r24, Z+27	; 0x1b
    18c6:	68 2f       	mov	r22, r24
    18c8:	70 e0       	ldi	r23, 0x00	; 0
    18ca:	89 81       	ldd	r24, Y+1	; 0x01
    18cc:	9a 81       	ldd	r25, Y+2	; 0x02
    18ce:	fc 01       	movw	r30, r24
    18d0:	84 8d       	ldd	r24, Z+28	; 0x1c
    18d2:	48 2f       	mov	r20, r24
    18d4:	50 e0       	ldi	r21, 0x00	; 0
    18d6:	64 9f       	mul	r22, r20
    18d8:	c0 01       	movw	r24, r0
    18da:	65 9f       	mul	r22, r21
    18dc:	90 0d       	add	r25, r0
    18de:	74 9f       	mul	r23, r20
    18e0:	90 0d       	add	r25, r0
    18e2:	11 24       	eor	r1, r1
    18e4:	28 0f       	add	r18, r24
    18e6:	39 1f       	adc	r19, r25
    18e8:	89 81       	ldd	r24, Y+1	; 0x01
    18ea:	9a 81       	ldd	r25, Y+2	; 0x02
    18ec:	fc 01       	movw	r30, r24
    18ee:	33 83       	std	Z+3, r19	; 0x03
    18f0:	22 83       	std	Z+2, r18	; 0x02
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    18f2:	89 81       	ldd	r24, Y+1	; 0x01
    18f4:	9a 81       	ldd	r25, Y+2	; 0x02
    18f6:	fc 01       	movw	r30, r24
    18f8:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    18fa:	89 81       	ldd	r24, Y+1	; 0x01
    18fc:	9a 81       	ldd	r25, Y+2	; 0x02
    18fe:	fc 01       	movw	r30, r24
    1900:	20 81       	ld	r18, Z
    1902:	31 81       	ldd	r19, Z+1	; 0x01
    1904:	89 81       	ldd	r24, Y+1	; 0x01
    1906:	9a 81       	ldd	r25, Y+2	; 0x02
    1908:	fc 01       	movw	r30, r24
    190a:	35 83       	std	Z+5, r19	; 0x05
    190c:	24 83       	std	Z+4, r18	; 0x04
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
    190e:	89 81       	ldd	r24, Y+1	; 0x01
    1910:	9a 81       	ldd	r25, Y+2	; 0x02
    1912:	fc 01       	movw	r30, r24
    1914:	20 81       	ld	r18, Z
    1916:	31 81       	ldd	r19, Z+1	; 0x01
    1918:	89 81       	ldd	r24, Y+1	; 0x01
    191a:	9a 81       	ldd	r25, Y+2	; 0x02
    191c:	fc 01       	movw	r30, r24
    191e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1920:	88 2f       	mov	r24, r24
    1922:	90 e0       	ldi	r25, 0x00	; 0
    1924:	bc 01       	movw	r22, r24
    1926:	61 50       	subi	r22, 0x01	; 1
    1928:	71 09       	sbc	r23, r1
    192a:	89 81       	ldd	r24, Y+1	; 0x01
    192c:	9a 81       	ldd	r25, Y+2	; 0x02
    192e:	fc 01       	movw	r30, r24
    1930:	84 8d       	ldd	r24, Z+28	; 0x1c
    1932:	48 2f       	mov	r20, r24
    1934:	50 e0       	ldi	r21, 0x00	; 0
    1936:	64 9f       	mul	r22, r20
    1938:	c0 01       	movw	r24, r0
    193a:	65 9f       	mul	r22, r21
    193c:	90 0d       	add	r25, r0
    193e:	74 9f       	mul	r23, r20
    1940:	90 0d       	add	r25, r0
    1942:	11 24       	eor	r1, r1
    1944:	28 0f       	add	r18, r24
    1946:	39 1f       	adc	r19, r25
    1948:	89 81       	ldd	r24, Y+1	; 0x01
    194a:	9a 81       	ldd	r25, Y+2	; 0x02
    194c:	fc 01       	movw	r30, r24
    194e:	37 83       	std	Z+7, r19	; 0x07
    1950:	26 83       	std	Z+6, r18	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    1952:	89 81       	ldd	r24, Y+1	; 0x01
    1954:	9a 81       	ldd	r25, Y+2	; 0x02
    1956:	2f ef       	ldi	r18, 0xFF	; 255
    1958:	fc 01       	movw	r30, r24
    195a:	25 8f       	std	Z+29, r18	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    195c:	89 81       	ldd	r24, Y+1	; 0x01
    195e:	9a 81       	ldd	r25, Y+2	; 0x02
    1960:	2f ef       	ldi	r18, 0xFF	; 255
    1962:	fc 01       	movw	r30, r24
    1964:	26 8f       	std	Z+30, r18	; 0x1e

		if( xNewQueue == pdFALSE )
    1966:	8b 81       	ldd	r24, Y+3	; 0x03
    1968:	88 23       	and	r24, r24
    196a:	81 f4       	brne	.+32     	; 0x198c <xQueueGenericReset+0xee>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to	write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    196c:	89 81       	ldd	r24, Y+1	; 0x01
    196e:	9a 81       	ldd	r25, Y+2	; 0x02
    1970:	fc 01       	movw	r30, r24
    1972:	80 85       	ldd	r24, Z+8	; 0x08
    1974:	88 23       	and	r24, r24
    1976:	a1 f0       	breq	.+40     	; 0x19a0 <xQueueGenericReset+0x102>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1978:	89 81       	ldd	r24, Y+1	; 0x01
    197a:	9a 81       	ldd	r25, Y+2	; 0x02
    197c:	08 96       	adiw	r24, 0x08	; 8
    197e:	0e 94 a9 08 	call	0x1152	; 0x1152 <xTaskRemoveFromEventList>
    1982:	81 30       	cpi	r24, 0x01	; 1
    1984:	69 f4       	brne	.+26     	; 0x19a0 <xQueueGenericReset+0x102>
				{
					portYIELD_WITHIN_API();
    1986:	0e 94 d6 18 	call	0x31ac	; 0x31ac <vPortYield>
    198a:	0a c0       	rjmp	.+20     	; 0x19a0 <xQueueGenericReset+0x102>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    198c:	89 81       	ldd	r24, Y+1	; 0x01
    198e:	9a 81       	ldd	r25, Y+2	; 0x02
    1990:	08 96       	adiw	r24, 0x08	; 8
    1992:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1996:	89 81       	ldd	r24, Y+1	; 0x01
    1998:	9a 81       	ldd	r25, Y+2	; 0x02
    199a:	41 96       	adiw	r24, 0x11	; 17
    199c:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    19a0:	0f 90       	pop	r0
    19a2:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    19a4:	81 e0       	ldi	r24, 0x01	; 1
}
    19a6:	0f 90       	pop	r0
    19a8:	0f 90       	pop	r0
    19aa:	0f 90       	pop	r0
    19ac:	df 91       	pop	r29
    19ae:	cf 91       	pop	r28
    19b0:	08 95       	ret

000019b2 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
    19b2:	cf 93       	push	r28
    19b4:	df 93       	push	r29
    19b6:	cd b7       	in	r28, 0x3d	; 61
    19b8:	de b7       	in	r29, 0x3e	; 62
    19ba:	29 97       	sbiw	r28, 0x09	; 9
    19bc:	0f b6       	in	r0, 0x3f	; 63
    19be:	f8 94       	cli
    19c0:	de bf       	out	0x3e, r29	; 62
    19c2:	0f be       	out	0x3f, r0	; 63
    19c4:	cd bf       	out	0x3d, r28	; 61
    19c6:	8f 83       	std	Y+7, r24	; 0x07
    19c8:	68 87       	std	Y+8, r22	; 0x08
    19ca:	49 87       	std	Y+9, r20	; 0x09
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    19cc:	1a 82       	std	Y+2, r1	; 0x02
    19ce:	19 82       	std	Y+1, r1	; 0x01
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    19d0:	8f 81       	ldd	r24, Y+7	; 0x07
    19d2:	88 23       	and	r24, r24
    19d4:	09 f4       	brne	.+2      	; 0x19d8 <xQueueGenericCreate+0x26>
    19d6:	43 c0       	rjmp	.+134    	; 0x1a5e <xQueueGenericCreate+0xac>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    19d8:	8f e1       	ldi	r24, 0x1F	; 31
    19da:	90 e0       	ldi	r25, 0x00	; 0
    19dc:	0e 94 63 16 	call	0x2cc6	; 0x2cc6 <pvPortMalloc>
    19e0:	9c 83       	std	Y+4, r25	; 0x04
    19e2:	8b 83       	std	Y+3, r24	; 0x03
		if( pxNewQueue != NULL )
    19e4:	8b 81       	ldd	r24, Y+3	; 0x03
    19e6:	9c 81       	ldd	r25, Y+4	; 0x04
    19e8:	00 97       	sbiw	r24, 0x00	; 0
    19ea:	c9 f1       	breq	.+114    	; 0x1a5e <xQueueGenericCreate+0xac>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    19ec:	8f 81       	ldd	r24, Y+7	; 0x07
    19ee:	48 2f       	mov	r20, r24
    19f0:	50 e0       	ldi	r21, 0x00	; 0
    19f2:	88 85       	ldd	r24, Y+8	; 0x08
    19f4:	28 2f       	mov	r18, r24
    19f6:	30 e0       	ldi	r19, 0x00	; 0
    19f8:	42 9f       	mul	r20, r18
    19fa:	c0 01       	movw	r24, r0
    19fc:	43 9f       	mul	r20, r19
    19fe:	90 0d       	add	r25, r0
    1a00:	52 9f       	mul	r21, r18
    1a02:	90 0d       	add	r25, r0
    1a04:	11 24       	eor	r1, r1
    1a06:	01 96       	adiw	r24, 0x01	; 1
    1a08:	9e 83       	std	Y+6, r25	; 0x06
    1a0a:	8d 83       	std	Y+5, r24	; 0x05

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    1a0c:	8d 81       	ldd	r24, Y+5	; 0x05
    1a0e:	9e 81       	ldd	r25, Y+6	; 0x06
    1a10:	0e 94 63 16 	call	0x2cc6	; 0x2cc6 <pvPortMalloc>
    1a14:	9c 01       	movw	r18, r24
    1a16:	8b 81       	ldd	r24, Y+3	; 0x03
    1a18:	9c 81       	ldd	r25, Y+4	; 0x04
    1a1a:	fc 01       	movw	r30, r24
    1a1c:	31 83       	std	Z+1, r19	; 0x01
    1a1e:	20 83       	st	Z, r18
			if( pxNewQueue->pcHead != NULL )
    1a20:	8b 81       	ldd	r24, Y+3	; 0x03
    1a22:	9c 81       	ldd	r25, Y+4	; 0x04
    1a24:	fc 01       	movw	r30, r24
    1a26:	80 81       	ld	r24, Z
    1a28:	91 81       	ldd	r25, Z+1	; 0x01
    1a2a:	00 97       	sbiw	r24, 0x00	; 0
    1a2c:	a1 f0       	breq	.+40     	; 0x1a56 <xQueueGenericCreate+0xa4>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    1a2e:	8b 81       	ldd	r24, Y+3	; 0x03
    1a30:	9c 81       	ldd	r25, Y+4	; 0x04
    1a32:	2f 81       	ldd	r18, Y+7	; 0x07
    1a34:	fc 01       	movw	r30, r24
    1a36:	23 8f       	std	Z+27, r18	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1a38:	8b 81       	ldd	r24, Y+3	; 0x03
    1a3a:	9c 81       	ldd	r25, Y+4	; 0x04
    1a3c:	28 85       	ldd	r18, Y+8	; 0x08
    1a3e:	fc 01       	movw	r30, r24
    1a40:	24 8f       	std	Z+28, r18	; 0x1c
				xQueueGenericReset( pxNewQueue, pdTRUE );
    1a42:	8b 81       	ldd	r24, Y+3	; 0x03
    1a44:	9c 81       	ldd	r25, Y+4	; 0x04
    1a46:	61 e0       	ldi	r22, 0x01	; 1
    1a48:	0e 94 4f 0c 	call	0x189e	; 0x189e <xQueueGenericReset>
					pxNewQueue->ucQueueType = ucQueueType;
				}
				#endif /* configUSE_TRACE_FACILITY */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    1a4c:	8b 81       	ldd	r24, Y+3	; 0x03
    1a4e:	9c 81       	ldd	r25, Y+4	; 0x04
    1a50:	9a 83       	std	Y+2, r25	; 0x02
    1a52:	89 83       	std	Y+1, r24	; 0x01
    1a54:	04 c0       	rjmp	.+8      	; 0x1a5e <xQueueGenericCreate+0xac>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    1a56:	8b 81       	ldd	r24, Y+3	; 0x03
    1a58:	9c 81       	ldd	r25, Y+4	; 0x04
    1a5a:	0e 94 a9 16 	call	0x2d52	; 0x2d52 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    1a5e:	89 81       	ldd	r24, Y+1	; 0x01
    1a60:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1a62:	29 96       	adiw	r28, 0x09	; 9
    1a64:	0f b6       	in	r0, 0x3f	; 63
    1a66:	f8 94       	cli
    1a68:	de bf       	out	0x3e, r29	; 62
    1a6a:	0f be       	out	0x3f, r0	; 63
    1a6c:	cd bf       	out	0x3d, r28	; 61
    1a6e:	df 91       	pop	r29
    1a70:	cf 91       	pop	r28
    1a72:	08 95       	ret

00001a74 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
	{
    1a74:	cf 93       	push	r28
    1a76:	df 93       	push	r29
    1a78:	00 d0       	rcall	.+0      	; 0x1a7a <xQueueCreateMutex+0x6>
    1a7a:	cd b7       	in	r28, 0x3d	; 61
    1a7c:	de b7       	in	r29, 0x3e	; 62
    1a7e:	8b 83       	std	Y+3, r24	; 0x03
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    1a80:	8f e1       	ldi	r24, 0x1F	; 31
    1a82:	90 e0       	ldi	r25, 0x00	; 0
    1a84:	0e 94 63 16 	call	0x2cc6	; 0x2cc6 <pvPortMalloc>
    1a88:	9a 83       	std	Y+2, r25	; 0x02
    1a8a:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    1a8c:	89 81       	ldd	r24, Y+1	; 0x01
    1a8e:	9a 81       	ldd	r25, Y+2	; 0x02
    1a90:	00 97       	sbiw	r24, 0x00	; 0
    1a92:	f1 f1       	breq	.+124    	; 0x1b10 <xQueueCreateMutex+0x9c>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    1a94:	89 81       	ldd	r24, Y+1	; 0x01
    1a96:	9a 81       	ldd	r25, Y+2	; 0x02
    1a98:	fc 01       	movw	r30, r24
    1a9a:	13 82       	std	Z+3, r1	; 0x03
    1a9c:	12 82       	std	Z+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    1a9e:	89 81       	ldd	r24, Y+1	; 0x01
    1aa0:	9a 81       	ldd	r25, Y+2	; 0x02
    1aa2:	fc 01       	movw	r30, r24
    1aa4:	11 82       	std	Z+1, r1	; 0x01
    1aa6:	10 82       	st	Z, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    1aa8:	89 81       	ldd	r24, Y+1	; 0x01
    1aaa:	9a 81       	ldd	r25, Y+2	; 0x02
    1aac:	fc 01       	movw	r30, r24
    1aae:	15 82       	std	Z+5, r1	; 0x05
    1ab0:	14 82       	std	Z+4, r1	; 0x04
			pxNewQueue->pcReadFrom = NULL;
    1ab2:	89 81       	ldd	r24, Y+1	; 0x01
    1ab4:	9a 81       	ldd	r25, Y+2	; 0x02
    1ab6:	fc 01       	movw	r30, r24
    1ab8:	17 82       	std	Z+7, r1	; 0x07
    1aba:	16 82       	std	Z+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1abc:	89 81       	ldd	r24, Y+1	; 0x01
    1abe:	9a 81       	ldd	r25, Y+2	; 0x02
    1ac0:	fc 01       	movw	r30, r24
    1ac2:	12 8e       	std	Z+26, r1	; 0x1a
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
    1ac4:	89 81       	ldd	r24, Y+1	; 0x01
    1ac6:	9a 81       	ldd	r25, Y+2	; 0x02
    1ac8:	21 e0       	ldi	r18, 0x01	; 1
    1aca:	fc 01       	movw	r30, r24
    1acc:	23 8f       	std	Z+27, r18	; 0x1b
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
    1ace:	89 81       	ldd	r24, Y+1	; 0x01
    1ad0:	9a 81       	ldd	r25, Y+2	; 0x02
    1ad2:	fc 01       	movw	r30, r24
    1ad4:	14 8e       	std	Z+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    1ad6:	89 81       	ldd	r24, Y+1	; 0x01
    1ad8:	9a 81       	ldd	r25, Y+2	; 0x02
    1ada:	2f ef       	ldi	r18, 0xFF	; 255
    1adc:	fc 01       	movw	r30, r24
    1ade:	25 8f       	std	Z+29, r18	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    1ae0:	89 81       	ldd	r24, Y+1	; 0x01
    1ae2:	9a 81       	ldd	r25, Y+2	; 0x02
    1ae4:	2f ef       	ldi	r18, 0xFF	; 255
    1ae6:	fc 01       	movw	r30, r24
    1ae8:	26 8f       	std	Z+30, r18	; 0x1e
				pxNewQueue->ucQueueType = ucQueueType;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1aea:	89 81       	ldd	r24, Y+1	; 0x01
    1aec:	9a 81       	ldd	r25, Y+2	; 0x02
    1aee:	08 96       	adiw	r24, 0x08	; 8
    1af0:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1af4:	89 81       	ldd	r24, Y+1	; 0x01
    1af6:	9a 81       	ldd	r25, Y+2	; 0x02
    1af8:	41 96       	adiw	r24, 0x11	; 17
    1afa:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
    1afe:	89 81       	ldd	r24, Y+1	; 0x01
    1b00:	9a 81       	ldd	r25, Y+2	; 0x02
    1b02:	20 e0       	ldi	r18, 0x00	; 0
    1b04:	40 e0       	ldi	r20, 0x00	; 0
    1b06:	50 e0       	ldi	r21, 0x00	; 0
    1b08:	60 e0       	ldi	r22, 0x00	; 0
    1b0a:	70 e0       	ldi	r23, 0x00	; 0
    1b0c:	0e 94 90 0d 	call	0x1b20	; 0x1b20 <xQueueGenericSend>
		{
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
    1b10:	89 81       	ldd	r24, Y+1	; 0x01
    1b12:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    1b14:	0f 90       	pop	r0
    1b16:	0f 90       	pop	r0
    1b18:	0f 90       	pop	r0
    1b1a:	df 91       	pop	r29
    1b1c:	cf 91       	pop	r28
    1b1e:	08 95       	ret

00001b20 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    1b20:	cf 93       	push	r28
    1b22:	df 93       	push	r29
    1b24:	cd b7       	in	r28, 0x3d	; 61
    1b26:	de b7       	in	r29, 0x3e	; 62
    1b28:	2b 97       	sbiw	r28, 0x0b	; 11
    1b2a:	0f b6       	in	r0, 0x3f	; 63
    1b2c:	f8 94       	cli
    1b2e:	de bf       	out	0x3e, r29	; 62
    1b30:	0f be       	out	0x3f, r0	; 63
    1b32:	cd bf       	out	0x3d, r28	; 61
    1b34:	9e 83       	std	Y+6, r25	; 0x06
    1b36:	8d 83       	std	Y+5, r24	; 0x05
    1b38:	78 87       	std	Y+8, r23	; 0x08
    1b3a:	6f 83       	std	Y+7, r22	; 0x07
    1b3c:	5a 87       	std	Y+10, r21	; 0x0a
    1b3e:	49 87       	std	Y+9, r20	; 0x09
    1b40:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1b42:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1b44:	0f b6       	in	r0, 0x3f	; 63
    1b46:	f8 94       	cli
    1b48:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1b4a:	8d 81       	ldd	r24, Y+5	; 0x05
    1b4c:	9e 81       	ldd	r25, Y+6	; 0x06
    1b4e:	fc 01       	movw	r30, r24
    1b50:	22 8d       	ldd	r18, Z+26	; 0x1a
    1b52:	8d 81       	ldd	r24, Y+5	; 0x05
    1b54:	9e 81       	ldd	r25, Y+6	; 0x06
    1b56:	fc 01       	movw	r30, r24
    1b58:	83 8d       	ldd	r24, Z+27	; 0x1b
    1b5a:	28 17       	cp	r18, r24
    1b5c:	d8 f4       	brcc	.+54     	; 0x1b94 <xQueueGenericSend+0x74>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1b5e:	2f 81       	ldd	r18, Y+7	; 0x07
    1b60:	38 85       	ldd	r19, Y+8	; 0x08
    1b62:	8d 81       	ldd	r24, Y+5	; 0x05
    1b64:	9e 81       	ldd	r25, Y+6	; 0x06
    1b66:	4b 85       	ldd	r20, Y+11	; 0x0b
    1b68:	b9 01       	movw	r22, r18
    1b6a:	0e 94 1a 10 	call	0x2034	; 0x2034 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b6e:	8d 81       	ldd	r24, Y+5	; 0x05
    1b70:	9e 81       	ldd	r25, Y+6	; 0x06
    1b72:	fc 01       	movw	r30, r24
    1b74:	81 89       	ldd	r24, Z+17	; 0x11
    1b76:	88 23       	and	r24, r24
    1b78:	49 f0       	breq	.+18     	; 0x1b8c <xQueueGenericSend+0x6c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1b7a:	8d 81       	ldd	r24, Y+5	; 0x05
    1b7c:	9e 81       	ldd	r25, Y+6	; 0x06
    1b7e:	41 96       	adiw	r24, 0x11	; 17
    1b80:	0e 94 a9 08 	call	0x1152	; 0x1152 <xTaskRemoveFromEventList>
    1b84:	81 30       	cpi	r24, 0x01	; 1
    1b86:	11 f4       	brne	.+4      	; 0x1b8c <xQueueGenericSend+0x6c>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    1b88:	0e 94 d6 18 	call	0x31ac	; 0x31ac <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    1b8c:	0f 90       	pop	r0
    1b8e:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    1b90:	81 e0       	ldi	r24, 0x01	; 1
    1b92:	61 c0       	rjmp	.+194    	; 0x1c56 <xQueueGenericSend+0x136>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1b94:	89 85       	ldd	r24, Y+9	; 0x09
    1b96:	9a 85       	ldd	r25, Y+10	; 0x0a
    1b98:	00 97       	sbiw	r24, 0x00	; 0
    1b9a:	21 f4       	brne	.+8      	; 0x1ba4 <xQueueGenericSend+0x84>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1b9c:	0f 90       	pop	r0
    1b9e:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1ba0:	80 e0       	ldi	r24, 0x00	; 0
    1ba2:	59 c0       	rjmp	.+178    	; 0x1c56 <xQueueGenericSend+0x136>
				}
				else if( xEntryTimeSet == pdFALSE )
    1ba4:	89 81       	ldd	r24, Y+1	; 0x01
    1ba6:	88 23       	and	r24, r24
    1ba8:	31 f4       	brne	.+12     	; 0x1bb6 <xQueueGenericSend+0x96>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1baa:	ce 01       	movw	r24, r28
    1bac:	02 96       	adiw	r24, 0x02	; 2
    1bae:	0e 94 13 09 	call	0x1226	; 0x1226 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1bb2:	81 e0       	ldi	r24, 0x01	; 1
    1bb4:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    1bb6:	0f 90       	pop	r0
    1bb8:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1bba:	0e 94 35 06 	call	0xc6a	; 0xc6a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1bbe:	0f b6       	in	r0, 0x3f	; 63
    1bc0:	f8 94       	cli
    1bc2:	0f 92       	push	r0
    1bc4:	8d 81       	ldd	r24, Y+5	; 0x05
    1bc6:	9e 81       	ldd	r25, Y+6	; 0x06
    1bc8:	fc 01       	movw	r30, r24
    1bca:	85 8d       	ldd	r24, Z+29	; 0x1d
    1bcc:	8f 3f       	cpi	r24, 0xFF	; 255
    1bce:	21 f4       	brne	.+8      	; 0x1bd8 <xQueueGenericSend+0xb8>
    1bd0:	8d 81       	ldd	r24, Y+5	; 0x05
    1bd2:	9e 81       	ldd	r25, Y+6	; 0x06
    1bd4:	fc 01       	movw	r30, r24
    1bd6:	15 8e       	std	Z+29, r1	; 0x1d
    1bd8:	8d 81       	ldd	r24, Y+5	; 0x05
    1bda:	9e 81       	ldd	r25, Y+6	; 0x06
    1bdc:	fc 01       	movw	r30, r24
    1bde:	86 8d       	ldd	r24, Z+30	; 0x1e
    1be0:	8f 3f       	cpi	r24, 0xFF	; 255
    1be2:	21 f4       	brne	.+8      	; 0x1bec <xQueueGenericSend+0xcc>
    1be4:	8d 81       	ldd	r24, Y+5	; 0x05
    1be6:	9e 81       	ldd	r25, Y+6	; 0x06
    1be8:	fc 01       	movw	r30, r24
    1bea:	16 8e       	std	Z+30, r1	; 0x1e
    1bec:	0f 90       	pop	r0
    1bee:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1bf0:	9e 01       	movw	r18, r28
    1bf2:	27 5f       	subi	r18, 0xF7	; 247
    1bf4:	3f 4f       	sbci	r19, 0xFF	; 255
    1bf6:	ce 01       	movw	r24, r28
    1bf8:	02 96       	adiw	r24, 0x02	; 2
    1bfa:	b9 01       	movw	r22, r18
    1bfc:	0e 94 2f 09 	call	0x125e	; 0x125e <xTaskCheckForTimeOut>
    1c00:	88 23       	and	r24, r24
    1c02:	01 f5       	brne	.+64     	; 0x1c44 <xQueueGenericSend+0x124>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1c04:	8d 81       	ldd	r24, Y+5	; 0x05
    1c06:	9e 81       	ldd	r25, Y+6	; 0x06
    1c08:	0e 94 c1 11 	call	0x2382	; 0x2382 <prvIsQueueFull>
    1c0c:	88 23       	and	r24, r24
    1c0e:	99 f0       	breq	.+38     	; 0x1c36 <xQueueGenericSend+0x116>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1c10:	29 85       	ldd	r18, Y+9	; 0x09
    1c12:	3a 85       	ldd	r19, Y+10	; 0x0a
    1c14:	8d 81       	ldd	r24, Y+5	; 0x05
    1c16:	9e 81       	ldd	r25, Y+6	; 0x06
    1c18:	08 96       	adiw	r24, 0x08	; 8
    1c1a:	b9 01       	movw	r22, r18
    1c1c:	0e 94 64 08 	call	0x10c8	; 0x10c8 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1c20:	8d 81       	ldd	r24, Y+5	; 0x05
    1c22:	9e 81       	ldd	r25, Y+6	; 0x06
    1c24:	0e 94 29 11 	call	0x2252	; 0x2252 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1c28:	0e 94 41 06 	call	0xc82	; 0xc82 <xTaskResumeAll>
    1c2c:	88 23       	and	r24, r24
    1c2e:	91 f4       	brne	.+36     	; 0x1c54 <xQueueGenericSend+0x134>
				{
					portYIELD_WITHIN_API();
    1c30:	0e 94 d6 18 	call	0x31ac	; 0x31ac <vPortYield>
    1c34:	0f c0       	rjmp	.+30     	; 0x1c54 <xQueueGenericSend+0x134>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1c36:	8d 81       	ldd	r24, Y+5	; 0x05
    1c38:	9e 81       	ldd	r25, Y+6	; 0x06
    1c3a:	0e 94 29 11 	call	0x2252	; 0x2252 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1c3e:	0e 94 41 06 	call	0xc82	; 0xc82 <xTaskResumeAll>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
    1c42:	80 cf       	rjmp	.-256    	; 0x1b44 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1c44:	8d 81       	ldd	r24, Y+5	; 0x05
    1c46:	9e 81       	ldd	r25, Y+6	; 0x06
    1c48:	0e 94 29 11 	call	0x2252	; 0x2252 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1c4c:	0e 94 41 06 	call	0xc82	; 0xc82 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1c50:	80 e0       	ldi	r24, 0x00	; 0
    1c52:	01 c0       	rjmp	.+2      	; 0x1c56 <xQueueGenericSend+0x136>
		}
	}
    1c54:	77 cf       	rjmp	.-274    	; 0x1b44 <xQueueGenericSend+0x24>
}
    1c56:	2b 96       	adiw	r28, 0x0b	; 11
    1c58:	0f b6       	in	r0, 0x3f	; 63
    1c5a:	f8 94       	cli
    1c5c:	de bf       	out	0x3e, r29	; 62
    1c5e:	0f be       	out	0x3f, r0	; 63
    1c60:	cd bf       	out	0x3d, r28	; 61
    1c62:	df 91       	pop	r29
    1c64:	cf 91       	pop	r28
    1c66:	08 95       	ret

00001c68 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1c68:	cf 93       	push	r28
    1c6a:	df 93       	push	r29
    1c6c:	cd b7       	in	r28, 0x3d	; 61
    1c6e:	de b7       	in	r29, 0x3e	; 62
    1c70:	29 97       	sbiw	r28, 0x09	; 9
    1c72:	0f b6       	in	r0, 0x3f	; 63
    1c74:	f8 94       	cli
    1c76:	de bf       	out	0x3e, r29	; 62
    1c78:	0f be       	out	0x3f, r0	; 63
    1c7a:	cd bf       	out	0x3d, r28	; 61
    1c7c:	9c 83       	std	Y+4, r25	; 0x04
    1c7e:	8b 83       	std	Y+3, r24	; 0x03
    1c80:	7e 83       	std	Y+6, r23	; 0x06
    1c82:	6d 83       	std	Y+5, r22	; 0x05
    1c84:	58 87       	std	Y+8, r21	; 0x08
    1c86:	4f 83       	std	Y+7, r20	; 0x07
    1c88:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1c8a:	1a 82       	std	Y+2, r1	; 0x02
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1c8c:	8b 81       	ldd	r24, Y+3	; 0x03
    1c8e:	9c 81       	ldd	r25, Y+4	; 0x04
    1c90:	fc 01       	movw	r30, r24
    1c92:	22 8d       	ldd	r18, Z+26	; 0x1a
    1c94:	8b 81       	ldd	r24, Y+3	; 0x03
    1c96:	9c 81       	ldd	r25, Y+4	; 0x04
    1c98:	fc 01       	movw	r30, r24
    1c9a:	83 8d       	ldd	r24, Z+27	; 0x1b
    1c9c:	28 17       	cp	r18, r24
    1c9e:	90 f5       	brcc	.+100    	; 0x1d04 <xQueueGenericSendFromISR+0x9c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1ca0:	2d 81       	ldd	r18, Y+5	; 0x05
    1ca2:	3e 81       	ldd	r19, Y+6	; 0x06
    1ca4:	8b 81       	ldd	r24, Y+3	; 0x03
    1ca6:	9c 81       	ldd	r25, Y+4	; 0x04
    1ca8:	49 85       	ldd	r20, Y+9	; 0x09
    1caa:	b9 01       	movw	r22, r18
    1cac:	0e 94 1a 10 	call	0x2034	; 0x2034 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1cb0:	8b 81       	ldd	r24, Y+3	; 0x03
    1cb2:	9c 81       	ldd	r25, Y+4	; 0x04
    1cb4:	fc 01       	movw	r30, r24
    1cb6:	86 8d       	ldd	r24, Z+30	; 0x1e
    1cb8:	8f 3f       	cpi	r24, 0xFF	; 255
    1cba:	b9 f4       	brne	.+46     	; 0x1cea <xQueueGenericSendFromISR+0x82>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1cbc:	8b 81       	ldd	r24, Y+3	; 0x03
    1cbe:	9c 81       	ldd	r25, Y+4	; 0x04
    1cc0:	fc 01       	movw	r30, r24
    1cc2:	81 89       	ldd	r24, Z+17	; 0x11
    1cc4:	88 23       	and	r24, r24
    1cc6:	d9 f0       	breq	.+54     	; 0x1cfe <xQueueGenericSendFromISR+0x96>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1cc8:	8b 81       	ldd	r24, Y+3	; 0x03
    1cca:	9c 81       	ldd	r25, Y+4	; 0x04
    1ccc:	41 96       	adiw	r24, 0x11	; 17
    1cce:	0e 94 a9 08 	call	0x1152	; 0x1152 <xTaskRemoveFromEventList>
    1cd2:	88 23       	and	r24, r24
    1cd4:	a1 f0       	breq	.+40     	; 0x1cfe <xQueueGenericSendFromISR+0x96>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						if( pxHigherPriorityTaskWoken != NULL )
    1cd6:	8f 81       	ldd	r24, Y+7	; 0x07
    1cd8:	98 85       	ldd	r25, Y+8	; 0x08
    1cda:	00 97       	sbiw	r24, 0x00	; 0
    1cdc:	81 f0       	breq	.+32     	; 0x1cfe <xQueueGenericSendFromISR+0x96>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1cde:	8f 81       	ldd	r24, Y+7	; 0x07
    1ce0:	98 85       	ldd	r25, Y+8	; 0x08
    1ce2:	21 e0       	ldi	r18, 0x01	; 1
    1ce4:	fc 01       	movw	r30, r24
    1ce6:	20 83       	st	Z, r18
    1ce8:	0a c0       	rjmp	.+20     	; 0x1cfe <xQueueGenericSendFromISR+0x96>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1cea:	8b 81       	ldd	r24, Y+3	; 0x03
    1cec:	9c 81       	ldd	r25, Y+4	; 0x04
    1cee:	fc 01       	movw	r30, r24
    1cf0:	86 8d       	ldd	r24, Z+30	; 0x1e
    1cf2:	21 e0       	ldi	r18, 0x01	; 1
    1cf4:	28 0f       	add	r18, r24
    1cf6:	8b 81       	ldd	r24, Y+3	; 0x03
    1cf8:	9c 81       	ldd	r25, Y+4	; 0x04
    1cfa:	fc 01       	movw	r30, r24
    1cfc:	26 8f       	std	Z+30, r18	; 0x1e
			}

			xReturn = pdPASS;
    1cfe:	81 e0       	ldi	r24, 0x01	; 1
    1d00:	89 83       	std	Y+1, r24	; 0x01
    1d02:	01 c0       	rjmp	.+2      	; 0x1d06 <xQueueGenericSendFromISR+0x9e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1d04:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1d06:	89 81       	ldd	r24, Y+1	; 0x01
}
    1d08:	29 96       	adiw	r28, 0x09	; 9
    1d0a:	0f b6       	in	r0, 0x3f	; 63
    1d0c:	f8 94       	cli
    1d0e:	de bf       	out	0x3e, r29	; 62
    1d10:	0f be       	out	0x3f, r0	; 63
    1d12:	cd bf       	out	0x3d, r28	; 61
    1d14:	df 91       	pop	r29
    1d16:	cf 91       	pop	r28
    1d18:	08 95       	ret

00001d1a <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1d1a:	cf 93       	push	r28
    1d1c:	df 93       	push	r29
    1d1e:	cd b7       	in	r28, 0x3d	; 61
    1d20:	de b7       	in	r29, 0x3e	; 62
    1d22:	2d 97       	sbiw	r28, 0x0d	; 13
    1d24:	0f b6       	in	r0, 0x3f	; 63
    1d26:	f8 94       	cli
    1d28:	de bf       	out	0x3e, r29	; 62
    1d2a:	0f be       	out	0x3f, r0	; 63
    1d2c:	cd bf       	out	0x3d, r28	; 61
    1d2e:	98 87       	std	Y+8, r25	; 0x08
    1d30:	8f 83       	std	Y+7, r24	; 0x07
    1d32:	7a 87       	std	Y+10, r23	; 0x0a
    1d34:	69 87       	std	Y+9, r22	; 0x09
    1d36:	5c 87       	std	Y+12, r21	; 0x0c
    1d38:	4b 87       	std	Y+11, r20	; 0x0b
    1d3a:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1d3c:	19 82       	std	Y+1, r1	; 0x01
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1d3e:	0f b6       	in	r0, 0x3f	; 63
    1d40:	f8 94       	cli
    1d42:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1d44:	8f 81       	ldd	r24, Y+7	; 0x07
    1d46:	98 85       	ldd	r25, Y+8	; 0x08
    1d48:	fc 01       	movw	r30, r24
    1d4a:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d4c:	88 23       	and	r24, r24
    1d4e:	09 f4       	brne	.+2      	; 0x1d52 <xQueueGenericReceive+0x38>
    1d50:	54 c0       	rjmp	.+168    	; 0x1dfa <xQueueGenericReceive+0xe0>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1d52:	8f 81       	ldd	r24, Y+7	; 0x07
    1d54:	98 85       	ldd	r25, Y+8	; 0x08
    1d56:	fc 01       	movw	r30, r24
    1d58:	86 81       	ldd	r24, Z+6	; 0x06
    1d5a:	97 81       	ldd	r25, Z+7	; 0x07
    1d5c:	9b 83       	std	Y+3, r25	; 0x03
    1d5e:	8a 83       	std	Y+2, r24	; 0x02

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1d60:	29 85       	ldd	r18, Y+9	; 0x09
    1d62:	3a 85       	ldd	r19, Y+10	; 0x0a
    1d64:	8f 81       	ldd	r24, Y+7	; 0x07
    1d66:	98 85       	ldd	r25, Y+8	; 0x08
    1d68:	b9 01       	movw	r22, r18
    1d6a:	0e 94 d8 10 	call	0x21b0	; 0x21b0 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1d6e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1d70:	88 23       	and	r24, r24
    1d72:	49 f5       	brne	.+82     	; 0x1dc6 <xQueueGenericReceive+0xac>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1d74:	8f 81       	ldd	r24, Y+7	; 0x07
    1d76:	98 85       	ldd	r25, Y+8	; 0x08
    1d78:	fc 01       	movw	r30, r24
    1d7a:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d7c:	2f ef       	ldi	r18, 0xFF	; 255
    1d7e:	28 0f       	add	r18, r24
    1d80:	8f 81       	ldd	r24, Y+7	; 0x07
    1d82:	98 85       	ldd	r25, Y+8	; 0x08
    1d84:	fc 01       	movw	r30, r24
    1d86:	22 8f       	std	Z+26, r18	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1d88:	8f 81       	ldd	r24, Y+7	; 0x07
    1d8a:	98 85       	ldd	r25, Y+8	; 0x08
    1d8c:	fc 01       	movw	r30, r24
    1d8e:	80 81       	ld	r24, Z
    1d90:	91 81       	ldd	r25, Z+1	; 0x01
    1d92:	00 97       	sbiw	r24, 0x00	; 0
    1d94:	41 f4       	brne	.+16     	; 0x1da6 <xQueueGenericReceive+0x8c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    1d96:	0e 94 46 0b 	call	0x168c	; 0x168c <xTaskGetCurrentTaskHandle>
    1d9a:	9c 01       	movw	r18, r24
    1d9c:	8f 81       	ldd	r24, Y+7	; 0x07
    1d9e:	98 85       	ldd	r25, Y+8	; 0x08
    1da0:	fc 01       	movw	r30, r24
    1da2:	33 83       	std	Z+3, r19	; 0x03
    1da4:	22 83       	std	Z+2, r18	; 0x02
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1da6:	8f 81       	ldd	r24, Y+7	; 0x07
    1da8:	98 85       	ldd	r25, Y+8	; 0x08
    1daa:	fc 01       	movw	r30, r24
    1dac:	80 85       	ldd	r24, Z+8	; 0x08
    1dae:	88 23       	and	r24, r24
    1db0:	01 f1       	breq	.+64     	; 0x1df2 <xQueueGenericReceive+0xd8>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1db2:	8f 81       	ldd	r24, Y+7	; 0x07
    1db4:	98 85       	ldd	r25, Y+8	; 0x08
    1db6:	08 96       	adiw	r24, 0x08	; 8
    1db8:	0e 94 a9 08 	call	0x1152	; 0x1152 <xTaskRemoveFromEventList>
    1dbc:	81 30       	cpi	r24, 0x01	; 1
    1dbe:	c9 f4       	brne	.+50     	; 0x1df2 <xQueueGenericReceive+0xd8>
						{
							portYIELD_WITHIN_API();
    1dc0:	0e 94 d6 18 	call	0x31ac	; 0x31ac <vPortYield>
    1dc4:	16 c0       	rjmp	.+44     	; 0x1df2 <xQueueGenericReceive+0xd8>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1dc6:	8f 81       	ldd	r24, Y+7	; 0x07
    1dc8:	98 85       	ldd	r25, Y+8	; 0x08
    1dca:	2a 81       	ldd	r18, Y+2	; 0x02
    1dcc:	3b 81       	ldd	r19, Y+3	; 0x03
    1dce:	fc 01       	movw	r30, r24
    1dd0:	37 83       	std	Z+7, r19	; 0x07
    1dd2:	26 83       	std	Z+6, r18	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1dd4:	8f 81       	ldd	r24, Y+7	; 0x07
    1dd6:	98 85       	ldd	r25, Y+8	; 0x08
    1dd8:	fc 01       	movw	r30, r24
    1dda:	81 89       	ldd	r24, Z+17	; 0x11
    1ddc:	88 23       	and	r24, r24
    1dde:	49 f0       	breq	.+18     	; 0x1df2 <xQueueGenericReceive+0xd8>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1de0:	8f 81       	ldd	r24, Y+7	; 0x07
    1de2:	98 85       	ldd	r25, Y+8	; 0x08
    1de4:	41 96       	adiw	r24, 0x11	; 17
    1de6:	0e 94 a9 08 	call	0x1152	; 0x1152 <xTaskRemoveFromEventList>
    1dea:	88 23       	and	r24, r24
    1dec:	11 f0       	breq	.+4      	; 0x1df2 <xQueueGenericReceive+0xd8>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1dee:	0e 94 d6 18 	call	0x31ac	; 0x31ac <vPortYield>
						}
					}
				}

				taskEXIT_CRITICAL();
    1df2:	0f 90       	pop	r0
    1df4:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1df6:	81 e0       	ldi	r24, 0x01	; 1
    1df8:	74 c0       	rjmp	.+232    	; 0x1ee2 <xQueueGenericReceive+0x1c8>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1dfa:	8b 85       	ldd	r24, Y+11	; 0x0b
    1dfc:	9c 85       	ldd	r25, Y+12	; 0x0c
    1dfe:	00 97       	sbiw	r24, 0x00	; 0
    1e00:	21 f4       	brne	.+8      	; 0x1e0a <xQueueGenericReceive+0xf0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1e02:	0f 90       	pop	r0
    1e04:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1e06:	80 e0       	ldi	r24, 0x00	; 0
    1e08:	6c c0       	rjmp	.+216    	; 0x1ee2 <xQueueGenericReceive+0x1c8>
				}
				else if( xEntryTimeSet == pdFALSE )
    1e0a:	89 81       	ldd	r24, Y+1	; 0x01
    1e0c:	88 23       	and	r24, r24
    1e0e:	31 f4       	brne	.+12     	; 0x1e1c <xQueueGenericReceive+0x102>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1e10:	ce 01       	movw	r24, r28
    1e12:	04 96       	adiw	r24, 0x04	; 4
    1e14:	0e 94 13 09 	call	0x1226	; 0x1226 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1e18:	81 e0       	ldi	r24, 0x01	; 1
    1e1a:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    1e1c:	0f 90       	pop	r0
    1e1e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1e20:	0e 94 35 06 	call	0xc6a	; 0xc6a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1e24:	0f b6       	in	r0, 0x3f	; 63
    1e26:	f8 94       	cli
    1e28:	0f 92       	push	r0
    1e2a:	8f 81       	ldd	r24, Y+7	; 0x07
    1e2c:	98 85       	ldd	r25, Y+8	; 0x08
    1e2e:	fc 01       	movw	r30, r24
    1e30:	85 8d       	ldd	r24, Z+29	; 0x1d
    1e32:	8f 3f       	cpi	r24, 0xFF	; 255
    1e34:	21 f4       	brne	.+8      	; 0x1e3e <xQueueGenericReceive+0x124>
    1e36:	8f 81       	ldd	r24, Y+7	; 0x07
    1e38:	98 85       	ldd	r25, Y+8	; 0x08
    1e3a:	fc 01       	movw	r30, r24
    1e3c:	15 8e       	std	Z+29, r1	; 0x1d
    1e3e:	8f 81       	ldd	r24, Y+7	; 0x07
    1e40:	98 85       	ldd	r25, Y+8	; 0x08
    1e42:	fc 01       	movw	r30, r24
    1e44:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e46:	8f 3f       	cpi	r24, 0xFF	; 255
    1e48:	21 f4       	brne	.+8      	; 0x1e52 <xQueueGenericReceive+0x138>
    1e4a:	8f 81       	ldd	r24, Y+7	; 0x07
    1e4c:	98 85       	ldd	r25, Y+8	; 0x08
    1e4e:	fc 01       	movw	r30, r24
    1e50:	16 8e       	std	Z+30, r1	; 0x1e
    1e52:	0f 90       	pop	r0
    1e54:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1e56:	9e 01       	movw	r18, r28
    1e58:	25 5f       	subi	r18, 0xF5	; 245
    1e5a:	3f 4f       	sbci	r19, 0xFF	; 255
    1e5c:	ce 01       	movw	r24, r28
    1e5e:	04 96       	adiw	r24, 0x04	; 4
    1e60:	b9 01       	movw	r22, r18
    1e62:	0e 94 2f 09 	call	0x125e	; 0x125e <xTaskCheckForTimeOut>
    1e66:	88 23       	and	r24, r24
    1e68:	99 f5       	brne	.+102    	; 0x1ed0 <xQueueGenericReceive+0x1b6>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1e6a:	8f 81       	ldd	r24, Y+7	; 0x07
    1e6c:	98 85       	ldd	r25, Y+8	; 0x08
    1e6e:	0e 94 8e 11 	call	0x231c	; 0x231c <prvIsQueueEmpty>
    1e72:	88 23       	and	r24, r24
    1e74:	31 f1       	breq	.+76     	; 0x1ec2 <xQueueGenericReceive+0x1a8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1e76:	8f 81       	ldd	r24, Y+7	; 0x07
    1e78:	98 85       	ldd	r25, Y+8	; 0x08
    1e7a:	fc 01       	movw	r30, r24
    1e7c:	80 81       	ld	r24, Z
    1e7e:	91 81       	ldd	r25, Z+1	; 0x01
    1e80:	00 97       	sbiw	r24, 0x00	; 0
    1e82:	61 f4       	brne	.+24     	; 0x1e9c <xQueueGenericReceive+0x182>
					{
						portENTER_CRITICAL();
    1e84:	0f b6       	in	r0, 0x3f	; 63
    1e86:	f8 94       	cli
    1e88:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1e8a:	8f 81       	ldd	r24, Y+7	; 0x07
    1e8c:	98 85       	ldd	r25, Y+8	; 0x08
    1e8e:	fc 01       	movw	r30, r24
    1e90:	82 81       	ldd	r24, Z+2	; 0x02
    1e92:	93 81       	ldd	r25, Z+3	; 0x03
    1e94:	0e 94 59 0b 	call	0x16b2	; 0x16b2 <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    1e98:	0f 90       	pop	r0
    1e9a:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1e9c:	2b 85       	ldd	r18, Y+11	; 0x0b
    1e9e:	3c 85       	ldd	r19, Y+12	; 0x0c
    1ea0:	8f 81       	ldd	r24, Y+7	; 0x07
    1ea2:	98 85       	ldd	r25, Y+8	; 0x08
    1ea4:	41 96       	adiw	r24, 0x11	; 17
    1ea6:	b9 01       	movw	r22, r18
    1ea8:	0e 94 64 08 	call	0x10c8	; 0x10c8 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1eac:	8f 81       	ldd	r24, Y+7	; 0x07
    1eae:	98 85       	ldd	r25, Y+8	; 0x08
    1eb0:	0e 94 29 11 	call	0x2252	; 0x2252 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1eb4:	0e 94 41 06 	call	0xc82	; 0xc82 <xTaskResumeAll>
    1eb8:	88 23       	and	r24, r24
    1eba:	91 f4       	brne	.+36     	; 0x1ee0 <xQueueGenericReceive+0x1c6>
				{
					portYIELD_WITHIN_API();
    1ebc:	0e 94 d6 18 	call	0x31ac	; 0x31ac <vPortYield>
    1ec0:	0f c0       	rjmp	.+30     	; 0x1ee0 <xQueueGenericReceive+0x1c6>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1ec2:	8f 81       	ldd	r24, Y+7	; 0x07
    1ec4:	98 85       	ldd	r25, Y+8	; 0x08
    1ec6:	0e 94 29 11 	call	0x2252	; 0x2252 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1eca:	0e 94 41 06 	call	0xc82	; 0xc82 <xTaskResumeAll>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
    1ece:	37 cf       	rjmp	.-402    	; 0x1d3e <xQueueGenericReceive+0x24>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1ed0:	8f 81       	ldd	r24, Y+7	; 0x07
    1ed2:	98 85       	ldd	r25, Y+8	; 0x08
    1ed4:	0e 94 29 11 	call	0x2252	; 0x2252 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1ed8:	0e 94 41 06 	call	0xc82	; 0xc82 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1edc:	80 e0       	ldi	r24, 0x00	; 0
    1ede:	01 c0       	rjmp	.+2      	; 0x1ee2 <xQueueGenericReceive+0x1c8>
		}
	}
    1ee0:	2e cf       	rjmp	.-420    	; 0x1d3e <xQueueGenericReceive+0x24>
}
    1ee2:	2d 96       	adiw	r28, 0x0d	; 13
    1ee4:	0f b6       	in	r0, 0x3f	; 63
    1ee6:	f8 94       	cli
    1ee8:	de bf       	out	0x3e, r29	; 62
    1eea:	0f be       	out	0x3f, r0	; 63
    1eec:	cd bf       	out	0x3d, r28	; 61
    1eee:	df 91       	pop	r29
    1ef0:	cf 91       	pop	r28
    1ef2:	08 95       	ret

00001ef4 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
{
    1ef4:	cf 93       	push	r28
    1ef6:	df 93       	push	r29
    1ef8:	cd b7       	in	r28, 0x3d	; 61
    1efa:	de b7       	in	r29, 0x3e	; 62
    1efc:	28 97       	sbiw	r28, 0x08	; 8
    1efe:	0f b6       	in	r0, 0x3f	; 63
    1f00:	f8 94       	cli
    1f02:	de bf       	out	0x3e, r29	; 62
    1f04:	0f be       	out	0x3f, r0	; 63
    1f06:	cd bf       	out	0x3d, r28	; 61
    1f08:	9c 83       	std	Y+4, r25	; 0x04
    1f0a:	8b 83       	std	Y+3, r24	; 0x03
    1f0c:	7e 83       	std	Y+6, r23	; 0x06
    1f0e:	6d 83       	std	Y+5, r22	; 0x05
    1f10:	58 87       	std	Y+8, r21	; 0x08
    1f12:	4f 83       	std	Y+7, r20	; 0x07
unsigned portBASE_TYPE uxSavedInterruptStatus;

	configASSERT( pxQueue );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1f14:	1a 82       	std	Y+2, r1	; 0x02
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1f16:	8b 81       	ldd	r24, Y+3	; 0x03
    1f18:	9c 81       	ldd	r25, Y+4	; 0x04
    1f1a:	fc 01       	movw	r30, r24
    1f1c:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f1e:	88 23       	and	r24, r24
    1f20:	d9 f1       	breq	.+118    	; 0x1f98 <xQueueReceiveFromISR+0xa4>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1f22:	2d 81       	ldd	r18, Y+5	; 0x05
    1f24:	3e 81       	ldd	r19, Y+6	; 0x06
    1f26:	8b 81       	ldd	r24, Y+3	; 0x03
    1f28:	9c 81       	ldd	r25, Y+4	; 0x04
    1f2a:	b9 01       	movw	r22, r18
    1f2c:	0e 94 d8 10 	call	0x21b0	; 0x21b0 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1f30:	8b 81       	ldd	r24, Y+3	; 0x03
    1f32:	9c 81       	ldd	r25, Y+4	; 0x04
    1f34:	fc 01       	movw	r30, r24
    1f36:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f38:	2f ef       	ldi	r18, 0xFF	; 255
    1f3a:	28 0f       	add	r18, r24
    1f3c:	8b 81       	ldd	r24, Y+3	; 0x03
    1f3e:	9c 81       	ldd	r25, Y+4	; 0x04
    1f40:	fc 01       	movw	r30, r24
    1f42:	22 8f       	std	Z+26, r18	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1f44:	8b 81       	ldd	r24, Y+3	; 0x03
    1f46:	9c 81       	ldd	r25, Y+4	; 0x04
    1f48:	fc 01       	movw	r30, r24
    1f4a:	85 8d       	ldd	r24, Z+29	; 0x1d
    1f4c:	8f 3f       	cpi	r24, 0xFF	; 255
    1f4e:	b9 f4       	brne	.+46     	; 0x1f7e <xQueueReceiveFromISR+0x8a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1f50:	8b 81       	ldd	r24, Y+3	; 0x03
    1f52:	9c 81       	ldd	r25, Y+4	; 0x04
    1f54:	fc 01       	movw	r30, r24
    1f56:	80 85       	ldd	r24, Z+8	; 0x08
    1f58:	88 23       	and	r24, r24
    1f5a:	d9 f0       	breq	.+54     	; 0x1f92 <xQueueReceiveFromISR+0x9e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1f5c:	8b 81       	ldd	r24, Y+3	; 0x03
    1f5e:	9c 81       	ldd	r25, Y+4	; 0x04
    1f60:	08 96       	adiw	r24, 0x08	; 8
    1f62:	0e 94 a9 08 	call	0x1152	; 0x1152 <xTaskRemoveFromEventList>
    1f66:	88 23       	and	r24, r24
    1f68:	a1 f0       	breq	.+40     	; 0x1f92 <xQueueReceiveFromISR+0x9e>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1f6a:	8f 81       	ldd	r24, Y+7	; 0x07
    1f6c:	98 85       	ldd	r25, Y+8	; 0x08
    1f6e:	00 97       	sbiw	r24, 0x00	; 0
    1f70:	81 f0       	breq	.+32     	; 0x1f92 <xQueueReceiveFromISR+0x9e>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1f72:	8f 81       	ldd	r24, Y+7	; 0x07
    1f74:	98 85       	ldd	r25, Y+8	; 0x08
    1f76:	21 e0       	ldi	r18, 0x01	; 1
    1f78:	fc 01       	movw	r30, r24
    1f7a:	20 83       	st	Z, r18
    1f7c:	0a c0       	rjmp	.+20     	; 0x1f92 <xQueueReceiveFromISR+0x9e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1f7e:	8b 81       	ldd	r24, Y+3	; 0x03
    1f80:	9c 81       	ldd	r25, Y+4	; 0x04
    1f82:	fc 01       	movw	r30, r24
    1f84:	85 8d       	ldd	r24, Z+29	; 0x1d
    1f86:	21 e0       	ldi	r18, 0x01	; 1
    1f88:	28 0f       	add	r18, r24
    1f8a:	8b 81       	ldd	r24, Y+3	; 0x03
    1f8c:	9c 81       	ldd	r25, Y+4	; 0x04
    1f8e:	fc 01       	movw	r30, r24
    1f90:	25 8f       	std	Z+29, r18	; 0x1d
			}

			xReturn = pdPASS;
    1f92:	81 e0       	ldi	r24, 0x01	; 1
    1f94:	89 83       	std	Y+1, r24	; 0x01
    1f96:	01 c0       	rjmp	.+2      	; 0x1f9a <xQueueReceiveFromISR+0xa6>
		}
		else
		{
			xReturn = pdFAIL;
    1f98:	19 82       	std	Y+1, r1	; 0x01
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1f9a:	89 81       	ldd	r24, Y+1	; 0x01
}
    1f9c:	28 96       	adiw	r28, 0x08	; 8
    1f9e:	0f b6       	in	r0, 0x3f	; 63
    1fa0:	f8 94       	cli
    1fa2:	de bf       	out	0x3e, r29	; 62
    1fa4:	0f be       	out	0x3f, r0	; 63
    1fa6:	cd bf       	out	0x3d, r28	; 61
    1fa8:	df 91       	pop	r29
    1faa:	cf 91       	pop	r28
    1fac:	08 95       	ret

00001fae <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    1fae:	cf 93       	push	r28
    1fb0:	df 93       	push	r29
    1fb2:	00 d0       	rcall	.+0      	; 0x1fb4 <uxQueueMessagesWaiting+0x6>
    1fb4:	cd b7       	in	r28, 0x3d	; 61
    1fb6:	de b7       	in	r29, 0x3e	; 62
    1fb8:	9b 83       	std	Y+3, r25	; 0x03
    1fba:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1fbc:	0f b6       	in	r0, 0x3f	; 63
    1fbe:	f8 94       	cli
    1fc0:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1fc2:	8a 81       	ldd	r24, Y+2	; 0x02
    1fc4:	9b 81       	ldd	r25, Y+3	; 0x03
    1fc6:	fc 01       	movw	r30, r24
    1fc8:	82 8d       	ldd	r24, Z+26	; 0x1a
    1fca:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1fcc:	0f 90       	pop	r0
    1fce:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1fd0:	89 81       	ldd	r24, Y+1	; 0x01
}
    1fd2:	0f 90       	pop	r0
    1fd4:	0f 90       	pop	r0
    1fd6:	0f 90       	pop	r0
    1fd8:	df 91       	pop	r29
    1fda:	cf 91       	pop	r28
    1fdc:	08 95       	ret

00001fde <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    1fde:	cf 93       	push	r28
    1fe0:	df 93       	push	r29
    1fe2:	00 d0       	rcall	.+0      	; 0x1fe4 <uxQueueMessagesWaitingFromISR+0x6>
    1fe4:	cd b7       	in	r28, 0x3d	; 61
    1fe6:	de b7       	in	r29, 0x3e	; 62
    1fe8:	9b 83       	std	Y+3, r25	; 0x03
    1fea:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    1fec:	8a 81       	ldd	r24, Y+2	; 0x02
    1fee:	9b 81       	ldd	r25, Y+3	; 0x03
    1ff0:	fc 01       	movw	r30, r24
    1ff2:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ff4:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    1ff6:	89 81       	ldd	r24, Y+1	; 0x01
}
    1ff8:	0f 90       	pop	r0
    1ffa:	0f 90       	pop	r0
    1ffc:	0f 90       	pop	r0
    1ffe:	df 91       	pop	r29
    2000:	cf 91       	pop	r28
    2002:	08 95       	ret

00002004 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    2004:	cf 93       	push	r28
    2006:	df 93       	push	r29
    2008:	1f 92       	push	r1
    200a:	1f 92       	push	r1
    200c:	cd b7       	in	r28, 0x3d	; 61
    200e:	de b7       	in	r29, 0x3e	; 62
    2010:	9a 83       	std	Y+2, r25	; 0x02
    2012:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    2014:	89 81       	ldd	r24, Y+1	; 0x01
    2016:	9a 81       	ldd	r25, Y+2	; 0x02
    2018:	fc 01       	movw	r30, r24
    201a:	80 81       	ld	r24, Z
    201c:	91 81       	ldd	r25, Z+1	; 0x01
    201e:	0e 94 a9 16 	call	0x2d52	; 0x2d52 <vPortFree>
	vPortFree( pxQueue );
    2022:	89 81       	ldd	r24, Y+1	; 0x01
    2024:	9a 81       	ldd	r25, Y+2	; 0x02
    2026:	0e 94 a9 16 	call	0x2d52	; 0x2d52 <vPortFree>
}
    202a:	0f 90       	pop	r0
    202c:	0f 90       	pop	r0
    202e:	df 91       	pop	r29
    2030:	cf 91       	pop	r28
    2032:	08 95       	ret

00002034 <prvCopyDataToQueue>:

#endif
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    2034:	cf 93       	push	r28
    2036:	df 93       	push	r29
    2038:	00 d0       	rcall	.+0      	; 0x203a <prvCopyDataToQueue+0x6>
    203a:	1f 92       	push	r1
    203c:	1f 92       	push	r1
    203e:	cd b7       	in	r28, 0x3d	; 61
    2040:	de b7       	in	r29, 0x3e	; 62
    2042:	9a 83       	std	Y+2, r25	; 0x02
    2044:	89 83       	std	Y+1, r24	; 0x01
    2046:	7c 83       	std	Y+4, r23	; 0x04
    2048:	6b 83       	std	Y+3, r22	; 0x03
    204a:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    204c:	89 81       	ldd	r24, Y+1	; 0x01
    204e:	9a 81       	ldd	r25, Y+2	; 0x02
    2050:	fc 01       	movw	r30, r24
    2052:	84 8d       	ldd	r24, Z+28	; 0x1c
    2054:	88 23       	and	r24, r24
    2056:	a9 f4       	brne	.+42     	; 0x2082 <prvCopyDataToQueue+0x4e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2058:	89 81       	ldd	r24, Y+1	; 0x01
    205a:	9a 81       	ldd	r25, Y+2	; 0x02
    205c:	fc 01       	movw	r30, r24
    205e:	80 81       	ld	r24, Z
    2060:	91 81       	ldd	r25, Z+1	; 0x01
    2062:	00 97       	sbiw	r24, 0x00	; 0
    2064:	09 f0       	breq	.+2      	; 0x2068 <prvCopyDataToQueue+0x34>
    2066:	92 c0       	rjmp	.+292    	; 0x218c <prvCopyDataToQueue+0x158>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    2068:	89 81       	ldd	r24, Y+1	; 0x01
    206a:	9a 81       	ldd	r25, Y+2	; 0x02
    206c:	fc 01       	movw	r30, r24
    206e:	82 81       	ldd	r24, Z+2	; 0x02
    2070:	93 81       	ldd	r25, Z+3	; 0x03
    2072:	0e 94 e9 0b 	call	0x17d2	; 0x17d2 <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    2076:	89 81       	ldd	r24, Y+1	; 0x01
    2078:	9a 81       	ldd	r25, Y+2	; 0x02
    207a:	fc 01       	movw	r30, r24
    207c:	13 82       	std	Z+3, r1	; 0x03
    207e:	12 82       	std	Z+2, r1	; 0x02
    2080:	85 c0       	rjmp	.+266    	; 0x218c <prvCopyDataToQueue+0x158>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    2082:	8d 81       	ldd	r24, Y+5	; 0x05
    2084:	88 23       	and	r24, r24
    2086:	d9 f5       	brne	.+118    	; 0x20fe <prvCopyDataToQueue+0xca>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    2088:	89 81       	ldd	r24, Y+1	; 0x01
    208a:	9a 81       	ldd	r25, Y+2	; 0x02
    208c:	fc 01       	movw	r30, r24
    208e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2090:	48 2f       	mov	r20, r24
    2092:	50 e0       	ldi	r21, 0x00	; 0
    2094:	89 81       	ldd	r24, Y+1	; 0x01
    2096:	9a 81       	ldd	r25, Y+2	; 0x02
    2098:	fc 01       	movw	r30, r24
    209a:	84 81       	ldd	r24, Z+4	; 0x04
    209c:	95 81       	ldd	r25, Z+5	; 0x05
    209e:	2b 81       	ldd	r18, Y+3	; 0x03
    20a0:	3c 81       	ldd	r19, Y+4	; 0x04
    20a2:	b9 01       	movw	r22, r18
    20a4:	0e 94 ea 23 	call	0x47d4	; 0x47d4 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    20a8:	89 81       	ldd	r24, Y+1	; 0x01
    20aa:	9a 81       	ldd	r25, Y+2	; 0x02
    20ac:	fc 01       	movw	r30, r24
    20ae:	24 81       	ldd	r18, Z+4	; 0x04
    20b0:	35 81       	ldd	r19, Z+5	; 0x05
    20b2:	89 81       	ldd	r24, Y+1	; 0x01
    20b4:	9a 81       	ldd	r25, Y+2	; 0x02
    20b6:	fc 01       	movw	r30, r24
    20b8:	84 8d       	ldd	r24, Z+28	; 0x1c
    20ba:	88 2f       	mov	r24, r24
    20bc:	90 e0       	ldi	r25, 0x00	; 0
    20be:	28 0f       	add	r18, r24
    20c0:	39 1f       	adc	r19, r25
    20c2:	89 81       	ldd	r24, Y+1	; 0x01
    20c4:	9a 81       	ldd	r25, Y+2	; 0x02
    20c6:	fc 01       	movw	r30, r24
    20c8:	35 83       	std	Z+5, r19	; 0x05
    20ca:	24 83       	std	Z+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    20cc:	89 81       	ldd	r24, Y+1	; 0x01
    20ce:	9a 81       	ldd	r25, Y+2	; 0x02
    20d0:	fc 01       	movw	r30, r24
    20d2:	24 81       	ldd	r18, Z+4	; 0x04
    20d4:	35 81       	ldd	r19, Z+5	; 0x05
    20d6:	89 81       	ldd	r24, Y+1	; 0x01
    20d8:	9a 81       	ldd	r25, Y+2	; 0x02
    20da:	fc 01       	movw	r30, r24
    20dc:	82 81       	ldd	r24, Z+2	; 0x02
    20de:	93 81       	ldd	r25, Z+3	; 0x03
    20e0:	28 17       	cp	r18, r24
    20e2:	39 07       	cpc	r19, r25
    20e4:	08 f4       	brcc	.+2      	; 0x20e8 <prvCopyDataToQueue+0xb4>
    20e6:	52 c0       	rjmp	.+164    	; 0x218c <prvCopyDataToQueue+0x158>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    20e8:	89 81       	ldd	r24, Y+1	; 0x01
    20ea:	9a 81       	ldd	r25, Y+2	; 0x02
    20ec:	fc 01       	movw	r30, r24
    20ee:	20 81       	ld	r18, Z
    20f0:	31 81       	ldd	r19, Z+1	; 0x01
    20f2:	89 81       	ldd	r24, Y+1	; 0x01
    20f4:	9a 81       	ldd	r25, Y+2	; 0x02
    20f6:	fc 01       	movw	r30, r24
    20f8:	35 83       	std	Z+5, r19	; 0x05
    20fa:	24 83       	std	Z+4, r18	; 0x04
    20fc:	47 c0       	rjmp	.+142    	; 0x218c <prvCopyDataToQueue+0x158>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    20fe:	89 81       	ldd	r24, Y+1	; 0x01
    2100:	9a 81       	ldd	r25, Y+2	; 0x02
    2102:	fc 01       	movw	r30, r24
    2104:	84 8d       	ldd	r24, Z+28	; 0x1c
    2106:	48 2f       	mov	r20, r24
    2108:	50 e0       	ldi	r21, 0x00	; 0
    210a:	89 81       	ldd	r24, Y+1	; 0x01
    210c:	9a 81       	ldd	r25, Y+2	; 0x02
    210e:	fc 01       	movw	r30, r24
    2110:	86 81       	ldd	r24, Z+6	; 0x06
    2112:	97 81       	ldd	r25, Z+7	; 0x07
    2114:	2b 81       	ldd	r18, Y+3	; 0x03
    2116:	3c 81       	ldd	r19, Y+4	; 0x04
    2118:	b9 01       	movw	r22, r18
    211a:	0e 94 ea 23 	call	0x47d4	; 0x47d4 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    211e:	89 81       	ldd	r24, Y+1	; 0x01
    2120:	9a 81       	ldd	r25, Y+2	; 0x02
    2122:	fc 01       	movw	r30, r24
    2124:	26 81       	ldd	r18, Z+6	; 0x06
    2126:	37 81       	ldd	r19, Z+7	; 0x07
    2128:	89 81       	ldd	r24, Y+1	; 0x01
    212a:	9a 81       	ldd	r25, Y+2	; 0x02
    212c:	fc 01       	movw	r30, r24
    212e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2130:	88 2f       	mov	r24, r24
    2132:	90 e0       	ldi	r25, 0x00	; 0
    2134:	91 95       	neg	r25
    2136:	81 95       	neg	r24
    2138:	91 09       	sbc	r25, r1
    213a:	28 0f       	add	r18, r24
    213c:	39 1f       	adc	r19, r25
    213e:	89 81       	ldd	r24, Y+1	; 0x01
    2140:	9a 81       	ldd	r25, Y+2	; 0x02
    2142:	fc 01       	movw	r30, r24
    2144:	37 83       	std	Z+7, r19	; 0x07
    2146:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    2148:	89 81       	ldd	r24, Y+1	; 0x01
    214a:	9a 81       	ldd	r25, Y+2	; 0x02
    214c:	fc 01       	movw	r30, r24
    214e:	26 81       	ldd	r18, Z+6	; 0x06
    2150:	37 81       	ldd	r19, Z+7	; 0x07
    2152:	89 81       	ldd	r24, Y+1	; 0x01
    2154:	9a 81       	ldd	r25, Y+2	; 0x02
    2156:	fc 01       	movw	r30, r24
    2158:	80 81       	ld	r24, Z
    215a:	91 81       	ldd	r25, Z+1	; 0x01
    215c:	28 17       	cp	r18, r24
    215e:	39 07       	cpc	r19, r25
    2160:	a8 f4       	brcc	.+42     	; 0x218c <prvCopyDataToQueue+0x158>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    2162:	89 81       	ldd	r24, Y+1	; 0x01
    2164:	9a 81       	ldd	r25, Y+2	; 0x02
    2166:	fc 01       	movw	r30, r24
    2168:	22 81       	ldd	r18, Z+2	; 0x02
    216a:	33 81       	ldd	r19, Z+3	; 0x03
    216c:	89 81       	ldd	r24, Y+1	; 0x01
    216e:	9a 81       	ldd	r25, Y+2	; 0x02
    2170:	fc 01       	movw	r30, r24
    2172:	84 8d       	ldd	r24, Z+28	; 0x1c
    2174:	88 2f       	mov	r24, r24
    2176:	90 e0       	ldi	r25, 0x00	; 0
    2178:	91 95       	neg	r25
    217a:	81 95       	neg	r24
    217c:	91 09       	sbc	r25, r1
    217e:	28 0f       	add	r18, r24
    2180:	39 1f       	adc	r19, r25
    2182:	89 81       	ldd	r24, Y+1	; 0x01
    2184:	9a 81       	ldd	r25, Y+2	; 0x02
    2186:	fc 01       	movw	r30, r24
    2188:	37 83       	std	Z+7, r19	; 0x07
    218a:	26 83       	std	Z+6, r18	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    218c:	89 81       	ldd	r24, Y+1	; 0x01
    218e:	9a 81       	ldd	r25, Y+2	; 0x02
    2190:	fc 01       	movw	r30, r24
    2192:	82 8d       	ldd	r24, Z+26	; 0x1a
    2194:	21 e0       	ldi	r18, 0x01	; 1
    2196:	28 0f       	add	r18, r24
    2198:	89 81       	ldd	r24, Y+1	; 0x01
    219a:	9a 81       	ldd	r25, Y+2	; 0x02
    219c:	fc 01       	movw	r30, r24
    219e:	22 8f       	std	Z+26, r18	; 0x1a
}
    21a0:	0f 90       	pop	r0
    21a2:	0f 90       	pop	r0
    21a4:	0f 90       	pop	r0
    21a6:	0f 90       	pop	r0
    21a8:	0f 90       	pop	r0
    21aa:	df 91       	pop	r29
    21ac:	cf 91       	pop	r28
    21ae:	08 95       	ret

000021b0 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    21b0:	cf 93       	push	r28
    21b2:	df 93       	push	r29
    21b4:	00 d0       	rcall	.+0      	; 0x21b6 <prvCopyDataFromQueue+0x6>
    21b6:	1f 92       	push	r1
    21b8:	cd b7       	in	r28, 0x3d	; 61
    21ba:	de b7       	in	r29, 0x3e	; 62
    21bc:	9a 83       	std	Y+2, r25	; 0x02
    21be:	89 83       	std	Y+1, r24	; 0x01
    21c0:	7c 83       	std	Y+4, r23	; 0x04
    21c2:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    21c4:	89 81       	ldd	r24, Y+1	; 0x01
    21c6:	9a 81       	ldd	r25, Y+2	; 0x02
    21c8:	fc 01       	movw	r30, r24
    21ca:	80 81       	ld	r24, Z
    21cc:	91 81       	ldd	r25, Z+1	; 0x01
    21ce:	00 97       	sbiw	r24, 0x00	; 0
    21d0:	c9 f1       	breq	.+114    	; 0x2244 <__stack+0x45>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    21d2:	89 81       	ldd	r24, Y+1	; 0x01
    21d4:	9a 81       	ldd	r25, Y+2	; 0x02
    21d6:	fc 01       	movw	r30, r24
    21d8:	26 81       	ldd	r18, Z+6	; 0x06
    21da:	37 81       	ldd	r19, Z+7	; 0x07
    21dc:	89 81       	ldd	r24, Y+1	; 0x01
    21de:	9a 81       	ldd	r25, Y+2	; 0x02
    21e0:	fc 01       	movw	r30, r24
    21e2:	84 8d       	ldd	r24, Z+28	; 0x1c
    21e4:	88 2f       	mov	r24, r24
    21e6:	90 e0       	ldi	r25, 0x00	; 0
    21e8:	28 0f       	add	r18, r24
    21ea:	39 1f       	adc	r19, r25
    21ec:	89 81       	ldd	r24, Y+1	; 0x01
    21ee:	9a 81       	ldd	r25, Y+2	; 0x02
    21f0:	fc 01       	movw	r30, r24
    21f2:	37 83       	std	Z+7, r19	; 0x07
    21f4:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    21f6:	89 81       	ldd	r24, Y+1	; 0x01
    21f8:	9a 81       	ldd	r25, Y+2	; 0x02
    21fa:	fc 01       	movw	r30, r24
    21fc:	26 81       	ldd	r18, Z+6	; 0x06
    21fe:	37 81       	ldd	r19, Z+7	; 0x07
    2200:	89 81       	ldd	r24, Y+1	; 0x01
    2202:	9a 81       	ldd	r25, Y+2	; 0x02
    2204:	fc 01       	movw	r30, r24
    2206:	82 81       	ldd	r24, Z+2	; 0x02
    2208:	93 81       	ldd	r25, Z+3	; 0x03
    220a:	28 17       	cp	r18, r24
    220c:	39 07       	cpc	r19, r25
    220e:	50 f0       	brcs	.+20     	; 0x2224 <__stack+0x25>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    2210:	89 81       	ldd	r24, Y+1	; 0x01
    2212:	9a 81       	ldd	r25, Y+2	; 0x02
    2214:	fc 01       	movw	r30, r24
    2216:	20 81       	ld	r18, Z
    2218:	31 81       	ldd	r19, Z+1	; 0x01
    221a:	89 81       	ldd	r24, Y+1	; 0x01
    221c:	9a 81       	ldd	r25, Y+2	; 0x02
    221e:	fc 01       	movw	r30, r24
    2220:	37 83       	std	Z+7, r19	; 0x07
    2222:	26 83       	std	Z+6, r18	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    2224:	89 81       	ldd	r24, Y+1	; 0x01
    2226:	9a 81       	ldd	r25, Y+2	; 0x02
    2228:	fc 01       	movw	r30, r24
    222a:	84 8d       	ldd	r24, Z+28	; 0x1c
    222c:	48 2f       	mov	r20, r24
    222e:	50 e0       	ldi	r21, 0x00	; 0
    2230:	89 81       	ldd	r24, Y+1	; 0x01
    2232:	9a 81       	ldd	r25, Y+2	; 0x02
    2234:	fc 01       	movw	r30, r24
    2236:	26 81       	ldd	r18, Z+6	; 0x06
    2238:	37 81       	ldd	r19, Z+7	; 0x07
    223a:	8b 81       	ldd	r24, Y+3	; 0x03
    223c:	9c 81       	ldd	r25, Y+4	; 0x04
    223e:	b9 01       	movw	r22, r18
    2240:	0e 94 ea 23 	call	0x47d4	; 0x47d4 <memcpy>
	}
}
    2244:	0f 90       	pop	r0
    2246:	0f 90       	pop	r0
    2248:	0f 90       	pop	r0
    224a:	0f 90       	pop	r0
    224c:	df 91       	pop	r29
    224e:	cf 91       	pop	r28
    2250:	08 95       	ret

00002252 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    2252:	cf 93       	push	r28
    2254:	df 93       	push	r29
    2256:	1f 92       	push	r1
    2258:	1f 92       	push	r1
    225a:	cd b7       	in	r28, 0x3d	; 61
    225c:	de b7       	in	r29, 0x3e	; 62
    225e:	9a 83       	std	Y+2, r25	; 0x02
    2260:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    2262:	0f b6       	in	r0, 0x3f	; 63
    2264:	f8 94       	cli
    2266:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2268:	1b c0       	rjmp	.+54     	; 0x22a0 <prvUnlockQueue+0x4e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    226a:	89 81       	ldd	r24, Y+1	; 0x01
    226c:	9a 81       	ldd	r25, Y+2	; 0x02
    226e:	fc 01       	movw	r30, r24
    2270:	81 89       	ldd	r24, Z+17	; 0x11
    2272:	88 23       	and	r24, r24
    2274:	a1 f0       	breq	.+40     	; 0x229e <prvUnlockQueue+0x4c>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2276:	89 81       	ldd	r24, Y+1	; 0x01
    2278:	9a 81       	ldd	r25, Y+2	; 0x02
    227a:	41 96       	adiw	r24, 0x11	; 17
    227c:	0e 94 a9 08 	call	0x1152	; 0x1152 <xTaskRemoveFromEventList>
    2280:	88 23       	and	r24, r24
    2282:	11 f0       	breq	.+4      	; 0x2288 <prvUnlockQueue+0x36>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    2284:	0e 94 9e 09 	call	0x133c	; 0x133c <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    2288:	89 81       	ldd	r24, Y+1	; 0x01
    228a:	9a 81       	ldd	r25, Y+2	; 0x02
    228c:	fc 01       	movw	r30, r24
    228e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2290:	2f ef       	ldi	r18, 0xFF	; 255
    2292:	28 0f       	add	r18, r24
    2294:	89 81       	ldd	r24, Y+1	; 0x01
    2296:	9a 81       	ldd	r25, Y+2	; 0x02
    2298:	fc 01       	movw	r30, r24
    229a:	26 8f       	std	Z+30, r18	; 0x1e
    229c:	01 c0       	rjmp	.+2      	; 0x22a0 <prvUnlockQueue+0x4e>
			}
			else
			{
				break;
    229e:	06 c0       	rjmp	.+12     	; 0x22ac <prvUnlockQueue+0x5a>
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    22a0:	89 81       	ldd	r24, Y+1	; 0x01
    22a2:	9a 81       	ldd	r25, Y+2	; 0x02
    22a4:	fc 01       	movw	r30, r24
    22a6:	86 8d       	ldd	r24, Z+30	; 0x1e
    22a8:	18 16       	cp	r1, r24
    22aa:	fc f2       	brlt	.-66     	; 0x226a <prvUnlockQueue+0x18>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    22ac:	89 81       	ldd	r24, Y+1	; 0x01
    22ae:	9a 81       	ldd	r25, Y+2	; 0x02
    22b0:	2f ef       	ldi	r18, 0xFF	; 255
    22b2:	fc 01       	movw	r30, r24
    22b4:	26 8f       	std	Z+30, r18	; 0x1e
	}
	taskEXIT_CRITICAL();
    22b6:	0f 90       	pop	r0
    22b8:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    22ba:	0f b6       	in	r0, 0x3f	; 63
    22bc:	f8 94       	cli
    22be:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    22c0:	1b c0       	rjmp	.+54     	; 0x22f8 <prvUnlockQueue+0xa6>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    22c2:	89 81       	ldd	r24, Y+1	; 0x01
    22c4:	9a 81       	ldd	r25, Y+2	; 0x02
    22c6:	fc 01       	movw	r30, r24
    22c8:	80 85       	ldd	r24, Z+8	; 0x08
    22ca:	88 23       	and	r24, r24
    22cc:	a1 f0       	breq	.+40     	; 0x22f6 <prvUnlockQueue+0xa4>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    22ce:	89 81       	ldd	r24, Y+1	; 0x01
    22d0:	9a 81       	ldd	r25, Y+2	; 0x02
    22d2:	08 96       	adiw	r24, 0x08	; 8
    22d4:	0e 94 a9 08 	call	0x1152	; 0x1152 <xTaskRemoveFromEventList>
    22d8:	88 23       	and	r24, r24
    22da:	11 f0       	breq	.+4      	; 0x22e0 <prvUnlockQueue+0x8e>
				{
					vTaskMissedYield();
    22dc:	0e 94 9e 09 	call	0x133c	; 0x133c <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    22e0:	89 81       	ldd	r24, Y+1	; 0x01
    22e2:	9a 81       	ldd	r25, Y+2	; 0x02
    22e4:	fc 01       	movw	r30, r24
    22e6:	85 8d       	ldd	r24, Z+29	; 0x1d
    22e8:	2f ef       	ldi	r18, 0xFF	; 255
    22ea:	28 0f       	add	r18, r24
    22ec:	89 81       	ldd	r24, Y+1	; 0x01
    22ee:	9a 81       	ldd	r25, Y+2	; 0x02
    22f0:	fc 01       	movw	r30, r24
    22f2:	25 8f       	std	Z+29, r18	; 0x1d
    22f4:	01 c0       	rjmp	.+2      	; 0x22f8 <prvUnlockQueue+0xa6>
			}
			else
			{
				break;
    22f6:	06 c0       	rjmp	.+12     	; 0x2304 <prvUnlockQueue+0xb2>
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    22f8:	89 81       	ldd	r24, Y+1	; 0x01
    22fa:	9a 81       	ldd	r25, Y+2	; 0x02
    22fc:	fc 01       	movw	r30, r24
    22fe:	85 8d       	ldd	r24, Z+29	; 0x1d
    2300:	18 16       	cp	r1, r24
    2302:	fc f2       	brlt	.-66     	; 0x22c2 <prvUnlockQueue+0x70>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    2304:	89 81       	ldd	r24, Y+1	; 0x01
    2306:	9a 81       	ldd	r25, Y+2	; 0x02
    2308:	2f ef       	ldi	r18, 0xFF	; 255
    230a:	fc 01       	movw	r30, r24
    230c:	25 8f       	std	Z+29, r18	; 0x1d
	}
	taskEXIT_CRITICAL();
    230e:	0f 90       	pop	r0
    2310:	0f be       	out	0x3f, r0	; 63
}
    2312:	0f 90       	pop	r0
    2314:	0f 90       	pop	r0
    2316:	df 91       	pop	r29
    2318:	cf 91       	pop	r28
    231a:	08 95       	ret

0000231c <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    231c:	cf 93       	push	r28
    231e:	df 93       	push	r29
    2320:	00 d0       	rcall	.+0      	; 0x2322 <prvIsQueueEmpty+0x6>
    2322:	cd b7       	in	r28, 0x3d	; 61
    2324:	de b7       	in	r29, 0x3e	; 62
    2326:	9b 83       	std	Y+3, r25	; 0x03
    2328:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    232a:	0f b6       	in	r0, 0x3f	; 63
    232c:	f8 94       	cli
    232e:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    2330:	8a 81       	ldd	r24, Y+2	; 0x02
    2332:	9b 81       	ldd	r25, Y+3	; 0x03
    2334:	fc 01       	movw	r30, r24
    2336:	92 8d       	ldd	r25, Z+26	; 0x1a
    2338:	81 e0       	ldi	r24, 0x01	; 1
    233a:	99 23       	and	r25, r25
    233c:	09 f0       	breq	.+2      	; 0x2340 <prvIsQueueEmpty+0x24>
    233e:	80 e0       	ldi	r24, 0x00	; 0
    2340:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    2342:	0f 90       	pop	r0
    2344:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2346:	89 81       	ldd	r24, Y+1	; 0x01
}
    2348:	0f 90       	pop	r0
    234a:	0f 90       	pop	r0
    234c:	0f 90       	pop	r0
    234e:	df 91       	pop	r29
    2350:	cf 91       	pop	r28
    2352:	08 95       	ret

00002354 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    2354:	cf 93       	push	r28
    2356:	df 93       	push	r29
    2358:	00 d0       	rcall	.+0      	; 0x235a <xQueueIsQueueEmptyFromISR+0x6>
    235a:	cd b7       	in	r28, 0x3d	; 61
    235c:	de b7       	in	r29, 0x3e	; 62
    235e:	9b 83       	std	Y+3, r25	; 0x03
    2360:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    2362:	8a 81       	ldd	r24, Y+2	; 0x02
    2364:	9b 81       	ldd	r25, Y+3	; 0x03
    2366:	fc 01       	movw	r30, r24
    2368:	92 8d       	ldd	r25, Z+26	; 0x1a
    236a:	81 e0       	ldi	r24, 0x01	; 1
    236c:	99 23       	and	r25, r25
    236e:	09 f0       	breq	.+2      	; 0x2372 <xQueueIsQueueEmptyFromISR+0x1e>
    2370:	80 e0       	ldi	r24, 0x00	; 0
    2372:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    2374:	89 81       	ldd	r24, Y+1	; 0x01
}
    2376:	0f 90       	pop	r0
    2378:	0f 90       	pop	r0
    237a:	0f 90       	pop	r0
    237c:	df 91       	pop	r29
    237e:	cf 91       	pop	r28
    2380:	08 95       	ret

00002382 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    2382:	cf 93       	push	r28
    2384:	df 93       	push	r29
    2386:	00 d0       	rcall	.+0      	; 0x2388 <prvIsQueueFull+0x6>
    2388:	cd b7       	in	r28, 0x3d	; 61
    238a:	de b7       	in	r29, 0x3e	; 62
    238c:	9b 83       	std	Y+3, r25	; 0x03
    238e:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    2390:	0f b6       	in	r0, 0x3f	; 63
    2392:	f8 94       	cli
    2394:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    2396:	8a 81       	ldd	r24, Y+2	; 0x02
    2398:	9b 81       	ldd	r25, Y+3	; 0x03
    239a:	fc 01       	movw	r30, r24
    239c:	22 8d       	ldd	r18, Z+26	; 0x1a
    239e:	8a 81       	ldd	r24, Y+2	; 0x02
    23a0:	9b 81       	ldd	r25, Y+3	; 0x03
    23a2:	fc 01       	movw	r30, r24
    23a4:	93 8d       	ldd	r25, Z+27	; 0x1b
    23a6:	81 e0       	ldi	r24, 0x01	; 1
    23a8:	29 17       	cp	r18, r25
    23aa:	09 f0       	breq	.+2      	; 0x23ae <prvIsQueueFull+0x2c>
    23ac:	80 e0       	ldi	r24, 0x00	; 0
    23ae:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    23b0:	0f 90       	pop	r0
    23b2:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    23b4:	89 81       	ldd	r24, Y+1	; 0x01
}
    23b6:	0f 90       	pop	r0
    23b8:	0f 90       	pop	r0
    23ba:	0f 90       	pop	r0
    23bc:	df 91       	pop	r29
    23be:	cf 91       	pop	r28
    23c0:	08 95       	ret

000023c2 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    23c2:	cf 93       	push	r28
    23c4:	df 93       	push	r29
    23c6:	00 d0       	rcall	.+0      	; 0x23c8 <xQueueIsQueueFullFromISR+0x6>
    23c8:	cd b7       	in	r28, 0x3d	; 61
    23ca:	de b7       	in	r29, 0x3e	; 62
    23cc:	9b 83       	std	Y+3, r25	; 0x03
    23ce:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    23d0:	8a 81       	ldd	r24, Y+2	; 0x02
    23d2:	9b 81       	ldd	r25, Y+3	; 0x03
    23d4:	fc 01       	movw	r30, r24
    23d6:	22 8d       	ldd	r18, Z+26	; 0x1a
    23d8:	8a 81       	ldd	r24, Y+2	; 0x02
    23da:	9b 81       	ldd	r25, Y+3	; 0x03
    23dc:	fc 01       	movw	r30, r24
    23de:	93 8d       	ldd	r25, Z+27	; 0x1b
    23e0:	81 e0       	ldi	r24, 0x01	; 1
    23e2:	29 17       	cp	r18, r25
    23e4:	09 f0       	breq	.+2      	; 0x23e8 <xQueueIsQueueFullFromISR+0x26>
    23e6:	80 e0       	ldi	r24, 0x00	; 0
    23e8:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    23ea:	89 81       	ldd	r24, Y+1	; 0x01
}
    23ec:	0f 90       	pop	r0
    23ee:	0f 90       	pop	r0
    23f0:	0f 90       	pop	r0
    23f2:	df 91       	pop	r29
    23f4:	cf 91       	pop	r28
    23f6:	08 95       	ret

000023f8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    23f8:	cf 93       	push	r28
    23fa:	df 93       	push	r29
    23fc:	1f 92       	push	r1
    23fe:	1f 92       	push	r1
    2400:	cd b7       	in	r28, 0x3d	; 61
    2402:	de b7       	in	r29, 0x3e	; 62
    2404:	9a 83       	std	Y+2, r25	; 0x02
    2406:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    2408:	89 81       	ldd	r24, Y+1	; 0x01
    240a:	9a 81       	ldd	r25, Y+2	; 0x02
    240c:	9c 01       	movw	r18, r24
    240e:	2d 5f       	subi	r18, 0xFD	; 253
    2410:	3f 4f       	sbci	r19, 0xFF	; 255
    2412:	89 81       	ldd	r24, Y+1	; 0x01
    2414:	9a 81       	ldd	r25, Y+2	; 0x02
    2416:	fc 01       	movw	r30, r24
    2418:	32 83       	std	Z+2, r19	; 0x02
    241a:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    241c:	89 81       	ldd	r24, Y+1	; 0x01
    241e:	9a 81       	ldd	r25, Y+2	; 0x02
    2420:	2f ef       	ldi	r18, 0xFF	; 255
    2422:	3f ef       	ldi	r19, 0xFF	; 255
    2424:	fc 01       	movw	r30, r24
    2426:	34 83       	std	Z+4, r19	; 0x04
    2428:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    242a:	89 81       	ldd	r24, Y+1	; 0x01
    242c:	9a 81       	ldd	r25, Y+2	; 0x02
    242e:	9c 01       	movw	r18, r24
    2430:	2d 5f       	subi	r18, 0xFD	; 253
    2432:	3f 4f       	sbci	r19, 0xFF	; 255
    2434:	89 81       	ldd	r24, Y+1	; 0x01
    2436:	9a 81       	ldd	r25, Y+2	; 0x02
    2438:	fc 01       	movw	r30, r24
    243a:	36 83       	std	Z+6, r19	; 0x06
    243c:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    243e:	89 81       	ldd	r24, Y+1	; 0x01
    2440:	9a 81       	ldd	r25, Y+2	; 0x02
    2442:	9c 01       	movw	r18, r24
    2444:	2d 5f       	subi	r18, 0xFD	; 253
    2446:	3f 4f       	sbci	r19, 0xFF	; 255
    2448:	89 81       	ldd	r24, Y+1	; 0x01
    244a:	9a 81       	ldd	r25, Y+2	; 0x02
    244c:	fc 01       	movw	r30, r24
    244e:	30 87       	std	Z+8, r19	; 0x08
    2450:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    2452:	89 81       	ldd	r24, Y+1	; 0x01
    2454:	9a 81       	ldd	r25, Y+2	; 0x02
    2456:	fc 01       	movw	r30, r24
    2458:	10 82       	st	Z, r1
}
    245a:	0f 90       	pop	r0
    245c:	0f 90       	pop	r0
    245e:	df 91       	pop	r29
    2460:	cf 91       	pop	r28
    2462:	08 95       	ret

00002464 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    2464:	cf 93       	push	r28
    2466:	df 93       	push	r29
    2468:	1f 92       	push	r1
    246a:	1f 92       	push	r1
    246c:	cd b7       	in	r28, 0x3d	; 61
    246e:	de b7       	in	r29, 0x3e	; 62
    2470:	9a 83       	std	Y+2, r25	; 0x02
    2472:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    2474:	89 81       	ldd	r24, Y+1	; 0x01
    2476:	9a 81       	ldd	r25, Y+2	; 0x02
    2478:	fc 01       	movw	r30, r24
    247a:	11 86       	std	Z+9, r1	; 0x09
    247c:	10 86       	std	Z+8, r1	; 0x08
}
    247e:	0f 90       	pop	r0
    2480:	0f 90       	pop	r0
    2482:	df 91       	pop	r29
    2484:	cf 91       	pop	r28
    2486:	08 95       	ret

00002488 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    2488:	cf 93       	push	r28
    248a:	df 93       	push	r29
    248c:	00 d0       	rcall	.+0      	; 0x248e <vListInsertEnd+0x6>
    248e:	00 d0       	rcall	.+0      	; 0x2490 <vListInsertEnd+0x8>
    2490:	cd b7       	in	r28, 0x3d	; 61
    2492:	de b7       	in	r29, 0x3e	; 62
    2494:	9c 83       	std	Y+4, r25	; 0x04
    2496:	8b 83       	std	Y+3, r24	; 0x03
    2498:	7e 83       	std	Y+6, r23	; 0x06
    249a:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    249c:	8b 81       	ldd	r24, Y+3	; 0x03
    249e:	9c 81       	ldd	r25, Y+4	; 0x04
    24a0:	fc 01       	movw	r30, r24
    24a2:	81 81       	ldd	r24, Z+1	; 0x01
    24a4:	92 81       	ldd	r25, Z+2	; 0x02
    24a6:	9a 83       	std	Y+2, r25	; 0x02
    24a8:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    24aa:	89 81       	ldd	r24, Y+1	; 0x01
    24ac:	9a 81       	ldd	r25, Y+2	; 0x02
    24ae:	fc 01       	movw	r30, r24
    24b0:	22 81       	ldd	r18, Z+2	; 0x02
    24b2:	33 81       	ldd	r19, Z+3	; 0x03
    24b4:	8d 81       	ldd	r24, Y+5	; 0x05
    24b6:	9e 81       	ldd	r25, Y+6	; 0x06
    24b8:	fc 01       	movw	r30, r24
    24ba:	33 83       	std	Z+3, r19	; 0x03
    24bc:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    24be:	8b 81       	ldd	r24, Y+3	; 0x03
    24c0:	9c 81       	ldd	r25, Y+4	; 0x04
    24c2:	fc 01       	movw	r30, r24
    24c4:	21 81       	ldd	r18, Z+1	; 0x01
    24c6:	32 81       	ldd	r19, Z+2	; 0x02
    24c8:	8d 81       	ldd	r24, Y+5	; 0x05
    24ca:	9e 81       	ldd	r25, Y+6	; 0x06
    24cc:	fc 01       	movw	r30, r24
    24ce:	35 83       	std	Z+5, r19	; 0x05
    24d0:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    24d2:	89 81       	ldd	r24, Y+1	; 0x01
    24d4:	9a 81       	ldd	r25, Y+2	; 0x02
    24d6:	fc 01       	movw	r30, r24
    24d8:	82 81       	ldd	r24, Z+2	; 0x02
    24da:	93 81       	ldd	r25, Z+3	; 0x03
    24dc:	2d 81       	ldd	r18, Y+5	; 0x05
    24de:	3e 81       	ldd	r19, Y+6	; 0x06
    24e0:	fc 01       	movw	r30, r24
    24e2:	35 83       	std	Z+5, r19	; 0x05
    24e4:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    24e6:	89 81       	ldd	r24, Y+1	; 0x01
    24e8:	9a 81       	ldd	r25, Y+2	; 0x02
    24ea:	2d 81       	ldd	r18, Y+5	; 0x05
    24ec:	3e 81       	ldd	r19, Y+6	; 0x06
    24ee:	fc 01       	movw	r30, r24
    24f0:	33 83       	std	Z+3, r19	; 0x03
    24f2:	22 83       	std	Z+2, r18	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    24f4:	8b 81       	ldd	r24, Y+3	; 0x03
    24f6:	9c 81       	ldd	r25, Y+4	; 0x04
    24f8:	2d 81       	ldd	r18, Y+5	; 0x05
    24fa:	3e 81       	ldd	r19, Y+6	; 0x06
    24fc:	fc 01       	movw	r30, r24
    24fe:	32 83       	std	Z+2, r19	; 0x02
    2500:	21 83       	std	Z+1, r18	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2502:	8d 81       	ldd	r24, Y+5	; 0x05
    2504:	9e 81       	ldd	r25, Y+6	; 0x06
    2506:	2b 81       	ldd	r18, Y+3	; 0x03
    2508:	3c 81       	ldd	r19, Y+4	; 0x04
    250a:	fc 01       	movw	r30, r24
    250c:	31 87       	std	Z+9, r19	; 0x09
    250e:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    2510:	8b 81       	ldd	r24, Y+3	; 0x03
    2512:	9c 81       	ldd	r25, Y+4	; 0x04
    2514:	fc 01       	movw	r30, r24
    2516:	80 81       	ld	r24, Z
    2518:	21 e0       	ldi	r18, 0x01	; 1
    251a:	28 0f       	add	r18, r24
    251c:	8b 81       	ldd	r24, Y+3	; 0x03
    251e:	9c 81       	ldd	r25, Y+4	; 0x04
    2520:	fc 01       	movw	r30, r24
    2522:	20 83       	st	Z, r18
}
    2524:	26 96       	adiw	r28, 0x06	; 6
    2526:	0f b6       	in	r0, 0x3f	; 63
    2528:	f8 94       	cli
    252a:	de bf       	out	0x3e, r29	; 62
    252c:	0f be       	out	0x3f, r0	; 63
    252e:	cd bf       	out	0x3d, r28	; 61
    2530:	df 91       	pop	r29
    2532:	cf 91       	pop	r28
    2534:	08 95       	ret

00002536 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    2536:	cf 93       	push	r28
    2538:	df 93       	push	r29
    253a:	cd b7       	in	r28, 0x3d	; 61
    253c:	de b7       	in	r29, 0x3e	; 62
    253e:	28 97       	sbiw	r28, 0x08	; 8
    2540:	0f b6       	in	r0, 0x3f	; 63
    2542:	f8 94       	cli
    2544:	de bf       	out	0x3e, r29	; 62
    2546:	0f be       	out	0x3f, r0	; 63
    2548:	cd bf       	out	0x3d, r28	; 61
    254a:	9e 83       	std	Y+6, r25	; 0x06
    254c:	8d 83       	std	Y+5, r24	; 0x05
    254e:	78 87       	std	Y+8, r23	; 0x08
    2550:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    2552:	8f 81       	ldd	r24, Y+7	; 0x07
    2554:	98 85       	ldd	r25, Y+8	; 0x08
    2556:	fc 01       	movw	r30, r24
    2558:	80 81       	ld	r24, Z
    255a:	91 81       	ldd	r25, Z+1	; 0x01
    255c:	9c 83       	std	Y+4, r25	; 0x04
    255e:	8b 83       	std	Y+3, r24	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    2560:	8b 81       	ldd	r24, Y+3	; 0x03
    2562:	9c 81       	ldd	r25, Y+4	; 0x04
    2564:	8f 3f       	cpi	r24, 0xFF	; 255
    2566:	ff ef       	ldi	r31, 0xFF	; 255
    2568:	9f 07       	cpc	r25, r31
    256a:	41 f4       	brne	.+16     	; 0x257c <vListInsert+0x46>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    256c:	8d 81       	ldd	r24, Y+5	; 0x05
    256e:	9e 81       	ldd	r25, Y+6	; 0x06
    2570:	fc 01       	movw	r30, r24
    2572:	87 81       	ldd	r24, Z+7	; 0x07
    2574:	90 85       	ldd	r25, Z+8	; 0x08
    2576:	9a 83       	std	Y+2, r25	; 0x02
    2578:	89 83       	std	Y+1, r24	; 0x01
    257a:	1a c0       	rjmp	.+52     	; 0x25b0 <vListInsert+0x7a>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    257c:	8d 81       	ldd	r24, Y+5	; 0x05
    257e:	9e 81       	ldd	r25, Y+6	; 0x06
    2580:	03 96       	adiw	r24, 0x03	; 3
    2582:	9a 83       	std	Y+2, r25	; 0x02
    2584:	89 83       	std	Y+1, r24	; 0x01
    2586:	07 c0       	rjmp	.+14     	; 0x2596 <vListInsert+0x60>
    2588:	89 81       	ldd	r24, Y+1	; 0x01
    258a:	9a 81       	ldd	r25, Y+2	; 0x02
    258c:	fc 01       	movw	r30, r24
    258e:	82 81       	ldd	r24, Z+2	; 0x02
    2590:	93 81       	ldd	r25, Z+3	; 0x03
    2592:	9a 83       	std	Y+2, r25	; 0x02
    2594:	89 83       	std	Y+1, r24	; 0x01
    2596:	89 81       	ldd	r24, Y+1	; 0x01
    2598:	9a 81       	ldd	r25, Y+2	; 0x02
    259a:	fc 01       	movw	r30, r24
    259c:	82 81       	ldd	r24, Z+2	; 0x02
    259e:	93 81       	ldd	r25, Z+3	; 0x03
    25a0:	fc 01       	movw	r30, r24
    25a2:	20 81       	ld	r18, Z
    25a4:	31 81       	ldd	r19, Z+1	; 0x01
    25a6:	8b 81       	ldd	r24, Y+3	; 0x03
    25a8:	9c 81       	ldd	r25, Y+4	; 0x04
    25aa:	82 17       	cp	r24, r18
    25ac:	93 07       	cpc	r25, r19
    25ae:	60 f7       	brcc	.-40     	; 0x2588 <vListInsert+0x52>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    25b0:	89 81       	ldd	r24, Y+1	; 0x01
    25b2:	9a 81       	ldd	r25, Y+2	; 0x02
    25b4:	fc 01       	movw	r30, r24
    25b6:	22 81       	ldd	r18, Z+2	; 0x02
    25b8:	33 81       	ldd	r19, Z+3	; 0x03
    25ba:	8f 81       	ldd	r24, Y+7	; 0x07
    25bc:	98 85       	ldd	r25, Y+8	; 0x08
    25be:	fc 01       	movw	r30, r24
    25c0:	33 83       	std	Z+3, r19	; 0x03
    25c2:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    25c4:	8f 81       	ldd	r24, Y+7	; 0x07
    25c6:	98 85       	ldd	r25, Y+8	; 0x08
    25c8:	fc 01       	movw	r30, r24
    25ca:	82 81       	ldd	r24, Z+2	; 0x02
    25cc:	93 81       	ldd	r25, Z+3	; 0x03
    25ce:	2f 81       	ldd	r18, Y+7	; 0x07
    25d0:	38 85       	ldd	r19, Y+8	; 0x08
    25d2:	fc 01       	movw	r30, r24
    25d4:	35 83       	std	Z+5, r19	; 0x05
    25d6:	24 83       	std	Z+4, r18	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    25d8:	8f 81       	ldd	r24, Y+7	; 0x07
    25da:	98 85       	ldd	r25, Y+8	; 0x08
    25dc:	29 81       	ldd	r18, Y+1	; 0x01
    25de:	3a 81       	ldd	r19, Y+2	; 0x02
    25e0:	fc 01       	movw	r30, r24
    25e2:	35 83       	std	Z+5, r19	; 0x05
    25e4:	24 83       	std	Z+4, r18	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    25e6:	89 81       	ldd	r24, Y+1	; 0x01
    25e8:	9a 81       	ldd	r25, Y+2	; 0x02
    25ea:	2f 81       	ldd	r18, Y+7	; 0x07
    25ec:	38 85       	ldd	r19, Y+8	; 0x08
    25ee:	fc 01       	movw	r30, r24
    25f0:	33 83       	std	Z+3, r19	; 0x03
    25f2:	22 83       	std	Z+2, r18	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    25f4:	8f 81       	ldd	r24, Y+7	; 0x07
    25f6:	98 85       	ldd	r25, Y+8	; 0x08
    25f8:	2d 81       	ldd	r18, Y+5	; 0x05
    25fa:	3e 81       	ldd	r19, Y+6	; 0x06
    25fc:	fc 01       	movw	r30, r24
    25fe:	31 87       	std	Z+9, r19	; 0x09
    2600:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    2602:	8d 81       	ldd	r24, Y+5	; 0x05
    2604:	9e 81       	ldd	r25, Y+6	; 0x06
    2606:	fc 01       	movw	r30, r24
    2608:	80 81       	ld	r24, Z
    260a:	21 e0       	ldi	r18, 0x01	; 1
    260c:	28 0f       	add	r18, r24
    260e:	8d 81       	ldd	r24, Y+5	; 0x05
    2610:	9e 81       	ldd	r25, Y+6	; 0x06
    2612:	fc 01       	movw	r30, r24
    2614:	20 83       	st	Z, r18
}
    2616:	28 96       	adiw	r28, 0x08	; 8
    2618:	0f b6       	in	r0, 0x3f	; 63
    261a:	f8 94       	cli
    261c:	de bf       	out	0x3e, r29	; 62
    261e:	0f be       	out	0x3f, r0	; 63
    2620:	cd bf       	out	0x3d, r28	; 61
    2622:	df 91       	pop	r29
    2624:	cf 91       	pop	r28
    2626:	08 95       	ret

00002628 <uxListRemove>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
{
    2628:	cf 93       	push	r28
    262a:	df 93       	push	r29
    262c:	00 d0       	rcall	.+0      	; 0x262e <uxListRemove+0x6>
    262e:	1f 92       	push	r1
    2630:	cd b7       	in	r28, 0x3d	; 61
    2632:	de b7       	in	r29, 0x3e	; 62
    2634:	9c 83       	std	Y+4, r25	; 0x04
    2636:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2638:	8b 81       	ldd	r24, Y+3	; 0x03
    263a:	9c 81       	ldd	r25, Y+4	; 0x04
    263c:	fc 01       	movw	r30, r24
    263e:	82 81       	ldd	r24, Z+2	; 0x02
    2640:	93 81       	ldd	r25, Z+3	; 0x03
    2642:	2b 81       	ldd	r18, Y+3	; 0x03
    2644:	3c 81       	ldd	r19, Y+4	; 0x04
    2646:	f9 01       	movw	r30, r18
    2648:	24 81       	ldd	r18, Z+4	; 0x04
    264a:	35 81       	ldd	r19, Z+5	; 0x05
    264c:	fc 01       	movw	r30, r24
    264e:	35 83       	std	Z+5, r19	; 0x05
    2650:	24 83       	std	Z+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2652:	8b 81       	ldd	r24, Y+3	; 0x03
    2654:	9c 81       	ldd	r25, Y+4	; 0x04
    2656:	fc 01       	movw	r30, r24
    2658:	84 81       	ldd	r24, Z+4	; 0x04
    265a:	95 81       	ldd	r25, Z+5	; 0x05
    265c:	2b 81       	ldd	r18, Y+3	; 0x03
    265e:	3c 81       	ldd	r19, Y+4	; 0x04
    2660:	f9 01       	movw	r30, r18
    2662:	22 81       	ldd	r18, Z+2	; 0x02
    2664:	33 81       	ldd	r19, Z+3	; 0x03
    2666:	fc 01       	movw	r30, r24
    2668:	33 83       	std	Z+3, r19	; 0x03
    266a:	22 83       	std	Z+2, r18	; 0x02

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    266c:	8b 81       	ldd	r24, Y+3	; 0x03
    266e:	9c 81       	ldd	r25, Y+4	; 0x04
    2670:	fc 01       	movw	r30, r24
    2672:	80 85       	ldd	r24, Z+8	; 0x08
    2674:	91 85       	ldd	r25, Z+9	; 0x09
    2676:	9a 83       	std	Y+2, r25	; 0x02
    2678:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    267a:	89 81       	ldd	r24, Y+1	; 0x01
    267c:	9a 81       	ldd	r25, Y+2	; 0x02
    267e:	fc 01       	movw	r30, r24
    2680:	21 81       	ldd	r18, Z+1	; 0x01
    2682:	32 81       	ldd	r19, Z+2	; 0x02
    2684:	8b 81       	ldd	r24, Y+3	; 0x03
    2686:	9c 81       	ldd	r25, Y+4	; 0x04
    2688:	28 17       	cp	r18, r24
    268a:	39 07       	cpc	r19, r25
    268c:	51 f4       	brne	.+20     	; 0x26a2 <uxListRemove+0x7a>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    268e:	8b 81       	ldd	r24, Y+3	; 0x03
    2690:	9c 81       	ldd	r25, Y+4	; 0x04
    2692:	fc 01       	movw	r30, r24
    2694:	24 81       	ldd	r18, Z+4	; 0x04
    2696:	35 81       	ldd	r19, Z+5	; 0x05
    2698:	89 81       	ldd	r24, Y+1	; 0x01
    269a:	9a 81       	ldd	r25, Y+2	; 0x02
    269c:	fc 01       	movw	r30, r24
    269e:	32 83       	std	Z+2, r19	; 0x02
    26a0:	21 83       	std	Z+1, r18	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    26a2:	8b 81       	ldd	r24, Y+3	; 0x03
    26a4:	9c 81       	ldd	r25, Y+4	; 0x04
    26a6:	fc 01       	movw	r30, r24
    26a8:	11 86       	std	Z+9, r1	; 0x09
    26aa:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    26ac:	89 81       	ldd	r24, Y+1	; 0x01
    26ae:	9a 81       	ldd	r25, Y+2	; 0x02
    26b0:	fc 01       	movw	r30, r24
    26b2:	80 81       	ld	r24, Z
    26b4:	2f ef       	ldi	r18, 0xFF	; 255
    26b6:	28 0f       	add	r18, r24
    26b8:	89 81       	ldd	r24, Y+1	; 0x01
    26ba:	9a 81       	ldd	r25, Y+2	; 0x02
    26bc:	fc 01       	movw	r30, r24
    26be:	20 83       	st	Z, r18

	return pxList->uxNumberOfItems;
    26c0:	89 81       	ldd	r24, Y+1	; 0x01
    26c2:	9a 81       	ldd	r25, Y+2	; 0x02
    26c4:	fc 01       	movw	r30, r24
    26c6:	80 81       	ld	r24, Z
}
    26c8:	0f 90       	pop	r0
    26ca:	0f 90       	pop	r0
    26cc:	0f 90       	pop	r0
    26ce:	0f 90       	pop	r0
    26d0:	df 91       	pop	r29
    26d2:	cf 91       	pop	r28
    26d4:	08 95       	ret

000026d6 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    26d6:	cf 93       	push	r28
    26d8:	df 93       	push	r29
    26da:	cd b7       	in	r28, 0x3d	; 61
    26dc:	de b7       	in	r29, 0x3e	; 62
    26de:	27 97       	sbiw	r28, 0x07	; 7
    26e0:	0f b6       	in	r0, 0x3f	; 63
    26e2:	f8 94       	cli
    26e4:	de bf       	out	0x3e, r29	; 62
    26e6:	0f be       	out	0x3f, r0	; 63
    26e8:	cd bf       	out	0x3d, r28	; 61
    26ea:	9d 83       	std	Y+5, r25	; 0x05
    26ec:	8c 83       	std	Y+4, r24	; 0x04
    26ee:	6e 83       	std	Y+6, r22	; 0x06
    26f0:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    26f2:	8a e1       	ldi	r24, 0x1A	; 26
    26f4:	90 e0       	ldi	r25, 0x00	; 0
    26f6:	0e 94 63 16 	call	0x2cc6	; 0x2cc6 <pvPortMalloc>
    26fa:	9b 83       	std	Y+3, r25	; 0x03
    26fc:	8a 83       	std	Y+2, r24	; 0x02
	if( pxCoRoutine )
    26fe:	8a 81       	ldd	r24, Y+2	; 0x02
    2700:	9b 81       	ldd	r25, Y+3	; 0x03
    2702:	00 97       	sbiw	r24, 0x00	; 0
    2704:	09 f4       	brne	.+2      	; 0x2708 <xCoRoutineCreate+0x32>
    2706:	77 c0       	rjmp	.+238    	; 0x27f6 <xCoRoutineCreate+0x120>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    2708:	80 91 87 02 	lds	r24, 0x0287
    270c:	90 91 88 02 	lds	r25, 0x0288
    2710:	00 97       	sbiw	r24, 0x00	; 0
    2712:	41 f4       	brne	.+16     	; 0x2724 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    2714:	8a 81       	ldd	r24, Y+2	; 0x02
    2716:	9b 81       	ldd	r25, Y+3	; 0x03
    2718:	90 93 88 02 	sts	0x0288, r25
    271c:	80 93 87 02 	sts	0x0287, r24
			prvInitialiseCoRoutineLists();
    2720:	0e 94 f1 15 	call	0x2be2	; 0x2be2 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    2724:	8e 81       	ldd	r24, Y+6	; 0x06
    2726:	82 30       	cpi	r24, 0x02	; 2
    2728:	10 f0       	brcs	.+4      	; 0x272e <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    272a:	81 e0       	ldi	r24, 0x01	; 1
    272c:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    272e:	8a 81       	ldd	r24, Y+2	; 0x02
    2730:	9b 81       	ldd	r25, Y+3	; 0x03
    2732:	fc 01       	movw	r30, r24
    2734:	11 8e       	std	Z+25, r1	; 0x19
    2736:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    2738:	8a 81       	ldd	r24, Y+2	; 0x02
    273a:	9b 81       	ldd	r25, Y+3	; 0x03
    273c:	2e 81       	ldd	r18, Y+6	; 0x06
    273e:	fc 01       	movw	r30, r24
    2740:	26 8b       	std	Z+22, r18	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    2742:	8a 81       	ldd	r24, Y+2	; 0x02
    2744:	9b 81       	ldd	r25, Y+3	; 0x03
    2746:	2f 81       	ldd	r18, Y+7	; 0x07
    2748:	fc 01       	movw	r30, r24
    274a:	27 8b       	std	Z+23, r18	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    274c:	8a 81       	ldd	r24, Y+2	; 0x02
    274e:	9b 81       	ldd	r25, Y+3	; 0x03
    2750:	2c 81       	ldd	r18, Y+4	; 0x04
    2752:	3d 81       	ldd	r19, Y+5	; 0x05
    2754:	fc 01       	movw	r30, r24
    2756:	31 83       	std	Z+1, r19	; 0x01
    2758:	20 83       	st	Z, r18

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    275a:	8a 81       	ldd	r24, Y+2	; 0x02
    275c:	9b 81       	ldd	r25, Y+3	; 0x03
    275e:	02 96       	adiw	r24, 0x02	; 2
    2760:	0e 94 32 12 	call	0x2464	; 0x2464 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    2764:	8a 81       	ldd	r24, Y+2	; 0x02
    2766:	9b 81       	ldd	r25, Y+3	; 0x03
    2768:	0c 96       	adiw	r24, 0x0c	; 12
    276a:	0e 94 32 12 	call	0x2464	; 0x2464 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    276e:	8a 81       	ldd	r24, Y+2	; 0x02
    2770:	9b 81       	ldd	r25, Y+3	; 0x03
    2772:	2a 81       	ldd	r18, Y+2	; 0x02
    2774:	3b 81       	ldd	r19, Y+3	; 0x03
    2776:	fc 01       	movw	r30, r24
    2778:	31 87       	std	Z+9, r19	; 0x09
    277a:	20 87       	std	Z+8, r18	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    277c:	8a 81       	ldd	r24, Y+2	; 0x02
    277e:	9b 81       	ldd	r25, Y+3	; 0x03
    2780:	2a 81       	ldd	r18, Y+2	; 0x02
    2782:	3b 81       	ldd	r19, Y+3	; 0x03
    2784:	fc 01       	movw	r30, r24
    2786:	33 8b       	std	Z+19, r19	; 0x13
    2788:	22 8b       	std	Z+18, r18	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    278a:	8e 81       	ldd	r24, Y+6	; 0x06
    278c:	88 2f       	mov	r24, r24
    278e:	90 e0       	ldi	r25, 0x00	; 0
    2790:	24 e0       	ldi	r18, 0x04	; 4
    2792:	30 e0       	ldi	r19, 0x00	; 0
    2794:	28 1b       	sub	r18, r24
    2796:	39 0b       	sbc	r19, r25
    2798:	8a 81       	ldd	r24, Y+2	; 0x02
    279a:	9b 81       	ldd	r25, Y+3	; 0x03
    279c:	fc 01       	movw	r30, r24
    279e:	35 87       	std	Z+13, r19	; 0x0d
    27a0:	24 87       	std	Z+12, r18	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    27a2:	8a 81       	ldd	r24, Y+2	; 0x02
    27a4:	9b 81       	ldd	r25, Y+3	; 0x03
    27a6:	fc 01       	movw	r30, r24
    27a8:	96 89       	ldd	r25, Z+22	; 0x16
    27aa:	80 91 ba 02 	lds	r24, 0x02BA
    27ae:	89 17       	cp	r24, r25
    27b0:	30 f4       	brcc	.+12     	; 0x27be <xCoRoutineCreate+0xe8>
    27b2:	8a 81       	ldd	r24, Y+2	; 0x02
    27b4:	9b 81       	ldd	r25, Y+3	; 0x03
    27b6:	fc 01       	movw	r30, r24
    27b8:	86 89       	ldd	r24, Z+22	; 0x16
    27ba:	80 93 ba 02 	sts	0x02BA, r24
    27be:	8a 81       	ldd	r24, Y+2	; 0x02
    27c0:	9b 81       	ldd	r25, Y+3	; 0x03
    27c2:	ac 01       	movw	r20, r24
    27c4:	4e 5f       	subi	r20, 0xFE	; 254
    27c6:	5f 4f       	sbci	r21, 0xFF	; 255
    27c8:	8a 81       	ldd	r24, Y+2	; 0x02
    27ca:	9b 81       	ldd	r25, Y+3	; 0x03
    27cc:	fc 01       	movw	r30, r24
    27ce:	86 89       	ldd	r24, Z+22	; 0x16
    27d0:	28 2f       	mov	r18, r24
    27d2:	30 e0       	ldi	r19, 0x00	; 0
    27d4:	c9 01       	movw	r24, r18
    27d6:	88 0f       	add	r24, r24
    27d8:	99 1f       	adc	r25, r25
    27da:	88 0f       	add	r24, r24
    27dc:	99 1f       	adc	r25, r25
    27de:	88 0f       	add	r24, r24
    27e0:	99 1f       	adc	r25, r25
    27e2:	82 0f       	add	r24, r18
    27e4:	93 1f       	adc	r25, r19
    27e6:	87 57       	subi	r24, 0x77	; 119
    27e8:	9d 4f       	sbci	r25, 0xFD	; 253
    27ea:	ba 01       	movw	r22, r20
    27ec:	0e 94 44 12 	call	0x2488	; 0x2488 <vListInsertEnd>

		xReturn = pdPASS;
    27f0:	81 e0       	ldi	r24, 0x01	; 1
    27f2:	89 83       	std	Y+1, r24	; 0x01
    27f4:	02 c0       	rjmp	.+4      	; 0x27fa <xCoRoutineCreate+0x124>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    27f6:	8f ef       	ldi	r24, 0xFF	; 255
    27f8:	89 83       	std	Y+1, r24	; 0x01
	}
	
	return xReturn;	
    27fa:	89 81       	ldd	r24, Y+1	; 0x01
}
    27fc:	27 96       	adiw	r28, 0x07	; 7
    27fe:	0f b6       	in	r0, 0x3f	; 63
    2800:	f8 94       	cli
    2802:	de bf       	out	0x3e, r29	; 62
    2804:	0f be       	out	0x3f, r0	; 63
    2806:	cd bf       	out	0x3d, r28	; 61
    2808:	df 91       	pop	r29
    280a:	cf 91       	pop	r28
    280c:	08 95       	ret

0000280e <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    280e:	cf 93       	push	r28
    2810:	df 93       	push	r29
    2812:	00 d0       	rcall	.+0      	; 0x2814 <vCoRoutineAddToDelayedList+0x6>
    2814:	00 d0       	rcall	.+0      	; 0x2816 <vCoRoutineAddToDelayedList+0x8>
    2816:	cd b7       	in	r28, 0x3d	; 61
    2818:	de b7       	in	r29, 0x3e	; 62
    281a:	9c 83       	std	Y+4, r25	; 0x04
    281c:	8b 83       	std	Y+3, r24	; 0x03
    281e:	7e 83       	std	Y+6, r23	; 0x06
    2820:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    2822:	20 91 bb 02 	lds	r18, 0x02BB
    2826:	30 91 bc 02 	lds	r19, 0x02BC
    282a:	8b 81       	ldd	r24, Y+3	; 0x03
    282c:	9c 81       	ldd	r25, Y+4	; 0x04
    282e:	82 0f       	add	r24, r18
    2830:	93 1f       	adc	r25, r19
    2832:	9a 83       	std	Y+2, r25	; 0x02
    2834:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2836:	80 91 87 02 	lds	r24, 0x0287
    283a:	90 91 88 02 	lds	r25, 0x0288
    283e:	02 96       	adiw	r24, 0x02	; 2
    2840:	0e 94 14 13 	call	0x2628	; 0x2628 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    2844:	80 91 87 02 	lds	r24, 0x0287
    2848:	90 91 88 02 	lds	r25, 0x0288
    284c:	29 81       	ldd	r18, Y+1	; 0x01
    284e:	3a 81       	ldd	r19, Y+2	; 0x02
    2850:	fc 01       	movw	r30, r24
    2852:	33 83       	std	Z+3, r19	; 0x03
    2854:	22 83       	std	Z+2, r18	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    2856:	80 91 bb 02 	lds	r24, 0x02BB
    285a:	90 91 bc 02 	lds	r25, 0x02BC
    285e:	29 81       	ldd	r18, Y+1	; 0x01
    2860:	3a 81       	ldd	r19, Y+2	; 0x02
    2862:	28 17       	cp	r18, r24
    2864:	39 07       	cpc	r19, r25
    2866:	78 f4       	brcc	.+30     	; 0x2886 <vCoRoutineAddToDelayedList+0x78>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2868:	80 91 87 02 	lds	r24, 0x0287
    286c:	90 91 88 02 	lds	r25, 0x0288
    2870:	9c 01       	movw	r18, r24
    2872:	2e 5f       	subi	r18, 0xFE	; 254
    2874:	3f 4f       	sbci	r19, 0xFF	; 255
    2876:	80 91 af 02 	lds	r24, 0x02AF
    287a:	90 91 b0 02 	lds	r25, 0x02B0
    287e:	b9 01       	movw	r22, r18
    2880:	0e 94 9b 12 	call	0x2536	; 0x2536 <vListInsert>
    2884:	0e c0       	rjmp	.+28     	; 0x28a2 <vCoRoutineAddToDelayedList+0x94>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2886:	80 91 87 02 	lds	r24, 0x0287
    288a:	90 91 88 02 	lds	r25, 0x0288
    288e:	9c 01       	movw	r18, r24
    2890:	2e 5f       	subi	r18, 0xFE	; 254
    2892:	3f 4f       	sbci	r19, 0xFF	; 255
    2894:	80 91 ad 02 	lds	r24, 0x02AD
    2898:	90 91 ae 02 	lds	r25, 0x02AE
    289c:	b9 01       	movw	r22, r18
    289e:	0e 94 9b 12 	call	0x2536	; 0x2536 <vListInsert>
	}

	if( pxEventList )
    28a2:	8d 81       	ldd	r24, Y+5	; 0x05
    28a4:	9e 81       	ldd	r25, Y+6	; 0x06
    28a6:	00 97       	sbiw	r24, 0x00	; 0
    28a8:	61 f0       	breq	.+24     	; 0x28c2 <vCoRoutineAddToDelayedList+0xb4>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    28aa:	80 91 87 02 	lds	r24, 0x0287
    28ae:	90 91 88 02 	lds	r25, 0x0288
    28b2:	9c 01       	movw	r18, r24
    28b4:	24 5f       	subi	r18, 0xF4	; 244
    28b6:	3f 4f       	sbci	r19, 0xFF	; 255
    28b8:	8d 81       	ldd	r24, Y+5	; 0x05
    28ba:	9e 81       	ldd	r25, Y+6	; 0x06
    28bc:	b9 01       	movw	r22, r18
    28be:	0e 94 9b 12 	call	0x2536	; 0x2536 <vListInsert>
	}
}
    28c2:	26 96       	adiw	r28, 0x06	; 6
    28c4:	0f b6       	in	r0, 0x3f	; 63
    28c6:	f8 94       	cli
    28c8:	de bf       	out	0x3e, r29	; 62
    28ca:	0f be       	out	0x3f, r0	; 63
    28cc:	cd bf       	out	0x3d, r28	; 61
    28ce:	df 91       	pop	r29
    28d0:	cf 91       	pop	r28
    28d2:	08 95       	ret

000028d4 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    28d4:	cf 93       	push	r28
    28d6:	df 93       	push	r29
    28d8:	1f 92       	push	r1
    28da:	1f 92       	push	r1
    28dc:	cd b7       	in	r28, 0x3d	; 61
    28de:	de b7       	in	r29, 0x3e	; 62
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    28e0:	3c c0       	rjmp	.+120    	; 0x295a <prvCheckPendingReadyList+0x86>
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    28e2:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    28e4:	80 91 b6 02 	lds	r24, 0x02B6
    28e8:	90 91 b7 02 	lds	r25, 0x02B7
    28ec:	fc 01       	movw	r30, r24
    28ee:	86 81       	ldd	r24, Z+6	; 0x06
    28f0:	97 81       	ldd	r25, Z+7	; 0x07
    28f2:	9a 83       	std	Y+2, r25	; 0x02
    28f4:	89 83       	std	Y+1, r24	; 0x01
			uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    28f6:	89 81       	ldd	r24, Y+1	; 0x01
    28f8:	9a 81       	ldd	r25, Y+2	; 0x02
    28fa:	0c 96       	adiw	r24, 0x0c	; 12
    28fc:	0e 94 14 13 	call	0x2628	; 0x2628 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    2900:	78 94       	sei

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    2902:	89 81       	ldd	r24, Y+1	; 0x01
    2904:	9a 81       	ldd	r25, Y+2	; 0x02
    2906:	02 96       	adiw	r24, 0x02	; 2
    2908:	0e 94 14 13 	call	0x2628	; 0x2628 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    290c:	89 81       	ldd	r24, Y+1	; 0x01
    290e:	9a 81       	ldd	r25, Y+2	; 0x02
    2910:	fc 01       	movw	r30, r24
    2912:	96 89       	ldd	r25, Z+22	; 0x16
    2914:	80 91 ba 02 	lds	r24, 0x02BA
    2918:	89 17       	cp	r24, r25
    291a:	30 f4       	brcc	.+12     	; 0x2928 <prvCheckPendingReadyList+0x54>
    291c:	89 81       	ldd	r24, Y+1	; 0x01
    291e:	9a 81       	ldd	r25, Y+2	; 0x02
    2920:	fc 01       	movw	r30, r24
    2922:	86 89       	ldd	r24, Z+22	; 0x16
    2924:	80 93 ba 02 	sts	0x02BA, r24
    2928:	89 81       	ldd	r24, Y+1	; 0x01
    292a:	9a 81       	ldd	r25, Y+2	; 0x02
    292c:	ac 01       	movw	r20, r24
    292e:	4e 5f       	subi	r20, 0xFE	; 254
    2930:	5f 4f       	sbci	r21, 0xFF	; 255
    2932:	89 81       	ldd	r24, Y+1	; 0x01
    2934:	9a 81       	ldd	r25, Y+2	; 0x02
    2936:	fc 01       	movw	r30, r24
    2938:	86 89       	ldd	r24, Z+22	; 0x16
    293a:	28 2f       	mov	r18, r24
    293c:	30 e0       	ldi	r19, 0x00	; 0
    293e:	c9 01       	movw	r24, r18
    2940:	88 0f       	add	r24, r24
    2942:	99 1f       	adc	r25, r25
    2944:	88 0f       	add	r24, r24
    2946:	99 1f       	adc	r25, r25
    2948:	88 0f       	add	r24, r24
    294a:	99 1f       	adc	r25, r25
    294c:	82 0f       	add	r24, r18
    294e:	93 1f       	adc	r25, r19
    2950:	87 57       	subi	r24, 0x77	; 119
    2952:	9d 4f       	sbci	r25, 0xFD	; 253
    2954:	ba 01       	movw	r22, r20
    2956:	0e 94 44 12 	call	0x2488	; 0x2488 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    295a:	80 91 b1 02 	lds	r24, 0x02B1
    295e:	88 23       	and	r24, r24
    2960:	09 f0       	breq	.+2      	; 0x2964 <prvCheckPendingReadyList+0x90>
    2962:	bf cf       	rjmp	.-130    	; 0x28e2 <prvCheckPendingReadyList+0xe>
		portENABLE_INTERRUPTS();

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    2964:	0f 90       	pop	r0
    2966:	0f 90       	pop	r0
    2968:	df 91       	pop	r29
    296a:	cf 91       	pop	r28
    296c:	08 95       	ret

0000296e <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    296e:	cf 93       	push	r28
    2970:	df 93       	push	r29
    2972:	00 d0       	rcall	.+0      	; 0x2974 <prvCheckDelayedList+0x6>
    2974:	1f 92       	push	r1
    2976:	cd b7       	in	r28, 0x3d	; 61
    2978:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    297a:	0e 94 c5 06 	call	0xd8a	; 0xd8a <xTaskGetTickCount>
    297e:	9c 01       	movw	r18, r24
    2980:	80 91 bd 02 	lds	r24, 0x02BD
    2984:	90 91 be 02 	lds	r25, 0x02BE
    2988:	a9 01       	movw	r20, r18
    298a:	48 1b       	sub	r20, r24
    298c:	59 0b       	sbc	r21, r25
    298e:	ca 01       	movw	r24, r20
    2990:	90 93 c0 02 	sts	0x02C0, r25
    2994:	80 93 bf 02 	sts	0x02BF, r24
	while( xPassedTicks )
    2998:	8a c0       	rjmp	.+276    	; 0x2aae <prvCheckDelayedList+0x140>
	{
		xCoRoutineTickCount++;
    299a:	80 91 bb 02 	lds	r24, 0x02BB
    299e:	90 91 bc 02 	lds	r25, 0x02BC
    29a2:	01 96       	adiw	r24, 0x01	; 1
    29a4:	90 93 bc 02 	sts	0x02BC, r25
    29a8:	80 93 bb 02 	sts	0x02BB, r24
		xPassedTicks--;
    29ac:	80 91 bf 02 	lds	r24, 0x02BF
    29b0:	90 91 c0 02 	lds	r25, 0x02C0
    29b4:	01 97       	sbiw	r24, 0x01	; 1
    29b6:	90 93 c0 02 	sts	0x02C0, r25
    29ba:	80 93 bf 02 	sts	0x02BF, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    29be:	80 91 bb 02 	lds	r24, 0x02BB
    29c2:	90 91 bc 02 	lds	r25, 0x02BC
    29c6:	00 97       	sbiw	r24, 0x00	; 0
    29c8:	a9 f4       	brne	.+42     	; 0x29f4 <prvCheckDelayedList+0x86>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    29ca:	80 91 ad 02 	lds	r24, 0x02AD
    29ce:	90 91 ae 02 	lds	r25, 0x02AE
    29d2:	9a 83       	std	Y+2, r25	; 0x02
    29d4:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    29d6:	80 91 af 02 	lds	r24, 0x02AF
    29da:	90 91 b0 02 	lds	r25, 0x02B0
    29de:	90 93 ae 02 	sts	0x02AE, r25
    29e2:	80 93 ad 02 	sts	0x02AD, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    29e6:	89 81       	ldd	r24, Y+1	; 0x01
    29e8:	9a 81       	ldd	r25, Y+2	; 0x02
    29ea:	90 93 b0 02 	sts	0x02B0, r25
    29ee:	80 93 af 02 	sts	0x02AF, r24
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    29f2:	54 c0       	rjmp	.+168    	; 0x2a9c <prvCheckDelayedList+0x12e>
    29f4:	53 c0       	rjmp	.+166    	; 0x2a9c <prvCheckDelayedList+0x12e>
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    29f6:	80 91 ad 02 	lds	r24, 0x02AD
    29fa:	90 91 ae 02 	lds	r25, 0x02AE
    29fe:	fc 01       	movw	r30, r24
    2a00:	85 81       	ldd	r24, Z+5	; 0x05
    2a02:	96 81       	ldd	r25, Z+6	; 0x06
    2a04:	fc 01       	movw	r30, r24
    2a06:	86 81       	ldd	r24, Z+6	; 0x06
    2a08:	97 81       	ldd	r25, Z+7	; 0x07
    2a0a:	9c 83       	std	Y+4, r25	; 0x04
    2a0c:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    2a0e:	8b 81       	ldd	r24, Y+3	; 0x03
    2a10:	9c 81       	ldd	r25, Y+4	; 0x04
    2a12:	fc 01       	movw	r30, r24
    2a14:	22 81       	ldd	r18, Z+2	; 0x02
    2a16:	33 81       	ldd	r19, Z+3	; 0x03
    2a18:	80 91 bb 02 	lds	r24, 0x02BB
    2a1c:	90 91 bc 02 	lds	r25, 0x02BC
    2a20:	82 17       	cp	r24, r18
    2a22:	93 07       	cpc	r25, r19
    2a24:	08 f4       	brcc	.+2      	; 0x2a28 <prvCheckDelayedList+0xba>
			{			
				/* Timeout not yet expired. */																			
				break;																				
    2a26:	43 c0       	rjmp	.+134    	; 0x2aae <prvCheckDelayedList+0x140>
			}																						

			portDISABLE_INTERRUPTS();
    2a28:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				uxListRemove( &( pxCRCB->xGenericListItem ) );											
    2a2a:	8b 81       	ldd	r24, Y+3	; 0x03
    2a2c:	9c 81       	ldd	r25, Y+4	; 0x04
    2a2e:	02 96       	adiw	r24, 0x02	; 2
    2a30:	0e 94 14 13 	call	0x2628	; 0x2628 <uxListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    2a34:	8b 81       	ldd	r24, Y+3	; 0x03
    2a36:	9c 81       	ldd	r25, Y+4	; 0x04
    2a38:	fc 01       	movw	r30, r24
    2a3a:	84 89       	ldd	r24, Z+20	; 0x14
    2a3c:	95 89       	ldd	r25, Z+21	; 0x15
    2a3e:	00 97       	sbiw	r24, 0x00	; 0
    2a40:	29 f0       	breq	.+10     	; 0x2a4c <prvCheckDelayedList+0xde>
				{															
					uxListRemove( &( pxCRCB->xEventListItem ) );											
    2a42:	8b 81       	ldd	r24, Y+3	; 0x03
    2a44:	9c 81       	ldd	r25, Y+4	; 0x04
    2a46:	0c 96       	adiw	r24, 0x0c	; 12
    2a48:	0e 94 14 13 	call	0x2628	; 0x2628 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    2a4c:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    2a4e:	8b 81       	ldd	r24, Y+3	; 0x03
    2a50:	9c 81       	ldd	r25, Y+4	; 0x04
    2a52:	fc 01       	movw	r30, r24
    2a54:	96 89       	ldd	r25, Z+22	; 0x16
    2a56:	80 91 ba 02 	lds	r24, 0x02BA
    2a5a:	89 17       	cp	r24, r25
    2a5c:	30 f4       	brcc	.+12     	; 0x2a6a <prvCheckDelayedList+0xfc>
    2a5e:	8b 81       	ldd	r24, Y+3	; 0x03
    2a60:	9c 81       	ldd	r25, Y+4	; 0x04
    2a62:	fc 01       	movw	r30, r24
    2a64:	86 89       	ldd	r24, Z+22	; 0x16
    2a66:	80 93 ba 02 	sts	0x02BA, r24
    2a6a:	8b 81       	ldd	r24, Y+3	; 0x03
    2a6c:	9c 81       	ldd	r25, Y+4	; 0x04
    2a6e:	ac 01       	movw	r20, r24
    2a70:	4e 5f       	subi	r20, 0xFE	; 254
    2a72:	5f 4f       	sbci	r21, 0xFF	; 255
    2a74:	8b 81       	ldd	r24, Y+3	; 0x03
    2a76:	9c 81       	ldd	r25, Y+4	; 0x04
    2a78:	fc 01       	movw	r30, r24
    2a7a:	86 89       	ldd	r24, Z+22	; 0x16
    2a7c:	28 2f       	mov	r18, r24
    2a7e:	30 e0       	ldi	r19, 0x00	; 0
    2a80:	c9 01       	movw	r24, r18
    2a82:	88 0f       	add	r24, r24
    2a84:	99 1f       	adc	r25, r25
    2a86:	88 0f       	add	r24, r24
    2a88:	99 1f       	adc	r25, r25
    2a8a:	88 0f       	add	r24, r24
    2a8c:	99 1f       	adc	r25, r25
    2a8e:	82 0f       	add	r24, r18
    2a90:	93 1f       	adc	r25, r19
    2a92:	87 57       	subi	r24, 0x77	; 119
    2a94:	9d 4f       	sbci	r25, 0xFD	; 253
    2a96:	ba 01       	movw	r22, r20
    2a98:	0e 94 44 12 	call	0x2488	; 0x2488 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    2a9c:	80 91 ad 02 	lds	r24, 0x02AD
    2aa0:	90 91 ae 02 	lds	r25, 0x02AE
    2aa4:	fc 01       	movw	r30, r24
    2aa6:	80 81       	ld	r24, Z
    2aa8:	88 23       	and	r24, r24
    2aaa:	09 f0       	breq	.+2      	; 0x2aae <prvCheckDelayedList+0x140>
    2aac:	a4 cf       	rjmp	.-184    	; 0x29f6 <prvCheckDelayedList+0x88>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    2aae:	80 91 bf 02 	lds	r24, 0x02BF
    2ab2:	90 91 c0 02 	lds	r25, 0x02C0
    2ab6:	00 97       	sbiw	r24, 0x00	; 0
    2ab8:	09 f0       	breq	.+2      	; 0x2abc <prvCheckDelayedList+0x14e>
    2aba:	6f cf       	rjmp	.-290    	; 0x299a <prvCheckDelayedList+0x2c>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    2abc:	80 91 bb 02 	lds	r24, 0x02BB
    2ac0:	90 91 bc 02 	lds	r25, 0x02BC
    2ac4:	90 93 be 02 	sts	0x02BE, r25
    2ac8:	80 93 bd 02 	sts	0x02BD, r24
}
    2acc:	0f 90       	pop	r0
    2ace:	0f 90       	pop	r0
    2ad0:	0f 90       	pop	r0
    2ad2:	0f 90       	pop	r0
    2ad4:	df 91       	pop	r29
    2ad6:	cf 91       	pop	r28
    2ad8:	08 95       	ret

00002ada <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    2ada:	cf 93       	push	r28
    2adc:	df 93       	push	r29
    2ade:	1f 92       	push	r1
    2ae0:	1f 92       	push	r1
    2ae2:	cd b7       	in	r28, 0x3d	; 61
    2ae4:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    2ae6:	0e 94 6a 14 	call	0x28d4	; 0x28d4 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    2aea:	0e 94 b7 14 	call	0x296e	; 0x296e <prvCheckDelayedList>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2aee:	0a c0       	rjmp	.+20     	; 0x2b04 <vCoRoutineSchedule+0x2a>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    2af0:	80 91 ba 02 	lds	r24, 0x02BA
    2af4:	88 23       	and	r24, r24
    2af6:	09 f4       	brne	.+2      	; 0x2afa <vCoRoutineSchedule+0x20>
		{
			/* No more co-routines to check. */
			return;
    2af8:	6f c0       	rjmp	.+222    	; 0x2bd8 <vCoRoutineSchedule+0xfe>
		}
		--uxTopCoRoutineReadyPriority;
    2afa:	80 91 ba 02 	lds	r24, 0x02BA
    2afe:	81 50       	subi	r24, 0x01	; 1
    2b00:	80 93 ba 02 	sts	0x02BA, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2b04:	80 91 ba 02 	lds	r24, 0x02BA
    2b08:	28 2f       	mov	r18, r24
    2b0a:	30 e0       	ldi	r19, 0x00	; 0
    2b0c:	c9 01       	movw	r24, r18
    2b0e:	88 0f       	add	r24, r24
    2b10:	99 1f       	adc	r25, r25
    2b12:	88 0f       	add	r24, r24
    2b14:	99 1f       	adc	r25, r25
    2b16:	88 0f       	add	r24, r24
    2b18:	99 1f       	adc	r25, r25
    2b1a:	82 0f       	add	r24, r18
    2b1c:	93 1f       	adc	r25, r19
    2b1e:	87 57       	subi	r24, 0x77	; 119
    2b20:	9d 4f       	sbci	r25, 0xFD	; 253
    2b22:	fc 01       	movw	r30, r24
    2b24:	80 81       	ld	r24, Z
    2b26:	88 23       	and	r24, r24
    2b28:	19 f3       	breq	.-58     	; 0x2af0 <vCoRoutineSchedule+0x16>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    2b2a:	80 91 ba 02 	lds	r24, 0x02BA
    2b2e:	28 2f       	mov	r18, r24
    2b30:	30 e0       	ldi	r19, 0x00	; 0
    2b32:	c9 01       	movw	r24, r18
    2b34:	88 0f       	add	r24, r24
    2b36:	99 1f       	adc	r25, r25
    2b38:	88 0f       	add	r24, r24
    2b3a:	99 1f       	adc	r25, r25
    2b3c:	88 0f       	add	r24, r24
    2b3e:	99 1f       	adc	r25, r25
    2b40:	82 0f       	add	r24, r18
    2b42:	93 1f       	adc	r25, r19
    2b44:	87 57       	subi	r24, 0x77	; 119
    2b46:	9d 4f       	sbci	r25, 0xFD	; 253
    2b48:	9a 83       	std	Y+2, r25	; 0x02
    2b4a:	89 83       	std	Y+1, r24	; 0x01
    2b4c:	89 81       	ldd	r24, Y+1	; 0x01
    2b4e:	9a 81       	ldd	r25, Y+2	; 0x02
    2b50:	fc 01       	movw	r30, r24
    2b52:	81 81       	ldd	r24, Z+1	; 0x01
    2b54:	92 81       	ldd	r25, Z+2	; 0x02
    2b56:	fc 01       	movw	r30, r24
    2b58:	22 81       	ldd	r18, Z+2	; 0x02
    2b5a:	33 81       	ldd	r19, Z+3	; 0x03
    2b5c:	89 81       	ldd	r24, Y+1	; 0x01
    2b5e:	9a 81       	ldd	r25, Y+2	; 0x02
    2b60:	fc 01       	movw	r30, r24
    2b62:	32 83       	std	Z+2, r19	; 0x02
    2b64:	21 83       	std	Z+1, r18	; 0x01
    2b66:	89 81       	ldd	r24, Y+1	; 0x01
    2b68:	9a 81       	ldd	r25, Y+2	; 0x02
    2b6a:	fc 01       	movw	r30, r24
    2b6c:	21 81       	ldd	r18, Z+1	; 0x01
    2b6e:	32 81       	ldd	r19, Z+2	; 0x02
    2b70:	89 81       	ldd	r24, Y+1	; 0x01
    2b72:	9a 81       	ldd	r25, Y+2	; 0x02
    2b74:	03 96       	adiw	r24, 0x03	; 3
    2b76:	28 17       	cp	r18, r24
    2b78:	39 07       	cpc	r19, r25
    2b7a:	69 f4       	brne	.+26     	; 0x2b96 <vCoRoutineSchedule+0xbc>
    2b7c:	89 81       	ldd	r24, Y+1	; 0x01
    2b7e:	9a 81       	ldd	r25, Y+2	; 0x02
    2b80:	fc 01       	movw	r30, r24
    2b82:	81 81       	ldd	r24, Z+1	; 0x01
    2b84:	92 81       	ldd	r25, Z+2	; 0x02
    2b86:	fc 01       	movw	r30, r24
    2b88:	22 81       	ldd	r18, Z+2	; 0x02
    2b8a:	33 81       	ldd	r19, Z+3	; 0x03
    2b8c:	89 81       	ldd	r24, Y+1	; 0x01
    2b8e:	9a 81       	ldd	r25, Y+2	; 0x02
    2b90:	fc 01       	movw	r30, r24
    2b92:	32 83       	std	Z+2, r19	; 0x02
    2b94:	21 83       	std	Z+1, r18	; 0x01
    2b96:	89 81       	ldd	r24, Y+1	; 0x01
    2b98:	9a 81       	ldd	r25, Y+2	; 0x02
    2b9a:	fc 01       	movw	r30, r24
    2b9c:	81 81       	ldd	r24, Z+1	; 0x01
    2b9e:	92 81       	ldd	r25, Z+2	; 0x02
    2ba0:	fc 01       	movw	r30, r24
    2ba2:	86 81       	ldd	r24, Z+6	; 0x06
    2ba4:	97 81       	ldd	r25, Z+7	; 0x07
    2ba6:	90 93 88 02 	sts	0x0288, r25
    2baa:	80 93 87 02 	sts	0x0287, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2bae:	80 91 87 02 	lds	r24, 0x0287
    2bb2:	90 91 88 02 	lds	r25, 0x0288
    2bb6:	fc 01       	movw	r30, r24
    2bb8:	20 81       	ld	r18, Z
    2bba:	31 81       	ldd	r19, Z+1	; 0x01
    2bbc:	80 91 87 02 	lds	r24, 0x0287
    2bc0:	90 91 88 02 	lds	r25, 0x0288
    2bc4:	fc 01       	movw	r30, r24
    2bc6:	47 89       	ldd	r20, Z+23	; 0x17
    2bc8:	80 91 87 02 	lds	r24, 0x0287
    2bcc:	90 91 88 02 	lds	r25, 0x0288
    2bd0:	64 2f       	mov	r22, r20
    2bd2:	f9 01       	movw	r30, r18
    2bd4:	19 95       	eicall

	return;
    2bd6:	00 00       	nop
}
    2bd8:	0f 90       	pop	r0
    2bda:	0f 90       	pop	r0
    2bdc:	df 91       	pop	r29
    2bde:	cf 91       	pop	r28
    2be0:	08 95       	ret

00002be2 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    2be2:	cf 93       	push	r28
    2be4:	df 93       	push	r29
    2be6:	1f 92       	push	r1
    2be8:	cd b7       	in	r28, 0x3d	; 61
    2bea:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2bec:	19 82       	std	Y+1, r1	; 0x01
    2bee:	13 c0       	rjmp	.+38     	; 0x2c16 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    2bf0:	89 81       	ldd	r24, Y+1	; 0x01
    2bf2:	28 2f       	mov	r18, r24
    2bf4:	30 e0       	ldi	r19, 0x00	; 0
    2bf6:	c9 01       	movw	r24, r18
    2bf8:	88 0f       	add	r24, r24
    2bfa:	99 1f       	adc	r25, r25
    2bfc:	88 0f       	add	r24, r24
    2bfe:	99 1f       	adc	r25, r25
    2c00:	88 0f       	add	r24, r24
    2c02:	99 1f       	adc	r25, r25
    2c04:	82 0f       	add	r24, r18
    2c06:	93 1f       	adc	r25, r19
    2c08:	87 57       	subi	r24, 0x77	; 119
    2c0a:	9d 4f       	sbci	r25, 0xFD	; 253
    2c0c:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2c10:	89 81       	ldd	r24, Y+1	; 0x01
    2c12:	8f 5f       	subi	r24, 0xFF	; 255
    2c14:	89 83       	std	Y+1, r24	; 0x01
    2c16:	89 81       	ldd	r24, Y+1	; 0x01
    2c18:	82 30       	cpi	r24, 0x02	; 2
    2c1a:	50 f3       	brcs	.-44     	; 0x2bf0 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    2c1c:	8b e9       	ldi	r24, 0x9B	; 155
    2c1e:	92 e0       	ldi	r25, 0x02	; 2
    2c20:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    2c24:	84 ea       	ldi	r24, 0xA4	; 164
    2c26:	92 e0       	ldi	r25, 0x02	; 2
    2c28:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    2c2c:	81 eb       	ldi	r24, 0xB1	; 177
    2c2e:	92 e0       	ldi	r25, 0x02	; 2
    2c30:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    2c34:	8b e9       	ldi	r24, 0x9B	; 155
    2c36:	92 e0       	ldi	r25, 0x02	; 2
    2c38:	90 93 ae 02 	sts	0x02AE, r25
    2c3c:	80 93 ad 02 	sts	0x02AD, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    2c40:	84 ea       	ldi	r24, 0xA4	; 164
    2c42:	92 e0       	ldi	r25, 0x02	; 2
    2c44:	90 93 b0 02 	sts	0x02B0, r25
    2c48:	80 93 af 02 	sts	0x02AF, r24
}
    2c4c:	0f 90       	pop	r0
    2c4e:	df 91       	pop	r29
    2c50:	cf 91       	pop	r28
    2c52:	08 95       	ret

00002c54 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    2c54:	cf 93       	push	r28
    2c56:	df 93       	push	r29
    2c58:	00 d0       	rcall	.+0      	; 0x2c5a <xCoRoutineRemoveFromEventList+0x6>
    2c5a:	1f 92       	push	r1
    2c5c:	1f 92       	push	r1
    2c5e:	cd b7       	in	r28, 0x3d	; 61
    2c60:	de b7       	in	r29, 0x3e	; 62
    2c62:	9d 83       	std	Y+5, r25	; 0x05
    2c64:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2c66:	8c 81       	ldd	r24, Y+4	; 0x04
    2c68:	9d 81       	ldd	r25, Y+5	; 0x05
    2c6a:	fc 01       	movw	r30, r24
    2c6c:	85 81       	ldd	r24, Z+5	; 0x05
    2c6e:	96 81       	ldd	r25, Z+6	; 0x06
    2c70:	fc 01       	movw	r30, r24
    2c72:	86 81       	ldd	r24, Z+6	; 0x06
    2c74:	97 81       	ldd	r25, Z+7	; 0x07
    2c76:	9b 83       	std	Y+3, r25	; 0x03
    2c78:	8a 83       	std	Y+2, r24	; 0x02
	uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2c7a:	8a 81       	ldd	r24, Y+2	; 0x02
    2c7c:	9b 81       	ldd	r25, Y+3	; 0x03
    2c7e:	0c 96       	adiw	r24, 0x0c	; 12
    2c80:	0e 94 14 13 	call	0x2628	; 0x2628 <uxListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    2c84:	8a 81       	ldd	r24, Y+2	; 0x02
    2c86:	9b 81       	ldd	r25, Y+3	; 0x03
    2c88:	0c 96       	adiw	r24, 0x0c	; 12
    2c8a:	bc 01       	movw	r22, r24
    2c8c:	81 eb       	ldi	r24, 0xB1	; 177
    2c8e:	92 e0       	ldi	r25, 0x02	; 2
    2c90:	0e 94 44 12 	call	0x2488	; 0x2488 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    2c94:	8a 81       	ldd	r24, Y+2	; 0x02
    2c96:	9b 81       	ldd	r25, Y+3	; 0x03
    2c98:	fc 01       	movw	r30, r24
    2c9a:	26 89       	ldd	r18, Z+22	; 0x16
    2c9c:	80 91 87 02 	lds	r24, 0x0287
    2ca0:	90 91 88 02 	lds	r25, 0x0288
    2ca4:	fc 01       	movw	r30, r24
    2ca6:	86 89       	ldd	r24, Z+22	; 0x16
    2ca8:	28 17       	cp	r18, r24
    2caa:	18 f0       	brcs	.+6      	; 0x2cb2 <xCoRoutineRemoveFromEventList+0x5e>
	{
		xReturn = pdTRUE;
    2cac:	81 e0       	ldi	r24, 0x01	; 1
    2cae:	89 83       	std	Y+1, r24	; 0x01
    2cb0:	01 c0       	rjmp	.+2      	; 0x2cb4 <xCoRoutineRemoveFromEventList+0x60>
	}
	else
	{
		xReturn = pdFALSE;
    2cb2:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2cb4:	89 81       	ldd	r24, Y+1	; 0x01
}
    2cb6:	0f 90       	pop	r0
    2cb8:	0f 90       	pop	r0
    2cba:	0f 90       	pop	r0
    2cbc:	0f 90       	pop	r0
    2cbe:	0f 90       	pop	r0
    2cc0:	df 91       	pop	r29
    2cc2:	cf 91       	pop	r28
    2cc4:	08 95       	ret

00002cc6 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2cc6:	cf 93       	push	r28
    2cc8:	df 93       	push	r29
    2cca:	00 d0       	rcall	.+0      	; 0x2ccc <pvPortMalloc+0x6>
    2ccc:	1f 92       	push	r1
    2cce:	cd b7       	in	r28, 0x3d	; 61
    2cd0:	de b7       	in	r29, 0x3e	; 62
    2cd2:	9c 83       	std	Y+4, r25	; 0x04
    2cd4:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    2cd6:	1a 82       	std	Y+2, r1	; 0x02
    2cd8:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    2cda:	0e 94 35 06 	call	0xc6a	; 0xc6a <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    2cde:	20 91 c1 1a 	lds	r18, 0x1AC1
    2ce2:	30 91 c2 1a 	lds	r19, 0x1AC2
    2ce6:	8b 81       	ldd	r24, Y+3	; 0x03
    2ce8:	9c 81       	ldd	r25, Y+4	; 0x04
    2cea:	82 0f       	add	r24, r18
    2cec:	93 1f       	adc	r25, r19
    2cee:	81 15       	cp	r24, r1
    2cf0:	28 e1       	ldi	r18, 0x18	; 24
    2cf2:	92 07       	cpc	r25, r18
    2cf4:	18 f5       	brcc	.+70     	; 0x2d3c <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
    2cf6:	20 91 c1 1a 	lds	r18, 0x1AC1
    2cfa:	30 91 c2 1a 	lds	r19, 0x1AC2
    2cfe:	8b 81       	ldd	r24, Y+3	; 0x03
    2d00:	9c 81       	ldd	r25, Y+4	; 0x04
    2d02:	28 0f       	add	r18, r24
    2d04:	39 1f       	adc	r19, r25
    2d06:	80 91 c1 1a 	lds	r24, 0x1AC1
    2d0a:	90 91 c2 1a 	lds	r25, 0x1AC2
	#endif

	vTaskSuspendAll();
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    2d0e:	82 17       	cp	r24, r18
    2d10:	93 07       	cpc	r25, r19
    2d12:	a0 f4       	brcc	.+40     	; 0x2d3c <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    2d14:	80 91 c1 1a 	lds	r24, 0x1AC1
    2d18:	90 91 c2 1a 	lds	r25, 0x1AC2
    2d1c:	8f 53       	subi	r24, 0x3F	; 63
    2d1e:	9d 4f       	sbci	r25, 0xFD	; 253
    2d20:	9a 83       	std	Y+2, r25	; 0x02
    2d22:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    2d24:	20 91 c1 1a 	lds	r18, 0x1AC1
    2d28:	30 91 c2 1a 	lds	r19, 0x1AC2
    2d2c:	8b 81       	ldd	r24, Y+3	; 0x03
    2d2e:	9c 81       	ldd	r25, Y+4	; 0x04
    2d30:	82 0f       	add	r24, r18
    2d32:	93 1f       	adc	r25, r19
    2d34:	90 93 c2 1a 	sts	0x1AC2, r25
    2d38:	80 93 c1 1a 	sts	0x1AC1, r24
		}
	}
	xTaskResumeAll();
    2d3c:	0e 94 41 06 	call	0xc82	; 0xc82 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    2d40:	89 81       	ldd	r24, Y+1	; 0x01
    2d42:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2d44:	0f 90       	pop	r0
    2d46:	0f 90       	pop	r0
    2d48:	0f 90       	pop	r0
    2d4a:	0f 90       	pop	r0
    2d4c:	df 91       	pop	r29
    2d4e:	cf 91       	pop	r28
    2d50:	08 95       	ret

00002d52 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2d52:	cf 93       	push	r28
    2d54:	df 93       	push	r29
    2d56:	1f 92       	push	r1
    2d58:	1f 92       	push	r1
    2d5a:	cd b7       	in	r28, 0x3d	; 61
    2d5c:	de b7       	in	r29, 0x3e	; 62
    2d5e:	9a 83       	std	Y+2, r25	; 0x02
    2d60:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    2d62:	0f 90       	pop	r0
    2d64:	0f 90       	pop	r0
    2d66:	df 91       	pop	r29
    2d68:	cf 91       	pop	r28
    2d6a:	08 95       	ret

00002d6c <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    2d6c:	cf 93       	push	r28
    2d6e:	df 93       	push	r29
    2d70:	cd b7       	in	r28, 0x3d	; 61
    2d72:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    2d74:	10 92 c2 1a 	sts	0x1AC2, r1
    2d78:	10 92 c1 1a 	sts	0x1AC1, r1
}
    2d7c:	df 91       	pop	r29
    2d7e:	cf 91       	pop	r28
    2d80:	08 95       	ret

00002d82 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    2d82:	cf 93       	push	r28
    2d84:	df 93       	push	r29
    2d86:	cd b7       	in	r28, 0x3d	; 61
    2d88:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    2d8a:	80 91 c1 1a 	lds	r24, 0x1AC1
    2d8e:	90 91 c2 1a 	lds	r25, 0x1AC2
    2d92:	20 e0       	ldi	r18, 0x00	; 0
    2d94:	38 e1       	ldi	r19, 0x18	; 24
    2d96:	a9 01       	movw	r20, r18
    2d98:	48 1b       	sub	r20, r24
    2d9a:	59 0b       	sbc	r21, r25
    2d9c:	ca 01       	movw	r24, r20
}
    2d9e:	df 91       	pop	r29
    2da0:	cf 91       	pop	r28
    2da2:	08 95       	ret

00002da4 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    2da4:	cf 93       	push	r28
    2da6:	df 93       	push	r29
    2da8:	cd b7       	in	r28, 0x3d	; 61
    2daa:	de b7       	in	r29, 0x3e	; 62
    2dac:	28 97       	sbiw	r28, 0x08	; 8
    2dae:	0f b6       	in	r0, 0x3f	; 63
    2db0:	f8 94       	cli
    2db2:	de bf       	out	0x3e, r29	; 62
    2db4:	0f be       	out	0x3f, r0	; 63
    2db6:	cd bf       	out	0x3d, r28	; 61
    2db8:	9c 83       	std	Y+4, r25	; 0x04
    2dba:	8b 83       	std	Y+3, r24	; 0x03
    2dbc:	7e 83       	std	Y+6, r23	; 0x06
    2dbe:	6d 83       	std	Y+5, r22	; 0x05
    2dc0:	58 87       	std	Y+8, r21	; 0x08
    2dc2:	4f 83       	std	Y+7, r20	; 0x07
#endif

	/* Place a few bytes of known values on the bottom of the stack.
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2dc4:	8b 81       	ldd	r24, Y+3	; 0x03
    2dc6:	9c 81       	ldd	r25, Y+4	; 0x04
    2dc8:	21 e1       	ldi	r18, 0x11	; 17
    2dca:	fc 01       	movw	r30, r24
    2dcc:	20 83       	st	Z, r18
	pxTopOfStack--;
    2dce:	8b 81       	ldd	r24, Y+3	; 0x03
    2dd0:	9c 81       	ldd	r25, Y+4	; 0x04
    2dd2:	01 97       	sbiw	r24, 0x01	; 1
    2dd4:	9c 83       	std	Y+4, r25	; 0x04
    2dd6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    2dd8:	8b 81       	ldd	r24, Y+3	; 0x03
    2dda:	9c 81       	ldd	r25, Y+4	; 0x04
    2ddc:	22 e2       	ldi	r18, 0x22	; 34
    2dde:	fc 01       	movw	r30, r24
    2de0:	20 83       	st	Z, r18
	pxTopOfStack--;
    2de2:	8b 81       	ldd	r24, Y+3	; 0x03
    2de4:	9c 81       	ldd	r25, Y+4	; 0x04
    2de6:	01 97       	sbiw	r24, 0x01	; 1
    2de8:	9c 83       	std	Y+4, r25	; 0x04
    2dea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    2dec:	8b 81       	ldd	r24, Y+3	; 0x03
    2dee:	9c 81       	ldd	r25, Y+4	; 0x04
    2df0:	23 e3       	ldi	r18, 0x33	; 51
    2df2:	fc 01       	movw	r30, r24
    2df4:	20 83       	st	Z, r18
	pxTopOfStack--;
    2df6:	8b 81       	ldd	r24, Y+3	; 0x03
    2df8:	9c 81       	ldd	r25, Y+4	; 0x04
    2dfa:	01 97       	sbiw	r24, 0x01	; 1
    2dfc:	9c 83       	std	Y+4, r25	; 0x04
    2dfe:	8b 83       	std	Y+3, r24	; 0x03
	 * of flash. We do this by adding the .task label in the linker script.
	 *
	 * In order to do this properly, we would need to get a full 3-byte pointer to
	 * pxCode.  That requires a change to GCC.  Not likely to happen any time soon.
	 */
	usAddress = ( unsigned portSHORT ) pxCode;
    2e00:	8d 81       	ldd	r24, Y+5	; 0x05
    2e02:	9e 81       	ldd	r25, Y+6	; 0x06
    2e04:	9a 83       	std	Y+2, r25	; 0x02
    2e06:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    2e08:	29 81       	ldd	r18, Y+1	; 0x01
    2e0a:	8b 81       	ldd	r24, Y+3	; 0x03
    2e0c:	9c 81       	ldd	r25, Y+4	; 0x04
    2e0e:	fc 01       	movw	r30, r24
    2e10:	20 83       	st	Z, r18
	pxTopOfStack--;
    2e12:	8b 81       	ldd	r24, Y+3	; 0x03
    2e14:	9c 81       	ldd	r25, Y+4	; 0x04
    2e16:	01 97       	sbiw	r24, 0x01	; 1
    2e18:	9c 83       	std	Y+4, r25	; 0x04
    2e1a:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2e1c:	89 81       	ldd	r24, Y+1	; 0x01
    2e1e:	9a 81       	ldd	r25, Y+2	; 0x02
    2e20:	89 2f       	mov	r24, r25
    2e22:	99 27       	eor	r25, r25
    2e24:	9a 83       	std	Y+2, r25	; 0x02
    2e26:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    2e28:	29 81       	ldd	r18, Y+1	; 0x01
    2e2a:	8b 81       	ldd	r24, Y+3	; 0x03
    2e2c:	9c 81       	ldd	r25, Y+4	; 0x04
    2e2e:	fc 01       	movw	r30, r24
    2e30:	20 83       	st	Z, r18
	pxTopOfStack--;
    2e32:	8b 81       	ldd	r24, Y+3	; 0x03
    2e34:	9c 81       	ldd	r25, Y+4	; 0x04
    2e36:	01 97       	sbiw	r24, 0x01	; 1
    2e38:	9c 83       	std	Y+4, r25	; 0x04
    2e3a:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = 0;
    2e3c:	8b 81       	ldd	r24, Y+3	; 0x03
    2e3e:	9c 81       	ldd	r25, Y+4	; 0x04
    2e40:	fc 01       	movw	r30, r24
    2e42:	10 82       	st	Z, r1
	pxTopOfStack--;
    2e44:	8b 81       	ldd	r24, Y+3	; 0x03
    2e46:	9c 81       	ldd	r25, Y+4	; 0x04
    2e48:	01 97       	sbiw	r24, 0x01	; 1
    2e4a:	9c 83       	std	Y+4, r25	; 0x04
    2e4c:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    2e4e:	8b 81       	ldd	r24, Y+3	; 0x03
    2e50:	9c 81       	ldd	r25, Y+4	; 0x04
    2e52:	fc 01       	movw	r30, r24
    2e54:	10 82       	st	Z, r1
	pxTopOfStack--;
    2e56:	8b 81       	ldd	r24, Y+3	; 0x03
    2e58:	9c 81       	ldd	r25, Y+4	; 0x04
    2e5a:	01 97       	sbiw	r24, 0x01	; 1
    2e5c:	9c 83       	std	Y+4, r25	; 0x04
    2e5e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2e60:	8b 81       	ldd	r24, Y+3	; 0x03
    2e62:	9c 81       	ldd	r25, Y+4	; 0x04
    2e64:	20 e8       	ldi	r18, 0x80	; 128
    2e66:	fc 01       	movw	r30, r24
    2e68:	20 83       	st	Z, r18
	pxTopOfStack--;
    2e6a:	8b 81       	ldd	r24, Y+3	; 0x03
    2e6c:	9c 81       	ldd	r25, Y+4	; 0x04
    2e6e:	01 97       	sbiw	r24, 0x01	; 1
    2e70:	9c 83       	std	Y+4, r25	; 0x04
    2e72:	8b 83       	std	Y+3, r24	; 0x03
#if defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

	/* If we have an ATmega256x, we are also saving the RAMPZ and EIND registers.
	 * We should default those to 0.
	 */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* EIND */
    2e74:	8b 81       	ldd	r24, Y+3	; 0x03
    2e76:	9c 81       	ldd	r25, Y+4	; 0x04
    2e78:	fc 01       	movw	r30, r24
    2e7a:	10 82       	st	Z, r1
	pxTopOfStack--;
    2e7c:	8b 81       	ldd	r24, Y+3	; 0x03
    2e7e:	9c 81       	ldd	r25, Y+4	; 0x04
    2e80:	01 97       	sbiw	r24, 0x01	; 1
    2e82:	9c 83       	std	Y+4, r25	; 0x04
    2e84:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* RAMPZ */
    2e86:	8b 81       	ldd	r24, Y+3	; 0x03
    2e88:	9c 81       	ldd	r25, Y+4	; 0x04
    2e8a:	fc 01       	movw	r30, r24
    2e8c:	10 82       	st	Z, r1
	pxTopOfStack--;
    2e8e:	8b 81       	ldd	r24, Y+3	; 0x03
    2e90:	9c 81       	ldd	r25, Y+4	; 0x04
    2e92:	01 97       	sbiw	r24, 0x01	; 1
    2e94:	9c 83       	std	Y+4, r25	; 0x04
    2e96:	8b 83       	std	Y+3, r24	; 0x03

#endif

	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    2e98:	8b 81       	ldd	r24, Y+3	; 0x03
    2e9a:	9c 81       	ldd	r25, Y+4	; 0x04
    2e9c:	fc 01       	movw	r30, r24
    2e9e:	10 82       	st	Z, r1
	pxTopOfStack--;
    2ea0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ea2:	9c 81       	ldd	r25, Y+4	; 0x04
    2ea4:	01 97       	sbiw	r24, 0x01	; 1
    2ea6:	9c 83       	std	Y+4, r25	; 0x04
    2ea8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    2eaa:	8b 81       	ldd	r24, Y+3	; 0x03
    2eac:	9c 81       	ldd	r25, Y+4	; 0x04
    2eae:	22 e0       	ldi	r18, 0x02	; 2
    2eb0:	fc 01       	movw	r30, r24
    2eb2:	20 83       	st	Z, r18
	pxTopOfStack--;
    2eb4:	8b 81       	ldd	r24, Y+3	; 0x03
    2eb6:	9c 81       	ldd	r25, Y+4	; 0x04
    2eb8:	01 97       	sbiw	r24, 0x01	; 1
    2eba:	9c 83       	std	Y+4, r25	; 0x04
    2ebc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    2ebe:	8b 81       	ldd	r24, Y+3	; 0x03
    2ec0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ec2:	23 e0       	ldi	r18, 0x03	; 3
    2ec4:	fc 01       	movw	r30, r24
    2ec6:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ec8:	8b 81       	ldd	r24, Y+3	; 0x03
    2eca:	9c 81       	ldd	r25, Y+4	; 0x04
    2ecc:	01 97       	sbiw	r24, 0x01	; 1
    2ece:	9c 83       	std	Y+4, r25	; 0x04
    2ed0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    2ed2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ed4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ed6:	24 e0       	ldi	r18, 0x04	; 4
    2ed8:	fc 01       	movw	r30, r24
    2eda:	20 83       	st	Z, r18
	pxTopOfStack--;
    2edc:	8b 81       	ldd	r24, Y+3	; 0x03
    2ede:	9c 81       	ldd	r25, Y+4	; 0x04
    2ee0:	01 97       	sbiw	r24, 0x01	; 1
    2ee2:	9c 83       	std	Y+4, r25	; 0x04
    2ee4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    2ee6:	8b 81       	ldd	r24, Y+3	; 0x03
    2ee8:	9c 81       	ldd	r25, Y+4	; 0x04
    2eea:	25 e0       	ldi	r18, 0x05	; 5
    2eec:	fc 01       	movw	r30, r24
    2eee:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ef0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ef2:	9c 81       	ldd	r25, Y+4	; 0x04
    2ef4:	01 97       	sbiw	r24, 0x01	; 1
    2ef6:	9c 83       	std	Y+4, r25	; 0x04
    2ef8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    2efa:	8b 81       	ldd	r24, Y+3	; 0x03
    2efc:	9c 81       	ldd	r25, Y+4	; 0x04
    2efe:	26 e0       	ldi	r18, 0x06	; 6
    2f00:	fc 01       	movw	r30, r24
    2f02:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f04:	8b 81       	ldd	r24, Y+3	; 0x03
    2f06:	9c 81       	ldd	r25, Y+4	; 0x04
    2f08:	01 97       	sbiw	r24, 0x01	; 1
    2f0a:	9c 83       	std	Y+4, r25	; 0x04
    2f0c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    2f0e:	8b 81       	ldd	r24, Y+3	; 0x03
    2f10:	9c 81       	ldd	r25, Y+4	; 0x04
    2f12:	27 e0       	ldi	r18, 0x07	; 7
    2f14:	fc 01       	movw	r30, r24
    2f16:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f18:	8b 81       	ldd	r24, Y+3	; 0x03
    2f1a:	9c 81       	ldd	r25, Y+4	; 0x04
    2f1c:	01 97       	sbiw	r24, 0x01	; 1
    2f1e:	9c 83       	std	Y+4, r25	; 0x04
    2f20:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    2f22:	8b 81       	ldd	r24, Y+3	; 0x03
    2f24:	9c 81       	ldd	r25, Y+4	; 0x04
    2f26:	28 e0       	ldi	r18, 0x08	; 8
    2f28:	fc 01       	movw	r30, r24
    2f2a:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f2c:	8b 81       	ldd	r24, Y+3	; 0x03
    2f2e:	9c 81       	ldd	r25, Y+4	; 0x04
    2f30:	01 97       	sbiw	r24, 0x01	; 1
    2f32:	9c 83       	std	Y+4, r25	; 0x04
    2f34:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    2f36:	8b 81       	ldd	r24, Y+3	; 0x03
    2f38:	9c 81       	ldd	r25, Y+4	; 0x04
    2f3a:	29 e0       	ldi	r18, 0x09	; 9
    2f3c:	fc 01       	movw	r30, r24
    2f3e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f40:	8b 81       	ldd	r24, Y+3	; 0x03
    2f42:	9c 81       	ldd	r25, Y+4	; 0x04
    2f44:	01 97       	sbiw	r24, 0x01	; 1
    2f46:	9c 83       	std	Y+4, r25	; 0x04
    2f48:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    2f4a:	8b 81       	ldd	r24, Y+3	; 0x03
    2f4c:	9c 81       	ldd	r25, Y+4	; 0x04
    2f4e:	20 e1       	ldi	r18, 0x10	; 16
    2f50:	fc 01       	movw	r30, r24
    2f52:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f54:	8b 81       	ldd	r24, Y+3	; 0x03
    2f56:	9c 81       	ldd	r25, Y+4	; 0x04
    2f58:	01 97       	sbiw	r24, 0x01	; 1
    2f5a:	9c 83       	std	Y+4, r25	; 0x04
    2f5c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    2f5e:	8b 81       	ldd	r24, Y+3	; 0x03
    2f60:	9c 81       	ldd	r25, Y+4	; 0x04
    2f62:	21 e1       	ldi	r18, 0x11	; 17
    2f64:	fc 01       	movw	r30, r24
    2f66:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f68:	8b 81       	ldd	r24, Y+3	; 0x03
    2f6a:	9c 81       	ldd	r25, Y+4	; 0x04
    2f6c:	01 97       	sbiw	r24, 0x01	; 1
    2f6e:	9c 83       	std	Y+4, r25	; 0x04
    2f70:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    2f72:	8b 81       	ldd	r24, Y+3	; 0x03
    2f74:	9c 81       	ldd	r25, Y+4	; 0x04
    2f76:	22 e1       	ldi	r18, 0x12	; 18
    2f78:	fc 01       	movw	r30, r24
    2f7a:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f7c:	8b 81       	ldd	r24, Y+3	; 0x03
    2f7e:	9c 81       	ldd	r25, Y+4	; 0x04
    2f80:	01 97       	sbiw	r24, 0x01	; 1
    2f82:	9c 83       	std	Y+4, r25	; 0x04
    2f84:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    2f86:	8b 81       	ldd	r24, Y+3	; 0x03
    2f88:	9c 81       	ldd	r25, Y+4	; 0x04
    2f8a:	23 e1       	ldi	r18, 0x13	; 19
    2f8c:	fc 01       	movw	r30, r24
    2f8e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f90:	8b 81       	ldd	r24, Y+3	; 0x03
    2f92:	9c 81       	ldd	r25, Y+4	; 0x04
    2f94:	01 97       	sbiw	r24, 0x01	; 1
    2f96:	9c 83       	std	Y+4, r25	; 0x04
    2f98:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    2f9a:	8b 81       	ldd	r24, Y+3	; 0x03
    2f9c:	9c 81       	ldd	r25, Y+4	; 0x04
    2f9e:	24 e1       	ldi	r18, 0x14	; 20
    2fa0:	fc 01       	movw	r30, r24
    2fa2:	20 83       	st	Z, r18
	pxTopOfStack--;
    2fa4:	8b 81       	ldd	r24, Y+3	; 0x03
    2fa6:	9c 81       	ldd	r25, Y+4	; 0x04
    2fa8:	01 97       	sbiw	r24, 0x01	; 1
    2faa:	9c 83       	std	Y+4, r25	; 0x04
    2fac:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    2fae:	8b 81       	ldd	r24, Y+3	; 0x03
    2fb0:	9c 81       	ldd	r25, Y+4	; 0x04
    2fb2:	25 e1       	ldi	r18, 0x15	; 21
    2fb4:	fc 01       	movw	r30, r24
    2fb6:	20 83       	st	Z, r18
	pxTopOfStack--;
    2fb8:	8b 81       	ldd	r24, Y+3	; 0x03
    2fba:	9c 81       	ldd	r25, Y+4	; 0x04
    2fbc:	01 97       	sbiw	r24, 0x01	; 1
    2fbe:	9c 83       	std	Y+4, r25	; 0x04
    2fc0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    2fc2:	8b 81       	ldd	r24, Y+3	; 0x03
    2fc4:	9c 81       	ldd	r25, Y+4	; 0x04
    2fc6:	26 e1       	ldi	r18, 0x16	; 22
    2fc8:	fc 01       	movw	r30, r24
    2fca:	20 83       	st	Z, r18
	pxTopOfStack--;
    2fcc:	8b 81       	ldd	r24, Y+3	; 0x03
    2fce:	9c 81       	ldd	r25, Y+4	; 0x04
    2fd0:	01 97       	sbiw	r24, 0x01	; 1
    2fd2:	9c 83       	std	Y+4, r25	; 0x04
    2fd4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    2fd6:	8b 81       	ldd	r24, Y+3	; 0x03
    2fd8:	9c 81       	ldd	r25, Y+4	; 0x04
    2fda:	27 e1       	ldi	r18, 0x17	; 23
    2fdc:	fc 01       	movw	r30, r24
    2fde:	20 83       	st	Z, r18
	pxTopOfStack--;
    2fe0:	8b 81       	ldd	r24, Y+3	; 0x03
    2fe2:	9c 81       	ldd	r25, Y+4	; 0x04
    2fe4:	01 97       	sbiw	r24, 0x01	; 1
    2fe6:	9c 83       	std	Y+4, r25	; 0x04
    2fe8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    2fea:	8b 81       	ldd	r24, Y+3	; 0x03
    2fec:	9c 81       	ldd	r25, Y+4	; 0x04
    2fee:	28 e1       	ldi	r18, 0x18	; 24
    2ff0:	fc 01       	movw	r30, r24
    2ff2:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ff4:	8b 81       	ldd	r24, Y+3	; 0x03
    2ff6:	9c 81       	ldd	r25, Y+4	; 0x04
    2ff8:	01 97       	sbiw	r24, 0x01	; 1
    2ffa:	9c 83       	std	Y+4, r25	; 0x04
    2ffc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    2ffe:	8b 81       	ldd	r24, Y+3	; 0x03
    3000:	9c 81       	ldd	r25, Y+4	; 0x04
    3002:	29 e1       	ldi	r18, 0x19	; 25
    3004:	fc 01       	movw	r30, r24
    3006:	20 83       	st	Z, r18
	pxTopOfStack--;
    3008:	8b 81       	ldd	r24, Y+3	; 0x03
    300a:	9c 81       	ldd	r25, Y+4	; 0x04
    300c:	01 97       	sbiw	r24, 0x01	; 1
    300e:	9c 83       	std	Y+4, r25	; 0x04
    3010:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    3012:	8b 81       	ldd	r24, Y+3	; 0x03
    3014:	9c 81       	ldd	r25, Y+4	; 0x04
    3016:	20 e2       	ldi	r18, 0x20	; 32
    3018:	fc 01       	movw	r30, r24
    301a:	20 83       	st	Z, r18
	pxTopOfStack--;
    301c:	8b 81       	ldd	r24, Y+3	; 0x03
    301e:	9c 81       	ldd	r25, Y+4	; 0x04
    3020:	01 97       	sbiw	r24, 0x01	; 1
    3022:	9c 83       	std	Y+4, r25	; 0x04
    3024:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    3026:	8b 81       	ldd	r24, Y+3	; 0x03
    3028:	9c 81       	ldd	r25, Y+4	; 0x04
    302a:	21 e2       	ldi	r18, 0x21	; 33
    302c:	fc 01       	movw	r30, r24
    302e:	20 83       	st	Z, r18
	pxTopOfStack--;
    3030:	8b 81       	ldd	r24, Y+3	; 0x03
    3032:	9c 81       	ldd	r25, Y+4	; 0x04
    3034:	01 97       	sbiw	r24, 0x01	; 1
    3036:	9c 83       	std	Y+4, r25	; 0x04
    3038:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    303a:	8b 81       	ldd	r24, Y+3	; 0x03
    303c:	9c 81       	ldd	r25, Y+4	; 0x04
    303e:	22 e2       	ldi	r18, 0x22	; 34
    3040:	fc 01       	movw	r30, r24
    3042:	20 83       	st	Z, r18
	pxTopOfStack--;
    3044:	8b 81       	ldd	r24, Y+3	; 0x03
    3046:	9c 81       	ldd	r25, Y+4	; 0x04
    3048:	01 97       	sbiw	r24, 0x01	; 1
    304a:	9c 83       	std	Y+4, r25	; 0x04
    304c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    304e:	8b 81       	ldd	r24, Y+3	; 0x03
    3050:	9c 81       	ldd	r25, Y+4	; 0x04
    3052:	23 e2       	ldi	r18, 0x23	; 35
    3054:	fc 01       	movw	r30, r24
    3056:	20 83       	st	Z, r18
	pxTopOfStack--;
    3058:	8b 81       	ldd	r24, Y+3	; 0x03
    305a:	9c 81       	ldd	r25, Y+4	; 0x04
    305c:	01 97       	sbiw	r24, 0x01	; 1
    305e:	9c 83       	std	Y+4, r25	; 0x04
    3060:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    3062:	8f 81       	ldd	r24, Y+7	; 0x07
    3064:	98 85       	ldd	r25, Y+8	; 0x08
    3066:	9a 83       	std	Y+2, r25	; 0x02
    3068:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    306a:	29 81       	ldd	r18, Y+1	; 0x01
    306c:	8b 81       	ldd	r24, Y+3	; 0x03
    306e:	9c 81       	ldd	r25, Y+4	; 0x04
    3070:	fc 01       	movw	r30, r24
    3072:	20 83       	st	Z, r18
	pxTopOfStack--;
    3074:	8b 81       	ldd	r24, Y+3	; 0x03
    3076:	9c 81       	ldd	r25, Y+4	; 0x04
    3078:	01 97       	sbiw	r24, 0x01	; 1
    307a:	9c 83       	std	Y+4, r25	; 0x04
    307c:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    307e:	89 81       	ldd	r24, Y+1	; 0x01
    3080:	9a 81       	ldd	r25, Y+2	; 0x02
    3082:	89 2f       	mov	r24, r25
    3084:	99 27       	eor	r25, r25
    3086:	9a 83       	std	Y+2, r25	; 0x02
    3088:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    308a:	29 81       	ldd	r18, Y+1	; 0x01
    308c:	8b 81       	ldd	r24, Y+3	; 0x03
    308e:	9c 81       	ldd	r25, Y+4	; 0x04
    3090:	fc 01       	movw	r30, r24
    3092:	20 83       	st	Z, r18
	pxTopOfStack--;
    3094:	8b 81       	ldd	r24, Y+3	; 0x03
    3096:	9c 81       	ldd	r25, Y+4	; 0x04
    3098:	01 97       	sbiw	r24, 0x01	; 1
    309a:	9c 83       	std	Y+4, r25	; 0x04
    309c:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    309e:	8b 81       	ldd	r24, Y+3	; 0x03
    30a0:	9c 81       	ldd	r25, Y+4	; 0x04
    30a2:	26 e2       	ldi	r18, 0x26	; 38
    30a4:	fc 01       	movw	r30, r24
    30a6:	20 83       	st	Z, r18
	pxTopOfStack--;
    30a8:	8b 81       	ldd	r24, Y+3	; 0x03
    30aa:	9c 81       	ldd	r25, Y+4	; 0x04
    30ac:	01 97       	sbiw	r24, 0x01	; 1
    30ae:	9c 83       	std	Y+4, r25	; 0x04
    30b0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    30b2:	8b 81       	ldd	r24, Y+3	; 0x03
    30b4:	9c 81       	ldd	r25, Y+4	; 0x04
    30b6:	27 e2       	ldi	r18, 0x27	; 39
    30b8:	fc 01       	movw	r30, r24
    30ba:	20 83       	st	Z, r18
	pxTopOfStack--;
    30bc:	8b 81       	ldd	r24, Y+3	; 0x03
    30be:	9c 81       	ldd	r25, Y+4	; 0x04
    30c0:	01 97       	sbiw	r24, 0x01	; 1
    30c2:	9c 83       	std	Y+4, r25	; 0x04
    30c4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    30c6:	8b 81       	ldd	r24, Y+3	; 0x03
    30c8:	9c 81       	ldd	r25, Y+4	; 0x04
    30ca:	28 e2       	ldi	r18, 0x28	; 40
    30cc:	fc 01       	movw	r30, r24
    30ce:	20 83       	st	Z, r18
	pxTopOfStack--;
    30d0:	8b 81       	ldd	r24, Y+3	; 0x03
    30d2:	9c 81       	ldd	r25, Y+4	; 0x04
    30d4:	01 97       	sbiw	r24, 0x01	; 1
    30d6:	9c 83       	std	Y+4, r25	; 0x04
    30d8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    30da:	8b 81       	ldd	r24, Y+3	; 0x03
    30dc:	9c 81       	ldd	r25, Y+4	; 0x04
    30de:	29 e2       	ldi	r18, 0x29	; 41
    30e0:	fc 01       	movw	r30, r24
    30e2:	20 83       	st	Z, r18
	pxTopOfStack--;
    30e4:	8b 81       	ldd	r24, Y+3	; 0x03
    30e6:	9c 81       	ldd	r25, Y+4	; 0x04
    30e8:	01 97       	sbiw	r24, 0x01	; 1
    30ea:	9c 83       	std	Y+4, r25	; 0x04
    30ec:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    30ee:	8b 81       	ldd	r24, Y+3	; 0x03
    30f0:	9c 81       	ldd	r25, Y+4	; 0x04
    30f2:	20 e3       	ldi	r18, 0x30	; 48
    30f4:	fc 01       	movw	r30, r24
    30f6:	20 83       	st	Z, r18
	pxTopOfStack--;
    30f8:	8b 81       	ldd	r24, Y+3	; 0x03
    30fa:	9c 81       	ldd	r25, Y+4	; 0x04
    30fc:	01 97       	sbiw	r24, 0x01	; 1
    30fe:	9c 83       	std	Y+4, r25	; 0x04
    3100:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    3102:	8b 81       	ldd	r24, Y+3	; 0x03
    3104:	9c 81       	ldd	r25, Y+4	; 0x04
    3106:	21 e3       	ldi	r18, 0x31	; 49
    3108:	fc 01       	movw	r30, r24
    310a:	20 83       	st	Z, r18
	pxTopOfStack--;
    310c:	8b 81       	ldd	r24, Y+3	; 0x03
    310e:	9c 81       	ldd	r25, Y+4	; 0x04
    3110:	01 97       	sbiw	r24, 0x01	; 1
    3112:	9c 83       	std	Y+4, r25	; 0x04
    3114:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    3116:	8b 81       	ldd	r24, Y+3	; 0x03
    3118:	9c 81       	ldd	r25, Y+4	; 0x04
}
    311a:	28 96       	adiw	r28, 0x08	; 8
    311c:	0f b6       	in	r0, 0x3f	; 63
    311e:	f8 94       	cli
    3120:	de bf       	out	0x3e, r29	; 62
    3122:	0f be       	out	0x3f, r0	; 63
    3124:	cd bf       	out	0x3d, r28	; 61
    3126:	df 91       	pop	r29
    3128:	cf 91       	pop	r28
    312a:	08 95       	ret

0000312c <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    312c:	cf 93       	push	r28
    312e:	df 93       	push	r29
    3130:	cd b7       	in	r28, 0x3d	; 61
    3132:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    3134:	0e 94 9a 19 	call	0x3334	; 0x3334 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    3138:	a0 91 2e 02 	lds	r26, 0x022E
    313c:	b0 91 2f 02 	lds	r27, 0x022F
    3140:	cd 91       	ld	r28, X+
    3142:	cd bf       	out	0x3d, r28	; 61
    3144:	dd 91       	ld	r29, X+
    3146:	de bf       	out	0x3e, r29	; 62
    3148:	ff 91       	pop	r31
    314a:	ef 91       	pop	r30
    314c:	df 91       	pop	r29
    314e:	cf 91       	pop	r28
    3150:	bf 91       	pop	r27
    3152:	af 91       	pop	r26
    3154:	9f 91       	pop	r25
    3156:	8f 91       	pop	r24
    3158:	7f 91       	pop	r23
    315a:	6f 91       	pop	r22
    315c:	5f 91       	pop	r21
    315e:	4f 91       	pop	r20
    3160:	3f 91       	pop	r19
    3162:	2f 91       	pop	r18
    3164:	1f 91       	pop	r17
    3166:	0f 91       	pop	r16
    3168:	ff 90       	pop	r15
    316a:	ef 90       	pop	r14
    316c:	df 90       	pop	r13
    316e:	cf 90       	pop	r12
    3170:	bf 90       	pop	r11
    3172:	af 90       	pop	r10
    3174:	9f 90       	pop	r9
    3176:	8f 90       	pop	r8
    3178:	7f 90       	pop	r7
    317a:	6f 90       	pop	r6
    317c:	5f 90       	pop	r5
    317e:	4f 90       	pop	r4
    3180:	3f 90       	pop	r3
    3182:	2f 90       	pop	r2
    3184:	1f 90       	pop	r1
    3186:	0f 90       	pop	r0
    3188:	0c be       	out	0x3c, r0	; 60
    318a:	0f 90       	pop	r0
    318c:	0b be       	out	0x3b, r0	; 59
    318e:	0f 90       	pop	r0
    3190:	0f be       	out	0x3f, r0	; 63
    3192:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    3194:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    3196:	81 e0       	ldi	r24, 0x01	; 1
}
    3198:	df 91       	pop	r29
    319a:	cf 91       	pop	r28
    319c:	08 95       	ret

0000319e <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    319e:	cf 93       	push	r28
    31a0:	df 93       	push	r29
    31a2:	cd b7       	in	r28, 0x3d	; 61
    31a4:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    31a6:	df 91       	pop	r29
    31a8:	cf 91       	pop	r28
    31aa:	08 95       	ret

000031ac <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    31ac:	0f 92       	push	r0
    31ae:	0f b6       	in	r0, 0x3f	; 63
    31b0:	f8 94       	cli
    31b2:	0f 92       	push	r0
    31b4:	0b b6       	in	r0, 0x3b	; 59
    31b6:	0f 92       	push	r0
    31b8:	0c b6       	in	r0, 0x3c	; 60
    31ba:	0f 92       	push	r0
    31bc:	1f 92       	push	r1
    31be:	11 24       	eor	r1, r1
    31c0:	2f 92       	push	r2
    31c2:	3f 92       	push	r3
    31c4:	4f 92       	push	r4
    31c6:	5f 92       	push	r5
    31c8:	6f 92       	push	r6
    31ca:	7f 92       	push	r7
    31cc:	8f 92       	push	r8
    31ce:	9f 92       	push	r9
    31d0:	af 92       	push	r10
    31d2:	bf 92       	push	r11
    31d4:	cf 92       	push	r12
    31d6:	df 92       	push	r13
    31d8:	ef 92       	push	r14
    31da:	ff 92       	push	r15
    31dc:	0f 93       	push	r16
    31de:	1f 93       	push	r17
    31e0:	2f 93       	push	r18
    31e2:	3f 93       	push	r19
    31e4:	4f 93       	push	r20
    31e6:	5f 93       	push	r21
    31e8:	6f 93       	push	r22
    31ea:	7f 93       	push	r23
    31ec:	8f 93       	push	r24
    31ee:	9f 93       	push	r25
    31f0:	af 93       	push	r26
    31f2:	bf 93       	push	r27
    31f4:	cf 93       	push	r28
    31f6:	df 93       	push	r29
    31f8:	ef 93       	push	r30
    31fa:	ff 93       	push	r31
    31fc:	a0 91 2e 02 	lds	r26, 0x022E
    3200:	b0 91 2f 02 	lds	r27, 0x022F
    3204:	0d b6       	in	r0, 0x3d	; 61
    3206:	0d 92       	st	X+, r0
    3208:	0e b6       	in	r0, 0x3e	; 62
    320a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    320c:	0e 94 d7 07 	call	0xfae	; 0xfae <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3210:	a0 91 2e 02 	lds	r26, 0x022E
    3214:	b0 91 2f 02 	lds	r27, 0x022F
    3218:	cd 91       	ld	r28, X+
    321a:	cd bf       	out	0x3d, r28	; 61
    321c:	dd 91       	ld	r29, X+
    321e:	de bf       	out	0x3e, r29	; 62
    3220:	ff 91       	pop	r31
    3222:	ef 91       	pop	r30
    3224:	df 91       	pop	r29
    3226:	cf 91       	pop	r28
    3228:	bf 91       	pop	r27
    322a:	af 91       	pop	r26
    322c:	9f 91       	pop	r25
    322e:	8f 91       	pop	r24
    3230:	7f 91       	pop	r23
    3232:	6f 91       	pop	r22
    3234:	5f 91       	pop	r21
    3236:	4f 91       	pop	r20
    3238:	3f 91       	pop	r19
    323a:	2f 91       	pop	r18
    323c:	1f 91       	pop	r17
    323e:	0f 91       	pop	r16
    3240:	ff 90       	pop	r15
    3242:	ef 90       	pop	r14
    3244:	df 90       	pop	r13
    3246:	cf 90       	pop	r12
    3248:	bf 90       	pop	r11
    324a:	af 90       	pop	r10
    324c:	9f 90       	pop	r9
    324e:	8f 90       	pop	r8
    3250:	7f 90       	pop	r7
    3252:	6f 90       	pop	r6
    3254:	5f 90       	pop	r5
    3256:	4f 90       	pop	r4
    3258:	3f 90       	pop	r3
    325a:	2f 90       	pop	r2
    325c:	1f 90       	pop	r1
    325e:	0f 90       	pop	r0
    3260:	0c be       	out	0x3c, r0	; 60
    3262:	0f 90       	pop	r0
    3264:	0b be       	out	0x3b, r0	; 59
    3266:	0f 90       	pop	r0
    3268:	0f be       	out	0x3f, r0	; 63
    326a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    326c:	08 95       	ret

0000326e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    326e:	0f 92       	push	r0
    3270:	0f b6       	in	r0, 0x3f	; 63
    3272:	f8 94       	cli
    3274:	0f 92       	push	r0
    3276:	0b b6       	in	r0, 0x3b	; 59
    3278:	0f 92       	push	r0
    327a:	0c b6       	in	r0, 0x3c	; 60
    327c:	0f 92       	push	r0
    327e:	1f 92       	push	r1
    3280:	11 24       	eor	r1, r1
    3282:	2f 92       	push	r2
    3284:	3f 92       	push	r3
    3286:	4f 92       	push	r4
    3288:	5f 92       	push	r5
    328a:	6f 92       	push	r6
    328c:	7f 92       	push	r7
    328e:	8f 92       	push	r8
    3290:	9f 92       	push	r9
    3292:	af 92       	push	r10
    3294:	bf 92       	push	r11
    3296:	cf 92       	push	r12
    3298:	df 92       	push	r13
    329a:	ef 92       	push	r14
    329c:	ff 92       	push	r15
    329e:	0f 93       	push	r16
    32a0:	1f 93       	push	r17
    32a2:	2f 93       	push	r18
    32a4:	3f 93       	push	r19
    32a6:	4f 93       	push	r20
    32a8:	5f 93       	push	r21
    32aa:	6f 93       	push	r22
    32ac:	7f 93       	push	r23
    32ae:	8f 93       	push	r24
    32b0:	9f 93       	push	r25
    32b2:	af 93       	push	r26
    32b4:	bf 93       	push	r27
    32b6:	cf 93       	push	r28
    32b8:	df 93       	push	r29
    32ba:	ef 93       	push	r30
    32bc:	ff 93       	push	r31
    32be:	a0 91 2e 02 	lds	r26, 0x022E
    32c2:	b0 91 2f 02 	lds	r27, 0x022F
    32c6:	0d b6       	in	r0, 0x3d	; 61
    32c8:	0d 92       	st	X+, r0
    32ca:	0e b6       	in	r0, 0x3e	; 62
    32cc:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    32ce:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <vTaskIncrementTick>
	vTaskSwitchContext();
    32d2:	0e 94 d7 07 	call	0xfae	; 0xfae <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    32d6:	a0 91 2e 02 	lds	r26, 0x022E
    32da:	b0 91 2f 02 	lds	r27, 0x022F
    32de:	cd 91       	ld	r28, X+
    32e0:	cd bf       	out	0x3d, r28	; 61
    32e2:	dd 91       	ld	r29, X+
    32e4:	de bf       	out	0x3e, r29	; 62
    32e6:	ff 91       	pop	r31
    32e8:	ef 91       	pop	r30
    32ea:	df 91       	pop	r29
    32ec:	cf 91       	pop	r28
    32ee:	bf 91       	pop	r27
    32f0:	af 91       	pop	r26
    32f2:	9f 91       	pop	r25
    32f4:	8f 91       	pop	r24
    32f6:	7f 91       	pop	r23
    32f8:	6f 91       	pop	r22
    32fa:	5f 91       	pop	r21
    32fc:	4f 91       	pop	r20
    32fe:	3f 91       	pop	r19
    3300:	2f 91       	pop	r18
    3302:	1f 91       	pop	r17
    3304:	0f 91       	pop	r16
    3306:	ff 90       	pop	r15
    3308:	ef 90       	pop	r14
    330a:	df 90       	pop	r13
    330c:	cf 90       	pop	r12
    330e:	bf 90       	pop	r11
    3310:	af 90       	pop	r10
    3312:	9f 90       	pop	r9
    3314:	8f 90       	pop	r8
    3316:	7f 90       	pop	r7
    3318:	6f 90       	pop	r6
    331a:	5f 90       	pop	r5
    331c:	4f 90       	pop	r4
    331e:	3f 90       	pop	r3
    3320:	2f 90       	pop	r2
    3322:	1f 90       	pop	r1
    3324:	0f 90       	pop	r0
    3326:	0c be       	out	0x3c, r0	; 60
    3328:	0f 90       	pop	r0
    332a:	0b be       	out	0x3b, r0	; 59
    332c:	0f 90       	pop	r0
    332e:	0f be       	out	0x3f, r0	; 63
    3330:	0f 90       	pop	r0

	asm volatile ( "ret" );
    3332:	08 95       	ret

00003334 <prvSetupTimerInterrupt>:

/*
 * Setup timer 0 or 3 or 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    3334:	cf 93       	push	r28
    3336:	df 93       	push	r29
    3338:	00 d0       	rcall	.+0      	; 0x333a <prvSetupTimerInterrupt+0x6>
    333a:	00 d0       	rcall	.+0      	; 0x333c <prvSetupTimerInterrupt+0x8>
    333c:	cd b7       	in	r28, 0x3d	; 61
    333e:	de b7       	in	r29, 0x3e	; 62

    /* Using 8bit Timer0 or 16bit Timer1 or Timer3 to generate the tick. */

    // ulCompareMatch 40,000 = 20,000,000 / 500; 20MHz
    // ulCompareMatch 110,592 = 22,118,400 / 200; 22.1184 MHz
    ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    3340:	80 e0       	ldi	r24, 0x00	; 0
    3342:	9d e7       	ldi	r25, 0x7D	; 125
    3344:	a0 e0       	ldi	r26, 0x00	; 0
    3346:	b0 e0       	ldi	r27, 0x00	; 0
    3348:	89 83       	std	Y+1, r24	; 0x01
    334a:	9a 83       	std	Y+2, r25	; 0x02
    334c:	ab 83       	std	Y+3, r26	; 0x03
    334e:	bc 83       	std	Y+4, r27	; 0x04

    /* We only have 8 or 16 bits so have to scale 64 or 256 to get our required tick rate. */
    //ulCompareMatch = 625 /= portCLOCK_PRESCALER; 20MHz with 64 prescale
    //ulCompareMatch = 108 /= portCLOCK_PRESCALER; 22.1184 MHz with 1024 prescale
    ulCompareMatch /= portCLOCK_PRESCALER;
    3350:	89 81       	ldd	r24, Y+1	; 0x01
    3352:	9a 81       	ldd	r25, Y+2	; 0x02
    3354:	ab 81       	ldd	r26, Y+3	; 0x03
    3356:	bc 81       	ldd	r27, Y+4	; 0x04
    3358:	68 94       	set
    335a:	15 f8       	bld	r1, 5
    335c:	b6 95       	lsr	r27
    335e:	a7 95       	ror	r26
    3360:	97 95       	ror	r25
    3362:	87 95       	ror	r24
    3364:	16 94       	lsr	r1
    3366:	d1 f7       	brne	.-12     	; 0x335c <prvSetupTimerInterrupt+0x28>
    3368:	89 83       	std	Y+1, r24	; 0x01
    336a:	9a 83       	std	Y+2, r25	; 0x02
    336c:	ab 83       	std	Y+3, r26	; 0x03
    336e:	bc 83       	std	Y+4, r27	; 0x04

    /* Adjust for correct value. */
    ulCompareMatch -= ( unsigned portLONG ) 1;
    3370:	89 81       	ldd	r24, Y+1	; 0x01
    3372:	9a 81       	ldd	r25, Y+2	; 0x02
    3374:	ab 81       	ldd	r26, Y+3	; 0x03
    3376:	bc 81       	ldd	r27, Y+4	; 0x04
    3378:	01 97       	sbiw	r24, 0x01	; 1
    337a:	a1 09       	sbc	r26, r1
    337c:	b1 09       	sbc	r27, r1
    337e:	89 83       	std	Y+1, r24	; 0x01
    3380:	9a 83       	std	Y+2, r25	; 0x02
    3382:	ab 83       	std	Y+3, r26	; 0x03
    3384:	bc 83       	std	Y+4, r27	; 0x04

    /* Setup compare match value for compare match A.  Interrupts are disabled
    before this is called so we need not worry here. */
    ucLowByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
    3386:	89 81       	ldd	r24, Y+1	; 0x01
    3388:	8d 83       	std	Y+5, r24	; 0x05
    //  OCR3AL = ucLowByte;

    // the HiByte is only needed, if a 16 Bit counter is being utilized
#ifdef portOCRH

    ulCompareMatch >>= 8;
    338a:	89 81       	ldd	r24, Y+1	; 0x01
    338c:	9a 81       	ldd	r25, Y+2	; 0x02
    338e:	ab 81       	ldd	r26, Y+3	; 0x03
    3390:	bc 81       	ldd	r27, Y+4	; 0x04
    3392:	89 2f       	mov	r24, r25
    3394:	9a 2f       	mov	r25, r26
    3396:	ab 2f       	mov	r26, r27
    3398:	bb 27       	eor	r27, r27
    339a:	89 83       	std	Y+1, r24	; 0x01
    339c:	9a 83       	std	Y+2, r25	; 0x02
    339e:	ab 83       	std	Y+3, r26	; 0x03
    33a0:	bc 83       	std	Y+4, r27	; 0x04
    ucHighByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
    33a2:	89 81       	ldd	r24, Y+1	; 0x01
    33a4:	8e 83       	std	Y+6, r24	; 0x06
    portOCRH = ucHighByte;
    33a6:	89 e9       	ldi	r24, 0x99	; 153
    33a8:	90 e0       	ldi	r25, 0x00	; 0
    33aa:	2e 81       	ldd	r18, Y+6	; 0x06
    33ac:	fc 01       	movw	r30, r24
    33ae:	20 83       	st	Z, r18

#endif

    portOCRL = ucLowByte;
    33b0:	88 e9       	ldi	r24, 0x98	; 152
    33b2:	90 e0       	ldi	r25, 0x00	; 0
    33b4:	2d 81       	ldd	r18, Y+5	; 0x05
    33b6:	fc 01       	movw	r30, r24
    33b8:	20 83       	st	Z, r18
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	portTCCRb = ucLowByte;

#elif defined( portUSE_TIMER3 )
	/* Setup clock source and compare match behaviour. Assuming  640 / 1280 /1281 / 1284p / 2560 / 2561 (with Timer3) */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    33ba:	8b e0       	ldi	r24, 0x0B	; 11
    33bc:	8d 83       	std	Y+5, r24	; 0x05
	portTCCRb = ucLowByte;
    33be:	81 e9       	ldi	r24, 0x91	; 145
    33c0:	90 e0       	ldi	r25, 0x00	; 0
    33c2:	2d 81       	ldd	r18, Y+5	; 0x05
    33c4:	fc 01       	movw	r30, r24
    33c6:	20 83       	st	Z, r18
#endif

    /* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
    ucLowByte = portTIMSK;
    33c8:	81 e7       	ldi	r24, 0x71	; 113
    33ca:	90 e0       	ldi	r25, 0x00	; 0
    33cc:	fc 01       	movw	r30, r24
    33ce:	80 81       	ld	r24, Z
    33d0:	8d 83       	std	Y+5, r24	; 0x05
    ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    33d2:	8d 81       	ldd	r24, Y+5	; 0x05
    33d4:	82 60       	ori	r24, 0x02	; 2
    33d6:	8d 83       	std	Y+5, r24	; 0x05
    portTIMSK = ucLowByte;
    33d8:	81 e7       	ldi	r24, 0x71	; 113
    33da:	90 e0       	ldi	r25, 0x00	; 0
    33dc:	2d 81       	ldd	r18, Y+5	; 0x05
    33de:	fc 01       	movw	r30, r24
    33e0:	20 83       	st	Z, r18

}
    33e2:	26 96       	adiw	r28, 0x06	; 6
    33e4:	0f b6       	in	r0, 0x3f	; 63
    33e6:	f8 94       	cli
    33e8:	de bf       	out	0x3e, r29	; 62
    33ea:	0f be       	out	0x3f, r0	; 63
    33ec:	cd bf       	out	0x3d, r28	; 61
    33ee:	df 91       	pop	r29
    33f0:	cf 91       	pop	r28
    33f2:	08 95       	ret

000033f4 <__vector_32>:

	#elif defined( portUSE_TIMER3 )
		#warning "Timer3 used for PRE-EMPTIVE scheduler."
		ISR(TIMER3_COMPA_vect, ISR_NAKED)
		{
			vPortYieldFromTick();
    33f4:	0e 94 37 19 	call	0x326e	; 0x326e <vPortYieldFromTick>
			asm volatile ( "reti" );
    33f8:	18 95       	reti

000033fa <USART_Init>:
*  the specified baud rate and clk speed.
*
* Param buadin: The desired Baud rate.
* Param clk_seedin: The clk speed of the ATmega328p
************************************/
void USART_Init(uint16_t baudin, uint32_t clk_speedin) {
    33fa:	cf 93       	push	r28
    33fc:	df 93       	push	r29
    33fe:	00 d0       	rcall	.+0      	; 0x3400 <USART_Init+0x6>
    3400:	00 d0       	rcall	.+0      	; 0x3402 <USART_Init+0x8>
    3402:	cd b7       	in	r28, 0x3d	; 61
    3404:	de b7       	in	r29, 0x3e	; 62
    3406:	9a 83       	std	Y+2, r25	; 0x02
    3408:	89 83       	std	Y+1, r24	; 0x01
    340a:	4b 83       	std	Y+3, r20	; 0x03
    340c:	5c 83       	std	Y+4, r21	; 0x04
    340e:	6d 83       	std	Y+5, r22	; 0x05
    3410:	7e 83       	std	Y+6, r23	; 0x06
    USART_WriteQueue = xQueueCreate(64,sizeof(uint8_t));
    3412:	40 e0       	ldi	r20, 0x00	; 0
    3414:	61 e0       	ldi	r22, 0x01	; 1
    3416:	80 e4       	ldi	r24, 0x40	; 64
    3418:	0e 94 d9 0c 	call	0x19b2	; 0x19b2 <xQueueGenericCreate>
    341c:	90 93 cb 1a 	sts	0x1ACB, r25
    3420:	80 93 ca 1a 	sts	0x1ACA, r24
    USART_ReadQueue = xQueueCreate(8,sizeof(uint8_t));
    3424:	40 e0       	ldi	r20, 0x00	; 0
    3426:	61 e0       	ldi	r22, 0x01	; 1
    3428:	88 e0       	ldi	r24, 0x08	; 8
    342a:	0e 94 d9 0c 	call	0x19b2	; 0x19b2 <xQueueGenericCreate>
    342e:	90 93 c7 1a 	sts	0x1AC7, r25
    3432:	80 93 c6 1a 	sts	0x1AC6, r24

    //uint32_t ubrr = clk_speedin/(16UL)/baudin-1;
    //UBRR1H = (unsigned char)(ubrr>>8) ;// & 0x7F;
    //UBRR1L = (unsigned char)ubrr;
    
    UBRR2H = 0; //115200
    3436:	85 ed       	ldi	r24, 0xD5	; 213
    3438:	90 e0       	ldi	r25, 0x00	; 0
    343a:	fc 01       	movw	r30, r24
    343c:	10 82       	st	Z, r1
    UBRR2L = 8;
    343e:	84 ed       	ldi	r24, 0xD4	; 212
    3440:	90 e0       	ldi	r25, 0x00	; 0
    3442:	28 e0       	ldi	r18, 0x08	; 8
    3444:	fc 01       	movw	r30, r24
    3446:	20 83       	st	Z, r18

    /* Enable receiver and transmitter */
    UCSR2B = (1<<RXEN2)|(1<<TXEN2);//|(1<<RXCIE1);
    3448:	81 ed       	ldi	r24, 0xD1	; 209
    344a:	90 e0       	ldi	r25, 0x00	; 0
    344c:	28 e1       	ldi	r18, 0x18	; 24
    344e:	fc 01       	movw	r30, r24
    3450:	20 83       	st	Z, r18
    /* Set frame format: 8data, 1stop bit */
    UCSR2C = (1<<UCSZ21)|(1<<UCSZ20);
    3452:	82 ed       	ldi	r24, 0xD2	; 210
    3454:	90 e0       	ldi	r25, 0x00	; 0
    3456:	26 e0       	ldi	r18, 0x06	; 6
    3458:	fc 01       	movw	r30, r24
    345a:	20 83       	st	Z, r18
	 // clear U2X0 for Synchronous operation
    UCSR2A &= ~(1<<U2X2);
    345c:	80 ed       	ldi	r24, 0xD0	; 208
    345e:	90 e0       	ldi	r25, 0x00	; 0
    3460:	20 ed       	ldi	r18, 0xD0	; 208
    3462:	30 e0       	ldi	r19, 0x00	; 0
    3464:	f9 01       	movw	r30, r18
    3466:	20 81       	ld	r18, Z
    3468:	2d 7f       	andi	r18, 0xFD	; 253
    346a:	fc 01       	movw	r30, r24
    346c:	20 83       	st	Z, r18
    /* Set frame format: 8data, 1stop bit */
    //UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);
    // clear U2X0 for Synchronous operation
    //UCSR0A &= ~(1<<U2X0);*/

}
    346e:	26 96       	adiw	r28, 0x06	; 6
    3470:	0f b6       	in	r0, 0x3f	; 63
    3472:	f8 94       	cli
    3474:	de bf       	out	0x3e, r29	; 62
    3476:	0f be       	out	0x3f, r0	; 63
    3478:	cd bf       	out	0x3d, r28	; 61
    347a:	df 91       	pop	r29
    347c:	cf 91       	pop	r28
    347e:	08 95       	ret

00003480 <USART_Write>:

/*the send function will put 8bits on the trans line. */
void USART_Write(uint8_t data) {
    3480:	cf 93       	push	r28
    3482:	df 93       	push	r29
    3484:	1f 92       	push	r1
    3486:	cd b7       	in	r28, 0x3d	; 61
    3488:	de b7       	in	r29, 0x3e	; 62
    348a:	89 83       	std	Y+1, r24	; 0x01
		/* Wait for empty transmit buffer */
		while ( !( UCSR2A & (1<<UDRE2)) )
    348c:	00 00       	nop
    348e:	80 ed       	ldi	r24, 0xD0	; 208
    3490:	90 e0       	ldi	r25, 0x00	; 0
    3492:	fc 01       	movw	r30, r24
    3494:	80 81       	ld	r24, Z
    3496:	88 2f       	mov	r24, r24
    3498:	90 e0       	ldi	r25, 0x00	; 0
    349a:	80 72       	andi	r24, 0x20	; 32
    349c:	99 27       	eor	r25, r25
    349e:	00 97       	sbiw	r24, 0x00	; 0
    34a0:	b1 f3       	breq	.-20     	; 0x348e <USART_Write+0xe>
		;
		/* Put data into buffer, sends the data */
		UDR2 = data;
    34a2:	86 ed       	ldi	r24, 0xD6	; 214
    34a4:	90 e0       	ldi	r25, 0x00	; 0
    34a6:	29 81       	ldd	r18, Y+1	; 0x01
    34a8:	fc 01       	movw	r30, r24
    34aa:	20 83       	st	Z, r18
}
    34ac:	0f 90       	pop	r0
    34ae:	df 91       	pop	r29
    34b0:	cf 91       	pop	r28
    34b2:	08 95       	ret

000034b4 <USART_Write_Unprotected>:

/*the send function will put 8bits on the trans line. */
void USART_Write_Unprotected(uint8_t data) {
    34b4:	cf 93       	push	r28
    34b6:	df 93       	push	r29
    34b8:	1f 92       	push	r1
    34ba:	cd b7       	in	r28, 0x3d	; 61
    34bc:	de b7       	in	r29, 0x3e	; 62
    34be:	89 83       	std	Y+1, r24	; 0x01
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)) )
    34c0:	00 00       	nop
    34c2:	80 ec       	ldi	r24, 0xC0	; 192
    34c4:	90 e0       	ldi	r25, 0x00	; 0
    34c6:	fc 01       	movw	r30, r24
    34c8:	80 81       	ld	r24, Z
    34ca:	88 2f       	mov	r24, r24
    34cc:	90 e0       	ldi	r25, 0x00	; 0
    34ce:	80 72       	andi	r24, 0x20	; 32
    34d0:	99 27       	eor	r25, r25
    34d2:	00 97       	sbiw	r24, 0x00	; 0
    34d4:	b1 f3       	breq	.-20     	; 0x34c2 <USART_Write_Unprotected+0xe>
	;
	/* Put data into buffer, sends the data */
	UDR0 = data;
    34d6:	86 ec       	ldi	r24, 0xC6	; 198
    34d8:	90 e0       	ldi	r25, 0x00	; 0
    34da:	29 81       	ldd	r18, Y+1	; 0x01
    34dc:	fc 01       	movw	r30, r24
    34de:	20 83       	st	Z, r18
}
    34e0:	0f 90       	pop	r0
    34e2:	df 91       	pop	r29
    34e4:	cf 91       	pop	r28
    34e6:	08 95       	ret

000034e8 <USART_Read>:
Therefore you may not get control back after this is called 
until a much later time. It may be helpful to use the 
istheredata() function to check before calling this function
        @return 8bit data packet from sender
*/
uint8_t USART_Read(void) {
    34e8:	cf 93       	push	r28
    34ea:	df 93       	push	r29
    34ec:	cd b7       	in	r28, 0x3d	; 61
    34ee:	de b7       	in	r29, 0x3e	; 62
    /* Wait for data to be received */
    while ( !(UCSR2A & (1<<RXC2)) )
    34f0:	00 00       	nop
    34f2:	80 ed       	ldi	r24, 0xD0	; 208
    34f4:	90 e0       	ldi	r25, 0x00	; 0
    34f6:	fc 01       	movw	r30, r24
    34f8:	80 81       	ld	r24, Z
    34fa:	88 23       	and	r24, r24
    34fc:	d4 f7       	brge	.-12     	; 0x34f2 <USART_Read+0xa>
        ;
    /* Get and return received data from buffer */
    return UDR2;
    34fe:	86 ed       	ldi	r24, 0xD6	; 214
    3500:	90 e0       	ldi	r25, 0x00	; 0
    3502:	fc 01       	movw	r30, r24
    3504:	80 81       	ld	r24, Z
}
    3506:	df 91       	pop	r29
    3508:	cf 91       	pop	r28
    350a:	08 95       	ret

0000350c <__vector_36>:


ISR(USART1_RX_vect){
    350c:	1f 92       	push	r1
    350e:	0f 92       	push	r0
    3510:	00 90 5f 00 	lds	r0, 0x005F
    3514:	0f 92       	push	r0
    3516:	11 24       	eor	r1, r1
    3518:	00 90 5b 00 	lds	r0, 0x005B
    351c:	0f 92       	push	r0
    351e:	2f 93       	push	r18
    3520:	3f 93       	push	r19
    3522:	8f 93       	push	r24
    3524:	9f 93       	push	r25
    3526:	ef 93       	push	r30
    3528:	ff 93       	push	r31
    352a:	cf 93       	push	r28
    352c:	df 93       	push	r29
    352e:	1f 92       	push	r1
    3530:	cd b7       	in	r28, 0x3d	; 61
    3532:	de b7       	in	r29, 0x3e	; 62
    uint8_t data;
    data = UDR1;
    3534:	8e ec       	ldi	r24, 0xCE	; 206
    3536:	90 e0       	ldi	r25, 0x00	; 0
    3538:	fc 01       	movw	r30, r24
    353a:	80 81       	ld	r24, Z
    353c:	89 83       	std	Y+1, r24	; 0x01

    //while(!(UCSR1A & (1<<UDRE1)));
    PORTB ^= 0x10;
    353e:	85 e2       	ldi	r24, 0x25	; 37
    3540:	90 e0       	ldi	r25, 0x00	; 0
    3542:	25 e2       	ldi	r18, 0x25	; 37
    3544:	30 e0       	ldi	r19, 0x00	; 0
    3546:	f9 01       	movw	r30, r18
    3548:	30 81       	ld	r19, Z
    354a:	20 e1       	ldi	r18, 0x10	; 16
    354c:	23 27       	eor	r18, r19
    354e:	fc 01       	movw	r30, r24
    3550:	20 83       	st	Z, r18
    //UDR1 = data;
    

  //  USART_AddToQueue(data);
    //xQueueSendToBackFromISR(USART_ReadQueue,&data,NULL);
}
    3552:	0f 90       	pop	r0
    3554:	df 91       	pop	r29
    3556:	cf 91       	pop	r28
    3558:	ff 91       	pop	r31
    355a:	ef 91       	pop	r30
    355c:	9f 91       	pop	r25
    355e:	8f 91       	pop	r24
    3560:	3f 91       	pop	r19
    3562:	2f 91       	pop	r18
    3564:	0f 90       	pop	r0
    3566:	00 92 5b 00 	sts	0x005B, r0
    356a:	0f 90       	pop	r0
    356c:	00 92 5f 00 	sts	0x005F, r0
    3570:	0f 90       	pop	r0
    3572:	1f 90       	pop	r1
    3574:	18 95       	reti

00003576 <USART_AddToQueue>:

void USART_AddToQueue(uint8_t data){
    3576:	cf 93       	push	r28
    3578:	df 93       	push	r29
    357a:	1f 92       	push	r1
    357c:	cd b7       	in	r28, 0x3d	; 61
    357e:	de b7       	in	r29, 0x3e	; 62
    3580:	89 83       	std	Y+1, r24	; 0x01
    
    xQueueSendToBack(USART_WriteQueue,&data,portMAX_DELAY);
    3582:	80 91 ca 1a 	lds	r24, 0x1ACA
    3586:	90 91 cb 1a 	lds	r25, 0x1ACB
    358a:	20 e0       	ldi	r18, 0x00	; 0
    358c:	4f ef       	ldi	r20, 0xFF	; 255
    358e:	5f ef       	ldi	r21, 0xFF	; 255
    3590:	be 01       	movw	r22, r28
    3592:	6f 5f       	subi	r22, 0xFF	; 255
    3594:	7f 4f       	sbci	r23, 0xFF	; 255
    3596:	0e 94 90 0d 	call	0x1b20	; 0x1b20 <xQueueGenericSend>

}
    359a:	0f 90       	pop	r0
    359c:	df 91       	pop	r29
    359e:	cf 91       	pop	r28
    35a0:	08 95       	ret

000035a2 <USART_TransmitString>:

void USART_TransmitString(char* str){
    35a2:	cf 93       	push	r28
    35a4:	df 93       	push	r29
    35a6:	1f 92       	push	r1
    35a8:	1f 92       	push	r1
    35aa:	cd b7       	in	r28, 0x3d	; 61
    35ac:	de b7       	in	r29, 0x3e	; 62
    35ae:	9a 83       	std	Y+2, r25	; 0x02
    35b0:	89 83       	std	Y+1, r24	; 0x01
    while(*str) {
    35b2:	0b c0       	rjmp	.+22     	; 0x35ca <USART_TransmitString+0x28>
        USART_AddToQueue(*str);
    35b4:	89 81       	ldd	r24, Y+1	; 0x01
    35b6:	9a 81       	ldd	r25, Y+2	; 0x02
    35b8:	fc 01       	movw	r30, r24
    35ba:	80 81       	ld	r24, Z
    35bc:	0e 94 bb 1a 	call	0x3576	; 0x3576 <USART_AddToQueue>
        str++;
    35c0:	89 81       	ldd	r24, Y+1	; 0x01
    35c2:	9a 81       	ldd	r25, Y+2	; 0x02
    35c4:	01 96       	adiw	r24, 0x01	; 1
    35c6:	9a 83       	std	Y+2, r25	; 0x02
    35c8:	89 83       	std	Y+1, r24	; 0x01
    xQueueSendToBack(USART_WriteQueue,&data,portMAX_DELAY);

}

void USART_TransmitString(char* str){
    while(*str) {
    35ca:	89 81       	ldd	r24, Y+1	; 0x01
    35cc:	9a 81       	ldd	r25, Y+2	; 0x02
    35ce:	fc 01       	movw	r30, r24
    35d0:	80 81       	ld	r24, Z
    35d2:	88 23       	and	r24, r24
    35d4:	79 f7       	brne	.-34     	; 0x35b4 <USART_TransmitString+0x12>
        USART_AddToQueue(*str);
        str++;
    }
}
    35d6:	0f 90       	pop	r0
    35d8:	0f 90       	pop	r0
    35da:	df 91       	pop	r29
    35dc:	cf 91       	pop	r28
    35de:	08 95       	ret

000035e0 <vTaskUSARTWrite>:

void vTaskUSARTWrite(void *pvParameters){
    35e0:	cf 93       	push	r28
    35e2:	df 93       	push	r29
    35e4:	00 d0       	rcall	.+0      	; 0x35e6 <vTaskUSARTWrite+0x6>
    35e6:	cd b7       	in	r28, 0x3d	; 61
    35e8:	de b7       	in	r29, 0x3e	; 62
    35ea:	9b 83       	std	Y+3, r25	; 0x03
    35ec:	8a 83       	std	Y+2, r24	; 0x02
    uint8_t data;
    while(1){
    xQueueReceive(USART_WriteQueue,&data,portMAX_DELAY);
    35ee:	80 91 ca 1a 	lds	r24, 0x1ACA
    35f2:	90 91 cb 1a 	lds	r25, 0x1ACB
    35f6:	20 e0       	ldi	r18, 0x00	; 0
    35f8:	4f ef       	ldi	r20, 0xFF	; 255
    35fa:	5f ef       	ldi	r21, 0xFF	; 255
    35fc:	be 01       	movw	r22, r28
    35fe:	6f 5f       	subi	r22, 0xFF	; 255
    3600:	7f 4f       	sbci	r23, 0xFF	; 255
    3602:	0e 94 8d 0e 	call	0x1d1a	; 0x1d1a <xQueueGenericReceive>

        while(!(UCSR1A & (1<<UDRE1)));
    3606:	00 00       	nop
    3608:	88 ec       	ldi	r24, 0xC8	; 200
    360a:	90 e0       	ldi	r25, 0x00	; 0
    360c:	fc 01       	movw	r30, r24
    360e:	80 81       	ld	r24, Z
    3610:	88 2f       	mov	r24, r24
    3612:	90 e0       	ldi	r25, 0x00	; 0
    3614:	80 72       	andi	r24, 0x20	; 32
    3616:	99 27       	eor	r25, r25
    3618:	00 97       	sbiw	r24, 0x00	; 0
    361a:	b1 f3       	breq	.-20     	; 0x3608 <vTaskUSARTWrite+0x28>
        UDR1 = data;
    361c:	8e ec       	ldi	r24, 0xCE	; 206
    361e:	90 e0       	ldi	r25, 0x00	; 0
    3620:	29 81       	ldd	r18, Y+1	; 0x01
    3622:	fc 01       	movw	r30, r24
    3624:	20 83       	st	Z, r18

    }
    3626:	e3 cf       	rjmp	.-58     	; 0x35ee <vTaskUSARTWrite+0xe>

00003628 <USART_LogChar>:
}

void USART_LogChar(uint8_t data){
    3628:	cf 93       	push	r28
    362a:	df 93       	push	r29
    362c:	1f 92       	push	r1
    362e:	cd b7       	in	r28, 0x3d	; 61
    3630:	de b7       	in	r29, 0x3e	; 62
    3632:	89 83       	std	Y+1, r24	; 0x01
    xQueueSendToBack(USART_WriteQueueLog,&data,portMAX_DELAY);
    3634:	80 91 c8 1a 	lds	r24, 0x1AC8
    3638:	90 91 c9 1a 	lds	r25, 0x1AC9
    363c:	20 e0       	ldi	r18, 0x00	; 0
    363e:	4f ef       	ldi	r20, 0xFF	; 255
    3640:	5f ef       	ldi	r21, 0xFF	; 255
    3642:	be 01       	movw	r22, r28
    3644:	6f 5f       	subi	r22, 0xFF	; 255
    3646:	7f 4f       	sbci	r23, 0xFF	; 255
    3648:	0e 94 90 0d 	call	0x1b20	; 0x1b20 <xQueueGenericSend>
}
    364c:	0f 90       	pop	r0
    364e:	df 91       	pop	r29
    3650:	cf 91       	pop	r28
    3652:	08 95       	ret

00003654 <USART_LogString>:

void USART_LogString(char* str){
    3654:	cf 93       	push	r28
    3656:	df 93       	push	r29
    3658:	1f 92       	push	r1
    365a:	1f 92       	push	r1
    365c:	cd b7       	in	r28, 0x3d	; 61
    365e:	de b7       	in	r29, 0x3e	; 62
    3660:	9a 83       	std	Y+2, r25	; 0x02
    3662:	89 83       	std	Y+1, r24	; 0x01
    while(*str){
    3664:	0b c0       	rjmp	.+22     	; 0x367c <USART_LogString+0x28>
        USART_LogChar(*str);
    3666:	89 81       	ldd	r24, Y+1	; 0x01
    3668:	9a 81       	ldd	r25, Y+2	; 0x02
    366a:	fc 01       	movw	r30, r24
    366c:	80 81       	ld	r24, Z
    366e:	0e 94 14 1b 	call	0x3628	; 0x3628 <USART_LogChar>
        str++;
    3672:	89 81       	ldd	r24, Y+1	; 0x01
    3674:	9a 81       	ldd	r25, Y+2	; 0x02
    3676:	01 96       	adiw	r24, 0x01	; 1
    3678:	9a 83       	std	Y+2, r25	; 0x02
    367a:	89 83       	std	Y+1, r24	; 0x01
void USART_LogChar(uint8_t data){
    xQueueSendToBack(USART_WriteQueueLog,&data,portMAX_DELAY);
}

void USART_LogString(char* str){
    while(*str){
    367c:	89 81       	ldd	r24, Y+1	; 0x01
    367e:	9a 81       	ldd	r25, Y+2	; 0x02
    3680:	fc 01       	movw	r30, r24
    3682:	80 81       	ld	r24, Z
    3684:	88 23       	and	r24, r24
    3686:	79 f7       	brne	.-34     	; 0x3666 <USART_LogString+0x12>
        USART_LogChar(*str);
        str++;
    }
}
    3688:	0f 90       	pop	r0
    368a:	0f 90       	pop	r0
    368c:	df 91       	pop	r29
    368e:	cf 91       	pop	r28
    3690:	08 95       	ret

00003692 <vTaskUSARTLog>:

void vTaskUSARTLog(void *pvParameters){
    3692:	cf 93       	push	r28
    3694:	df 93       	push	r29
    3696:	00 d0       	rcall	.+0      	; 0x3698 <vTaskUSARTLog+0x6>
    3698:	cd b7       	in	r28, 0x3d	; 61
    369a:	de b7       	in	r29, 0x3e	; 62
    369c:	9b 83       	std	Y+3, r25	; 0x03
    369e:	8a 83       	std	Y+2, r24	; 0x02
    uint8_t data;
    while(1){
        xQueueReceive(USART_WriteQueueLog,&data,portMAX_DELAY);
    36a0:	80 91 c8 1a 	lds	r24, 0x1AC8
    36a4:	90 91 c9 1a 	lds	r25, 0x1AC9
    36a8:	20 e0       	ldi	r18, 0x00	; 0
    36aa:	4f ef       	ldi	r20, 0xFF	; 255
    36ac:	5f ef       	ldi	r21, 0xFF	; 255
    36ae:	be 01       	movw	r22, r28
    36b0:	6f 5f       	subi	r22, 0xFF	; 255
    36b2:	7f 4f       	sbci	r23, 0xFF	; 255
    36b4:	0e 94 8d 0e 	call	0x1d1a	; 0x1d1a <xQueueGenericReceive>

        while(!(UCSR0A & (1<<UDRE0)));
    36b8:	00 00       	nop
    36ba:	80 ec       	ldi	r24, 0xC0	; 192
    36bc:	90 e0       	ldi	r25, 0x00	; 0
    36be:	fc 01       	movw	r30, r24
    36c0:	80 81       	ld	r24, Z
    36c2:	88 2f       	mov	r24, r24
    36c4:	90 e0       	ldi	r25, 0x00	; 0
    36c6:	80 72       	andi	r24, 0x20	; 32
    36c8:	99 27       	eor	r25, r25
    36ca:	00 97       	sbiw	r24, 0x00	; 0
    36cc:	b1 f3       	breq	.-20     	; 0x36ba <vTaskUSARTLog+0x28>
        UDR0 = data;
    36ce:	86 ec       	ldi	r24, 0xC6	; 198
    36d0:	90 e0       	ldi	r25, 0x00	; 0
    36d2:	29 81       	ldd	r18, Y+1	; 0x01
    36d4:	fc 01       	movw	r30, r24
    36d6:	20 83       	st	Z, r18

    }
    36d8:	e3 cf       	rjmp	.-58     	; 0x36a0 <vTaskUSARTLog+0xe>

000036da <USART_GetChar>:

}

uint8_t USART_GetChar(){
    36da:	cf 93       	push	r28
    36dc:	df 93       	push	r29
    36de:	1f 92       	push	r1
    36e0:	cd b7       	in	r28, 0x3d	; 61
    36e2:	de b7       	in	r29, 0x3e	; 62
    uint8_t data;
    if(xQueueReceive(USART_ReadQueue,&data,1) == pdTRUE){
    36e4:	80 91 c6 1a 	lds	r24, 0x1AC6
    36e8:	90 91 c7 1a 	lds	r25, 0x1AC7
    36ec:	20 e0       	ldi	r18, 0x00	; 0
    36ee:	41 e0       	ldi	r20, 0x01	; 1
    36f0:	50 e0       	ldi	r21, 0x00	; 0
    36f2:	be 01       	movw	r22, r28
    36f4:	6f 5f       	subi	r22, 0xFF	; 255
    36f6:	7f 4f       	sbci	r23, 0xFF	; 255
    36f8:	0e 94 8d 0e 	call	0x1d1a	; 0x1d1a <xQueueGenericReceive>
    36fc:	81 30       	cpi	r24, 0x01	; 1
    36fe:	11 f4       	brne	.+4      	; 0x3704 <USART_GetChar+0x2a>
        //USART_AddToQueue('~');
        return data;
    3700:	89 81       	ldd	r24, Y+1	; 0x01
    3702:	01 c0       	rjmp	.+2      	; 0x3706 <USART_GetChar+0x2c>
    } else {
        return 255;
    3704:	8f ef       	ldi	r24, 0xFF	; 255
    }
}
    3706:	0f 90       	pop	r0
    3708:	df 91       	pop	r29
    370a:	cf 91       	pop	r28
    370c:	08 95       	ret

0000370e <delay>:

void delay(int a){
    370e:	cf 93       	push	r28
    3710:	df 93       	push	r29
    3712:	00 d0       	rcall	.+0      	; 0x3714 <delay+0x6>
    3714:	1f 92       	push	r1
    3716:	cd b7       	in	r28, 0x3d	; 61
    3718:	de b7       	in	r29, 0x3e	; 62
    371a:	9c 83       	std	Y+4, r25	; 0x04
    371c:	8b 83       	std	Y+3, r24	; 0x03
	int i;
	for(i = 0;i < a;i++);
    371e:	1a 82       	std	Y+2, r1	; 0x02
    3720:	19 82       	std	Y+1, r1	; 0x01
    3722:	05 c0       	rjmp	.+10     	; 0x372e <delay+0x20>
    3724:	89 81       	ldd	r24, Y+1	; 0x01
    3726:	9a 81       	ldd	r25, Y+2	; 0x02
    3728:	01 96       	adiw	r24, 0x01	; 1
    372a:	9a 83       	std	Y+2, r25	; 0x02
    372c:	89 83       	std	Y+1, r24	; 0x01
    372e:	29 81       	ldd	r18, Y+1	; 0x01
    3730:	3a 81       	ldd	r19, Y+2	; 0x02
    3732:	8b 81       	ldd	r24, Y+3	; 0x03
    3734:	9c 81       	ldd	r25, Y+4	; 0x04
    3736:	28 17       	cp	r18, r24
    3738:	39 07       	cpc	r19, r25
    373a:	a4 f3       	brlt	.-24     	; 0x3724 <delay+0x16>
}
    373c:	0f 90       	pop	r0
    373e:	0f 90       	pop	r0
    3740:	0f 90       	pop	r0
    3742:	0f 90       	pop	r0
    3744:	df 91       	pop	r29
    3746:	cf 91       	pop	r28
    3748:	08 95       	ret

0000374a <sendACK>:

void sendACK(){
    374a:	cf 93       	push	r28
    374c:	df 93       	push	r29
    374e:	cd b7       	in	r28, 0x3d	; 61
    3750:	de b7       	in	r29, 0x3e	; 62
    USART_Write(ACK_BYTE);
    3752:	80 e8       	ldi	r24, 0x80	; 128
    3754:	0e 94 40 1a 	call	0x3480	; 0x3480 <USART_Write>
}
    3758:	df 91       	pop	r29
    375a:	cf 91       	pop	r28
    375c:	08 95       	ret

0000375e <sendNACK>:

void sendNACK(){
    375e:	cf 93       	push	r28
    3760:	df 93       	push	r29
    3762:	cd b7       	in	r28, 0x3d	; 61
    3764:	de b7       	in	r29, 0x3e	; 62
    USART_Write(NACK_BYTE);
    3766:	80 e0       	ldi	r24, 0x00	; 0
    3768:	0e 94 40 1a 	call	0x3480	; 0x3480 <USART_Write>
}
    376c:	df 91       	pop	r29
    376e:	cf 91       	pop	r28
    3770:	08 95       	ret

00003772 <recievePayload>:

int recievePayload(int size,unsigned char *buffer){
    3772:	cf 93       	push	r28
    3774:	df 93       	push	r29
    3776:	cd b7       	in	r28, 0x3d	; 61
    3778:	de b7       	in	r29, 0x3e	; 62
    377a:	2d 97       	sbiw	r28, 0x0d	; 13
    377c:	0f b6       	in	r0, 0x3f	; 63
    377e:	f8 94       	cli
    3780:	de bf       	out	0x3e, r29	; 62
    3782:	0f be       	out	0x3f, r0	; 63
    3784:	cd bf       	out	0x3d, r28	; 61
    3786:	9b 87       	std	Y+11, r25	; 0x0b
    3788:	8a 87       	std	Y+10, r24	; 0x0a
    378a:	7d 87       	std	Y+13, r23	; 0x0d
    378c:	6c 87       	std	Y+12, r22	; 0x0c

	int bytesRecieved = 0;
    378e:	1a 82       	std	Y+2, r1	; 0x02
    3790:	19 82       	std	Y+1, r1	; 0x01
	int numTries = 0;
    3792:	1c 82       	std	Y+4, r1	; 0x04
    3794:	1b 82       	std	Y+3, r1	; 0x03
	const int maxNumTries = 3;
    3796:	83 e0       	ldi	r24, 0x03	; 3
    3798:	90 e0       	ldi	r25, 0x00	; 0
    379a:	98 87       	std	Y+8, r25	; 0x08
    379c:	8f 83       	std	Y+7, r24	; 0x07
	unsigned char data;
	int timeout;

	while(numTries < maxNumTries){
    379e:	93 c0       	rjmp	.+294    	; 0x38c6 <recievePayload+0x154>
		PORTB = 0;
    37a0:	85 e2       	ldi	r24, 0x25	; 37
    37a2:	90 e0       	ldi	r25, 0x00	; 0
    37a4:	fc 01       	movw	r30, r24
    37a6:	10 82       	st	Z, r1
		while(bytesRecieved < size){
    37a8:	3e c0       	rjmp	.+124    	; 0x3826 <recievePayload+0xb4>
			timeout = 50;
    37aa:	82 e3       	ldi	r24, 0x32	; 50
    37ac:	90 e0       	ldi	r25, 0x00	; 0
    37ae:	9e 83       	std	Y+6, r25	; 0x06
    37b0:	8d 83       	std	Y+5, r24	; 0x05
			while ( !(UCSR2A & (1<<RXC2)) ){
    37b2:	19 c0       	rjmp	.+50     	; 0x37e6 <recievePayload+0x74>
  				timeout--;
    37b4:	8d 81       	ldd	r24, Y+5	; 0x05
    37b6:	9e 81       	ldd	r25, Y+6	; 0x06
    37b8:	01 97       	sbiw	r24, 0x01	; 1
    37ba:	9e 83       	std	Y+6, r25	; 0x06
    37bc:	8d 83       	std	Y+5, r24	; 0x05
     			if(timeout == 0){
    37be:	8d 81       	ldd	r24, Y+5	; 0x05
    37c0:	9e 81       	ldd	r25, Y+6	; 0x06
    37c2:	00 97       	sbiw	r24, 0x00	; 0
    37c4:	61 f4       	brne	.+24     	; 0x37de <recievePayload+0x6c>
					PORTB &= ~0x80;
    37c6:	85 e2       	ldi	r24, 0x25	; 37
    37c8:	90 e0       	ldi	r25, 0x00	; 0
    37ca:	25 e2       	ldi	r18, 0x25	; 37
    37cc:	30 e0       	ldi	r19, 0x00	; 0
    37ce:	f9 01       	movw	r30, r18
    37d0:	20 81       	ld	r18, Z
    37d2:	2f 77       	andi	r18, 0x7F	; 127
    37d4:	fc 01       	movw	r30, r24
    37d6:	20 83       	st	Z, r18
					return -1;
    37d8:	8f ef       	ldi	r24, 0xFF	; 255
    37da:	9f ef       	ldi	r25, 0xFF	; 255
    37dc:	7e c0       	rjmp	.+252    	; 0x38da <recievePayload+0x168>
     			}
     			vTaskDelay(1);
    37de:	81 e0       	ldi	r24, 0x01	; 1
    37e0:	90 e0       	ldi	r25, 0x00	; 0
    37e2:	0e 94 61 04 	call	0x8c2	; 0x8c2 <vTaskDelay>

	while(numTries < maxNumTries){
		PORTB = 0;
		while(bytesRecieved < size){
			timeout = 50;
			while ( !(UCSR2A & (1<<RXC2)) ){
    37e6:	80 ed       	ldi	r24, 0xD0	; 208
    37e8:	90 e0       	ldi	r25, 0x00	; 0
    37ea:	fc 01       	movw	r30, r24
    37ec:	80 81       	ld	r24, Z
    37ee:	88 23       	and	r24, r24
    37f0:	0c f7       	brge	.-62     	; 0x37b4 <recievePayload+0x42>
					PORTB &= ~0x80;
					return -1;
     			}
     			vTaskDelay(1);
   		}
			data = UDR2;
    37f2:	86 ed       	ldi	r24, 0xD6	; 214
    37f4:	90 e0       	ldi	r25, 0x00	; 0
    37f6:	fc 01       	movw	r30, r24
    37f8:	80 81       	ld	r24, Z
    37fa:	89 87       	std	Y+9, r24	; 0x09
			buffer[bytesRecieved] = data;
    37fc:	89 81       	ldd	r24, Y+1	; 0x01
    37fe:	9a 81       	ldd	r25, Y+2	; 0x02
    3800:	2c 85       	ldd	r18, Y+12	; 0x0c
    3802:	3d 85       	ldd	r19, Y+13	; 0x0d
    3804:	82 0f       	add	r24, r18
    3806:	93 1f       	adc	r25, r19
    3808:	29 85       	ldd	r18, Y+9	; 0x09
    380a:	fc 01       	movw	r30, r24
    380c:	20 83       	st	Z, r18
			bytesRecieved++;
    380e:	89 81       	ldd	r24, Y+1	; 0x01
    3810:	9a 81       	ldd	r25, Y+2	; 0x02
    3812:	01 96       	adiw	r24, 0x01	; 1
    3814:	9a 83       	std	Y+2, r25	; 0x02
    3816:	89 83       	std	Y+1, r24	; 0x01
			PORTB = bytesRecieved << 4;
    3818:	85 e2       	ldi	r24, 0x25	; 37
    381a:	90 e0       	ldi	r25, 0x00	; 0
    381c:	29 81       	ldd	r18, Y+1	; 0x01
    381e:	22 95       	swap	r18
    3820:	20 7f       	andi	r18, 0xF0	; 240
    3822:	fc 01       	movw	r30, r24
    3824:	20 83       	st	Z, r18
	unsigned char data;
	int timeout;

	while(numTries < maxNumTries){
		PORTB = 0;
		while(bytesRecieved < size){
    3826:	29 81       	ldd	r18, Y+1	; 0x01
    3828:	3a 81       	ldd	r19, Y+2	; 0x02
    382a:	8a 85       	ldd	r24, Y+10	; 0x0a
    382c:	9b 85       	ldd	r25, Y+11	; 0x0b
    382e:	28 17       	cp	r18, r24
    3830:	39 07       	cpc	r19, r25
    3832:	0c f4       	brge	.+2      	; 0x3836 <recievePayload+0xc4>
    3834:	ba cf       	rjmp	.-140    	; 0x37aa <recievePayload+0x38>
			buffer[bytesRecieved] = data;
			bytesRecieved++;
			PORTB = bytesRecieved << 4;
		}
		
		timeout = 50;
    3836:	82 e3       	ldi	r24, 0x32	; 50
    3838:	90 e0       	ldi	r25, 0x00	; 0
    383a:	9e 83       	std	Y+6, r25	; 0x06
    383c:	8d 83       	std	Y+5, r24	; 0x05
		while ( !(UCSR2A & (1<<RXC2)) ){
    383e:	19 c0       	rjmp	.+50     	; 0x3872 <recievePayload+0x100>
  			timeout--;
    3840:	8d 81       	ldd	r24, Y+5	; 0x05
    3842:	9e 81       	ldd	r25, Y+6	; 0x06
    3844:	01 97       	sbiw	r24, 0x01	; 1
    3846:	9e 83       	std	Y+6, r25	; 0x06
    3848:	8d 83       	std	Y+5, r24	; 0x05
     		if(timeout == 0){
    384a:	8d 81       	ldd	r24, Y+5	; 0x05
    384c:	9e 81       	ldd	r25, Y+6	; 0x06
    384e:	00 97       	sbiw	r24, 0x00	; 0
    3850:	61 f4       	brne	.+24     	; 0x386a <recievePayload+0xf8>
				PORTB &= ~0x80;
    3852:	85 e2       	ldi	r24, 0x25	; 37
    3854:	90 e0       	ldi	r25, 0x00	; 0
    3856:	25 e2       	ldi	r18, 0x25	; 37
    3858:	30 e0       	ldi	r19, 0x00	; 0
    385a:	f9 01       	movw	r30, r18
    385c:	20 81       	ld	r18, Z
    385e:	2f 77       	andi	r18, 0x7F	; 127
    3860:	fc 01       	movw	r30, r24
    3862:	20 83       	st	Z, r18
				return -1;
    3864:	8f ef       	ldi	r24, 0xFF	; 255
    3866:	9f ef       	ldi	r25, 0xFF	; 255
    3868:	38 c0       	rjmp	.+112    	; 0x38da <recievePayload+0x168>
     		}
     		vTaskDelay(1);
    386a:	81 e0       	ldi	r24, 0x01	; 1
    386c:	90 e0       	ldi	r25, 0x00	; 0
    386e:	0e 94 61 04 	call	0x8c2	; 0x8c2 <vTaskDelay>
			bytesRecieved++;
			PORTB = bytesRecieved << 4;
		}
		
		timeout = 50;
		while ( !(UCSR2A & (1<<RXC2)) ){
    3872:	80 ed       	ldi	r24, 0xD0	; 208
    3874:	90 e0       	ldi	r25, 0x00	; 0
    3876:	fc 01       	movw	r30, r24
    3878:	80 81       	ld	r24, Z
    387a:	88 23       	and	r24, r24
    387c:	0c f7       	brge	.-62     	; 0x3840 <recievePayload+0xce>
				PORTB &= ~0x80;
				return -1;
     		}
     		vTaskDelay(1);
   	}	
		data = UDR2;
    387e:	86 ed       	ldi	r24, 0xD6	; 214
    3880:	90 e0       	ldi	r25, 0x00	; 0
    3882:	fc 01       	movw	r30, r24
    3884:	80 81       	ld	r24, Z
    3886:	89 87       	std	Y+9, r24	; 0x09
		PORTB = (bytesRecieved + 1) << 4;
    3888:	85 e2       	ldi	r24, 0x25	; 37
    388a:	90 e0       	ldi	r25, 0x00	; 0
    388c:	29 81       	ldd	r18, Y+1	; 0x01
    388e:	2f 5f       	subi	r18, 0xFF	; 255
    3890:	22 95       	swap	r18
    3892:	20 7f       	andi	r18, 0xF0	; 240
    3894:	fc 01       	movw	r30, r24
    3896:	20 83       	st	Z, r18
		if(data != calcChecksum(buffer,size)){
    3898:	2a 85       	ldd	r18, Y+10	; 0x0a
    389a:	8c 85       	ldd	r24, Y+12	; 0x0c
    389c:	9d 85       	ldd	r25, Y+13	; 0x0d
    389e:	62 2f       	mov	r22, r18
    38a0:	0e 94 e5 1d 	call	0x3bca	; 0x3bca <calcChecksum>
    38a4:	98 2f       	mov	r25, r24
    38a6:	89 85       	ldd	r24, Y+9	; 0x09
    38a8:	98 17       	cp	r25, r24
    38aa:	41 f0       	breq	.+16     	; 0x38bc <recievePayload+0x14a>
			sendNACK();
    38ac:	0e 94 af 1b 	call	0x375e	; 0x375e <sendNACK>
			numTries++;
    38b0:	8b 81       	ldd	r24, Y+3	; 0x03
    38b2:	9c 81       	ldd	r25, Y+4	; 0x04
    38b4:	01 96       	adiw	r24, 0x01	; 1
    38b6:	9c 83       	std	Y+4, r25	; 0x04
    38b8:	8b 83       	std	Y+3, r24	; 0x03
    38ba:	05 c0       	rjmp	.+10     	; 0x38c6 <recievePayload+0x154>
		} else {
			sendACK();
    38bc:	0e 94 a5 1b 	call	0x374a	; 0x374a <sendACK>
			return 0;
    38c0:	80 e0       	ldi	r24, 0x00	; 0
    38c2:	90 e0       	ldi	r25, 0x00	; 0
    38c4:	0a c0       	rjmp	.+20     	; 0x38da <recievePayload+0x168>
	int numTries = 0;
	const int maxNumTries = 3;
	unsigned char data;
	int timeout;

	while(numTries < maxNumTries){
    38c6:	2b 81       	ldd	r18, Y+3	; 0x03
    38c8:	3c 81       	ldd	r19, Y+4	; 0x04
    38ca:	8f 81       	ldd	r24, Y+7	; 0x07
    38cc:	98 85       	ldd	r25, Y+8	; 0x08
    38ce:	28 17       	cp	r18, r24
    38d0:	39 07       	cpc	r19, r25
    38d2:	0c f4       	brge	.+2      	; 0x38d6 <recievePayload+0x164>
    38d4:	65 cf       	rjmp	.-310    	; 0x37a0 <recievePayload+0x2e>
		} else {
			sendACK();
			return 0;
		}
	}
	return -1;
    38d6:	8f ef       	ldi	r24, 0xFF	; 255
    38d8:	9f ef       	ldi	r25, 0xFF	; 255
}
    38da:	2d 96       	adiw	r28, 0x0d	; 13
    38dc:	0f b6       	in	r0, 0x3f	; 63
    38de:	f8 94       	cli
    38e0:	de bf       	out	0x3e, r29	; 62
    38e2:	0f be       	out	0x3f, r0	; 63
    38e4:	cd bf       	out	0x3d, r28	; 61
    38e6:	df 91       	pop	r29
    38e8:	cf 91       	pop	r28
    38ea:	08 95       	ret

000038ec <vTaskUSARTRead>:

void vTaskUSARTRead(void *pvParameters){
    38ec:	cf 93       	push	r28
    38ee:	df 93       	push	r29
    38f0:	cd b7       	in	r28, 0x3d	; 61
    38f2:	de b7       	in	r29, 0x3e	; 62
    38f4:	cc 55       	subi	r28, 0x5C	; 92
    38f6:	d1 09       	sbc	r29, r1
    38f8:	0f b6       	in	r0, 0x3f	; 63
    38fa:	f8 94       	cli
    38fc:	de bf       	out	0x3e, r29	; 62
    38fe:	0f be       	out	0x3f, r0	; 63
    3900:	cd bf       	out	0x3d, r28	; 61
    3902:	9e 01       	movw	r18, r28
    3904:	25 5a       	subi	r18, 0xA5	; 165
    3906:	3f 4f       	sbci	r19, 0xFF	; 255
    3908:	f9 01       	movw	r30, r18
    390a:	91 83       	std	Z+1, r25	; 0x01
    390c:	80 83       	st	Z, r24
    unsigned char size;
    char groupID;
    char cmd;
    unsigned int timeout;

	DDRB = 0xFF;
    390e:	84 e2       	ldi	r24, 0x24	; 36
    3910:	90 e0       	ldi	r25, 0x00	; 0
    3912:	2f ef       	ldi	r18, 0xFF	; 255
    3914:	fc 01       	movw	r30, r24
    3916:	20 83       	st	Z, r18
    PORTB = 0;
    3918:	85 e2       	ldi	r24, 0x25	; 37
    391a:	90 e0       	ldi	r25, 0x00	; 0
    391c:	fc 01       	movw	r30, r24
    391e:	10 82       	st	Z, r1

    Command command;
    Response response;
    while(1){
        bytesRecieved = 0;
    3920:	19 82       	std	Y+1, r1	; 0x01
        int timeout = 30;
    3922:	8e e1       	ldi	r24, 0x1E	; 30
    3924:	90 e0       	ldi	r25, 0x00	; 0
    3926:	9b 83       	std	Y+3, r25	; 0x03
    3928:	8a 83       	std	Y+2, r24	; 0x02
        while(bytesRecieved < 4){
    392a:	4a c0       	rjmp	.+148    	; 0x39c0 <vTaskUSARTRead+0xd4>
            
            while ( !(UCSR2A & (1<<RXC2)) ){
    392c:	1b c0       	rjmp	.+54     	; 0x3964 <vTaskUSARTRead+0x78>
                timeout--;
    392e:	8a 81       	ldd	r24, Y+2	; 0x02
    3930:	9b 81       	ldd	r25, Y+3	; 0x03
    3932:	01 97       	sbiw	r24, 0x01	; 1
    3934:	9b 83       	std	Y+3, r25	; 0x03
    3936:	8a 83       	std	Y+2, r24	; 0x02
                if(timeout == 0){
    3938:	8a 81       	ldd	r24, Y+2	; 0x02
    393a:	9b 81       	ldd	r25, Y+3	; 0x03
    393c:	00 97       	sbiw	r24, 0x00	; 0
    393e:	71 f4       	brne	.+28     	; 0x395c <vTaskUSARTRead+0x70>
                    bytesRecieved = 0;
    3940:	19 82       	std	Y+1, r1	; 0x01
							PORTB &= ~0x80;
    3942:	85 e2       	ldi	r24, 0x25	; 37
    3944:	90 e0       	ldi	r25, 0x00	; 0
    3946:	25 e2       	ldi	r18, 0x25	; 37
    3948:	30 e0       	ldi	r19, 0x00	; 0
    394a:	f9 01       	movw	r30, r18
    394c:	20 81       	ld	r18, Z
    394e:	2f 77       	andi	r18, 0x7F	; 127
    3950:	fc 01       	movw	r30, r24
    3952:	20 83       	st	Z, r18
                    timeout = 30;
    3954:	8e e1       	ldi	r24, 0x1E	; 30
    3956:	90 e0       	ldi	r25, 0x00	; 0
    3958:	9b 83       	std	Y+3, r25	; 0x03
    395a:	8a 83       	std	Y+2, r24	; 0x02
                }
                vTaskDelay(1);
    395c:	81 e0       	ldi	r24, 0x01	; 1
    395e:	90 e0       	ldi	r25, 0x00	; 0
    3960:	0e 94 61 04 	call	0x8c2	; 0x8c2 <vTaskDelay>
    while(1){
        bytesRecieved = 0;
        int timeout = 30;
        while(bytesRecieved < 4){
            
            while ( !(UCSR2A & (1<<RXC2)) ){
    3964:	80 ed       	ldi	r24, 0xD0	; 208
    3966:	90 e0       	ldi	r25, 0x00	; 0
    3968:	fc 01       	movw	r30, r24
    396a:	80 81       	ld	r24, Z
    396c:	88 23       	and	r24, r24
    396e:	fc f6       	brge	.-66     	; 0x392e <vTaskUSARTRead+0x42>
							PORTB &= ~0x80;
                    timeout = 30;
                }
                vTaskDelay(1);
            }
            data = UDR2;
    3970:	86 ed       	ldi	r24, 0xD6	; 214
    3972:	90 e0       	ldi	r25, 0x00	; 0
    3974:	fc 01       	movw	r30, r24
    3976:	80 81       	ld	r24, Z
    3978:	8c 83       	std	Y+4, r24	; 0x04
            buffer[bytesRecieved] = data;
    397a:	89 81       	ldd	r24, Y+1	; 0x01
    397c:	99 27       	eor	r25, r25
    397e:	87 fd       	sbrc	r24, 7
    3980:	90 95       	com	r25
    3982:	9e 01       	movw	r18, r28
    3984:	2a 5f       	subi	r18, 0xFA	; 250
    3986:	3f 4f       	sbci	r19, 0xFF	; 255
    3988:	82 0f       	add	r24, r18
    398a:	93 1f       	adc	r25, r19
    398c:	2c 81       	ldd	r18, Y+4	; 0x04
    398e:	fc 01       	movw	r30, r24
    3990:	20 83       	st	Z, r18
            bytesRecieved++;        
    3992:	89 81       	ldd	r24, Y+1	; 0x01
    3994:	8f 5f       	subi	r24, 0xFF	; 255
    3996:	89 83       	std	Y+1, r24	; 0x01
				//PORTB &= ~0x30;
				PORTB |= bytesRecieved << 4;
    3998:	85 e2       	ldi	r24, 0x25	; 37
    399a:	90 e0       	ldi	r25, 0x00	; 0
    399c:	25 e2       	ldi	r18, 0x25	; 37
    399e:	30 e0       	ldi	r19, 0x00	; 0
    39a0:	f9 01       	movw	r30, r18
    39a2:	20 81       	ld	r18, Z
    39a4:	42 2f       	mov	r20, r18
    39a6:	29 81       	ldd	r18, Y+1	; 0x01
    39a8:	33 27       	eor	r19, r19
    39aa:	27 fd       	sbrc	r18, 7
    39ac:	30 95       	com	r19
    39ae:	22 95       	swap	r18
    39b0:	32 95       	swap	r19
    39b2:	30 7f       	andi	r19, 0xF0	; 240
    39b4:	32 27       	eor	r19, r18
    39b6:	20 7f       	andi	r18, 0xF0	; 240
    39b8:	32 27       	eor	r19, r18
    39ba:	24 2b       	or	r18, r20
    39bc:	fc 01       	movw	r30, r24
    39be:	20 83       	st	Z, r18
    Command command;
    Response response;
    while(1){
        bytesRecieved = 0;
        int timeout = 30;
        while(bytesRecieved < 4){
    39c0:	89 81       	ldd	r24, Y+1	; 0x01
    39c2:	84 30       	cpi	r24, 0x04	; 4
    39c4:	0c f4       	brge	.+2      	; 0x39c8 <vTaskUSARTRead+0xdc>
    39c6:	b2 cf       	rjmp	.-156    	; 0x392c <vTaskUSARTRead+0x40>
				//PORTB &= ~0x30;
				PORTB |= bytesRecieved << 4;
            
        }

        if(calcChecksum(buffer,3) != buffer[3]){
    39c8:	ce 01       	movw	r24, r28
    39ca:	06 96       	adiw	r24, 0x06	; 6
    39cc:	63 e0       	ldi	r22, 0x03	; 3
    39ce:	0e 94 e5 1d 	call	0x3bca	; 0x3bca <calcChecksum>
    39d2:	98 2f       	mov	r25, r24
    39d4:	89 85       	ldd	r24, Y+9	; 0x09
    39d6:	98 17       	cp	r25, r24
    39d8:	21 f0       	breq	.+8      	; 0x39e2 <vTaskUSARTRead+0xf6>
            sendNACK();
    39da:	0e 94 af 1b 	call	0x375e	; 0x375e <sendNACK>
            bytesRecieved = 0;
    39de:	19 82       	std	Y+1, r1	; 0x01
            processCommand(&command,&response);
            sendResponse(&response);

        }

    }
    39e0:	9f cf       	rjmp	.-194    	; 0x3920 <vTaskUSARTRead+0x34>

        if(calcChecksum(buffer,3) != buffer[3]){
            sendNACK();
            bytesRecieved = 0;
        } else {
            PORTB |= 0x10;
    39e2:	85 e2       	ldi	r24, 0x25	; 37
    39e4:	90 e0       	ldi	r25, 0x00	; 0
    39e6:	25 e2       	ldi	r18, 0x25	; 37
    39e8:	30 e0       	ldi	r19, 0x00	; 0
    39ea:	f9 01       	movw	r30, r18
    39ec:	20 81       	ld	r18, Z
    39ee:	20 61       	ori	r18, 0x10	; 16
    39f0:	fc 01       	movw	r30, r24
    39f2:	20 83       	st	Z, r18
            sendACK();
    39f4:	0e 94 a5 1b 	call	0x374a	; 0x374a <sendACK>
            bytesRecieved = 0;
    39f8:	19 82       	std	Y+1, r1	; 0x01
				command.groupID = buffer[0];
    39fa:	8e 81       	ldd	r24, Y+6	; 0x06
    39fc:	8e 8b       	std	Y+22, r24	; 0x16
				command.cmd = buffer[1];
    39fe:	8f 81       	ldd	r24, Y+7	; 0x07
    3a00:	8f 8b       	std	Y+23, r24	; 0x17
				size = buffer[2];
    3a02:	88 85       	ldd	r24, Y+8	; 0x08
    3a04:	8d 83       	std	Y+5, r24	; 0x05
						continue;	//Restart comms
					}
				}*/
           
 
            processCommand(&command,&response);
    3a06:	9e 01       	movw	r18, r28
    3a08:	27 5c       	subi	r18, 0xC7	; 199
    3a0a:	3f 4f       	sbci	r19, 0xFF	; 255
    3a0c:	ce 01       	movw	r24, r28
    3a0e:	46 96       	adiw	r24, 0x16	; 22
    3a10:	b9 01       	movw	r22, r18
    3a12:	0e 94 b0 1f 	call	0x3f60	; 0x3f60 <processCommand>
            sendResponse(&response);
    3a16:	ce 01       	movw	r24, r28
    3a18:	c9 96       	adiw	r24, 0x39	; 57
    3a1a:	0e 94 10 1d 	call	0x3a20	; 0x3a20 <sendResponse>

        }

    }
    3a1e:	80 cf       	rjmp	.-256    	; 0x3920 <vTaskUSARTRead+0x34>

00003a20 <sendResponse>:

}

int sendResponse(Response* response){
    3a20:	cf 93       	push	r28
    3a22:	df 93       	push	r29
    3a24:	cd b7       	in	r28, 0x3d	; 61
    3a26:	de b7       	in	r29, 0x3e	; 62
    3a28:	28 97       	sbiw	r28, 0x08	; 8
    3a2a:	0f b6       	in	r0, 0x3f	; 63
    3a2c:	f8 94       	cli
    3a2e:	de bf       	out	0x3e, r29	; 62
    3a30:	0f be       	out	0x3f, r0	; 63
    3a32:	cd bf       	out	0x3d, r28	; 61
    3a34:	98 87       	std	Y+8, r25	; 0x08
    3a36:	8f 83       	std	Y+7, r24	; 0x07
    char checksumBuffer[2];
    int i;
    int timeout = 50;
    3a38:	82 e3       	ldi	r24, 0x32	; 50
    3a3a:	90 e0       	ldi	r25, 0x00	; 0
    3a3c:	9c 83       	std	Y+4, r25	; 0x04
    3a3e:	8b 83       	std	Y+3, r24	; 0x03
    while(1){
        	PORTB = 0x20;
    3a40:	85 e2       	ldi	r24, 0x25	; 37
    3a42:	90 e0       	ldi	r25, 0x00	; 0
    3a44:	20 e2       	ldi	r18, 0x20	; 32
    3a46:	fc 01       	movw	r30, r24
    3a48:	20 83       	st	Z, r18
        	USART_Write(response->commandBack);
    3a4a:	8f 81       	ldd	r24, Y+7	; 0x07
    3a4c:	98 85       	ldd	r25, Y+8	; 0x08
    3a4e:	fc 01       	movw	r30, r24
    3a50:	80 81       	ld	r24, Z
    3a52:	0e 94 40 1a 	call	0x3480	; 0x3480 <USART_Write>
			PORTB = 0x10;
    3a56:	85 e2       	ldi	r24, 0x25	; 37
    3a58:	90 e0       	ldi	r25, 0x00	; 0
    3a5a:	20 e1       	ldi	r18, 0x10	; 16
    3a5c:	fc 01       	movw	r30, r24
    3a5e:	20 83       	st	Z, r18
			vTaskDelay(1);
    3a60:	81 e0       	ldi	r24, 0x01	; 1
    3a62:	90 e0       	ldi	r25, 0x00	; 0
    3a64:	0e 94 61 04 	call	0x8c2	; 0x8c2 <vTaskDelay>
        	USART_Write(response->size);
    3a68:	8f 81       	ldd	r24, Y+7	; 0x07
    3a6a:	98 85       	ldd	r25, Y+8	; 0x08
    3a6c:	fc 01       	movw	r30, r24
    3a6e:	81 81       	ldd	r24, Z+1	; 0x01
    3a70:	0e 94 40 1a 	call	0x3480	; 0x3480 <USART_Write>
			PORTB = 0x20;
    3a74:	85 e2       	ldi	r24, 0x25	; 37
    3a76:	90 e0       	ldi	r25, 0x00	; 0
    3a78:	20 e2       	ldi	r18, 0x20	; 32
    3a7a:	fc 01       	movw	r30, r24
    3a7c:	20 83       	st	Z, r18
			vTaskDelay(1);
    3a7e:	81 e0       	ldi	r24, 0x01	; 1
    3a80:	90 e0       	ldi	r25, 0x00	; 0
    3a82:	0e 94 61 04 	call	0x8c2	; 0x8c2 <vTaskDelay>
        	checksumBuffer[0] = response->commandBack;
    3a86:	8f 81       	ldd	r24, Y+7	; 0x07
    3a88:	98 85       	ldd	r25, Y+8	; 0x08
    3a8a:	fc 01       	movw	r30, r24
    3a8c:	80 81       	ld	r24, Z
    3a8e:	8d 83       	std	Y+5, r24	; 0x05
        	checksumBuffer[1] = response->size;
    3a90:	8f 81       	ldd	r24, Y+7	; 0x07
    3a92:	98 85       	ldd	r25, Y+8	; 0x08
    3a94:	fc 01       	movw	r30, r24
    3a96:	81 81       	ldd	r24, Z+1	; 0x01
    3a98:	8e 83       	std	Y+6, r24	; 0x06
        	USART_Write(calcChecksum(checksumBuffer,2));
    3a9a:	ce 01       	movw	r24, r28
    3a9c:	05 96       	adiw	r24, 0x05	; 5
    3a9e:	62 e0       	ldi	r22, 0x02	; 2
    3aa0:	0e 94 e5 1d 	call	0x3bca	; 0x3bca <calcChecksum>
    3aa4:	0e 94 40 1a 	call	0x3480	; 0x3480 <USART_Write>
			PORTB = 0x30;
    3aa8:	85 e2       	ldi	r24, 0x25	; 37
    3aaa:	90 e0       	ldi	r25, 0x00	; 0
    3aac:	20 e3       	ldi	r18, 0x30	; 48
    3aae:	fc 01       	movw	r30, r24
    3ab0:	20 83       	st	Z, r18
        	switch(waitForAck()){
    3ab2:	0e 94 bb 1d 	call	0x3b76	; 0x3b76 <waitForAck>
    3ab6:	99 27       	eor	r25, r25
    3ab8:	87 fd       	sbrc	r24, 7
    3aba:	90 95       	com	r25
    3abc:	00 97       	sbiw	r24, 0x00	; 0
    3abe:	59 f0       	breq	.+22     	; 0x3ad6 <sendResponse+0xb6>
    3ac0:	81 30       	cpi	r24, 0x01	; 1
    3ac2:	91 05       	cpc	r25, r1
    3ac4:	a9 f0       	breq	.+42     	; 0x3af0 <sendResponse+0xd0>
    3ac6:	8f 3f       	cpi	r24, 0xFF	; 255
    3ac8:	ff ef       	ldi	r31, 0xFF	; 255
    3aca:	9f 07       	cpc	r25, r31
    3acc:	09 f0       	breq	.+2      	; 0x3ad0 <sendResponse+0xb0>
           	timeout--;
           	if(!timeout){
              	return -1;
           	}
        	}
    }
    3ace:	b8 cf       	rjmp	.-144    	; 0x3a40 <sendResponse+0x20>
			PORTB = 0x30;
        	switch(waitForAck()){
        	case 1:
           	goto outOfWhile;
        	case -1:
           	return -1;
    3ad0:	8f ef       	ldi	r24, 0xFF	; 255
    3ad2:	9f ef       	ldi	r25, 0xFF	; 255
    3ad4:	47 c0       	rjmp	.+142    	; 0x3b64 <sendResponse+0x144>
        	case 0:
           	timeout--;
    3ad6:	8b 81       	ldd	r24, Y+3	; 0x03
    3ad8:	9c 81       	ldd	r25, Y+4	; 0x04
    3ada:	01 97       	sbiw	r24, 0x01	; 1
    3adc:	9c 83       	std	Y+4, r25	; 0x04
    3ade:	8b 83       	std	Y+3, r24	; 0x03
           	if(!timeout){
    3ae0:	8b 81       	ldd	r24, Y+3	; 0x03
    3ae2:	9c 81       	ldd	r25, Y+4	; 0x04
    3ae4:	00 97       	sbiw	r24, 0x00	; 0
    3ae6:	19 f4       	brne	.+6      	; 0x3aee <sendResponse+0xce>
              	return -1;
    3ae8:	8f ef       	ldi	r24, 0xFF	; 255
    3aea:	9f ef       	ldi	r25, 0xFF	; 255
    3aec:	3b c0       	rjmp	.+118    	; 0x3b64 <sendResponse+0x144>
           	}
        	}
    }
    3aee:	a8 cf       	rjmp	.-176    	; 0x3a40 <sendResponse+0x20>
        	checksumBuffer[1] = response->size;
        	USART_Write(calcChecksum(checksumBuffer,2));
			PORTB = 0x30;
        	switch(waitForAck()){
        	case 1:
           	goto outOfWhile;
    3af0:	00 00       	nop
        	}
    }

    outOfWhile:

    PORTB = 0;
    3af2:	85 e2       	ldi	r24, 0x25	; 37
    3af4:	90 e0       	ldi	r25, 0x00	; 0
    3af6:	fc 01       	movw	r30, r24
    3af8:	10 82       	st	Z, r1

    for(i=0;i<response->size;i++){
    3afa:	1a 82       	std	Y+2, r1	; 0x02
    3afc:	19 82       	std	Y+1, r1	; 0x01
    3afe:	14 c0       	rjmp	.+40     	; 0x3b28 <sendResponse+0x108>
        USART_Write(response->payload[i]);
    3b00:	2f 81       	ldd	r18, Y+7	; 0x07
    3b02:	38 85       	ldd	r19, Y+8	; 0x08
    3b04:	89 81       	ldd	r24, Y+1	; 0x01
    3b06:	9a 81       	ldd	r25, Y+2	; 0x02
    3b08:	82 0f       	add	r24, r18
    3b0a:	93 1f       	adc	r25, r19
    3b0c:	02 96       	adiw	r24, 0x02	; 2
    3b0e:	fc 01       	movw	r30, r24
    3b10:	80 81       	ld	r24, Z
    3b12:	0e 94 40 1a 	call	0x3480	; 0x3480 <USART_Write>
			vTaskDelay(1);
    3b16:	81 e0       	ldi	r24, 0x01	; 1
    3b18:	90 e0       	ldi	r25, 0x00	; 0
    3b1a:	0e 94 61 04 	call	0x8c2	; 0x8c2 <vTaskDelay>

    outOfWhile:

    PORTB = 0;

    for(i=0;i<response->size;i++){
    3b1e:	89 81       	ldd	r24, Y+1	; 0x01
    3b20:	9a 81       	ldd	r25, Y+2	; 0x02
    3b22:	01 96       	adiw	r24, 0x01	; 1
    3b24:	9a 83       	std	Y+2, r25	; 0x02
    3b26:	89 83       	std	Y+1, r24	; 0x01
    3b28:	8f 81       	ldd	r24, Y+7	; 0x07
    3b2a:	98 85       	ldd	r25, Y+8	; 0x08
    3b2c:	fc 01       	movw	r30, r24
    3b2e:	81 81       	ldd	r24, Z+1	; 0x01
    3b30:	28 2f       	mov	r18, r24
    3b32:	33 27       	eor	r19, r19
    3b34:	27 fd       	sbrc	r18, 7
    3b36:	30 95       	com	r19
    3b38:	89 81       	ldd	r24, Y+1	; 0x01
    3b3a:	9a 81       	ldd	r25, Y+2	; 0x02
    3b3c:	82 17       	cp	r24, r18
    3b3e:	93 07       	cpc	r25, r19
    3b40:	fc f2       	brlt	.-66     	; 0x3b00 <sendResponse+0xe0>
        USART_Write(response->payload[i]);
			vTaskDelay(1);
		  //USART_AddToQueue(0x30 | (i + 2));
        //USART_AddToQueue()
    }
    USART_Write(calcChecksum((uint8_t*)response->payload,response->size));
    3b42:	8f 81       	ldd	r24, Y+7	; 0x07
    3b44:	98 85       	ldd	r25, Y+8	; 0x08
    3b46:	fc 01       	movw	r30, r24
    3b48:	81 81       	ldd	r24, Z+1	; 0x01
    3b4a:	28 2f       	mov	r18, r24
    3b4c:	8f 81       	ldd	r24, Y+7	; 0x07
    3b4e:	98 85       	ldd	r25, Y+8	; 0x08
    3b50:	02 96       	adiw	r24, 0x02	; 2
    3b52:	62 2f       	mov	r22, r18
    3b54:	0e 94 e5 1d 	call	0x3bca	; 0x3bca <calcChecksum>
    3b58:	0e 94 40 1a 	call	0x3480	; 0x3480 <USART_Write>
	 

    waitForAck();
    3b5c:	0e 94 bb 1d 	call	0x3b76	; 0x3b76 <waitForAck>

    return 0;
    3b60:	80 e0       	ldi	r24, 0x00	; 0
    3b62:	90 e0       	ldi	r25, 0x00	; 0

}
    3b64:	28 96       	adiw	r28, 0x08	; 8
    3b66:	0f b6       	in	r0, 0x3f	; 63
    3b68:	f8 94       	cli
    3b6a:	de bf       	out	0x3e, r29	; 62
    3b6c:	0f be       	out	0x3f, r0	; 63
    3b6e:	cd bf       	out	0x3d, r28	; 61
    3b70:	df 91       	pop	r29
    3b72:	cf 91       	pop	r28
    3b74:	08 95       	ret

00003b76 <waitForAck>:

char waitForAck(){
    3b76:	cf 93       	push	r28
    3b78:	df 93       	push	r29
    3b7a:	1f 92       	push	r1
    3b7c:	1f 92       	push	r1
    3b7e:	cd b7       	in	r28, 0x3d	; 61
    3b80:	de b7       	in	r29, 0x3e	; 62
    int timeout = 5000;
    3b82:	88 e8       	ldi	r24, 0x88	; 136
    3b84:	93 e1       	ldi	r25, 0x13	; 19
    3b86:	9a 83       	std	Y+2, r25	; 0x02
    3b88:	89 83       	std	Y+1, r24	; 0x01
    while ( !(UCSR2A & (1<<RXC2)) ){
    3b8a:	0b c0       	rjmp	.+22     	; 0x3ba2 <waitForAck+0x2c>
        timeout--;
    3b8c:	89 81       	ldd	r24, Y+1	; 0x01
    3b8e:	9a 81       	ldd	r25, Y+2	; 0x02
    3b90:	01 97       	sbiw	r24, 0x01	; 1
    3b92:	9a 83       	std	Y+2, r25	; 0x02
    3b94:	89 83       	std	Y+1, r24	; 0x01
        if(!timeout){
    3b96:	89 81       	ldd	r24, Y+1	; 0x01
    3b98:	9a 81       	ldd	r25, Y+2	; 0x02
    3b9a:	00 97       	sbiw	r24, 0x00	; 0
    3b9c:	11 f4       	brne	.+4      	; 0x3ba2 <waitForAck+0x2c>
            return -1;
    3b9e:	8f ef       	ldi	r24, 0xFF	; 255
    3ba0:	0f c0       	rjmp	.+30     	; 0x3bc0 <waitForAck+0x4a>

}

char waitForAck(){
    int timeout = 5000;
    while ( !(UCSR2A & (1<<RXC2)) ){
    3ba2:	80 ed       	ldi	r24, 0xD0	; 208
    3ba4:	90 e0       	ldi	r25, 0x00	; 0
    3ba6:	fc 01       	movw	r30, r24
    3ba8:	80 81       	ld	r24, Z
    3baa:	88 23       	and	r24, r24
    3bac:	7c f7       	brge	.-34     	; 0x3b8c <waitForAck+0x16>
        timeout--;
        if(!timeout){
            return -1;
        }
    }
    if(UDR2 == ACK_BYTE){
    3bae:	86 ed       	ldi	r24, 0xD6	; 214
    3bb0:	90 e0       	ldi	r25, 0x00	; 0
    3bb2:	fc 01       	movw	r30, r24
    3bb4:	80 81       	ld	r24, Z
    3bb6:	80 38       	cpi	r24, 0x80	; 128
    3bb8:	11 f4       	brne	.+4      	; 0x3bbe <waitForAck+0x48>
        return 1;
    3bba:	81 e0       	ldi	r24, 0x01	; 1
    3bbc:	01 c0       	rjmp	.+2      	; 0x3bc0 <waitForAck+0x4a>
    } else {
        return 0;
    3bbe:	80 e0       	ldi	r24, 0x00	; 0
    }
}
    3bc0:	0f 90       	pop	r0
    3bc2:	0f 90       	pop	r0
    3bc4:	df 91       	pop	r29
    3bc6:	cf 91       	pop	r28
    3bc8:	08 95       	ret

00003bca <calcChecksum>:

uint8_t calcChecksum(uint8_t* buffer,uint8_t size){
    3bca:	cf 93       	push	r28
    3bcc:	df 93       	push	r29
    3bce:	00 d0       	rcall	.+0      	; 0x3bd0 <calcChecksum+0x6>
    3bd0:	00 d0       	rcall	.+0      	; 0x3bd2 <calcChecksum+0x8>
    3bd2:	cd b7       	in	r28, 0x3d	; 61
    3bd4:	de b7       	in	r29, 0x3e	; 62
    3bd6:	9d 83       	std	Y+5, r25	; 0x05
    3bd8:	8c 83       	std	Y+4, r24	; 0x04
    3bda:	6e 83       	std	Y+6, r22	; 0x06
    uint8_t checksum = 0;
    3bdc:	19 82       	std	Y+1, r1	; 0x01
    for(int i = 0; i < size; i++) {
    3bde:	1b 82       	std	Y+3, r1	; 0x03
    3be0:	1a 82       	std	Y+2, r1	; 0x02
    3be2:	11 c0       	rjmp	.+34     	; 0x3c06 <calcChecksum+0x3c>
        checksum += *(buffer++);
    3be4:	8c 81       	ldd	r24, Y+4	; 0x04
    3be6:	9d 81       	ldd	r25, Y+5	; 0x05
    3be8:	9c 01       	movw	r18, r24
    3bea:	2f 5f       	subi	r18, 0xFF	; 255
    3bec:	3f 4f       	sbci	r19, 0xFF	; 255
    3bee:	3d 83       	std	Y+5, r19	; 0x05
    3bf0:	2c 83       	std	Y+4, r18	; 0x04
    3bf2:	fc 01       	movw	r30, r24
    3bf4:	80 81       	ld	r24, Z
    3bf6:	99 81       	ldd	r25, Y+1	; 0x01
    3bf8:	89 0f       	add	r24, r25
    3bfa:	89 83       	std	Y+1, r24	; 0x01
    }
}

uint8_t calcChecksum(uint8_t* buffer,uint8_t size){
    uint8_t checksum = 0;
    for(int i = 0; i < size; i++) {
    3bfc:	8a 81       	ldd	r24, Y+2	; 0x02
    3bfe:	9b 81       	ldd	r25, Y+3	; 0x03
    3c00:	01 96       	adiw	r24, 0x01	; 1
    3c02:	9b 83       	std	Y+3, r25	; 0x03
    3c04:	8a 83       	std	Y+2, r24	; 0x02
    3c06:	8e 81       	ldd	r24, Y+6	; 0x06
    3c08:	28 2f       	mov	r18, r24
    3c0a:	30 e0       	ldi	r19, 0x00	; 0
    3c0c:	8a 81       	ldd	r24, Y+2	; 0x02
    3c0e:	9b 81       	ldd	r25, Y+3	; 0x03
    3c10:	82 17       	cp	r24, r18
    3c12:	93 07       	cpc	r25, r19
    3c14:	3c f3       	brlt	.-50     	; 0x3be4 <calcChecksum+0x1a>
        checksum += *(buffer++);
    }
    return checksum;
    3c16:	89 81       	ldd	r24, Y+1	; 0x01
}
    3c18:	26 96       	adiw	r28, 0x06	; 6
    3c1a:	0f b6       	in	r0, 0x3f	; 63
    3c1c:	f8 94       	cli
    3c1e:	de bf       	out	0x3e, r29	; 62
    3c20:	0f be       	out	0x3f, r0	; 63
    3c22:	cd bf       	out	0x3d, r28	; 61
    3c24:	df 91       	pop	r29
    3c26:	cf 91       	pop	r28
    3c28:	08 95       	ret

00003c2a <commandIntegCheck>:
#include "protocol.h"
#include "Components/Sonar/Sonar.h"


//function to CRC the command structure
char commandIntegCheck(Command *command) {
    3c2a:	cf 93       	push	r28
    3c2c:	df 93       	push	r29
    3c2e:	1f 92       	push	r1
    3c30:	1f 92       	push	r1
    3c32:	cd b7       	in	r28, 0x3d	; 61
    3c34:	de b7       	in	r29, 0x3e	; 62
    3c36:	9a 83       	std	Y+2, r25	; 0x02
    3c38:	89 83       	std	Y+1, r24	; 0x01
   //CRC the command with 0x00 in place of the CRC
   //return success for now
   return 1;
    3c3a:	81 e0       	ldi	r24, 0x01	; 1
}
    3c3c:	0f 90       	pop	r0
    3c3e:	0f 90       	pop	r0
    3c40:	df 91       	pop	r29
    3c42:	cf 91       	pop	r28
    3c44:	08 95       	ret

00003c46 <processUltrasonicCommand>:

char processUltrasonicCommand(char commandCode, void* commandData,char* size, void* responseData) {
    3c46:	cf 93       	push	r28
    3c48:	df 93       	push	r29
    3c4a:	cd b7       	in	r28, 0x3d	; 61
    3c4c:	de b7       	in	r29, 0x3e	; 62
    3c4e:	27 97       	sbiw	r28, 0x07	; 7
    3c50:	0f b6       	in	r0, 0x3f	; 63
    3c52:	f8 94       	cli
    3c54:	de bf       	out	0x3e, r29	; 62
    3c56:	0f be       	out	0x3f, r0	; 63
    3c58:	cd bf       	out	0x3d, r28	; 61
    3c5a:	89 83       	std	Y+1, r24	; 0x01
    3c5c:	7b 83       	std	Y+3, r23	; 0x03
    3c5e:	6a 83       	std	Y+2, r22	; 0x02
    3c60:	5d 83       	std	Y+5, r21	; 0x05
    3c62:	4c 83       	std	Y+4, r20	; 0x04
    3c64:	3f 83       	std	Y+7, r19	; 0x07
    3c66:	2e 83       	std	Y+6, r18	; 0x06
   switch(commandCode) {
    3c68:	89 81       	ldd	r24, Y+1	; 0x01
    3c6a:	99 27       	eor	r25, r25
    3c6c:	87 fd       	sbrc	r24, 7
    3c6e:	90 95       	com	r25
    3c70:	82 30       	cpi	r24, 0x02	; 2
    3c72:	91 05       	cpc	r25, r1
    3c74:	81 f0       	breq	.+32     	; 0x3c96 <processUltrasonicCommand+0x50>
    3c76:	83 30       	cpi	r24, 0x03	; 3
    3c78:	91 05       	cpc	r25, r1
    3c7a:	c1 f0       	breq	.+48     	; 0x3cac <processUltrasonicCommand+0x66>
    3c7c:	81 30       	cpi	r24, 0x01	; 1
    3c7e:	91 05       	cpc	r25, r1
    3c80:	01 f5       	brne	.+64     	; 0x3cc2 <processUltrasonicCommand+0x7c>
      case GET_ALL_SENSORS:
         getAllSensors((int*) responseData);
    3c82:	8e 81       	ldd	r24, Y+6	; 0x06
    3c84:	9f 81       	ldd	r25, Y+7	; 0x07
    3c86:	0e 94 75 21 	call	0x42ea	; 0x42ea <getAllSensors>
         *size = 12;
    3c8a:	8c 81       	ldd	r24, Y+4	; 0x04
    3c8c:	9d 81       	ldd	r25, Y+5	; 0x05
    3c8e:	2c e0       	ldi	r18, 0x0C	; 12
    3c90:	fc 01       	movw	r30, r24
    3c92:	20 83       	st	Z, r18
         break;
    3c94:	16 c0       	rjmp	.+44     	; 0x3cc2 <processUltrasonicCommand+0x7c>
      case GET_CERTAIN_SENSORS:
         getCertainSensor(((char*)commandData)[0], (int*) responseData);
    3c96:	8a 81       	ldd	r24, Y+2	; 0x02
    3c98:	9b 81       	ldd	r25, Y+3	; 0x03
    3c9a:	fc 01       	movw	r30, r24
    3c9c:	20 81       	ld	r18, Z
    3c9e:	8e 81       	ldd	r24, Y+6	; 0x06
    3ca0:	9f 81       	ldd	r25, Y+7	; 0x07
    3ca2:	bc 01       	movw	r22, r24
    3ca4:	82 2f       	mov	r24, r18
    3ca6:	0e 94 a0 21 	call	0x4340	; 0x4340 <getCertainSensor>
         break;
    3caa:	0b c0       	rjmp	.+22     	; 0x3cc2 <processUltrasonicCommand+0x7c>
      case GET_SENSOR_GROUP:
         getSensorGroup(((char*)commandData)[0], (int*) responseData);
    3cac:	8a 81       	ldd	r24, Y+2	; 0x02
    3cae:	9b 81       	ldd	r25, Y+3	; 0x03
    3cb0:	fc 01       	movw	r30, r24
    3cb2:	20 81       	ld	r18, Z
    3cb4:	8e 81       	ldd	r24, Y+6	; 0x06
    3cb6:	9f 81       	ldd	r25, Y+7	; 0x07
    3cb8:	bc 01       	movw	r22, r24
    3cba:	82 2f       	mov	r24, r18
    3cbc:	0e 94 cb 21 	call	0x4396	; 0x4396 <getSensorGroup>
         break;
    3cc0:	00 00       	nop
   }
   //return success for now...
   return 1;
    3cc2:	81 e0       	ldi	r24, 0x01	; 1
}
    3cc4:	27 96       	adiw	r28, 0x07	; 7
    3cc6:	0f b6       	in	r0, 0x3f	; 63
    3cc8:	f8 94       	cli
    3cca:	de bf       	out	0x3e, r29	; 62
    3ccc:	0f be       	out	0x3f, r0	; 63
    3cce:	cd bf       	out	0x3d, r28	; 61
    3cd0:	df 91       	pop	r29
    3cd2:	cf 91       	pop	r28
    3cd4:	08 95       	ret

00003cd6 <processSpeedCommand>:

char processSpeedCommand(char commandCode, void* commandData, void* responseData) {
    3cd6:	cf 93       	push	r28
    3cd8:	df 93       	push	r29
    3cda:	00 d0       	rcall	.+0      	; 0x3cdc <processSpeedCommand+0x6>
    3cdc:	1f 92       	push	r1
    3cde:	1f 92       	push	r1
    3ce0:	cd b7       	in	r28, 0x3d	; 61
    3ce2:	de b7       	in	r29, 0x3e	; 62
    3ce4:	89 83       	std	Y+1, r24	; 0x01
    3ce6:	7b 83       	std	Y+3, r23	; 0x03
    3ce8:	6a 83       	std	Y+2, r22	; 0x02
    3cea:	5d 83       	std	Y+5, r21	; 0x05
    3cec:	4c 83       	std	Y+4, r20	; 0x04
   switch(commandCode) {
    3cee:	89 81       	ldd	r24, Y+1	; 0x01
    3cf0:	99 27       	eor	r25, r25
    3cf2:	87 fd       	sbrc	r24, 7
    3cf4:	90 95       	com	r25
    3cf6:	00 97       	sbiw	r24, 0x00	; 0
    3cf8:	21 f0       	breq	.+8      	; 0x3d02 <processSpeedCommand+0x2c>
    3cfa:	81 30       	cpi	r24, 0x01	; 1
    3cfc:	91 05       	cpc	r25, r1
    3cfe:	31 f0       	breq	.+12     	; 0x3d0c <processSpeedCommand+0x36>
    3d00:	0f c0       	rjmp	.+30     	; 0x3d20 <processSpeedCommand+0x4a>
      case GET_SPEED:
         getSpeed((char*) responseData);
    3d02:	8c 81       	ldd	r24, Y+4	; 0x04
    3d04:	9d 81       	ldd	r25, Y+5	; 0x05
    3d06:	0e 94 73 22 	call	0x44e6	; 0x44e6 <getSpeed>
         break;
    3d0a:	0a c0       	rjmp	.+20     	; 0x3d20 <processSpeedCommand+0x4a>
      case SET_SPEED:
         setSpeed(((char*)commandData)[0]);
    3d0c:	8a 81       	ldd	r24, Y+2	; 0x02
    3d0e:	9b 81       	ldd	r25, Y+3	; 0x03
    3d10:	fc 01       	movw	r30, r24
    3d12:	80 81       	ld	r24, Z
    3d14:	99 27       	eor	r25, r25
    3d16:	87 fd       	sbrc	r24, 7
    3d18:	90 95       	com	r25
    3d1a:	0e 94 85 22 	call	0x450a	; 0x450a <setSpeed>
         break;
    3d1e:	00 00       	nop
   }
   //return success for now
   return 1;
    3d20:	81 e0       	ldi	r24, 0x01	; 1
}
    3d22:	0f 90       	pop	r0
    3d24:	0f 90       	pop	r0
    3d26:	0f 90       	pop	r0
    3d28:	0f 90       	pop	r0
    3d2a:	0f 90       	pop	r0
    3d2c:	df 91       	pop	r29
    3d2e:	cf 91       	pop	r28
    3d30:	08 95       	ret

00003d32 <processSteeringCommand>:

char processSteeringCommand(char commandCode, void* commandData, void* responseData) {
    3d32:	cf 93       	push	r28
    3d34:	df 93       	push	r29
    3d36:	00 d0       	rcall	.+0      	; 0x3d38 <processSteeringCommand+0x6>
    3d38:	1f 92       	push	r1
    3d3a:	1f 92       	push	r1
    3d3c:	cd b7       	in	r28, 0x3d	; 61
    3d3e:	de b7       	in	r29, 0x3e	; 62
    3d40:	89 83       	std	Y+1, r24	; 0x01
    3d42:	7b 83       	std	Y+3, r23	; 0x03
    3d44:	6a 83       	std	Y+2, r22	; 0x02
    3d46:	5d 83       	std	Y+5, r21	; 0x05
    3d48:	4c 83       	std	Y+4, r20	; 0x04
   switch(commandCode) {
    3d4a:	89 81       	ldd	r24, Y+1	; 0x01
    3d4c:	99 27       	eor	r25, r25
    3d4e:	87 fd       	sbrc	r24, 7
    3d50:	90 95       	com	r25
    3d52:	82 30       	cpi	r24, 0x02	; 2
    3d54:	91 05       	cpc	r25, r1
    3d56:	f9 f0       	breq	.+62     	; 0x3d96 <processSteeringCommand+0x64>
    3d58:	83 30       	cpi	r24, 0x03	; 3
    3d5a:	91 05       	cpc	r25, r1
    3d5c:	34 f4       	brge	.+12     	; 0x3d6a <processSteeringCommand+0x38>
    3d5e:	00 97       	sbiw	r24, 0x00	; 0
    3d60:	59 f0       	breq	.+22     	; 0x3d78 <processSteeringCommand+0x46>
    3d62:	81 30       	cpi	r24, 0x01	; 1
    3d64:	91 05       	cpc	r25, r1
    3d66:	91 f0       	breq	.+36     	; 0x3d8c <processSteeringCommand+0x5a>
    3d68:	4c c0       	rjmp	.+152    	; 0x3e02 <processSteeringCommand+0xd0>
    3d6a:	83 30       	cpi	r24, 0x03	; 3
    3d6c:	91 05       	cpc	r25, r1
    3d6e:	c1 f0       	breq	.+48     	; 0x3da0 <processSteeringCommand+0x6e>
    3d70:	84 30       	cpi	r24, 0x04	; 4
    3d72:	91 05       	cpc	r25, r1
    3d74:	91 f1       	breq	.+100    	; 0x3dda <processSteeringCommand+0xa8>
    3d76:	45 c0       	rjmp	.+138    	; 0x3e02 <processSteeringCommand+0xd0>
      case SET_ANGLE:
         setAngle(*((char*)commandData));
    3d78:	8a 81       	ldd	r24, Y+2	; 0x02
    3d7a:	9b 81       	ldd	r25, Y+3	; 0x03
    3d7c:	fc 01       	movw	r30, r24
    3d7e:	80 81       	ld	r24, Z
    3d80:	99 27       	eor	r25, r25
    3d82:	87 fd       	sbrc	r24, 7
    3d84:	90 95       	com	r25
    3d86:	0e 94 90 22 	call	0x4520	; 0x4520 <setAngle>
         break;
    3d8a:	3b c0       	rjmp	.+118    	; 0x3e02 <processSteeringCommand+0xd0>
      case GET_ANGLE:
         getAngle((char*) responseData);
    3d8c:	8c 81       	ldd	r24, Y+4	; 0x04
    3d8e:	9d 81       	ldd	r25, Y+5	; 0x05
    3d90:	0e 94 9b 22 	call	0x4536	; 0x4536 <getAngle>
         break;
    3d94:	36 c0       	rjmp	.+108    	; 0x3e02 <processSteeringCommand+0xd0>
      case GET_DESIRED_ANGLE:
         getDesiredAngle((char*) responseData);
    3d96:	8c 81       	ldd	r24, Y+4	; 0x04
    3d98:	9d 81       	ldd	r25, Y+5	; 0x05
    3d9a:	0e 94 ad 22 	call	0x455a	; 0x455a <getDesiredAngle>
         break;
    3d9e:	31 c0       	rjmp	.+98     	; 0x3e02 <processSteeringCommand+0xd0>
      case CHANGE_PID:
         changePID(((char*)commandData)[0], ((char*)commandData)[1], ((char*)commandData)[2]);
    3da0:	8a 81       	ldd	r24, Y+2	; 0x02
    3da2:	9b 81       	ldd	r25, Y+3	; 0x03
    3da4:	02 96       	adiw	r24, 0x02	; 2
    3da6:	fc 01       	movw	r30, r24
    3da8:	80 81       	ld	r24, Z
    3daa:	48 2f       	mov	r20, r24
    3dac:	55 27       	eor	r21, r21
    3dae:	47 fd       	sbrc	r20, 7
    3db0:	50 95       	com	r21
    3db2:	8a 81       	ldd	r24, Y+2	; 0x02
    3db4:	9b 81       	ldd	r25, Y+3	; 0x03
    3db6:	01 96       	adiw	r24, 0x01	; 1
    3db8:	fc 01       	movw	r30, r24
    3dba:	80 81       	ld	r24, Z
    3dbc:	28 2f       	mov	r18, r24
    3dbe:	33 27       	eor	r19, r19
    3dc0:	27 fd       	sbrc	r18, 7
    3dc2:	30 95       	com	r19
    3dc4:	8a 81       	ldd	r24, Y+2	; 0x02
    3dc6:	9b 81       	ldd	r25, Y+3	; 0x03
    3dc8:	fc 01       	movw	r30, r24
    3dca:	80 81       	ld	r24, Z
    3dcc:	99 27       	eor	r25, r25
    3dce:	87 fd       	sbrc	r24, 7
    3dd0:	90 95       	com	r25
    3dd2:	b9 01       	movw	r22, r18
    3dd4:	0e 94 bf 22 	call	0x457e	; 0x457e <changePID>
         break;
    3dd8:	14 c0       	rjmp	.+40     	; 0x3e02 <processSteeringCommand+0xd0>
      case SET_LIMITS:
         setLimits(((char*)commandData)[0], ((char*)commandData)[1]);
    3dda:	8a 81       	ldd	r24, Y+2	; 0x02
    3ddc:	9b 81       	ldd	r25, Y+3	; 0x03
    3dde:	01 96       	adiw	r24, 0x01	; 1
    3de0:	fc 01       	movw	r30, r24
    3de2:	80 81       	ld	r24, Z
    3de4:	28 2f       	mov	r18, r24
    3de6:	33 27       	eor	r19, r19
    3de8:	27 fd       	sbrc	r18, 7
    3dea:	30 95       	com	r19
    3dec:	8a 81       	ldd	r24, Y+2	; 0x02
    3dee:	9b 81       	ldd	r25, Y+3	; 0x03
    3df0:	fc 01       	movw	r30, r24
    3df2:	80 81       	ld	r24, Z
    3df4:	99 27       	eor	r25, r25
    3df6:	87 fd       	sbrc	r24, 7
    3df8:	90 95       	com	r25
    3dfa:	b9 01       	movw	r22, r18
    3dfc:	0e 94 ce 22 	call	0x459c	; 0x459c <setLimits>
         break;
    3e00:	00 00       	nop
   }
   //return success for now
   return 1;
    3e02:	81 e0       	ldi	r24, 0x01	; 1
}
    3e04:	0f 90       	pop	r0
    3e06:	0f 90       	pop	r0
    3e08:	0f 90       	pop	r0
    3e0a:	0f 90       	pop	r0
    3e0c:	0f 90       	pop	r0
    3e0e:	df 91       	pop	r29
    3e10:	cf 91       	pop	r28
    3e12:	08 95       	ret

00003e14 <processFNRCommand>:

char processFNRCommand(char commandCode, void* commandData, void* responseData) {
    3e14:	cf 93       	push	r28
    3e16:	df 93       	push	r29
    3e18:	00 d0       	rcall	.+0      	; 0x3e1a <processFNRCommand+0x6>
    3e1a:	1f 92       	push	r1
    3e1c:	1f 92       	push	r1
    3e1e:	cd b7       	in	r28, 0x3d	; 61
    3e20:	de b7       	in	r29, 0x3e	; 62
    3e22:	89 83       	std	Y+1, r24	; 0x01
    3e24:	7b 83       	std	Y+3, r23	; 0x03
    3e26:	6a 83       	std	Y+2, r22	; 0x02
    3e28:	5d 83       	std	Y+5, r21	; 0x05
    3e2a:	4c 83       	std	Y+4, r20	; 0x04
   switch(commandCode) {
    3e2c:	89 81       	ldd	r24, Y+1	; 0x01
    3e2e:	99 27       	eor	r25, r25
    3e30:	87 fd       	sbrc	r24, 7
    3e32:	90 95       	com	r25
    3e34:	00 97       	sbiw	r24, 0x00	; 0
    3e36:	21 f0       	breq	.+8      	; 0x3e40 <processFNRCommand+0x2c>
    3e38:	81 30       	cpi	r24, 0x01	; 1
    3e3a:	91 05       	cpc	r25, r1
    3e3c:	59 f0       	breq	.+22     	; 0x3e54 <processFNRCommand+0x40>
    3e3e:	0f c0       	rjmp	.+30     	; 0x3e5e <processFNRCommand+0x4a>
      case SET_FNR:
         setFNR(*((char*)commandData));
    3e40:	8a 81       	ldd	r24, Y+2	; 0x02
    3e42:	9b 81       	ldd	r25, Y+3	; 0x03
    3e44:	fc 01       	movw	r30, r24
    3e46:	80 81       	ld	r24, Z
    3e48:	99 27       	eor	r25, r25
    3e4a:	87 fd       	sbrc	r24, 7
    3e4c:	90 95       	com	r25
    3e4e:	0e 94 1a 20 	call	0x4034	; 0x4034 <setFNR>
         break;
    3e52:	05 c0       	rjmp	.+10     	; 0x3e5e <processFNRCommand+0x4a>
      case GET_FNR:
         getFNR((char*) responseData);
    3e54:	8c 81       	ldd	r24, Y+4	; 0x04
    3e56:	9d 81       	ldd	r25, Y+5	; 0x05
    3e58:	0e 94 25 20 	call	0x404a	; 0x404a <getFNR>
         break;
    3e5c:	00 00       	nop
   }
}
    3e5e:	0f 90       	pop	r0
    3e60:	0f 90       	pop	r0
    3e62:	0f 90       	pop	r0
    3e64:	0f 90       	pop	r0
    3e66:	0f 90       	pop	r0
    3e68:	df 91       	pop	r29
    3e6a:	cf 91       	pop	r28
    3e6c:	08 95       	ret

00003e6e <processBrakeCommand>:

char processBrakeCommand(char commandCode, void* commandData, void* responseData) {
    3e6e:	cf 93       	push	r28
    3e70:	df 93       	push	r29
    3e72:	00 d0       	rcall	.+0      	; 0x3e74 <processBrakeCommand+0x6>
    3e74:	1f 92       	push	r1
    3e76:	1f 92       	push	r1
    3e78:	cd b7       	in	r28, 0x3d	; 61
    3e7a:	de b7       	in	r29, 0x3e	; 62
    3e7c:	89 83       	std	Y+1, r24	; 0x01
    3e7e:	7b 83       	std	Y+3, r23	; 0x03
    3e80:	6a 83       	std	Y+2, r22	; 0x02
    3e82:	5d 83       	std	Y+5, r21	; 0x05
    3e84:	4c 83       	std	Y+4, r20	; 0x04
   switch(commandCode) {
    3e86:	89 81       	ldd	r24, Y+1	; 0x01
    3e88:	99 27       	eor	r25, r25
    3e8a:	87 fd       	sbrc	r24, 7
    3e8c:	90 95       	com	r25
    3e8e:	00 97       	sbiw	r24, 0x00	; 0
    3e90:	21 f0       	breq	.+8      	; 0x3e9a <processBrakeCommand+0x2c>
    3e92:	81 30       	cpi	r24, 0x01	; 1
    3e94:	91 05       	cpc	r25, r1
    3e96:	59 f0       	breq	.+22     	; 0x3eae <processBrakeCommand+0x40>
    3e98:	0f c0       	rjmp	.+30     	; 0x3eb8 <processBrakeCommand+0x4a>
      case SET_BRAKE:
	 setBrake(*((char*)commandData));
    3e9a:	8a 81       	ldd	r24, Y+2	; 0x02
    3e9c:	9b 81       	ldd	r25, Y+3	; 0x03
    3e9e:	fc 01       	movw	r30, r24
    3ea0:	80 81       	ld	r24, Z
    3ea2:	99 27       	eor	r25, r25
    3ea4:	87 fd       	sbrc	r24, 7
    3ea6:	90 95       	com	r25
    3ea8:	0e 94 fd 1f 	call	0x3ffa	; 0x3ffa <setBrake>
	 break;
    3eac:	05 c0       	rjmp	.+10     	; 0x3eb8 <processBrakeCommand+0x4a>
      case GET_BRAKE:
	 getBrake((char*) responseData);
    3eae:	8c 81       	ldd	r24, Y+4	; 0x04
    3eb0:	9d 81       	ldd	r25, Y+5	; 0x05
    3eb2:	0e 94 08 20 	call	0x4010	; 0x4010 <getBrake>
	 break; 
    3eb6:	00 00       	nop
   }
}
    3eb8:	0f 90       	pop	r0
    3eba:	0f 90       	pop	r0
    3ebc:	0f 90       	pop	r0
    3ebe:	0f 90       	pop	r0
    3ec0:	0f 90       	pop	r0
    3ec2:	df 91       	pop	r29
    3ec4:	cf 91       	pop	r28
    3ec6:	08 95       	ret

00003ec8 <processBatteryCommand>:

char processBatteryCommand(char commandCode, void* commandData, void* responseData) {
    3ec8:	cf 93       	push	r28
    3eca:	df 93       	push	r29
    3ecc:	00 d0       	rcall	.+0      	; 0x3ece <processBatteryCommand+0x6>
    3ece:	1f 92       	push	r1
    3ed0:	1f 92       	push	r1
    3ed2:	cd b7       	in	r28, 0x3d	; 61
    3ed4:	de b7       	in	r29, 0x3e	; 62
    3ed6:	89 83       	std	Y+1, r24	; 0x01
    3ed8:	7b 83       	std	Y+3, r23	; 0x03
    3eda:	6a 83       	std	Y+2, r22	; 0x02
    3edc:	5d 83       	std	Y+5, r21	; 0x05
    3ede:	4c 83       	std	Y+4, r20	; 0x04
   switch(commandCode) {
    3ee0:	89 81       	ldd	r24, Y+1	; 0x01
    3ee2:	99 27       	eor	r25, r25
    3ee4:	87 fd       	sbrc	r24, 7
    3ee6:	90 95       	com	r25
    3ee8:	00 97       	sbiw	r24, 0x00	; 0
    3eea:	21 f0       	breq	.+8      	; 0x3ef4 <processBatteryCommand+0x2c>
    3eec:	81 30       	cpi	r24, 0x01	; 1
    3eee:	91 05       	cpc	r25, r1
    3ef0:	31 f0       	breq	.+12     	; 0x3efe <processBatteryCommand+0x36>
    3ef2:	0a c0       	rjmp	.+20     	; 0x3f08 <processBatteryCommand+0x40>
      case GET_BATTERY_VOLTAGE:
         getBatteryVoltage((char*) responseData);
    3ef4:	8c 81       	ldd	r24, Y+4	; 0x04
    3ef6:	9d 81       	ldd	r25, Y+5	; 0x05
    3ef8:	0e 94 d9 1f 	call	0x3fb2	; 0x3fb2 <getBatteryVoltage>
         break;
    3efc:	05 c0       	rjmp	.+10     	; 0x3f08 <processBatteryCommand+0x40>
      case GET_STEERING_VOLTAGE:
         getSteeringVoltage((char*) responseData);
    3efe:	8c 81       	ldd	r24, Y+4	; 0x04
    3f00:	9d 81       	ldd	r25, Y+5	; 0x05
    3f02:	0e 94 eb 1f 	call	0x3fd6	; 0x3fd6 <getSteeringVoltage>
         break;
    3f06:	00 00       	nop
   }
}
    3f08:	0f 90       	pop	r0
    3f0a:	0f 90       	pop	r0
    3f0c:	0f 90       	pop	r0
    3f0e:	0f 90       	pop	r0
    3f10:	0f 90       	pop	r0
    3f12:	df 91       	pop	r29
    3f14:	cf 91       	pop	r28
    3f16:	08 95       	ret

00003f18 <processLightCommand>:

char processLightCommand(char commandCode, void* commandData, void* responseDate) {
    3f18:	cf 93       	push	r28
    3f1a:	df 93       	push	r29
    3f1c:	00 d0       	rcall	.+0      	; 0x3f1e <processLightCommand+0x6>
    3f1e:	1f 92       	push	r1
    3f20:	1f 92       	push	r1
    3f22:	cd b7       	in	r28, 0x3d	; 61
    3f24:	de b7       	in	r29, 0x3e	; 62
    3f26:	89 83       	std	Y+1, r24	; 0x01
    3f28:	7b 83       	std	Y+3, r23	; 0x03
    3f2a:	6a 83       	std	Y+2, r22	; 0x02
    3f2c:	5d 83       	std	Y+5, r21	; 0x05
    3f2e:	4c 83       	std	Y+4, r20	; 0x04
   switch(commandCode) {
    3f30:	89 81       	ldd	r24, Y+1	; 0x01
    3f32:	99 27       	eor	r25, r25
    3f34:	87 fd       	sbrc	r24, 7
    3f36:	90 95       	com	r25
    3f38:	00 97       	sbiw	r24, 0x00	; 0
    3f3a:	51 f4       	brne	.+20     	; 0x3f50 <processLightCommand+0x38>
      case SET_LIGHT:
	 setLight(*((char*)commandData));
    3f3c:	8a 81       	ldd	r24, Y+2	; 0x02
    3f3e:	9b 81       	ldd	r25, Y+3	; 0x03
    3f40:	fc 01       	movw	r30, r24
    3f42:	80 81       	ld	r24, Z
    3f44:	99 27       	eor	r25, r25
    3f46:	87 fd       	sbrc	r24, 7
    3f48:	90 95       	com	r25
    3f4a:	0e 94 37 20 	call	0x406e	; 0x406e <setLight>
         break;
    3f4e:	00 00       	nop
   }
}
    3f50:	0f 90       	pop	r0
    3f52:	0f 90       	pop	r0
    3f54:	0f 90       	pop	r0
    3f56:	0f 90       	pop	r0
    3f58:	0f 90       	pop	r0
    3f5a:	df 91       	pop	r29
    3f5c:	cf 91       	pop	r28
    3f5e:	08 95       	ret

00003f60 <processCommand>:



//Function that will take in a command (as char array) and process it into a
//correct response to be stored into response
char processCommand(Command *command, Response *response) {
    3f60:	cf 93       	push	r28
    3f62:	df 93       	push	r29
    3f64:	00 d0       	rcall	.+0      	; 0x3f66 <processCommand+0x6>
    3f66:	1f 92       	push	r1
    3f68:	cd b7       	in	r28, 0x3d	; 61
    3f6a:	de b7       	in	r29, 0x3e	; 62
    3f6c:	9a 83       	std	Y+2, r25	; 0x02
    3f6e:	89 83       	std	Y+1, r24	; 0x01
    3f70:	7c 83       	std	Y+4, r23	; 0x04
    3f72:	6b 83       	std	Y+3, r22	; 0x03
	response->size = 2;
    3f74:	8b 81       	ldd	r24, Y+3	; 0x03
    3f76:	9c 81       	ldd	r25, Y+4	; 0x04
    3f78:	22 e0       	ldi	r18, 0x02	; 2
    3f7a:	fc 01       	movw	r30, r24
    3f7c:	21 83       	std	Z+1, r18	; 0x01
	response->commandBack = command->cmd;
    3f7e:	89 81       	ldd	r24, Y+1	; 0x01
    3f80:	9a 81       	ldd	r25, Y+2	; 0x02
    3f82:	fc 01       	movw	r30, r24
    3f84:	21 81       	ldd	r18, Z+1	; 0x01
    3f86:	8b 81       	ldd	r24, Y+3	; 0x03
    3f88:	9c 81       	ldd	r25, Y+4	; 0x04
    3f8a:	fc 01       	movw	r30, r24
    3f8c:	20 83       	st	Z, r18
	response->payload[0] = 0xF;
    3f8e:	8b 81       	ldd	r24, Y+3	; 0x03
    3f90:	9c 81       	ldd	r25, Y+4	; 0x04
    3f92:	2f e0       	ldi	r18, 0x0F	; 15
    3f94:	fc 01       	movw	r30, r24
    3f96:	22 83       	std	Z+2, r18	; 0x02
	response->payload[1] = 9;
    3f98:	8b 81       	ldd	r24, Y+3	; 0x03
    3f9a:	9c 81       	ldd	r25, Y+4	; 0x04
    3f9c:	29 e0       	ldi	r18, 0x09	; 9
    3f9e:	fc 01       	movw	r30, r24
    3fa0:	23 83       	std	Z+3, r18	; 0x03
	return 1;
    3fa2:	81 e0       	ldi	r24, 0x01	; 1
      //return a dummy success for now
      return 1;
   } else {
      return 0;
   }
}
    3fa4:	0f 90       	pop	r0
    3fa6:	0f 90       	pop	r0
    3fa8:	0f 90       	pop	r0
    3faa:	0f 90       	pop	r0
    3fac:	df 91       	pop	r29
    3fae:	cf 91       	pop	r28
    3fb0:	08 95       	ret

00003fb2 <getBatteryVoltage>:

//battery controller functions

//read battery strength in a char. Might need to be unsigned, specs don't say
//anything regarding that.
char getBatteryVoltage(char *sensorResponse) {
    3fb2:	cf 93       	push	r28
    3fb4:	df 93       	push	r29
    3fb6:	1f 92       	push	r1
    3fb8:	1f 92       	push	r1
    3fba:	cd b7       	in	r28, 0x3d	; 61
    3fbc:	de b7       	in	r29, 0x3e	; 62
    3fbe:	9a 83       	std	Y+2, r25	; 0x02
    3fc0:	89 83       	std	Y+1, r24	; 0x01
   //fake battery reading
   *sensorResponse = 0;
    3fc2:	89 81       	ldd	r24, Y+1	; 0x01
    3fc4:	9a 81       	ldd	r25, Y+2	; 0x02
    3fc6:	fc 01       	movw	r30, r24
    3fc8:	10 82       	st	Z, r1
   //return success
   return 1;
    3fca:	81 e0       	ldi	r24, 0x01	; 1
}
    3fcc:	0f 90       	pop	r0
    3fce:	0f 90       	pop	r0
    3fd0:	df 91       	pop	r29
    3fd2:	cf 91       	pop	r28
    3fd4:	08 95       	ret

00003fd6 <getSteeringVoltage>:

//gets voltage from steering?
char getSteeringVoltage(char *sensorResponse) {
    3fd6:	cf 93       	push	r28
    3fd8:	df 93       	push	r29
    3fda:	1f 92       	push	r1
    3fdc:	1f 92       	push	r1
    3fde:	cd b7       	in	r28, 0x3d	; 61
    3fe0:	de b7       	in	r29, 0x3e	; 62
    3fe2:	9a 83       	std	Y+2, r25	; 0x02
    3fe4:	89 83       	std	Y+1, r24	; 0x01
   //fake steering voltage reading
   *sensorResponse = 0;
    3fe6:	89 81       	ldd	r24, Y+1	; 0x01
    3fe8:	9a 81       	ldd	r25, Y+2	; 0x02
    3fea:	fc 01       	movw	r30, r24
    3fec:	10 82       	st	Z, r1
   //return success
   return 1;
    3fee:	81 e0       	ldi	r24, 0x01	; 1
}
    3ff0:	0f 90       	pop	r0
    3ff2:	0f 90       	pop	r0
    3ff4:	df 91       	pop	r29
    3ff6:	cf 91       	pop	r28
    3ff8:	08 95       	ret

00003ffa <setBrake>:
//Brake controller functions. THERE IS CURRENTLY NO WAY TO GET THE DESIRED
//BRAKE TARGET IN THE SPECS

//set brake target
char setBrake(char gainTarget) {
    3ffa:	cf 93       	push	r28
    3ffc:	df 93       	push	r29
    3ffe:	1f 92       	push	r1
    4000:	cd b7       	in	r28, 0x3d	; 61
    4002:	de b7       	in	r29, 0x3e	; 62
    4004:	89 83       	std	Y+1, r24	; 0x01
   //dummy function, nothing happens
   //return success
   return 1;
    4006:	81 e0       	ldi	r24, 0x01	; 1
}
    4008:	0f 90       	pop	r0
    400a:	df 91       	pop	r29
    400c:	cf 91       	pop	r28
    400e:	08 95       	ret

00004010 <getBrake>:

//get what is assumed to be the current brake value?
char getBrake(char* sensorResponse) {
    4010:	cf 93       	push	r28
    4012:	df 93       	push	r29
    4014:	1f 92       	push	r1
    4016:	1f 92       	push	r1
    4018:	cd b7       	in	r28, 0x3d	; 61
    401a:	de b7       	in	r29, 0x3e	; 62
    401c:	9a 83       	std	Y+2, r25	; 0x02
    401e:	89 83       	std	Y+1, r24	; 0x01
   //fake brake reading
   *sensorResponse = 0;
    4020:	89 81       	ldd	r24, Y+1	; 0x01
    4022:	9a 81       	ldd	r25, Y+2	; 0x02
    4024:	fc 01       	movw	r30, r24
    4026:	10 82       	st	Z, r1
   //return success
   return 1;
    4028:	81 e0       	ldi	r24, 0x01	; 1
}
    402a:	0f 90       	pop	r0
    402c:	0f 90       	pop	r0
    402e:	df 91       	pop	r29
    4030:	cf 91       	pop	r28
    4032:	08 95       	ret

00004034 <setFNR>:
//FNR controller functions
#include <avr/io.h>

//set the FNR controller, inputs are either -1, 0, or 1.
char setFNR(char FNR) {
    4034:	cf 93       	push	r28
    4036:	df 93       	push	r29
    4038:	1f 92       	push	r1
    403a:	cd b7       	in	r28, 0x3d	; 61
    403c:	de b7       	in	r29, 0x3e	; 62
    403e:	89 83       	std	Y+1, r24	; 0x01
   //dummy function, nothing happens
   //return success
   return 1;
    4040:	81 e0       	ldi	r24, 0x01	; 1
}
    4042:	0f 90       	pop	r0
    4044:	df 91       	pop	r29
    4046:	cf 91       	pop	r28
    4048:	08 95       	ret

0000404a <getFNR>:

//get the current FNR state. Function follows same format for consistancy
char getFNR(char *sensorResponse) {
    404a:	cf 93       	push	r28
    404c:	df 93       	push	r29
    404e:	1f 92       	push	r1
    4050:	1f 92       	push	r1
    4052:	cd b7       	in	r28, 0x3d	; 61
    4054:	de b7       	in	r29, 0x3e	; 62
    4056:	9a 83       	std	Y+2, r25	; 0x02
    4058:	89 83       	std	Y+1, r24	; 0x01
   //fake reading
   *sensorResponse = 0;
    405a:	89 81       	ldd	r24, Y+1	; 0x01
    405c:	9a 81       	ldd	r25, Y+2	; 0x02
    405e:	fc 01       	movw	r30, r24
    4060:	10 82       	st	Z, r1
   //return success
   return 1;
    4062:	81 e0       	ldi	r24, 0x01	; 1
}
    4064:	0f 90       	pop	r0
    4066:	0f 90       	pop	r0
    4068:	df 91       	pop	r29
    406a:	cf 91       	pop	r28
    406c:	08 95       	ret

0000406e <setLight>:
//light controller functions
#include <avr/io.h>

//turn lights on and off
char setLight(char lightTarget) {
    406e:	cf 93       	push	r28
    4070:	df 93       	push	r29
    4072:	1f 92       	push	r1
    4074:	cd b7       	in	r28, 0x3d	; 61
    4076:	de b7       	in	r29, 0x3e	; 62
    4078:	89 83       	std	Y+1, r24	; 0x01
   //dummy function, nothing happens
	if(lightTarget == 1){
    407a:	89 81       	ldd	r24, Y+1	; 0x01
    407c:	81 30       	cpi	r24, 0x01	; 1
    407e:	51 f4       	brne	.+20     	; 0x4094 <setLight+0x26>
		PORTB |= 0x80;
    4080:	85 e2       	ldi	r24, 0x25	; 37
    4082:	90 e0       	ldi	r25, 0x00	; 0
    4084:	25 e2       	ldi	r18, 0x25	; 37
    4086:	30 e0       	ldi	r19, 0x00	; 0
    4088:	f9 01       	movw	r30, r18
    408a:	20 81       	ld	r18, Z
    408c:	20 68       	ori	r18, 0x80	; 128
    408e:	fc 01       	movw	r30, r24
    4090:	20 83       	st	Z, r18
    4092:	09 c0       	rjmp	.+18     	; 0x40a6 <setLight+0x38>
	} else {
		PORTB &= ~0x80;
    4094:	85 e2       	ldi	r24, 0x25	; 37
    4096:	90 e0       	ldi	r25, 0x00	; 0
    4098:	25 e2       	ldi	r18, 0x25	; 37
    409a:	30 e0       	ldi	r19, 0x00	; 0
    409c:	f9 01       	movw	r30, r18
    409e:	20 81       	ld	r18, Z
    40a0:	2f 77       	andi	r18, 0x7F	; 127
    40a2:	fc 01       	movw	r30, r24
    40a4:	20 83       	st	Z, r18
	}
   return 1;
    40a6:	81 e0       	ldi	r24, 0x01	; 1
}
    40a8:	0f 90       	pop	r0
    40aa:	df 91       	pop	r29
    40ac:	cf 91       	pop	r28
    40ae:	08 95       	ret

000040b0 <setSonarData>:
extern int count;

unsigned char currSonar;
unsigned char lastSonarData = 0;
   
void setSonarData(int i,unsigned char data){
    40b0:	cf 93       	push	r28
    40b2:	df 93       	push	r29
    40b4:	00 d0       	rcall	.+0      	; 0x40b6 <setSonarData+0x6>
    40b6:	cd b7       	in	r28, 0x3d	; 61
    40b8:	de b7       	in	r29, 0x3e	; 62
    40ba:	9a 83       	std	Y+2, r25	; 0x02
    40bc:	89 83       	std	Y+1, r24	; 0x01
    40be:	6b 83       	std	Y+3, r22	; 0x03
// xSemaphoreTake(sonarDataMutex[i],portMAX_DELAY);
   sonarData[i] = data;
    40c0:	89 81       	ldd	r24, Y+1	; 0x01
    40c2:	9a 81       	ldd	r25, Y+2	; 0x02
    40c4:	84 53       	subi	r24, 0x34	; 52
    40c6:	95 4e       	sbci	r25, 0xE5	; 229
    40c8:	2b 81       	ldd	r18, Y+3	; 0x03
    40ca:	fc 01       	movw	r30, r24
    40cc:	20 83       	st	Z, r18
   //xSemaphoreGive(sonarDataMutex[i]);
}
    40ce:	0f 90       	pop	r0
    40d0:	0f 90       	pop	r0
    40d2:	0f 90       	pop	r0
    40d4:	df 91       	pop	r29
    40d6:	cf 91       	pop	r28
    40d8:	08 95       	ret

000040da <getSonarData>:

unsigned char getSonarData(int i){
    40da:	cf 93       	push	r28
    40dc:	df 93       	push	r29
    40de:	1f 92       	push	r1
    40e0:	1f 92       	push	r1
    40e2:	cd b7       	in	r28, 0x3d	; 61
    40e4:	de b7       	in	r29, 0x3e	; 62
    40e6:	9a 83       	std	Y+2, r25	; 0x02
    40e8:	89 83       	std	Y+1, r24	; 0x01
   //xSemaphoreTake(sonarDataMutex[i],portMAX_DELAY);
   //return sonarData[i];
   return i + 2;
    40ea:	89 81       	ldd	r24, Y+1	; 0x01
    40ec:	8e 5f       	subi	r24, 0xFE	; 254
   //xSemaphoreGive(sonarDataMutex[i]);
}
    40ee:	0f 90       	pop	r0
    40f0:	0f 90       	pop	r0
    40f2:	df 91       	pop	r29
    40f4:	cf 91       	pop	r28
    40f6:	08 95       	ret

000040f8 <getTimerCount>:

unsigned char getTimerCount(){
    40f8:	cf 93       	push	r28
    40fa:	df 93       	push	r29
    40fc:	cd b7       	in	r28, 0x3d	; 61
    40fe:	de b7       	in	r29, 0x3e	; 62
   return TCNT0;
    4100:	86 e4       	ldi	r24, 0x46	; 70
    4102:	90 e0       	ldi	r25, 0x00	; 0
    4104:	fc 01       	movw	r30, r24
    4106:	80 81       	ld	r24, Z
}
    4108:	df 91       	pop	r29
    410a:	cf 91       	pop	r28
    410c:	08 95       	ret

0000410e <__vector_11>:

inline void setTimerCount(unsigned char i){
   TCNT0 = i;
}

ISR(PCINT2_vect) {
    410e:	1f 92       	push	r1
    4110:	0f 92       	push	r0
    4112:	00 90 5f 00 	lds	r0, 0x005F
    4116:	0f 92       	push	r0
    4118:	11 24       	eor	r1, r1
    411a:	00 90 5b 00 	lds	r0, 0x005B
    411e:	0f 92       	push	r0
    4120:	2f 93       	push	r18
    4122:	3f 93       	push	r19
    4124:	4f 93       	push	r20
    4126:	5f 93       	push	r21
    4128:	6f 93       	push	r22
    412a:	7f 93       	push	r23
    412c:	8f 93       	push	r24
    412e:	9f 93       	push	r25
    4130:	af 93       	push	r26
    4132:	bf 93       	push	r27
    4134:	ef 93       	push	r30
    4136:	ff 93       	push	r31
    4138:	cf 93       	push	r28
    413a:	df 93       	push	r29
    413c:	00 d0       	rcall	.+0      	; 0x413e <__vector_11+0x30>
    413e:	cd b7       	in	r28, 0x3d	; 61
    4140:	de b7       	in	r29, 0x3e	; 62

   unsigned char beginCount;
   unsigned char currCount;
   char i=0;   
    4142:	19 82       	std	Y+1, r1	; 0x01

   if(PINK&(1<<currSonar)){
    4144:	86 e0       	ldi	r24, 0x06	; 6
    4146:	91 e0       	ldi	r25, 0x01	; 1
    4148:	fc 01       	movw	r30, r24
    414a:	80 81       	ld	r24, Z
    414c:	88 2f       	mov	r24, r24
    414e:	90 e0       	ldi	r25, 0x00	; 0
    4150:	20 91 e0 1a 	lds	r18, 0x1AE0
    4154:	22 2f       	mov	r18, r18
    4156:	30 e0       	ldi	r19, 0x00	; 0
    4158:	02 2e       	mov	r0, r18
    415a:	02 c0       	rjmp	.+4      	; 0x4160 <__vector_11+0x52>
    415c:	95 95       	asr	r25
    415e:	87 95       	ror	r24
    4160:	0a 94       	dec	r0
    4162:	e2 f7       	brpl	.-8      	; 0x415c <__vector_11+0x4e>
    4164:	81 70       	andi	r24, 0x01	; 1
    4166:	99 27       	eor	r25, r25
    4168:	00 97       	sbiw	r24, 0x00	; 0
    416a:	49 f0       	breq	.+18     	; 0x417e <__vector_11+0x70>
      //USART_AddToQueue('U');
      beginCount = getTimerCount();
    416c:	0e 94 7c 20 	call	0x40f8	; 0x40f8 <getTimerCount>
    4170:	8a 83       	std	Y+2, r24	; 0x02
      PORTE = 0xFF;
    4172:	8e e2       	ldi	r24, 0x2E	; 46
    4174:	90 e0       	ldi	r25, 0x00	; 0
    4176:	2f ef       	ldi	r18, 0xFF	; 255
    4178:	fc 01       	movw	r30, r24
    417a:	20 83       	st	Z, r18
    417c:	1d c0       	rjmp	.+58     	; 0x41b8 <__vector_11+0xaa>
   } else {
      //USART_AddToQueue('D');
      currCount = getTimerCount();
    417e:	0e 94 7c 20 	call	0x40f8	; 0x40f8 <getTimerCount>
    4182:	8b 83       	std	Y+3, r24	; 0x03
      if(currCount > beginCount){
    4184:	9b 81       	ldd	r25, Y+3	; 0x03
    4186:	8a 81       	ldd	r24, Y+2	; 0x02
    4188:	89 17       	cp	r24, r25
    418a:	38 f4       	brcc	.+14     	; 0x419a <__vector_11+0x8c>
         lastSonarData = currCount - beginCount;
    418c:	9b 81       	ldd	r25, Y+3	; 0x03
    418e:	8a 81       	ldd	r24, Y+2	; 0x02
    4190:	f9 2f       	mov	r31, r25
    4192:	f8 1b       	sub	r31, r24
    4194:	8f 2f       	mov	r24, r31
    4196:	80 93 c3 1a 	sts	0x1AC3, r24
      }
      PORTE = 0;
    419a:	8e e2       	ldi	r24, 0x2E	; 46
    419c:	90 e0       	ldi	r25, 0x00	; 0
    419e:	fc 01       	movw	r30, r24
    41a0:	10 82       	st	Z, r1
      xSemaphoreGiveFromISR(sonarSemaphore,0);
    41a2:	80 91 d2 1a 	lds	r24, 0x1AD2
    41a6:	90 91 d3 1a 	lds	r25, 0x1AD3
    41aa:	20 e0       	ldi	r18, 0x00	; 0
    41ac:	40 e0       	ldi	r20, 0x00	; 0
    41ae:	50 e0       	ldi	r21, 0x00	; 0
    41b0:	60 e0       	ldi	r22, 0x00	; 0
    41b2:	70 e0       	ldi	r23, 0x00	; 0
    41b4:	0e 94 34 0e 	call	0x1c68	; 0x1c68 <xQueueGenericSendFromISR>
   }

}
    41b8:	0f 90       	pop	r0
    41ba:	0f 90       	pop	r0
    41bc:	0f 90       	pop	r0
    41be:	df 91       	pop	r29
    41c0:	cf 91       	pop	r28
    41c2:	ff 91       	pop	r31
    41c4:	ef 91       	pop	r30
    41c6:	bf 91       	pop	r27
    41c8:	af 91       	pop	r26
    41ca:	9f 91       	pop	r25
    41cc:	8f 91       	pop	r24
    41ce:	7f 91       	pop	r23
    41d0:	6f 91       	pop	r22
    41d2:	5f 91       	pop	r21
    41d4:	4f 91       	pop	r20
    41d6:	3f 91       	pop	r19
    41d8:	2f 91       	pop	r18
    41da:	0f 90       	pop	r0
    41dc:	00 92 5b 00 	sts	0x005B, r0
    41e0:	0f 90       	pop	r0
    41e2:	00 92 5f 00 	sts	0x005F, r0
    41e6:	0f 90       	pop	r0
    41e8:	1f 90       	pop	r1
    41ea:	18 95       	reti

000041ec <initializeSonarSensors>:

void initializeSonarSensors(){
    41ec:	cf 93       	push	r28
    41ee:	df 93       	push	r29
    41f0:	cd b7       	in	r28, 0x3d	; 61
    41f2:	de b7       	in	r29, 0x3e	; 62
   //DDRD &= 0xFE;   
   DIDR2 = 0;
    41f4:	8d e7       	ldi	r24, 0x7D	; 125
    41f6:	90 e0       	ldi	r25, 0x00	; 0
    41f8:	fc 01       	movw	r30, r24
    41fa:	10 82       	st	Z, r1
   DDRK = 0;
    41fc:	87 e0       	ldi	r24, 0x07	; 7
    41fe:	91 e0       	ldi	r25, 0x01	; 1
    4200:	fc 01       	movw	r30, r24
    4202:	10 82       	st	Z, r1
   DDRC = 0;
    4204:	87 e2       	ldi	r24, 0x27	; 39
    4206:	90 e0       	ldi	r25, 0x00	; 0
    4208:	fc 01       	movw	r30, r24
    420a:	10 82       	st	Z, r1

   PORTC = 0;
    420c:	88 e2       	ldi	r24, 0x28	; 40
    420e:	90 e0       	ldi	r25, 0x00	; 0
    4210:	fc 01       	movw	r30, r24
    4212:	10 82       	st	Z, r1

   //EICRA = 1;
   //EIMSK = 1;

   PCMSK2 = 0xFF;
    4214:	8d e6       	ldi	r24, 0x6D	; 109
    4216:	90 e0       	ldi	r25, 0x00	; 0
    4218:	2f ef       	ldi	r18, 0xFF	; 255
    421a:	fc 01       	movw	r30, r24
    421c:	20 83       	st	Z, r18
   PCICR = 0x7;
    421e:	88 e6       	ldi	r24, 0x68	; 104
    4220:	90 e0       	ldi	r25, 0x00	; 0
    4222:	27 e0       	ldi	r18, 0x07	; 7
    4224:	fc 01       	movw	r30, r24
    4226:	20 83       	st	Z, r18

   TCCR0A = 0;
    4228:	84 e4       	ldi	r24, 0x44	; 68
    422a:	90 e0       	ldi	r25, 0x00	; 0
    422c:	fc 01       	movw	r30, r24
    422e:	10 82       	st	Z, r1
   TCCR0B = 5;
    4230:	85 e4       	ldi	r24, 0x45	; 69
    4232:	90 e0       	ldi	r25, 0x00	; 0
    4234:	25 e0       	ldi	r18, 0x05	; 5
    4236:	fc 01       	movw	r30, r24
    4238:	20 83       	st	Z, r18

}
    423a:	df 91       	pop	r29
    423c:	cf 91       	pop	r28
    423e:	08 95       	ret

00004240 <vTaskSonar>:

void vTaskSonar(void* parameter){
    4240:	cf 93       	push	r28
    4242:	df 93       	push	r29
    4244:	00 d0       	rcall	.+0      	; 0x4246 <vTaskSonar+0x6>
    4246:	1f 92       	push	r1
    4248:	cd b7       	in	r28, 0x3d	; 61
    424a:	de b7       	in	r29, 0x3e	; 62
    424c:	9c 83       	std	Y+4, r25	; 0x04
    424e:	8b 83       	std	Y+3, r24	; 0x03

   int i;
   initializeSonarSensors();
    4250:	0e 94 f6 20 	call	0x41ec	; 0x41ec <initializeSonarSensors>
   
   vSemaphoreCreateBinary(sonarSemaphore);
    4254:	43 e0       	ldi	r20, 0x03	; 3
    4256:	60 e0       	ldi	r22, 0x00	; 0
    4258:	81 e0       	ldi	r24, 0x01	; 1
    425a:	0e 94 d9 0c 	call	0x19b2	; 0x19b2 <xQueueGenericCreate>
    425e:	90 93 d3 1a 	sts	0x1AD3, r25
    4262:	80 93 d2 1a 	sts	0x1AD2, r24
    4266:	80 91 d2 1a 	lds	r24, 0x1AD2
    426a:	90 91 d3 1a 	lds	r25, 0x1AD3
    426e:	00 97       	sbiw	r24, 0x00	; 0
    4270:	59 f0       	breq	.+22     	; 0x4288 <vTaskSonar+0x48>
    4272:	80 91 d2 1a 	lds	r24, 0x1AD2
    4276:	90 91 d3 1a 	lds	r25, 0x1AD3
    427a:	20 e0       	ldi	r18, 0x00	; 0
    427c:	40 e0       	ldi	r20, 0x00	; 0
    427e:	50 e0       	ldi	r21, 0x00	; 0
    4280:	60 e0       	ldi	r22, 0x00	; 0
    4282:	70 e0       	ldi	r23, 0x00	; 0
    4284:	0e 94 90 0d 	call	0x1b20	; 0x1b20 <xQueueGenericSend>
      
   currSonar = 0;
    4288:	10 92 e0 1a 	sts	0x1AE0, r1

   while(1){
      for(i=0;i<2;i++){
    428c:	1a 82       	std	Y+2, r1	; 0x02
    428e:	19 82       	std	Y+1, r1	; 0x01
    4290:	26 c0       	rjmp	.+76     	; 0x42de <vTaskSonar+0x9e>
         currSonar = i;
    4292:	89 81       	ldd	r24, Y+1	; 0x01
    4294:	80 93 e0 1a 	sts	0x1AE0, r24
         PORTC = (1<<i);
    4298:	88 e2       	ldi	r24, 0x28	; 40
    429a:	90 e0       	ldi	r25, 0x00	; 0
    429c:	21 e0       	ldi	r18, 0x01	; 1
    429e:	30 e0       	ldi	r19, 0x00	; 0
    42a0:	09 80       	ldd	r0, Y+1	; 0x01
    42a2:	02 c0       	rjmp	.+4      	; 0x42a8 <vTaskSonar+0x68>
    42a4:	22 0f       	add	r18, r18
    42a6:	33 1f       	adc	r19, r19
    42a8:	0a 94       	dec	r0
    42aa:	e2 f7       	brpl	.-8      	; 0x42a4 <vTaskSonar+0x64>
    42ac:	fc 01       	movw	r30, r24
    42ae:	20 83       	st	Z, r18
         xSemaphoreTake(sonarSemaphore,portMAX_DELAY);
    42b0:	80 91 d2 1a 	lds	r24, 0x1AD2
    42b4:	90 91 d3 1a 	lds	r25, 0x1AD3
    42b8:	20 e0       	ldi	r18, 0x00	; 0
    42ba:	4f ef       	ldi	r20, 0xFF	; 255
    42bc:	5f ef       	ldi	r21, 0xFF	; 255
    42be:	60 e0       	ldi	r22, 0x00	; 0
    42c0:	70 e0       	ldi	r23, 0x00	; 0
    42c2:	0e 94 8d 0e 	call	0x1d1a	; 0x1d1a <xQueueGenericReceive>
         setSonarData(i,lastSonarData);
    42c6:	20 91 c3 1a 	lds	r18, 0x1AC3
    42ca:	89 81       	ldd	r24, Y+1	; 0x01
    42cc:	9a 81       	ldd	r25, Y+2	; 0x02
    42ce:	62 2f       	mov	r22, r18
    42d0:	0e 94 58 20 	call	0x40b0	; 0x40b0 <setSonarData>
   vSemaphoreCreateBinary(sonarSemaphore);
      
   currSonar = 0;

   while(1){
      for(i=0;i<2;i++){
    42d4:	89 81       	ldd	r24, Y+1	; 0x01
    42d6:	9a 81       	ldd	r25, Y+2	; 0x02
    42d8:	01 96       	adiw	r24, 0x01	; 1
    42da:	9a 83       	std	Y+2, r25	; 0x02
    42dc:	89 83       	std	Y+1, r24	; 0x01
    42de:	89 81       	ldd	r24, Y+1	; 0x01
    42e0:	9a 81       	ldd	r25, Y+2	; 0x02
    42e2:	82 30       	cpi	r24, 0x02	; 2
    42e4:	91 05       	cpc	r25, r1
    42e6:	ac f2       	brlt	.-86     	; 0x4292 <vTaskSonar+0x52>
         currSonar = i;
         PORTC = (1<<i);
         xSemaphoreTake(sonarSemaphore,portMAX_DELAY);
         setSonarData(i,lastSonarData);
      }
   }
    42e8:	d1 cf       	rjmp	.-94     	; 0x428c <vTaskSonar+0x4c>

000042ea <getAllSensors>:
            
} 

char getAllSensors(unsigned short* responseData){
    42ea:	cf 93       	push	r28
    42ec:	df 93       	push	r29
    42ee:	00 d0       	rcall	.+0      	; 0x42f0 <getAllSensors+0x6>
    42f0:	1f 92       	push	r1
    42f2:	cd b7       	in	r28, 0x3d	; 61
    42f4:	de b7       	in	r29, 0x3e	; 62
    42f6:	9c 83       	std	Y+4, r25	; 0x04
    42f8:	8b 83       	std	Y+3, r24	; 0x03
   unsigned short i;
   for(i=0;i<6;i++){
    42fa:	1a 82       	std	Y+2, r1	; 0x02
    42fc:	19 82       	std	Y+1, r1	; 0x01
    42fe:	14 c0       	rjmp	.+40     	; 0x4328 <getAllSensors+0x3e>
      //responseData[i] = getSonarData(i);
      responseData[i] = i+1;
    4300:	89 81       	ldd	r24, Y+1	; 0x01
    4302:	9a 81       	ldd	r25, Y+2	; 0x02
    4304:	88 0f       	add	r24, r24
    4306:	99 1f       	adc	r25, r25
    4308:	2b 81       	ldd	r18, Y+3	; 0x03
    430a:	3c 81       	ldd	r19, Y+4	; 0x04
    430c:	82 0f       	add	r24, r18
    430e:	93 1f       	adc	r25, r19
    4310:	29 81       	ldd	r18, Y+1	; 0x01
    4312:	3a 81       	ldd	r19, Y+2	; 0x02
    4314:	2f 5f       	subi	r18, 0xFF	; 255
    4316:	3f 4f       	sbci	r19, 0xFF	; 255
    4318:	fc 01       	movw	r30, r24
    431a:	31 83       	std	Z+1, r19	; 0x01
    431c:	20 83       	st	Z, r18
            
} 

char getAllSensors(unsigned short* responseData){
   unsigned short i;
   for(i=0;i<6;i++){
    431e:	89 81       	ldd	r24, Y+1	; 0x01
    4320:	9a 81       	ldd	r25, Y+2	; 0x02
    4322:	01 96       	adiw	r24, 0x01	; 1
    4324:	9a 83       	std	Y+2, r25	; 0x02
    4326:	89 83       	std	Y+1, r24	; 0x01
    4328:	89 81       	ldd	r24, Y+1	; 0x01
    432a:	9a 81       	ldd	r25, Y+2	; 0x02
    432c:	86 30       	cpi	r24, 0x06	; 6
    432e:	91 05       	cpc	r25, r1
    4330:	38 f3       	brcs	.-50     	; 0x4300 <getAllSensors+0x16>
      //responseData[i] = getSonarData(i);
      responseData[i] = i+1;
   }
}
    4332:	0f 90       	pop	r0
    4334:	0f 90       	pop	r0
    4336:	0f 90       	pop	r0
    4338:	0f 90       	pop	r0
    433a:	df 91       	pop	r29
    433c:	cf 91       	pop	r28
    433e:	08 95       	ret

00004340 <getCertainSensor>:

char getCertainSensor(char commandData,int* responseData){
    4340:	0f 93       	push	r16
    4342:	1f 93       	push	r17
    4344:	cf 93       	push	r28
    4346:	df 93       	push	r29
    4348:	00 d0       	rcall	.+0      	; 0x434a <getCertainSensor+0xa>
    434a:	cd b7       	in	r28, 0x3d	; 61
    434c:	de b7       	in	r29, 0x3e	; 62
    434e:	89 83       	std	Y+1, r24	; 0x01
    4350:	7b 83       	std	Y+3, r23	; 0x03
    4352:	6a 83       	std	Y+2, r22	; 0x02
   if(commandData < 6){
    4354:	89 81       	ldd	r24, Y+1	; 0x01
    4356:	86 30       	cpi	r24, 0x06	; 6
    4358:	b4 f4       	brge	.+44     	; 0x4386 <getCertainSensor+0x46>
      responseData[commandData] = getSonarData(commandData);
    435a:	89 81       	ldd	r24, Y+1	; 0x01
    435c:	99 27       	eor	r25, r25
    435e:	87 fd       	sbrc	r24, 7
    4360:	90 95       	com	r25
    4362:	88 0f       	add	r24, r24
    4364:	99 1f       	adc	r25, r25
    4366:	2a 81       	ldd	r18, Y+2	; 0x02
    4368:	3b 81       	ldd	r19, Y+3	; 0x03
    436a:	89 01       	movw	r16, r18
    436c:	08 0f       	add	r16, r24
    436e:	19 1f       	adc	r17, r25
    4370:	89 81       	ldd	r24, Y+1	; 0x01
    4372:	99 27       	eor	r25, r25
    4374:	87 fd       	sbrc	r24, 7
    4376:	90 95       	com	r25
    4378:	0e 94 6d 20 	call	0x40da	; 0x40da <getSonarData>
    437c:	88 2f       	mov	r24, r24
    437e:	90 e0       	ldi	r25, 0x00	; 0
    4380:	f8 01       	movw	r30, r16
    4382:	91 83       	std	Z+1, r25	; 0x01
    4384:	80 83       	st	Z, r24
   }
}
    4386:	0f 90       	pop	r0
    4388:	0f 90       	pop	r0
    438a:	0f 90       	pop	r0
    438c:	df 91       	pop	r29
    438e:	cf 91       	pop	r28
    4390:	1f 91       	pop	r17
    4392:	0f 91       	pop	r16
    4394:	08 95       	ret

00004396 <getSensorGroup>:

char getSensorGroup(char commandData,int* responseData){
    4396:	0f 93       	push	r16
    4398:	1f 93       	push	r17
    439a:	cf 93       	push	r28
    439c:	df 93       	push	r29
    439e:	00 d0       	rcall	.+0      	; 0x43a0 <getSensorGroup+0xa>
    43a0:	cd b7       	in	r28, 0x3d	; 61
    43a2:	de b7       	in	r29, 0x3e	; 62
    43a4:	89 83       	std	Y+1, r24	; 0x01
    43a6:	7b 83       	std	Y+3, r23	; 0x03
    43a8:	6a 83       	std	Y+2, r22	; 0x02

   switch(commandData){
    43aa:	89 81       	ldd	r24, Y+1	; 0x01
    43ac:	99 27       	eor	r25, r25
    43ae:	87 fd       	sbrc	r24, 7
    43b0:	90 95       	com	r25
    43b2:	81 30       	cpi	r24, 0x01	; 1
    43b4:	91 05       	cpc	r25, r1
    43b6:	01 f1       	breq	.+64     	; 0x43f8 <getSensorGroup+0x62>
    43b8:	82 30       	cpi	r24, 0x02	; 2
    43ba:	91 05       	cpc	r25, r1
    43bc:	b9 f1       	breq	.+110    	; 0x442c <getSensorGroup+0x96>
    43be:	00 97       	sbiw	r24, 0x00	; 0
    43c0:	09 f0       	breq	.+2      	; 0x43c4 <getSensorGroup+0x2e>
    43c2:	4e c0       	rjmp	.+156    	; 0x4460 <getSensorGroup+0xca>
      case SONAR_GROUP_LEFT:
         responseData[0] = getSonarData(0);
    43c4:	80 e0       	ldi	r24, 0x00	; 0
    43c6:	90 e0       	ldi	r25, 0x00	; 0
    43c8:	0e 94 6d 20 	call	0x40da	; 0x40da <getSonarData>
    43cc:	28 2f       	mov	r18, r24
    43ce:	30 e0       	ldi	r19, 0x00	; 0
    43d0:	8a 81       	ldd	r24, Y+2	; 0x02
    43d2:	9b 81       	ldd	r25, Y+3	; 0x03
    43d4:	fc 01       	movw	r30, r24
    43d6:	31 83       	std	Z+1, r19	; 0x01
    43d8:	20 83       	st	Z, r18
         responseData[1] = getSonarData(1);
    43da:	8a 81       	ldd	r24, Y+2	; 0x02
    43dc:	9b 81       	ldd	r25, Y+3	; 0x03
    43de:	8c 01       	movw	r16, r24
    43e0:	0e 5f       	subi	r16, 0xFE	; 254
    43e2:	1f 4f       	sbci	r17, 0xFF	; 255
    43e4:	81 e0       	ldi	r24, 0x01	; 1
    43e6:	90 e0       	ldi	r25, 0x00	; 0
    43e8:	0e 94 6d 20 	call	0x40da	; 0x40da <getSonarData>
    43ec:	88 2f       	mov	r24, r24
    43ee:	90 e0       	ldi	r25, 0x00	; 0
    43f0:	f8 01       	movw	r30, r16
    43f2:	91 83       	std	Z+1, r25	; 0x01
    43f4:	80 83       	st	Z, r24
         break;
    43f6:	34 c0       	rjmp	.+104    	; 0x4460 <getSensorGroup+0xca>
      case SONAR_GROUP_FRONT:
         responseData[0] = getSonarData(2);
    43f8:	82 e0       	ldi	r24, 0x02	; 2
    43fa:	90 e0       	ldi	r25, 0x00	; 0
    43fc:	0e 94 6d 20 	call	0x40da	; 0x40da <getSonarData>
    4400:	28 2f       	mov	r18, r24
    4402:	30 e0       	ldi	r19, 0x00	; 0
    4404:	8a 81       	ldd	r24, Y+2	; 0x02
    4406:	9b 81       	ldd	r25, Y+3	; 0x03
    4408:	fc 01       	movw	r30, r24
    440a:	31 83       	std	Z+1, r19	; 0x01
    440c:	20 83       	st	Z, r18
         responseData[1] = getSonarData(3);
    440e:	8a 81       	ldd	r24, Y+2	; 0x02
    4410:	9b 81       	ldd	r25, Y+3	; 0x03
    4412:	8c 01       	movw	r16, r24
    4414:	0e 5f       	subi	r16, 0xFE	; 254
    4416:	1f 4f       	sbci	r17, 0xFF	; 255
    4418:	83 e0       	ldi	r24, 0x03	; 3
    441a:	90 e0       	ldi	r25, 0x00	; 0
    441c:	0e 94 6d 20 	call	0x40da	; 0x40da <getSonarData>
    4420:	88 2f       	mov	r24, r24
    4422:	90 e0       	ldi	r25, 0x00	; 0
    4424:	f8 01       	movw	r30, r16
    4426:	91 83       	std	Z+1, r25	; 0x01
    4428:	80 83       	st	Z, r24
         break;
    442a:	1a c0       	rjmp	.+52     	; 0x4460 <getSensorGroup+0xca>
      case SONAR_GROUP_RIGHT:
         responseData[0] = getSonarData(4);
    442c:	84 e0       	ldi	r24, 0x04	; 4
    442e:	90 e0       	ldi	r25, 0x00	; 0
    4430:	0e 94 6d 20 	call	0x40da	; 0x40da <getSonarData>
    4434:	28 2f       	mov	r18, r24
    4436:	30 e0       	ldi	r19, 0x00	; 0
    4438:	8a 81       	ldd	r24, Y+2	; 0x02
    443a:	9b 81       	ldd	r25, Y+3	; 0x03
    443c:	fc 01       	movw	r30, r24
    443e:	31 83       	std	Z+1, r19	; 0x01
    4440:	20 83       	st	Z, r18
         responseData[1] = getSonarData(5);
    4442:	8a 81       	ldd	r24, Y+2	; 0x02
    4444:	9b 81       	ldd	r25, Y+3	; 0x03
    4446:	8c 01       	movw	r16, r24
    4448:	0e 5f       	subi	r16, 0xFE	; 254
    444a:	1f 4f       	sbci	r17, 0xFF	; 255
    444c:	85 e0       	ldi	r24, 0x05	; 5
    444e:	90 e0       	ldi	r25, 0x00	; 0
    4450:	0e 94 6d 20 	call	0x40da	; 0x40da <getSonarData>
    4454:	88 2f       	mov	r24, r24
    4456:	90 e0       	ldi	r25, 0x00	; 0
    4458:	f8 01       	movw	r30, r16
    445a:	91 83       	std	Z+1, r25	; 0x01
    445c:	80 83       	st	Z, r24
         break;
    445e:	00 00       	nop
   }

    4460:	0f 90       	pop	r0
    4462:	0f 90       	pop	r0
    4464:	0f 90       	pop	r0
    4466:	df 91       	pop	r29
    4468:	cf 91       	pop	r28
    446a:	1f 91       	pop	r17
    446c:	0f 91       	pop	r16
    446e:	08 95       	ret

00004470 <initSpeedController>:
//Speed Sensor group

#include "spi.h"

void initSpeedController(){
    4470:	cf 93       	push	r28
    4472:	df 93       	push	r29
    4474:	cd b7       	in	r28, 0x3d	; 61
    4476:	de b7       	in	r29, 0x3e	; 62
	SPIsendShort(0x400F);
    4478:	8f e0       	ldi	r24, 0x0F	; 15
    447a:	90 e4       	ldi	r25, 0x40	; 64
    447c:	0e 94 92 23 	call	0x4724	; 0x4724 <SPIsendShort>
}
    4480:	df 91       	pop	r29
    4482:	cf 91       	pop	r28
    4484:	08 95       	ret

00004486 <setPot>:

void setPot(int value){
    4486:	cf 93       	push	r28
    4488:	df 93       	push	r29
    448a:	00 d0       	rcall	.+0      	; 0x448c <setPot+0x6>
    448c:	1f 92       	push	r1
    448e:	cd b7       	in	r28, 0x3d	; 61
    4490:	de b7       	in	r29, 0x3e	; 62
    4492:	9c 83       	std	Y+4, r25	; 0x04
    4494:	8b 83       	std	Y+3, r24	; 0x03
	unsigned short data = 0;
    4496:	1a 82       	std	Y+2, r1	; 0x02
    4498:	19 82       	std	Y+1, r1	; 0x01
	data = value & 0xFF;
    449a:	8b 81       	ldd	r24, Y+3	; 0x03
    449c:	9c 81       	ldd	r25, Y+4	; 0x04
    449e:	99 27       	eor	r25, r25
    44a0:	9a 83       	std	Y+2, r25	; 0x02
    44a2:	89 83       	std	Y+1, r24	; 0x01

	SPIsendShort(data);
    44a4:	89 81       	ldd	r24, Y+1	; 0x01
    44a6:	9a 81       	ldd	r25, Y+2	; 0x02
    44a8:	0e 94 92 23 	call	0x4724	; 0x4724 <SPIsendShort>
}
    44ac:	0f 90       	pop	r0
    44ae:	0f 90       	pop	r0
    44b0:	0f 90       	pop	r0
    44b2:	0f 90       	pop	r0
    44b4:	df 91       	pop	r29
    44b6:	cf 91       	pop	r28
    44b8:	08 95       	ret

000044ba <decrementPot>:

void decrementPot(){
    44ba:	cf 93       	push	r28
    44bc:	df 93       	push	r29
    44be:	cd b7       	in	r28, 0x3d	; 61
    44c0:	de b7       	in	r29, 0x3e	; 62
	SPIsendByte(0x06);
    44c2:	86 e0       	ldi	r24, 0x06	; 6
    44c4:	90 e0       	ldi	r25, 0x00	; 0
    44c6:	0e 94 4c 23 	call	0x4698	; 0x4698 <SPIsendByte>
}
    44ca:	df 91       	pop	r29
    44cc:	cf 91       	pop	r28
    44ce:	08 95       	ret

000044d0 <incrementPot>:

void incrementPot(){
    44d0:	cf 93       	push	r28
    44d2:	df 93       	push	r29
    44d4:	cd b7       	in	r28, 0x3d	; 61
    44d6:	de b7       	in	r29, 0x3e	; 62
	SPIsendByte(0x0A);
    44d8:	8a e0       	ldi	r24, 0x0A	; 10
    44da:	90 e0       	ldi	r25, 0x00	; 0
    44dc:	0e 94 4c 23 	call	0x4698	; 0x4698 <SPIsendByte>
}
    44e0:	df 91       	pop	r29
    44e2:	cf 91       	pop	r28
    44e4:	08 95       	ret

000044e6 <getSpeed>:

//get the speed of the vehicle
char getSpeed(char* sensorResponse) {
    44e6:	cf 93       	push	r28
    44e8:	df 93       	push	r29
    44ea:	1f 92       	push	r1
    44ec:	1f 92       	push	r1
    44ee:	cd b7       	in	r28, 0x3d	; 61
    44f0:	de b7       	in	r29, 0x3e	; 62
    44f2:	9a 83       	std	Y+2, r25	; 0x02
    44f4:	89 83       	std	Y+1, r24	; 0x01
   //store dummy speed value
   *sensorResponse = 0;
    44f6:	89 81       	ldd	r24, Y+1	; 0x01
    44f8:	9a 81       	ldd	r25, Y+2	; 0x02
    44fa:	fc 01       	movw	r30, r24
    44fc:	10 82       	st	Z, r1
   //return success
   return 1;
    44fe:	81 e0       	ldi	r24, 0x01	; 1
}
    4500:	0f 90       	pop	r0
    4502:	0f 90       	pop	r0
    4504:	df 91       	pop	r29
    4506:	cf 91       	pop	r28
    4508:	08 95       	ret

0000450a <setSpeed>:

//will set just the speed of the wheels of the car
char setSpeed(char speedTarget) {
    450a:	cf 93       	push	r28
    450c:	df 93       	push	r29
    450e:	1f 92       	push	r1
    4510:	cd b7       	in	r28, 0x3d	; 61
    4512:	de b7       	in	r29, 0x3e	; 62
    4514:	89 83       	std	Y+1, r24	; 0x01
   //nothing done down here
   //return success
   return 1;
    4516:	81 e0       	ldi	r24, 0x01	; 1
}
    4518:	0f 90       	pop	r0
    451a:	df 91       	pop	r29
    451c:	cf 91       	pop	r28
    451e:	08 95       	ret

00004520 <setAngle>:

//Steering group

//JUST SETS ANGLE TARGET. Actual angle changing is lower level
char setAngle(char angleTarget) {
    4520:	cf 93       	push	r28
    4522:	df 93       	push	r29
    4524:	1f 92       	push	r1
    4526:	cd b7       	in	r28, 0x3d	; 61
    4528:	de b7       	in	r29, 0x3e	; 62
    452a:	89 83       	std	Y+1, r24	; 0x01
   //dummy function, nothing will happen for now...
   //return success
   return 1;
    452c:	81 e0       	ldi	r24, 0x01	; 1
}
    452e:	0f 90       	pop	r0
    4530:	df 91       	pop	r29
    4532:	cf 91       	pop	r28
    4534:	08 95       	ret

00004536 <getAngle>:

//get the current angle of the steering system
char getAngle(char* sensorResponse) {
    4536:	cf 93       	push	r28
    4538:	df 93       	push	r29
    453a:	1f 92       	push	r1
    453c:	1f 92       	push	r1
    453e:	cd b7       	in	r28, 0x3d	; 61
    4540:	de b7       	in	r29, 0x3e	; 62
    4542:	9a 83       	std	Y+2, r25	; 0x02
    4544:	89 83       	std	Y+1, r24	; 0x01
   //store fake angle reading
   *sensorResponse = 0;
    4546:	89 81       	ldd	r24, Y+1	; 0x01
    4548:	9a 81       	ldd	r25, Y+2	; 0x02
    454a:	fc 01       	movw	r30, r24
    454c:	10 82       	st	Z, r1
   //return success
   return 1;
    454e:	81 e0       	ldi	r24, 0x01	; 1
}
    4550:	0f 90       	pop	r0
    4552:	0f 90       	pop	r0
    4554:	df 91       	pop	r29
    4556:	cf 91       	pop	r28
    4558:	08 95       	ret

0000455a <getDesiredAngle>:

//get the angle target. argument name is sensorResponse for the sake of consistancy
char getDesiredAngle(char* sensorResponse) {
    455a:	cf 93       	push	r28
    455c:	df 93       	push	r29
    455e:	1f 92       	push	r1
    4560:	1f 92       	push	r1
    4562:	cd b7       	in	r28, 0x3d	; 61
    4564:	de b7       	in	r29, 0x3e	; 62
    4566:	9a 83       	std	Y+2, r25	; 0x02
    4568:	89 83       	std	Y+1, r24	; 0x01
   //fake response
   *sensorResponse = 0;
    456a:	89 81       	ldd	r24, Y+1	; 0x01
    456c:	9a 81       	ldd	r25, Y+2	; 0x02
    456e:	fc 01       	movw	r30, r24
    4570:	10 82       	st	Z, r1
   //return success
   return 1;
    4572:	81 e0       	ldi	r24, 0x01	; 1
}
    4574:	0f 90       	pop	r0
    4576:	0f 90       	pop	r0
    4578:	df 91       	pop	r29
    457a:	cf 91       	pop	r28
    457c:	08 95       	ret

0000457e <changePID>:

//change the PID controller
char changePID(char P, char I, char D) {
    457e:	cf 93       	push	r28
    4580:	df 93       	push	r29
    4582:	00 d0       	rcall	.+0      	; 0x4584 <changePID+0x6>
    4584:	cd b7       	in	r28, 0x3d	; 61
    4586:	de b7       	in	r29, 0x3e	; 62
    4588:	89 83       	std	Y+1, r24	; 0x01
    458a:	6a 83       	std	Y+2, r22	; 0x02
    458c:	4b 83       	std	Y+3, r20	; 0x03
   //dummy function, nothing happens
   //return success
   return 1;
    458e:	81 e0       	ldi	r24, 0x01	; 1
}
    4590:	0f 90       	pop	r0
    4592:	0f 90       	pop	r0
    4594:	0f 90       	pop	r0
    4596:	df 91       	pop	r29
    4598:	cf 91       	pop	r28
    459a:	08 95       	ret

0000459c <setLimits>:

//not sure what this does. Also not sure why upper and lower are separated
//but its in the specs so...
char setLimits(char upper, char lower) {
    459c:	cf 93       	push	r28
    459e:	df 93       	push	r29
    45a0:	1f 92       	push	r1
    45a2:	1f 92       	push	r1
    45a4:	cd b7       	in	r28, 0x3d	; 61
    45a6:	de b7       	in	r29, 0x3e	; 62
    45a8:	89 83       	std	Y+1, r24	; 0x01
    45aa:	6a 83       	std	Y+2, r22	; 0x02
   //dummy function, nothing happens
   //return success
   return 1;
    45ac:	81 e0       	ldi	r24, 0x01	; 1
}
    45ae:	0f 90       	pop	r0
    45b0:	0f 90       	pop	r0
    45b2:	df 91       	pop	r29
    45b4:	cf 91       	pop	r28
    45b6:	08 95       	ret

000045b8 <initializeSPI>:
const static int mosi_pin = 2;
const static int miso_pin = 3;
const static int sck_pin = 1;
const static int ss_pin = 0; 

void initializeSPI(){
    45b8:	cf 93       	push	r28
    45ba:	df 93       	push	r29
    45bc:	cd b7       	in	r28, 0x3d	; 61
    45be:	de b7       	in	r29, 0x3e	; 62
	SPCR = (1 << SPE)|(1 << MSTR)|(1 << SPR1)|(1 << SPR0);
    45c0:	8c e4       	ldi	r24, 0x4C	; 76
    45c2:	90 e0       	ldi	r25, 0x00	; 0
    45c4:	23 e5       	ldi	r18, 0x53	; 83
    45c6:	fc 01       	movw	r30, r24
    45c8:	20 83       	st	Z, r18
	DDRB |= (1 << ss_pin)|(1 << sck_pin)|(1 << mosi_pin);
    45ca:	84 e2       	ldi	r24, 0x24	; 36
    45cc:	90 e0       	ldi	r25, 0x00	; 0
    45ce:	24 e2       	ldi	r18, 0x24	; 36
    45d0:	30 e0       	ldi	r19, 0x00	; 0
    45d2:	f9 01       	movw	r30, r18
    45d4:	20 81       	ld	r18, Z
    45d6:	62 2f       	mov	r22, r18
    45d8:	40 e0       	ldi	r20, 0x00	; 0
    45da:	50 e0       	ldi	r21, 0x00	; 0
    45dc:	21 e0       	ldi	r18, 0x01	; 1
    45de:	30 e0       	ldi	r19, 0x00	; 0
    45e0:	02 c0       	rjmp	.+4      	; 0x45e6 <initializeSPI+0x2e>
    45e2:	22 0f       	add	r18, r18
    45e4:	33 1f       	adc	r19, r19
    45e6:	4a 95       	dec	r20
    45e8:	e2 f7       	brpl	.-8      	; 0x45e2 <initializeSPI+0x2a>
    45ea:	72 2f       	mov	r23, r18
    45ec:	41 e0       	ldi	r20, 0x01	; 1
    45ee:	50 e0       	ldi	r21, 0x00	; 0
    45f0:	21 e0       	ldi	r18, 0x01	; 1
    45f2:	30 e0       	ldi	r19, 0x00	; 0
    45f4:	02 c0       	rjmp	.+4      	; 0x45fa <initializeSPI+0x42>
    45f6:	22 0f       	add	r18, r18
    45f8:	33 1f       	adc	r19, r19
    45fa:	4a 95       	dec	r20
    45fc:	e2 f7       	brpl	.-8      	; 0x45f6 <initializeSPI+0x3e>
    45fe:	72 2b       	or	r23, r18
    4600:	42 e0       	ldi	r20, 0x02	; 2
    4602:	50 e0       	ldi	r21, 0x00	; 0
    4604:	21 e0       	ldi	r18, 0x01	; 1
    4606:	30 e0       	ldi	r19, 0x00	; 0
    4608:	02 c0       	rjmp	.+4      	; 0x460e <initializeSPI+0x56>
    460a:	22 0f       	add	r18, r18
    460c:	33 1f       	adc	r19, r19
    460e:	4a 95       	dec	r20
    4610:	e2 f7       	brpl	.-8      	; 0x460a <initializeSPI+0x52>
    4612:	27 2b       	or	r18, r23
    4614:	26 2b       	or	r18, r22
    4616:	fc 01       	movw	r30, r24
    4618:	20 83       	st	Z, r18
	DDRB &= ~(1 << miso_pin);
    461a:	84 e2       	ldi	r24, 0x24	; 36
    461c:	90 e0       	ldi	r25, 0x00	; 0
    461e:	24 e2       	ldi	r18, 0x24	; 36
    4620:	30 e0       	ldi	r19, 0x00	; 0
    4622:	f9 01       	movw	r30, r18
    4624:	20 81       	ld	r18, Z
    4626:	62 2f       	mov	r22, r18
    4628:	43 e0       	ldi	r20, 0x03	; 3
    462a:	50 e0       	ldi	r21, 0x00	; 0
    462c:	21 e0       	ldi	r18, 0x01	; 1
    462e:	30 e0       	ldi	r19, 0x00	; 0
    4630:	02 c0       	rjmp	.+4      	; 0x4636 <initializeSPI+0x7e>
    4632:	22 0f       	add	r18, r18
    4634:	33 1f       	adc	r19, r19
    4636:	4a 95       	dec	r20
    4638:	e2 f7       	brpl	.-8      	; 0x4632 <initializeSPI+0x7a>
    463a:	20 95       	com	r18
    463c:	26 23       	and	r18, r22
    463e:	fc 01       	movw	r30, r24
    4640:	20 83       	st	Z, r18
	PORTB |= 1 << ss_pin;
    4642:	85 e2       	ldi	r24, 0x25	; 37
    4644:	90 e0       	ldi	r25, 0x00	; 0
    4646:	25 e2       	ldi	r18, 0x25	; 37
    4648:	30 e0       	ldi	r19, 0x00	; 0
    464a:	f9 01       	movw	r30, r18
    464c:	20 81       	ld	r18, Z
    464e:	62 2f       	mov	r22, r18
    4650:	40 e0       	ldi	r20, 0x00	; 0
    4652:	50 e0       	ldi	r21, 0x00	; 0
    4654:	21 e0       	ldi	r18, 0x01	; 1
    4656:	30 e0       	ldi	r19, 0x00	; 0
    4658:	02 c0       	rjmp	.+4      	; 0x465e <initializeSPI+0xa6>
    465a:	22 0f       	add	r18, r18
    465c:	33 1f       	adc	r19, r19
    465e:	4a 95       	dec	r20
    4660:	e2 f7       	brpl	.-8      	; 0x465a <initializeSPI+0xa2>
    4662:	26 2b       	or	r18, r22
    4664:	fc 01       	movw	r30, r24
    4666:	20 83       	st	Z, r18
	PORTB &= ~(1 << sck_pin);
    4668:	85 e2       	ldi	r24, 0x25	; 37
    466a:	90 e0       	ldi	r25, 0x00	; 0
    466c:	25 e2       	ldi	r18, 0x25	; 37
    466e:	30 e0       	ldi	r19, 0x00	; 0
    4670:	f9 01       	movw	r30, r18
    4672:	20 81       	ld	r18, Z
    4674:	62 2f       	mov	r22, r18
    4676:	41 e0       	ldi	r20, 0x01	; 1
    4678:	50 e0       	ldi	r21, 0x00	; 0
    467a:	21 e0       	ldi	r18, 0x01	; 1
    467c:	30 e0       	ldi	r19, 0x00	; 0
    467e:	04 2e       	mov	r0, r20
    4680:	02 c0       	rjmp	.+4      	; 0x4686 <initializeSPI+0xce>
    4682:	22 0f       	add	r18, r18
    4684:	33 1f       	adc	r19, r19
    4686:	0a 94       	dec	r0
    4688:	e2 f7       	brpl	.-8      	; 0x4682 <initializeSPI+0xca>
    468a:	20 95       	com	r18
    468c:	26 23       	and	r18, r22
    468e:	fc 01       	movw	r30, r24
    4690:	20 83       	st	Z, r18
}
    4692:	df 91       	pop	r29
    4694:	cf 91       	pop	r28
    4696:	08 95       	ret

00004698 <SPIsendByte>:

void SPIsendByte(unsigned char byte){
    4698:	cf 93       	push	r28
    469a:	df 93       	push	r29
    469c:	1f 92       	push	r1
    469e:	cd b7       	in	r28, 0x3d	; 61
    46a0:	de b7       	in	r29, 0x3e	; 62
    46a2:	89 83       	std	Y+1, r24	; 0x01
	PORTB &= ~(1 << ss_pin);
    46a4:	85 e2       	ldi	r24, 0x25	; 37
    46a6:	90 e0       	ldi	r25, 0x00	; 0
    46a8:	25 e2       	ldi	r18, 0x25	; 37
    46aa:	30 e0       	ldi	r19, 0x00	; 0
    46ac:	f9 01       	movw	r30, r18
    46ae:	20 81       	ld	r18, Z
    46b0:	62 2f       	mov	r22, r18
    46b2:	40 e0       	ldi	r20, 0x00	; 0
    46b4:	50 e0       	ldi	r21, 0x00	; 0
    46b6:	21 e0       	ldi	r18, 0x01	; 1
    46b8:	30 e0       	ldi	r19, 0x00	; 0
    46ba:	02 c0       	rjmp	.+4      	; 0x46c0 <SPIsendByte+0x28>
    46bc:	22 0f       	add	r18, r18
    46be:	33 1f       	adc	r19, r19
    46c0:	4a 95       	dec	r20
    46c2:	e2 f7       	brpl	.-8      	; 0x46bc <SPIsendByte+0x24>
    46c4:	20 95       	com	r18
    46c6:	26 23       	and	r18, r22
    46c8:	fc 01       	movw	r30, r24
    46ca:	20 83       	st	Z, r18
	vTaskDelay(1);
    46cc:	81 e0       	ldi	r24, 0x01	; 1
    46ce:	90 e0       	ldi	r25, 0x00	; 0
    46d0:	0e 94 61 04 	call	0x8c2	; 0x8c2 <vTaskDelay>
	SPDR = byte;
    46d4:	8e e4       	ldi	r24, 0x4E	; 78
    46d6:	90 e0       	ldi	r25, 0x00	; 0
    46d8:	29 81       	ldd	r18, Y+1	; 0x01
    46da:	fc 01       	movw	r30, r24
    46dc:	20 83       	st	Z, r18
	while((SPSR & (1 << SPIF)) == 0)
    46de:	00 00       	nop
    46e0:	8d e4       	ldi	r24, 0x4D	; 77
    46e2:	90 e0       	ldi	r25, 0x00	; 0
    46e4:	fc 01       	movw	r30, r24
    46e6:	80 81       	ld	r24, Z
    46e8:	88 23       	and	r24, r24
    46ea:	d4 f7       	brge	.-12     	; 0x46e0 <SPIsendByte+0x48>
	;
	vTaskDelay(1);
    46ec:	81 e0       	ldi	r24, 0x01	; 1
    46ee:	90 e0       	ldi	r25, 0x00	; 0
    46f0:	0e 94 61 04 	call	0x8c2	; 0x8c2 <vTaskDelay>
	PORTB |= (1 << ss_pin);
    46f4:	85 e2       	ldi	r24, 0x25	; 37
    46f6:	90 e0       	ldi	r25, 0x00	; 0
    46f8:	25 e2       	ldi	r18, 0x25	; 37
    46fa:	30 e0       	ldi	r19, 0x00	; 0
    46fc:	f9 01       	movw	r30, r18
    46fe:	20 81       	ld	r18, Z
    4700:	62 2f       	mov	r22, r18
    4702:	40 e0       	ldi	r20, 0x00	; 0
    4704:	50 e0       	ldi	r21, 0x00	; 0
    4706:	21 e0       	ldi	r18, 0x01	; 1
    4708:	30 e0       	ldi	r19, 0x00	; 0
    470a:	04 2e       	mov	r0, r20
    470c:	02 c0       	rjmp	.+4      	; 0x4712 <SPIsendByte+0x7a>
    470e:	22 0f       	add	r18, r18
    4710:	33 1f       	adc	r19, r19
    4712:	0a 94       	dec	r0
    4714:	e2 f7       	brpl	.-8      	; 0x470e <SPIsendByte+0x76>
    4716:	26 2b       	or	r18, r22
    4718:	fc 01       	movw	r30, r24
    471a:	20 83       	st	Z, r18

}
    471c:	0f 90       	pop	r0
    471e:	df 91       	pop	r29
    4720:	cf 91       	pop	r28
    4722:	08 95       	ret

00004724 <SPIsendShort>:

void SPIsendShort(unsigned short data){
    4724:	cf 93       	push	r28
    4726:	df 93       	push	r29
    4728:	1f 92       	push	r1
    472a:	1f 92       	push	r1
    472c:	cd b7       	in	r28, 0x3d	; 61
    472e:	de b7       	in	r29, 0x3e	; 62
    4730:	9a 83       	std	Y+2, r25	; 0x02
    4732:	89 83       	std	Y+1, r24	; 0x01
	PORTB &= ~(1 << ss_pin);
    4734:	85 e2       	ldi	r24, 0x25	; 37
    4736:	90 e0       	ldi	r25, 0x00	; 0
    4738:	25 e2       	ldi	r18, 0x25	; 37
    473a:	30 e0       	ldi	r19, 0x00	; 0
    473c:	f9 01       	movw	r30, r18
    473e:	20 81       	ld	r18, Z
    4740:	62 2f       	mov	r22, r18
    4742:	40 e0       	ldi	r20, 0x00	; 0
    4744:	50 e0       	ldi	r21, 0x00	; 0
    4746:	21 e0       	ldi	r18, 0x01	; 1
    4748:	30 e0       	ldi	r19, 0x00	; 0
    474a:	02 c0       	rjmp	.+4      	; 0x4750 <SPIsendShort+0x2c>
    474c:	22 0f       	add	r18, r18
    474e:	33 1f       	adc	r19, r19
    4750:	4a 95       	dec	r20
    4752:	e2 f7       	brpl	.-8      	; 0x474c <SPIsendShort+0x28>
    4754:	20 95       	com	r18
    4756:	26 23       	and	r18, r22
    4758:	fc 01       	movw	r30, r24
    475a:	20 83       	st	Z, r18
	vTaskDelay(2);
    475c:	82 e0       	ldi	r24, 0x02	; 2
    475e:	90 e0       	ldi	r25, 0x00	; 0
    4760:	0e 94 61 04 	call	0x8c2	; 0x8c2 <vTaskDelay>
	SPDR = (data >> 8);
    4764:	8e e4       	ldi	r24, 0x4E	; 78
    4766:	90 e0       	ldi	r25, 0x00	; 0
    4768:	29 81       	ldd	r18, Y+1	; 0x01
    476a:	3a 81       	ldd	r19, Y+2	; 0x02
    476c:	23 2f       	mov	r18, r19
    476e:	33 27       	eor	r19, r19
    4770:	fc 01       	movw	r30, r24
    4772:	20 83       	st	Z, r18
	while((SPSR & (1 << SPIF)) == 0)
    4774:	00 00       	nop
    4776:	8d e4       	ldi	r24, 0x4D	; 77
    4778:	90 e0       	ldi	r25, 0x00	; 0
    477a:	fc 01       	movw	r30, r24
    477c:	80 81       	ld	r24, Z
    477e:	88 23       	and	r24, r24
    4780:	d4 f7       	brge	.-12     	; 0x4776 <SPIsendShort+0x52>
	;
	SPDR = data & 0xFF;
    4782:	8e e4       	ldi	r24, 0x4E	; 78
    4784:	90 e0       	ldi	r25, 0x00	; 0
    4786:	29 81       	ldd	r18, Y+1	; 0x01
    4788:	fc 01       	movw	r30, r24
    478a:	20 83       	st	Z, r18
	while((SPSR & (1 << SPIF)) == 0)
    478c:	00 00       	nop
    478e:	8d e4       	ldi	r24, 0x4D	; 77
    4790:	90 e0       	ldi	r25, 0x00	; 0
    4792:	fc 01       	movw	r30, r24
    4794:	80 81       	ld	r24, Z
    4796:	88 23       	and	r24, r24
    4798:	d4 f7       	brge	.-12     	; 0x478e <SPIsendShort+0x6a>
	;
	vTaskDelay(2);
    479a:	82 e0       	ldi	r24, 0x02	; 2
    479c:	90 e0       	ldi	r25, 0x00	; 0
    479e:	0e 94 61 04 	call	0x8c2	; 0x8c2 <vTaskDelay>
	PORTB |= (1 << ss_pin);
    47a2:	85 e2       	ldi	r24, 0x25	; 37
    47a4:	90 e0       	ldi	r25, 0x00	; 0
    47a6:	25 e2       	ldi	r18, 0x25	; 37
    47a8:	30 e0       	ldi	r19, 0x00	; 0
    47aa:	f9 01       	movw	r30, r18
    47ac:	20 81       	ld	r18, Z
    47ae:	62 2f       	mov	r22, r18
    47b0:	40 e0       	ldi	r20, 0x00	; 0
    47b2:	50 e0       	ldi	r21, 0x00	; 0
    47b4:	21 e0       	ldi	r18, 0x01	; 1
    47b6:	30 e0       	ldi	r19, 0x00	; 0
    47b8:	04 2e       	mov	r0, r20
    47ba:	02 c0       	rjmp	.+4      	; 0x47c0 <SPIsendShort+0x9c>
    47bc:	22 0f       	add	r18, r18
    47be:	33 1f       	adc	r19, r19
    47c0:	0a 94       	dec	r0
    47c2:	e2 f7       	brpl	.-8      	; 0x47bc <SPIsendShort+0x98>
    47c4:	26 2b       	or	r18, r22
    47c6:	fc 01       	movw	r30, r24
    47c8:	20 83       	st	Z, r18
}
    47ca:	0f 90       	pop	r0
    47cc:	0f 90       	pop	r0
    47ce:	df 91       	pop	r29
    47d0:	cf 91       	pop	r28
    47d2:	08 95       	ret

000047d4 <memcpy>:
    47d4:	fb 01       	movw	r30, r22
    47d6:	dc 01       	movw	r26, r24
    47d8:	02 c0       	rjmp	.+4      	; 0x47de <memcpy+0xa>
    47da:	01 90       	ld	r0, Z+
    47dc:	0d 92       	st	X+, r0
    47de:	41 50       	subi	r20, 0x01	; 1
    47e0:	50 40       	sbci	r21, 0x00	; 0
    47e2:	d8 f7       	brcc	.-10     	; 0x47da <memcpy+0x6>
    47e4:	08 95       	ret

000047e6 <memset>:
    47e6:	dc 01       	movw	r26, r24
    47e8:	01 c0       	rjmp	.+2      	; 0x47ec <memset+0x6>
    47ea:	6d 93       	st	X+, r22
    47ec:	41 50       	subi	r20, 0x01	; 1
    47ee:	50 40       	sbci	r21, 0x00	; 0
    47f0:	e0 f7       	brcc	.-8      	; 0x47ea <memset+0x4>
    47f2:	08 95       	ret

000047f4 <strncpy>:
    47f4:	fb 01       	movw	r30, r22
    47f6:	dc 01       	movw	r26, r24
    47f8:	41 50       	subi	r20, 0x01	; 1
    47fa:	50 40       	sbci	r21, 0x00	; 0
    47fc:	48 f0       	brcs	.+18     	; 0x4810 <strncpy+0x1c>
    47fe:	01 90       	ld	r0, Z+
    4800:	0d 92       	st	X+, r0
    4802:	00 20       	and	r0, r0
    4804:	c9 f7       	brne	.-14     	; 0x47f8 <strncpy+0x4>
    4806:	01 c0       	rjmp	.+2      	; 0x480a <strncpy+0x16>
    4808:	1d 92       	st	X+, r1
    480a:	41 50       	subi	r20, 0x01	; 1
    480c:	50 40       	sbci	r21, 0x00	; 0
    480e:	e0 f7       	brcc	.-8      	; 0x4808 <strncpy+0x14>
    4810:	08 95       	ret

00004812 <itoa>:
    4812:	fb 01       	movw	r30, r22
    4814:	9f 01       	movw	r18, r30
    4816:	e8 94       	clt
    4818:	42 30       	cpi	r20, 0x02	; 2
    481a:	c4 f0       	brlt	.+48     	; 0x484c <itoa+0x3a>
    481c:	45 32       	cpi	r20, 0x25	; 37
    481e:	b4 f4       	brge	.+44     	; 0x484c <itoa+0x3a>
    4820:	4a 30       	cpi	r20, 0x0A	; 10
    4822:	29 f4       	brne	.+10     	; 0x482e <itoa+0x1c>
    4824:	97 fb       	bst	r25, 7
    4826:	1e f4       	brtc	.+6      	; 0x482e <itoa+0x1c>
    4828:	90 95       	com	r25
    482a:	81 95       	neg	r24
    482c:	9f 4f       	sbci	r25, 0xFF	; 255
    482e:	64 2f       	mov	r22, r20
    4830:	77 27       	eor	r23, r23
    4832:	0e 94 3a 24 	call	0x4874	; 0x4874 <__udivmodhi4>
    4836:	80 5d       	subi	r24, 0xD0	; 208
    4838:	8a 33       	cpi	r24, 0x3A	; 58
    483a:	0c f0       	brlt	.+2      	; 0x483e <itoa+0x2c>
    483c:	89 5d       	subi	r24, 0xD9	; 217
    483e:	81 93       	st	Z+, r24
    4840:	cb 01       	movw	r24, r22
    4842:	00 97       	sbiw	r24, 0x00	; 0
    4844:	a1 f7       	brne	.-24     	; 0x482e <itoa+0x1c>
    4846:	16 f4       	brtc	.+4      	; 0x484c <itoa+0x3a>
    4848:	5d e2       	ldi	r21, 0x2D	; 45
    484a:	51 93       	st	Z+, r21
    484c:	10 82       	st	Z, r1
    484e:	c9 01       	movw	r24, r18
    4850:	0c 94 2a 24 	jmp	0x4854	; 0x4854 <strrev>

00004854 <strrev>:
    4854:	dc 01       	movw	r26, r24
    4856:	fc 01       	movw	r30, r24
    4858:	67 2f       	mov	r22, r23
    485a:	71 91       	ld	r23, Z+
    485c:	77 23       	and	r23, r23
    485e:	e1 f7       	brne	.-8      	; 0x4858 <strrev+0x4>
    4860:	32 97       	sbiw	r30, 0x02	; 2
    4862:	04 c0       	rjmp	.+8      	; 0x486c <strrev+0x18>
    4864:	7c 91       	ld	r23, X
    4866:	6d 93       	st	X+, r22
    4868:	70 83       	st	Z, r23
    486a:	62 91       	ld	r22, -Z
    486c:	ae 17       	cp	r26, r30
    486e:	bf 07       	cpc	r27, r31
    4870:	c8 f3       	brcs	.-14     	; 0x4864 <strrev+0x10>
    4872:	08 95       	ret

00004874 <__udivmodhi4>:
    4874:	aa 1b       	sub	r26, r26
    4876:	bb 1b       	sub	r27, r27
    4878:	51 e1       	ldi	r21, 0x11	; 17
    487a:	07 c0       	rjmp	.+14     	; 0x488a <__udivmodhi4_ep>

0000487c <__udivmodhi4_loop>:
    487c:	aa 1f       	adc	r26, r26
    487e:	bb 1f       	adc	r27, r27
    4880:	a6 17       	cp	r26, r22
    4882:	b7 07       	cpc	r27, r23
    4884:	10 f0       	brcs	.+4      	; 0x488a <__udivmodhi4_ep>
    4886:	a6 1b       	sub	r26, r22
    4888:	b7 0b       	sbc	r27, r23

0000488a <__udivmodhi4_ep>:
    488a:	88 1f       	adc	r24, r24
    488c:	99 1f       	adc	r25, r25
    488e:	5a 95       	dec	r21
    4890:	a9 f7       	brne	.-22     	; 0x487c <__udivmodhi4_loop>
    4892:	80 95       	com	r24
    4894:	90 95       	com	r25
    4896:	bc 01       	movw	r22, r24
    4898:	cd 01       	movw	r24, r26
    489a:	08 95       	ret

0000489c <_exit>:
    489c:	f8 94       	cli

0000489e <__stop_program>:
    489e:	ff cf       	rjmp	.-2      	; 0x489e <__stop_program>
