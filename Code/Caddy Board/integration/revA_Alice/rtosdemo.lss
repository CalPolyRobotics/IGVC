
rtosdemo.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000024  00800200  000040ee  00004182  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000040ee  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000018b5  00800224  00800224  000041a6  2**0
                  ALLOC
  3 .stab         00008a24  00000000  00000000  000041a8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00003d66  00000000  00000000  0000cbcc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 72 00 	jmp	0xe4	; 0xe4 <__ctors_end>
       4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
       8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
       c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      10:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      14:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      18:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      1c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      20:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      24:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      28:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      2c:	0c 94 d0 1d 	jmp	0x3ba0	; 0x3ba0 <__vector_11>
      30:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      34:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      38:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      3c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      40:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      44:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      48:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      4c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      50:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      54:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      58:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      5c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      60:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      64:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      68:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      6c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      70:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      74:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      78:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      7c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      80:	0c 94 31 18 	jmp	0x3062	; 0x3062 <__vector_32>
      84:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      88:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      8c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      90:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      94:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      98:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      9c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      a0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      a4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      a8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      ac:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      b0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      b4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      b8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      bc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      c0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      c4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      c8:	0c 94 ee 01 	jmp	0x3dc	; 0x3dc <__vector_50>
      cc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      d0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      d4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      d8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      dc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      e0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	12 e0       	ldi	r17, 0x02	; 2
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	ee ee       	ldi	r30, 0xEE	; 238
      fc:	f0 e4       	ldi	r31, 0x40	; 64
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	a4 32       	cpi	r26, 0x24	; 36
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
     10e:	1a e1       	ldi	r17, 0x1A	; 26
     110:	a4 e2       	ldi	r26, 0x24	; 36
     112:	b2 e0       	ldi	r27, 0x02	; 2
     114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
     116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
     118:	a9 3d       	cpi	r26, 0xD9	; 217
     11a:	b1 07       	cpc	r27, r17
     11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
     11e:	0e 94 ac 00 	call	0x158	; 0x158 <main>
     122:	0c 94 75 20 	jmp	0x40ea	; 0x40ea <_exit>

00000126 <__bad_interrupt>:
     126:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000012a <vApplicationTickHook>:
int count = 0;

int sonarTime;

void vApplicationTickHook()
{
     12a:	df 93       	push	r29
     12c:	cf 93       	push	r28
     12e:	cd b7       	in	r28, 0x3d	; 61
     130:	de b7       	in	r29, 0x3e	; 62
    count++;
     132:	80 91 24 02 	lds	r24, 0x0224
     136:	90 91 25 02 	lds	r25, 0x0225
     13a:	01 96       	adiw	r24, 0x01	; 1
     13c:	90 93 25 02 	sts	0x0225, r25
     140:	80 93 24 02 	sts	0x0224, r24
}
     144:	cf 91       	pop	r28
     146:	df 91       	pop	r29
     148:	08 95       	ret

0000014a <vApplicationStackOverflowHook>:

void vApplicationStackOverflowHook(){
     14a:	df 93       	push	r29
     14c:	cf 93       	push	r28
     14e:	cd b7       	in	r28, 0x3d	; 61
     150:	de b7       	in	r29, 0x3e	; 62
	return;
}
     152:	cf 91       	pop	r28
     154:	df 91       	pop	r29
     156:	08 95       	ret

00000158 <main>:
/*-----------------------------------------------------------*/

int main( void )
{
     158:	af 92       	push	r10
     15a:	bf 92       	push	r11
     15c:	cf 92       	push	r12
     15e:	df 92       	push	r13
     160:	ef 92       	push	r14
     162:	ff 92       	push	r15
     164:	0f 93       	push	r16
     166:	df 93       	push	r29
     168:	cf 93       	push	r28
     16a:	00 d0       	rcall	.+0      	; 0x16c <main+0x14>
     16c:	00 d0       	rcall	.+0      	; 0x16e <main+0x16>
     16e:	cd b7       	in	r28, 0x3d	; 61
     170:	de b7       	in	r29, 0x3e	; 62
    
    //- wimpy variable defs
	uint8_t val[2] = {0x3F, 0xFE};
     172:	8f e3       	ldi	r24, 0x3F	; 63
     174:	8d 83       	std	Y+5, r24	; 0x05
     176:	8e ef       	ldi	r24, 0xFE	; 254
     178:	8e 83       	std	Y+6, r24	; 0x06
    uint8_t *val0, *val1;
    
	//- avoid pesky warnings...
	val0 = val + 0;
     17a:	ce 01       	movw	r24, r28
     17c:	05 96       	adiw	r24, 0x05	; 5
     17e:	9c 83       	std	Y+4, r25	; 0x04
     180:	8b 83       	std	Y+3, r24	; 0x03
	val1 = val + 1;
     182:	ce 01       	movw	r24, r28
     184:	05 96       	adiw	r24, 0x05	; 5
     186:	01 96       	adiw	r24, 0x01	; 1
     188:	9a 83       	std	Y+2, r25	; 0x02
     18a:	89 83       	std	Y+1, r24	; 0x01
    
	DDRD = 0xFF;
     18c:	ea e2       	ldi	r30, 0x2A	; 42
     18e:	f0 e0       	ldi	r31, 0x00	; 0
     190:	8f ef       	ldi	r24, 0xFF	; 255
     192:	80 83       	st	Z, r24
	DDRE = 0xFF;
     194:	ed e2       	ldi	r30, 0x2D	; 45
     196:	f0 e0       	ldi	r31, 0x00	; 0
     198:	8f ef       	ldi	r24, 0xFF	; 255
     19a:	80 83       	st	Z, r24
	DDRK = 0;
     19c:	e7 e0       	ldi	r30, 0x07	; 7
     19e:	f1 e0       	ldi	r31, 0x01	; 1
     1a0:	10 82       	st	Z, r1

	PORTD = 0;
     1a2:	eb e2       	ldi	r30, 0x2B	; 43
     1a4:	f0 e0       	ldi	r31, 0x00	; 0
     1a6:	10 82       	st	Z, r1
	PORTE = 0;
     1a8:	ee e2       	ldi	r30, 0x2E	; 46
     1aa:	f0 e0       	ldi	r31, 0x00	; 0
     1ac:	10 82       	st	Z, r1
	PORTK = 2;
     1ae:	e8 e0       	ldi	r30, 0x08	; 8
     1b0:	f1 e0       	ldi	r31, 0x01	; 1
     1b2:	82 e0       	ldi	r24, 0x02	; 2
     1b4:	80 83       	st	Z, r24

    //- init IO with goodness
	vIO_init();
     1b6:	0e 94 45 02 	call	0x48a	; 0x48a <vIO_init>

	//- Create a 
	xTaskCreate( (pdTASK_CODE) vTaskFunction_1, (signed char *) "T0", configMINIMAL_STACK_SIZE+1000,
     1ba:	87 e2       	ldi	r24, 0x27	; 39
     1bc:	92 e0       	ldi	r25, 0x02	; 2
     1be:	20 e0       	ldi	r18, 0x00	; 0
     1c0:	32 e0       	ldi	r19, 0x02	; 2
     1c2:	e9 81       	ldd	r30, Y+1	; 0x01
     1c4:	fa 81       	ldd	r31, Y+2	; 0x02
     1c6:	b9 01       	movw	r22, r18
     1c8:	4d e3       	ldi	r20, 0x3D	; 61
     1ca:	54 e0       	ldi	r21, 0x04	; 4
     1cc:	9f 01       	movw	r18, r30
     1ce:	01 e0       	ldi	r16, 0x01	; 1
     1d0:	ee 24       	eor	r14, r14
     1d2:	ff 24       	eor	r15, r15
     1d4:	cc 24       	eor	r12, r12
     1d6:	dd 24       	eor	r13, r13
     1d8:	aa 24       	eor	r10, r10
     1da:	bb 24       	eor	r11, r11
     1dc:	0e 94 53 02 	call	0x4a6	; 0x4a6 <xTaskGenericCreate>
                (void *) val1, 1, NULL );
    
   xTaskCreate( (pdTASK_CODE) vTaskSonar, (signed char *) "T1", configMINIMAL_STACK_SIZE+1000,
     1e0:	8b e5       	ldi	r24, 0x5B	; 91
     1e2:	9e e1       	ldi	r25, 0x1E	; 30
     1e4:	23 e0       	ldi	r18, 0x03	; 3
     1e6:	32 e0       	ldi	r19, 0x02	; 2
     1e8:	e9 81       	ldd	r30, Y+1	; 0x01
     1ea:	fa 81       	ldd	r31, Y+2	; 0x02
     1ec:	b9 01       	movw	r22, r18
     1ee:	4d e3       	ldi	r20, 0x3D	; 61
     1f0:	54 e0       	ldi	r21, 0x04	; 4
     1f2:	9f 01       	movw	r18, r30
     1f4:	01 e0       	ldi	r16, 0x01	; 1
     1f6:	ee 24       	eor	r14, r14
     1f8:	ff 24       	eor	r15, r15
     1fa:	cc 24       	eor	r12, r12
     1fc:	dd 24       	eor	r13, r13
     1fe:	aa 24       	eor	r10, r10
     200:	bb 24       	eor	r11, r11
     202:	0e 94 53 02 	call	0x4a6	; 0x4a6 <xTaskGenericCreate>
                (void *) val1, 1, NULL );

   xTaskCreate( (pdTASK_CODE) vTaskUSARTWrite, (signed char *) "T2", configMINIMAL_STACK_SIZE+1000,
     206:	88 e3       	ldi	r24, 0x38	; 56
     208:	99 e1       	ldi	r25, 0x19	; 25
     20a:	26 e0       	ldi	r18, 0x06	; 6
     20c:	32 e0       	ldi	r19, 0x02	; 2
     20e:	e9 81       	ldd	r30, Y+1	; 0x01
     210:	fa 81       	ldd	r31, Y+2	; 0x02
     212:	b9 01       	movw	r22, r18
     214:	4d e3       	ldi	r20, 0x3D	; 61
     216:	54 e0       	ldi	r21, 0x04	; 4
     218:	9f 01       	movw	r18, r30
     21a:	01 e0       	ldi	r16, 0x01	; 1
     21c:	ee 24       	eor	r14, r14
     21e:	ff 24       	eor	r15, r15
     220:	cc 24       	eor	r12, r12
     222:	dd 24       	eor	r13, r13
     224:	aa 24       	eor	r10, r10
     226:	bb 24       	eor	r11, r11
     228:	0e 94 53 02 	call	0x4a6	; 0x4a6 <xTaskGenericCreate>
   				(void *) val1, 1, NULL);

   xTaskCreate( (pdTASK_CODE) vTaskUSARTRead, (signed char *) "T3", configMINIMAL_STACK_SIZE+1000,
     22c:	80 eb       	ldi	r24, 0xB0	; 176
     22e:	99 e1       	ldi	r25, 0x19	; 25
     230:	29 e0       	ldi	r18, 0x09	; 9
     232:	32 e0       	ldi	r19, 0x02	; 2
     234:	e9 81       	ldd	r30, Y+1	; 0x01
     236:	fa 81       	ldd	r31, Y+2	; 0x02
     238:	b9 01       	movw	r22, r18
     23a:	4d e3       	ldi	r20, 0x3D	; 61
     23c:	54 e0       	ldi	r21, 0x04	; 4
     23e:	9f 01       	movw	r18, r30
     240:	01 e0       	ldi	r16, 0x01	; 1
     242:	ee 24       	eor	r14, r14
     244:	ff 24       	eor	r15, r15
     246:	cc 24       	eor	r12, r12
     248:	dd 24       	eor	r13, r13
     24a:	aa 24       	eor	r10, r10
     24c:	bb 24       	eor	r11, r11
     24e:	0e 94 53 02 	call	0x4a6	; 0x4a6 <xTaskGenericCreate>

//   xTaskCreate( (pdTASK_CODE) vTaskUSARTLog, (signed char *) "T4", configMINIMAL_STACK_SIZE+1000,
//   				(void *) val1, 1, NULL);
    
    //- kick off the scheduler
	vTaskStartScheduler();
     252:	0e 94 48 05 	call	0xa90	; 0xa90 <vTaskStartScheduler>
    
	return 0;
     256:	80 e0       	ldi	r24, 0x00	; 0
     258:	90 e0       	ldi	r25, 0x00	; 0
}
     25a:	26 96       	adiw	r28, 0x06	; 6
     25c:	0f b6       	in	r0, 0x3f	; 63
     25e:	f8 94       	cli
     260:	de bf       	out	0x3e, r29	; 62
     262:	0f be       	out	0x3f, r0	; 63
     264:	cd bf       	out	0x3d, r28	; 61
     266:	cf 91       	pop	r28
     268:	df 91       	pop	r29
     26a:	0f 91       	pop	r16
     26c:	ff 90       	pop	r15
     26e:	ef 90       	pop	r14
     270:	df 90       	pop	r13
     272:	cf 90       	pop	r12
     274:	bf 90       	pop	r11
     276:	af 90       	pop	r10
     278:	08 95       	ret

0000027a <printHex>:
/*-----------------------------------------------------------*/

void printHex(int i){
     27a:	df 93       	push	r29
     27c:	cf 93       	push	r28
     27e:	cd b7       	in	r28, 0x3d	; 61
     280:	de b7       	in	r29, 0x3e	; 62
     282:	67 97       	sbiw	r28, 0x17	; 23
     284:	0f b6       	in	r0, 0x3f	; 63
     286:	f8 94       	cli
     288:	de bf       	out	0x3e, r29	; 62
     28a:	0f be       	out	0x3f, r0	; 63
     28c:	cd bf       	out	0x3d, r28	; 61
     28e:	9a 8b       	std	Y+18, r25	; 0x12
     290:	89 8b       	std	Y+17, r24	; 0x11
	char hex[] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
     292:	ce 01       	movw	r24, r28
     294:	01 96       	adiw	r24, 0x01	; 1
     296:	9c 8b       	std	Y+20, r25	; 0x14
     298:	8b 8b       	std	Y+19, r24	; 0x13
     29a:	ec e0       	ldi	r30, 0x0C	; 12
     29c:	f2 e0       	ldi	r31, 0x02	; 2
     29e:	fe 8b       	std	Y+22, r31	; 0x16
     2a0:	ed 8b       	std	Y+21, r30	; 0x15
     2a2:	f0 e1       	ldi	r31, 0x10	; 16
     2a4:	ff 8b       	std	Y+23, r31	; 0x17
     2a6:	ed 89       	ldd	r30, Y+21	; 0x15
     2a8:	fe 89       	ldd	r31, Y+22	; 0x16
     2aa:	00 80       	ld	r0, Z
     2ac:	8d 89       	ldd	r24, Y+21	; 0x15
     2ae:	9e 89       	ldd	r25, Y+22	; 0x16
     2b0:	01 96       	adiw	r24, 0x01	; 1
     2b2:	9e 8b       	std	Y+22, r25	; 0x16
     2b4:	8d 8b       	std	Y+21, r24	; 0x15
     2b6:	eb 89       	ldd	r30, Y+19	; 0x13
     2b8:	fc 89       	ldd	r31, Y+20	; 0x14
     2ba:	00 82       	st	Z, r0
     2bc:	8b 89       	ldd	r24, Y+19	; 0x13
     2be:	9c 89       	ldd	r25, Y+20	; 0x14
     2c0:	01 96       	adiw	r24, 0x01	; 1
     2c2:	9c 8b       	std	Y+20, r25	; 0x14
     2c4:	8b 8b       	std	Y+19, r24	; 0x13
     2c6:	9f 89       	ldd	r25, Y+23	; 0x17
     2c8:	91 50       	subi	r25, 0x01	; 1
     2ca:	9f 8b       	std	Y+23, r25	; 0x17
     2cc:	ef 89       	ldd	r30, Y+23	; 0x17
     2ce:	ee 23       	and	r30, r30
     2d0:	51 f7       	brne	.-44     	; 0x2a6 <printHex+0x2c>

	USART_Write(hex[(i&0xF000) >> 12]);
     2d2:	89 89       	ldd	r24, Y+17	; 0x11
     2d4:	9a 89       	ldd	r25, Y+18	; 0x12
     2d6:	9c 01       	movw	r18, r24
     2d8:	23 2f       	mov	r18, r19
     2da:	33 27       	eor	r19, r19
     2dc:	22 95       	swap	r18
     2de:	2f 70       	andi	r18, 0x0F	; 15
     2e0:	ce 01       	movw	r24, r28
     2e2:	01 96       	adiw	r24, 0x01	; 1
     2e4:	fc 01       	movw	r30, r24
     2e6:	e2 0f       	add	r30, r18
     2e8:	f3 1f       	adc	r31, r19
     2ea:	80 81       	ld	r24, Z
     2ec:	0e 94 a5 18 	call	0x314a	; 0x314a <USART_Write>
	USART_Write(hex[(i&0xF00) >> 8]);
     2f0:	89 89       	ldd	r24, Y+17	; 0x11
     2f2:	9a 89       	ldd	r25, Y+18	; 0x12
     2f4:	80 70       	andi	r24, 0x00	; 0
     2f6:	9f 70       	andi	r25, 0x0F	; 15
     2f8:	29 2f       	mov	r18, r25
     2fa:	33 27       	eor	r19, r19
     2fc:	27 fd       	sbrc	r18, 7
     2fe:	3a 95       	dec	r19
     300:	ce 01       	movw	r24, r28
     302:	01 96       	adiw	r24, 0x01	; 1
     304:	fc 01       	movw	r30, r24
     306:	e2 0f       	add	r30, r18
     308:	f3 1f       	adc	r31, r19
     30a:	80 81       	ld	r24, Z
     30c:	0e 94 a5 18 	call	0x314a	; 0x314a <USART_Write>
	USART_Write(hex[(i&0xF0) >> 4]);
     310:	89 89       	ldd	r24, Y+17	; 0x11
     312:	9a 89       	ldd	r25, Y+18	; 0x12
     314:	80 7f       	andi	r24, 0xF0	; 240
     316:	90 70       	andi	r25, 0x00	; 0
     318:	9c 01       	movw	r18, r24
     31a:	35 95       	asr	r19
     31c:	27 95       	ror	r18
     31e:	35 95       	asr	r19
     320:	27 95       	ror	r18
     322:	35 95       	asr	r19
     324:	27 95       	ror	r18
     326:	35 95       	asr	r19
     328:	27 95       	ror	r18
     32a:	ce 01       	movw	r24, r28
     32c:	01 96       	adiw	r24, 0x01	; 1
     32e:	fc 01       	movw	r30, r24
     330:	e2 0f       	add	r30, r18
     332:	f3 1f       	adc	r31, r19
     334:	80 81       	ld	r24, Z
     336:	0e 94 a5 18 	call	0x314a	; 0x314a <USART_Write>
	USART_Write(hex[i&0xF]);
     33a:	89 89       	ldd	r24, Y+17	; 0x11
     33c:	9a 89       	ldd	r25, Y+18	; 0x12
     33e:	9c 01       	movw	r18, r24
     340:	2f 70       	andi	r18, 0x0F	; 15
     342:	30 70       	andi	r19, 0x00	; 0
     344:	ce 01       	movw	r24, r28
     346:	01 96       	adiw	r24, 0x01	; 1
     348:	fc 01       	movw	r30, r24
     34a:	e2 0f       	add	r30, r18
     34c:	f3 1f       	adc	r31, r19
     34e:	80 81       	ld	r24, Z
     350:	0e 94 a5 18 	call	0x314a	; 0x314a <USART_Write>

}
     354:	67 96       	adiw	r28, 0x17	; 23
     356:	0f b6       	in	r0, 0x3f	; 63
     358:	f8 94       	cli
     35a:	de bf       	out	0x3e, r29	; 62
     35c:	0f be       	out	0x3f, r0	; 63
     35e:	cd bf       	out	0x3d, r28	; 61
     360:	cf 91       	pop	r28
     362:	df 91       	pop	r29
     364:	08 95       	ret

00000366 <printNum>:

void printNum(unsigned char i){
     366:	df 93       	push	r29
     368:	cf 93       	push	r28
     36a:	cd b7       	in	r28, 0x3d	; 61
     36c:	de b7       	in	r29, 0x3e	; 62
     36e:	2d 97       	sbiw	r28, 0x0d	; 13
     370:	0f b6       	in	r0, 0x3f	; 63
     372:	f8 94       	cli
     374:	de bf       	out	0x3e, r29	; 62
     376:	0f be       	out	0x3f, r0	; 63
     378:	cd bf       	out	0x3d, r28	; 61
     37a:	8d 87       	std	Y+13, r24	; 0x0d
    
    char str[10];
    memset(str,0,10);
     37c:	ce 01       	movw	r24, r28
     37e:	03 96       	adiw	r24, 0x03	; 3
     380:	60 e0       	ldi	r22, 0x00	; 0
     382:	70 e0       	ldi	r23, 0x00	; 0
     384:	4a e0       	ldi	r20, 0x0A	; 10
     386:	50 e0       	ldi	r21, 0x00	; 0
     388:	0e 94 1a 20 	call	0x4034	; 0x4034 <memset>
    itoa(i,str,10);
     38c:	8d 85       	ldd	r24, Y+13	; 0x0d
     38e:	88 2f       	mov	r24, r24
     390:	90 e0       	ldi	r25, 0x00	; 0
     392:	9e 01       	movw	r18, r28
     394:	2d 5f       	subi	r18, 0xFD	; 253
     396:	3f 4f       	sbci	r19, 0xFF	; 255
     398:	b9 01       	movw	r22, r18
     39a:	4a e0       	ldi	r20, 0x0A	; 10
     39c:	50 e0       	ldi	r21, 0x00	; 0
     39e:	0e 94 30 20 	call	0x4060	; 0x4060 <itoa>
    char * irr = str;
     3a2:	ce 01       	movw	r24, r28
     3a4:	03 96       	adiw	r24, 0x03	; 3
     3a6:	9a 83       	std	Y+2, r25	; 0x02
     3a8:	89 83       	std	Y+1, r24	; 0x01
     3aa:	0a c0       	rjmp	.+20     	; 0x3c0 <printNum+0x5a>
    while(*irr){
        USART_AddToQueue((unsigned char )*irr);
     3ac:	e9 81       	ldd	r30, Y+1	; 0x01
     3ae:	fa 81       	ldd	r31, Y+2	; 0x02
     3b0:	80 81       	ld	r24, Z
     3b2:	0e 94 04 19 	call	0x3208	; 0x3208 <USART_AddToQueue>
        irr++;
     3b6:	89 81       	ldd	r24, Y+1	; 0x01
     3b8:	9a 81       	ldd	r25, Y+2	; 0x02
     3ba:	01 96       	adiw	r24, 0x01	; 1
     3bc:	9a 83       	std	Y+2, r25	; 0x02
     3be:	89 83       	std	Y+1, r24	; 0x01
    
    char str[10];
    memset(str,0,10);
    itoa(i,str,10);
    char * irr = str;
    while(*irr){
     3c0:	e9 81       	ldd	r30, Y+1	; 0x01
     3c2:	fa 81       	ldd	r31, Y+2	; 0x02
     3c4:	80 81       	ld	r24, Z
     3c6:	88 23       	and	r24, r24
     3c8:	89 f7       	brne	.-30     	; 0x3ac <printNum+0x46>
        USART_AddToQueue((unsigned char )*irr);
        irr++;
    }
    
}
     3ca:	2d 96       	adiw	r28, 0x0d	; 13
     3cc:	0f b6       	in	r0, 0x3f	; 63
     3ce:	f8 94       	cli
     3d0:	de bf       	out	0x3e, r29	; 62
     3d2:	0f be       	out	0x3f, r0	; 63
     3d4:	cd bf       	out	0x3d, r28	; 61
     3d6:	cf 91       	pop	r28
     3d8:	df 91       	pop	r29
     3da:	08 95       	ret

000003dc <__vector_50>:

ISR(TIMER5_OVF_vect){
     3dc:	1f 92       	push	r1
     3de:	0f 92       	push	r0
     3e0:	0f b6       	in	r0, 0x3f	; 63
     3e2:	0f 92       	push	r0
     3e4:	00 90 5b 00 	lds	r0, 0x005B
     3e8:	0f 92       	push	r0
     3ea:	11 24       	eor	r1, r1
     3ec:	8f 93       	push	r24
     3ee:	af 93       	push	r26
     3f0:	bf 93       	push	r27
     3f2:	ef 93       	push	r30
     3f4:	ff 93       	push	r31
     3f6:	df 93       	push	r29
     3f8:	cf 93       	push	r28
     3fa:	cd b7       	in	r28, 0x3d	; 61
     3fc:	de b7       	in	r29, 0x3e	; 62

	PORTB ^= 0xFF;
     3fe:	a5 e2       	ldi	r26, 0x25	; 37
     400:	b0 e0       	ldi	r27, 0x00	; 0
     402:	e5 e2       	ldi	r30, 0x25	; 37
     404:	f0 e0       	ldi	r31, 0x00	; 0
     406:	80 81       	ld	r24, Z
     408:	80 95       	com	r24
     40a:	8c 93       	st	X, r24
	TCNT3L = 0;
     40c:	e4 e9       	ldi	r30, 0x94	; 148
     40e:	f0 e0       	ldi	r31, 0x00	; 0
     410:	10 82       	st	Z, r1
	TCNT3H = 0;
     412:	e5 e9       	ldi	r30, 0x95	; 149
     414:	f0 e0       	ldi	r31, 0x00	; 0
     416:	10 82       	st	Z, r1

}
     418:	cf 91       	pop	r28
     41a:	df 91       	pop	r29
     41c:	ff 91       	pop	r31
     41e:	ef 91       	pop	r30
     420:	bf 91       	pop	r27
     422:	af 91       	pop	r26
     424:	8f 91       	pop	r24
     426:	0f 90       	pop	r0
     428:	00 92 5b 00 	sts	0x005B, r0
     42c:	0f 90       	pop	r0
     42e:	0f be       	out	0x3f, r0	; 63
     430:	0f 90       	pop	r0
     432:	1f 90       	pop	r1
     434:	18 95       	reti

00000436 <getTimerCount2>:

unsigned int getTimerCount2(){
     436:	df 93       	push	r29
     438:	cf 93       	push	r28
     43a:	cd b7       	in	r28, 0x3d	; 61
     43c:	de b7       	in	r29, 0x3e	; 62

	//volatile char timerLow = TCNT3L;

	return TCNT0;
     43e:	e6 e4       	ldi	r30, 0x46	; 70
     440:	f0 e0       	ldi	r31, 0x00	; 0
     442:	80 81       	ld	r24, Z
     444:	88 2f       	mov	r24, r24
     446:	90 e0       	ldi	r25, 0x00	; 0

}
     448:	cf 91       	pop	r28
     44a:	df 91       	pop	r29
     44c:	08 95       	ret

0000044e <vTaskFunction_1>:

void vTaskFunction_1(void *pvParameters)
{	
     44e:	df 93       	push	r29
     450:	cf 93       	push	r28
     452:	0f 92       	push	r0
     454:	0f 92       	push	r0
     456:	cd b7       	in	r28, 0x3d	; 61
     458:	de b7       	in	r29, 0x3e	; 62
     45a:	9a 83       	std	Y+2, r25	; 0x02
     45c:	89 83       	std	Y+1, r24	; 0x01
    USART_Init(9600, 16000000);
     45e:	80 e8       	ldi	r24, 0x80	; 128
     460:	95 e2       	ldi	r25, 0x25	; 37
     462:	40 e0       	ldi	r20, 0x00	; 0
     464:	54 e2       	ldi	r21, 0x24	; 36
     466:	64 ef       	ldi	r22, 0xF4	; 244
     468:	70 e0       	ldi	r23, 0x00	; 0
     46a:	0e 94 34 18 	call	0x3068	; 0x3068 <USART_Init>
	}*/

    for (;;)  {
//        PORTB ^=  0xff;j
		//PCMSK2 = 1;
    	printNum(getSonarData(0));
     46e:	80 e0       	ldi	r24, 0x00	; 0
     470:	90 e0       	ldi	r25, 0x00	; 0
     472:	0e 94 b7 1d 	call	0x3b6e	; 0x3b6e <getSonarData>
     476:	0e 94 b3 01 	call	0x366	; 0x366 <printNum>
		USART_AddToQueue(' ');
     47a:	80 e2       	ldi	r24, 0x20	; 32
     47c:	0e 94 04 19 	call	0x3208	; 0x3208 <USART_AddToQueue>
		//printNum(getSonarData(1));
		//USART_Write('\n');
      	vTaskDelay(25);
     480:	89 e1       	ldi	r24, 0x19	; 25
     482:	90 e0       	ldi	r25, 0x00	; 0
     484:	0e 94 b4 03 	call	0x768	; 0x768 <vTaskDelay>
     488:	f2 cf       	rjmp	.-28     	; 0x46e <vTaskFunction_1+0x20>

0000048a <vIO_init>:
        // UDR0;
    }
}

void vIO_init(void)
{
     48a:	df 93       	push	r29
     48c:	cf 93       	push	r28
     48e:	cd b7       	in	r28, 0x3d	; 61
     490:	de b7       	in	r29, 0x3e	; 62
    //- set PortB as output
	DDRB = 0xFF; 
     492:	e4 e2       	ldi	r30, 0x24	; 36
     494:	f0 e0       	ldi	r31, 0x00	; 0
     496:	8f ef       	ldi	r24, 0xFF	; 255
     498:	80 83       	st	Z, r24
    PORTB = 0; 
     49a:	e5 e2       	ldi	r30, 0x25	; 37
     49c:	f0 e0       	ldi	r31, 0x00	; 0
     49e:	10 82       	st	Z, r1
}
     4a0:	cf 91       	pop	r28
     4a2:	df 91       	pop	r29
     4a4:	08 95       	ret

000004a6 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
     4a6:	af 92       	push	r10
     4a8:	bf 92       	push	r11
     4aa:	cf 92       	push	r12
     4ac:	df 92       	push	r13
     4ae:	ef 92       	push	r14
     4b0:	ff 92       	push	r15
     4b2:	0f 93       	push	r16
     4b4:	1f 93       	push	r17
     4b6:	df 93       	push	r29
     4b8:	cf 93       	push	r28
     4ba:	cd b7       	in	r28, 0x3d	; 61
     4bc:	de b7       	in	r29, 0x3e	; 62
     4be:	64 97       	sbiw	r28, 0x14	; 20
     4c0:	0f b6       	in	r0, 0x3f	; 63
     4c2:	f8 94       	cli
     4c4:	de bf       	out	0x3e, r29	; 62
     4c6:	0f be       	out	0x3f, r0	; 63
     4c8:	cd bf       	out	0x3d, r28	; 61
     4ca:	9f 83       	std	Y+7, r25	; 0x07
     4cc:	8e 83       	std	Y+6, r24	; 0x06
     4ce:	79 87       	std	Y+9, r23	; 0x09
     4d0:	68 87       	std	Y+8, r22	; 0x08
     4d2:	5b 87       	std	Y+11, r21	; 0x0b
     4d4:	4a 87       	std	Y+10, r20	; 0x0a
     4d6:	3d 87       	std	Y+13, r19	; 0x0d
     4d8:	2c 87       	std	Y+12, r18	; 0x0c
     4da:	0e 87       	std	Y+14, r16	; 0x0e
     4dc:	f8 8a       	std	Y+16, r15	; 0x10
     4de:	ef 86       	std	Y+15, r14	; 0x0f
     4e0:	da 8a       	std	Y+18, r13	; 0x12
     4e2:	c9 8a       	std	Y+17, r12	; 0x11
     4e4:	bc 8a       	std	Y+20, r11	; 0x14
     4e6:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
     4e8:	8a 85       	ldd	r24, Y+10	; 0x0a
     4ea:	9b 85       	ldd	r25, Y+11	; 0x0b
     4ec:	29 89       	ldd	r18, Y+17	; 0x11
     4ee:	3a 89       	ldd	r19, Y+18	; 0x12
     4f0:	b9 01       	movw	r22, r18
     4f2:	0e 94 e2 09 	call	0x13c4	; 0x13c4 <prvAllocateTCBAndStack>
     4f6:	9c 83       	std	Y+4, r25	; 0x04
     4f8:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
     4fa:	8b 81       	ldd	r24, Y+3	; 0x03
     4fc:	9c 81       	ldd	r25, Y+4	; 0x04
     4fe:	00 97       	sbiw	r24, 0x00	; 0
     500:	09 f4       	brne	.+2      	; 0x504 <xTaskGenericCreate+0x5e>
     502:	99 c0       	rjmp	.+306    	; 0x636 <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
     504:	eb 81       	ldd	r30, Y+3	; 0x03
     506:	fc 81       	ldd	r31, Y+4	; 0x04
     508:	27 89       	ldd	r18, Z+23	; 0x17
     50a:	30 8d       	ldd	r19, Z+24	; 0x18
     50c:	8a 85       	ldd	r24, Y+10	; 0x0a
     50e:	9b 85       	ldd	r25, Y+11	; 0x0b
     510:	01 97       	sbiw	r24, 0x01	; 1
     512:	82 0f       	add	r24, r18
     514:	93 1f       	adc	r25, r19
     516:	9a 83       	std	Y+2, r25	; 0x02
     518:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
     51a:	8b 81       	ldd	r24, Y+3	; 0x03
     51c:	9c 81       	ldd	r25, Y+4	; 0x04
     51e:	28 85       	ldd	r18, Y+8	; 0x08
     520:	39 85       	ldd	r19, Y+9	; 0x09
     522:	eb 89       	ldd	r30, Y+19	; 0x13
     524:	fc 89       	ldd	r31, Y+20	; 0x14
     526:	aa 85       	ldd	r26, Y+10	; 0x0a
     528:	bb 85       	ldd	r27, Y+11	; 0x0b
     52a:	b9 01       	movw	r22, r18
     52c:	4e 85       	ldd	r20, Y+14	; 0x0e
     52e:	9f 01       	movw	r18, r30
     530:	8d 01       	movw	r16, r26
     532:	0e 94 f9 08 	call	0x11f2	; 0x11f2 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     536:	89 81       	ldd	r24, Y+1	; 0x01
     538:	9a 81       	ldd	r25, Y+2	; 0x02
     53a:	2e 81       	ldd	r18, Y+6	; 0x06
     53c:	3f 81       	ldd	r19, Y+7	; 0x07
     53e:	4c 85       	ldd	r20, Y+12	; 0x0c
     540:	5d 85       	ldd	r21, Y+13	; 0x0d
     542:	b9 01       	movw	r22, r18
     544:	0e 94 37 15 	call	0x2a6e	; 0x2a6e <pxPortInitialiseStack>
     548:	eb 81       	ldd	r30, Y+3	; 0x03
     54a:	fc 81       	ldd	r31, Y+4	; 0x04
     54c:	91 83       	std	Z+1, r25	; 0x01
     54e:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
     550:	8f 85       	ldd	r24, Y+15	; 0x0f
     552:	98 89       	ldd	r25, Y+16	; 0x10
     554:	00 97       	sbiw	r24, 0x00	; 0
     556:	31 f0       	breq	.+12     	; 0x564 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
     558:	ef 85       	ldd	r30, Y+15	; 0x0f
     55a:	f8 89       	ldd	r31, Y+16	; 0x10
     55c:	8b 81       	ldd	r24, Y+3	; 0x03
     55e:	9c 81       	ldd	r25, Y+4	; 0x04
     560:	91 83       	std	Z+1, r25	; 0x01
     562:	80 83       	st	Z, r24
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
     564:	0f b6       	in	r0, 0x3f	; 63
     566:	f8 94       	cli
     568:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
     56a:	80 91 28 02 	lds	r24, 0x0228
     56e:	8f 5f       	subi	r24, 0xFF	; 255
     570:	80 93 28 02 	sts	0x0228, r24
			if( pxCurrentTCB == NULL )
     574:	80 91 26 02 	lds	r24, 0x0226
     578:	90 91 27 02 	lds	r25, 0x0227
     57c:	00 97       	sbiw	r24, 0x00	; 0
     57e:	69 f4       	brne	.+26     	; 0x59a <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
     580:	8b 81       	ldd	r24, Y+3	; 0x03
     582:	9c 81       	ldd	r25, Y+4	; 0x04
     584:	90 93 27 02 	sts	0x0227, r25
     588:	80 93 26 02 	sts	0x0226, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
     58c:	80 91 28 02 	lds	r24, 0x0228
     590:	81 30       	cpi	r24, 0x01	; 1
     592:	a9 f4       	brne	.+42     	; 0x5be <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
     594:	0e 94 54 09 	call	0x12a8	; 0x12a8 <prvInitialiseTaskLists>
     598:	12 c0       	rjmp	.+36     	; 0x5be <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
     59a:	80 91 2d 02 	lds	r24, 0x022D
     59e:	88 23       	and	r24, r24
     5a0:	71 f4       	brne	.+28     	; 0x5be <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
     5a2:	e0 91 26 02 	lds	r30, 0x0226
     5a6:	f0 91 27 02 	lds	r31, 0x0227
     5aa:	96 89       	ldd	r25, Z+22	; 0x16
     5ac:	8e 85       	ldd	r24, Y+14	; 0x0e
     5ae:	89 17       	cp	r24, r25
     5b0:	30 f0       	brcs	.+12     	; 0x5be <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
     5b2:	8b 81       	ldd	r24, Y+3	; 0x03
     5b4:	9c 81       	ldd	r25, Y+4	; 0x04
     5b6:	90 93 27 02 	sts	0x0227, r25
     5ba:	80 93 26 02 	sts	0x0226, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
     5be:	eb 81       	ldd	r30, Y+3	; 0x03
     5c0:	fc 81       	ldd	r31, Y+4	; 0x04
     5c2:	96 89       	ldd	r25, Z+22	; 0x16
     5c4:	80 91 2b 02 	lds	r24, 0x022B
     5c8:	89 17       	cp	r24, r25
     5ca:	28 f4       	brcc	.+10     	; 0x5d6 <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
     5cc:	eb 81       	ldd	r30, Y+3	; 0x03
     5ce:	fc 81       	ldd	r31, Y+4	; 0x04
     5d0:	86 89       	ldd	r24, Z+22	; 0x16
     5d2:	80 93 2b 02 	sts	0x022B, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
     5d6:	80 91 32 02 	lds	r24, 0x0232
     5da:	8f 5f       	subi	r24, 0xFF	; 255
     5dc:	80 93 32 02 	sts	0x0232, r24

			prvAddTaskToReadyQueue( pxNewTCB );
     5e0:	eb 81       	ldd	r30, Y+3	; 0x03
     5e2:	fc 81       	ldd	r31, Y+4	; 0x04
     5e4:	96 89       	ldd	r25, Z+22	; 0x16
     5e6:	80 91 2c 02 	lds	r24, 0x022C
     5ea:	89 17       	cp	r24, r25
     5ec:	28 f4       	brcc	.+10     	; 0x5f8 <xTaskGenericCreate+0x152>
     5ee:	eb 81       	ldd	r30, Y+3	; 0x03
     5f0:	fc 81       	ldd	r31, Y+4	; 0x04
     5f2:	86 89       	ldd	r24, Z+22	; 0x16
     5f4:	80 93 2c 02 	sts	0x022C, r24
     5f8:	eb 81       	ldd	r30, Y+3	; 0x03
     5fa:	fc 81       	ldd	r31, Y+4	; 0x04
     5fc:	86 89       	ldd	r24, Z+22	; 0x16
     5fe:	28 2f       	mov	r18, r24
     600:	30 e0       	ldi	r19, 0x00	; 0
     602:	c9 01       	movw	r24, r18
     604:	88 0f       	add	r24, r24
     606:	99 1f       	adc	r25, r25
     608:	88 0f       	add	r24, r24
     60a:	99 1f       	adc	r25, r25
     60c:	88 0f       	add	r24, r24
     60e:	99 1f       	adc	r25, r25
     610:	82 0f       	add	r24, r18
     612:	93 1f       	adc	r25, r19
     614:	ac 01       	movw	r20, r24
     616:	4d 5c       	subi	r20, 0xCD	; 205
     618:	5d 4f       	sbci	r21, 0xFD	; 253
     61a:	8b 81       	ldd	r24, Y+3	; 0x03
     61c:	9c 81       	ldd	r25, Y+4	; 0x04
     61e:	9c 01       	movw	r18, r24
     620:	2e 5f       	subi	r18, 0xFE	; 254
     622:	3f 4f       	sbci	r19, 0xFF	; 255
     624:	ca 01       	movw	r24, r20
     626:	b9 01       	movw	r22, r18
     628:	0e 94 ee 10 	call	0x21dc	; 0x21dc <vListInsertEnd>

			xReturn = pdPASS;
     62c:	81 e0       	ldi	r24, 0x01	; 1
     62e:	8d 83       	std	Y+5, r24	; 0x05
			portSETUP_TCB( pxNewTCB );
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
     630:	0f 90       	pop	r0
     632:	0f be       	out	0x3f, r0	; 63
     634:	02 c0       	rjmp	.+4      	; 0x63a <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     636:	8f ef       	ldi	r24, 0xFF	; 255
     638:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
     63a:	8d 81       	ldd	r24, Y+5	; 0x05
     63c:	81 30       	cpi	r24, 0x01	; 1
     63e:	71 f4       	brne	.+28     	; 0x65c <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
     640:	80 91 2d 02 	lds	r24, 0x022D
     644:	88 23       	and	r24, r24
     646:	51 f0       	breq	.+20     	; 0x65c <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
     648:	e0 91 26 02 	lds	r30, 0x0226
     64c:	f0 91 27 02 	lds	r31, 0x0227
     650:	96 89       	ldd	r25, Z+22	; 0x16
     652:	8e 85       	ldd	r24, Y+14	; 0x0e
     654:	98 17       	cp	r25, r24
     656:	10 f4       	brcc	.+4      	; 0x65c <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
     658:	0e 94 12 17 	call	0x2e24	; 0x2e24 <vPortYield>
			}
		}
	}

	return xReturn;
     65c:	8d 81       	ldd	r24, Y+5	; 0x05
}
     65e:	64 96       	adiw	r28, 0x14	; 20
     660:	0f b6       	in	r0, 0x3f	; 63
     662:	f8 94       	cli
     664:	de bf       	out	0x3e, r29	; 62
     666:	0f be       	out	0x3f, r0	; 63
     668:	cd bf       	out	0x3d, r28	; 61
     66a:	cf 91       	pop	r28
     66c:	df 91       	pop	r29
     66e:	1f 91       	pop	r17
     670:	0f 91       	pop	r16
     672:	ff 90       	pop	r15
     674:	ef 90       	pop	r14
     676:	df 90       	pop	r13
     678:	cf 90       	pop	r12
     67a:	bf 90       	pop	r11
     67c:	af 90       	pop	r10
     67e:	08 95       	ret

00000680 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
     680:	df 93       	push	r29
     682:	cf 93       	push	r28
     684:	cd b7       	in	r28, 0x3d	; 61
     686:	de b7       	in	r29, 0x3e	; 62
     688:	28 97       	sbiw	r28, 0x08	; 8
     68a:	0f b6       	in	r0, 0x3f	; 63
     68c:	f8 94       	cli
     68e:	de bf       	out	0x3e, r29	; 62
     690:	0f be       	out	0x3f, r0	; 63
     692:	cd bf       	out	0x3d, r28	; 61
     694:	9e 83       	std	Y+6, r25	; 0x06
     696:	8d 83       	std	Y+5, r24	; 0x05
     698:	78 87       	std	Y+8, r23	; 0x08
     69a:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
     69c:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
     69e:	0e 94 8b 05 	call	0xb16	; 0xb16 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     6a2:	ed 81       	ldd	r30, Y+5	; 0x05
     6a4:	fe 81       	ldd	r31, Y+6	; 0x06
     6a6:	20 81       	ld	r18, Z
     6a8:	31 81       	ldd	r19, Z+1	; 0x01
     6aa:	8f 81       	ldd	r24, Y+7	; 0x07
     6ac:	98 85       	ldd	r25, Y+8	; 0x08
     6ae:	82 0f       	add	r24, r18
     6b0:	93 1f       	adc	r25, r19
     6b2:	9c 83       	std	Y+4, r25	; 0x04
     6b4:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
     6b6:	ed 81       	ldd	r30, Y+5	; 0x05
     6b8:	fe 81       	ldd	r31, Y+6	; 0x06
     6ba:	20 81       	ld	r18, Z
     6bc:	31 81       	ldd	r19, Z+1	; 0x01
     6be:	80 91 29 02 	lds	r24, 0x0229
     6c2:	90 91 2a 02 	lds	r25, 0x022A
     6c6:	82 17       	cp	r24, r18
     6c8:	93 07       	cpc	r25, r19
     6ca:	a8 f4       	brcc	.+42     	; 0x6f6 <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
     6cc:	ed 81       	ldd	r30, Y+5	; 0x05
     6ce:	fe 81       	ldd	r31, Y+6	; 0x06
     6d0:	20 81       	ld	r18, Z
     6d2:	31 81       	ldd	r19, Z+1	; 0x01
     6d4:	8b 81       	ldd	r24, Y+3	; 0x03
     6d6:	9c 81       	ldd	r25, Y+4	; 0x04
     6d8:	82 17       	cp	r24, r18
     6da:	93 07       	cpc	r25, r19
     6dc:	00 f5       	brcc	.+64     	; 0x71e <vTaskDelayUntil+0x9e>
     6de:	20 91 29 02 	lds	r18, 0x0229
     6e2:	30 91 2a 02 	lds	r19, 0x022A
     6e6:	8b 81       	ldd	r24, Y+3	; 0x03
     6e8:	9c 81       	ldd	r25, Y+4	; 0x04
     6ea:	28 17       	cp	r18, r24
     6ec:	39 07       	cpc	r19, r25
     6ee:	b8 f4       	brcc	.+46     	; 0x71e <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
     6f0:	81 e0       	ldi	r24, 0x01	; 1
     6f2:	89 83       	std	Y+1, r24	; 0x01
     6f4:	14 c0       	rjmp	.+40     	; 0x71e <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
     6f6:	ed 81       	ldd	r30, Y+5	; 0x05
     6f8:	fe 81       	ldd	r31, Y+6	; 0x06
     6fa:	20 81       	ld	r18, Z
     6fc:	31 81       	ldd	r19, Z+1	; 0x01
     6fe:	8b 81       	ldd	r24, Y+3	; 0x03
     700:	9c 81       	ldd	r25, Y+4	; 0x04
     702:	82 17       	cp	r24, r18
     704:	93 07       	cpc	r25, r19
     706:	48 f0       	brcs	.+18     	; 0x71a <vTaskDelayUntil+0x9a>
     708:	20 91 29 02 	lds	r18, 0x0229
     70c:	30 91 2a 02 	lds	r19, 0x022A
     710:	8b 81       	ldd	r24, Y+3	; 0x03
     712:	9c 81       	ldd	r25, Y+4	; 0x04
     714:	28 17       	cp	r18, r24
     716:	39 07       	cpc	r19, r25
     718:	10 f4       	brcc	.+4      	; 0x71e <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
     71a:	81 e0       	ldi	r24, 0x01	; 1
     71c:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     71e:	ed 81       	ldd	r30, Y+5	; 0x05
     720:	fe 81       	ldd	r31, Y+6	; 0x06
     722:	8b 81       	ldd	r24, Y+3	; 0x03
     724:	9c 81       	ldd	r25, Y+4	; 0x04
     726:	91 83       	std	Z+1, r25	; 0x01
     728:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
     72a:	89 81       	ldd	r24, Y+1	; 0x01
     72c:	88 23       	and	r24, r24
     72e:	59 f0       	breq	.+22     	; 0x746 <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
     730:	80 91 26 02 	lds	r24, 0x0226
     734:	90 91 27 02 	lds	r25, 0x0227
     738:	02 96       	adiw	r24, 0x02	; 2
     73a:	0e 94 a5 11 	call	0x234a	; 0x234a <uxListRemove>
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
     73e:	8b 81       	ldd	r24, Y+3	; 0x03
     740:	9c 81       	ldd	r25, Y+4	; 0x04
     742:	0e 94 98 09 	call	0x1330	; 0x1330 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     746:	0e 94 97 05 	call	0xb2e	; 0xb2e <xTaskResumeAll>
     74a:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     74c:	8a 81       	ldd	r24, Y+2	; 0x02
     74e:	88 23       	and	r24, r24
     750:	11 f4       	brne	.+4      	; 0x756 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
     752:	0e 94 12 17 	call	0x2e24	; 0x2e24 <vPortYield>
		}
	}
     756:	28 96       	adiw	r28, 0x08	; 8
     758:	0f b6       	in	r0, 0x3f	; 63
     75a:	f8 94       	cli
     75c:	de bf       	out	0x3e, r29	; 62
     75e:	0f be       	out	0x3f, r0	; 63
     760:	cd bf       	out	0x3d, r28	; 61
     762:	cf 91       	pop	r28
     764:	df 91       	pop	r29
     766:	08 95       	ret

00000768 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
     768:	df 93       	push	r29
     76a:	cf 93       	push	r28
     76c:	00 d0       	rcall	.+0      	; 0x76e <vTaskDelay+0x6>
     76e:	0f 92       	push	r0
     770:	0f 92       	push	r0
     772:	cd b7       	in	r28, 0x3d	; 61
     774:	de b7       	in	r29, 0x3e	; 62
     776:	9d 83       	std	Y+5, r25	; 0x05
     778:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
     77a:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
     77c:	8c 81       	ldd	r24, Y+4	; 0x04
     77e:	9d 81       	ldd	r25, Y+5	; 0x05
     780:	00 97       	sbiw	r24, 0x00	; 0
     782:	d1 f0       	breq	.+52     	; 0x7b8 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
     784:	0e 94 8b 05 	call	0xb16	; 0xb16 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
     788:	20 91 29 02 	lds	r18, 0x0229
     78c:	30 91 2a 02 	lds	r19, 0x022A
     790:	8c 81       	ldd	r24, Y+4	; 0x04
     792:	9d 81       	ldd	r25, Y+5	; 0x05
     794:	82 0f       	add	r24, r18
     796:	93 1f       	adc	r25, r19
     798:	9b 83       	std	Y+3, r25	; 0x03
     79a:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
     79c:	80 91 26 02 	lds	r24, 0x0226
     7a0:	90 91 27 02 	lds	r25, 0x0227
     7a4:	02 96       	adiw	r24, 0x02	; 2
     7a6:	0e 94 a5 11 	call	0x234a	; 0x234a <uxListRemove>
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
     7aa:	8a 81       	ldd	r24, Y+2	; 0x02
     7ac:	9b 81       	ldd	r25, Y+3	; 0x03
     7ae:	0e 94 98 09 	call	0x1330	; 0x1330 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     7b2:	0e 94 97 05 	call	0xb2e	; 0xb2e <xTaskResumeAll>
     7b6:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     7b8:	89 81       	ldd	r24, Y+1	; 0x01
     7ba:	88 23       	and	r24, r24
     7bc:	11 f4       	brne	.+4      	; 0x7c2 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
     7be:	0e 94 12 17 	call	0x2e24	; 0x2e24 <vPortYield>
		}
	}
     7c2:	0f 90       	pop	r0
     7c4:	0f 90       	pop	r0
     7c6:	0f 90       	pop	r0
     7c8:	0f 90       	pop	r0
     7ca:	0f 90       	pop	r0
     7cc:	cf 91       	pop	r28
     7ce:	df 91       	pop	r29
     7d0:	08 95       	ret

000007d2 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
     7d2:	df 93       	push	r29
     7d4:	cf 93       	push	r28
     7d6:	00 d0       	rcall	.+0      	; 0x7d8 <vTaskSuspend+0x6>
     7d8:	00 d0       	rcall	.+0      	; 0x7da <vTaskSuspend+0x8>
     7da:	cd b7       	in	r28, 0x3d	; 61
     7dc:	de b7       	in	r29, 0x3e	; 62
     7de:	9c 83       	std	Y+4, r25	; 0x04
     7e0:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
     7e2:	0f b6       	in	r0, 0x3f	; 63
     7e4:	f8 94       	cli
     7e6:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
     7e8:	20 91 26 02 	lds	r18, 0x0226
     7ec:	30 91 27 02 	lds	r19, 0x0227
     7f0:	8b 81       	ldd	r24, Y+3	; 0x03
     7f2:	9c 81       	ldd	r25, Y+4	; 0x04
     7f4:	82 17       	cp	r24, r18
     7f6:	93 07       	cpc	r25, r19
     7f8:	11 f4       	brne	.+4      	; 0x7fe <vTaskSuspend+0x2c>
			{
				pxTaskToSuspend = NULL;
     7fa:	1c 82       	std	Y+4, r1	; 0x04
     7fc:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
     7fe:	8b 81       	ldd	r24, Y+3	; 0x03
     800:	9c 81       	ldd	r25, Y+4	; 0x04
     802:	00 97       	sbiw	r24, 0x00	; 0
     804:	39 f4       	brne	.+14     	; 0x814 <vTaskSuspend+0x42>
     806:	80 91 26 02 	lds	r24, 0x0226
     80a:	90 91 27 02 	lds	r25, 0x0227
     80e:	9e 83       	std	Y+6, r25	; 0x06
     810:	8d 83       	std	Y+5, r24	; 0x05
     812:	04 c0       	rjmp	.+8      	; 0x81c <vTaskSuspend+0x4a>
     814:	8b 81       	ldd	r24, Y+3	; 0x03
     816:	9c 81       	ldd	r25, Y+4	; 0x04
     818:	9e 83       	std	Y+6, r25	; 0x06
     81a:	8d 83       	std	Y+5, r24	; 0x05
     81c:	8d 81       	ldd	r24, Y+5	; 0x05
     81e:	9e 81       	ldd	r25, Y+6	; 0x06
     820:	9a 83       	std	Y+2, r25	; 0x02
     822:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
     824:	89 81       	ldd	r24, Y+1	; 0x01
     826:	9a 81       	ldd	r25, Y+2	; 0x02
     828:	02 96       	adiw	r24, 0x02	; 2
     82a:	0e 94 a5 11 	call	0x234a	; 0x234a <uxListRemove>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
			}

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
     82e:	e9 81       	ldd	r30, Y+1	; 0x01
     830:	fa 81       	ldd	r31, Y+2	; 0x02
     832:	84 89       	ldd	r24, Z+20	; 0x14
     834:	95 89       	ldd	r25, Z+21	; 0x15
     836:	00 97       	sbiw	r24, 0x00	; 0
     838:	29 f0       	breq	.+10     	; 0x844 <vTaskSuspend+0x72>
			{
				uxListRemove( &( pxTCB->xEventListItem ) );
     83a:	89 81       	ldd	r24, Y+1	; 0x01
     83c:	9a 81       	ldd	r25, Y+2	; 0x02
     83e:	0c 96       	adiw	r24, 0x0c	; 12
     840:	0e 94 a5 11 	call	0x234a	; 0x234a <uxListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
     844:	89 81       	ldd	r24, Y+1	; 0x01
     846:	9a 81       	ldd	r25, Y+2	; 0x02
     848:	9c 01       	movw	r18, r24
     84a:	2e 5f       	subi	r18, 0xFE	; 254
     84c:	3f 4f       	sbci	r19, 0xFF	; 255
     84e:	86 e7       	ldi	r24, 0x76	; 118
     850:	92 e0       	ldi	r25, 0x02	; 2
     852:	b9 01       	movw	r22, r18
     854:	0e 94 ee 10 	call	0x21dc	; 0x21dc <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
     858:	0f 90       	pop	r0
     85a:	0f be       	out	0x3f, r0	; 63

		if( ( void * ) pxTaskToSuspend == NULL )
     85c:	8b 81       	ldd	r24, Y+3	; 0x03
     85e:	9c 81       	ldd	r25, Y+4	; 0x04
     860:	00 97       	sbiw	r24, 0x00	; 0
     862:	a1 f4       	brne	.+40     	; 0x88c <vTaskSuspend+0xba>
		{
			if( xSchedulerRunning != pdFALSE )
     864:	80 91 2d 02 	lds	r24, 0x022D
     868:	88 23       	and	r24, r24
     86a:	19 f0       	breq	.+6      	; 0x872 <vTaskSuspend+0xa0>
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
     86c:	0e 94 12 17 	call	0x2e24	; 0x2e24 <vPortYield>
     870:	0d c0       	rjmp	.+26     	; 0x88c <vTaskSuspend+0xba>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
     872:	90 91 76 02 	lds	r25, 0x0276
     876:	80 91 28 02 	lds	r24, 0x0228
     87a:	98 17       	cp	r25, r24
     87c:	29 f4       	brne	.+10     	; 0x888 <vTaskSuspend+0xb6>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
     87e:	10 92 27 02 	sts	0x0227, r1
     882:	10 92 26 02 	sts	0x0226, r1
     886:	02 c0       	rjmp	.+4      	; 0x88c <vTaskSuspend+0xba>
				}
				else
				{
					vTaskSwitchContext();
     888:	0e 94 2a 07 	call	0xe54	; 0xe54 <vTaskSwitchContext>
				}
			}
		}
	}
     88c:	26 96       	adiw	r28, 0x06	; 6
     88e:	0f b6       	in	r0, 0x3f	; 63
     890:	f8 94       	cli
     892:	de bf       	out	0x3e, r29	; 62
     894:	0f be       	out	0x3f, r0	; 63
     896:	cd bf       	out	0x3d, r28	; 61
     898:	cf 91       	pop	r28
     89a:	df 91       	pop	r29
     89c:	08 95       	ret

0000089e <xTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
     89e:	df 93       	push	r29
     8a0:	cf 93       	push	r28
     8a2:	00 d0       	rcall	.+0      	; 0x8a4 <xTaskIsTaskSuspended+0x6>
     8a4:	0f 92       	push	r0
     8a6:	0f 92       	push	r0
     8a8:	cd b7       	in	r28, 0x3d	; 61
     8aa:	de b7       	in	r29, 0x3e	; 62
     8ac:	9d 83       	std	Y+5, r25	; 0x05
     8ae:	8c 83       	std	Y+4, r24	; 0x04
	portBASE_TYPE xReturn = pdFALSE;
     8b0:	1b 82       	std	Y+3, r1	; 0x03
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
     8b2:	8c 81       	ldd	r24, Y+4	; 0x04
     8b4:	9d 81       	ldd	r25, Y+5	; 0x05
     8b6:	9a 83       	std	Y+2, r25	; 0x02
     8b8:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
     8ba:	e9 81       	ldd	r30, Y+1	; 0x01
     8bc:	fa 81       	ldd	r31, Y+2	; 0x02
     8be:	82 85       	ldd	r24, Z+10	; 0x0a
     8c0:	93 85       	ldd	r25, Z+11	; 0x0b
     8c2:	22 e0       	ldi	r18, 0x02	; 2
     8c4:	86 37       	cpi	r24, 0x76	; 118
     8c6:	92 07       	cpc	r25, r18
     8c8:	81 f4       	brne	.+32     	; 0x8ea <xTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
     8ca:	e9 81       	ldd	r30, Y+1	; 0x01
     8cc:	fa 81       	ldd	r31, Y+2	; 0x02
     8ce:	84 89       	ldd	r24, Z+20	; 0x14
     8d0:	95 89       	ldd	r25, Z+21	; 0x15
     8d2:	22 e0       	ldi	r18, 0x02	; 2
     8d4:	8d 36       	cpi	r24, 0x6D	; 109
     8d6:	92 07       	cpc	r25, r18
     8d8:	41 f0       	breq	.+16     	; 0x8ea <xTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
     8da:	e9 81       	ldd	r30, Y+1	; 0x01
     8dc:	fa 81       	ldd	r31, Y+2	; 0x02
     8de:	84 89       	ldd	r24, Z+20	; 0x14
     8e0:	95 89       	ldd	r25, Z+21	; 0x15
     8e2:	00 97       	sbiw	r24, 0x00	; 0
     8e4:	11 f4       	brne	.+4      	; 0x8ea <xTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
     8e6:	81 e0       	ldi	r24, 0x01	; 1
     8e8:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}

		return xReturn;
     8ea:	8b 81       	ldd	r24, Y+3	; 0x03
	}
     8ec:	0f 90       	pop	r0
     8ee:	0f 90       	pop	r0
     8f0:	0f 90       	pop	r0
     8f2:	0f 90       	pop	r0
     8f4:	0f 90       	pop	r0
     8f6:	cf 91       	pop	r28
     8f8:	df 91       	pop	r29
     8fa:	08 95       	ret

000008fc <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
     8fc:	df 93       	push	r29
     8fe:	cf 93       	push	r28
     900:	00 d0       	rcall	.+0      	; 0x902 <vTaskResume+0x6>
     902:	0f 92       	push	r0
     904:	cd b7       	in	r28, 0x3d	; 61
     906:	de b7       	in	r29, 0x3e	; 62
     908:	9c 83       	std	Y+4, r25	; 0x04
     90a:	8b 83       	std	Y+3, r24	; 0x03
		/* It does not make sense to resume the calling task. */
		configASSERT( pxTaskToResume );

		/* Remove the task from whichever list it is currently in, and place
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;
     90c:	8b 81       	ldd	r24, Y+3	; 0x03
     90e:	9c 81       	ldd	r25, Y+4	; 0x04
     910:	9a 83       	std	Y+2, r25	; 0x02
     912:	89 83       	std	Y+1, r24	; 0x01

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
     914:	89 81       	ldd	r24, Y+1	; 0x01
     916:	9a 81       	ldd	r25, Y+2	; 0x02
     918:	00 97       	sbiw	r24, 0x00	; 0
     91a:	09 f4       	brne	.+2      	; 0x91e <vTaskResume+0x22>
     91c:	4c c0       	rjmp	.+152    	; 0x9b6 <vTaskResume+0xba>
     91e:	20 91 26 02 	lds	r18, 0x0226
     922:	30 91 27 02 	lds	r19, 0x0227
     926:	89 81       	ldd	r24, Y+1	; 0x01
     928:	9a 81       	ldd	r25, Y+2	; 0x02
     92a:	82 17       	cp	r24, r18
     92c:	93 07       	cpc	r25, r19
     92e:	09 f4       	brne	.+2      	; 0x932 <vTaskResume+0x36>
     930:	42 c0       	rjmp	.+132    	; 0x9b6 <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
     932:	0f b6       	in	r0, 0x3f	; 63
     934:	f8 94       	cli
     936:	0f 92       	push	r0
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
     938:	89 81       	ldd	r24, Y+1	; 0x01
     93a:	9a 81       	ldd	r25, Y+2	; 0x02
     93c:	0e 94 4f 04 	call	0x89e	; 0x89e <xTaskIsTaskSuspended>
     940:	81 30       	cpi	r24, 0x01	; 1
     942:	b9 f5       	brne	.+110    	; 0x9b2 <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					uxListRemove(  &( pxTCB->xGenericListItem ) );
     944:	89 81       	ldd	r24, Y+1	; 0x01
     946:	9a 81       	ldd	r25, Y+2	; 0x02
     948:	02 96       	adiw	r24, 0x02	; 2
     94a:	0e 94 a5 11 	call	0x234a	; 0x234a <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
     94e:	e9 81       	ldd	r30, Y+1	; 0x01
     950:	fa 81       	ldd	r31, Y+2	; 0x02
     952:	96 89       	ldd	r25, Z+22	; 0x16
     954:	80 91 2c 02 	lds	r24, 0x022C
     958:	89 17       	cp	r24, r25
     95a:	28 f4       	brcc	.+10     	; 0x966 <vTaskResume+0x6a>
     95c:	e9 81       	ldd	r30, Y+1	; 0x01
     95e:	fa 81       	ldd	r31, Y+2	; 0x02
     960:	86 89       	ldd	r24, Z+22	; 0x16
     962:	80 93 2c 02 	sts	0x022C, r24
     966:	e9 81       	ldd	r30, Y+1	; 0x01
     968:	fa 81       	ldd	r31, Y+2	; 0x02
     96a:	86 89       	ldd	r24, Z+22	; 0x16
     96c:	28 2f       	mov	r18, r24
     96e:	30 e0       	ldi	r19, 0x00	; 0
     970:	c9 01       	movw	r24, r18
     972:	88 0f       	add	r24, r24
     974:	99 1f       	adc	r25, r25
     976:	88 0f       	add	r24, r24
     978:	99 1f       	adc	r25, r25
     97a:	88 0f       	add	r24, r24
     97c:	99 1f       	adc	r25, r25
     97e:	82 0f       	add	r24, r18
     980:	93 1f       	adc	r25, r19
     982:	ac 01       	movw	r20, r24
     984:	4d 5c       	subi	r20, 0xCD	; 205
     986:	5d 4f       	sbci	r21, 0xFD	; 253
     988:	89 81       	ldd	r24, Y+1	; 0x01
     98a:	9a 81       	ldd	r25, Y+2	; 0x02
     98c:	9c 01       	movw	r18, r24
     98e:	2e 5f       	subi	r18, 0xFE	; 254
     990:	3f 4f       	sbci	r19, 0xFF	; 255
     992:	ca 01       	movw	r24, r20
     994:	b9 01       	movw	r22, r18
     996:	0e 94 ee 10 	call	0x21dc	; 0x21dc <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     99a:	e9 81       	ldd	r30, Y+1	; 0x01
     99c:	fa 81       	ldd	r31, Y+2	; 0x02
     99e:	96 89       	ldd	r25, Z+22	; 0x16
     9a0:	e0 91 26 02 	lds	r30, 0x0226
     9a4:	f0 91 27 02 	lds	r31, 0x0227
     9a8:	86 89       	ldd	r24, Z+22	; 0x16
     9aa:	98 17       	cp	r25, r24
     9ac:	10 f0       	brcs	.+4      	; 0x9b2 <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
     9ae:	0e 94 12 17 	call	0x2e24	; 0x2e24 <vPortYield>
					}
				}
			}
			taskEXIT_CRITICAL();
     9b2:	0f 90       	pop	r0
     9b4:	0f be       	out	0x3f, r0	; 63
		}
	}
     9b6:	0f 90       	pop	r0
     9b8:	0f 90       	pop	r0
     9ba:	0f 90       	pop	r0
     9bc:	0f 90       	pop	r0
     9be:	cf 91       	pop	r28
     9c0:	df 91       	pop	r29
     9c2:	08 95       	ret

000009c4 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
     9c4:	df 93       	push	r29
     9c6:	cf 93       	push	r28
     9c8:	00 d0       	rcall	.+0      	; 0x9ca <xTaskResumeFromISR+0x6>
     9ca:	00 d0       	rcall	.+0      	; 0x9cc <xTaskResumeFromISR+0x8>
     9cc:	cd b7       	in	r28, 0x3d	; 61
     9ce:	de b7       	in	r29, 0x3e	; 62
     9d0:	9e 83       	std	Y+6, r25	; 0x06
     9d2:	8d 83       	std	Y+5, r24	; 0x05
	portBASE_TYPE xYieldRequired = pdFALSE;
     9d4:	1c 82       	std	Y+4, r1	; 0x04
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxSavedInterruptStatus;

		configASSERT( pxTaskToResume );

		pxTCB = ( tskTCB * ) pxTaskToResume;
     9d6:	8d 81       	ldd	r24, Y+5	; 0x05
     9d8:	9e 81       	ldd	r25, Y+6	; 0x06
     9da:	9b 83       	std	Y+3, r25	; 0x03
     9dc:	8a 83       	std	Y+2, r24	; 0x02

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     9de:	19 82       	std	Y+1, r1	; 0x01
		{
			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
     9e0:	8a 81       	ldd	r24, Y+2	; 0x02
     9e2:	9b 81       	ldd	r25, Y+3	; 0x03
     9e4:	0e 94 4f 04 	call	0x89e	; 0x89e <xTaskIsTaskSuspended>
     9e8:	81 30       	cpi	r24, 0x01	; 1
     9ea:	09 f0       	breq	.+2      	; 0x9ee <xTaskResumeFromISR+0x2a>
     9ec:	47 c0       	rjmp	.+142    	; 0xa7c <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     9ee:	80 91 2e 02 	lds	r24, 0x022E
     9f2:	88 23       	and	r24, r24
     9f4:	c9 f5       	brne	.+114    	; 0xa68 <xTaskResumeFromISR+0xa4>
				{
					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
     9f6:	ea 81       	ldd	r30, Y+2	; 0x02
     9f8:	fb 81       	ldd	r31, Y+3	; 0x03
     9fa:	96 89       	ldd	r25, Z+22	; 0x16
     9fc:	e0 91 26 02 	lds	r30, 0x0226
     a00:	f0 91 27 02 	lds	r31, 0x0227
     a04:	86 89       	ldd	r24, Z+22	; 0x16
     a06:	1c 82       	std	Y+4, r1	; 0x04
     a08:	98 17       	cp	r25, r24
     a0a:	10 f0       	brcs	.+4      	; 0xa10 <xTaskResumeFromISR+0x4c>
     a0c:	81 e0       	ldi	r24, 0x01	; 1
     a0e:	8c 83       	std	Y+4, r24	; 0x04
					uxListRemove(  &( pxTCB->xGenericListItem ) );
     a10:	8a 81       	ldd	r24, Y+2	; 0x02
     a12:	9b 81       	ldd	r25, Y+3	; 0x03
     a14:	02 96       	adiw	r24, 0x02	; 2
     a16:	0e 94 a5 11 	call	0x234a	; 0x234a <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
     a1a:	ea 81       	ldd	r30, Y+2	; 0x02
     a1c:	fb 81       	ldd	r31, Y+3	; 0x03
     a1e:	96 89       	ldd	r25, Z+22	; 0x16
     a20:	80 91 2c 02 	lds	r24, 0x022C
     a24:	89 17       	cp	r24, r25
     a26:	28 f4       	brcc	.+10     	; 0xa32 <xTaskResumeFromISR+0x6e>
     a28:	ea 81       	ldd	r30, Y+2	; 0x02
     a2a:	fb 81       	ldd	r31, Y+3	; 0x03
     a2c:	86 89       	ldd	r24, Z+22	; 0x16
     a2e:	80 93 2c 02 	sts	0x022C, r24
     a32:	ea 81       	ldd	r30, Y+2	; 0x02
     a34:	fb 81       	ldd	r31, Y+3	; 0x03
     a36:	86 89       	ldd	r24, Z+22	; 0x16
     a38:	28 2f       	mov	r18, r24
     a3a:	30 e0       	ldi	r19, 0x00	; 0
     a3c:	c9 01       	movw	r24, r18
     a3e:	88 0f       	add	r24, r24
     a40:	99 1f       	adc	r25, r25
     a42:	88 0f       	add	r24, r24
     a44:	99 1f       	adc	r25, r25
     a46:	88 0f       	add	r24, r24
     a48:	99 1f       	adc	r25, r25
     a4a:	82 0f       	add	r24, r18
     a4c:	93 1f       	adc	r25, r19
     a4e:	ac 01       	movw	r20, r24
     a50:	4d 5c       	subi	r20, 0xCD	; 205
     a52:	5d 4f       	sbci	r21, 0xFD	; 253
     a54:	8a 81       	ldd	r24, Y+2	; 0x02
     a56:	9b 81       	ldd	r25, Y+3	; 0x03
     a58:	9c 01       	movw	r18, r24
     a5a:	2e 5f       	subi	r18, 0xFE	; 254
     a5c:	3f 4f       	sbci	r19, 0xFF	; 255
     a5e:	ca 01       	movw	r24, r20
     a60:	b9 01       	movw	r22, r18
     a62:	0e 94 ee 10 	call	0x21dc	; 0x21dc <vListInsertEnd>
     a66:	0a c0       	rjmp	.+20     	; 0xa7c <xTaskResumeFromISR+0xb8>
				else
				{
					/* We cannot access the delayed or ready lists, so will hold this
					task pending until the scheduler is resumed, at which point a
					yield will be performed if necessary. */
					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
     a68:	8a 81       	ldd	r24, Y+2	; 0x02
     a6a:	9b 81       	ldd	r25, Y+3	; 0x03
     a6c:	9c 01       	movw	r18, r24
     a6e:	24 5f       	subi	r18, 0xF4	; 244
     a70:	3f 4f       	sbci	r19, 0xFF	; 255
     a72:	8d e6       	ldi	r24, 0x6D	; 109
     a74:	92 e0       	ldi	r25, 0x02	; 2
     a76:	b9 01       	movw	r22, r18
     a78:	0e 94 ee 10 	call	0x21dc	; 0x21dc <vListInsertEnd>
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
     a7c:	8c 81       	ldd	r24, Y+4	; 0x04
	}
     a7e:	26 96       	adiw	r28, 0x06	; 6
     a80:	0f b6       	in	r0, 0x3f	; 63
     a82:	f8 94       	cli
     a84:	de bf       	out	0x3e, r29	; 62
     a86:	0f be       	out	0x3f, r0	; 63
     a88:	cd bf       	out	0x3d, r28	; 61
     a8a:	cf 91       	pop	r28
     a8c:	df 91       	pop	r29
     a8e:	08 95       	ret

00000a90 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
     a90:	af 92       	push	r10
     a92:	bf 92       	push	r11
     a94:	cf 92       	push	r12
     a96:	df 92       	push	r13
     a98:	ef 92       	push	r14
     a9a:	ff 92       	push	r15
     a9c:	0f 93       	push	r16
     a9e:	df 93       	push	r29
     aa0:	cf 93       	push	r28
     aa2:	0f 92       	push	r0
     aa4:	cd b7       	in	r28, 0x3d	; 61
     aa6:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
     aa8:	88 ee       	ldi	r24, 0xE8	; 232
     aaa:	98 e0       	ldi	r25, 0x08	; 8
     aac:	2e e1       	ldi	r18, 0x1E	; 30
     aae:	32 e0       	ldi	r19, 0x02	; 2
     ab0:	b9 01       	movw	r22, r18
     ab2:	45 e5       	ldi	r20, 0x55	; 85
     ab4:	50 e0       	ldi	r21, 0x00	; 0
     ab6:	20 e0       	ldi	r18, 0x00	; 0
     ab8:	30 e0       	ldi	r19, 0x00	; 0
     aba:	00 e0       	ldi	r16, 0x00	; 0
     abc:	ee 24       	eor	r14, r14
     abe:	ff 24       	eor	r15, r15
     ac0:	cc 24       	eor	r12, r12
     ac2:	dd 24       	eor	r13, r13
     ac4:	aa 24       	eor	r10, r10
     ac6:	bb 24       	eor	r11, r11
     ac8:	0e 94 53 02 	call	0x4a6	; 0x4a6 <xTaskGenericCreate>
     acc:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
     ace:	89 81       	ldd	r24, Y+1	; 0x01
     ad0:	81 30       	cpi	r24, 0x01	; 1
     ad2:	51 f4       	brne	.+20     	; 0xae8 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
     ad4:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
     ad6:	81 e0       	ldi	r24, 0x01	; 1
     ad8:	80 93 2d 02 	sts	0x022D, r24
		xTickCount = ( portTickType ) 0U;
     adc:	10 92 2a 02 	sts	0x022A, r1
     ae0:	10 92 29 02 	sts	0x0229, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     ae4:	0e 94 d2 16 	call	0x2da4	; 0x2da4 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
     ae8:	0f 90       	pop	r0
     aea:	cf 91       	pop	r28
     aec:	df 91       	pop	r29
     aee:	0f 91       	pop	r16
     af0:	ff 90       	pop	r15
     af2:	ef 90       	pop	r14
     af4:	df 90       	pop	r13
     af6:	cf 90       	pop	r12
     af8:	bf 90       	pop	r11
     afa:	af 90       	pop	r10
     afc:	08 95       	ret

00000afe <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
     afe:	df 93       	push	r29
     b00:	cf 93       	push	r28
     b02:	cd b7       	in	r28, 0x3d	; 61
     b04:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
     b06:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
     b08:	10 92 2d 02 	sts	0x022D, r1
	vPortEndScheduler();
     b0c:	0e 94 0b 17 	call	0x2e16	; 0x2e16 <vPortEndScheduler>
}
     b10:	cf 91       	pop	r28
     b12:	df 91       	pop	r29
     b14:	08 95       	ret

00000b16 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
     b16:	df 93       	push	r29
     b18:	cf 93       	push	r28
     b1a:	cd b7       	in	r28, 0x3d	; 61
     b1c:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
     b1e:	80 91 2e 02 	lds	r24, 0x022E
     b22:	8f 5f       	subi	r24, 0xFF	; 255
     b24:	80 93 2e 02 	sts	0x022E, r24
}
     b28:	cf 91       	pop	r28
     b2a:	df 91       	pop	r29
     b2c:	08 95       	ret

00000b2e <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE != 0  */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
     b2e:	df 93       	push	r29
     b30:	cf 93       	push	r28
     b32:	00 d0       	rcall	.+0      	; 0xb34 <xTaskResumeAll+0x6>
     b34:	0f 92       	push	r0
     b36:	cd b7       	in	r28, 0x3d	; 61
     b38:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
     b3a:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     b3c:	0f b6       	in	r0, 0x3f	; 63
     b3e:	f8 94       	cli
     b40:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     b42:	80 91 2e 02 	lds	r24, 0x022E
     b46:	81 50       	subi	r24, 0x01	; 1
     b48:	80 93 2e 02 	sts	0x022E, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     b4c:	80 91 2e 02 	lds	r24, 0x022E
     b50:	88 23       	and	r24, r24
     b52:	09 f0       	breq	.+2      	; 0xb56 <xTaskResumeAll+0x28>
     b54:	6c c0       	rjmp	.+216    	; 0xc2e <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
     b56:	80 91 28 02 	lds	r24, 0x0228
     b5a:	88 23       	and	r24, r24
     b5c:	09 f4       	brne	.+2      	; 0xb60 <xTaskResumeAll+0x32>
     b5e:	67 c0       	rjmp	.+206    	; 0xc2e <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
     b60:	19 82       	std	Y+1, r1	; 0x01
     b62:	41 c0       	rjmp	.+130    	; 0xbe6 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
     b64:	e0 91 72 02 	lds	r30, 0x0272
     b68:	f0 91 73 02 	lds	r31, 0x0273
     b6c:	86 81       	ldd	r24, Z+6	; 0x06
     b6e:	97 81       	ldd	r25, Z+7	; 0x07
     b70:	9c 83       	std	Y+4, r25	; 0x04
     b72:	8b 83       	std	Y+3, r24	; 0x03
					uxListRemove( &( pxTCB->xEventListItem ) );
     b74:	8b 81       	ldd	r24, Y+3	; 0x03
     b76:	9c 81       	ldd	r25, Y+4	; 0x04
     b78:	0c 96       	adiw	r24, 0x0c	; 12
     b7a:	0e 94 a5 11 	call	0x234a	; 0x234a <uxListRemove>
					uxListRemove( &( pxTCB->xGenericListItem ) );
     b7e:	8b 81       	ldd	r24, Y+3	; 0x03
     b80:	9c 81       	ldd	r25, Y+4	; 0x04
     b82:	02 96       	adiw	r24, 0x02	; 2
     b84:	0e 94 a5 11 	call	0x234a	; 0x234a <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
     b88:	eb 81       	ldd	r30, Y+3	; 0x03
     b8a:	fc 81       	ldd	r31, Y+4	; 0x04
     b8c:	96 89       	ldd	r25, Z+22	; 0x16
     b8e:	80 91 2c 02 	lds	r24, 0x022C
     b92:	89 17       	cp	r24, r25
     b94:	28 f4       	brcc	.+10     	; 0xba0 <xTaskResumeAll+0x72>
     b96:	eb 81       	ldd	r30, Y+3	; 0x03
     b98:	fc 81       	ldd	r31, Y+4	; 0x04
     b9a:	86 89       	ldd	r24, Z+22	; 0x16
     b9c:	80 93 2c 02 	sts	0x022C, r24
     ba0:	eb 81       	ldd	r30, Y+3	; 0x03
     ba2:	fc 81       	ldd	r31, Y+4	; 0x04
     ba4:	86 89       	ldd	r24, Z+22	; 0x16
     ba6:	28 2f       	mov	r18, r24
     ba8:	30 e0       	ldi	r19, 0x00	; 0
     baa:	c9 01       	movw	r24, r18
     bac:	88 0f       	add	r24, r24
     bae:	99 1f       	adc	r25, r25
     bb0:	88 0f       	add	r24, r24
     bb2:	99 1f       	adc	r25, r25
     bb4:	88 0f       	add	r24, r24
     bb6:	99 1f       	adc	r25, r25
     bb8:	82 0f       	add	r24, r18
     bba:	93 1f       	adc	r25, r19
     bbc:	8d 5c       	subi	r24, 0xCD	; 205
     bbe:	9d 4f       	sbci	r25, 0xFD	; 253
     bc0:	2b 81       	ldd	r18, Y+3	; 0x03
     bc2:	3c 81       	ldd	r19, Y+4	; 0x04
     bc4:	2e 5f       	subi	r18, 0xFE	; 254
     bc6:	3f 4f       	sbci	r19, 0xFF	; 255
     bc8:	b9 01       	movw	r22, r18
     bca:	0e 94 ee 10 	call	0x21dc	; 0x21dc <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     bce:	eb 81       	ldd	r30, Y+3	; 0x03
     bd0:	fc 81       	ldd	r31, Y+4	; 0x04
     bd2:	96 89       	ldd	r25, Z+22	; 0x16
     bd4:	e0 91 26 02 	lds	r30, 0x0226
     bd8:	f0 91 27 02 	lds	r31, 0x0227
     bdc:	86 89       	ldd	r24, Z+22	; 0x16
     bde:	98 17       	cp	r25, r24
     be0:	10 f0       	brcs	.+4      	; 0xbe6 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
     be2:	81 e0       	ldi	r24, 0x01	; 1
     be4:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
     be6:	80 91 6d 02 	lds	r24, 0x026D
     bea:	88 23       	and	r24, r24
     bec:	09 f0       	breq	.+2      	; 0xbf0 <xTaskResumeAll+0xc2>
     bee:	ba cf       	rjmp	.-140    	; 0xb64 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
     bf0:	80 91 2f 02 	lds	r24, 0x022F
     bf4:	88 23       	and	r24, r24
     bf6:	71 f0       	breq	.+28     	; 0xc14 <xTaskResumeAll+0xe6>
     bf8:	07 c0       	rjmp	.+14     	; 0xc08 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
     bfa:	0e 94 56 06 	call	0xcac	; 0xcac <vTaskIncrementTick>
						--uxMissedTicks;
     bfe:	80 91 2f 02 	lds	r24, 0x022F
     c02:	81 50       	subi	r24, 0x01	; 1
     c04:	80 93 2f 02 	sts	0x022F, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
     c08:	80 91 2f 02 	lds	r24, 0x022F
     c0c:	88 23       	and	r24, r24
     c0e:	a9 f7       	brne	.-22     	; 0xbfa <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
     c10:	81 e0       	ldi	r24, 0x01	; 1
     c12:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
     c14:	89 81       	ldd	r24, Y+1	; 0x01
     c16:	81 30       	cpi	r24, 0x01	; 1
     c18:	21 f0       	breq	.+8      	; 0xc22 <xTaskResumeAll+0xf4>
     c1a:	80 91 30 02 	lds	r24, 0x0230
     c1e:	81 30       	cpi	r24, 0x01	; 1
     c20:	31 f4       	brne	.+12     	; 0xc2e <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
     c22:	81 e0       	ldi	r24, 0x01	; 1
     c24:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
     c26:	10 92 30 02 	sts	0x0230, r1
					portYIELD_WITHIN_API();
     c2a:	0e 94 12 17 	call	0x2e24	; 0x2e24 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
     c2e:	0f 90       	pop	r0
     c30:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
     c32:	8a 81       	ldd	r24, Y+2	; 0x02
}
     c34:	0f 90       	pop	r0
     c36:	0f 90       	pop	r0
     c38:	0f 90       	pop	r0
     c3a:	0f 90       	pop	r0
     c3c:	cf 91       	pop	r28
     c3e:	df 91       	pop	r29
     c40:	08 95       	ret

00000c42 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
     c42:	df 93       	push	r29
     c44:	cf 93       	push	r28
     c46:	0f 92       	push	r0
     c48:	0f 92       	push	r0
     c4a:	cd b7       	in	r28, 0x3d	; 61
     c4c:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
     c4e:	0f b6       	in	r0, 0x3f	; 63
     c50:	f8 94       	cli
     c52:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     c54:	80 91 29 02 	lds	r24, 0x0229
     c58:	90 91 2a 02 	lds	r25, 0x022A
     c5c:	9a 83       	std	Y+2, r25	; 0x02
     c5e:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
     c60:	0f 90       	pop	r0
     c62:	0f be       	out	0x3f, r0	; 63

	return xTicks;
     c64:	89 81       	ldd	r24, Y+1	; 0x01
     c66:	9a 81       	ldd	r25, Y+2	; 0x02
}
     c68:	0f 90       	pop	r0
     c6a:	0f 90       	pop	r0
     c6c:	cf 91       	pop	r28
     c6e:	df 91       	pop	r29
     c70:	08 95       	ret

00000c72 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
     c72:	df 93       	push	r29
     c74:	cf 93       	push	r28
     c76:	00 d0       	rcall	.+0      	; 0xc78 <xTaskGetTickCountFromISR+0x6>
     c78:	cd b7       	in	r28, 0x3d	; 61
     c7a:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     c7c:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
     c7e:	80 91 29 02 	lds	r24, 0x0229
     c82:	90 91 2a 02 	lds	r25, 0x022A
     c86:	9b 83       	std	Y+3, r25	; 0x03
     c88:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
     c8a:	8a 81       	ldd	r24, Y+2	; 0x02
     c8c:	9b 81       	ldd	r25, Y+3	; 0x03
}
     c8e:	0f 90       	pop	r0
     c90:	0f 90       	pop	r0
     c92:	0f 90       	pop	r0
     c94:	cf 91       	pop	r28
     c96:	df 91       	pop	r29
     c98:	08 95       	ret

00000c9a <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
     c9a:	df 93       	push	r29
     c9c:	cf 93       	push	r28
     c9e:	cd b7       	in	r28, 0x3d	; 61
     ca0:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
     ca2:	80 91 28 02 	lds	r24, 0x0228
}
     ca6:	cf 91       	pop	r28
     ca8:	df 91       	pop	r29
     caa:	08 95       	ret

00000cac <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
     cac:	df 93       	push	r29
     cae:	cf 93       	push	r28
     cb0:	00 d0       	rcall	.+0      	; 0xcb2 <vTaskIncrementTick+0x6>
     cb2:	00 d0       	rcall	.+0      	; 0xcb4 <vTaskIncrementTick+0x8>
     cb4:	cd b7       	in	r28, 0x3d	; 61
     cb6:	de b7       	in	r29, 0x3e	; 62

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     cb8:	80 91 2e 02 	lds	r24, 0x022E
     cbc:	88 23       	and	r24, r24
     cbe:	09 f0       	breq	.+2      	; 0xcc2 <vTaskIncrementTick+0x16>
     cc0:	bb c0       	rjmp	.+374    	; 0xe38 <vTaskIncrementTick+0x18c>
	{
		++xTickCount;
     cc2:	80 91 29 02 	lds	r24, 0x0229
     cc6:	90 91 2a 02 	lds	r25, 0x022A
     cca:	01 96       	adiw	r24, 0x01	; 1
     ccc:	90 93 2a 02 	sts	0x022A, r25
     cd0:	80 93 29 02 	sts	0x0229, r24
		if( xTickCount == ( portTickType ) 0U )
     cd4:	80 91 29 02 	lds	r24, 0x0229
     cd8:	90 91 2a 02 	lds	r25, 0x022A
     cdc:	00 97       	sbiw	r24, 0x00	; 0
     cde:	d1 f5       	brne	.+116    	; 0xd54 <vTaskIncrementTick+0xa8>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
     ce0:	80 91 69 02 	lds	r24, 0x0269
     ce4:	90 91 6a 02 	lds	r25, 0x026A
     ce8:	9c 83       	std	Y+4, r25	; 0x04
     cea:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
     cec:	80 91 6b 02 	lds	r24, 0x026B
     cf0:	90 91 6c 02 	lds	r25, 0x026C
     cf4:	90 93 6a 02 	sts	0x026A, r25
     cf8:	80 93 69 02 	sts	0x0269, r24
			pxOverflowDelayedTaskList = pxTemp;
     cfc:	8b 81       	ldd	r24, Y+3	; 0x03
     cfe:	9c 81       	ldd	r25, Y+4	; 0x04
     d00:	90 93 6c 02 	sts	0x026C, r25
     d04:	80 93 6b 02 	sts	0x026B, r24
			xNumOfOverflows++;
     d08:	80 91 31 02 	lds	r24, 0x0231
     d0c:	8f 5f       	subi	r24, 0xFF	; 255
     d0e:	80 93 31 02 	sts	0x0231, r24

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     d12:	e0 91 69 02 	lds	r30, 0x0269
     d16:	f0 91 6a 02 	lds	r31, 0x026A
     d1a:	80 81       	ld	r24, Z
     d1c:	88 23       	and	r24, r24
     d1e:	39 f4       	brne	.+14     	; 0xd2e <vTaskIncrementTick+0x82>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
     d20:	8f ef       	ldi	r24, 0xFF	; 255
     d22:	9f ef       	ldi	r25, 0xFF	; 255
     d24:	90 93 1d 02 	sts	0x021D, r25
     d28:	80 93 1c 02 	sts	0x021C, r24
     d2c:	13 c0       	rjmp	.+38     	; 0xd54 <vTaskIncrementTick+0xa8>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     d2e:	e0 91 69 02 	lds	r30, 0x0269
     d32:	f0 91 6a 02 	lds	r31, 0x026A
     d36:	05 80       	ldd	r0, Z+5	; 0x05
     d38:	f6 81       	ldd	r31, Z+6	; 0x06
     d3a:	e0 2d       	mov	r30, r0
     d3c:	86 81       	ldd	r24, Z+6	; 0x06
     d3e:	97 81       	ldd	r25, Z+7	; 0x07
     d40:	9e 83       	std	Y+6, r25	; 0x06
     d42:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
     d44:	ed 81       	ldd	r30, Y+5	; 0x05
     d46:	fe 81       	ldd	r31, Y+6	; 0x06
     d48:	82 81       	ldd	r24, Z+2	; 0x02
     d4a:	93 81       	ldd	r25, Z+3	; 0x03
     d4c:	90 93 1d 02 	sts	0x021D, r25
     d50:	80 93 1c 02 	sts	0x021C, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
     d54:	20 91 29 02 	lds	r18, 0x0229
     d58:	30 91 2a 02 	lds	r19, 0x022A
     d5c:	80 91 1c 02 	lds	r24, 0x021C
     d60:	90 91 1d 02 	lds	r25, 0x021D
     d64:	28 17       	cp	r18, r24
     d66:	39 07       	cpc	r19, r25
     d68:	08 f4       	brcc	.+2      	; 0xd6c <vTaskIncrementTick+0xc0>
     d6a:	6b c0       	rjmp	.+214    	; 0xe42 <vTaskIncrementTick+0x196>
     d6c:	e0 91 69 02 	lds	r30, 0x0269
     d70:	f0 91 6a 02 	lds	r31, 0x026A
     d74:	80 81       	ld	r24, Z
     d76:	88 23       	and	r24, r24
     d78:	39 f4       	brne	.+14     	; 0xd88 <vTaskIncrementTick+0xdc>
     d7a:	8f ef       	ldi	r24, 0xFF	; 255
     d7c:	9f ef       	ldi	r25, 0xFF	; 255
     d7e:	90 93 1d 02 	sts	0x021D, r25
     d82:	80 93 1c 02 	sts	0x021C, r24
     d86:	5d c0       	rjmp	.+186    	; 0xe42 <vTaskIncrementTick+0x196>
     d88:	e0 91 69 02 	lds	r30, 0x0269
     d8c:	f0 91 6a 02 	lds	r31, 0x026A
     d90:	05 80       	ldd	r0, Z+5	; 0x05
     d92:	f6 81       	ldd	r31, Z+6	; 0x06
     d94:	e0 2d       	mov	r30, r0
     d96:	86 81       	ldd	r24, Z+6	; 0x06
     d98:	97 81       	ldd	r25, Z+7	; 0x07
     d9a:	9e 83       	std	Y+6, r25	; 0x06
     d9c:	8d 83       	std	Y+5, r24	; 0x05
     d9e:	ed 81       	ldd	r30, Y+5	; 0x05
     da0:	fe 81       	ldd	r31, Y+6	; 0x06
     da2:	82 81       	ldd	r24, Z+2	; 0x02
     da4:	93 81       	ldd	r25, Z+3	; 0x03
     da6:	9a 83       	std	Y+2, r25	; 0x02
     da8:	89 83       	std	Y+1, r24	; 0x01
     daa:	20 91 29 02 	lds	r18, 0x0229
     dae:	30 91 2a 02 	lds	r19, 0x022A
     db2:	89 81       	ldd	r24, Y+1	; 0x01
     db4:	9a 81       	ldd	r25, Y+2	; 0x02
     db6:	28 17       	cp	r18, r24
     db8:	39 07       	cpc	r19, r25
     dba:	38 f4       	brcc	.+14     	; 0xdca <vTaskIncrementTick+0x11e>
     dbc:	89 81       	ldd	r24, Y+1	; 0x01
     dbe:	9a 81       	ldd	r25, Y+2	; 0x02
     dc0:	90 93 1d 02 	sts	0x021D, r25
     dc4:	80 93 1c 02 	sts	0x021C, r24
     dc8:	3c c0       	rjmp	.+120    	; 0xe42 <vTaskIncrementTick+0x196>
     dca:	8d 81       	ldd	r24, Y+5	; 0x05
     dcc:	9e 81       	ldd	r25, Y+6	; 0x06
     dce:	02 96       	adiw	r24, 0x02	; 2
     dd0:	0e 94 a5 11 	call	0x234a	; 0x234a <uxListRemove>
     dd4:	ed 81       	ldd	r30, Y+5	; 0x05
     dd6:	fe 81       	ldd	r31, Y+6	; 0x06
     dd8:	84 89       	ldd	r24, Z+20	; 0x14
     dda:	95 89       	ldd	r25, Z+21	; 0x15
     ddc:	00 97       	sbiw	r24, 0x00	; 0
     dde:	29 f0       	breq	.+10     	; 0xdea <vTaskIncrementTick+0x13e>
     de0:	8d 81       	ldd	r24, Y+5	; 0x05
     de2:	9e 81       	ldd	r25, Y+6	; 0x06
     de4:	0c 96       	adiw	r24, 0x0c	; 12
     de6:	0e 94 a5 11 	call	0x234a	; 0x234a <uxListRemove>
     dea:	ed 81       	ldd	r30, Y+5	; 0x05
     dec:	fe 81       	ldd	r31, Y+6	; 0x06
     dee:	96 89       	ldd	r25, Z+22	; 0x16
     df0:	80 91 2c 02 	lds	r24, 0x022C
     df4:	89 17       	cp	r24, r25
     df6:	28 f4       	brcc	.+10     	; 0xe02 <vTaskIncrementTick+0x156>
     df8:	ed 81       	ldd	r30, Y+5	; 0x05
     dfa:	fe 81       	ldd	r31, Y+6	; 0x06
     dfc:	86 89       	ldd	r24, Z+22	; 0x16
     dfe:	80 93 2c 02 	sts	0x022C, r24
     e02:	ed 81       	ldd	r30, Y+5	; 0x05
     e04:	fe 81       	ldd	r31, Y+6	; 0x06
     e06:	86 89       	ldd	r24, Z+22	; 0x16
     e08:	28 2f       	mov	r18, r24
     e0a:	30 e0       	ldi	r19, 0x00	; 0
     e0c:	c9 01       	movw	r24, r18
     e0e:	88 0f       	add	r24, r24
     e10:	99 1f       	adc	r25, r25
     e12:	88 0f       	add	r24, r24
     e14:	99 1f       	adc	r25, r25
     e16:	88 0f       	add	r24, r24
     e18:	99 1f       	adc	r25, r25
     e1a:	82 0f       	add	r24, r18
     e1c:	93 1f       	adc	r25, r19
     e1e:	ac 01       	movw	r20, r24
     e20:	4d 5c       	subi	r20, 0xCD	; 205
     e22:	5d 4f       	sbci	r21, 0xFD	; 253
     e24:	8d 81       	ldd	r24, Y+5	; 0x05
     e26:	9e 81       	ldd	r25, Y+6	; 0x06
     e28:	9c 01       	movw	r18, r24
     e2a:	2e 5f       	subi	r18, 0xFE	; 254
     e2c:	3f 4f       	sbci	r19, 0xFF	; 255
     e2e:	ca 01       	movw	r24, r20
     e30:	b9 01       	movw	r22, r18
     e32:	0e 94 ee 10 	call	0x21dc	; 0x21dc <vListInsertEnd>
     e36:	9a cf       	rjmp	.-204    	; 0xd6c <vTaskIncrementTick+0xc0>
	}
	else
	{
		++uxMissedTicks;
     e38:	80 91 2f 02 	lds	r24, 0x022F
     e3c:	8f 5f       	subi	r24, 0xFF	; 255
     e3e:	80 93 2f 02 	sts	0x022F, r24
		{
			vApplicationTickHook();
		}
	}
	#endif
}
     e42:	26 96       	adiw	r28, 0x06	; 6
     e44:	0f b6       	in	r0, 0x3f	; 63
     e46:	f8 94       	cli
     e48:	de bf       	out	0x3e, r29	; 62
     e4a:	0f be       	out	0x3f, r0	; 63
     e4c:	cd bf       	out	0x3d, r28	; 61
     e4e:	cf 91       	pop	r28
     e50:	df 91       	pop	r29
     e52:	08 95       	ret

00000e54 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
     e54:	df 93       	push	r29
     e56:	cf 93       	push	r28
     e58:	0f 92       	push	r0
     e5a:	0f 92       	push	r0
     e5c:	cd b7       	in	r28, 0x3d	; 61
     e5e:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
     e60:	80 91 2e 02 	lds	r24, 0x022E
     e64:	88 23       	and	r24, r24
     e66:	21 f0       	breq	.+8      	; 0xe70 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
     e68:	81 e0       	ldi	r24, 0x01	; 1
     e6a:	80 93 30 02 	sts	0x0230, r24
     e6e:	70 c0       	rjmp	.+224    	; 0xf50 <vTaskSwitchContext+0xfc>
				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
				ulTaskSwitchedInTime = ulTempCounter;
		}
		#endif

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
     e70:	e0 91 26 02 	lds	r30, 0x0226
     e74:	f0 91 27 02 	lds	r31, 0x0227
     e78:	20 81       	ld	r18, Z
     e7a:	31 81       	ldd	r19, Z+1	; 0x01
     e7c:	e0 91 26 02 	lds	r30, 0x0226
     e80:	f0 91 27 02 	lds	r31, 0x0227
     e84:	87 89       	ldd	r24, Z+23	; 0x17
     e86:	90 8d       	ldd	r25, Z+24	; 0x18
     e88:	82 17       	cp	r24, r18
     e8a:	93 07       	cpc	r25, r19
     e8c:	90 f0       	brcs	.+36     	; 0xeb2 <vTaskSwitchContext+0x5e>
     e8e:	80 91 26 02 	lds	r24, 0x0226
     e92:	90 91 27 02 	lds	r25, 0x0227
     e96:	20 91 26 02 	lds	r18, 0x0226
     e9a:	30 91 27 02 	lds	r19, 0x0227
     e9e:	27 5e       	subi	r18, 0xE7	; 231
     ea0:	3f 4f       	sbci	r19, 0xFF	; 255
     ea2:	b9 01       	movw	r22, r18
     ea4:	0e 94 a5 00 	call	0x14a	; 0x14a <vApplicationStackOverflowHook>
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
     ea8:	80 91 2c 02 	lds	r24, 0x022C
     eac:	81 50       	subi	r24, 0x01	; 1
     eae:	80 93 2c 02 	sts	0x022C, r24
     eb2:	80 91 2c 02 	lds	r24, 0x022C
     eb6:	28 2f       	mov	r18, r24
     eb8:	30 e0       	ldi	r19, 0x00	; 0
     eba:	c9 01       	movw	r24, r18
     ebc:	88 0f       	add	r24, r24
     ebe:	99 1f       	adc	r25, r25
     ec0:	88 0f       	add	r24, r24
     ec2:	99 1f       	adc	r25, r25
     ec4:	88 0f       	add	r24, r24
     ec6:	99 1f       	adc	r25, r25
     ec8:	82 0f       	add	r24, r18
     eca:	93 1f       	adc	r25, r19
     ecc:	fc 01       	movw	r30, r24
     ece:	ed 5c       	subi	r30, 0xCD	; 205
     ed0:	fd 4f       	sbci	r31, 0xFD	; 253
     ed2:	80 81       	ld	r24, Z
     ed4:	88 23       	and	r24, r24
     ed6:	41 f3       	breq	.-48     	; 0xea8 <vTaskSwitchContext+0x54>
     ed8:	80 91 2c 02 	lds	r24, 0x022C
     edc:	28 2f       	mov	r18, r24
     ede:	30 e0       	ldi	r19, 0x00	; 0
     ee0:	c9 01       	movw	r24, r18
     ee2:	88 0f       	add	r24, r24
     ee4:	99 1f       	adc	r25, r25
     ee6:	88 0f       	add	r24, r24
     ee8:	99 1f       	adc	r25, r25
     eea:	88 0f       	add	r24, r24
     eec:	99 1f       	adc	r25, r25
     eee:	82 0f       	add	r24, r18
     ef0:	93 1f       	adc	r25, r19
     ef2:	8d 5c       	subi	r24, 0xCD	; 205
     ef4:	9d 4f       	sbci	r25, 0xFD	; 253
     ef6:	9a 83       	std	Y+2, r25	; 0x02
     ef8:	89 83       	std	Y+1, r24	; 0x01
     efa:	e9 81       	ldd	r30, Y+1	; 0x01
     efc:	fa 81       	ldd	r31, Y+2	; 0x02
     efe:	01 80       	ldd	r0, Z+1	; 0x01
     f00:	f2 81       	ldd	r31, Z+2	; 0x02
     f02:	e0 2d       	mov	r30, r0
     f04:	82 81       	ldd	r24, Z+2	; 0x02
     f06:	93 81       	ldd	r25, Z+3	; 0x03
     f08:	e9 81       	ldd	r30, Y+1	; 0x01
     f0a:	fa 81       	ldd	r31, Y+2	; 0x02
     f0c:	92 83       	std	Z+2, r25	; 0x02
     f0e:	81 83       	std	Z+1, r24	; 0x01
     f10:	e9 81       	ldd	r30, Y+1	; 0x01
     f12:	fa 81       	ldd	r31, Y+2	; 0x02
     f14:	21 81       	ldd	r18, Z+1	; 0x01
     f16:	32 81       	ldd	r19, Z+2	; 0x02
     f18:	89 81       	ldd	r24, Y+1	; 0x01
     f1a:	9a 81       	ldd	r25, Y+2	; 0x02
     f1c:	03 96       	adiw	r24, 0x03	; 3
     f1e:	28 17       	cp	r18, r24
     f20:	39 07       	cpc	r19, r25
     f22:	59 f4       	brne	.+22     	; 0xf3a <vTaskSwitchContext+0xe6>
     f24:	e9 81       	ldd	r30, Y+1	; 0x01
     f26:	fa 81       	ldd	r31, Y+2	; 0x02
     f28:	01 80       	ldd	r0, Z+1	; 0x01
     f2a:	f2 81       	ldd	r31, Z+2	; 0x02
     f2c:	e0 2d       	mov	r30, r0
     f2e:	82 81       	ldd	r24, Z+2	; 0x02
     f30:	93 81       	ldd	r25, Z+3	; 0x03
     f32:	e9 81       	ldd	r30, Y+1	; 0x01
     f34:	fa 81       	ldd	r31, Y+2	; 0x02
     f36:	92 83       	std	Z+2, r25	; 0x02
     f38:	81 83       	std	Z+1, r24	; 0x01
     f3a:	e9 81       	ldd	r30, Y+1	; 0x01
     f3c:	fa 81       	ldd	r31, Y+2	; 0x02
     f3e:	01 80       	ldd	r0, Z+1	; 0x01
     f40:	f2 81       	ldd	r31, Z+2	; 0x02
     f42:	e0 2d       	mov	r30, r0
     f44:	86 81       	ldd	r24, Z+6	; 0x06
     f46:	97 81       	ldd	r25, Z+7	; 0x07
     f48:	90 93 27 02 	sts	0x0227, r25
     f4c:	80 93 26 02 	sts	0x0226, r24

		traceTASK_SWITCHED_IN();
	}
}
     f50:	0f 90       	pop	r0
     f52:	0f 90       	pop	r0
     f54:	cf 91       	pop	r28
     f56:	df 91       	pop	r29
     f58:	08 95       	ret

00000f5a <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
     f5a:	df 93       	push	r29
     f5c:	cf 93       	push	r28
     f5e:	00 d0       	rcall	.+0      	; 0xf60 <vTaskPlaceOnEventList+0x6>
     f60:	00 d0       	rcall	.+0      	; 0xf62 <vTaskPlaceOnEventList+0x8>
     f62:	cd b7       	in	r28, 0x3d	; 61
     f64:	de b7       	in	r29, 0x3e	; 62
     f66:	9c 83       	std	Y+4, r25	; 0x04
     f68:	8b 83       	std	Y+3, r24	; 0x03
     f6a:	7e 83       	std	Y+6, r23	; 0x06
     f6c:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
     f6e:	4b 81       	ldd	r20, Y+3	; 0x03
     f70:	5c 81       	ldd	r21, Y+4	; 0x04
     f72:	80 91 26 02 	lds	r24, 0x0226
     f76:	90 91 27 02 	lds	r25, 0x0227
     f7a:	9c 01       	movw	r18, r24
     f7c:	24 5f       	subi	r18, 0xF4	; 244
     f7e:	3f 4f       	sbci	r19, 0xFF	; 255
     f80:	ca 01       	movw	r24, r20
     f82:	b9 01       	movw	r22, r18
     f84:	0e 94 39 11 	call	0x2272	; 0x2272 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
     f88:	80 91 26 02 	lds	r24, 0x0226
     f8c:	90 91 27 02 	lds	r25, 0x0227
     f90:	02 96       	adiw	r24, 0x02	; 2
     f92:	0e 94 a5 11 	call	0x234a	; 0x234a <uxListRemove>
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
     f96:	8d 81       	ldd	r24, Y+5	; 0x05
     f98:	9e 81       	ldd	r25, Y+6	; 0x06
     f9a:	2f ef       	ldi	r18, 0xFF	; 255
     f9c:	8f 3f       	cpi	r24, 0xFF	; 255
     f9e:	92 07       	cpc	r25, r18
     fa0:	69 f4       	brne	.+26     	; 0xfbc <vTaskPlaceOnEventList+0x62>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
     fa2:	80 91 26 02 	lds	r24, 0x0226
     fa6:	90 91 27 02 	lds	r25, 0x0227
     faa:	9c 01       	movw	r18, r24
     fac:	2e 5f       	subi	r18, 0xFE	; 254
     fae:	3f 4f       	sbci	r19, 0xFF	; 255
     fb0:	86 e7       	ldi	r24, 0x76	; 118
     fb2:	92 e0       	ldi	r25, 0x02	; 2
     fb4:	b9 01       	movw	r22, r18
     fb6:	0e 94 ee 10 	call	0x21dc	; 0x21dc <vListInsertEnd>
     fba:	0e c0       	rjmp	.+28     	; 0xfd8 <vTaskPlaceOnEventList+0x7e>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
     fbc:	20 91 29 02 	lds	r18, 0x0229
     fc0:	30 91 2a 02 	lds	r19, 0x022A
     fc4:	8d 81       	ldd	r24, Y+5	; 0x05
     fc6:	9e 81       	ldd	r25, Y+6	; 0x06
     fc8:	82 0f       	add	r24, r18
     fca:	93 1f       	adc	r25, r19
     fcc:	9a 83       	std	Y+2, r25	; 0x02
     fce:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
     fd0:	89 81       	ldd	r24, Y+1	; 0x01
     fd2:	9a 81       	ldd	r25, Y+2	; 0x02
     fd4:	0e 94 98 09 	call	0x1330	; 0x1330 <prvAddCurrentTaskToDelayedList>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
     fd8:	26 96       	adiw	r28, 0x06	; 6
     fda:	0f b6       	in	r0, 0x3f	; 63
     fdc:	f8 94       	cli
     fde:	de bf       	out	0x3e, r29	; 62
     fe0:	0f be       	out	0x3f, r0	; 63
     fe2:	cd bf       	out	0x3d, r28	; 61
     fe4:	cf 91       	pop	r28
     fe6:	df 91       	pop	r29
     fe8:	08 95       	ret

00000fea <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
     fea:	df 93       	push	r29
     fec:	cf 93       	push	r28
     fee:	00 d0       	rcall	.+0      	; 0xff0 <xTaskRemoveFromEventList+0x6>
     ff0:	0f 92       	push	r0
     ff2:	0f 92       	push	r0
     ff4:	cd b7       	in	r28, 0x3d	; 61
     ff6:	de b7       	in	r29, 0x3e	; 62
     ff8:	9d 83       	std	Y+5, r25	; 0x05
     ffa:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     ffc:	ec 81       	ldd	r30, Y+4	; 0x04
     ffe:	fd 81       	ldd	r31, Y+5	; 0x05
    1000:	05 80       	ldd	r0, Z+5	; 0x05
    1002:	f6 81       	ldd	r31, Z+6	; 0x06
    1004:	e0 2d       	mov	r30, r0
    1006:	86 81       	ldd	r24, Z+6	; 0x06
    1008:	97 81       	ldd	r25, Z+7	; 0x07
    100a:	9b 83       	std	Y+3, r25	; 0x03
    100c:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    100e:	8a 81       	ldd	r24, Y+2	; 0x02
    1010:	9b 81       	ldd	r25, Y+3	; 0x03
    1012:	0c 96       	adiw	r24, 0x0c	; 12
    1014:	0e 94 a5 11 	call	0x234a	; 0x234a <uxListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1018:	80 91 2e 02 	lds	r24, 0x022E
    101c:	88 23       	and	r24, r24
    101e:	61 f5       	brne	.+88     	; 0x1078 <xTaskRemoveFromEventList+0x8e>
	{
		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    1020:	8a 81       	ldd	r24, Y+2	; 0x02
    1022:	9b 81       	ldd	r25, Y+3	; 0x03
    1024:	02 96       	adiw	r24, 0x02	; 2
    1026:	0e 94 a5 11 	call	0x234a	; 0x234a <uxListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    102a:	ea 81       	ldd	r30, Y+2	; 0x02
    102c:	fb 81       	ldd	r31, Y+3	; 0x03
    102e:	96 89       	ldd	r25, Z+22	; 0x16
    1030:	80 91 2c 02 	lds	r24, 0x022C
    1034:	89 17       	cp	r24, r25
    1036:	28 f4       	brcc	.+10     	; 0x1042 <xTaskRemoveFromEventList+0x58>
    1038:	ea 81       	ldd	r30, Y+2	; 0x02
    103a:	fb 81       	ldd	r31, Y+3	; 0x03
    103c:	86 89       	ldd	r24, Z+22	; 0x16
    103e:	80 93 2c 02 	sts	0x022C, r24
    1042:	ea 81       	ldd	r30, Y+2	; 0x02
    1044:	fb 81       	ldd	r31, Y+3	; 0x03
    1046:	86 89       	ldd	r24, Z+22	; 0x16
    1048:	28 2f       	mov	r18, r24
    104a:	30 e0       	ldi	r19, 0x00	; 0
    104c:	c9 01       	movw	r24, r18
    104e:	88 0f       	add	r24, r24
    1050:	99 1f       	adc	r25, r25
    1052:	88 0f       	add	r24, r24
    1054:	99 1f       	adc	r25, r25
    1056:	88 0f       	add	r24, r24
    1058:	99 1f       	adc	r25, r25
    105a:	82 0f       	add	r24, r18
    105c:	93 1f       	adc	r25, r19
    105e:	ac 01       	movw	r20, r24
    1060:	4d 5c       	subi	r20, 0xCD	; 205
    1062:	5d 4f       	sbci	r21, 0xFD	; 253
    1064:	8a 81       	ldd	r24, Y+2	; 0x02
    1066:	9b 81       	ldd	r25, Y+3	; 0x03
    1068:	9c 01       	movw	r18, r24
    106a:	2e 5f       	subi	r18, 0xFE	; 254
    106c:	3f 4f       	sbci	r19, 0xFF	; 255
    106e:	ca 01       	movw	r24, r20
    1070:	b9 01       	movw	r22, r18
    1072:	0e 94 ee 10 	call	0x21dc	; 0x21dc <vListInsertEnd>
    1076:	0a c0       	rjmp	.+20     	; 0x108c <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1078:	8a 81       	ldd	r24, Y+2	; 0x02
    107a:	9b 81       	ldd	r25, Y+3	; 0x03
    107c:	9c 01       	movw	r18, r24
    107e:	24 5f       	subi	r18, 0xF4	; 244
    1080:	3f 4f       	sbci	r19, 0xFF	; 255
    1082:	8d e6       	ldi	r24, 0x6D	; 109
    1084:	92 e0       	ldi	r25, 0x02	; 2
    1086:	b9 01       	movw	r22, r18
    1088:	0e 94 ee 10 	call	0x21dc	; 0x21dc <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    108c:	ea 81       	ldd	r30, Y+2	; 0x02
    108e:	fb 81       	ldd	r31, Y+3	; 0x03
    1090:	96 89       	ldd	r25, Z+22	; 0x16
    1092:	e0 91 26 02 	lds	r30, 0x0226
    1096:	f0 91 27 02 	lds	r31, 0x0227
    109a:	86 89       	ldd	r24, Z+22	; 0x16
    109c:	98 17       	cp	r25, r24
    109e:	18 f0       	brcs	.+6      	; 0x10a6 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    10a0:	81 e0       	ldi	r24, 0x01	; 1
    10a2:	89 83       	std	Y+1, r24	; 0x01
    10a4:	01 c0       	rjmp	.+2      	; 0x10a8 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    10a6:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    10a8:	89 81       	ldd	r24, Y+1	; 0x01
}
    10aa:	0f 90       	pop	r0
    10ac:	0f 90       	pop	r0
    10ae:	0f 90       	pop	r0
    10b0:	0f 90       	pop	r0
    10b2:	0f 90       	pop	r0
    10b4:	cf 91       	pop	r28
    10b6:	df 91       	pop	r29
    10b8:	08 95       	ret

000010ba <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    10ba:	df 93       	push	r29
    10bc:	cf 93       	push	r28
    10be:	0f 92       	push	r0
    10c0:	0f 92       	push	r0
    10c2:	cd b7       	in	r28, 0x3d	; 61
    10c4:	de b7       	in	r29, 0x3e	; 62
    10c6:	9a 83       	std	Y+2, r25	; 0x02
    10c8:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    10ca:	80 91 31 02 	lds	r24, 0x0231
    10ce:	e9 81       	ldd	r30, Y+1	; 0x01
    10d0:	fa 81       	ldd	r31, Y+2	; 0x02
    10d2:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    10d4:	80 91 29 02 	lds	r24, 0x0229
    10d8:	90 91 2a 02 	lds	r25, 0x022A
    10dc:	e9 81       	ldd	r30, Y+1	; 0x01
    10de:	fa 81       	ldd	r31, Y+2	; 0x02
    10e0:	92 83       	std	Z+2, r25	; 0x02
    10e2:	81 83       	std	Z+1, r24	; 0x01
}
    10e4:	0f 90       	pop	r0
    10e6:	0f 90       	pop	r0
    10e8:	cf 91       	pop	r28
    10ea:	df 91       	pop	r29
    10ec:	08 95       	ret

000010ee <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    10ee:	df 93       	push	r29
    10f0:	cf 93       	push	r28
    10f2:	00 d0       	rcall	.+0      	; 0x10f4 <xTaskCheckForTimeOut+0x6>
    10f4:	0f 92       	push	r0
    10f6:	0f 92       	push	r0
    10f8:	cd b7       	in	r28, 0x3d	; 61
    10fa:	de b7       	in	r29, 0x3e	; 62
    10fc:	9b 83       	std	Y+3, r25	; 0x03
    10fe:	8a 83       	std	Y+2, r24	; 0x02
    1100:	7d 83       	std	Y+5, r23	; 0x05
    1102:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1104:	0f b6       	in	r0, 0x3f	; 63
    1106:	f8 94       	cli
    1108:	0f 92       	push	r0
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    110a:	ec 81       	ldd	r30, Y+4	; 0x04
    110c:	fd 81       	ldd	r31, Y+5	; 0x05
    110e:	80 81       	ld	r24, Z
    1110:	91 81       	ldd	r25, Z+1	; 0x01
    1112:	2f ef       	ldi	r18, 0xFF	; 255
    1114:	8f 3f       	cpi	r24, 0xFF	; 255
    1116:	92 07       	cpc	r25, r18
    1118:	11 f4       	brne	.+4      	; 0x111e <xTaskCheckForTimeOut+0x30>
			{
				xReturn = pdFALSE;
    111a:	19 82       	std	Y+1, r1	; 0x01
    111c:	44 c0       	rjmp	.+136    	; 0x11a6 <xTaskCheckForTimeOut+0xb8>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    111e:	ea 81       	ldd	r30, Y+2	; 0x02
    1120:	fb 81       	ldd	r31, Y+3	; 0x03
    1122:	90 81       	ld	r25, Z
    1124:	80 91 31 02 	lds	r24, 0x0231
    1128:	98 17       	cp	r25, r24
    112a:	71 f0       	breq	.+28     	; 0x1148 <xTaskCheckForTimeOut+0x5a>
    112c:	ea 81       	ldd	r30, Y+2	; 0x02
    112e:	fb 81       	ldd	r31, Y+3	; 0x03
    1130:	21 81       	ldd	r18, Z+1	; 0x01
    1132:	32 81       	ldd	r19, Z+2	; 0x02
    1134:	80 91 29 02 	lds	r24, 0x0229
    1138:	90 91 2a 02 	lds	r25, 0x022A
    113c:	82 17       	cp	r24, r18
    113e:	93 07       	cpc	r25, r19
    1140:	18 f0       	brcs	.+6      	; 0x1148 <xTaskCheckForTimeOut+0x5a>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    1142:	81 e0       	ldi	r24, 0x01	; 1
    1144:	89 83       	std	Y+1, r24	; 0x01
    1146:	2f c0       	rjmp	.+94     	; 0x11a6 <xTaskCheckForTimeOut+0xb8>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    1148:	20 91 29 02 	lds	r18, 0x0229
    114c:	30 91 2a 02 	lds	r19, 0x022A
    1150:	ea 81       	ldd	r30, Y+2	; 0x02
    1152:	fb 81       	ldd	r31, Y+3	; 0x03
    1154:	81 81       	ldd	r24, Z+1	; 0x01
    1156:	92 81       	ldd	r25, Z+2	; 0x02
    1158:	28 1b       	sub	r18, r24
    115a:	39 0b       	sbc	r19, r25
    115c:	ec 81       	ldd	r30, Y+4	; 0x04
    115e:	fd 81       	ldd	r31, Y+5	; 0x05
    1160:	80 81       	ld	r24, Z
    1162:	91 81       	ldd	r25, Z+1	; 0x01
    1164:	28 17       	cp	r18, r24
    1166:	39 07       	cpc	r19, r25
    1168:	e0 f4       	brcc	.+56     	; 0x11a2 <xTaskCheckForTimeOut+0xb4>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    116a:	ec 81       	ldd	r30, Y+4	; 0x04
    116c:	fd 81       	ldd	r31, Y+5	; 0x05
    116e:	40 81       	ld	r20, Z
    1170:	51 81       	ldd	r21, Z+1	; 0x01
    1172:	ea 81       	ldd	r30, Y+2	; 0x02
    1174:	fb 81       	ldd	r31, Y+3	; 0x03
    1176:	21 81       	ldd	r18, Z+1	; 0x01
    1178:	32 81       	ldd	r19, Z+2	; 0x02
    117a:	80 91 29 02 	lds	r24, 0x0229
    117e:	90 91 2a 02 	lds	r25, 0x022A
    1182:	b9 01       	movw	r22, r18
    1184:	68 1b       	sub	r22, r24
    1186:	79 0b       	sbc	r23, r25
    1188:	cb 01       	movw	r24, r22
    118a:	84 0f       	add	r24, r20
    118c:	95 1f       	adc	r25, r21
    118e:	ec 81       	ldd	r30, Y+4	; 0x04
    1190:	fd 81       	ldd	r31, Y+5	; 0x05
    1192:	91 83       	std	Z+1, r25	; 0x01
    1194:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    1196:	8a 81       	ldd	r24, Y+2	; 0x02
    1198:	9b 81       	ldd	r25, Y+3	; 0x03
    119a:	0e 94 5d 08 	call	0x10ba	; 0x10ba <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    119e:	19 82       	std	Y+1, r1	; 0x01
    11a0:	02 c0       	rjmp	.+4      	; 0x11a6 <xTaskCheckForTimeOut+0xb8>
		}
		else
		{
			xReturn = pdTRUE;
    11a2:	81 e0       	ldi	r24, 0x01	; 1
    11a4:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    11a6:	0f 90       	pop	r0
    11a8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    11aa:	89 81       	ldd	r24, Y+1	; 0x01
}
    11ac:	0f 90       	pop	r0
    11ae:	0f 90       	pop	r0
    11b0:	0f 90       	pop	r0
    11b2:	0f 90       	pop	r0
    11b4:	0f 90       	pop	r0
    11b6:	cf 91       	pop	r28
    11b8:	df 91       	pop	r29
    11ba:	08 95       	ret

000011bc <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    11bc:	df 93       	push	r29
    11be:	cf 93       	push	r28
    11c0:	cd b7       	in	r28, 0x3d	; 61
    11c2:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    11c4:	81 e0       	ldi	r24, 0x01	; 1
    11c6:	80 93 30 02 	sts	0x0230, r24
}
    11ca:	cf 91       	pop	r28
    11cc:	df 91       	pop	r29
    11ce:	08 95       	ret

000011d0 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    11d0:	df 93       	push	r29
    11d2:	cf 93       	push	r28
    11d4:	0f 92       	push	r0
    11d6:	0f 92       	push	r0
    11d8:	cd b7       	in	r28, 0x3d	; 61
    11da:	de b7       	in	r29, 0x3e	; 62
    11dc:	9a 83       	std	Y+2, r25	; 0x02
    11de:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    11e0:	0e 94 91 09 	call	0x1322	; 0x1322 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    11e4:	80 91 33 02 	lds	r24, 0x0233
    11e8:	82 30       	cpi	r24, 0x02	; 2
    11ea:	d0 f3       	brcs	.-12     	; 0x11e0 <prvIdleTask+0x10>
			{
				taskYIELD();
    11ec:	0e 94 12 17 	call	0x2e24	; 0x2e24 <vPortYield>
    11f0:	f7 cf       	rjmp	.-18     	; 0x11e0 <prvIdleTask+0x10>

000011f2 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    11f2:	0f 93       	push	r16
    11f4:	1f 93       	push	r17
    11f6:	df 93       	push	r29
    11f8:	cf 93       	push	r28
    11fa:	cd b7       	in	r28, 0x3d	; 61
    11fc:	de b7       	in	r29, 0x3e	; 62
    11fe:	29 97       	sbiw	r28, 0x09	; 9
    1200:	0f b6       	in	r0, 0x3f	; 63
    1202:	f8 94       	cli
    1204:	de bf       	out	0x3e, r29	; 62
    1206:	0f be       	out	0x3f, r0	; 63
    1208:	cd bf       	out	0x3d, r28	; 61
    120a:	9a 83       	std	Y+2, r25	; 0x02
    120c:	89 83       	std	Y+1, r24	; 0x01
    120e:	7c 83       	std	Y+4, r23	; 0x04
    1210:	6b 83       	std	Y+3, r22	; 0x03
    1212:	4d 83       	std	Y+5, r20	; 0x05
    1214:	3f 83       	std	Y+7, r19	; 0x07
    1216:	2e 83       	std	Y+6, r18	; 0x06
    1218:	19 87       	std	Y+9, r17	; 0x09
    121a:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    121c:	89 81       	ldd	r24, Y+1	; 0x01
    121e:	9a 81       	ldd	r25, Y+2	; 0x02
    1220:	49 96       	adiw	r24, 0x19	; 25
    1222:	2b 81       	ldd	r18, Y+3	; 0x03
    1224:	3c 81       	ldd	r19, Y+4	; 0x04
    1226:	b9 01       	movw	r22, r18
    1228:	40 e1       	ldi	r20, 0x10	; 16
    122a:	50 e0       	ldi	r21, 0x00	; 0
    122c:	0e 94 21 20 	call	0x4042	; 0x4042 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    1230:	e9 81       	ldd	r30, Y+1	; 0x01
    1232:	fa 81       	ldd	r31, Y+2	; 0x02
    1234:	10 a6       	std	Z+40, r1	; 0x28

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    1236:	8d 81       	ldd	r24, Y+5	; 0x05
    1238:	84 30       	cpi	r24, 0x04	; 4
    123a:	10 f0       	brcs	.+4      	; 0x1240 <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    123c:	83 e0       	ldi	r24, 0x03	; 3
    123e:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    1240:	e9 81       	ldd	r30, Y+1	; 0x01
    1242:	fa 81       	ldd	r31, Y+2	; 0x02
    1244:	8d 81       	ldd	r24, Y+5	; 0x05
    1246:	86 8b       	std	Z+22, r24	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    1248:	e9 81       	ldd	r30, Y+1	; 0x01
    124a:	fa 81       	ldd	r31, Y+2	; 0x02
    124c:	8d 81       	ldd	r24, Y+5	; 0x05
    124e:	81 a7       	std	Z+41, r24	; 0x29
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    1250:	89 81       	ldd	r24, Y+1	; 0x01
    1252:	9a 81       	ldd	r25, Y+2	; 0x02
    1254:	02 96       	adiw	r24, 0x02	; 2
    1256:	0e 94 dd 10 	call	0x21ba	; 0x21ba <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    125a:	89 81       	ldd	r24, Y+1	; 0x01
    125c:	9a 81       	ldd	r25, Y+2	; 0x02
    125e:	0c 96       	adiw	r24, 0x0c	; 12
    1260:	0e 94 dd 10 	call	0x21ba	; 0x21ba <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    1264:	e9 81       	ldd	r30, Y+1	; 0x01
    1266:	fa 81       	ldd	r31, Y+2	; 0x02
    1268:	89 81       	ldd	r24, Y+1	; 0x01
    126a:	9a 81       	ldd	r25, Y+2	; 0x02
    126c:	91 87       	std	Z+9, r25	; 0x09
    126e:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    1270:	8d 81       	ldd	r24, Y+5	; 0x05
    1272:	28 2f       	mov	r18, r24
    1274:	30 e0       	ldi	r19, 0x00	; 0
    1276:	84 e0       	ldi	r24, 0x04	; 4
    1278:	90 e0       	ldi	r25, 0x00	; 0
    127a:	82 1b       	sub	r24, r18
    127c:	93 0b       	sbc	r25, r19
    127e:	e9 81       	ldd	r30, Y+1	; 0x01
    1280:	fa 81       	ldd	r31, Y+2	; 0x02
    1282:	95 87       	std	Z+13, r25	; 0x0d
    1284:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    1286:	e9 81       	ldd	r30, Y+1	; 0x01
    1288:	fa 81       	ldd	r31, Y+2	; 0x02
    128a:	89 81       	ldd	r24, Y+1	; 0x01
    128c:	9a 81       	ldd	r25, Y+2	; 0x02
    128e:	93 8b       	std	Z+19, r25	; 0x13
    1290:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    1292:	29 96       	adiw	r28, 0x09	; 9
    1294:	0f b6       	in	r0, 0x3f	; 63
    1296:	f8 94       	cli
    1298:	de bf       	out	0x3e, r29	; 62
    129a:	0f be       	out	0x3f, r0	; 63
    129c:	cd bf       	out	0x3d, r28	; 61
    129e:	cf 91       	pop	r28
    12a0:	df 91       	pop	r29
    12a2:	1f 91       	pop	r17
    12a4:	0f 91       	pop	r16
    12a6:	08 95       	ret

000012a8 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    12a8:	df 93       	push	r29
    12aa:	cf 93       	push	r28
    12ac:	0f 92       	push	r0
    12ae:	cd b7       	in	r28, 0x3d	; 61
    12b0:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    12b2:	19 82       	std	Y+1, r1	; 0x01
    12b4:	13 c0       	rjmp	.+38     	; 0x12dc <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    12b6:	89 81       	ldd	r24, Y+1	; 0x01
    12b8:	28 2f       	mov	r18, r24
    12ba:	30 e0       	ldi	r19, 0x00	; 0
    12bc:	c9 01       	movw	r24, r18
    12be:	88 0f       	add	r24, r24
    12c0:	99 1f       	adc	r25, r25
    12c2:	88 0f       	add	r24, r24
    12c4:	99 1f       	adc	r25, r25
    12c6:	88 0f       	add	r24, r24
    12c8:	99 1f       	adc	r25, r25
    12ca:	82 0f       	add	r24, r18
    12cc:	93 1f       	adc	r25, r19
    12ce:	8d 5c       	subi	r24, 0xCD	; 205
    12d0:	9d 4f       	sbci	r25, 0xFD	; 253
    12d2:	0e 94 b2 10 	call	0x2164	; 0x2164 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    12d6:	89 81       	ldd	r24, Y+1	; 0x01
    12d8:	8f 5f       	subi	r24, 0xFF	; 255
    12da:	89 83       	std	Y+1, r24	; 0x01
    12dc:	89 81       	ldd	r24, Y+1	; 0x01
    12de:	84 30       	cpi	r24, 0x04	; 4
    12e0:	50 f3       	brcs	.-44     	; 0x12b6 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    12e2:	87 e5       	ldi	r24, 0x57	; 87
    12e4:	92 e0       	ldi	r25, 0x02	; 2
    12e6:	0e 94 b2 10 	call	0x2164	; 0x2164 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    12ea:	80 e6       	ldi	r24, 0x60	; 96
    12ec:	92 e0       	ldi	r25, 0x02	; 2
    12ee:	0e 94 b2 10 	call	0x2164	; 0x2164 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    12f2:	8d e6       	ldi	r24, 0x6D	; 109
    12f4:	92 e0       	ldi	r25, 0x02	; 2
    12f6:	0e 94 b2 10 	call	0x2164	; 0x2164 <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
    12fa:	86 e7       	ldi	r24, 0x76	; 118
    12fc:	92 e0       	ldi	r25, 0x02	; 2
    12fe:	0e 94 b2 10 	call	0x2164	; 0x2164 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1302:	87 e5       	ldi	r24, 0x57	; 87
    1304:	92 e0       	ldi	r25, 0x02	; 2
    1306:	90 93 6a 02 	sts	0x026A, r25
    130a:	80 93 69 02 	sts	0x0269, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    130e:	80 e6       	ldi	r24, 0x60	; 96
    1310:	92 e0       	ldi	r25, 0x02	; 2
    1312:	90 93 6c 02 	sts	0x026C, r25
    1316:	80 93 6b 02 	sts	0x026B, r24
}
    131a:	0f 90       	pop	r0
    131c:	cf 91       	pop	r28
    131e:	df 91       	pop	r29
    1320:	08 95       	ret

00001322 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    1322:	df 93       	push	r29
    1324:	cf 93       	push	r28
    1326:	cd b7       	in	r28, 0x3d	; 61
    1328:	de b7       	in	r29, 0x3e	; 62
				prvDeleteTCB( pxTCB );
			}
		}
	}
	#endif
}
    132a:	cf 91       	pop	r28
    132c:	df 91       	pop	r29
    132e:	08 95       	ret

00001330 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    1330:	df 93       	push	r29
    1332:	cf 93       	push	r28
    1334:	0f 92       	push	r0
    1336:	0f 92       	push	r0
    1338:	cd b7       	in	r28, 0x3d	; 61
    133a:	de b7       	in	r29, 0x3e	; 62
    133c:	9a 83       	std	Y+2, r25	; 0x02
    133e:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1340:	e0 91 26 02 	lds	r30, 0x0226
    1344:	f0 91 27 02 	lds	r31, 0x0227
    1348:	89 81       	ldd	r24, Y+1	; 0x01
    134a:	9a 81       	ldd	r25, Y+2	; 0x02
    134c:	93 83       	std	Z+3, r25	; 0x03
    134e:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    1350:	20 91 29 02 	lds	r18, 0x0229
    1354:	30 91 2a 02 	lds	r19, 0x022A
    1358:	89 81       	ldd	r24, Y+1	; 0x01
    135a:	9a 81       	ldd	r25, Y+2	; 0x02
    135c:	82 17       	cp	r24, r18
    135e:	93 07       	cpc	r25, r19
    1360:	70 f4       	brcc	.+28     	; 0x137e <prvAddCurrentTaskToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1362:	80 91 6b 02 	lds	r24, 0x026B
    1366:	90 91 6c 02 	lds	r25, 0x026C
    136a:	20 91 26 02 	lds	r18, 0x0226
    136e:	30 91 27 02 	lds	r19, 0x0227
    1372:	2e 5f       	subi	r18, 0xFE	; 254
    1374:	3f 4f       	sbci	r19, 0xFF	; 255
    1376:	b9 01       	movw	r22, r18
    1378:	0e 94 39 11 	call	0x2272	; 0x2272 <vListInsert>
    137c:	1e c0       	rjmp	.+60     	; 0x13ba <prvAddCurrentTaskToDelayedList+0x8a>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    137e:	40 91 69 02 	lds	r20, 0x0269
    1382:	50 91 6a 02 	lds	r21, 0x026A
    1386:	80 91 26 02 	lds	r24, 0x0226
    138a:	90 91 27 02 	lds	r25, 0x0227
    138e:	9c 01       	movw	r18, r24
    1390:	2e 5f       	subi	r18, 0xFE	; 254
    1392:	3f 4f       	sbci	r19, 0xFF	; 255
    1394:	ca 01       	movw	r24, r20
    1396:	b9 01       	movw	r22, r18
    1398:	0e 94 39 11 	call	0x2272	; 0x2272 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    139c:	20 91 1c 02 	lds	r18, 0x021C
    13a0:	30 91 1d 02 	lds	r19, 0x021D
    13a4:	89 81       	ldd	r24, Y+1	; 0x01
    13a6:	9a 81       	ldd	r25, Y+2	; 0x02
    13a8:	82 17       	cp	r24, r18
    13aa:	93 07       	cpc	r25, r19
    13ac:	30 f4       	brcc	.+12     	; 0x13ba <prvAddCurrentTaskToDelayedList+0x8a>
		{
			xNextTaskUnblockTime = xTimeToWake;
    13ae:	89 81       	ldd	r24, Y+1	; 0x01
    13b0:	9a 81       	ldd	r25, Y+2	; 0x02
    13b2:	90 93 1d 02 	sts	0x021D, r25
    13b6:	80 93 1c 02 	sts	0x021C, r24
		}
	}
}
    13ba:	0f 90       	pop	r0
    13bc:	0f 90       	pop	r0
    13be:	cf 91       	pop	r28
    13c0:	df 91       	pop	r29
    13c2:	08 95       	ret

000013c4 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    13c4:	df 93       	push	r29
    13c6:	cf 93       	push	r28
    13c8:	cd b7       	in	r28, 0x3d	; 61
    13ca:	de b7       	in	r29, 0x3e	; 62
    13cc:	28 97       	sbiw	r28, 0x08	; 8
    13ce:	0f b6       	in	r0, 0x3f	; 63
    13d0:	f8 94       	cli
    13d2:	de bf       	out	0x3e, r29	; 62
    13d4:	0f be       	out	0x3f, r0	; 63
    13d6:	cd bf       	out	0x3d, r28	; 61
    13d8:	9c 83       	std	Y+4, r25	; 0x04
    13da:	8b 83       	std	Y+3, r24	; 0x03
    13dc:	7e 83       	std	Y+6, r23	; 0x06
    13de:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    13e0:	8a e2       	ldi	r24, 0x2A	; 42
    13e2:	90 e0       	ldi	r25, 0x00	; 0
    13e4:	0e 94 ca 14 	call	0x2994	; 0x2994 <pvPortMalloc>
    13e8:	9a 83       	std	Y+2, r25	; 0x02
    13ea:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    13ec:	89 81       	ldd	r24, Y+1	; 0x01
    13ee:	9a 81       	ldd	r25, Y+2	; 0x02
    13f0:	00 97       	sbiw	r24, 0x00	; 0
    13f2:	69 f1       	breq	.+90     	; 0x144e <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    13f4:	8d 81       	ldd	r24, Y+5	; 0x05
    13f6:	9e 81       	ldd	r25, Y+6	; 0x06
    13f8:	00 97       	sbiw	r24, 0x00	; 0
    13fa:	39 f4       	brne	.+14     	; 0x140a <prvAllocateTCBAndStack+0x46>
    13fc:	8b 81       	ldd	r24, Y+3	; 0x03
    13fe:	9c 81       	ldd	r25, Y+4	; 0x04
    1400:	0e 94 ca 14 	call	0x2994	; 0x2994 <pvPortMalloc>
    1404:	98 87       	std	Y+8, r25	; 0x08
    1406:	8f 83       	std	Y+7, r24	; 0x07
    1408:	04 c0       	rjmp	.+8      	; 0x1412 <prvAllocateTCBAndStack+0x4e>
    140a:	8d 81       	ldd	r24, Y+5	; 0x05
    140c:	9e 81       	ldd	r25, Y+6	; 0x06
    140e:	98 87       	std	Y+8, r25	; 0x08
    1410:	8f 83       	std	Y+7, r24	; 0x07
    1412:	e9 81       	ldd	r30, Y+1	; 0x01
    1414:	fa 81       	ldd	r31, Y+2	; 0x02
    1416:	8f 81       	ldd	r24, Y+7	; 0x07
    1418:	98 85       	ldd	r25, Y+8	; 0x08
    141a:	90 8f       	std	Z+24, r25	; 0x18
    141c:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    141e:	e9 81       	ldd	r30, Y+1	; 0x01
    1420:	fa 81       	ldd	r31, Y+2	; 0x02
    1422:	87 89       	ldd	r24, Z+23	; 0x17
    1424:	90 8d       	ldd	r25, Z+24	; 0x18
    1426:	00 97       	sbiw	r24, 0x00	; 0
    1428:	39 f4       	brne	.+14     	; 0x1438 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    142a:	89 81       	ldd	r24, Y+1	; 0x01
    142c:	9a 81       	ldd	r25, Y+2	; 0x02
    142e:	0e 94 10 15 	call	0x2a20	; 0x2a20 <vPortFree>
			pxNewTCB = NULL;
    1432:	1a 82       	std	Y+2, r1	; 0x02
    1434:	19 82       	std	Y+1, r1	; 0x01
    1436:	0b c0       	rjmp	.+22     	; 0x144e <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    1438:	e9 81       	ldd	r30, Y+1	; 0x01
    143a:	fa 81       	ldd	r31, Y+2	; 0x02
    143c:	87 89       	ldd	r24, Z+23	; 0x17
    143e:	90 8d       	ldd	r25, Z+24	; 0x18
    1440:	2b 81       	ldd	r18, Y+3	; 0x03
    1442:	3c 81       	ldd	r19, Y+4	; 0x04
    1444:	65 ea       	ldi	r22, 0xA5	; 165
    1446:	70 e0       	ldi	r23, 0x00	; 0
    1448:	a9 01       	movw	r20, r18
    144a:	0e 94 1a 20 	call	0x4034	; 0x4034 <memset>
		}
	}

	return pxNewTCB;
    144e:	89 81       	ldd	r24, Y+1	; 0x01
    1450:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1452:	28 96       	adiw	r28, 0x08	; 8
    1454:	0f b6       	in	r0, 0x3f	; 63
    1456:	f8 94       	cli
    1458:	de bf       	out	0x3e, r29	; 62
    145a:	0f be       	out	0x3f, r0	; 63
    145c:	cd bf       	out	0x3d, r28	; 61
    145e:	cf 91       	pop	r28
    1460:	df 91       	pop	r29
    1462:	08 95       	ret

00001464 <usTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
    1464:	df 93       	push	r29
    1466:	cf 93       	push	r28
    1468:	00 d0       	rcall	.+0      	; 0x146a <usTaskCheckFreeStackSpace+0x6>
    146a:	0f 92       	push	r0
    146c:	cd b7       	in	r28, 0x3d	; 61
    146e:	de b7       	in	r29, 0x3e	; 62
    1470:	9a 83       	std	Y+2, r25	; 0x02
    1472:	89 83       	std	Y+1, r24	; 0x01
	register unsigned short usCount = 0U;
    1474:	1c 82       	std	Y+4, r1	; 0x04
    1476:	1b 82       	std	Y+3, r1	; 0x03
    1478:	0a c0       	rjmp	.+20     	; 0x148e <usTaskCheckFreeStackSpace+0x2a>

		while( *pucStackByte == tskSTACK_FILL_BYTE )
		{
			pucStackByte -= portSTACK_GROWTH;
    147a:	89 81       	ldd	r24, Y+1	; 0x01
    147c:	9a 81       	ldd	r25, Y+2	; 0x02
    147e:	01 96       	adiw	r24, 0x01	; 1
    1480:	9a 83       	std	Y+2, r25	; 0x02
    1482:	89 83       	std	Y+1, r24	; 0x01
			usCount++;
    1484:	8b 81       	ldd	r24, Y+3	; 0x03
    1486:	9c 81       	ldd	r25, Y+4	; 0x04
    1488:	01 96       	adiw	r24, 0x01	; 1
    148a:	9c 83       	std	Y+4, r25	; 0x04
    148c:	8b 83       	std	Y+3, r24	; 0x03

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    148e:	e9 81       	ldd	r30, Y+1	; 0x01
    1490:	fa 81       	ldd	r31, Y+2	; 0x02
    1492:	80 81       	ld	r24, Z
    1494:	85 3a       	cpi	r24, 0xA5	; 165
    1496:	89 f3       	breq	.-30     	; 0x147a <usTaskCheckFreeStackSpace+0x16>
			usCount++;
		}

		usCount /= sizeof( portSTACK_TYPE );

		return usCount;
    1498:	8b 81       	ldd	r24, Y+3	; 0x03
    149a:	9c 81       	ldd	r25, Y+4	; 0x04
	}
    149c:	0f 90       	pop	r0
    149e:	0f 90       	pop	r0
    14a0:	0f 90       	pop	r0
    14a2:	0f 90       	pop	r0
    14a4:	cf 91       	pop	r28
    14a6:	df 91       	pop	r29
    14a8:	08 95       	ret

000014aa <uxTaskGetStackHighWaterMark>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
	{
    14aa:	df 93       	push	r29
    14ac:	cf 93       	push	r28
    14ae:	cd b7       	in	r28, 0x3d	; 61
    14b0:	de b7       	in	r29, 0x3e	; 62
    14b2:	29 97       	sbiw	r28, 0x09	; 9
    14b4:	0f b6       	in	r0, 0x3f	; 63
    14b6:	f8 94       	cli
    14b8:	de bf       	out	0x3e, r29	; 62
    14ba:	0f be       	out	0x3f, r0	; 63
    14bc:	cd bf       	out	0x3d, r28	; 61
    14be:	9f 83       	std	Y+7, r25	; 0x07
    14c0:	8e 83       	std	Y+6, r24	; 0x06
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    14c2:	8e 81       	ldd	r24, Y+6	; 0x06
    14c4:	9f 81       	ldd	r25, Y+7	; 0x07
    14c6:	00 97       	sbiw	r24, 0x00	; 0
    14c8:	39 f4       	brne	.+14     	; 0x14d8 <uxTaskGetStackHighWaterMark+0x2e>
    14ca:	80 91 26 02 	lds	r24, 0x0226
    14ce:	90 91 27 02 	lds	r25, 0x0227
    14d2:	99 87       	std	Y+9, r25	; 0x09
    14d4:	88 87       	std	Y+8, r24	; 0x08
    14d6:	04 c0       	rjmp	.+8      	; 0x14e0 <uxTaskGetStackHighWaterMark+0x36>
    14d8:	8e 81       	ldd	r24, Y+6	; 0x06
    14da:	9f 81       	ldd	r25, Y+7	; 0x07
    14dc:	99 87       	std	Y+9, r25	; 0x09
    14de:	88 87       	std	Y+8, r24	; 0x08
    14e0:	88 85       	ldd	r24, Y+8	; 0x08
    14e2:	99 85       	ldd	r25, Y+9	; 0x09
    14e4:	9d 83       	std	Y+5, r25	; 0x05
    14e6:	8c 83       	std	Y+4, r24	; 0x04

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    14e8:	ec 81       	ldd	r30, Y+4	; 0x04
    14ea:	fd 81       	ldd	r31, Y+5	; 0x05
    14ec:	87 89       	ldd	r24, Z+23	; 0x17
    14ee:	90 8d       	ldd	r25, Z+24	; 0x18
    14f0:	9b 83       	std	Y+3, r25	; 0x03
    14f2:	8a 83       	std	Y+2, r24	; 0x02
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
		}
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
    14f4:	8a 81       	ldd	r24, Y+2	; 0x02
    14f6:	9b 81       	ldd	r25, Y+3	; 0x03
    14f8:	0e 94 32 0a 	call	0x1464	; 0x1464 <usTaskCheckFreeStackSpace>
    14fc:	89 83       	std	Y+1, r24	; 0x01

		return uxReturn;
    14fe:	89 81       	ldd	r24, Y+1	; 0x01
	}
    1500:	29 96       	adiw	r28, 0x09	; 9
    1502:	0f b6       	in	r0, 0x3f	; 63
    1504:	f8 94       	cli
    1506:	de bf       	out	0x3e, r29	; 62
    1508:	0f be       	out	0x3f, r0	; 63
    150a:	cd bf       	out	0x3d, r28	; 61
    150c:	cf 91       	pop	r28
    150e:	df 91       	pop	r29
    1510:	08 95       	ret

00001512 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	xTaskHandle xTaskGetCurrentTaskHandle( void )
	{
    1512:	df 93       	push	r29
    1514:	cf 93       	push	r28
    1516:	0f 92       	push	r0
    1518:	0f 92       	push	r0
    151a:	cd b7       	in	r28, 0x3d	; 61
    151c:	de b7       	in	r29, 0x3e	; 62
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    151e:	80 91 26 02 	lds	r24, 0x0226
    1522:	90 91 27 02 	lds	r25, 0x0227
    1526:	9a 83       	std	Y+2, r25	; 0x02
    1528:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    152a:	89 81       	ldd	r24, Y+1	; 0x01
    152c:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    152e:	0f 90       	pop	r0
    1530:	0f 90       	pop	r0
    1532:	cf 91       	pop	r28
    1534:	df 91       	pop	r29
    1536:	08 95       	ret

00001538 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    1538:	df 93       	push	r29
    153a:	cf 93       	push	r28
    153c:	00 d0       	rcall	.+0      	; 0x153e <vTaskPriorityInherit+0x6>
    153e:	0f 92       	push	r0
    1540:	cd b7       	in	r28, 0x3d	; 61
    1542:	de b7       	in	r29, 0x3e	; 62
    1544:	9c 83       	std	Y+4, r25	; 0x04
    1546:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
    1548:	8b 81       	ldd	r24, Y+3	; 0x03
    154a:	9c 81       	ldd	r25, Y+4	; 0x04
    154c:	9a 83       	std	Y+2, r25	; 0x02
    154e:	89 83       	std	Y+1, r24	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    1550:	8b 81       	ldd	r24, Y+3	; 0x03
    1552:	9c 81       	ldd	r25, Y+4	; 0x04
    1554:	00 97       	sbiw	r24, 0x00	; 0
    1556:	09 f4       	brne	.+2      	; 0x155a <vTaskPriorityInherit+0x22>
    1558:	6d c0       	rjmp	.+218    	; 0x1634 <vTaskPriorityInherit+0xfc>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    155a:	e9 81       	ldd	r30, Y+1	; 0x01
    155c:	fa 81       	ldd	r31, Y+2	; 0x02
    155e:	96 89       	ldd	r25, Z+22	; 0x16
    1560:	e0 91 26 02 	lds	r30, 0x0226
    1564:	f0 91 27 02 	lds	r31, 0x0227
    1568:	86 89       	ldd	r24, Z+22	; 0x16
    156a:	98 17       	cp	r25, r24
    156c:	08 f0       	brcs	.+2      	; 0x1570 <vTaskPriorityInherit+0x38>
    156e:	62 c0       	rjmp	.+196    	; 0x1634 <vTaskPriorityInherit+0xfc>
			{
				/* Adjust the mutex holder state to account for its new priority. */
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    1570:	e0 91 26 02 	lds	r30, 0x0226
    1574:	f0 91 27 02 	lds	r31, 0x0227
    1578:	86 89       	ldd	r24, Z+22	; 0x16
    157a:	28 2f       	mov	r18, r24
    157c:	30 e0       	ldi	r19, 0x00	; 0
    157e:	84 e0       	ldi	r24, 0x04	; 4
    1580:	90 e0       	ldi	r25, 0x00	; 0
    1582:	82 1b       	sub	r24, r18
    1584:	93 0b       	sbc	r25, r19
    1586:	e9 81       	ldd	r30, Y+1	; 0x01
    1588:	fa 81       	ldd	r31, Y+2	; 0x02
    158a:	95 87       	std	Z+13, r25	; 0x0d
    158c:	84 87       	std	Z+12, r24	; 0x0c

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    158e:	e9 81       	ldd	r30, Y+1	; 0x01
    1590:	fa 81       	ldd	r31, Y+2	; 0x02
    1592:	42 85       	ldd	r20, Z+10	; 0x0a
    1594:	53 85       	ldd	r21, Z+11	; 0x0b
    1596:	e9 81       	ldd	r30, Y+1	; 0x01
    1598:	fa 81       	ldd	r31, Y+2	; 0x02
    159a:	86 89       	ldd	r24, Z+22	; 0x16
    159c:	28 2f       	mov	r18, r24
    159e:	30 e0       	ldi	r19, 0x00	; 0
    15a0:	c9 01       	movw	r24, r18
    15a2:	88 0f       	add	r24, r24
    15a4:	99 1f       	adc	r25, r25
    15a6:	88 0f       	add	r24, r24
    15a8:	99 1f       	adc	r25, r25
    15aa:	88 0f       	add	r24, r24
    15ac:	99 1f       	adc	r25, r25
    15ae:	82 0f       	add	r24, r18
    15b0:	93 1f       	adc	r25, r19
    15b2:	8d 5c       	subi	r24, 0xCD	; 205
    15b4:	9d 4f       	sbci	r25, 0xFD	; 253
    15b6:	48 17       	cp	r20, r24
    15b8:	59 07       	cpc	r21, r25
    15ba:	a1 f5       	brne	.+104    	; 0x1624 <vTaskPriorityInherit+0xec>
				{
					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    15bc:	89 81       	ldd	r24, Y+1	; 0x01
    15be:	9a 81       	ldd	r25, Y+2	; 0x02
    15c0:	02 96       	adiw	r24, 0x02	; 2
    15c2:	0e 94 a5 11 	call	0x234a	; 0x234a <uxListRemove>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    15c6:	e0 91 26 02 	lds	r30, 0x0226
    15ca:	f0 91 27 02 	lds	r31, 0x0227
    15ce:	86 89       	ldd	r24, Z+22	; 0x16
    15d0:	e9 81       	ldd	r30, Y+1	; 0x01
    15d2:	fa 81       	ldd	r31, Y+2	; 0x02
    15d4:	86 8b       	std	Z+22, r24	; 0x16
					prvAddTaskToReadyQueue( pxTCB );
    15d6:	e9 81       	ldd	r30, Y+1	; 0x01
    15d8:	fa 81       	ldd	r31, Y+2	; 0x02
    15da:	96 89       	ldd	r25, Z+22	; 0x16
    15dc:	80 91 2c 02 	lds	r24, 0x022C
    15e0:	89 17       	cp	r24, r25
    15e2:	28 f4       	brcc	.+10     	; 0x15ee <vTaskPriorityInherit+0xb6>
    15e4:	e9 81       	ldd	r30, Y+1	; 0x01
    15e6:	fa 81       	ldd	r31, Y+2	; 0x02
    15e8:	86 89       	ldd	r24, Z+22	; 0x16
    15ea:	80 93 2c 02 	sts	0x022C, r24
    15ee:	e9 81       	ldd	r30, Y+1	; 0x01
    15f0:	fa 81       	ldd	r31, Y+2	; 0x02
    15f2:	86 89       	ldd	r24, Z+22	; 0x16
    15f4:	28 2f       	mov	r18, r24
    15f6:	30 e0       	ldi	r19, 0x00	; 0
    15f8:	c9 01       	movw	r24, r18
    15fa:	88 0f       	add	r24, r24
    15fc:	99 1f       	adc	r25, r25
    15fe:	88 0f       	add	r24, r24
    1600:	99 1f       	adc	r25, r25
    1602:	88 0f       	add	r24, r24
    1604:	99 1f       	adc	r25, r25
    1606:	82 0f       	add	r24, r18
    1608:	93 1f       	adc	r25, r19
    160a:	ac 01       	movw	r20, r24
    160c:	4d 5c       	subi	r20, 0xCD	; 205
    160e:	5d 4f       	sbci	r21, 0xFD	; 253
    1610:	89 81       	ldd	r24, Y+1	; 0x01
    1612:	9a 81       	ldd	r25, Y+2	; 0x02
    1614:	9c 01       	movw	r18, r24
    1616:	2e 5f       	subi	r18, 0xFE	; 254
    1618:	3f 4f       	sbci	r19, 0xFF	; 255
    161a:	ca 01       	movw	r24, r20
    161c:	b9 01       	movw	r22, r18
    161e:	0e 94 ee 10 	call	0x21dc	; 0x21dc <vListInsertEnd>
    1622:	08 c0       	rjmp	.+16     	; 0x1634 <vTaskPriorityInherit+0xfc>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    1624:	e0 91 26 02 	lds	r30, 0x0226
    1628:	f0 91 27 02 	lds	r31, 0x0227
    162c:	86 89       	ldd	r24, Z+22	; 0x16
    162e:	e9 81       	ldd	r30, Y+1	; 0x01
    1630:	fa 81       	ldd	r31, Y+2	; 0x02
    1632:	86 8b       	std	Z+22, r24	; 0x16
				}

				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
			}
		}
	}
    1634:	0f 90       	pop	r0
    1636:	0f 90       	pop	r0
    1638:	0f 90       	pop	r0
    163a:	0f 90       	pop	r0
    163c:	cf 91       	pop	r28
    163e:	df 91       	pop	r29
    1640:	08 95       	ret

00001642 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    1642:	df 93       	push	r29
    1644:	cf 93       	push	r28
    1646:	00 d0       	rcall	.+0      	; 0x1648 <vTaskPriorityDisinherit+0x6>
    1648:	0f 92       	push	r0
    164a:	cd b7       	in	r28, 0x3d	; 61
    164c:	de b7       	in	r29, 0x3e	; 62
    164e:	9c 83       	std	Y+4, r25	; 0x04
    1650:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
    1652:	8b 81       	ldd	r24, Y+3	; 0x03
    1654:	9c 81       	ldd	r25, Y+4	; 0x04
    1656:	9a 83       	std	Y+2, r25	; 0x02
    1658:	89 83       	std	Y+1, r24	; 0x01

		if( pxMutexHolder != NULL )
    165a:	8b 81       	ldd	r24, Y+3	; 0x03
    165c:	9c 81       	ldd	r25, Y+4	; 0x04
    165e:	00 97       	sbiw	r24, 0x00	; 0
    1660:	09 f4       	brne	.+2      	; 0x1664 <vTaskPriorityDisinherit+0x22>
    1662:	47 c0       	rjmp	.+142    	; 0x16f2 <vTaskPriorityDisinherit+0xb0>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    1664:	e9 81       	ldd	r30, Y+1	; 0x01
    1666:	fa 81       	ldd	r31, Y+2	; 0x02
    1668:	96 89       	ldd	r25, Z+22	; 0x16
    166a:	e9 81       	ldd	r30, Y+1	; 0x01
    166c:	fa 81       	ldd	r31, Y+2	; 0x02
    166e:	81 a5       	ldd	r24, Z+41	; 0x29
    1670:	98 17       	cp	r25, r24
    1672:	09 f4       	brne	.+2      	; 0x1676 <vTaskPriorityDisinherit+0x34>
    1674:	3e c0       	rjmp	.+124    	; 0x16f2 <vTaskPriorityDisinherit+0xb0>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    1676:	89 81       	ldd	r24, Y+1	; 0x01
    1678:	9a 81       	ldd	r25, Y+2	; 0x02
    167a:	02 96       	adiw	r24, 0x02	; 2
    167c:	0e 94 a5 11 	call	0x234a	; 0x234a <uxListRemove>
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    1680:	e9 81       	ldd	r30, Y+1	; 0x01
    1682:	fa 81       	ldd	r31, Y+2	; 0x02
    1684:	81 a5       	ldd	r24, Z+41	; 0x29
    1686:	e9 81       	ldd	r30, Y+1	; 0x01
    1688:	fa 81       	ldd	r31, Y+2	; 0x02
    168a:	86 8b       	std	Z+22, r24	; 0x16
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    168c:	e9 81       	ldd	r30, Y+1	; 0x01
    168e:	fa 81       	ldd	r31, Y+2	; 0x02
    1690:	86 89       	ldd	r24, Z+22	; 0x16
    1692:	28 2f       	mov	r18, r24
    1694:	30 e0       	ldi	r19, 0x00	; 0
    1696:	84 e0       	ldi	r24, 0x04	; 4
    1698:	90 e0       	ldi	r25, 0x00	; 0
    169a:	82 1b       	sub	r24, r18
    169c:	93 0b       	sbc	r25, r19
    169e:	e9 81       	ldd	r30, Y+1	; 0x01
    16a0:	fa 81       	ldd	r31, Y+2	; 0x02
    16a2:	95 87       	std	Z+13, r25	; 0x0d
    16a4:	84 87       	std	Z+12, r24	; 0x0c
				prvAddTaskToReadyQueue( pxTCB );
    16a6:	e9 81       	ldd	r30, Y+1	; 0x01
    16a8:	fa 81       	ldd	r31, Y+2	; 0x02
    16aa:	96 89       	ldd	r25, Z+22	; 0x16
    16ac:	80 91 2c 02 	lds	r24, 0x022C
    16b0:	89 17       	cp	r24, r25
    16b2:	28 f4       	brcc	.+10     	; 0x16be <vTaskPriorityDisinherit+0x7c>
    16b4:	e9 81       	ldd	r30, Y+1	; 0x01
    16b6:	fa 81       	ldd	r31, Y+2	; 0x02
    16b8:	86 89       	ldd	r24, Z+22	; 0x16
    16ba:	80 93 2c 02 	sts	0x022C, r24
    16be:	e9 81       	ldd	r30, Y+1	; 0x01
    16c0:	fa 81       	ldd	r31, Y+2	; 0x02
    16c2:	86 89       	ldd	r24, Z+22	; 0x16
    16c4:	28 2f       	mov	r18, r24
    16c6:	30 e0       	ldi	r19, 0x00	; 0
    16c8:	c9 01       	movw	r24, r18
    16ca:	88 0f       	add	r24, r24
    16cc:	99 1f       	adc	r25, r25
    16ce:	88 0f       	add	r24, r24
    16d0:	99 1f       	adc	r25, r25
    16d2:	88 0f       	add	r24, r24
    16d4:	99 1f       	adc	r25, r25
    16d6:	82 0f       	add	r24, r18
    16d8:	93 1f       	adc	r25, r19
    16da:	ac 01       	movw	r20, r24
    16dc:	4d 5c       	subi	r20, 0xCD	; 205
    16de:	5d 4f       	sbci	r21, 0xFD	; 253
    16e0:	89 81       	ldd	r24, Y+1	; 0x01
    16e2:	9a 81       	ldd	r25, Y+2	; 0x02
    16e4:	9c 01       	movw	r18, r24
    16e6:	2e 5f       	subi	r18, 0xFE	; 254
    16e8:	3f 4f       	sbci	r19, 0xFF	; 255
    16ea:	ca 01       	movw	r24, r20
    16ec:	b9 01       	movw	r22, r18
    16ee:	0e 94 ee 10 	call	0x21dc	; 0x21dc <vListInsertEnd>
			}
		}
	}
    16f2:	0f 90       	pop	r0
    16f4:	0f 90       	pop	r0
    16f6:	0f 90       	pop	r0
    16f8:	0f 90       	pop	r0
    16fa:	cf 91       	pop	r28
    16fc:	df 91       	pop	r29
    16fe:	08 95       	ret

00001700 <xQueueGenericReset>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle pxQueue, portBASE_TYPE xNewQueue )
{
    1700:	df 93       	push	r29
    1702:	cf 93       	push	r28
    1704:	00 d0       	rcall	.+0      	; 0x1706 <xQueueGenericReset+0x6>
    1706:	cd b7       	in	r28, 0x3d	; 61
    1708:	de b7       	in	r29, 0x3e	; 62
    170a:	9a 83       	std	Y+2, r25	; 0x02
    170c:	89 83       	std	Y+1, r24	; 0x01
    170e:	6b 83       	std	Y+3, r22	; 0x03
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1710:	0f b6       	in	r0, 0x3f	; 63
    1712:	f8 94       	cli
    1714:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1716:	e9 81       	ldd	r30, Y+1	; 0x01
    1718:	fa 81       	ldd	r31, Y+2	; 0x02
    171a:	40 81       	ld	r20, Z
    171c:	51 81       	ldd	r21, Z+1	; 0x01
    171e:	e9 81       	ldd	r30, Y+1	; 0x01
    1720:	fa 81       	ldd	r31, Y+2	; 0x02
    1722:	83 8d       	ldd	r24, Z+27	; 0x1b
    1724:	28 2f       	mov	r18, r24
    1726:	30 e0       	ldi	r19, 0x00	; 0
    1728:	e9 81       	ldd	r30, Y+1	; 0x01
    172a:	fa 81       	ldd	r31, Y+2	; 0x02
    172c:	84 8d       	ldd	r24, Z+28	; 0x1c
    172e:	88 2f       	mov	r24, r24
    1730:	90 e0       	ldi	r25, 0x00	; 0
    1732:	bc 01       	movw	r22, r24
    1734:	26 9f       	mul	r18, r22
    1736:	c0 01       	movw	r24, r0
    1738:	27 9f       	mul	r18, r23
    173a:	90 0d       	add	r25, r0
    173c:	36 9f       	mul	r19, r22
    173e:	90 0d       	add	r25, r0
    1740:	11 24       	eor	r1, r1
    1742:	84 0f       	add	r24, r20
    1744:	95 1f       	adc	r25, r21
    1746:	e9 81       	ldd	r30, Y+1	; 0x01
    1748:	fa 81       	ldd	r31, Y+2	; 0x02
    174a:	93 83       	std	Z+3, r25	; 0x03
    174c:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    174e:	e9 81       	ldd	r30, Y+1	; 0x01
    1750:	fa 81       	ldd	r31, Y+2	; 0x02
    1752:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1754:	e9 81       	ldd	r30, Y+1	; 0x01
    1756:	fa 81       	ldd	r31, Y+2	; 0x02
    1758:	80 81       	ld	r24, Z
    175a:	91 81       	ldd	r25, Z+1	; 0x01
    175c:	e9 81       	ldd	r30, Y+1	; 0x01
    175e:	fa 81       	ldd	r31, Y+2	; 0x02
    1760:	95 83       	std	Z+5, r25	; 0x05
    1762:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
    1764:	e9 81       	ldd	r30, Y+1	; 0x01
    1766:	fa 81       	ldd	r31, Y+2	; 0x02
    1768:	40 81       	ld	r20, Z
    176a:	51 81       	ldd	r21, Z+1	; 0x01
    176c:	e9 81       	ldd	r30, Y+1	; 0x01
    176e:	fa 81       	ldd	r31, Y+2	; 0x02
    1770:	83 8d       	ldd	r24, Z+27	; 0x1b
    1772:	88 2f       	mov	r24, r24
    1774:	90 e0       	ldi	r25, 0x00	; 0
    1776:	9c 01       	movw	r18, r24
    1778:	21 50       	subi	r18, 0x01	; 1
    177a:	30 40       	sbci	r19, 0x00	; 0
    177c:	e9 81       	ldd	r30, Y+1	; 0x01
    177e:	fa 81       	ldd	r31, Y+2	; 0x02
    1780:	84 8d       	ldd	r24, Z+28	; 0x1c
    1782:	88 2f       	mov	r24, r24
    1784:	90 e0       	ldi	r25, 0x00	; 0
    1786:	bc 01       	movw	r22, r24
    1788:	26 9f       	mul	r18, r22
    178a:	c0 01       	movw	r24, r0
    178c:	27 9f       	mul	r18, r23
    178e:	90 0d       	add	r25, r0
    1790:	36 9f       	mul	r19, r22
    1792:	90 0d       	add	r25, r0
    1794:	11 24       	eor	r1, r1
    1796:	84 0f       	add	r24, r20
    1798:	95 1f       	adc	r25, r21
    179a:	e9 81       	ldd	r30, Y+1	; 0x01
    179c:	fa 81       	ldd	r31, Y+2	; 0x02
    179e:	97 83       	std	Z+7, r25	; 0x07
    17a0:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    17a2:	e9 81       	ldd	r30, Y+1	; 0x01
    17a4:	fa 81       	ldd	r31, Y+2	; 0x02
    17a6:	8f ef       	ldi	r24, 0xFF	; 255
    17a8:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    17aa:	e9 81       	ldd	r30, Y+1	; 0x01
    17ac:	fa 81       	ldd	r31, Y+2	; 0x02
    17ae:	8f ef       	ldi	r24, 0xFF	; 255
    17b0:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    17b2:	8b 81       	ldd	r24, Y+3	; 0x03
    17b4:	88 23       	and	r24, r24
    17b6:	79 f4       	brne	.+30     	; 0x17d6 <xQueueGenericReset+0xd6>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to	write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    17b8:	e9 81       	ldd	r30, Y+1	; 0x01
    17ba:	fa 81       	ldd	r31, Y+2	; 0x02
    17bc:	80 85       	ldd	r24, Z+8	; 0x08
    17be:	88 23       	and	r24, r24
    17c0:	a1 f0       	breq	.+40     	; 0x17ea <xQueueGenericReset+0xea>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    17c2:	89 81       	ldd	r24, Y+1	; 0x01
    17c4:	9a 81       	ldd	r25, Y+2	; 0x02
    17c6:	08 96       	adiw	r24, 0x08	; 8
    17c8:	0e 94 f5 07 	call	0xfea	; 0xfea <xTaskRemoveFromEventList>
    17cc:	81 30       	cpi	r24, 0x01	; 1
    17ce:	69 f4       	brne	.+26     	; 0x17ea <xQueueGenericReset+0xea>
				{
					portYIELD_WITHIN_API();
    17d0:	0e 94 12 17 	call	0x2e24	; 0x2e24 <vPortYield>
    17d4:	0a c0       	rjmp	.+20     	; 0x17ea <xQueueGenericReset+0xea>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    17d6:	89 81       	ldd	r24, Y+1	; 0x01
    17d8:	9a 81       	ldd	r25, Y+2	; 0x02
    17da:	08 96       	adiw	r24, 0x08	; 8
    17dc:	0e 94 b2 10 	call	0x2164	; 0x2164 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    17e0:	89 81       	ldd	r24, Y+1	; 0x01
    17e2:	9a 81       	ldd	r25, Y+2	; 0x02
    17e4:	41 96       	adiw	r24, 0x11	; 17
    17e6:	0e 94 b2 10 	call	0x2164	; 0x2164 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    17ea:	0f 90       	pop	r0
    17ec:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    17ee:	81 e0       	ldi	r24, 0x01	; 1
}
    17f0:	0f 90       	pop	r0
    17f2:	0f 90       	pop	r0
    17f4:	0f 90       	pop	r0
    17f6:	cf 91       	pop	r28
    17f8:	df 91       	pop	r29
    17fa:	08 95       	ret

000017fc <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
    17fc:	df 93       	push	r29
    17fe:	cf 93       	push	r28
    1800:	cd b7       	in	r28, 0x3d	; 61
    1802:	de b7       	in	r29, 0x3e	; 62
    1804:	29 97       	sbiw	r28, 0x09	; 9
    1806:	0f b6       	in	r0, 0x3f	; 63
    1808:	f8 94       	cli
    180a:	de bf       	out	0x3e, r29	; 62
    180c:	0f be       	out	0x3f, r0	; 63
    180e:	cd bf       	out	0x3d, r28	; 61
    1810:	8f 83       	std	Y+7, r24	; 0x07
    1812:	68 87       	std	Y+8, r22	; 0x08
    1814:	49 87       	std	Y+9, r20	; 0x09
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    1816:	1a 82       	std	Y+2, r1	; 0x02
    1818:	19 82       	std	Y+1, r1	; 0x01
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    181a:	8f 81       	ldd	r24, Y+7	; 0x07
    181c:	88 23       	and	r24, r24
    181e:	09 f4       	brne	.+2      	; 0x1822 <xQueueGenericCreate+0x26>
    1820:	3f c0       	rjmp	.+126    	; 0x18a0 <xQueueGenericCreate+0xa4>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    1822:	8f e1       	ldi	r24, 0x1F	; 31
    1824:	90 e0       	ldi	r25, 0x00	; 0
    1826:	0e 94 ca 14 	call	0x2994	; 0x2994 <pvPortMalloc>
    182a:	9e 83       	std	Y+6, r25	; 0x06
    182c:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    182e:	8d 81       	ldd	r24, Y+5	; 0x05
    1830:	9e 81       	ldd	r25, Y+6	; 0x06
    1832:	00 97       	sbiw	r24, 0x00	; 0
    1834:	a9 f1       	breq	.+106    	; 0x18a0 <xQueueGenericCreate+0xa4>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    1836:	8f 81       	ldd	r24, Y+7	; 0x07
    1838:	28 2f       	mov	r18, r24
    183a:	30 e0       	ldi	r19, 0x00	; 0
    183c:	88 85       	ldd	r24, Y+8	; 0x08
    183e:	88 2f       	mov	r24, r24
    1840:	90 e0       	ldi	r25, 0x00	; 0
    1842:	ac 01       	movw	r20, r24
    1844:	24 9f       	mul	r18, r20
    1846:	c0 01       	movw	r24, r0
    1848:	25 9f       	mul	r18, r21
    184a:	90 0d       	add	r25, r0
    184c:	34 9f       	mul	r19, r20
    184e:	90 0d       	add	r25, r0
    1850:	11 24       	eor	r1, r1
    1852:	01 96       	adiw	r24, 0x01	; 1
    1854:	9c 83       	std	Y+4, r25	; 0x04
    1856:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    1858:	8b 81       	ldd	r24, Y+3	; 0x03
    185a:	9c 81       	ldd	r25, Y+4	; 0x04
    185c:	0e 94 ca 14 	call	0x2994	; 0x2994 <pvPortMalloc>
    1860:	ed 81       	ldd	r30, Y+5	; 0x05
    1862:	fe 81       	ldd	r31, Y+6	; 0x06
    1864:	91 83       	std	Z+1, r25	; 0x01
    1866:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    1868:	ed 81       	ldd	r30, Y+5	; 0x05
    186a:	fe 81       	ldd	r31, Y+6	; 0x06
    186c:	80 81       	ld	r24, Z
    186e:	91 81       	ldd	r25, Z+1	; 0x01
    1870:	00 97       	sbiw	r24, 0x00	; 0
    1872:	91 f0       	breq	.+36     	; 0x1898 <xQueueGenericCreate+0x9c>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    1874:	ed 81       	ldd	r30, Y+5	; 0x05
    1876:	fe 81       	ldd	r31, Y+6	; 0x06
    1878:	8f 81       	ldd	r24, Y+7	; 0x07
    187a:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    187c:	ed 81       	ldd	r30, Y+5	; 0x05
    187e:	fe 81       	ldd	r31, Y+6	; 0x06
    1880:	88 85       	ldd	r24, Y+8	; 0x08
    1882:	84 8f       	std	Z+28, r24	; 0x1c
				xQueueGenericReset( pxNewQueue, pdTRUE );
    1884:	8d 81       	ldd	r24, Y+5	; 0x05
    1886:	9e 81       	ldd	r25, Y+6	; 0x06
    1888:	61 e0       	ldi	r22, 0x01	; 1
    188a:	0e 94 80 0b 	call	0x1700	; 0x1700 <xQueueGenericReset>
					pxNewQueue->ucQueueType = ucQueueType;
				}
				#endif /* configUSE_TRACE_FACILITY */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    188e:	8d 81       	ldd	r24, Y+5	; 0x05
    1890:	9e 81       	ldd	r25, Y+6	; 0x06
    1892:	9a 83       	std	Y+2, r25	; 0x02
    1894:	89 83       	std	Y+1, r24	; 0x01
    1896:	04 c0       	rjmp	.+8      	; 0x18a0 <xQueueGenericCreate+0xa4>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    1898:	8d 81       	ldd	r24, Y+5	; 0x05
    189a:	9e 81       	ldd	r25, Y+6	; 0x06
    189c:	0e 94 10 15 	call	0x2a20	; 0x2a20 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    18a0:	89 81       	ldd	r24, Y+1	; 0x01
    18a2:	9a 81       	ldd	r25, Y+2	; 0x02
}
    18a4:	29 96       	adiw	r28, 0x09	; 9
    18a6:	0f b6       	in	r0, 0x3f	; 63
    18a8:	f8 94       	cli
    18aa:	de bf       	out	0x3e, r29	; 62
    18ac:	0f be       	out	0x3f, r0	; 63
    18ae:	cd bf       	out	0x3d, r28	; 61
    18b0:	cf 91       	pop	r28
    18b2:	df 91       	pop	r29
    18b4:	08 95       	ret

000018b6 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
	{
    18b6:	df 93       	push	r29
    18b8:	cf 93       	push	r28
    18ba:	00 d0       	rcall	.+0      	; 0x18bc <xQueueCreateMutex+0x6>
    18bc:	cd b7       	in	r28, 0x3d	; 61
    18be:	de b7       	in	r29, 0x3e	; 62
    18c0:	8b 83       	std	Y+3, r24	; 0x03
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    18c2:	8f e1       	ldi	r24, 0x1F	; 31
    18c4:	90 e0       	ldi	r25, 0x00	; 0
    18c6:	0e 94 ca 14 	call	0x2994	; 0x2994 <pvPortMalloc>
    18ca:	9a 83       	std	Y+2, r25	; 0x02
    18cc:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    18ce:	89 81       	ldd	r24, Y+1	; 0x01
    18d0:	9a 81       	ldd	r25, Y+2	; 0x02
    18d2:	00 97       	sbiw	r24, 0x00	; 0
    18d4:	a9 f1       	breq	.+106    	; 0x1940 <xQueueCreateMutex+0x8a>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    18d6:	e9 81       	ldd	r30, Y+1	; 0x01
    18d8:	fa 81       	ldd	r31, Y+2	; 0x02
    18da:	13 82       	std	Z+3, r1	; 0x03
    18dc:	12 82       	std	Z+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    18de:	e9 81       	ldd	r30, Y+1	; 0x01
    18e0:	fa 81       	ldd	r31, Y+2	; 0x02
    18e2:	11 82       	std	Z+1, r1	; 0x01
    18e4:	10 82       	st	Z, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    18e6:	e9 81       	ldd	r30, Y+1	; 0x01
    18e8:	fa 81       	ldd	r31, Y+2	; 0x02
    18ea:	15 82       	std	Z+5, r1	; 0x05
    18ec:	14 82       	std	Z+4, r1	; 0x04
			pxNewQueue->pcReadFrom = NULL;
    18ee:	e9 81       	ldd	r30, Y+1	; 0x01
    18f0:	fa 81       	ldd	r31, Y+2	; 0x02
    18f2:	17 82       	std	Z+7, r1	; 0x07
    18f4:	16 82       	std	Z+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    18f6:	e9 81       	ldd	r30, Y+1	; 0x01
    18f8:	fa 81       	ldd	r31, Y+2	; 0x02
    18fa:	12 8e       	std	Z+26, r1	; 0x1a
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
    18fc:	e9 81       	ldd	r30, Y+1	; 0x01
    18fe:	fa 81       	ldd	r31, Y+2	; 0x02
    1900:	81 e0       	ldi	r24, 0x01	; 1
    1902:	83 8f       	std	Z+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
    1904:	e9 81       	ldd	r30, Y+1	; 0x01
    1906:	fa 81       	ldd	r31, Y+2	; 0x02
    1908:	14 8e       	std	Z+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    190a:	e9 81       	ldd	r30, Y+1	; 0x01
    190c:	fa 81       	ldd	r31, Y+2	; 0x02
    190e:	8f ef       	ldi	r24, 0xFF	; 255
    1910:	85 8f       	std	Z+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    1912:	e9 81       	ldd	r30, Y+1	; 0x01
    1914:	fa 81       	ldd	r31, Y+2	; 0x02
    1916:	8f ef       	ldi	r24, 0xFF	; 255
    1918:	86 8f       	std	Z+30, r24	; 0x1e
				pxNewQueue->ucQueueType = ucQueueType;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    191a:	89 81       	ldd	r24, Y+1	; 0x01
    191c:	9a 81       	ldd	r25, Y+2	; 0x02
    191e:	08 96       	adiw	r24, 0x08	; 8
    1920:	0e 94 b2 10 	call	0x2164	; 0x2164 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1924:	89 81       	ldd	r24, Y+1	; 0x01
    1926:	9a 81       	ldd	r25, Y+2	; 0x02
    1928:	41 96       	adiw	r24, 0x11	; 17
    192a:	0e 94 b2 10 	call	0x2164	; 0x2164 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
    192e:	89 81       	ldd	r24, Y+1	; 0x01
    1930:	9a 81       	ldd	r25, Y+2	; 0x02
    1932:	60 e0       	ldi	r22, 0x00	; 0
    1934:	70 e0       	ldi	r23, 0x00	; 0
    1936:	40 e0       	ldi	r20, 0x00	; 0
    1938:	50 e0       	ldi	r21, 0x00	; 0
    193a:	20 e0       	ldi	r18, 0x00	; 0
    193c:	0e 94 a8 0c 	call	0x1950	; 0x1950 <xQueueGenericSend>
		{
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
    1940:	89 81       	ldd	r24, Y+1	; 0x01
    1942:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    1944:	0f 90       	pop	r0
    1946:	0f 90       	pop	r0
    1948:	0f 90       	pop	r0
    194a:	cf 91       	pop	r28
    194c:	df 91       	pop	r29
    194e:	08 95       	ret

00001950 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    1950:	df 93       	push	r29
    1952:	cf 93       	push	r28
    1954:	cd b7       	in	r28, 0x3d	; 61
    1956:	de b7       	in	r29, 0x3e	; 62
    1958:	2c 97       	sbiw	r28, 0x0c	; 12
    195a:	0f b6       	in	r0, 0x3f	; 63
    195c:	f8 94       	cli
    195e:	de bf       	out	0x3e, r29	; 62
    1960:	0f be       	out	0x3f, r0	; 63
    1962:	cd bf       	out	0x3d, r28	; 61
    1964:	9e 83       	std	Y+6, r25	; 0x06
    1966:	8d 83       	std	Y+5, r24	; 0x05
    1968:	78 87       	std	Y+8, r23	; 0x08
    196a:	6f 83       	std	Y+7, r22	; 0x07
    196c:	5a 87       	std	Y+10, r21	; 0x0a
    196e:	49 87       	std	Y+9, r20	; 0x09
    1970:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1972:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1974:	0f b6       	in	r0, 0x3f	; 63
    1976:	f8 94       	cli
    1978:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    197a:	ed 81       	ldd	r30, Y+5	; 0x05
    197c:	fe 81       	ldd	r31, Y+6	; 0x06
    197e:	92 8d       	ldd	r25, Z+26	; 0x1a
    1980:	ed 81       	ldd	r30, Y+5	; 0x05
    1982:	fe 81       	ldd	r31, Y+6	; 0x06
    1984:	83 8d       	ldd	r24, Z+27	; 0x1b
    1986:	98 17       	cp	r25, r24
    1988:	d8 f4       	brcc	.+54     	; 0x19c0 <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    198a:	8d 81       	ldd	r24, Y+5	; 0x05
    198c:	9e 81       	ldd	r25, Y+6	; 0x06
    198e:	2f 81       	ldd	r18, Y+7	; 0x07
    1990:	38 85       	ldd	r19, Y+8	; 0x08
    1992:	b9 01       	movw	r22, r18
    1994:	4b 85       	ldd	r20, Y+11	; 0x0b
    1996:	0e 94 07 0f 	call	0x1e0e	; 0x1e0e <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    199a:	ed 81       	ldd	r30, Y+5	; 0x05
    199c:	fe 81       	ldd	r31, Y+6	; 0x06
    199e:	81 89       	ldd	r24, Z+17	; 0x11
    19a0:	88 23       	and	r24, r24
    19a2:	49 f0       	breq	.+18     	; 0x19b6 <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    19a4:	8d 81       	ldd	r24, Y+5	; 0x05
    19a6:	9e 81       	ldd	r25, Y+6	; 0x06
    19a8:	41 96       	adiw	r24, 0x11	; 17
    19aa:	0e 94 f5 07 	call	0xfea	; 0xfea <xTaskRemoveFromEventList>
    19ae:	81 30       	cpi	r24, 0x01	; 1
    19b0:	11 f4       	brne	.+4      	; 0x19b6 <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    19b2:	0e 94 12 17 	call	0x2e24	; 0x2e24 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    19b6:	0f 90       	pop	r0
    19b8:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    19ba:	81 e0       	ldi	r24, 0x01	; 1
    19bc:	8c 87       	std	Y+12, r24	; 0x0c
    19be:	5c c0       	rjmp	.+184    	; 0x1a78 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    19c0:	89 85       	ldd	r24, Y+9	; 0x09
    19c2:	9a 85       	ldd	r25, Y+10	; 0x0a
    19c4:	00 97       	sbiw	r24, 0x00	; 0
    19c6:	21 f4       	brne	.+8      	; 0x19d0 <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    19c8:	0f 90       	pop	r0
    19ca:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    19cc:	1c 86       	std	Y+12, r1	; 0x0c
    19ce:	54 c0       	rjmp	.+168    	; 0x1a78 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    19d0:	89 81       	ldd	r24, Y+1	; 0x01
    19d2:	88 23       	and	r24, r24
    19d4:	31 f4       	brne	.+12     	; 0x19e2 <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    19d6:	ce 01       	movw	r24, r28
    19d8:	02 96       	adiw	r24, 0x02	; 2
    19da:	0e 94 5d 08 	call	0x10ba	; 0x10ba <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    19de:	81 e0       	ldi	r24, 0x01	; 1
    19e0:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    19e2:	0f 90       	pop	r0
    19e4:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    19e6:	0e 94 8b 05 	call	0xb16	; 0xb16 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    19ea:	0f b6       	in	r0, 0x3f	; 63
    19ec:	f8 94       	cli
    19ee:	0f 92       	push	r0
    19f0:	ed 81       	ldd	r30, Y+5	; 0x05
    19f2:	fe 81       	ldd	r31, Y+6	; 0x06
    19f4:	85 8d       	ldd	r24, Z+29	; 0x1d
    19f6:	8f 3f       	cpi	r24, 0xFF	; 255
    19f8:	19 f4       	brne	.+6      	; 0x1a00 <xQueueGenericSend+0xb0>
    19fa:	ed 81       	ldd	r30, Y+5	; 0x05
    19fc:	fe 81       	ldd	r31, Y+6	; 0x06
    19fe:	15 8e       	std	Z+29, r1	; 0x1d
    1a00:	ed 81       	ldd	r30, Y+5	; 0x05
    1a02:	fe 81       	ldd	r31, Y+6	; 0x06
    1a04:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a06:	8f 3f       	cpi	r24, 0xFF	; 255
    1a08:	19 f4       	brne	.+6      	; 0x1a10 <xQueueGenericSend+0xc0>
    1a0a:	ed 81       	ldd	r30, Y+5	; 0x05
    1a0c:	fe 81       	ldd	r31, Y+6	; 0x06
    1a0e:	16 8e       	std	Z+30, r1	; 0x1e
    1a10:	0f 90       	pop	r0
    1a12:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1a14:	ce 01       	movw	r24, r28
    1a16:	02 96       	adiw	r24, 0x02	; 2
    1a18:	9e 01       	movw	r18, r28
    1a1a:	27 5f       	subi	r18, 0xF7	; 247
    1a1c:	3f 4f       	sbci	r19, 0xFF	; 255
    1a1e:	b9 01       	movw	r22, r18
    1a20:	0e 94 77 08 	call	0x10ee	; 0x10ee <xTaskCheckForTimeOut>
    1a24:	88 23       	and	r24, r24
    1a26:	09 f5       	brne	.+66     	; 0x1a6a <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1a28:	8d 81       	ldd	r24, Y+5	; 0x05
    1a2a:	9e 81       	ldd	r25, Y+6	; 0x06
    1a2c:	0e 94 7b 10 	call	0x20f6	; 0x20f6 <prvIsQueueFull>
    1a30:	88 23       	and	r24, r24
    1a32:	a1 f0       	breq	.+40     	; 0x1a5c <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1a34:	8d 81       	ldd	r24, Y+5	; 0x05
    1a36:	9e 81       	ldd	r25, Y+6	; 0x06
    1a38:	08 96       	adiw	r24, 0x08	; 8
    1a3a:	29 85       	ldd	r18, Y+9	; 0x09
    1a3c:	3a 85       	ldd	r19, Y+10	; 0x0a
    1a3e:	b9 01       	movw	r22, r18
    1a40:	0e 94 ad 07 	call	0xf5a	; 0xf5a <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1a44:	8d 81       	ldd	r24, Y+5	; 0x05
    1a46:	9e 81       	ldd	r25, Y+6	; 0x06
    1a48:	0e 94 f5 0f 	call	0x1fea	; 0x1fea <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1a4c:	0e 94 97 05 	call	0xb2e	; 0xb2e <xTaskResumeAll>
    1a50:	88 23       	and	r24, r24
    1a52:	09 f0       	breq	.+2      	; 0x1a56 <xQueueGenericSend+0x106>
    1a54:	8f cf       	rjmp	.-226    	; 0x1974 <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    1a56:	0e 94 12 17 	call	0x2e24	; 0x2e24 <vPortYield>
    1a5a:	8c cf       	rjmp	.-232    	; 0x1974 <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1a5c:	8d 81       	ldd	r24, Y+5	; 0x05
    1a5e:	9e 81       	ldd	r25, Y+6	; 0x06
    1a60:	0e 94 f5 0f 	call	0x1fea	; 0x1fea <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1a64:	0e 94 97 05 	call	0xb2e	; 0xb2e <xTaskResumeAll>
    1a68:	85 cf       	rjmp	.-246    	; 0x1974 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1a6a:	8d 81       	ldd	r24, Y+5	; 0x05
    1a6c:	9e 81       	ldd	r25, Y+6	; 0x06
    1a6e:	0e 94 f5 0f 	call	0x1fea	; 0x1fea <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1a72:	0e 94 97 05 	call	0xb2e	; 0xb2e <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1a76:	1c 86       	std	Y+12, r1	; 0x0c
    1a78:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    1a7a:	2c 96       	adiw	r28, 0x0c	; 12
    1a7c:	0f b6       	in	r0, 0x3f	; 63
    1a7e:	f8 94       	cli
    1a80:	de bf       	out	0x3e, r29	; 62
    1a82:	0f be       	out	0x3f, r0	; 63
    1a84:	cd bf       	out	0x3d, r28	; 61
    1a86:	cf 91       	pop	r28
    1a88:	df 91       	pop	r29
    1a8a:	08 95       	ret

00001a8c <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1a8c:	df 93       	push	r29
    1a8e:	cf 93       	push	r28
    1a90:	cd b7       	in	r28, 0x3d	; 61
    1a92:	de b7       	in	r29, 0x3e	; 62
    1a94:	29 97       	sbiw	r28, 0x09	; 9
    1a96:	0f b6       	in	r0, 0x3f	; 63
    1a98:	f8 94       	cli
    1a9a:	de bf       	out	0x3e, r29	; 62
    1a9c:	0f be       	out	0x3f, r0	; 63
    1a9e:	cd bf       	out	0x3d, r28	; 61
    1aa0:	9c 83       	std	Y+4, r25	; 0x04
    1aa2:	8b 83       	std	Y+3, r24	; 0x03
    1aa4:	7e 83       	std	Y+6, r23	; 0x06
    1aa6:	6d 83       	std	Y+5, r22	; 0x05
    1aa8:	58 87       	std	Y+8, r21	; 0x08
    1aaa:	4f 83       	std	Y+7, r20	; 0x07
    1aac:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1aae:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1ab0:	eb 81       	ldd	r30, Y+3	; 0x03
    1ab2:	fc 81       	ldd	r31, Y+4	; 0x04
    1ab4:	92 8d       	ldd	r25, Z+26	; 0x1a
    1ab6:	eb 81       	ldd	r30, Y+3	; 0x03
    1ab8:	fc 81       	ldd	r31, Y+4	; 0x04
    1aba:	83 8d       	ldd	r24, Z+27	; 0x1b
    1abc:	98 17       	cp	r25, r24
    1abe:	60 f5       	brcc	.+88     	; 0x1b18 <xQueueGenericSendFromISR+0x8c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1ac0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ac2:	9c 81       	ldd	r25, Y+4	; 0x04
    1ac4:	2d 81       	ldd	r18, Y+5	; 0x05
    1ac6:	3e 81       	ldd	r19, Y+6	; 0x06
    1ac8:	b9 01       	movw	r22, r18
    1aca:	49 85       	ldd	r20, Y+9	; 0x09
    1acc:	0e 94 07 0f 	call	0x1e0e	; 0x1e0e <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1ad0:	eb 81       	ldd	r30, Y+3	; 0x03
    1ad2:	fc 81       	ldd	r31, Y+4	; 0x04
    1ad4:	86 8d       	ldd	r24, Z+30	; 0x1e
    1ad6:	8f 3f       	cpi	r24, 0xFF	; 255
    1ad8:	a9 f4       	brne	.+42     	; 0x1b04 <xQueueGenericSendFromISR+0x78>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1ada:	eb 81       	ldd	r30, Y+3	; 0x03
    1adc:	fc 81       	ldd	r31, Y+4	; 0x04
    1ade:	81 89       	ldd	r24, Z+17	; 0x11
    1ae0:	88 23       	and	r24, r24
    1ae2:	b9 f0       	breq	.+46     	; 0x1b12 <xQueueGenericSendFromISR+0x86>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1ae4:	8b 81       	ldd	r24, Y+3	; 0x03
    1ae6:	9c 81       	ldd	r25, Y+4	; 0x04
    1ae8:	41 96       	adiw	r24, 0x11	; 17
    1aea:	0e 94 f5 07 	call	0xfea	; 0xfea <xTaskRemoveFromEventList>
    1aee:	88 23       	and	r24, r24
    1af0:	81 f0       	breq	.+32     	; 0x1b12 <xQueueGenericSendFromISR+0x86>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						if( pxHigherPriorityTaskWoken != NULL )
    1af2:	8f 81       	ldd	r24, Y+7	; 0x07
    1af4:	98 85       	ldd	r25, Y+8	; 0x08
    1af6:	00 97       	sbiw	r24, 0x00	; 0
    1af8:	61 f0       	breq	.+24     	; 0x1b12 <xQueueGenericSendFromISR+0x86>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1afa:	ef 81       	ldd	r30, Y+7	; 0x07
    1afc:	f8 85       	ldd	r31, Y+8	; 0x08
    1afe:	81 e0       	ldi	r24, 0x01	; 1
    1b00:	80 83       	st	Z, r24
    1b02:	07 c0       	rjmp	.+14     	; 0x1b12 <xQueueGenericSendFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1b04:	eb 81       	ldd	r30, Y+3	; 0x03
    1b06:	fc 81       	ldd	r31, Y+4	; 0x04
    1b08:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b0a:	8f 5f       	subi	r24, 0xFF	; 255
    1b0c:	eb 81       	ldd	r30, Y+3	; 0x03
    1b0e:	fc 81       	ldd	r31, Y+4	; 0x04
    1b10:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1b12:	81 e0       	ldi	r24, 0x01	; 1
    1b14:	8a 83       	std	Y+2, r24	; 0x02
    1b16:	01 c0       	rjmp	.+2      	; 0x1b1a <xQueueGenericSendFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1b18:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1b1a:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1b1c:	29 96       	adiw	r28, 0x09	; 9
    1b1e:	0f b6       	in	r0, 0x3f	; 63
    1b20:	f8 94       	cli
    1b22:	de bf       	out	0x3e, r29	; 62
    1b24:	0f be       	out	0x3f, r0	; 63
    1b26:	cd bf       	out	0x3d, r28	; 61
    1b28:	cf 91       	pop	r28
    1b2a:	df 91       	pop	r29
    1b2c:	08 95       	ret

00001b2e <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1b2e:	df 93       	push	r29
    1b30:	cf 93       	push	r28
    1b32:	cd b7       	in	r28, 0x3d	; 61
    1b34:	de b7       	in	r29, 0x3e	; 62
    1b36:	2e 97       	sbiw	r28, 0x0e	; 14
    1b38:	0f b6       	in	r0, 0x3f	; 63
    1b3a:	f8 94       	cli
    1b3c:	de bf       	out	0x3e, r29	; 62
    1b3e:	0f be       	out	0x3f, r0	; 63
    1b40:	cd bf       	out	0x3d, r28	; 61
    1b42:	98 87       	std	Y+8, r25	; 0x08
    1b44:	8f 83       	std	Y+7, r24	; 0x07
    1b46:	7a 87       	std	Y+10, r23	; 0x0a
    1b48:	69 87       	std	Y+9, r22	; 0x09
    1b4a:	5c 87       	std	Y+12, r21	; 0x0c
    1b4c:	4b 87       	std	Y+11, r20	; 0x0b
    1b4e:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1b50:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1b52:	0f b6       	in	r0, 0x3f	; 63
    1b54:	f8 94       	cli
    1b56:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1b58:	ef 81       	ldd	r30, Y+7	; 0x07
    1b5a:	f8 85       	ldd	r31, Y+8	; 0x08
    1b5c:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b5e:	88 23       	and	r24, r24
    1b60:	09 f4       	brne	.+2      	; 0x1b64 <xQueueGenericReceive+0x36>
    1b62:	4b c0       	rjmp	.+150    	; 0x1bfa <xQueueGenericReceive+0xcc>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1b64:	ef 81       	ldd	r30, Y+7	; 0x07
    1b66:	f8 85       	ldd	r31, Y+8	; 0x08
    1b68:	86 81       	ldd	r24, Z+6	; 0x06
    1b6a:	97 81       	ldd	r25, Z+7	; 0x07
    1b6c:	9a 83       	std	Y+2, r25	; 0x02
    1b6e:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1b70:	8f 81       	ldd	r24, Y+7	; 0x07
    1b72:	98 85       	ldd	r25, Y+8	; 0x08
    1b74:	29 85       	ldd	r18, Y+9	; 0x09
    1b76:	3a 85       	ldd	r19, Y+10	; 0x0a
    1b78:	b9 01       	movw	r22, r18
    1b7a:	0e 94 ad 0f 	call	0x1f5a	; 0x1f5a <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1b7e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1b80:	88 23       	and	r24, r24
    1b82:	11 f5       	brne	.+68     	; 0x1bc8 <xQueueGenericReceive+0x9a>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1b84:	ef 81       	ldd	r30, Y+7	; 0x07
    1b86:	f8 85       	ldd	r31, Y+8	; 0x08
    1b88:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b8a:	81 50       	subi	r24, 0x01	; 1
    1b8c:	ef 81       	ldd	r30, Y+7	; 0x07
    1b8e:	f8 85       	ldd	r31, Y+8	; 0x08
    1b90:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1b92:	ef 81       	ldd	r30, Y+7	; 0x07
    1b94:	f8 85       	ldd	r31, Y+8	; 0x08
    1b96:	80 81       	ld	r24, Z
    1b98:	91 81       	ldd	r25, Z+1	; 0x01
    1b9a:	00 97       	sbiw	r24, 0x00	; 0
    1b9c:	31 f4       	brne	.+12     	; 0x1baa <xQueueGenericReceive+0x7c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    1b9e:	0e 94 89 0a 	call	0x1512	; 0x1512 <xTaskGetCurrentTaskHandle>
    1ba2:	ef 81       	ldd	r30, Y+7	; 0x07
    1ba4:	f8 85       	ldd	r31, Y+8	; 0x08
    1ba6:	93 83       	std	Z+3, r25	; 0x03
    1ba8:	82 83       	std	Z+2, r24	; 0x02
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1baa:	ef 81       	ldd	r30, Y+7	; 0x07
    1bac:	f8 85       	ldd	r31, Y+8	; 0x08
    1bae:	80 85       	ldd	r24, Z+8	; 0x08
    1bb0:	88 23       	and	r24, r24
    1bb2:	f1 f0       	breq	.+60     	; 0x1bf0 <xQueueGenericReceive+0xc2>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1bb4:	8f 81       	ldd	r24, Y+7	; 0x07
    1bb6:	98 85       	ldd	r25, Y+8	; 0x08
    1bb8:	08 96       	adiw	r24, 0x08	; 8
    1bba:	0e 94 f5 07 	call	0xfea	; 0xfea <xTaskRemoveFromEventList>
    1bbe:	81 30       	cpi	r24, 0x01	; 1
    1bc0:	b9 f4       	brne	.+46     	; 0x1bf0 <xQueueGenericReceive+0xc2>
						{
							portYIELD_WITHIN_API();
    1bc2:	0e 94 12 17 	call	0x2e24	; 0x2e24 <vPortYield>
    1bc6:	14 c0       	rjmp	.+40     	; 0x1bf0 <xQueueGenericReceive+0xc2>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1bc8:	ef 81       	ldd	r30, Y+7	; 0x07
    1bca:	f8 85       	ldd	r31, Y+8	; 0x08
    1bcc:	89 81       	ldd	r24, Y+1	; 0x01
    1bce:	9a 81       	ldd	r25, Y+2	; 0x02
    1bd0:	97 83       	std	Z+7, r25	; 0x07
    1bd2:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1bd4:	ef 81       	ldd	r30, Y+7	; 0x07
    1bd6:	f8 85       	ldd	r31, Y+8	; 0x08
    1bd8:	81 89       	ldd	r24, Z+17	; 0x11
    1bda:	88 23       	and	r24, r24
    1bdc:	49 f0       	breq	.+18     	; 0x1bf0 <xQueueGenericReceive+0xc2>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1bde:	8f 81       	ldd	r24, Y+7	; 0x07
    1be0:	98 85       	ldd	r25, Y+8	; 0x08
    1be2:	41 96       	adiw	r24, 0x11	; 17
    1be4:	0e 94 f5 07 	call	0xfea	; 0xfea <xTaskRemoveFromEventList>
    1be8:	88 23       	and	r24, r24
    1bea:	11 f0       	breq	.+4      	; 0x1bf0 <xQueueGenericReceive+0xc2>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1bec:	0e 94 12 17 	call	0x2e24	; 0x2e24 <vPortYield>
						}
					}
				}

				taskEXIT_CRITICAL();
    1bf0:	0f 90       	pop	r0
    1bf2:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1bf4:	81 e0       	ldi	r24, 0x01	; 1
    1bf6:	8e 87       	std	Y+14, r24	; 0x0e
    1bf8:	6d c0       	rjmp	.+218    	; 0x1cd4 <xQueueGenericReceive+0x1a6>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1bfa:	8b 85       	ldd	r24, Y+11	; 0x0b
    1bfc:	9c 85       	ldd	r25, Y+12	; 0x0c
    1bfe:	00 97       	sbiw	r24, 0x00	; 0
    1c00:	21 f4       	brne	.+8      	; 0x1c0a <xQueueGenericReceive+0xdc>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1c02:	0f 90       	pop	r0
    1c04:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1c06:	1e 86       	std	Y+14, r1	; 0x0e
    1c08:	65 c0       	rjmp	.+202    	; 0x1cd4 <xQueueGenericReceive+0x1a6>
				}
				else if( xEntryTimeSet == pdFALSE )
    1c0a:	8b 81       	ldd	r24, Y+3	; 0x03
    1c0c:	88 23       	and	r24, r24
    1c0e:	31 f4       	brne	.+12     	; 0x1c1c <xQueueGenericReceive+0xee>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1c10:	ce 01       	movw	r24, r28
    1c12:	04 96       	adiw	r24, 0x04	; 4
    1c14:	0e 94 5d 08 	call	0x10ba	; 0x10ba <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1c18:	81 e0       	ldi	r24, 0x01	; 1
    1c1a:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    1c1c:	0f 90       	pop	r0
    1c1e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1c20:	0e 94 8b 05 	call	0xb16	; 0xb16 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1c24:	0f b6       	in	r0, 0x3f	; 63
    1c26:	f8 94       	cli
    1c28:	0f 92       	push	r0
    1c2a:	ef 81       	ldd	r30, Y+7	; 0x07
    1c2c:	f8 85       	ldd	r31, Y+8	; 0x08
    1c2e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c30:	8f 3f       	cpi	r24, 0xFF	; 255
    1c32:	19 f4       	brne	.+6      	; 0x1c3a <xQueueGenericReceive+0x10c>
    1c34:	ef 81       	ldd	r30, Y+7	; 0x07
    1c36:	f8 85       	ldd	r31, Y+8	; 0x08
    1c38:	15 8e       	std	Z+29, r1	; 0x1d
    1c3a:	ef 81       	ldd	r30, Y+7	; 0x07
    1c3c:	f8 85       	ldd	r31, Y+8	; 0x08
    1c3e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c40:	8f 3f       	cpi	r24, 0xFF	; 255
    1c42:	19 f4       	brne	.+6      	; 0x1c4a <xQueueGenericReceive+0x11c>
    1c44:	ef 81       	ldd	r30, Y+7	; 0x07
    1c46:	f8 85       	ldd	r31, Y+8	; 0x08
    1c48:	16 8e       	std	Z+30, r1	; 0x1e
    1c4a:	0f 90       	pop	r0
    1c4c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1c4e:	ce 01       	movw	r24, r28
    1c50:	04 96       	adiw	r24, 0x04	; 4
    1c52:	9e 01       	movw	r18, r28
    1c54:	25 5f       	subi	r18, 0xF5	; 245
    1c56:	3f 4f       	sbci	r19, 0xFF	; 255
    1c58:	b9 01       	movw	r22, r18
    1c5a:	0e 94 77 08 	call	0x10ee	; 0x10ee <xTaskCheckForTimeOut>
    1c5e:	88 23       	and	r24, r24
    1c60:	91 f5       	brne	.+100    	; 0x1cc6 <xQueueGenericReceive+0x198>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1c62:	8f 81       	ldd	r24, Y+7	; 0x07
    1c64:	98 85       	ldd	r25, Y+8	; 0x08
    1c66:	0e 94 4a 10 	call	0x2094	; 0x2094 <prvIsQueueEmpty>
    1c6a:	88 23       	and	r24, r24
    1c6c:	29 f1       	breq	.+74     	; 0x1cb8 <xQueueGenericReceive+0x18a>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1c6e:	ef 81       	ldd	r30, Y+7	; 0x07
    1c70:	f8 85       	ldd	r31, Y+8	; 0x08
    1c72:	80 81       	ld	r24, Z
    1c74:	91 81       	ldd	r25, Z+1	; 0x01
    1c76:	00 97       	sbiw	r24, 0x00	; 0
    1c78:	59 f4       	brne	.+22     	; 0x1c90 <xQueueGenericReceive+0x162>
					{
						portENTER_CRITICAL();
    1c7a:	0f b6       	in	r0, 0x3f	; 63
    1c7c:	f8 94       	cli
    1c7e:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1c80:	ef 81       	ldd	r30, Y+7	; 0x07
    1c82:	f8 85       	ldd	r31, Y+8	; 0x08
    1c84:	82 81       	ldd	r24, Z+2	; 0x02
    1c86:	93 81       	ldd	r25, Z+3	; 0x03
    1c88:	0e 94 9c 0a 	call	0x1538	; 0x1538 <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    1c8c:	0f 90       	pop	r0
    1c8e:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1c90:	8f 81       	ldd	r24, Y+7	; 0x07
    1c92:	98 85       	ldd	r25, Y+8	; 0x08
    1c94:	41 96       	adiw	r24, 0x11	; 17
    1c96:	2b 85       	ldd	r18, Y+11	; 0x0b
    1c98:	3c 85       	ldd	r19, Y+12	; 0x0c
    1c9a:	b9 01       	movw	r22, r18
    1c9c:	0e 94 ad 07 	call	0xf5a	; 0xf5a <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1ca0:	8f 81       	ldd	r24, Y+7	; 0x07
    1ca2:	98 85       	ldd	r25, Y+8	; 0x08
    1ca4:	0e 94 f5 0f 	call	0x1fea	; 0x1fea <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1ca8:	0e 94 97 05 	call	0xb2e	; 0xb2e <xTaskResumeAll>
    1cac:	88 23       	and	r24, r24
    1cae:	09 f0       	breq	.+2      	; 0x1cb2 <xQueueGenericReceive+0x184>
    1cb0:	50 cf       	rjmp	.-352    	; 0x1b52 <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    1cb2:	0e 94 12 17 	call	0x2e24	; 0x2e24 <vPortYield>
    1cb6:	4d cf       	rjmp	.-358    	; 0x1b52 <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1cb8:	8f 81       	ldd	r24, Y+7	; 0x07
    1cba:	98 85       	ldd	r25, Y+8	; 0x08
    1cbc:	0e 94 f5 0f 	call	0x1fea	; 0x1fea <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1cc0:	0e 94 97 05 	call	0xb2e	; 0xb2e <xTaskResumeAll>
    1cc4:	46 cf       	rjmp	.-372    	; 0x1b52 <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1cc6:	8f 81       	ldd	r24, Y+7	; 0x07
    1cc8:	98 85       	ldd	r25, Y+8	; 0x08
    1cca:	0e 94 f5 0f 	call	0x1fea	; 0x1fea <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1cce:	0e 94 97 05 	call	0xb2e	; 0xb2e <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1cd2:	1e 86       	std	Y+14, r1	; 0x0e
    1cd4:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    1cd6:	2e 96       	adiw	r28, 0x0e	; 14
    1cd8:	0f b6       	in	r0, 0x3f	; 63
    1cda:	f8 94       	cli
    1cdc:	de bf       	out	0x3e, r29	; 62
    1cde:	0f be       	out	0x3f, r0	; 63
    1ce0:	cd bf       	out	0x3d, r28	; 61
    1ce2:	cf 91       	pop	r28
    1ce4:	df 91       	pop	r29
    1ce6:	08 95       	ret

00001ce8 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
{
    1ce8:	df 93       	push	r29
    1cea:	cf 93       	push	r28
    1cec:	cd b7       	in	r28, 0x3d	; 61
    1cee:	de b7       	in	r29, 0x3e	; 62
    1cf0:	28 97       	sbiw	r28, 0x08	; 8
    1cf2:	0f b6       	in	r0, 0x3f	; 63
    1cf4:	f8 94       	cli
    1cf6:	de bf       	out	0x3e, r29	; 62
    1cf8:	0f be       	out	0x3f, r0	; 63
    1cfa:	cd bf       	out	0x3d, r28	; 61
    1cfc:	9c 83       	std	Y+4, r25	; 0x04
    1cfe:	8b 83       	std	Y+3, r24	; 0x03
    1d00:	7e 83       	std	Y+6, r23	; 0x06
    1d02:	6d 83       	std	Y+5, r22	; 0x05
    1d04:	58 87       	std	Y+8, r21	; 0x08
    1d06:	4f 83       	std	Y+7, r20	; 0x07
unsigned portBASE_TYPE uxSavedInterruptStatus;

	configASSERT( pxQueue );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1d08:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1d0a:	eb 81       	ldd	r30, Y+3	; 0x03
    1d0c:	fc 81       	ldd	r31, Y+4	; 0x04
    1d0e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d10:	88 23       	and	r24, r24
    1d12:	91 f1       	breq	.+100    	; 0x1d78 <xQueueReceiveFromISR+0x90>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1d14:	8b 81       	ldd	r24, Y+3	; 0x03
    1d16:	9c 81       	ldd	r25, Y+4	; 0x04
    1d18:	2d 81       	ldd	r18, Y+5	; 0x05
    1d1a:	3e 81       	ldd	r19, Y+6	; 0x06
    1d1c:	b9 01       	movw	r22, r18
    1d1e:	0e 94 ad 0f 	call	0x1f5a	; 0x1f5a <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1d22:	eb 81       	ldd	r30, Y+3	; 0x03
    1d24:	fc 81       	ldd	r31, Y+4	; 0x04
    1d26:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d28:	81 50       	subi	r24, 0x01	; 1
    1d2a:	eb 81       	ldd	r30, Y+3	; 0x03
    1d2c:	fc 81       	ldd	r31, Y+4	; 0x04
    1d2e:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1d30:	eb 81       	ldd	r30, Y+3	; 0x03
    1d32:	fc 81       	ldd	r31, Y+4	; 0x04
    1d34:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d36:	8f 3f       	cpi	r24, 0xFF	; 255
    1d38:	a9 f4       	brne	.+42     	; 0x1d64 <xQueueReceiveFromISR+0x7c>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1d3a:	eb 81       	ldd	r30, Y+3	; 0x03
    1d3c:	fc 81       	ldd	r31, Y+4	; 0x04
    1d3e:	80 85       	ldd	r24, Z+8	; 0x08
    1d40:	88 23       	and	r24, r24
    1d42:	b9 f0       	breq	.+46     	; 0x1d72 <xQueueReceiveFromISR+0x8a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1d44:	8b 81       	ldd	r24, Y+3	; 0x03
    1d46:	9c 81       	ldd	r25, Y+4	; 0x04
    1d48:	08 96       	adiw	r24, 0x08	; 8
    1d4a:	0e 94 f5 07 	call	0xfea	; 0xfea <xTaskRemoveFromEventList>
    1d4e:	88 23       	and	r24, r24
    1d50:	81 f0       	breq	.+32     	; 0x1d72 <xQueueReceiveFromISR+0x8a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1d52:	8f 81       	ldd	r24, Y+7	; 0x07
    1d54:	98 85       	ldd	r25, Y+8	; 0x08
    1d56:	00 97       	sbiw	r24, 0x00	; 0
    1d58:	61 f0       	breq	.+24     	; 0x1d72 <xQueueReceiveFromISR+0x8a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1d5a:	ef 81       	ldd	r30, Y+7	; 0x07
    1d5c:	f8 85       	ldd	r31, Y+8	; 0x08
    1d5e:	81 e0       	ldi	r24, 0x01	; 1
    1d60:	80 83       	st	Z, r24
    1d62:	07 c0       	rjmp	.+14     	; 0x1d72 <xQueueReceiveFromISR+0x8a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1d64:	eb 81       	ldd	r30, Y+3	; 0x03
    1d66:	fc 81       	ldd	r31, Y+4	; 0x04
    1d68:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d6a:	8f 5f       	subi	r24, 0xFF	; 255
    1d6c:	eb 81       	ldd	r30, Y+3	; 0x03
    1d6e:	fc 81       	ldd	r31, Y+4	; 0x04
    1d70:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    1d72:	81 e0       	ldi	r24, 0x01	; 1
    1d74:	8a 83       	std	Y+2, r24	; 0x02
    1d76:	01 c0       	rjmp	.+2      	; 0x1d7a <xQueueReceiveFromISR+0x92>
		}
		else
		{
			xReturn = pdFAIL;
    1d78:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1d7a:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1d7c:	28 96       	adiw	r28, 0x08	; 8
    1d7e:	0f b6       	in	r0, 0x3f	; 63
    1d80:	f8 94       	cli
    1d82:	de bf       	out	0x3e, r29	; 62
    1d84:	0f be       	out	0x3f, r0	; 63
    1d86:	cd bf       	out	0x3d, r28	; 61
    1d88:	cf 91       	pop	r28
    1d8a:	df 91       	pop	r29
    1d8c:	08 95       	ret

00001d8e <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    1d8e:	df 93       	push	r29
    1d90:	cf 93       	push	r28
    1d92:	00 d0       	rcall	.+0      	; 0x1d94 <uxQueueMessagesWaiting+0x6>
    1d94:	cd b7       	in	r28, 0x3d	; 61
    1d96:	de b7       	in	r29, 0x3e	; 62
    1d98:	9b 83       	std	Y+3, r25	; 0x03
    1d9a:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1d9c:	0f b6       	in	r0, 0x3f	; 63
    1d9e:	f8 94       	cli
    1da0:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1da2:	ea 81       	ldd	r30, Y+2	; 0x02
    1da4:	fb 81       	ldd	r31, Y+3	; 0x03
    1da6:	82 8d       	ldd	r24, Z+26	; 0x1a
    1da8:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1daa:	0f 90       	pop	r0
    1dac:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1dae:	89 81       	ldd	r24, Y+1	; 0x01
}
    1db0:	0f 90       	pop	r0
    1db2:	0f 90       	pop	r0
    1db4:	0f 90       	pop	r0
    1db6:	cf 91       	pop	r28
    1db8:	df 91       	pop	r29
    1dba:	08 95       	ret

00001dbc <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    1dbc:	df 93       	push	r29
    1dbe:	cf 93       	push	r28
    1dc0:	00 d0       	rcall	.+0      	; 0x1dc2 <uxQueueMessagesWaitingFromISR+0x6>
    1dc2:	cd b7       	in	r28, 0x3d	; 61
    1dc4:	de b7       	in	r29, 0x3e	; 62
    1dc6:	9b 83       	std	Y+3, r25	; 0x03
    1dc8:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    1dca:	ea 81       	ldd	r30, Y+2	; 0x02
    1dcc:	fb 81       	ldd	r31, Y+3	; 0x03
    1dce:	82 8d       	ldd	r24, Z+26	; 0x1a
    1dd0:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    1dd2:	89 81       	ldd	r24, Y+1	; 0x01
}
    1dd4:	0f 90       	pop	r0
    1dd6:	0f 90       	pop	r0
    1dd8:	0f 90       	pop	r0
    1dda:	cf 91       	pop	r28
    1ddc:	df 91       	pop	r29
    1dde:	08 95       	ret

00001de0 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    1de0:	df 93       	push	r29
    1de2:	cf 93       	push	r28
    1de4:	0f 92       	push	r0
    1de6:	0f 92       	push	r0
    1de8:	cd b7       	in	r28, 0x3d	; 61
    1dea:	de b7       	in	r29, 0x3e	; 62
    1dec:	9a 83       	std	Y+2, r25	; 0x02
    1dee:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    1df0:	e9 81       	ldd	r30, Y+1	; 0x01
    1df2:	fa 81       	ldd	r31, Y+2	; 0x02
    1df4:	80 81       	ld	r24, Z
    1df6:	91 81       	ldd	r25, Z+1	; 0x01
    1df8:	0e 94 10 15 	call	0x2a20	; 0x2a20 <vPortFree>
	vPortFree( pxQueue );
    1dfc:	89 81       	ldd	r24, Y+1	; 0x01
    1dfe:	9a 81       	ldd	r25, Y+2	; 0x02
    1e00:	0e 94 10 15 	call	0x2a20	; 0x2a20 <vPortFree>
}
    1e04:	0f 90       	pop	r0
    1e06:	0f 90       	pop	r0
    1e08:	cf 91       	pop	r28
    1e0a:	df 91       	pop	r29
    1e0c:	08 95       	ret

00001e0e <prvCopyDataToQueue>:

#endif
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    1e0e:	df 93       	push	r29
    1e10:	cf 93       	push	r28
    1e12:	00 d0       	rcall	.+0      	; 0x1e14 <prvCopyDataToQueue+0x6>
    1e14:	0f 92       	push	r0
    1e16:	0f 92       	push	r0
    1e18:	cd b7       	in	r28, 0x3d	; 61
    1e1a:	de b7       	in	r29, 0x3e	; 62
    1e1c:	9a 83       	std	Y+2, r25	; 0x02
    1e1e:	89 83       	std	Y+1, r24	; 0x01
    1e20:	7c 83       	std	Y+4, r23	; 0x04
    1e22:	6b 83       	std	Y+3, r22	; 0x03
    1e24:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    1e26:	e9 81       	ldd	r30, Y+1	; 0x01
    1e28:	fa 81       	ldd	r31, Y+2	; 0x02
    1e2a:	84 8d       	ldd	r24, Z+28	; 0x1c
    1e2c:	88 23       	and	r24, r24
    1e2e:	91 f4       	brne	.+36     	; 0x1e54 <prvCopyDataToQueue+0x46>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1e30:	e9 81       	ldd	r30, Y+1	; 0x01
    1e32:	fa 81       	ldd	r31, Y+2	; 0x02
    1e34:	80 81       	ld	r24, Z
    1e36:	91 81       	ldd	r25, Z+1	; 0x01
    1e38:	00 97       	sbiw	r24, 0x00	; 0
    1e3a:	09 f0       	breq	.+2      	; 0x1e3e <prvCopyDataToQueue+0x30>
    1e3c:	7f c0       	rjmp	.+254    	; 0x1f3c <prvCopyDataToQueue+0x12e>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    1e3e:	e9 81       	ldd	r30, Y+1	; 0x01
    1e40:	fa 81       	ldd	r31, Y+2	; 0x02
    1e42:	82 81       	ldd	r24, Z+2	; 0x02
    1e44:	93 81       	ldd	r25, Z+3	; 0x03
    1e46:	0e 94 21 0b 	call	0x1642	; 0x1642 <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    1e4a:	e9 81       	ldd	r30, Y+1	; 0x01
    1e4c:	fa 81       	ldd	r31, Y+2	; 0x02
    1e4e:	13 82       	std	Z+3, r1	; 0x03
    1e50:	12 82       	std	Z+2, r1	; 0x02
    1e52:	74 c0       	rjmp	.+232    	; 0x1f3c <prvCopyDataToQueue+0x12e>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    1e54:	8d 81       	ldd	r24, Y+5	; 0x05
    1e56:	88 23       	and	r24, r24
    1e58:	99 f5       	brne	.+102    	; 0x1ec0 <prvCopyDataToQueue+0xb2>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1e5a:	e9 81       	ldd	r30, Y+1	; 0x01
    1e5c:	fa 81       	ldd	r31, Y+2	; 0x02
    1e5e:	64 81       	ldd	r22, Z+4	; 0x04
    1e60:	75 81       	ldd	r23, Z+5	; 0x05
    1e62:	e9 81       	ldd	r30, Y+1	; 0x01
    1e64:	fa 81       	ldd	r31, Y+2	; 0x02
    1e66:	84 8d       	ldd	r24, Z+28	; 0x1c
    1e68:	48 2f       	mov	r20, r24
    1e6a:	50 e0       	ldi	r21, 0x00	; 0
    1e6c:	2b 81       	ldd	r18, Y+3	; 0x03
    1e6e:	3c 81       	ldd	r19, Y+4	; 0x04
    1e70:	cb 01       	movw	r24, r22
    1e72:	b9 01       	movw	r22, r18
    1e74:	0e 94 11 20 	call	0x4022	; 0x4022 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1e78:	e9 81       	ldd	r30, Y+1	; 0x01
    1e7a:	fa 81       	ldd	r31, Y+2	; 0x02
    1e7c:	24 81       	ldd	r18, Z+4	; 0x04
    1e7e:	35 81       	ldd	r19, Z+5	; 0x05
    1e80:	e9 81       	ldd	r30, Y+1	; 0x01
    1e82:	fa 81       	ldd	r31, Y+2	; 0x02
    1e84:	84 8d       	ldd	r24, Z+28	; 0x1c
    1e86:	88 2f       	mov	r24, r24
    1e88:	90 e0       	ldi	r25, 0x00	; 0
    1e8a:	82 0f       	add	r24, r18
    1e8c:	93 1f       	adc	r25, r19
    1e8e:	e9 81       	ldd	r30, Y+1	; 0x01
    1e90:	fa 81       	ldd	r31, Y+2	; 0x02
    1e92:	95 83       	std	Z+5, r25	; 0x05
    1e94:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    1e96:	e9 81       	ldd	r30, Y+1	; 0x01
    1e98:	fa 81       	ldd	r31, Y+2	; 0x02
    1e9a:	24 81       	ldd	r18, Z+4	; 0x04
    1e9c:	35 81       	ldd	r19, Z+5	; 0x05
    1e9e:	e9 81       	ldd	r30, Y+1	; 0x01
    1ea0:	fa 81       	ldd	r31, Y+2	; 0x02
    1ea2:	82 81       	ldd	r24, Z+2	; 0x02
    1ea4:	93 81       	ldd	r25, Z+3	; 0x03
    1ea6:	28 17       	cp	r18, r24
    1ea8:	39 07       	cpc	r19, r25
    1eaa:	08 f4       	brcc	.+2      	; 0x1eae <prvCopyDataToQueue+0xa0>
    1eac:	47 c0       	rjmp	.+142    	; 0x1f3c <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1eae:	e9 81       	ldd	r30, Y+1	; 0x01
    1eb0:	fa 81       	ldd	r31, Y+2	; 0x02
    1eb2:	80 81       	ld	r24, Z
    1eb4:	91 81       	ldd	r25, Z+1	; 0x01
    1eb6:	e9 81       	ldd	r30, Y+1	; 0x01
    1eb8:	fa 81       	ldd	r31, Y+2	; 0x02
    1eba:	95 83       	std	Z+5, r25	; 0x05
    1ebc:	84 83       	std	Z+4, r24	; 0x04
    1ebe:	3e c0       	rjmp	.+124    	; 0x1f3c <prvCopyDataToQueue+0x12e>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1ec0:	e9 81       	ldd	r30, Y+1	; 0x01
    1ec2:	fa 81       	ldd	r31, Y+2	; 0x02
    1ec4:	66 81       	ldd	r22, Z+6	; 0x06
    1ec6:	77 81       	ldd	r23, Z+7	; 0x07
    1ec8:	e9 81       	ldd	r30, Y+1	; 0x01
    1eca:	fa 81       	ldd	r31, Y+2	; 0x02
    1ecc:	84 8d       	ldd	r24, Z+28	; 0x1c
    1ece:	48 2f       	mov	r20, r24
    1ed0:	50 e0       	ldi	r21, 0x00	; 0
    1ed2:	2b 81       	ldd	r18, Y+3	; 0x03
    1ed4:	3c 81       	ldd	r19, Y+4	; 0x04
    1ed6:	cb 01       	movw	r24, r22
    1ed8:	b9 01       	movw	r22, r18
    1eda:	0e 94 11 20 	call	0x4022	; 0x4022 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    1ede:	e9 81       	ldd	r30, Y+1	; 0x01
    1ee0:	fa 81       	ldd	r31, Y+2	; 0x02
    1ee2:	26 81       	ldd	r18, Z+6	; 0x06
    1ee4:	37 81       	ldd	r19, Z+7	; 0x07
    1ee6:	e9 81       	ldd	r30, Y+1	; 0x01
    1ee8:	fa 81       	ldd	r31, Y+2	; 0x02
    1eea:	84 8d       	ldd	r24, Z+28	; 0x1c
    1eec:	88 2f       	mov	r24, r24
    1eee:	90 e0       	ldi	r25, 0x00	; 0
    1ef0:	90 95       	com	r25
    1ef2:	81 95       	neg	r24
    1ef4:	9f 4f       	sbci	r25, 0xFF	; 255
    1ef6:	82 0f       	add	r24, r18
    1ef8:	93 1f       	adc	r25, r19
    1efa:	e9 81       	ldd	r30, Y+1	; 0x01
    1efc:	fa 81       	ldd	r31, Y+2	; 0x02
    1efe:	97 83       	std	Z+7, r25	; 0x07
    1f00:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    1f02:	e9 81       	ldd	r30, Y+1	; 0x01
    1f04:	fa 81       	ldd	r31, Y+2	; 0x02
    1f06:	26 81       	ldd	r18, Z+6	; 0x06
    1f08:	37 81       	ldd	r19, Z+7	; 0x07
    1f0a:	e9 81       	ldd	r30, Y+1	; 0x01
    1f0c:	fa 81       	ldd	r31, Y+2	; 0x02
    1f0e:	80 81       	ld	r24, Z
    1f10:	91 81       	ldd	r25, Z+1	; 0x01
    1f12:	28 17       	cp	r18, r24
    1f14:	39 07       	cpc	r19, r25
    1f16:	90 f4       	brcc	.+36     	; 0x1f3c <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1f18:	e9 81       	ldd	r30, Y+1	; 0x01
    1f1a:	fa 81       	ldd	r31, Y+2	; 0x02
    1f1c:	22 81       	ldd	r18, Z+2	; 0x02
    1f1e:	33 81       	ldd	r19, Z+3	; 0x03
    1f20:	e9 81       	ldd	r30, Y+1	; 0x01
    1f22:	fa 81       	ldd	r31, Y+2	; 0x02
    1f24:	84 8d       	ldd	r24, Z+28	; 0x1c
    1f26:	88 2f       	mov	r24, r24
    1f28:	90 e0       	ldi	r25, 0x00	; 0
    1f2a:	90 95       	com	r25
    1f2c:	81 95       	neg	r24
    1f2e:	9f 4f       	sbci	r25, 0xFF	; 255
    1f30:	82 0f       	add	r24, r18
    1f32:	93 1f       	adc	r25, r19
    1f34:	e9 81       	ldd	r30, Y+1	; 0x01
    1f36:	fa 81       	ldd	r31, Y+2	; 0x02
    1f38:	97 83       	std	Z+7, r25	; 0x07
    1f3a:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1f3c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f3e:	fa 81       	ldd	r31, Y+2	; 0x02
    1f40:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f42:	8f 5f       	subi	r24, 0xFF	; 255
    1f44:	e9 81       	ldd	r30, Y+1	; 0x01
    1f46:	fa 81       	ldd	r31, Y+2	; 0x02
    1f48:	82 8f       	std	Z+26, r24	; 0x1a
}
    1f4a:	0f 90       	pop	r0
    1f4c:	0f 90       	pop	r0
    1f4e:	0f 90       	pop	r0
    1f50:	0f 90       	pop	r0
    1f52:	0f 90       	pop	r0
    1f54:	cf 91       	pop	r28
    1f56:	df 91       	pop	r29
    1f58:	08 95       	ret

00001f5a <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    1f5a:	df 93       	push	r29
    1f5c:	cf 93       	push	r28
    1f5e:	00 d0       	rcall	.+0      	; 0x1f60 <prvCopyDataFromQueue+0x6>
    1f60:	0f 92       	push	r0
    1f62:	cd b7       	in	r28, 0x3d	; 61
    1f64:	de b7       	in	r29, 0x3e	; 62
    1f66:	9a 83       	std	Y+2, r25	; 0x02
    1f68:	89 83       	std	Y+1, r24	; 0x01
    1f6a:	7c 83       	std	Y+4, r23	; 0x04
    1f6c:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    1f6e:	e9 81       	ldd	r30, Y+1	; 0x01
    1f70:	fa 81       	ldd	r31, Y+2	; 0x02
    1f72:	80 81       	ld	r24, Z
    1f74:	91 81       	ldd	r25, Z+1	; 0x01
    1f76:	00 97       	sbiw	r24, 0x00	; 0
    1f78:	89 f1       	breq	.+98     	; 0x1fdc <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    1f7a:	e9 81       	ldd	r30, Y+1	; 0x01
    1f7c:	fa 81       	ldd	r31, Y+2	; 0x02
    1f7e:	26 81       	ldd	r18, Z+6	; 0x06
    1f80:	37 81       	ldd	r19, Z+7	; 0x07
    1f82:	e9 81       	ldd	r30, Y+1	; 0x01
    1f84:	fa 81       	ldd	r31, Y+2	; 0x02
    1f86:	84 8d       	ldd	r24, Z+28	; 0x1c
    1f88:	88 2f       	mov	r24, r24
    1f8a:	90 e0       	ldi	r25, 0x00	; 0
    1f8c:	82 0f       	add	r24, r18
    1f8e:	93 1f       	adc	r25, r19
    1f90:	e9 81       	ldd	r30, Y+1	; 0x01
    1f92:	fa 81       	ldd	r31, Y+2	; 0x02
    1f94:	97 83       	std	Z+7, r25	; 0x07
    1f96:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1f98:	e9 81       	ldd	r30, Y+1	; 0x01
    1f9a:	fa 81       	ldd	r31, Y+2	; 0x02
    1f9c:	26 81       	ldd	r18, Z+6	; 0x06
    1f9e:	37 81       	ldd	r19, Z+7	; 0x07
    1fa0:	e9 81       	ldd	r30, Y+1	; 0x01
    1fa2:	fa 81       	ldd	r31, Y+2	; 0x02
    1fa4:	82 81       	ldd	r24, Z+2	; 0x02
    1fa6:	93 81       	ldd	r25, Z+3	; 0x03
    1fa8:	28 17       	cp	r18, r24
    1faa:	39 07       	cpc	r19, r25
    1fac:	40 f0       	brcs	.+16     	; 0x1fbe <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    1fae:	e9 81       	ldd	r30, Y+1	; 0x01
    1fb0:	fa 81       	ldd	r31, Y+2	; 0x02
    1fb2:	80 81       	ld	r24, Z
    1fb4:	91 81       	ldd	r25, Z+1	; 0x01
    1fb6:	e9 81       	ldd	r30, Y+1	; 0x01
    1fb8:	fa 81       	ldd	r31, Y+2	; 0x02
    1fba:	97 83       	std	Z+7, r25	; 0x07
    1fbc:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1fbe:	e9 81       	ldd	r30, Y+1	; 0x01
    1fc0:	fa 81       	ldd	r31, Y+2	; 0x02
    1fc2:	46 81       	ldd	r20, Z+6	; 0x06
    1fc4:	57 81       	ldd	r21, Z+7	; 0x07
    1fc6:	e9 81       	ldd	r30, Y+1	; 0x01
    1fc8:	fa 81       	ldd	r31, Y+2	; 0x02
    1fca:	84 8d       	ldd	r24, Z+28	; 0x1c
    1fcc:	28 2f       	mov	r18, r24
    1fce:	30 e0       	ldi	r19, 0x00	; 0
    1fd0:	8b 81       	ldd	r24, Y+3	; 0x03
    1fd2:	9c 81       	ldd	r25, Y+4	; 0x04
    1fd4:	ba 01       	movw	r22, r20
    1fd6:	a9 01       	movw	r20, r18
    1fd8:	0e 94 11 20 	call	0x4022	; 0x4022 <memcpy>
	}
}
    1fdc:	0f 90       	pop	r0
    1fde:	0f 90       	pop	r0
    1fe0:	0f 90       	pop	r0
    1fe2:	0f 90       	pop	r0
    1fe4:	cf 91       	pop	r28
    1fe6:	df 91       	pop	r29
    1fe8:	08 95       	ret

00001fea <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    1fea:	df 93       	push	r29
    1fec:	cf 93       	push	r28
    1fee:	0f 92       	push	r0
    1ff0:	0f 92       	push	r0
    1ff2:	cd b7       	in	r28, 0x3d	; 61
    1ff4:	de b7       	in	r29, 0x3e	; 62
    1ff6:	9a 83       	std	Y+2, r25	; 0x02
    1ff8:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1ffa:	0f b6       	in	r0, 0x3f	; 63
    1ffc:	f8 94       	cli
    1ffe:	0f 92       	push	r0
    2000:	15 c0       	rjmp	.+42     	; 0x202c <prvUnlockQueue+0x42>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2002:	e9 81       	ldd	r30, Y+1	; 0x01
    2004:	fa 81       	ldd	r31, Y+2	; 0x02
    2006:	81 89       	ldd	r24, Z+17	; 0x11
    2008:	88 23       	and	r24, r24
    200a:	a9 f0       	breq	.+42     	; 0x2036 <prvUnlockQueue+0x4c>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    200c:	89 81       	ldd	r24, Y+1	; 0x01
    200e:	9a 81       	ldd	r25, Y+2	; 0x02
    2010:	41 96       	adiw	r24, 0x11	; 17
    2012:	0e 94 f5 07 	call	0xfea	; 0xfea <xTaskRemoveFromEventList>
    2016:	88 23       	and	r24, r24
    2018:	11 f0       	breq	.+4      	; 0x201e <prvUnlockQueue+0x34>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    201a:	0e 94 de 08 	call	0x11bc	; 0x11bc <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    201e:	e9 81       	ldd	r30, Y+1	; 0x01
    2020:	fa 81       	ldd	r31, Y+2	; 0x02
    2022:	86 8d       	ldd	r24, Z+30	; 0x1e
    2024:	81 50       	subi	r24, 0x01	; 1
    2026:	e9 81       	ldd	r30, Y+1	; 0x01
    2028:	fa 81       	ldd	r31, Y+2	; 0x02
    202a:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    202c:	e9 81       	ldd	r30, Y+1	; 0x01
    202e:	fa 81       	ldd	r31, Y+2	; 0x02
    2030:	86 8d       	ldd	r24, Z+30	; 0x1e
    2032:	18 16       	cp	r1, r24
    2034:	34 f3       	brlt	.-52     	; 0x2002 <prvUnlockQueue+0x18>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    2036:	e9 81       	ldd	r30, Y+1	; 0x01
    2038:	fa 81       	ldd	r31, Y+2	; 0x02
    203a:	8f ef       	ldi	r24, 0xFF	; 255
    203c:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    203e:	0f 90       	pop	r0
    2040:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2042:	0f b6       	in	r0, 0x3f	; 63
    2044:	f8 94       	cli
    2046:	0f 92       	push	r0
    2048:	15 c0       	rjmp	.+42     	; 0x2074 <prvUnlockQueue+0x8a>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    204a:	e9 81       	ldd	r30, Y+1	; 0x01
    204c:	fa 81       	ldd	r31, Y+2	; 0x02
    204e:	80 85       	ldd	r24, Z+8	; 0x08
    2050:	88 23       	and	r24, r24
    2052:	a9 f0       	breq	.+42     	; 0x207e <prvUnlockQueue+0x94>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2054:	89 81       	ldd	r24, Y+1	; 0x01
    2056:	9a 81       	ldd	r25, Y+2	; 0x02
    2058:	08 96       	adiw	r24, 0x08	; 8
    205a:	0e 94 f5 07 	call	0xfea	; 0xfea <xTaskRemoveFromEventList>
    205e:	88 23       	and	r24, r24
    2060:	11 f0       	breq	.+4      	; 0x2066 <prvUnlockQueue+0x7c>
				{
					vTaskMissedYield();
    2062:	0e 94 de 08 	call	0x11bc	; 0x11bc <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    2066:	e9 81       	ldd	r30, Y+1	; 0x01
    2068:	fa 81       	ldd	r31, Y+2	; 0x02
    206a:	85 8d       	ldd	r24, Z+29	; 0x1d
    206c:	81 50       	subi	r24, 0x01	; 1
    206e:	e9 81       	ldd	r30, Y+1	; 0x01
    2070:	fa 81       	ldd	r31, Y+2	; 0x02
    2072:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2074:	e9 81       	ldd	r30, Y+1	; 0x01
    2076:	fa 81       	ldd	r31, Y+2	; 0x02
    2078:	85 8d       	ldd	r24, Z+29	; 0x1d
    207a:	18 16       	cp	r1, r24
    207c:	34 f3       	brlt	.-52     	; 0x204a <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    207e:	e9 81       	ldd	r30, Y+1	; 0x01
    2080:	fa 81       	ldd	r31, Y+2	; 0x02
    2082:	8f ef       	ldi	r24, 0xFF	; 255
    2084:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    2086:	0f 90       	pop	r0
    2088:	0f be       	out	0x3f, r0	; 63
}
    208a:	0f 90       	pop	r0
    208c:	0f 90       	pop	r0
    208e:	cf 91       	pop	r28
    2090:	df 91       	pop	r29
    2092:	08 95       	ret

00002094 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    2094:	df 93       	push	r29
    2096:	cf 93       	push	r28
    2098:	00 d0       	rcall	.+0      	; 0x209a <prvIsQueueEmpty+0x6>
    209a:	cd b7       	in	r28, 0x3d	; 61
    209c:	de b7       	in	r29, 0x3e	; 62
    209e:	9b 83       	std	Y+3, r25	; 0x03
    20a0:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    20a2:	0f b6       	in	r0, 0x3f	; 63
    20a4:	f8 94       	cli
    20a6:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    20a8:	ea 81       	ldd	r30, Y+2	; 0x02
    20aa:	fb 81       	ldd	r31, Y+3	; 0x03
    20ac:	82 8d       	ldd	r24, Z+26	; 0x1a
    20ae:	19 82       	std	Y+1, r1	; 0x01
    20b0:	88 23       	and	r24, r24
    20b2:	11 f4       	brne	.+4      	; 0x20b8 <prvIsQueueEmpty+0x24>
    20b4:	81 e0       	ldi	r24, 0x01	; 1
    20b6:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    20b8:	0f 90       	pop	r0
    20ba:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    20bc:	89 81       	ldd	r24, Y+1	; 0x01
}
    20be:	0f 90       	pop	r0
    20c0:	0f 90       	pop	r0
    20c2:	0f 90       	pop	r0
    20c4:	cf 91       	pop	r28
    20c6:	df 91       	pop	r29
    20c8:	08 95       	ret

000020ca <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    20ca:	df 93       	push	r29
    20cc:	cf 93       	push	r28
    20ce:	00 d0       	rcall	.+0      	; 0x20d0 <xQueueIsQueueEmptyFromISR+0x6>
    20d0:	cd b7       	in	r28, 0x3d	; 61
    20d2:	de b7       	in	r29, 0x3e	; 62
    20d4:	9b 83       	std	Y+3, r25	; 0x03
    20d6:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    20d8:	ea 81       	ldd	r30, Y+2	; 0x02
    20da:	fb 81       	ldd	r31, Y+3	; 0x03
    20dc:	82 8d       	ldd	r24, Z+26	; 0x1a
    20de:	19 82       	std	Y+1, r1	; 0x01
    20e0:	88 23       	and	r24, r24
    20e2:	11 f4       	brne	.+4      	; 0x20e8 <xQueueIsQueueEmptyFromISR+0x1e>
    20e4:	81 e0       	ldi	r24, 0x01	; 1
    20e6:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    20e8:	89 81       	ldd	r24, Y+1	; 0x01
}
    20ea:	0f 90       	pop	r0
    20ec:	0f 90       	pop	r0
    20ee:	0f 90       	pop	r0
    20f0:	cf 91       	pop	r28
    20f2:	df 91       	pop	r29
    20f4:	08 95       	ret

000020f6 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    20f6:	df 93       	push	r29
    20f8:	cf 93       	push	r28
    20fa:	00 d0       	rcall	.+0      	; 0x20fc <prvIsQueueFull+0x6>
    20fc:	cd b7       	in	r28, 0x3d	; 61
    20fe:	de b7       	in	r29, 0x3e	; 62
    2100:	9b 83       	std	Y+3, r25	; 0x03
    2102:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    2104:	0f b6       	in	r0, 0x3f	; 63
    2106:	f8 94       	cli
    2108:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    210a:	ea 81       	ldd	r30, Y+2	; 0x02
    210c:	fb 81       	ldd	r31, Y+3	; 0x03
    210e:	92 8d       	ldd	r25, Z+26	; 0x1a
    2110:	ea 81       	ldd	r30, Y+2	; 0x02
    2112:	fb 81       	ldd	r31, Y+3	; 0x03
    2114:	83 8d       	ldd	r24, Z+27	; 0x1b
    2116:	19 82       	std	Y+1, r1	; 0x01
    2118:	98 17       	cp	r25, r24
    211a:	11 f4       	brne	.+4      	; 0x2120 <prvIsQueueFull+0x2a>
    211c:	81 e0       	ldi	r24, 0x01	; 1
    211e:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    2120:	0f 90       	pop	r0
    2122:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2124:	89 81       	ldd	r24, Y+1	; 0x01
}
    2126:	0f 90       	pop	r0
    2128:	0f 90       	pop	r0
    212a:	0f 90       	pop	r0
    212c:	cf 91       	pop	r28
    212e:	df 91       	pop	r29
    2130:	08 95       	ret

00002132 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    2132:	df 93       	push	r29
    2134:	cf 93       	push	r28
    2136:	00 d0       	rcall	.+0      	; 0x2138 <xQueueIsQueueFullFromISR+0x6>
    2138:	cd b7       	in	r28, 0x3d	; 61
    213a:	de b7       	in	r29, 0x3e	; 62
    213c:	9b 83       	std	Y+3, r25	; 0x03
    213e:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    2140:	ea 81       	ldd	r30, Y+2	; 0x02
    2142:	fb 81       	ldd	r31, Y+3	; 0x03
    2144:	92 8d       	ldd	r25, Z+26	; 0x1a
    2146:	ea 81       	ldd	r30, Y+2	; 0x02
    2148:	fb 81       	ldd	r31, Y+3	; 0x03
    214a:	83 8d       	ldd	r24, Z+27	; 0x1b
    214c:	19 82       	std	Y+1, r1	; 0x01
    214e:	98 17       	cp	r25, r24
    2150:	11 f4       	brne	.+4      	; 0x2156 <xQueueIsQueueFullFromISR+0x24>
    2152:	81 e0       	ldi	r24, 0x01	; 1
    2154:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    2156:	89 81       	ldd	r24, Y+1	; 0x01
}
    2158:	0f 90       	pop	r0
    215a:	0f 90       	pop	r0
    215c:	0f 90       	pop	r0
    215e:	cf 91       	pop	r28
    2160:	df 91       	pop	r29
    2162:	08 95       	ret

00002164 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    2164:	df 93       	push	r29
    2166:	cf 93       	push	r28
    2168:	0f 92       	push	r0
    216a:	0f 92       	push	r0
    216c:	cd b7       	in	r28, 0x3d	; 61
    216e:	de b7       	in	r29, 0x3e	; 62
    2170:	9a 83       	std	Y+2, r25	; 0x02
    2172:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    2174:	89 81       	ldd	r24, Y+1	; 0x01
    2176:	9a 81       	ldd	r25, Y+2	; 0x02
    2178:	03 96       	adiw	r24, 0x03	; 3
    217a:	e9 81       	ldd	r30, Y+1	; 0x01
    217c:	fa 81       	ldd	r31, Y+2	; 0x02
    217e:	92 83       	std	Z+2, r25	; 0x02
    2180:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2182:	e9 81       	ldd	r30, Y+1	; 0x01
    2184:	fa 81       	ldd	r31, Y+2	; 0x02
    2186:	8f ef       	ldi	r24, 0xFF	; 255
    2188:	9f ef       	ldi	r25, 0xFF	; 255
    218a:	94 83       	std	Z+4, r25	; 0x04
    218c:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    218e:	89 81       	ldd	r24, Y+1	; 0x01
    2190:	9a 81       	ldd	r25, Y+2	; 0x02
    2192:	03 96       	adiw	r24, 0x03	; 3
    2194:	e9 81       	ldd	r30, Y+1	; 0x01
    2196:	fa 81       	ldd	r31, Y+2	; 0x02
    2198:	96 83       	std	Z+6, r25	; 0x06
    219a:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    219c:	89 81       	ldd	r24, Y+1	; 0x01
    219e:	9a 81       	ldd	r25, Y+2	; 0x02
    21a0:	03 96       	adiw	r24, 0x03	; 3
    21a2:	e9 81       	ldd	r30, Y+1	; 0x01
    21a4:	fa 81       	ldd	r31, Y+2	; 0x02
    21a6:	90 87       	std	Z+8, r25	; 0x08
    21a8:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    21aa:	e9 81       	ldd	r30, Y+1	; 0x01
    21ac:	fa 81       	ldd	r31, Y+2	; 0x02
    21ae:	10 82       	st	Z, r1
}
    21b0:	0f 90       	pop	r0
    21b2:	0f 90       	pop	r0
    21b4:	cf 91       	pop	r28
    21b6:	df 91       	pop	r29
    21b8:	08 95       	ret

000021ba <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    21ba:	df 93       	push	r29
    21bc:	cf 93       	push	r28
    21be:	0f 92       	push	r0
    21c0:	0f 92       	push	r0
    21c2:	cd b7       	in	r28, 0x3d	; 61
    21c4:	de b7       	in	r29, 0x3e	; 62
    21c6:	9a 83       	std	Y+2, r25	; 0x02
    21c8:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    21ca:	e9 81       	ldd	r30, Y+1	; 0x01
    21cc:	fa 81       	ldd	r31, Y+2	; 0x02
    21ce:	11 86       	std	Z+9, r1	; 0x09
    21d0:	10 86       	std	Z+8, r1	; 0x08
}
    21d2:	0f 90       	pop	r0
    21d4:	0f 90       	pop	r0
    21d6:	cf 91       	pop	r28
    21d8:	df 91       	pop	r29
    21da:	08 95       	ret

000021dc <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    21dc:	df 93       	push	r29
    21de:	cf 93       	push	r28
    21e0:	00 d0       	rcall	.+0      	; 0x21e2 <vListInsertEnd+0x6>
    21e2:	00 d0       	rcall	.+0      	; 0x21e4 <vListInsertEnd+0x8>
    21e4:	cd b7       	in	r28, 0x3d	; 61
    21e6:	de b7       	in	r29, 0x3e	; 62
    21e8:	9c 83       	std	Y+4, r25	; 0x04
    21ea:	8b 83       	std	Y+3, r24	; 0x03
    21ec:	7e 83       	std	Y+6, r23	; 0x06
    21ee:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    21f0:	eb 81       	ldd	r30, Y+3	; 0x03
    21f2:	fc 81       	ldd	r31, Y+4	; 0x04
    21f4:	81 81       	ldd	r24, Z+1	; 0x01
    21f6:	92 81       	ldd	r25, Z+2	; 0x02
    21f8:	9a 83       	std	Y+2, r25	; 0x02
    21fa:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    21fc:	e9 81       	ldd	r30, Y+1	; 0x01
    21fe:	fa 81       	ldd	r31, Y+2	; 0x02
    2200:	82 81       	ldd	r24, Z+2	; 0x02
    2202:	93 81       	ldd	r25, Z+3	; 0x03
    2204:	ed 81       	ldd	r30, Y+5	; 0x05
    2206:	fe 81       	ldd	r31, Y+6	; 0x06
    2208:	93 83       	std	Z+3, r25	; 0x03
    220a:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    220c:	eb 81       	ldd	r30, Y+3	; 0x03
    220e:	fc 81       	ldd	r31, Y+4	; 0x04
    2210:	81 81       	ldd	r24, Z+1	; 0x01
    2212:	92 81       	ldd	r25, Z+2	; 0x02
    2214:	ed 81       	ldd	r30, Y+5	; 0x05
    2216:	fe 81       	ldd	r31, Y+6	; 0x06
    2218:	95 83       	std	Z+5, r25	; 0x05
    221a:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    221c:	e9 81       	ldd	r30, Y+1	; 0x01
    221e:	fa 81       	ldd	r31, Y+2	; 0x02
    2220:	02 80       	ldd	r0, Z+2	; 0x02
    2222:	f3 81       	ldd	r31, Z+3	; 0x03
    2224:	e0 2d       	mov	r30, r0
    2226:	8d 81       	ldd	r24, Y+5	; 0x05
    2228:	9e 81       	ldd	r25, Y+6	; 0x06
    222a:	95 83       	std	Z+5, r25	; 0x05
    222c:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    222e:	8d 81       	ldd	r24, Y+5	; 0x05
    2230:	9e 81       	ldd	r25, Y+6	; 0x06
    2232:	e9 81       	ldd	r30, Y+1	; 0x01
    2234:	fa 81       	ldd	r31, Y+2	; 0x02
    2236:	93 83       	std	Z+3, r25	; 0x03
    2238:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    223a:	8d 81       	ldd	r24, Y+5	; 0x05
    223c:	9e 81       	ldd	r25, Y+6	; 0x06
    223e:	eb 81       	ldd	r30, Y+3	; 0x03
    2240:	fc 81       	ldd	r31, Y+4	; 0x04
    2242:	92 83       	std	Z+2, r25	; 0x02
    2244:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2246:	ed 81       	ldd	r30, Y+5	; 0x05
    2248:	fe 81       	ldd	r31, Y+6	; 0x06
    224a:	8b 81       	ldd	r24, Y+3	; 0x03
    224c:	9c 81       	ldd	r25, Y+4	; 0x04
    224e:	91 87       	std	Z+9, r25	; 0x09
    2250:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    2252:	eb 81       	ldd	r30, Y+3	; 0x03
    2254:	fc 81       	ldd	r31, Y+4	; 0x04
    2256:	80 81       	ld	r24, Z
    2258:	8f 5f       	subi	r24, 0xFF	; 255
    225a:	eb 81       	ldd	r30, Y+3	; 0x03
    225c:	fc 81       	ldd	r31, Y+4	; 0x04
    225e:	80 83       	st	Z, r24
}
    2260:	26 96       	adiw	r28, 0x06	; 6
    2262:	0f b6       	in	r0, 0x3f	; 63
    2264:	f8 94       	cli
    2266:	de bf       	out	0x3e, r29	; 62
    2268:	0f be       	out	0x3f, r0	; 63
    226a:	cd bf       	out	0x3d, r28	; 61
    226c:	cf 91       	pop	r28
    226e:	df 91       	pop	r29
    2270:	08 95       	ret

00002272 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    2272:	df 93       	push	r29
    2274:	cf 93       	push	r28
    2276:	cd b7       	in	r28, 0x3d	; 61
    2278:	de b7       	in	r29, 0x3e	; 62
    227a:	28 97       	sbiw	r28, 0x08	; 8
    227c:	0f b6       	in	r0, 0x3f	; 63
    227e:	f8 94       	cli
    2280:	de bf       	out	0x3e, r29	; 62
    2282:	0f be       	out	0x3f, r0	; 63
    2284:	cd bf       	out	0x3d, r28	; 61
    2286:	9e 83       	std	Y+6, r25	; 0x06
    2288:	8d 83       	std	Y+5, r24	; 0x05
    228a:	78 87       	std	Y+8, r23	; 0x08
    228c:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    228e:	ef 81       	ldd	r30, Y+7	; 0x07
    2290:	f8 85       	ldd	r31, Y+8	; 0x08
    2292:	80 81       	ld	r24, Z
    2294:	91 81       	ldd	r25, Z+1	; 0x01
    2296:	9a 83       	std	Y+2, r25	; 0x02
    2298:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    229a:	89 81       	ldd	r24, Y+1	; 0x01
    229c:	9a 81       	ldd	r25, Y+2	; 0x02
    229e:	2f ef       	ldi	r18, 0xFF	; 255
    22a0:	8f 3f       	cpi	r24, 0xFF	; 255
    22a2:	92 07       	cpc	r25, r18
    22a4:	39 f4       	brne	.+14     	; 0x22b4 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    22a6:	ed 81       	ldd	r30, Y+5	; 0x05
    22a8:	fe 81       	ldd	r31, Y+6	; 0x06
    22aa:	87 81       	ldd	r24, Z+7	; 0x07
    22ac:	90 85       	ldd	r25, Z+8	; 0x08
    22ae:	9c 83       	std	Y+4, r25	; 0x04
    22b0:	8b 83       	std	Y+3, r24	; 0x03
    22b2:	18 c0       	rjmp	.+48     	; 0x22e4 <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    22b4:	8d 81       	ldd	r24, Y+5	; 0x05
    22b6:	9e 81       	ldd	r25, Y+6	; 0x06
    22b8:	03 96       	adiw	r24, 0x03	; 3
    22ba:	9c 83       	std	Y+4, r25	; 0x04
    22bc:	8b 83       	std	Y+3, r24	; 0x03
    22be:	06 c0       	rjmp	.+12     	; 0x22cc <vListInsert+0x5a>
    22c0:	eb 81       	ldd	r30, Y+3	; 0x03
    22c2:	fc 81       	ldd	r31, Y+4	; 0x04
    22c4:	82 81       	ldd	r24, Z+2	; 0x02
    22c6:	93 81       	ldd	r25, Z+3	; 0x03
    22c8:	9c 83       	std	Y+4, r25	; 0x04
    22ca:	8b 83       	std	Y+3, r24	; 0x03
    22cc:	eb 81       	ldd	r30, Y+3	; 0x03
    22ce:	fc 81       	ldd	r31, Y+4	; 0x04
    22d0:	02 80       	ldd	r0, Z+2	; 0x02
    22d2:	f3 81       	ldd	r31, Z+3	; 0x03
    22d4:	e0 2d       	mov	r30, r0
    22d6:	20 81       	ld	r18, Z
    22d8:	31 81       	ldd	r19, Z+1	; 0x01
    22da:	89 81       	ldd	r24, Y+1	; 0x01
    22dc:	9a 81       	ldd	r25, Y+2	; 0x02
    22de:	82 17       	cp	r24, r18
    22e0:	93 07       	cpc	r25, r19
    22e2:	70 f7       	brcc	.-36     	; 0x22c0 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    22e4:	eb 81       	ldd	r30, Y+3	; 0x03
    22e6:	fc 81       	ldd	r31, Y+4	; 0x04
    22e8:	82 81       	ldd	r24, Z+2	; 0x02
    22ea:	93 81       	ldd	r25, Z+3	; 0x03
    22ec:	ef 81       	ldd	r30, Y+7	; 0x07
    22ee:	f8 85       	ldd	r31, Y+8	; 0x08
    22f0:	93 83       	std	Z+3, r25	; 0x03
    22f2:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    22f4:	ef 81       	ldd	r30, Y+7	; 0x07
    22f6:	f8 85       	ldd	r31, Y+8	; 0x08
    22f8:	02 80       	ldd	r0, Z+2	; 0x02
    22fa:	f3 81       	ldd	r31, Z+3	; 0x03
    22fc:	e0 2d       	mov	r30, r0
    22fe:	8f 81       	ldd	r24, Y+7	; 0x07
    2300:	98 85       	ldd	r25, Y+8	; 0x08
    2302:	95 83       	std	Z+5, r25	; 0x05
    2304:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    2306:	ef 81       	ldd	r30, Y+7	; 0x07
    2308:	f8 85       	ldd	r31, Y+8	; 0x08
    230a:	8b 81       	ldd	r24, Y+3	; 0x03
    230c:	9c 81       	ldd	r25, Y+4	; 0x04
    230e:	95 83       	std	Z+5, r25	; 0x05
    2310:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    2312:	8f 81       	ldd	r24, Y+7	; 0x07
    2314:	98 85       	ldd	r25, Y+8	; 0x08
    2316:	eb 81       	ldd	r30, Y+3	; 0x03
    2318:	fc 81       	ldd	r31, Y+4	; 0x04
    231a:	93 83       	std	Z+3, r25	; 0x03
    231c:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    231e:	ef 81       	ldd	r30, Y+7	; 0x07
    2320:	f8 85       	ldd	r31, Y+8	; 0x08
    2322:	8d 81       	ldd	r24, Y+5	; 0x05
    2324:	9e 81       	ldd	r25, Y+6	; 0x06
    2326:	91 87       	std	Z+9, r25	; 0x09
    2328:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    232a:	ed 81       	ldd	r30, Y+5	; 0x05
    232c:	fe 81       	ldd	r31, Y+6	; 0x06
    232e:	80 81       	ld	r24, Z
    2330:	8f 5f       	subi	r24, 0xFF	; 255
    2332:	ed 81       	ldd	r30, Y+5	; 0x05
    2334:	fe 81       	ldd	r31, Y+6	; 0x06
    2336:	80 83       	st	Z, r24
}
    2338:	28 96       	adiw	r28, 0x08	; 8
    233a:	0f b6       	in	r0, 0x3f	; 63
    233c:	f8 94       	cli
    233e:	de bf       	out	0x3e, r29	; 62
    2340:	0f be       	out	0x3f, r0	; 63
    2342:	cd bf       	out	0x3d, r28	; 61
    2344:	cf 91       	pop	r28
    2346:	df 91       	pop	r29
    2348:	08 95       	ret

0000234a <uxListRemove>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
{
    234a:	df 93       	push	r29
    234c:	cf 93       	push	r28
    234e:	00 d0       	rcall	.+0      	; 0x2350 <uxListRemove+0x6>
    2350:	0f 92       	push	r0
    2352:	cd b7       	in	r28, 0x3d	; 61
    2354:	de b7       	in	r29, 0x3e	; 62
    2356:	9c 83       	std	Y+4, r25	; 0x04
    2358:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    235a:	eb 81       	ldd	r30, Y+3	; 0x03
    235c:	fc 81       	ldd	r31, Y+4	; 0x04
    235e:	a2 81       	ldd	r26, Z+2	; 0x02
    2360:	b3 81       	ldd	r27, Z+3	; 0x03
    2362:	eb 81       	ldd	r30, Y+3	; 0x03
    2364:	fc 81       	ldd	r31, Y+4	; 0x04
    2366:	84 81       	ldd	r24, Z+4	; 0x04
    2368:	95 81       	ldd	r25, Z+5	; 0x05
    236a:	15 96       	adiw	r26, 0x05	; 5
    236c:	9c 93       	st	X, r25
    236e:	8e 93       	st	-X, r24
    2370:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2372:	eb 81       	ldd	r30, Y+3	; 0x03
    2374:	fc 81       	ldd	r31, Y+4	; 0x04
    2376:	a4 81       	ldd	r26, Z+4	; 0x04
    2378:	b5 81       	ldd	r27, Z+5	; 0x05
    237a:	eb 81       	ldd	r30, Y+3	; 0x03
    237c:	fc 81       	ldd	r31, Y+4	; 0x04
    237e:	82 81       	ldd	r24, Z+2	; 0x02
    2380:	93 81       	ldd	r25, Z+3	; 0x03
    2382:	13 96       	adiw	r26, 0x03	; 3
    2384:	9c 93       	st	X, r25
    2386:	8e 93       	st	-X, r24
    2388:	12 97       	sbiw	r26, 0x02	; 2

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    238a:	eb 81       	ldd	r30, Y+3	; 0x03
    238c:	fc 81       	ldd	r31, Y+4	; 0x04
    238e:	80 85       	ldd	r24, Z+8	; 0x08
    2390:	91 85       	ldd	r25, Z+9	; 0x09
    2392:	9a 83       	std	Y+2, r25	; 0x02
    2394:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2396:	e9 81       	ldd	r30, Y+1	; 0x01
    2398:	fa 81       	ldd	r31, Y+2	; 0x02
    239a:	21 81       	ldd	r18, Z+1	; 0x01
    239c:	32 81       	ldd	r19, Z+2	; 0x02
    239e:	8b 81       	ldd	r24, Y+3	; 0x03
    23a0:	9c 81       	ldd	r25, Y+4	; 0x04
    23a2:	28 17       	cp	r18, r24
    23a4:	39 07       	cpc	r19, r25
    23a6:	41 f4       	brne	.+16     	; 0x23b8 <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    23a8:	eb 81       	ldd	r30, Y+3	; 0x03
    23aa:	fc 81       	ldd	r31, Y+4	; 0x04
    23ac:	84 81       	ldd	r24, Z+4	; 0x04
    23ae:	95 81       	ldd	r25, Z+5	; 0x05
    23b0:	e9 81       	ldd	r30, Y+1	; 0x01
    23b2:	fa 81       	ldd	r31, Y+2	; 0x02
    23b4:	92 83       	std	Z+2, r25	; 0x02
    23b6:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    23b8:	eb 81       	ldd	r30, Y+3	; 0x03
    23ba:	fc 81       	ldd	r31, Y+4	; 0x04
    23bc:	11 86       	std	Z+9, r1	; 0x09
    23be:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    23c0:	e9 81       	ldd	r30, Y+1	; 0x01
    23c2:	fa 81       	ldd	r31, Y+2	; 0x02
    23c4:	80 81       	ld	r24, Z
    23c6:	81 50       	subi	r24, 0x01	; 1
    23c8:	e9 81       	ldd	r30, Y+1	; 0x01
    23ca:	fa 81       	ldd	r31, Y+2	; 0x02
    23cc:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    23ce:	e9 81       	ldd	r30, Y+1	; 0x01
    23d0:	fa 81       	ldd	r31, Y+2	; 0x02
    23d2:	80 81       	ld	r24, Z
}
    23d4:	0f 90       	pop	r0
    23d6:	0f 90       	pop	r0
    23d8:	0f 90       	pop	r0
    23da:	0f 90       	pop	r0
    23dc:	cf 91       	pop	r28
    23de:	df 91       	pop	r29
    23e0:	08 95       	ret

000023e2 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    23e2:	df 93       	push	r29
    23e4:	cf 93       	push	r28
    23e6:	cd b7       	in	r28, 0x3d	; 61
    23e8:	de b7       	in	r29, 0x3e	; 62
    23ea:	27 97       	sbiw	r28, 0x07	; 7
    23ec:	0f b6       	in	r0, 0x3f	; 63
    23ee:	f8 94       	cli
    23f0:	de bf       	out	0x3e, r29	; 62
    23f2:	0f be       	out	0x3f, r0	; 63
    23f4:	cd bf       	out	0x3d, r28	; 61
    23f6:	9d 83       	std	Y+5, r25	; 0x05
    23f8:	8c 83       	std	Y+4, r24	; 0x04
    23fa:	6e 83       	std	Y+6, r22	; 0x06
    23fc:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    23fe:	8a e1       	ldi	r24, 0x1A	; 26
    2400:	90 e0       	ldi	r25, 0x00	; 0
    2402:	0e 94 ca 14 	call	0x2994	; 0x2994 <pvPortMalloc>
    2406:	9a 83       	std	Y+2, r25	; 0x02
    2408:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
    240a:	89 81       	ldd	r24, Y+1	; 0x01
    240c:	9a 81       	ldd	r25, Y+2	; 0x02
    240e:	00 97       	sbiw	r24, 0x00	; 0
    2410:	09 f4       	brne	.+2      	; 0x2414 <xCoRoutineCreate+0x32>
    2412:	6f c0       	rjmp	.+222    	; 0x24f2 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    2414:	80 91 7f 02 	lds	r24, 0x027F
    2418:	90 91 80 02 	lds	r25, 0x0280
    241c:	00 97       	sbiw	r24, 0x00	; 0
    241e:	41 f4       	brne	.+16     	; 0x2430 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    2420:	89 81       	ldd	r24, Y+1	; 0x01
    2422:	9a 81       	ldd	r25, Y+2	; 0x02
    2424:	90 93 80 02 	sts	0x0280, r25
    2428:	80 93 7f 02 	sts	0x027F, r24
			prvInitialiseCoRoutineLists();
    242c:	0e 94 59 14 	call	0x28b2	; 0x28b2 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    2430:	8e 81       	ldd	r24, Y+6	; 0x06
    2432:	82 30       	cpi	r24, 0x02	; 2
    2434:	10 f0       	brcs	.+4      	; 0x243a <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    2436:	81 e0       	ldi	r24, 0x01	; 1
    2438:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    243a:	e9 81       	ldd	r30, Y+1	; 0x01
    243c:	fa 81       	ldd	r31, Y+2	; 0x02
    243e:	11 8e       	std	Z+25, r1	; 0x19
    2440:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    2442:	e9 81       	ldd	r30, Y+1	; 0x01
    2444:	fa 81       	ldd	r31, Y+2	; 0x02
    2446:	8e 81       	ldd	r24, Y+6	; 0x06
    2448:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    244a:	e9 81       	ldd	r30, Y+1	; 0x01
    244c:	fa 81       	ldd	r31, Y+2	; 0x02
    244e:	8f 81       	ldd	r24, Y+7	; 0x07
    2450:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    2452:	e9 81       	ldd	r30, Y+1	; 0x01
    2454:	fa 81       	ldd	r31, Y+2	; 0x02
    2456:	8c 81       	ldd	r24, Y+4	; 0x04
    2458:	9d 81       	ldd	r25, Y+5	; 0x05
    245a:	91 83       	std	Z+1, r25	; 0x01
    245c:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    245e:	89 81       	ldd	r24, Y+1	; 0x01
    2460:	9a 81       	ldd	r25, Y+2	; 0x02
    2462:	02 96       	adiw	r24, 0x02	; 2
    2464:	0e 94 dd 10 	call	0x21ba	; 0x21ba <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    2468:	89 81       	ldd	r24, Y+1	; 0x01
    246a:	9a 81       	ldd	r25, Y+2	; 0x02
    246c:	0c 96       	adiw	r24, 0x0c	; 12
    246e:	0e 94 dd 10 	call	0x21ba	; 0x21ba <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    2472:	e9 81       	ldd	r30, Y+1	; 0x01
    2474:	fa 81       	ldd	r31, Y+2	; 0x02
    2476:	89 81       	ldd	r24, Y+1	; 0x01
    2478:	9a 81       	ldd	r25, Y+2	; 0x02
    247a:	91 87       	std	Z+9, r25	; 0x09
    247c:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    247e:	e9 81       	ldd	r30, Y+1	; 0x01
    2480:	fa 81       	ldd	r31, Y+2	; 0x02
    2482:	89 81       	ldd	r24, Y+1	; 0x01
    2484:	9a 81       	ldd	r25, Y+2	; 0x02
    2486:	93 8b       	std	Z+19, r25	; 0x13
    2488:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    248a:	8e 81       	ldd	r24, Y+6	; 0x06
    248c:	28 2f       	mov	r18, r24
    248e:	30 e0       	ldi	r19, 0x00	; 0
    2490:	84 e0       	ldi	r24, 0x04	; 4
    2492:	90 e0       	ldi	r25, 0x00	; 0
    2494:	82 1b       	sub	r24, r18
    2496:	93 0b       	sbc	r25, r19
    2498:	e9 81       	ldd	r30, Y+1	; 0x01
    249a:	fa 81       	ldd	r31, Y+2	; 0x02
    249c:	95 87       	std	Z+13, r25	; 0x0d
    249e:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    24a0:	e9 81       	ldd	r30, Y+1	; 0x01
    24a2:	fa 81       	ldd	r31, Y+2	; 0x02
    24a4:	96 89       	ldd	r25, Z+22	; 0x16
    24a6:	80 91 81 02 	lds	r24, 0x0281
    24aa:	89 17       	cp	r24, r25
    24ac:	28 f4       	brcc	.+10     	; 0x24b8 <xCoRoutineCreate+0xd6>
    24ae:	e9 81       	ldd	r30, Y+1	; 0x01
    24b0:	fa 81       	ldd	r31, Y+2	; 0x02
    24b2:	86 89       	ldd	r24, Z+22	; 0x16
    24b4:	80 93 81 02 	sts	0x0281, r24
    24b8:	e9 81       	ldd	r30, Y+1	; 0x01
    24ba:	fa 81       	ldd	r31, Y+2	; 0x02
    24bc:	86 89       	ldd	r24, Z+22	; 0x16
    24be:	28 2f       	mov	r18, r24
    24c0:	30 e0       	ldi	r19, 0x00	; 0
    24c2:	c9 01       	movw	r24, r18
    24c4:	88 0f       	add	r24, r24
    24c6:	99 1f       	adc	r25, r25
    24c8:	88 0f       	add	r24, r24
    24ca:	99 1f       	adc	r25, r25
    24cc:	88 0f       	add	r24, r24
    24ce:	99 1f       	adc	r25, r25
    24d0:	82 0f       	add	r24, r18
    24d2:	93 1f       	adc	r25, r19
    24d4:	ac 01       	movw	r20, r24
    24d6:	48 57       	subi	r20, 0x78	; 120
    24d8:	5d 4f       	sbci	r21, 0xFD	; 253
    24da:	89 81       	ldd	r24, Y+1	; 0x01
    24dc:	9a 81       	ldd	r25, Y+2	; 0x02
    24de:	9c 01       	movw	r18, r24
    24e0:	2e 5f       	subi	r18, 0xFE	; 254
    24e2:	3f 4f       	sbci	r19, 0xFF	; 255
    24e4:	ca 01       	movw	r24, r20
    24e6:	b9 01       	movw	r22, r18
    24e8:	0e 94 ee 10 	call	0x21dc	; 0x21dc <vListInsertEnd>

		xReturn = pdPASS;
    24ec:	81 e0       	ldi	r24, 0x01	; 1
    24ee:	8b 83       	std	Y+3, r24	; 0x03
    24f0:	02 c0       	rjmp	.+4      	; 0x24f6 <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    24f2:	8f ef       	ldi	r24, 0xFF	; 255
    24f4:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
    24f6:	8b 81       	ldd	r24, Y+3	; 0x03
}
    24f8:	27 96       	adiw	r28, 0x07	; 7
    24fa:	0f b6       	in	r0, 0x3f	; 63
    24fc:	f8 94       	cli
    24fe:	de bf       	out	0x3e, r29	; 62
    2500:	0f be       	out	0x3f, r0	; 63
    2502:	cd bf       	out	0x3d, r28	; 61
    2504:	cf 91       	pop	r28
    2506:	df 91       	pop	r29
    2508:	08 95       	ret

0000250a <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    250a:	df 93       	push	r29
    250c:	cf 93       	push	r28
    250e:	00 d0       	rcall	.+0      	; 0x2510 <vCoRoutineAddToDelayedList+0x6>
    2510:	00 d0       	rcall	.+0      	; 0x2512 <vCoRoutineAddToDelayedList+0x8>
    2512:	cd b7       	in	r28, 0x3d	; 61
    2514:	de b7       	in	r29, 0x3e	; 62
    2516:	9c 83       	std	Y+4, r25	; 0x04
    2518:	8b 83       	std	Y+3, r24	; 0x03
    251a:	7e 83       	std	Y+6, r23	; 0x06
    251c:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    251e:	20 91 82 02 	lds	r18, 0x0282
    2522:	30 91 83 02 	lds	r19, 0x0283
    2526:	8b 81       	ldd	r24, Y+3	; 0x03
    2528:	9c 81       	ldd	r25, Y+4	; 0x04
    252a:	82 0f       	add	r24, r18
    252c:	93 1f       	adc	r25, r19
    252e:	9a 83       	std	Y+2, r25	; 0x02
    2530:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2532:	80 91 7f 02 	lds	r24, 0x027F
    2536:	90 91 80 02 	lds	r25, 0x0280
    253a:	02 96       	adiw	r24, 0x02	; 2
    253c:	0e 94 a5 11 	call	0x234a	; 0x234a <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    2540:	e0 91 7f 02 	lds	r30, 0x027F
    2544:	f0 91 80 02 	lds	r31, 0x0280
    2548:	89 81       	ldd	r24, Y+1	; 0x01
    254a:	9a 81       	ldd	r25, Y+2	; 0x02
    254c:	93 83       	std	Z+3, r25	; 0x03
    254e:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    2550:	20 91 82 02 	lds	r18, 0x0282
    2554:	30 91 83 02 	lds	r19, 0x0283
    2558:	89 81       	ldd	r24, Y+1	; 0x01
    255a:	9a 81       	ldd	r25, Y+2	; 0x02
    255c:	82 17       	cp	r24, r18
    255e:	93 07       	cpc	r25, r19
    2560:	70 f4       	brcc	.+28     	; 0x257e <vCoRoutineAddToDelayedList+0x74>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2562:	80 91 ae 02 	lds	r24, 0x02AE
    2566:	90 91 af 02 	lds	r25, 0x02AF
    256a:	20 91 7f 02 	lds	r18, 0x027F
    256e:	30 91 80 02 	lds	r19, 0x0280
    2572:	2e 5f       	subi	r18, 0xFE	; 254
    2574:	3f 4f       	sbci	r19, 0xFF	; 255
    2576:	b9 01       	movw	r22, r18
    2578:	0e 94 39 11 	call	0x2272	; 0x2272 <vListInsert>
    257c:	0d c0       	rjmp	.+26     	; 0x2598 <vCoRoutineAddToDelayedList+0x8e>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    257e:	80 91 ac 02 	lds	r24, 0x02AC
    2582:	90 91 ad 02 	lds	r25, 0x02AD
    2586:	20 91 7f 02 	lds	r18, 0x027F
    258a:	30 91 80 02 	lds	r19, 0x0280
    258e:	2e 5f       	subi	r18, 0xFE	; 254
    2590:	3f 4f       	sbci	r19, 0xFF	; 255
    2592:	b9 01       	movw	r22, r18
    2594:	0e 94 39 11 	call	0x2272	; 0x2272 <vListInsert>
	}

	if( pxEventList )
    2598:	8d 81       	ldd	r24, Y+5	; 0x05
    259a:	9e 81       	ldd	r25, Y+6	; 0x06
    259c:	00 97       	sbiw	r24, 0x00	; 0
    259e:	61 f0       	breq	.+24     	; 0x25b8 <vCoRoutineAddToDelayedList+0xae>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    25a0:	80 91 7f 02 	lds	r24, 0x027F
    25a4:	90 91 80 02 	lds	r25, 0x0280
    25a8:	9c 01       	movw	r18, r24
    25aa:	24 5f       	subi	r18, 0xF4	; 244
    25ac:	3f 4f       	sbci	r19, 0xFF	; 255
    25ae:	8d 81       	ldd	r24, Y+5	; 0x05
    25b0:	9e 81       	ldd	r25, Y+6	; 0x06
    25b2:	b9 01       	movw	r22, r18
    25b4:	0e 94 39 11 	call	0x2272	; 0x2272 <vListInsert>
	}
}
    25b8:	26 96       	adiw	r28, 0x06	; 6
    25ba:	0f b6       	in	r0, 0x3f	; 63
    25bc:	f8 94       	cli
    25be:	de bf       	out	0x3e, r29	; 62
    25c0:	0f be       	out	0x3f, r0	; 63
    25c2:	cd bf       	out	0x3d, r28	; 61
    25c4:	cf 91       	pop	r28
    25c6:	df 91       	pop	r29
    25c8:	08 95       	ret

000025ca <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    25ca:	df 93       	push	r29
    25cc:	cf 93       	push	r28
    25ce:	0f 92       	push	r0
    25d0:	0f 92       	push	r0
    25d2:	cd b7       	in	r28, 0x3d	; 61
    25d4:	de b7       	in	r29, 0x3e	; 62
    25d6:	3a c0       	rjmp	.+116    	; 0x264c <prvCheckPendingReadyList+0x82>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    25d8:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    25da:	e0 91 b5 02 	lds	r30, 0x02B5
    25de:	f0 91 b6 02 	lds	r31, 0x02B6
    25e2:	86 81       	ldd	r24, Z+6	; 0x06
    25e4:	97 81       	ldd	r25, Z+7	; 0x07
    25e6:	9a 83       	std	Y+2, r25	; 0x02
    25e8:	89 83       	std	Y+1, r24	; 0x01
			uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    25ea:	89 81       	ldd	r24, Y+1	; 0x01
    25ec:	9a 81       	ldd	r25, Y+2	; 0x02
    25ee:	0c 96       	adiw	r24, 0x0c	; 12
    25f0:	0e 94 a5 11 	call	0x234a	; 0x234a <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    25f4:	78 94       	sei

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    25f6:	89 81       	ldd	r24, Y+1	; 0x01
    25f8:	9a 81       	ldd	r25, Y+2	; 0x02
    25fa:	02 96       	adiw	r24, 0x02	; 2
    25fc:	0e 94 a5 11 	call	0x234a	; 0x234a <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    2600:	e9 81       	ldd	r30, Y+1	; 0x01
    2602:	fa 81       	ldd	r31, Y+2	; 0x02
    2604:	96 89       	ldd	r25, Z+22	; 0x16
    2606:	80 91 81 02 	lds	r24, 0x0281
    260a:	89 17       	cp	r24, r25
    260c:	28 f4       	brcc	.+10     	; 0x2618 <prvCheckPendingReadyList+0x4e>
    260e:	e9 81       	ldd	r30, Y+1	; 0x01
    2610:	fa 81       	ldd	r31, Y+2	; 0x02
    2612:	86 89       	ldd	r24, Z+22	; 0x16
    2614:	80 93 81 02 	sts	0x0281, r24
    2618:	e9 81       	ldd	r30, Y+1	; 0x01
    261a:	fa 81       	ldd	r31, Y+2	; 0x02
    261c:	86 89       	ldd	r24, Z+22	; 0x16
    261e:	28 2f       	mov	r18, r24
    2620:	30 e0       	ldi	r19, 0x00	; 0
    2622:	c9 01       	movw	r24, r18
    2624:	88 0f       	add	r24, r24
    2626:	99 1f       	adc	r25, r25
    2628:	88 0f       	add	r24, r24
    262a:	99 1f       	adc	r25, r25
    262c:	88 0f       	add	r24, r24
    262e:	99 1f       	adc	r25, r25
    2630:	82 0f       	add	r24, r18
    2632:	93 1f       	adc	r25, r19
    2634:	ac 01       	movw	r20, r24
    2636:	48 57       	subi	r20, 0x78	; 120
    2638:	5d 4f       	sbci	r21, 0xFD	; 253
    263a:	89 81       	ldd	r24, Y+1	; 0x01
    263c:	9a 81       	ldd	r25, Y+2	; 0x02
    263e:	9c 01       	movw	r18, r24
    2640:	2e 5f       	subi	r18, 0xFE	; 254
    2642:	3f 4f       	sbci	r19, 0xFF	; 255
    2644:	ca 01       	movw	r24, r20
    2646:	b9 01       	movw	r22, r18
    2648:	0e 94 ee 10 	call	0x21dc	; 0x21dc <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    264c:	80 91 b0 02 	lds	r24, 0x02B0
    2650:	88 23       	and	r24, r24
    2652:	09 f0       	breq	.+2      	; 0x2656 <prvCheckPendingReadyList+0x8c>
    2654:	c1 cf       	rjmp	.-126    	; 0x25d8 <prvCheckPendingReadyList+0xe>
		portENABLE_INTERRUPTS();

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    2656:	0f 90       	pop	r0
    2658:	0f 90       	pop	r0
    265a:	cf 91       	pop	r28
    265c:	df 91       	pop	r29
    265e:	08 95       	ret

00002660 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    2660:	df 93       	push	r29
    2662:	cf 93       	push	r28
    2664:	00 d0       	rcall	.+0      	; 0x2666 <prvCheckDelayedList+0x6>
    2666:	0f 92       	push	r0
    2668:	cd b7       	in	r28, 0x3d	; 61
    266a:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    266c:	0e 94 21 06 	call	0xc42	; 0xc42 <xTaskGetTickCount>
    2670:	20 91 84 02 	lds	r18, 0x0284
    2674:	30 91 85 02 	lds	r19, 0x0285
    2678:	82 1b       	sub	r24, r18
    267a:	93 0b       	sbc	r25, r19
    267c:	90 93 87 02 	sts	0x0287, r25
    2680:	80 93 86 02 	sts	0x0286, r24
    2684:	85 c0       	rjmp	.+266    	; 0x2790 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    2686:	80 91 82 02 	lds	r24, 0x0282
    268a:	90 91 83 02 	lds	r25, 0x0283
    268e:	01 96       	adiw	r24, 0x01	; 1
    2690:	90 93 83 02 	sts	0x0283, r25
    2694:	80 93 82 02 	sts	0x0282, r24
		xPassedTicks--;
    2698:	80 91 86 02 	lds	r24, 0x0286
    269c:	90 91 87 02 	lds	r25, 0x0287
    26a0:	01 97       	sbiw	r24, 0x01	; 1
    26a2:	90 93 87 02 	sts	0x0287, r25
    26a6:	80 93 86 02 	sts	0x0286, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    26aa:	80 91 82 02 	lds	r24, 0x0282
    26ae:	90 91 83 02 	lds	r25, 0x0283
    26b2:	00 97       	sbiw	r24, 0x00	; 0
    26b4:	09 f0       	breq	.+2      	; 0x26b8 <prvCheckDelayedList+0x58>
    26b6:	64 c0       	rjmp	.+200    	; 0x2780 <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    26b8:	80 91 ac 02 	lds	r24, 0x02AC
    26bc:	90 91 ad 02 	lds	r25, 0x02AD
    26c0:	9a 83       	std	Y+2, r25	; 0x02
    26c2:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    26c4:	80 91 ae 02 	lds	r24, 0x02AE
    26c8:	90 91 af 02 	lds	r25, 0x02AF
    26cc:	90 93 ad 02 	sts	0x02AD, r25
    26d0:	80 93 ac 02 	sts	0x02AC, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    26d4:	89 81       	ldd	r24, Y+1	; 0x01
    26d6:	9a 81       	ldd	r25, Y+2	; 0x02
    26d8:	90 93 af 02 	sts	0x02AF, r25
    26dc:	80 93 ae 02 	sts	0x02AE, r24
    26e0:	4f c0       	rjmp	.+158    	; 0x2780 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    26e2:	e0 91 ac 02 	lds	r30, 0x02AC
    26e6:	f0 91 ad 02 	lds	r31, 0x02AD
    26ea:	05 80       	ldd	r0, Z+5	; 0x05
    26ec:	f6 81       	ldd	r31, Z+6	; 0x06
    26ee:	e0 2d       	mov	r30, r0
    26f0:	86 81       	ldd	r24, Z+6	; 0x06
    26f2:	97 81       	ldd	r25, Z+7	; 0x07
    26f4:	9c 83       	std	Y+4, r25	; 0x04
    26f6:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    26f8:	eb 81       	ldd	r30, Y+3	; 0x03
    26fa:	fc 81       	ldd	r31, Y+4	; 0x04
    26fc:	22 81       	ldd	r18, Z+2	; 0x02
    26fe:	33 81       	ldd	r19, Z+3	; 0x03
    2700:	80 91 82 02 	lds	r24, 0x0282
    2704:	90 91 83 02 	lds	r25, 0x0283
    2708:	82 17       	cp	r24, r18
    270a:	93 07       	cpc	r25, r19
    270c:	08 f4       	brcc	.+2      	; 0x2710 <prvCheckDelayedList+0xb0>
    270e:	40 c0       	rjmp	.+128    	; 0x2790 <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    2710:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				uxListRemove( &( pxCRCB->xGenericListItem ) );											
    2712:	8b 81       	ldd	r24, Y+3	; 0x03
    2714:	9c 81       	ldd	r25, Y+4	; 0x04
    2716:	02 96       	adiw	r24, 0x02	; 2
    2718:	0e 94 a5 11 	call	0x234a	; 0x234a <uxListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    271c:	eb 81       	ldd	r30, Y+3	; 0x03
    271e:	fc 81       	ldd	r31, Y+4	; 0x04
    2720:	84 89       	ldd	r24, Z+20	; 0x14
    2722:	95 89       	ldd	r25, Z+21	; 0x15
    2724:	00 97       	sbiw	r24, 0x00	; 0
    2726:	29 f0       	breq	.+10     	; 0x2732 <prvCheckDelayedList+0xd2>
				{															
					uxListRemove( &( pxCRCB->xEventListItem ) );											
    2728:	8b 81       	ldd	r24, Y+3	; 0x03
    272a:	9c 81       	ldd	r25, Y+4	; 0x04
    272c:	0c 96       	adiw	r24, 0x0c	; 12
    272e:	0e 94 a5 11 	call	0x234a	; 0x234a <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    2732:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    2734:	eb 81       	ldd	r30, Y+3	; 0x03
    2736:	fc 81       	ldd	r31, Y+4	; 0x04
    2738:	96 89       	ldd	r25, Z+22	; 0x16
    273a:	80 91 81 02 	lds	r24, 0x0281
    273e:	89 17       	cp	r24, r25
    2740:	28 f4       	brcc	.+10     	; 0x274c <prvCheckDelayedList+0xec>
    2742:	eb 81       	ldd	r30, Y+3	; 0x03
    2744:	fc 81       	ldd	r31, Y+4	; 0x04
    2746:	86 89       	ldd	r24, Z+22	; 0x16
    2748:	80 93 81 02 	sts	0x0281, r24
    274c:	eb 81       	ldd	r30, Y+3	; 0x03
    274e:	fc 81       	ldd	r31, Y+4	; 0x04
    2750:	86 89       	ldd	r24, Z+22	; 0x16
    2752:	28 2f       	mov	r18, r24
    2754:	30 e0       	ldi	r19, 0x00	; 0
    2756:	c9 01       	movw	r24, r18
    2758:	88 0f       	add	r24, r24
    275a:	99 1f       	adc	r25, r25
    275c:	88 0f       	add	r24, r24
    275e:	99 1f       	adc	r25, r25
    2760:	88 0f       	add	r24, r24
    2762:	99 1f       	adc	r25, r25
    2764:	82 0f       	add	r24, r18
    2766:	93 1f       	adc	r25, r19
    2768:	ac 01       	movw	r20, r24
    276a:	48 57       	subi	r20, 0x78	; 120
    276c:	5d 4f       	sbci	r21, 0xFD	; 253
    276e:	8b 81       	ldd	r24, Y+3	; 0x03
    2770:	9c 81       	ldd	r25, Y+4	; 0x04
    2772:	9c 01       	movw	r18, r24
    2774:	2e 5f       	subi	r18, 0xFE	; 254
    2776:	3f 4f       	sbci	r19, 0xFF	; 255
    2778:	ca 01       	movw	r24, r20
    277a:	b9 01       	movw	r22, r18
    277c:	0e 94 ee 10 	call	0x21dc	; 0x21dc <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    2780:	e0 91 ac 02 	lds	r30, 0x02AC
    2784:	f0 91 ad 02 	lds	r31, 0x02AD
    2788:	80 81       	ld	r24, Z
    278a:	88 23       	and	r24, r24
    278c:	09 f0       	breq	.+2      	; 0x2790 <prvCheckDelayedList+0x130>
    278e:	a9 cf       	rjmp	.-174    	; 0x26e2 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    2790:	80 91 86 02 	lds	r24, 0x0286
    2794:	90 91 87 02 	lds	r25, 0x0287
    2798:	00 97       	sbiw	r24, 0x00	; 0
    279a:	09 f0       	breq	.+2      	; 0x279e <prvCheckDelayedList+0x13e>
    279c:	74 cf       	rjmp	.-280    	; 0x2686 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    279e:	80 91 82 02 	lds	r24, 0x0282
    27a2:	90 91 83 02 	lds	r25, 0x0283
    27a6:	90 93 85 02 	sts	0x0285, r25
    27aa:	80 93 84 02 	sts	0x0284, r24
}
    27ae:	0f 90       	pop	r0
    27b0:	0f 90       	pop	r0
    27b2:	0f 90       	pop	r0
    27b4:	0f 90       	pop	r0
    27b6:	cf 91       	pop	r28
    27b8:	df 91       	pop	r29
    27ba:	08 95       	ret

000027bc <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    27bc:	df 93       	push	r29
    27be:	cf 93       	push	r28
    27c0:	0f 92       	push	r0
    27c2:	0f 92       	push	r0
    27c4:	cd b7       	in	r28, 0x3d	; 61
    27c6:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    27c8:	0e 94 e5 12 	call	0x25ca	; 0x25ca <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    27cc:	0e 94 30 13 	call	0x2660	; 0x2660 <prvCheckDelayedList>
    27d0:	0a c0       	rjmp	.+20     	; 0x27e6 <vCoRoutineSchedule+0x2a>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    27d2:	80 91 81 02 	lds	r24, 0x0281
    27d6:	88 23       	and	r24, r24
    27d8:	09 f4       	brne	.+2      	; 0x27dc <vCoRoutineSchedule+0x20>
    27da:	66 c0       	rjmp	.+204    	; 0x28a8 <vCoRoutineSchedule+0xec>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    27dc:	80 91 81 02 	lds	r24, 0x0281
    27e0:	81 50       	subi	r24, 0x01	; 1
    27e2:	80 93 81 02 	sts	0x0281, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    27e6:	80 91 81 02 	lds	r24, 0x0281
    27ea:	28 2f       	mov	r18, r24
    27ec:	30 e0       	ldi	r19, 0x00	; 0
    27ee:	c9 01       	movw	r24, r18
    27f0:	88 0f       	add	r24, r24
    27f2:	99 1f       	adc	r25, r25
    27f4:	88 0f       	add	r24, r24
    27f6:	99 1f       	adc	r25, r25
    27f8:	88 0f       	add	r24, r24
    27fa:	99 1f       	adc	r25, r25
    27fc:	82 0f       	add	r24, r18
    27fe:	93 1f       	adc	r25, r19
    2800:	fc 01       	movw	r30, r24
    2802:	e8 57       	subi	r30, 0x78	; 120
    2804:	fd 4f       	sbci	r31, 0xFD	; 253
    2806:	80 81       	ld	r24, Z
    2808:	88 23       	and	r24, r24
    280a:	19 f3       	breq	.-58     	; 0x27d2 <vCoRoutineSchedule+0x16>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    280c:	80 91 81 02 	lds	r24, 0x0281
    2810:	28 2f       	mov	r18, r24
    2812:	30 e0       	ldi	r19, 0x00	; 0
    2814:	c9 01       	movw	r24, r18
    2816:	88 0f       	add	r24, r24
    2818:	99 1f       	adc	r25, r25
    281a:	88 0f       	add	r24, r24
    281c:	99 1f       	adc	r25, r25
    281e:	88 0f       	add	r24, r24
    2820:	99 1f       	adc	r25, r25
    2822:	82 0f       	add	r24, r18
    2824:	93 1f       	adc	r25, r19
    2826:	88 57       	subi	r24, 0x78	; 120
    2828:	9d 4f       	sbci	r25, 0xFD	; 253
    282a:	9a 83       	std	Y+2, r25	; 0x02
    282c:	89 83       	std	Y+1, r24	; 0x01
    282e:	e9 81       	ldd	r30, Y+1	; 0x01
    2830:	fa 81       	ldd	r31, Y+2	; 0x02
    2832:	01 80       	ldd	r0, Z+1	; 0x01
    2834:	f2 81       	ldd	r31, Z+2	; 0x02
    2836:	e0 2d       	mov	r30, r0
    2838:	82 81       	ldd	r24, Z+2	; 0x02
    283a:	93 81       	ldd	r25, Z+3	; 0x03
    283c:	e9 81       	ldd	r30, Y+1	; 0x01
    283e:	fa 81       	ldd	r31, Y+2	; 0x02
    2840:	92 83       	std	Z+2, r25	; 0x02
    2842:	81 83       	std	Z+1, r24	; 0x01
    2844:	e9 81       	ldd	r30, Y+1	; 0x01
    2846:	fa 81       	ldd	r31, Y+2	; 0x02
    2848:	21 81       	ldd	r18, Z+1	; 0x01
    284a:	32 81       	ldd	r19, Z+2	; 0x02
    284c:	89 81       	ldd	r24, Y+1	; 0x01
    284e:	9a 81       	ldd	r25, Y+2	; 0x02
    2850:	03 96       	adiw	r24, 0x03	; 3
    2852:	28 17       	cp	r18, r24
    2854:	39 07       	cpc	r19, r25
    2856:	59 f4       	brne	.+22     	; 0x286e <vCoRoutineSchedule+0xb2>
    2858:	e9 81       	ldd	r30, Y+1	; 0x01
    285a:	fa 81       	ldd	r31, Y+2	; 0x02
    285c:	01 80       	ldd	r0, Z+1	; 0x01
    285e:	f2 81       	ldd	r31, Z+2	; 0x02
    2860:	e0 2d       	mov	r30, r0
    2862:	82 81       	ldd	r24, Z+2	; 0x02
    2864:	93 81       	ldd	r25, Z+3	; 0x03
    2866:	e9 81       	ldd	r30, Y+1	; 0x01
    2868:	fa 81       	ldd	r31, Y+2	; 0x02
    286a:	92 83       	std	Z+2, r25	; 0x02
    286c:	81 83       	std	Z+1, r24	; 0x01
    286e:	e9 81       	ldd	r30, Y+1	; 0x01
    2870:	fa 81       	ldd	r31, Y+2	; 0x02
    2872:	01 80       	ldd	r0, Z+1	; 0x01
    2874:	f2 81       	ldd	r31, Z+2	; 0x02
    2876:	e0 2d       	mov	r30, r0
    2878:	86 81       	ldd	r24, Z+6	; 0x06
    287a:	97 81       	ldd	r25, Z+7	; 0x07
    287c:	90 93 80 02 	sts	0x0280, r25
    2880:	80 93 7f 02 	sts	0x027F, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2884:	e0 91 7f 02 	lds	r30, 0x027F
    2888:	f0 91 80 02 	lds	r31, 0x0280
    288c:	40 81       	ld	r20, Z
    288e:	51 81       	ldd	r21, Z+1	; 0x01
    2890:	80 91 7f 02 	lds	r24, 0x027F
    2894:	90 91 80 02 	lds	r25, 0x0280
    2898:	e0 91 7f 02 	lds	r30, 0x027F
    289c:	f0 91 80 02 	lds	r31, 0x0280
    28a0:	27 89       	ldd	r18, Z+23	; 0x17
    28a2:	62 2f       	mov	r22, r18
    28a4:	fa 01       	movw	r30, r20
    28a6:	19 95       	eicall

	return;
}
    28a8:	0f 90       	pop	r0
    28aa:	0f 90       	pop	r0
    28ac:	cf 91       	pop	r28
    28ae:	df 91       	pop	r29
    28b0:	08 95       	ret

000028b2 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    28b2:	df 93       	push	r29
    28b4:	cf 93       	push	r28
    28b6:	0f 92       	push	r0
    28b8:	cd b7       	in	r28, 0x3d	; 61
    28ba:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    28bc:	19 82       	std	Y+1, r1	; 0x01
    28be:	13 c0       	rjmp	.+38     	; 0x28e6 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    28c0:	89 81       	ldd	r24, Y+1	; 0x01
    28c2:	28 2f       	mov	r18, r24
    28c4:	30 e0       	ldi	r19, 0x00	; 0
    28c6:	c9 01       	movw	r24, r18
    28c8:	88 0f       	add	r24, r24
    28ca:	99 1f       	adc	r25, r25
    28cc:	88 0f       	add	r24, r24
    28ce:	99 1f       	adc	r25, r25
    28d0:	88 0f       	add	r24, r24
    28d2:	99 1f       	adc	r25, r25
    28d4:	82 0f       	add	r24, r18
    28d6:	93 1f       	adc	r25, r19
    28d8:	88 57       	subi	r24, 0x78	; 120
    28da:	9d 4f       	sbci	r25, 0xFD	; 253
    28dc:	0e 94 b2 10 	call	0x2164	; 0x2164 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    28e0:	89 81       	ldd	r24, Y+1	; 0x01
    28e2:	8f 5f       	subi	r24, 0xFF	; 255
    28e4:	89 83       	std	Y+1, r24	; 0x01
    28e6:	89 81       	ldd	r24, Y+1	; 0x01
    28e8:	82 30       	cpi	r24, 0x02	; 2
    28ea:	50 f3       	brcs	.-44     	; 0x28c0 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    28ec:	8a e9       	ldi	r24, 0x9A	; 154
    28ee:	92 e0       	ldi	r25, 0x02	; 2
    28f0:	0e 94 b2 10 	call	0x2164	; 0x2164 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    28f4:	83 ea       	ldi	r24, 0xA3	; 163
    28f6:	92 e0       	ldi	r25, 0x02	; 2
    28f8:	0e 94 b2 10 	call	0x2164	; 0x2164 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    28fc:	80 eb       	ldi	r24, 0xB0	; 176
    28fe:	92 e0       	ldi	r25, 0x02	; 2
    2900:	0e 94 b2 10 	call	0x2164	; 0x2164 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    2904:	8a e9       	ldi	r24, 0x9A	; 154
    2906:	92 e0       	ldi	r25, 0x02	; 2
    2908:	90 93 ad 02 	sts	0x02AD, r25
    290c:	80 93 ac 02 	sts	0x02AC, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    2910:	83 ea       	ldi	r24, 0xA3	; 163
    2912:	92 e0       	ldi	r25, 0x02	; 2
    2914:	90 93 af 02 	sts	0x02AF, r25
    2918:	80 93 ae 02 	sts	0x02AE, r24
}
    291c:	0f 90       	pop	r0
    291e:	cf 91       	pop	r28
    2920:	df 91       	pop	r29
    2922:	08 95       	ret

00002924 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    2924:	df 93       	push	r29
    2926:	cf 93       	push	r28
    2928:	00 d0       	rcall	.+0      	; 0x292a <xCoRoutineRemoveFromEventList+0x6>
    292a:	0f 92       	push	r0
    292c:	0f 92       	push	r0
    292e:	cd b7       	in	r28, 0x3d	; 61
    2930:	de b7       	in	r29, 0x3e	; 62
    2932:	9d 83       	std	Y+5, r25	; 0x05
    2934:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2936:	ec 81       	ldd	r30, Y+4	; 0x04
    2938:	fd 81       	ldd	r31, Y+5	; 0x05
    293a:	05 80       	ldd	r0, Z+5	; 0x05
    293c:	f6 81       	ldd	r31, Z+6	; 0x06
    293e:	e0 2d       	mov	r30, r0
    2940:	86 81       	ldd	r24, Z+6	; 0x06
    2942:	97 81       	ldd	r25, Z+7	; 0x07
    2944:	9b 83       	std	Y+3, r25	; 0x03
    2946:	8a 83       	std	Y+2, r24	; 0x02
	uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2948:	8a 81       	ldd	r24, Y+2	; 0x02
    294a:	9b 81       	ldd	r25, Y+3	; 0x03
    294c:	0c 96       	adiw	r24, 0x0c	; 12
    294e:	0e 94 a5 11 	call	0x234a	; 0x234a <uxListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    2952:	8a 81       	ldd	r24, Y+2	; 0x02
    2954:	9b 81       	ldd	r25, Y+3	; 0x03
    2956:	9c 01       	movw	r18, r24
    2958:	24 5f       	subi	r18, 0xF4	; 244
    295a:	3f 4f       	sbci	r19, 0xFF	; 255
    295c:	80 eb       	ldi	r24, 0xB0	; 176
    295e:	92 e0       	ldi	r25, 0x02	; 2
    2960:	b9 01       	movw	r22, r18
    2962:	0e 94 ee 10 	call	0x21dc	; 0x21dc <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    2966:	ea 81       	ldd	r30, Y+2	; 0x02
    2968:	fb 81       	ldd	r31, Y+3	; 0x03
    296a:	96 89       	ldd	r25, Z+22	; 0x16
    296c:	e0 91 7f 02 	lds	r30, 0x027F
    2970:	f0 91 80 02 	lds	r31, 0x0280
    2974:	86 89       	ldd	r24, Z+22	; 0x16
    2976:	98 17       	cp	r25, r24
    2978:	18 f0       	brcs	.+6      	; 0x2980 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    297a:	81 e0       	ldi	r24, 0x01	; 1
    297c:	89 83       	std	Y+1, r24	; 0x01
    297e:	01 c0       	rjmp	.+2      	; 0x2982 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    2980:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2982:	89 81       	ldd	r24, Y+1	; 0x01
}
    2984:	0f 90       	pop	r0
    2986:	0f 90       	pop	r0
    2988:	0f 90       	pop	r0
    298a:	0f 90       	pop	r0
    298c:	0f 90       	pop	r0
    298e:	cf 91       	pop	r28
    2990:	df 91       	pop	r29
    2992:	08 95       	ret

00002994 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2994:	df 93       	push	r29
    2996:	cf 93       	push	r28
    2998:	00 d0       	rcall	.+0      	; 0x299a <pvPortMalloc+0x6>
    299a:	0f 92       	push	r0
    299c:	cd b7       	in	r28, 0x3d	; 61
    299e:	de b7       	in	r29, 0x3e	; 62
    29a0:	9c 83       	std	Y+4, r25	; 0x04
    29a2:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    29a4:	1a 82       	std	Y+2, r1	; 0x02
    29a6:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    29a8:	0e 94 8b 05 	call	0xb16	; 0xb16 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    29ac:	80 91 b9 02 	lds	r24, 0x02B9
    29b0:	90 91 ba 02 	lds	r25, 0x02BA
    29b4:	2b 81       	ldd	r18, Y+3	; 0x03
    29b6:	3c 81       	ldd	r19, Y+4	; 0x04
    29b8:	82 0f       	add	r24, r18
    29ba:	93 1f       	adc	r25, r19
    29bc:	28 e1       	ldi	r18, 0x18	; 24
    29be:	80 30       	cpi	r24, 0x00	; 0
    29c0:	92 07       	cpc	r25, r18
    29c2:	18 f5       	brcc	.+70     	; 0x2a0a <pvPortMalloc+0x76>
    29c4:	20 91 b9 02 	lds	r18, 0x02B9
    29c8:	30 91 ba 02 	lds	r19, 0x02BA
    29cc:	8b 81       	ldd	r24, Y+3	; 0x03
    29ce:	9c 81       	ldd	r25, Y+4	; 0x04
    29d0:	28 0f       	add	r18, r24
    29d2:	39 1f       	adc	r19, r25
    29d4:	80 91 b9 02 	lds	r24, 0x02B9
    29d8:	90 91 ba 02 	lds	r25, 0x02BA
    29dc:	82 17       	cp	r24, r18
    29de:	93 07       	cpc	r25, r19
    29e0:	a0 f4       	brcc	.+40     	; 0x2a0a <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    29e2:	80 91 b9 02 	lds	r24, 0x02B9
    29e6:	90 91 ba 02 	lds	r25, 0x02BA
    29ea:	85 54       	subi	r24, 0x45	; 69
    29ec:	9d 4f       	sbci	r25, 0xFD	; 253
    29ee:	9a 83       	std	Y+2, r25	; 0x02
    29f0:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    29f2:	20 91 b9 02 	lds	r18, 0x02B9
    29f6:	30 91 ba 02 	lds	r19, 0x02BA
    29fa:	8b 81       	ldd	r24, Y+3	; 0x03
    29fc:	9c 81       	ldd	r25, Y+4	; 0x04
    29fe:	82 0f       	add	r24, r18
    2a00:	93 1f       	adc	r25, r19
    2a02:	90 93 ba 02 	sts	0x02BA, r25
    2a06:	80 93 b9 02 	sts	0x02B9, r24
		}
	}
	xTaskResumeAll();
    2a0a:	0e 94 97 05 	call	0xb2e	; 0xb2e <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    2a0e:	89 81       	ldd	r24, Y+1	; 0x01
    2a10:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2a12:	0f 90       	pop	r0
    2a14:	0f 90       	pop	r0
    2a16:	0f 90       	pop	r0
    2a18:	0f 90       	pop	r0
    2a1a:	cf 91       	pop	r28
    2a1c:	df 91       	pop	r29
    2a1e:	08 95       	ret

00002a20 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2a20:	df 93       	push	r29
    2a22:	cf 93       	push	r28
    2a24:	0f 92       	push	r0
    2a26:	0f 92       	push	r0
    2a28:	cd b7       	in	r28, 0x3d	; 61
    2a2a:	de b7       	in	r29, 0x3e	; 62
    2a2c:	9a 83       	std	Y+2, r25	; 0x02
    2a2e:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    2a30:	0f 90       	pop	r0
    2a32:	0f 90       	pop	r0
    2a34:	cf 91       	pop	r28
    2a36:	df 91       	pop	r29
    2a38:	08 95       	ret

00002a3a <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    2a3a:	df 93       	push	r29
    2a3c:	cf 93       	push	r28
    2a3e:	cd b7       	in	r28, 0x3d	; 61
    2a40:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    2a42:	10 92 ba 02 	sts	0x02BA, r1
    2a46:	10 92 b9 02 	sts	0x02B9, r1
}
    2a4a:	cf 91       	pop	r28
    2a4c:	df 91       	pop	r29
    2a4e:	08 95       	ret

00002a50 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    2a50:	df 93       	push	r29
    2a52:	cf 93       	push	r28
    2a54:	cd b7       	in	r28, 0x3d	; 61
    2a56:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    2a58:	20 91 b9 02 	lds	r18, 0x02B9
    2a5c:	30 91 ba 02 	lds	r19, 0x02BA
    2a60:	80 e0       	ldi	r24, 0x00	; 0
    2a62:	98 e1       	ldi	r25, 0x18	; 24
    2a64:	82 1b       	sub	r24, r18
    2a66:	93 0b       	sbc	r25, r19
}
    2a68:	cf 91       	pop	r28
    2a6a:	df 91       	pop	r29
    2a6c:	08 95       	ret

00002a6e <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    2a6e:	df 93       	push	r29
    2a70:	cf 93       	push	r28
    2a72:	cd b7       	in	r28, 0x3d	; 61
    2a74:	de b7       	in	r29, 0x3e	; 62
    2a76:	28 97       	sbiw	r28, 0x08	; 8
    2a78:	0f b6       	in	r0, 0x3f	; 63
    2a7a:	f8 94       	cli
    2a7c:	de bf       	out	0x3e, r29	; 62
    2a7e:	0f be       	out	0x3f, r0	; 63
    2a80:	cd bf       	out	0x3d, r28	; 61
    2a82:	9c 83       	std	Y+4, r25	; 0x04
    2a84:	8b 83       	std	Y+3, r24	; 0x03
    2a86:	7e 83       	std	Y+6, r23	; 0x06
    2a88:	6d 83       	std	Y+5, r22	; 0x05
    2a8a:	58 87       	std	Y+8, r21	; 0x08
    2a8c:	4f 83       	std	Y+7, r20	; 0x07
#endif

	/* Place a few bytes of known values on the bottom of the stack.
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2a8e:	eb 81       	ldd	r30, Y+3	; 0x03
    2a90:	fc 81       	ldd	r31, Y+4	; 0x04
    2a92:	81 e1       	ldi	r24, 0x11	; 17
    2a94:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a96:	8b 81       	ldd	r24, Y+3	; 0x03
    2a98:	9c 81       	ldd	r25, Y+4	; 0x04
    2a9a:	01 97       	sbiw	r24, 0x01	; 1
    2a9c:	9c 83       	std	Y+4, r25	; 0x04
    2a9e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    2aa0:	eb 81       	ldd	r30, Y+3	; 0x03
    2aa2:	fc 81       	ldd	r31, Y+4	; 0x04
    2aa4:	82 e2       	ldi	r24, 0x22	; 34
    2aa6:	80 83       	st	Z, r24
	pxTopOfStack--;
    2aa8:	8b 81       	ldd	r24, Y+3	; 0x03
    2aaa:	9c 81       	ldd	r25, Y+4	; 0x04
    2aac:	01 97       	sbiw	r24, 0x01	; 1
    2aae:	9c 83       	std	Y+4, r25	; 0x04
    2ab0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    2ab2:	eb 81       	ldd	r30, Y+3	; 0x03
    2ab4:	fc 81       	ldd	r31, Y+4	; 0x04
    2ab6:	83 e3       	ldi	r24, 0x33	; 51
    2ab8:	80 83       	st	Z, r24
	pxTopOfStack--;
    2aba:	8b 81       	ldd	r24, Y+3	; 0x03
    2abc:	9c 81       	ldd	r25, Y+4	; 0x04
    2abe:	01 97       	sbiw	r24, 0x01	; 1
    2ac0:	9c 83       	std	Y+4, r25	; 0x04
    2ac2:	8b 83       	std	Y+3, r24	; 0x03
	 * of flash. We do this by adding the .task label in the linker script.
	 *
	 * In order to do this properly, we would need to get a full 3-byte pointer to
	 * pxCode.  That requires a change to GCC.  Not likely to happen any time soon.
	 */
	usAddress = ( unsigned portSHORT ) pxCode;
    2ac4:	8d 81       	ldd	r24, Y+5	; 0x05
    2ac6:	9e 81       	ldd	r25, Y+6	; 0x06
    2ac8:	9a 83       	std	Y+2, r25	; 0x02
    2aca:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    2acc:	89 81       	ldd	r24, Y+1	; 0x01
    2ace:	eb 81       	ldd	r30, Y+3	; 0x03
    2ad0:	fc 81       	ldd	r31, Y+4	; 0x04
    2ad2:	80 83       	st	Z, r24
	pxTopOfStack--;
    2ad4:	8b 81       	ldd	r24, Y+3	; 0x03
    2ad6:	9c 81       	ldd	r25, Y+4	; 0x04
    2ad8:	01 97       	sbiw	r24, 0x01	; 1
    2ada:	9c 83       	std	Y+4, r25	; 0x04
    2adc:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2ade:	89 81       	ldd	r24, Y+1	; 0x01
    2ae0:	9a 81       	ldd	r25, Y+2	; 0x02
    2ae2:	89 2f       	mov	r24, r25
    2ae4:	99 27       	eor	r25, r25
    2ae6:	9a 83       	std	Y+2, r25	; 0x02
    2ae8:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    2aea:	89 81       	ldd	r24, Y+1	; 0x01
    2aec:	eb 81       	ldd	r30, Y+3	; 0x03
    2aee:	fc 81       	ldd	r31, Y+4	; 0x04
    2af0:	80 83       	st	Z, r24
	pxTopOfStack--;
    2af2:	8b 81       	ldd	r24, Y+3	; 0x03
    2af4:	9c 81       	ldd	r25, Y+4	; 0x04
    2af6:	01 97       	sbiw	r24, 0x01	; 1
    2af8:	9c 83       	std	Y+4, r25	; 0x04
    2afa:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = 0;
    2afc:	eb 81       	ldd	r30, Y+3	; 0x03
    2afe:	fc 81       	ldd	r31, Y+4	; 0x04
    2b00:	10 82       	st	Z, r1
	pxTopOfStack--;
    2b02:	8b 81       	ldd	r24, Y+3	; 0x03
    2b04:	9c 81       	ldd	r25, Y+4	; 0x04
    2b06:	01 97       	sbiw	r24, 0x01	; 1
    2b08:	9c 83       	std	Y+4, r25	; 0x04
    2b0a:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    2b0c:	eb 81       	ldd	r30, Y+3	; 0x03
    2b0e:	fc 81       	ldd	r31, Y+4	; 0x04
    2b10:	10 82       	st	Z, r1
	pxTopOfStack--;
    2b12:	8b 81       	ldd	r24, Y+3	; 0x03
    2b14:	9c 81       	ldd	r25, Y+4	; 0x04
    2b16:	01 97       	sbiw	r24, 0x01	; 1
    2b18:	9c 83       	std	Y+4, r25	; 0x04
    2b1a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2b1c:	eb 81       	ldd	r30, Y+3	; 0x03
    2b1e:	fc 81       	ldd	r31, Y+4	; 0x04
    2b20:	80 e8       	ldi	r24, 0x80	; 128
    2b22:	80 83       	st	Z, r24
	pxTopOfStack--;
    2b24:	8b 81       	ldd	r24, Y+3	; 0x03
    2b26:	9c 81       	ldd	r25, Y+4	; 0x04
    2b28:	01 97       	sbiw	r24, 0x01	; 1
    2b2a:	9c 83       	std	Y+4, r25	; 0x04
    2b2c:	8b 83       	std	Y+3, r24	; 0x03
#if defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

	/* If we have an ATmega256x, we are also saving the RAMPZ and EIND registers.
	 * We should default those to 0.
	 */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* EIND */
    2b2e:	eb 81       	ldd	r30, Y+3	; 0x03
    2b30:	fc 81       	ldd	r31, Y+4	; 0x04
    2b32:	10 82       	st	Z, r1
	pxTopOfStack--;
    2b34:	8b 81       	ldd	r24, Y+3	; 0x03
    2b36:	9c 81       	ldd	r25, Y+4	; 0x04
    2b38:	01 97       	sbiw	r24, 0x01	; 1
    2b3a:	9c 83       	std	Y+4, r25	; 0x04
    2b3c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* RAMPZ */
    2b3e:	eb 81       	ldd	r30, Y+3	; 0x03
    2b40:	fc 81       	ldd	r31, Y+4	; 0x04
    2b42:	10 82       	st	Z, r1
	pxTopOfStack--;
    2b44:	8b 81       	ldd	r24, Y+3	; 0x03
    2b46:	9c 81       	ldd	r25, Y+4	; 0x04
    2b48:	01 97       	sbiw	r24, 0x01	; 1
    2b4a:	9c 83       	std	Y+4, r25	; 0x04
    2b4c:	8b 83       	std	Y+3, r24	; 0x03

#endif

	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    2b4e:	eb 81       	ldd	r30, Y+3	; 0x03
    2b50:	fc 81       	ldd	r31, Y+4	; 0x04
    2b52:	10 82       	st	Z, r1
	pxTopOfStack--;
    2b54:	8b 81       	ldd	r24, Y+3	; 0x03
    2b56:	9c 81       	ldd	r25, Y+4	; 0x04
    2b58:	01 97       	sbiw	r24, 0x01	; 1
    2b5a:	9c 83       	std	Y+4, r25	; 0x04
    2b5c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    2b5e:	eb 81       	ldd	r30, Y+3	; 0x03
    2b60:	fc 81       	ldd	r31, Y+4	; 0x04
    2b62:	82 e0       	ldi	r24, 0x02	; 2
    2b64:	80 83       	st	Z, r24
	pxTopOfStack--;
    2b66:	8b 81       	ldd	r24, Y+3	; 0x03
    2b68:	9c 81       	ldd	r25, Y+4	; 0x04
    2b6a:	01 97       	sbiw	r24, 0x01	; 1
    2b6c:	9c 83       	std	Y+4, r25	; 0x04
    2b6e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    2b70:	eb 81       	ldd	r30, Y+3	; 0x03
    2b72:	fc 81       	ldd	r31, Y+4	; 0x04
    2b74:	83 e0       	ldi	r24, 0x03	; 3
    2b76:	80 83       	st	Z, r24
	pxTopOfStack--;
    2b78:	8b 81       	ldd	r24, Y+3	; 0x03
    2b7a:	9c 81       	ldd	r25, Y+4	; 0x04
    2b7c:	01 97       	sbiw	r24, 0x01	; 1
    2b7e:	9c 83       	std	Y+4, r25	; 0x04
    2b80:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    2b82:	eb 81       	ldd	r30, Y+3	; 0x03
    2b84:	fc 81       	ldd	r31, Y+4	; 0x04
    2b86:	84 e0       	ldi	r24, 0x04	; 4
    2b88:	80 83       	st	Z, r24
	pxTopOfStack--;
    2b8a:	8b 81       	ldd	r24, Y+3	; 0x03
    2b8c:	9c 81       	ldd	r25, Y+4	; 0x04
    2b8e:	01 97       	sbiw	r24, 0x01	; 1
    2b90:	9c 83       	std	Y+4, r25	; 0x04
    2b92:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    2b94:	eb 81       	ldd	r30, Y+3	; 0x03
    2b96:	fc 81       	ldd	r31, Y+4	; 0x04
    2b98:	85 e0       	ldi	r24, 0x05	; 5
    2b9a:	80 83       	st	Z, r24
	pxTopOfStack--;
    2b9c:	8b 81       	ldd	r24, Y+3	; 0x03
    2b9e:	9c 81       	ldd	r25, Y+4	; 0x04
    2ba0:	01 97       	sbiw	r24, 0x01	; 1
    2ba2:	9c 83       	std	Y+4, r25	; 0x04
    2ba4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    2ba6:	eb 81       	ldd	r30, Y+3	; 0x03
    2ba8:	fc 81       	ldd	r31, Y+4	; 0x04
    2baa:	86 e0       	ldi	r24, 0x06	; 6
    2bac:	80 83       	st	Z, r24
	pxTopOfStack--;
    2bae:	8b 81       	ldd	r24, Y+3	; 0x03
    2bb0:	9c 81       	ldd	r25, Y+4	; 0x04
    2bb2:	01 97       	sbiw	r24, 0x01	; 1
    2bb4:	9c 83       	std	Y+4, r25	; 0x04
    2bb6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    2bb8:	eb 81       	ldd	r30, Y+3	; 0x03
    2bba:	fc 81       	ldd	r31, Y+4	; 0x04
    2bbc:	87 e0       	ldi	r24, 0x07	; 7
    2bbe:	80 83       	st	Z, r24
	pxTopOfStack--;
    2bc0:	8b 81       	ldd	r24, Y+3	; 0x03
    2bc2:	9c 81       	ldd	r25, Y+4	; 0x04
    2bc4:	01 97       	sbiw	r24, 0x01	; 1
    2bc6:	9c 83       	std	Y+4, r25	; 0x04
    2bc8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    2bca:	eb 81       	ldd	r30, Y+3	; 0x03
    2bcc:	fc 81       	ldd	r31, Y+4	; 0x04
    2bce:	88 e0       	ldi	r24, 0x08	; 8
    2bd0:	80 83       	st	Z, r24
	pxTopOfStack--;
    2bd2:	8b 81       	ldd	r24, Y+3	; 0x03
    2bd4:	9c 81       	ldd	r25, Y+4	; 0x04
    2bd6:	01 97       	sbiw	r24, 0x01	; 1
    2bd8:	9c 83       	std	Y+4, r25	; 0x04
    2bda:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    2bdc:	eb 81       	ldd	r30, Y+3	; 0x03
    2bde:	fc 81       	ldd	r31, Y+4	; 0x04
    2be0:	89 e0       	ldi	r24, 0x09	; 9
    2be2:	80 83       	st	Z, r24
	pxTopOfStack--;
    2be4:	8b 81       	ldd	r24, Y+3	; 0x03
    2be6:	9c 81       	ldd	r25, Y+4	; 0x04
    2be8:	01 97       	sbiw	r24, 0x01	; 1
    2bea:	9c 83       	std	Y+4, r25	; 0x04
    2bec:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    2bee:	eb 81       	ldd	r30, Y+3	; 0x03
    2bf0:	fc 81       	ldd	r31, Y+4	; 0x04
    2bf2:	80 e1       	ldi	r24, 0x10	; 16
    2bf4:	80 83       	st	Z, r24
	pxTopOfStack--;
    2bf6:	8b 81       	ldd	r24, Y+3	; 0x03
    2bf8:	9c 81       	ldd	r25, Y+4	; 0x04
    2bfa:	01 97       	sbiw	r24, 0x01	; 1
    2bfc:	9c 83       	std	Y+4, r25	; 0x04
    2bfe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    2c00:	eb 81       	ldd	r30, Y+3	; 0x03
    2c02:	fc 81       	ldd	r31, Y+4	; 0x04
    2c04:	81 e1       	ldi	r24, 0x11	; 17
    2c06:	80 83       	st	Z, r24
	pxTopOfStack--;
    2c08:	8b 81       	ldd	r24, Y+3	; 0x03
    2c0a:	9c 81       	ldd	r25, Y+4	; 0x04
    2c0c:	01 97       	sbiw	r24, 0x01	; 1
    2c0e:	9c 83       	std	Y+4, r25	; 0x04
    2c10:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    2c12:	eb 81       	ldd	r30, Y+3	; 0x03
    2c14:	fc 81       	ldd	r31, Y+4	; 0x04
    2c16:	82 e1       	ldi	r24, 0x12	; 18
    2c18:	80 83       	st	Z, r24
	pxTopOfStack--;
    2c1a:	8b 81       	ldd	r24, Y+3	; 0x03
    2c1c:	9c 81       	ldd	r25, Y+4	; 0x04
    2c1e:	01 97       	sbiw	r24, 0x01	; 1
    2c20:	9c 83       	std	Y+4, r25	; 0x04
    2c22:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    2c24:	eb 81       	ldd	r30, Y+3	; 0x03
    2c26:	fc 81       	ldd	r31, Y+4	; 0x04
    2c28:	83 e1       	ldi	r24, 0x13	; 19
    2c2a:	80 83       	st	Z, r24
	pxTopOfStack--;
    2c2c:	8b 81       	ldd	r24, Y+3	; 0x03
    2c2e:	9c 81       	ldd	r25, Y+4	; 0x04
    2c30:	01 97       	sbiw	r24, 0x01	; 1
    2c32:	9c 83       	std	Y+4, r25	; 0x04
    2c34:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    2c36:	eb 81       	ldd	r30, Y+3	; 0x03
    2c38:	fc 81       	ldd	r31, Y+4	; 0x04
    2c3a:	84 e1       	ldi	r24, 0x14	; 20
    2c3c:	80 83       	st	Z, r24
	pxTopOfStack--;
    2c3e:	8b 81       	ldd	r24, Y+3	; 0x03
    2c40:	9c 81       	ldd	r25, Y+4	; 0x04
    2c42:	01 97       	sbiw	r24, 0x01	; 1
    2c44:	9c 83       	std	Y+4, r25	; 0x04
    2c46:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    2c48:	eb 81       	ldd	r30, Y+3	; 0x03
    2c4a:	fc 81       	ldd	r31, Y+4	; 0x04
    2c4c:	85 e1       	ldi	r24, 0x15	; 21
    2c4e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2c50:	8b 81       	ldd	r24, Y+3	; 0x03
    2c52:	9c 81       	ldd	r25, Y+4	; 0x04
    2c54:	01 97       	sbiw	r24, 0x01	; 1
    2c56:	9c 83       	std	Y+4, r25	; 0x04
    2c58:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    2c5a:	eb 81       	ldd	r30, Y+3	; 0x03
    2c5c:	fc 81       	ldd	r31, Y+4	; 0x04
    2c5e:	86 e1       	ldi	r24, 0x16	; 22
    2c60:	80 83       	st	Z, r24
	pxTopOfStack--;
    2c62:	8b 81       	ldd	r24, Y+3	; 0x03
    2c64:	9c 81       	ldd	r25, Y+4	; 0x04
    2c66:	01 97       	sbiw	r24, 0x01	; 1
    2c68:	9c 83       	std	Y+4, r25	; 0x04
    2c6a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    2c6c:	eb 81       	ldd	r30, Y+3	; 0x03
    2c6e:	fc 81       	ldd	r31, Y+4	; 0x04
    2c70:	87 e1       	ldi	r24, 0x17	; 23
    2c72:	80 83       	st	Z, r24
	pxTopOfStack--;
    2c74:	8b 81       	ldd	r24, Y+3	; 0x03
    2c76:	9c 81       	ldd	r25, Y+4	; 0x04
    2c78:	01 97       	sbiw	r24, 0x01	; 1
    2c7a:	9c 83       	std	Y+4, r25	; 0x04
    2c7c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    2c7e:	eb 81       	ldd	r30, Y+3	; 0x03
    2c80:	fc 81       	ldd	r31, Y+4	; 0x04
    2c82:	88 e1       	ldi	r24, 0x18	; 24
    2c84:	80 83       	st	Z, r24
	pxTopOfStack--;
    2c86:	8b 81       	ldd	r24, Y+3	; 0x03
    2c88:	9c 81       	ldd	r25, Y+4	; 0x04
    2c8a:	01 97       	sbiw	r24, 0x01	; 1
    2c8c:	9c 83       	std	Y+4, r25	; 0x04
    2c8e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    2c90:	eb 81       	ldd	r30, Y+3	; 0x03
    2c92:	fc 81       	ldd	r31, Y+4	; 0x04
    2c94:	89 e1       	ldi	r24, 0x19	; 25
    2c96:	80 83       	st	Z, r24
	pxTopOfStack--;
    2c98:	8b 81       	ldd	r24, Y+3	; 0x03
    2c9a:	9c 81       	ldd	r25, Y+4	; 0x04
    2c9c:	01 97       	sbiw	r24, 0x01	; 1
    2c9e:	9c 83       	std	Y+4, r25	; 0x04
    2ca0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    2ca2:	eb 81       	ldd	r30, Y+3	; 0x03
    2ca4:	fc 81       	ldd	r31, Y+4	; 0x04
    2ca6:	80 e2       	ldi	r24, 0x20	; 32
    2ca8:	80 83       	st	Z, r24
	pxTopOfStack--;
    2caa:	8b 81       	ldd	r24, Y+3	; 0x03
    2cac:	9c 81       	ldd	r25, Y+4	; 0x04
    2cae:	01 97       	sbiw	r24, 0x01	; 1
    2cb0:	9c 83       	std	Y+4, r25	; 0x04
    2cb2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    2cb4:	eb 81       	ldd	r30, Y+3	; 0x03
    2cb6:	fc 81       	ldd	r31, Y+4	; 0x04
    2cb8:	81 e2       	ldi	r24, 0x21	; 33
    2cba:	80 83       	st	Z, r24
	pxTopOfStack--;
    2cbc:	8b 81       	ldd	r24, Y+3	; 0x03
    2cbe:	9c 81       	ldd	r25, Y+4	; 0x04
    2cc0:	01 97       	sbiw	r24, 0x01	; 1
    2cc2:	9c 83       	std	Y+4, r25	; 0x04
    2cc4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    2cc6:	eb 81       	ldd	r30, Y+3	; 0x03
    2cc8:	fc 81       	ldd	r31, Y+4	; 0x04
    2cca:	82 e2       	ldi	r24, 0x22	; 34
    2ccc:	80 83       	st	Z, r24
	pxTopOfStack--;
    2cce:	8b 81       	ldd	r24, Y+3	; 0x03
    2cd0:	9c 81       	ldd	r25, Y+4	; 0x04
    2cd2:	01 97       	sbiw	r24, 0x01	; 1
    2cd4:	9c 83       	std	Y+4, r25	; 0x04
    2cd6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    2cd8:	eb 81       	ldd	r30, Y+3	; 0x03
    2cda:	fc 81       	ldd	r31, Y+4	; 0x04
    2cdc:	83 e2       	ldi	r24, 0x23	; 35
    2cde:	80 83       	st	Z, r24
	pxTopOfStack--;
    2ce0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ce2:	9c 81       	ldd	r25, Y+4	; 0x04
    2ce4:	01 97       	sbiw	r24, 0x01	; 1
    2ce6:	9c 83       	std	Y+4, r25	; 0x04
    2ce8:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    2cea:	8f 81       	ldd	r24, Y+7	; 0x07
    2cec:	98 85       	ldd	r25, Y+8	; 0x08
    2cee:	9a 83       	std	Y+2, r25	; 0x02
    2cf0:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2cf2:	89 81       	ldd	r24, Y+1	; 0x01
    2cf4:	eb 81       	ldd	r30, Y+3	; 0x03
    2cf6:	fc 81       	ldd	r31, Y+4	; 0x04
    2cf8:	80 83       	st	Z, r24
	pxTopOfStack--;
    2cfa:	8b 81       	ldd	r24, Y+3	; 0x03
    2cfc:	9c 81       	ldd	r25, Y+4	; 0x04
    2cfe:	01 97       	sbiw	r24, 0x01	; 1
    2d00:	9c 83       	std	Y+4, r25	; 0x04
    2d02:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2d04:	89 81       	ldd	r24, Y+1	; 0x01
    2d06:	9a 81       	ldd	r25, Y+2	; 0x02
    2d08:	89 2f       	mov	r24, r25
    2d0a:	99 27       	eor	r25, r25
    2d0c:	9a 83       	std	Y+2, r25	; 0x02
    2d0e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2d10:	89 81       	ldd	r24, Y+1	; 0x01
    2d12:	eb 81       	ldd	r30, Y+3	; 0x03
    2d14:	fc 81       	ldd	r31, Y+4	; 0x04
    2d16:	80 83       	st	Z, r24
	pxTopOfStack--;
    2d18:	8b 81       	ldd	r24, Y+3	; 0x03
    2d1a:	9c 81       	ldd	r25, Y+4	; 0x04
    2d1c:	01 97       	sbiw	r24, 0x01	; 1
    2d1e:	9c 83       	std	Y+4, r25	; 0x04
    2d20:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    2d22:	eb 81       	ldd	r30, Y+3	; 0x03
    2d24:	fc 81       	ldd	r31, Y+4	; 0x04
    2d26:	86 e2       	ldi	r24, 0x26	; 38
    2d28:	80 83       	st	Z, r24
	pxTopOfStack--;
    2d2a:	8b 81       	ldd	r24, Y+3	; 0x03
    2d2c:	9c 81       	ldd	r25, Y+4	; 0x04
    2d2e:	01 97       	sbiw	r24, 0x01	; 1
    2d30:	9c 83       	std	Y+4, r25	; 0x04
    2d32:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    2d34:	eb 81       	ldd	r30, Y+3	; 0x03
    2d36:	fc 81       	ldd	r31, Y+4	; 0x04
    2d38:	87 e2       	ldi	r24, 0x27	; 39
    2d3a:	80 83       	st	Z, r24
	pxTopOfStack--;
    2d3c:	8b 81       	ldd	r24, Y+3	; 0x03
    2d3e:	9c 81       	ldd	r25, Y+4	; 0x04
    2d40:	01 97       	sbiw	r24, 0x01	; 1
    2d42:	9c 83       	std	Y+4, r25	; 0x04
    2d44:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    2d46:	eb 81       	ldd	r30, Y+3	; 0x03
    2d48:	fc 81       	ldd	r31, Y+4	; 0x04
    2d4a:	88 e2       	ldi	r24, 0x28	; 40
    2d4c:	80 83       	st	Z, r24
	pxTopOfStack--;
    2d4e:	8b 81       	ldd	r24, Y+3	; 0x03
    2d50:	9c 81       	ldd	r25, Y+4	; 0x04
    2d52:	01 97       	sbiw	r24, 0x01	; 1
    2d54:	9c 83       	std	Y+4, r25	; 0x04
    2d56:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    2d58:	eb 81       	ldd	r30, Y+3	; 0x03
    2d5a:	fc 81       	ldd	r31, Y+4	; 0x04
    2d5c:	89 e2       	ldi	r24, 0x29	; 41
    2d5e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2d60:	8b 81       	ldd	r24, Y+3	; 0x03
    2d62:	9c 81       	ldd	r25, Y+4	; 0x04
    2d64:	01 97       	sbiw	r24, 0x01	; 1
    2d66:	9c 83       	std	Y+4, r25	; 0x04
    2d68:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    2d6a:	eb 81       	ldd	r30, Y+3	; 0x03
    2d6c:	fc 81       	ldd	r31, Y+4	; 0x04
    2d6e:	80 e3       	ldi	r24, 0x30	; 48
    2d70:	80 83       	st	Z, r24
	pxTopOfStack--;
    2d72:	8b 81       	ldd	r24, Y+3	; 0x03
    2d74:	9c 81       	ldd	r25, Y+4	; 0x04
    2d76:	01 97       	sbiw	r24, 0x01	; 1
    2d78:	9c 83       	std	Y+4, r25	; 0x04
    2d7a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    2d7c:	eb 81       	ldd	r30, Y+3	; 0x03
    2d7e:	fc 81       	ldd	r31, Y+4	; 0x04
    2d80:	81 e3       	ldi	r24, 0x31	; 49
    2d82:	80 83       	st	Z, r24
	pxTopOfStack--;
    2d84:	8b 81       	ldd	r24, Y+3	; 0x03
    2d86:	9c 81       	ldd	r25, Y+4	; 0x04
    2d88:	01 97       	sbiw	r24, 0x01	; 1
    2d8a:	9c 83       	std	Y+4, r25	; 0x04
    2d8c:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    2d8e:	8b 81       	ldd	r24, Y+3	; 0x03
    2d90:	9c 81       	ldd	r25, Y+4	; 0x04
}
    2d92:	28 96       	adiw	r28, 0x08	; 8
    2d94:	0f b6       	in	r0, 0x3f	; 63
    2d96:	f8 94       	cli
    2d98:	de bf       	out	0x3e, r29	; 62
    2d9a:	0f be       	out	0x3f, r0	; 63
    2d9c:	cd bf       	out	0x3d, r28	; 61
    2d9e:	cf 91       	pop	r28
    2da0:	df 91       	pop	r29
    2da2:	08 95       	ret

00002da4 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    2da4:	df 93       	push	r29
    2da6:	cf 93       	push	r28
    2da8:	cd b7       	in	r28, 0x3d	; 61
    2daa:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    2dac:	0e 94 d6 17 	call	0x2fac	; 0x2fac <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2db0:	a0 91 26 02 	lds	r26, 0x0226
    2db4:	b0 91 27 02 	lds	r27, 0x0227
    2db8:	cd 91       	ld	r28, X+
    2dba:	cd bf       	out	0x3d, r28	; 61
    2dbc:	dd 91       	ld	r29, X+
    2dbe:	de bf       	out	0x3e, r29	; 62
    2dc0:	ff 91       	pop	r31
    2dc2:	ef 91       	pop	r30
    2dc4:	df 91       	pop	r29
    2dc6:	cf 91       	pop	r28
    2dc8:	bf 91       	pop	r27
    2dca:	af 91       	pop	r26
    2dcc:	9f 91       	pop	r25
    2dce:	8f 91       	pop	r24
    2dd0:	7f 91       	pop	r23
    2dd2:	6f 91       	pop	r22
    2dd4:	5f 91       	pop	r21
    2dd6:	4f 91       	pop	r20
    2dd8:	3f 91       	pop	r19
    2dda:	2f 91       	pop	r18
    2ddc:	1f 91       	pop	r17
    2dde:	0f 91       	pop	r16
    2de0:	ff 90       	pop	r15
    2de2:	ef 90       	pop	r14
    2de4:	df 90       	pop	r13
    2de6:	cf 90       	pop	r12
    2de8:	bf 90       	pop	r11
    2dea:	af 90       	pop	r10
    2dec:	9f 90       	pop	r9
    2dee:	8f 90       	pop	r8
    2df0:	7f 90       	pop	r7
    2df2:	6f 90       	pop	r6
    2df4:	5f 90       	pop	r5
    2df6:	4f 90       	pop	r4
    2df8:	3f 90       	pop	r3
    2dfa:	2f 90       	pop	r2
    2dfc:	1f 90       	pop	r1
    2dfe:	0f 90       	pop	r0
    2e00:	0c be       	out	0x3c, r0	; 60
    2e02:	0f 90       	pop	r0
    2e04:	0b be       	out	0x3b, r0	; 59
    2e06:	0f 90       	pop	r0
    2e08:	0f be       	out	0x3f, r0	; 63
    2e0a:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2e0c:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    2e0e:	81 e0       	ldi	r24, 0x01	; 1
}
    2e10:	cf 91       	pop	r28
    2e12:	df 91       	pop	r29
    2e14:	08 95       	ret

00002e16 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    2e16:	df 93       	push	r29
    2e18:	cf 93       	push	r28
    2e1a:	cd b7       	in	r28, 0x3d	; 61
    2e1c:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    2e1e:	cf 91       	pop	r28
    2e20:	df 91       	pop	r29
    2e22:	08 95       	ret

00002e24 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2e24:	0f 92       	push	r0
    2e26:	0f b6       	in	r0, 0x3f	; 63
    2e28:	f8 94       	cli
    2e2a:	0f 92       	push	r0
    2e2c:	0b b6       	in	r0, 0x3b	; 59
    2e2e:	0f 92       	push	r0
    2e30:	0c b6       	in	r0, 0x3c	; 60
    2e32:	0f 92       	push	r0
    2e34:	1f 92       	push	r1
    2e36:	11 24       	eor	r1, r1
    2e38:	2f 92       	push	r2
    2e3a:	3f 92       	push	r3
    2e3c:	4f 92       	push	r4
    2e3e:	5f 92       	push	r5
    2e40:	6f 92       	push	r6
    2e42:	7f 92       	push	r7
    2e44:	8f 92       	push	r8
    2e46:	9f 92       	push	r9
    2e48:	af 92       	push	r10
    2e4a:	bf 92       	push	r11
    2e4c:	cf 92       	push	r12
    2e4e:	df 92       	push	r13
    2e50:	ef 92       	push	r14
    2e52:	ff 92       	push	r15
    2e54:	0f 93       	push	r16
    2e56:	1f 93       	push	r17
    2e58:	2f 93       	push	r18
    2e5a:	3f 93       	push	r19
    2e5c:	4f 93       	push	r20
    2e5e:	5f 93       	push	r21
    2e60:	6f 93       	push	r22
    2e62:	7f 93       	push	r23
    2e64:	8f 93       	push	r24
    2e66:	9f 93       	push	r25
    2e68:	af 93       	push	r26
    2e6a:	bf 93       	push	r27
    2e6c:	cf 93       	push	r28
    2e6e:	df 93       	push	r29
    2e70:	ef 93       	push	r30
    2e72:	ff 93       	push	r31
    2e74:	a0 91 26 02 	lds	r26, 0x0226
    2e78:	b0 91 27 02 	lds	r27, 0x0227
    2e7c:	0d b6       	in	r0, 0x3d	; 61
    2e7e:	0d 92       	st	X+, r0
    2e80:	0e b6       	in	r0, 0x3e	; 62
    2e82:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2e84:	0e 94 2a 07 	call	0xe54	; 0xe54 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2e88:	a0 91 26 02 	lds	r26, 0x0226
    2e8c:	b0 91 27 02 	lds	r27, 0x0227
    2e90:	cd 91       	ld	r28, X+
    2e92:	cd bf       	out	0x3d, r28	; 61
    2e94:	dd 91       	ld	r29, X+
    2e96:	de bf       	out	0x3e, r29	; 62
    2e98:	ff 91       	pop	r31
    2e9a:	ef 91       	pop	r30
    2e9c:	df 91       	pop	r29
    2e9e:	cf 91       	pop	r28
    2ea0:	bf 91       	pop	r27
    2ea2:	af 91       	pop	r26
    2ea4:	9f 91       	pop	r25
    2ea6:	8f 91       	pop	r24
    2ea8:	7f 91       	pop	r23
    2eaa:	6f 91       	pop	r22
    2eac:	5f 91       	pop	r21
    2eae:	4f 91       	pop	r20
    2eb0:	3f 91       	pop	r19
    2eb2:	2f 91       	pop	r18
    2eb4:	1f 91       	pop	r17
    2eb6:	0f 91       	pop	r16
    2eb8:	ff 90       	pop	r15
    2eba:	ef 90       	pop	r14
    2ebc:	df 90       	pop	r13
    2ebe:	cf 90       	pop	r12
    2ec0:	bf 90       	pop	r11
    2ec2:	af 90       	pop	r10
    2ec4:	9f 90       	pop	r9
    2ec6:	8f 90       	pop	r8
    2ec8:	7f 90       	pop	r7
    2eca:	6f 90       	pop	r6
    2ecc:	5f 90       	pop	r5
    2ece:	4f 90       	pop	r4
    2ed0:	3f 90       	pop	r3
    2ed2:	2f 90       	pop	r2
    2ed4:	1f 90       	pop	r1
    2ed6:	0f 90       	pop	r0
    2ed8:	0c be       	out	0x3c, r0	; 60
    2eda:	0f 90       	pop	r0
    2edc:	0b be       	out	0x3b, r0	; 59
    2ede:	0f 90       	pop	r0
    2ee0:	0f be       	out	0x3f, r0	; 63
    2ee2:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2ee4:	08 95       	ret

00002ee6 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2ee6:	0f 92       	push	r0
    2ee8:	0f b6       	in	r0, 0x3f	; 63
    2eea:	f8 94       	cli
    2eec:	0f 92       	push	r0
    2eee:	0b b6       	in	r0, 0x3b	; 59
    2ef0:	0f 92       	push	r0
    2ef2:	0c b6       	in	r0, 0x3c	; 60
    2ef4:	0f 92       	push	r0
    2ef6:	1f 92       	push	r1
    2ef8:	11 24       	eor	r1, r1
    2efa:	2f 92       	push	r2
    2efc:	3f 92       	push	r3
    2efe:	4f 92       	push	r4
    2f00:	5f 92       	push	r5
    2f02:	6f 92       	push	r6
    2f04:	7f 92       	push	r7
    2f06:	8f 92       	push	r8
    2f08:	9f 92       	push	r9
    2f0a:	af 92       	push	r10
    2f0c:	bf 92       	push	r11
    2f0e:	cf 92       	push	r12
    2f10:	df 92       	push	r13
    2f12:	ef 92       	push	r14
    2f14:	ff 92       	push	r15
    2f16:	0f 93       	push	r16
    2f18:	1f 93       	push	r17
    2f1a:	2f 93       	push	r18
    2f1c:	3f 93       	push	r19
    2f1e:	4f 93       	push	r20
    2f20:	5f 93       	push	r21
    2f22:	6f 93       	push	r22
    2f24:	7f 93       	push	r23
    2f26:	8f 93       	push	r24
    2f28:	9f 93       	push	r25
    2f2a:	af 93       	push	r26
    2f2c:	bf 93       	push	r27
    2f2e:	cf 93       	push	r28
    2f30:	df 93       	push	r29
    2f32:	ef 93       	push	r30
    2f34:	ff 93       	push	r31
    2f36:	a0 91 26 02 	lds	r26, 0x0226
    2f3a:	b0 91 27 02 	lds	r27, 0x0227
    2f3e:	0d b6       	in	r0, 0x3d	; 61
    2f40:	0d 92       	st	X+, r0
    2f42:	0e b6       	in	r0, 0x3e	; 62
    2f44:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    2f46:	0e 94 56 06 	call	0xcac	; 0xcac <vTaskIncrementTick>
	vTaskSwitchContext();
    2f4a:	0e 94 2a 07 	call	0xe54	; 0xe54 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2f4e:	a0 91 26 02 	lds	r26, 0x0226
    2f52:	b0 91 27 02 	lds	r27, 0x0227
    2f56:	cd 91       	ld	r28, X+
    2f58:	cd bf       	out	0x3d, r28	; 61
    2f5a:	dd 91       	ld	r29, X+
    2f5c:	de bf       	out	0x3e, r29	; 62
    2f5e:	ff 91       	pop	r31
    2f60:	ef 91       	pop	r30
    2f62:	df 91       	pop	r29
    2f64:	cf 91       	pop	r28
    2f66:	bf 91       	pop	r27
    2f68:	af 91       	pop	r26
    2f6a:	9f 91       	pop	r25
    2f6c:	8f 91       	pop	r24
    2f6e:	7f 91       	pop	r23
    2f70:	6f 91       	pop	r22
    2f72:	5f 91       	pop	r21
    2f74:	4f 91       	pop	r20
    2f76:	3f 91       	pop	r19
    2f78:	2f 91       	pop	r18
    2f7a:	1f 91       	pop	r17
    2f7c:	0f 91       	pop	r16
    2f7e:	ff 90       	pop	r15
    2f80:	ef 90       	pop	r14
    2f82:	df 90       	pop	r13
    2f84:	cf 90       	pop	r12
    2f86:	bf 90       	pop	r11
    2f88:	af 90       	pop	r10
    2f8a:	9f 90       	pop	r9
    2f8c:	8f 90       	pop	r8
    2f8e:	7f 90       	pop	r7
    2f90:	6f 90       	pop	r6
    2f92:	5f 90       	pop	r5
    2f94:	4f 90       	pop	r4
    2f96:	3f 90       	pop	r3
    2f98:	2f 90       	pop	r2
    2f9a:	1f 90       	pop	r1
    2f9c:	0f 90       	pop	r0
    2f9e:	0c be       	out	0x3c, r0	; 60
    2fa0:	0f 90       	pop	r0
    2fa2:	0b be       	out	0x3b, r0	; 59
    2fa4:	0f 90       	pop	r0
    2fa6:	0f be       	out	0x3f, r0	; 63
    2fa8:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2faa:	08 95       	ret

00002fac <prvSetupTimerInterrupt>:

/*
 * Setup timer 0 or 3 or 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    2fac:	df 93       	push	r29
    2fae:	cf 93       	push	r28
    2fb0:	00 d0       	rcall	.+0      	; 0x2fb2 <prvSetupTimerInterrupt+0x6>
    2fb2:	00 d0       	rcall	.+0      	; 0x2fb4 <prvSetupTimerInterrupt+0x8>
    2fb4:	cd b7       	in	r28, 0x3d	; 61
    2fb6:	de b7       	in	r29, 0x3e	; 62

    /* Using 8bit Timer0 or 16bit Timer1 or Timer3 to generate the tick. */

    // ulCompareMatch 40,000 = 20,000,000 / 500; 20MHz
    // ulCompareMatch 110,592 = 22,118,400 / 200; 22.1184 MHz
    ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    2fb8:	80 e0       	ldi	r24, 0x00	; 0
    2fba:	9d e7       	ldi	r25, 0x7D	; 125
    2fbc:	a0 e0       	ldi	r26, 0x00	; 0
    2fbe:	b0 e0       	ldi	r27, 0x00	; 0
    2fc0:	8b 83       	std	Y+3, r24	; 0x03
    2fc2:	9c 83       	std	Y+4, r25	; 0x04
    2fc4:	ad 83       	std	Y+5, r26	; 0x05
    2fc6:	be 83       	std	Y+6, r27	; 0x06

    /* We only have 8 or 16 bits so have to scale 64 or 256 to get our required tick rate. */
    //ulCompareMatch = 625 /= portCLOCK_PRESCALER; 20MHz with 64 prescale
    //ulCompareMatch = 108 /= portCLOCK_PRESCALER; 22.1184 MHz with 1024 prescale
    ulCompareMatch /= portCLOCK_PRESCALER;
    2fc8:	8b 81       	ldd	r24, Y+3	; 0x03
    2fca:	9c 81       	ldd	r25, Y+4	; 0x04
    2fcc:	ad 81       	ldd	r26, Y+5	; 0x05
    2fce:	be 81       	ldd	r27, Y+6	; 0x06
    2fd0:	68 94       	set
    2fd2:	15 f8       	bld	r1, 5
    2fd4:	b6 95       	lsr	r27
    2fd6:	a7 95       	ror	r26
    2fd8:	97 95       	ror	r25
    2fda:	87 95       	ror	r24
    2fdc:	16 94       	lsr	r1
    2fde:	d1 f7       	brne	.-12     	; 0x2fd4 <prvSetupTimerInterrupt+0x28>
    2fe0:	8b 83       	std	Y+3, r24	; 0x03
    2fe2:	9c 83       	std	Y+4, r25	; 0x04
    2fe4:	ad 83       	std	Y+5, r26	; 0x05
    2fe6:	be 83       	std	Y+6, r27	; 0x06

    /* Adjust for correct value. */
    ulCompareMatch -= ( unsigned portLONG ) 1;
    2fe8:	8b 81       	ldd	r24, Y+3	; 0x03
    2fea:	9c 81       	ldd	r25, Y+4	; 0x04
    2fec:	ad 81       	ldd	r26, Y+5	; 0x05
    2fee:	be 81       	ldd	r27, Y+6	; 0x06
    2ff0:	01 97       	sbiw	r24, 0x01	; 1
    2ff2:	a1 09       	sbc	r26, r1
    2ff4:	b1 09       	sbc	r27, r1
    2ff6:	8b 83       	std	Y+3, r24	; 0x03
    2ff8:	9c 83       	std	Y+4, r25	; 0x04
    2ffa:	ad 83       	std	Y+5, r26	; 0x05
    2ffc:	be 83       	std	Y+6, r27	; 0x06

    /* Setup compare match value for compare match A.  Interrupts are disabled
    before this is called so we need not worry here. */
    ucLowByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
    2ffe:	8b 81       	ldd	r24, Y+3	; 0x03
    3000:	89 83       	std	Y+1, r24	; 0x01
    //  OCR3AL = ucLowByte;

    // the HiByte is only needed, if a 16 Bit counter is being utilized
#ifdef portOCRH

    ulCompareMatch >>= 8;
    3002:	8b 81       	ldd	r24, Y+3	; 0x03
    3004:	9c 81       	ldd	r25, Y+4	; 0x04
    3006:	ad 81       	ldd	r26, Y+5	; 0x05
    3008:	be 81       	ldd	r27, Y+6	; 0x06
    300a:	89 2f       	mov	r24, r25
    300c:	9a 2f       	mov	r25, r26
    300e:	ab 2f       	mov	r26, r27
    3010:	bb 27       	eor	r27, r27
    3012:	8b 83       	std	Y+3, r24	; 0x03
    3014:	9c 83       	std	Y+4, r25	; 0x04
    3016:	ad 83       	std	Y+5, r26	; 0x05
    3018:	be 83       	std	Y+6, r27	; 0x06
    ucHighByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
    301a:	8b 81       	ldd	r24, Y+3	; 0x03
    301c:	8a 83       	std	Y+2, r24	; 0x02
    portOCRH = ucHighByte;
    301e:	e9 e9       	ldi	r30, 0x99	; 153
    3020:	f0 e0       	ldi	r31, 0x00	; 0
    3022:	8a 81       	ldd	r24, Y+2	; 0x02
    3024:	80 83       	st	Z, r24

#endif

    portOCRL = ucLowByte;
    3026:	e8 e9       	ldi	r30, 0x98	; 152
    3028:	f0 e0       	ldi	r31, 0x00	; 0
    302a:	89 81       	ldd	r24, Y+1	; 0x01
    302c:	80 83       	st	Z, r24
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	portTCCRb = ucLowByte;

#elif defined( portUSE_TIMER3 )
	/* Setup clock source and compare match behaviour. Assuming  640 / 1280 /1281 / 1284p / 2560 / 2561 (with Timer3) */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    302e:	8b e0       	ldi	r24, 0x0B	; 11
    3030:	89 83       	std	Y+1, r24	; 0x01
	portTCCRb = ucLowByte;
    3032:	e1 e9       	ldi	r30, 0x91	; 145
    3034:	f0 e0       	ldi	r31, 0x00	; 0
    3036:	89 81       	ldd	r24, Y+1	; 0x01
    3038:	80 83       	st	Z, r24
#endif

    /* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
    ucLowByte = portTIMSK;
    303a:	e1 e7       	ldi	r30, 0x71	; 113
    303c:	f0 e0       	ldi	r31, 0x00	; 0
    303e:	80 81       	ld	r24, Z
    3040:	89 83       	std	Y+1, r24	; 0x01
    ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    3042:	89 81       	ldd	r24, Y+1	; 0x01
    3044:	82 60       	ori	r24, 0x02	; 2
    3046:	89 83       	std	Y+1, r24	; 0x01
    portTIMSK = ucLowByte;
    3048:	e1 e7       	ldi	r30, 0x71	; 113
    304a:	f0 e0       	ldi	r31, 0x00	; 0
    304c:	89 81       	ldd	r24, Y+1	; 0x01
    304e:	80 83       	st	Z, r24

}
    3050:	26 96       	adiw	r28, 0x06	; 6
    3052:	0f b6       	in	r0, 0x3f	; 63
    3054:	f8 94       	cli
    3056:	de bf       	out	0x3e, r29	; 62
    3058:	0f be       	out	0x3f, r0	; 63
    305a:	cd bf       	out	0x3d, r28	; 61
    305c:	cf 91       	pop	r28
    305e:	df 91       	pop	r29
    3060:	08 95       	ret

00003062 <__vector_32>:

	#elif defined( portUSE_TIMER3 )
		#warning "Timer3 used for PRE-EMPTIVE scheduler."
		ISR(TIMER3_COMPA_vect, ISR_NAKED)
		{
			vPortYieldFromTick();
    3062:	0e 94 73 17 	call	0x2ee6	; 0x2ee6 <vPortYieldFromTick>
			asm volatile ( "reti" );
    3066:	18 95       	reti

00003068 <USART_Init>:
*  the specified baud rate and clk speed.
*
* Param buadin: The desired Baud rate.
* Param clk_seedin: The clk speed of the ATmega328p
************************************/
void USART_Init(uint16_t baudin, uint32_t clk_speedin) {
    3068:	ef 92       	push	r14
    306a:	ff 92       	push	r15
    306c:	0f 93       	push	r16
    306e:	1f 93       	push	r17
    3070:	df 93       	push	r29
    3072:	cf 93       	push	r28
    3074:	cd b7       	in	r28, 0x3d	; 61
    3076:	de b7       	in	r29, 0x3e	; 62
    3078:	2a 97       	sbiw	r28, 0x0a	; 10
    307a:	0f b6       	in	r0, 0x3f	; 63
    307c:	f8 94       	cli
    307e:	de bf       	out	0x3e, r29	; 62
    3080:	0f be       	out	0x3f, r0	; 63
    3082:	cd bf       	out	0x3d, r28	; 61
    3084:	9e 83       	std	Y+6, r25	; 0x06
    3086:	8d 83       	std	Y+5, r24	; 0x05
    3088:	4f 83       	std	Y+7, r20	; 0x07
    308a:	58 87       	std	Y+8, r21	; 0x08
    308c:	69 87       	std	Y+9, r22	; 0x09
    308e:	7a 87       	std	Y+10, r23	; 0x0a
    USART_WriteQueue = xQueueCreate(64,sizeof(uint8_t));
    3090:	80 e4       	ldi	r24, 0x40	; 64
    3092:	61 e0       	ldi	r22, 0x01	; 1
    3094:	40 e0       	ldi	r20, 0x00	; 0
    3096:	0e 94 fe 0b 	call	0x17fc	; 0x17fc <xQueueGenericCreate>
    309a:	90 93 c3 1a 	sts	0x1AC3, r25
    309e:	80 93 c2 1a 	sts	0x1AC2, r24
    USART_ReadQueue = xQueueCreate(8,sizeof(uint8_t));
    30a2:	88 e0       	ldi	r24, 0x08	; 8
    30a4:	61 e0       	ldi	r22, 0x01	; 1
    30a6:	40 e0       	ldi	r20, 0x00	; 0
    30a8:	0e 94 fe 0b 	call	0x17fc	; 0x17fc <xQueueGenericCreate>
    30ac:	90 93 bf 1a 	sts	0x1ABF, r25
    30b0:	80 93 be 1a 	sts	0x1ABE, r24

    uint32_t ubrr = clk_speedin/(16UL)/baudin-1;
    30b4:	8f 81       	ldd	r24, Y+7	; 0x07
    30b6:	98 85       	ldd	r25, Y+8	; 0x08
    30b8:	a9 85       	ldd	r26, Y+9	; 0x09
    30ba:	ba 85       	ldd	r27, Y+10	; 0x0a
    30bc:	7c 01       	movw	r14, r24
    30be:	8d 01       	movw	r16, r26
    30c0:	68 94       	set
    30c2:	13 f8       	bld	r1, 3
    30c4:	16 95       	lsr	r17
    30c6:	07 95       	ror	r16
    30c8:	f7 94       	ror	r15
    30ca:	e7 94       	ror	r14
    30cc:	16 94       	lsr	r1
    30ce:	d1 f7       	brne	.-12     	; 0x30c4 <USART_Init+0x5c>
    30d0:	8d 81       	ldd	r24, Y+5	; 0x05
    30d2:	9e 81       	ldd	r25, Y+6	; 0x06
    30d4:	9c 01       	movw	r18, r24
    30d6:	40 e0       	ldi	r20, 0x00	; 0
    30d8:	50 e0       	ldi	r21, 0x00	; 0
    30da:	c8 01       	movw	r24, r16
    30dc:	b7 01       	movw	r22, r14
    30de:	0e 94 ef 1f 	call	0x3fde	; 0x3fde <__udivmodsi4>
    30e2:	da 01       	movw	r26, r20
    30e4:	c9 01       	movw	r24, r18
    30e6:	01 97       	sbiw	r24, 0x01	; 1
    30e8:	a1 09       	sbc	r26, r1
    30ea:	b1 09       	sbc	r27, r1
    30ec:	89 83       	std	Y+1, r24	; 0x01
    30ee:	9a 83       	std	Y+2, r25	; 0x02
    30f0:	ab 83       	std	Y+3, r26	; 0x03
    30f2:	bc 83       	std	Y+4, r27	; 0x04
    UBRR1H = (unsigned char)(ubrr>>8) ;// & 0x7F;
    30f4:	ed ec       	ldi	r30, 0xCD	; 205
    30f6:	f0 e0       	ldi	r31, 0x00	; 0
    30f8:	89 81       	ldd	r24, Y+1	; 0x01
    30fa:	9a 81       	ldd	r25, Y+2	; 0x02
    30fc:	ab 81       	ldd	r26, Y+3	; 0x03
    30fe:	bc 81       	ldd	r27, Y+4	; 0x04
    3100:	89 2f       	mov	r24, r25
    3102:	9a 2f       	mov	r25, r26
    3104:	ab 2f       	mov	r26, r27
    3106:	bb 27       	eor	r27, r27
    3108:	80 83       	st	Z, r24
    UBRR1L = (unsigned char)ubrr;
    310a:	ec ec       	ldi	r30, 0xCC	; 204
    310c:	f0 e0       	ldi	r31, 0x00	; 0
    310e:	89 81       	ldd	r24, Y+1	; 0x01
    3110:	80 83       	st	Z, r24
    
    //UBRR0H = 0; //115200
    //UBRR0L = 8;

    /* Enable receiver and transmitter */
    UCSR1B = (1<<RXEN1)|(1<<TXEN1);
    3112:	e9 ec       	ldi	r30, 0xC9	; 201
    3114:	f0 e0       	ldi	r31, 0x00	; 0
    3116:	88 e1       	ldi	r24, 0x18	; 24
    3118:	80 83       	st	Z, r24
    /* Set frame format: 8data, 1stop bit */
    UCSR1C = (1<<UCSZ11)|(1<<UCSZ10);
    311a:	ea ec       	ldi	r30, 0xCA	; 202
    311c:	f0 e0       	ldi	r31, 0x00	; 0
    311e:	86 e0       	ldi	r24, 0x06	; 6
    3120:	80 83       	st	Z, r24
	// clear U2X0 for Synchronous operation
    UCSR1A &= ~(1<<U2X1);
    3122:	a8 ec       	ldi	r26, 0xC8	; 200
    3124:	b0 e0       	ldi	r27, 0x00	; 0
    3126:	e8 ec       	ldi	r30, 0xC8	; 200
    3128:	f0 e0       	ldi	r31, 0x00	; 0
    312a:	80 81       	ld	r24, Z
    312c:	8d 7f       	andi	r24, 0xFD	; 253
    312e:	8c 93       	st	X, r24
    /* Set frame format: 8data, 1stop bit */
    //UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);
    // clear U2X0 for Synchronous operation
    //UCSR0A &= ~(1<<U2X0);*/

}
    3130:	2a 96       	adiw	r28, 0x0a	; 10
    3132:	0f b6       	in	r0, 0x3f	; 63
    3134:	f8 94       	cli
    3136:	de bf       	out	0x3e, r29	; 62
    3138:	0f be       	out	0x3f, r0	; 63
    313a:	cd bf       	out	0x3d, r28	; 61
    313c:	cf 91       	pop	r28
    313e:	df 91       	pop	r29
    3140:	1f 91       	pop	r17
    3142:	0f 91       	pop	r16
    3144:	ff 90       	pop	r15
    3146:	ef 90       	pop	r14
    3148:	08 95       	ret

0000314a <USART_Write>:

/*the send function will put 8bits on the trans line. */
void USART_Write(uint8_t data) {
    314a:	df 93       	push	r29
    314c:	cf 93       	push	r28
    314e:	0f 92       	push	r0
    3150:	cd b7       	in	r28, 0x3d	; 61
    3152:	de b7       	in	r29, 0x3e	; 62
    3154:	89 83       	std	Y+1, r24	; 0x01
		/* Wait for empty transmit buffer */
		while ( !( UCSR0A & (1<<UDRE0)) )
    3156:	e0 ec       	ldi	r30, 0xC0	; 192
    3158:	f0 e0       	ldi	r31, 0x00	; 0
    315a:	80 81       	ld	r24, Z
    315c:	88 2f       	mov	r24, r24
    315e:	90 e0       	ldi	r25, 0x00	; 0
    3160:	80 72       	andi	r24, 0x20	; 32
    3162:	90 70       	andi	r25, 0x00	; 0
    3164:	00 97       	sbiw	r24, 0x00	; 0
    3166:	b9 f3       	breq	.-18     	; 0x3156 <USART_Write+0xc>
		;
		/* Put data into buffer, sends the data */
		UDR0 = data;
    3168:	e6 ec       	ldi	r30, 0xC6	; 198
    316a:	f0 e0       	ldi	r31, 0x00	; 0
    316c:	89 81       	ldd	r24, Y+1	; 0x01
    316e:	80 83       	st	Z, r24
}
    3170:	0f 90       	pop	r0
    3172:	cf 91       	pop	r28
    3174:	df 91       	pop	r29
    3176:	08 95       	ret

00003178 <USART_Write_Unprotected>:

/*the send function will put 8bits on the trans line. */
void USART_Write_Unprotected(uint8_t data) {
    3178:	df 93       	push	r29
    317a:	cf 93       	push	r28
    317c:	0f 92       	push	r0
    317e:	cd b7       	in	r28, 0x3d	; 61
    3180:	de b7       	in	r29, 0x3e	; 62
    3182:	89 83       	std	Y+1, r24	; 0x01
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)) )
    3184:	e0 ec       	ldi	r30, 0xC0	; 192
    3186:	f0 e0       	ldi	r31, 0x00	; 0
    3188:	80 81       	ld	r24, Z
    318a:	88 2f       	mov	r24, r24
    318c:	90 e0       	ldi	r25, 0x00	; 0
    318e:	80 72       	andi	r24, 0x20	; 32
    3190:	90 70       	andi	r25, 0x00	; 0
    3192:	00 97       	sbiw	r24, 0x00	; 0
    3194:	b9 f3       	breq	.-18     	; 0x3184 <USART_Write_Unprotected+0xc>
	;
	/* Put data into buffer, sends the data */
	UDR0 = data;
    3196:	e6 ec       	ldi	r30, 0xC6	; 198
    3198:	f0 e0       	ldi	r31, 0x00	; 0
    319a:	89 81       	ldd	r24, Y+1	; 0x01
    319c:	80 83       	st	Z, r24
}
    319e:	0f 90       	pop	r0
    31a0:	cf 91       	pop	r28
    31a2:	df 91       	pop	r29
    31a4:	08 95       	ret

000031a6 <USART_Read>:
Therefore you may not get control back after this is called 
until a much later time. It may be helpful to use the 
istheredata() function to check before calling this function
        @return 8bit data packet from sender
*/
uint8_t USART_Read(void) {
    31a6:	df 93       	push	r29
    31a8:	cf 93       	push	r28
    31aa:	cd b7       	in	r28, 0x3d	; 61
    31ac:	de b7       	in	r29, 0x3e	; 62
    /* Wait for data to be received */
    while ( !(UCSR0A & (1<<RXC0)) )
    31ae:	e0 ec       	ldi	r30, 0xC0	; 192
    31b0:	f0 e0       	ldi	r31, 0x00	; 0
    31b2:	80 81       	ld	r24, Z
    31b4:	88 23       	and	r24, r24
    31b6:	dc f7       	brge	.-10     	; 0x31ae <USART_Read+0x8>
        ;
    /* Get and return received data from buffer */
    return UDR0;
    31b8:	e6 ec       	ldi	r30, 0xC6	; 198
    31ba:	f0 e0       	ldi	r31, 0x00	; 0
    31bc:	80 81       	ld	r24, Z
}
    31be:	cf 91       	pop	r28
    31c0:	df 91       	pop	r29
    31c2:	08 95       	ret

000031c4 <ISR>:


ISR(USART0_RX_vect){
    31c4:	df 93       	push	r29
    31c6:	cf 93       	push	r28
    31c8:	00 d0       	rcall	.+0      	; 0x31ca <ISR+0x6>
    31ca:	0f 92       	push	r0
    31cc:	0f 92       	push	r0
    31ce:	cd b7       	in	r28, 0x3d	; 61
    31d0:	de b7       	in	r29, 0x3e	; 62
    31d2:	9b 83       	std	Y+3, r25	; 0x03
    31d4:	8a 83       	std	Y+2, r24	; 0x02
    uint8_t data;
    data = UDR1;
    31d6:	ee ec       	ldi	r30, 0xCE	; 206
    31d8:	f0 e0       	ldi	r31, 0x00	; 0
    31da:	80 81       	ld	r24, Z
    31dc:	89 83       	std	Y+1, r24	; 0x01
    xQueueSendToBackFromISR(USART_ReadQueue,&data,NULL);
    31de:	80 91 be 1a 	lds	r24, 0x1ABE
    31e2:	90 91 bf 1a 	lds	r25, 0x1ABF
    31e6:	9e 01       	movw	r18, r28
    31e8:	2f 5f       	subi	r18, 0xFF	; 255
    31ea:	3f 4f       	sbci	r19, 0xFF	; 255
    31ec:	b9 01       	movw	r22, r18
    31ee:	40 e0       	ldi	r20, 0x00	; 0
    31f0:	50 e0       	ldi	r21, 0x00	; 0
    31f2:	20 e0       	ldi	r18, 0x00	; 0
    31f4:	0e 94 46 0d 	call	0x1a8c	; 0x1a8c <xQueueGenericSendFromISR>
}
    31f8:	0f 90       	pop	r0
    31fa:	0f 90       	pop	r0
    31fc:	0f 90       	pop	r0
    31fe:	0f 90       	pop	r0
    3200:	0f 90       	pop	r0
    3202:	cf 91       	pop	r28
    3204:	df 91       	pop	r29
    3206:	08 95       	ret

00003208 <USART_AddToQueue>:

void USART_AddToQueue(uint8_t data){
    3208:	df 93       	push	r29
    320a:	cf 93       	push	r28
    320c:	0f 92       	push	r0
    320e:	cd b7       	in	r28, 0x3d	; 61
    3210:	de b7       	in	r29, 0x3e	; 62
    3212:	89 83       	std	Y+1, r24	; 0x01
    
    xQueueSendToBack(USART_WriteQueue,&data,portMAX_DELAY);
    3214:	80 91 c2 1a 	lds	r24, 0x1AC2
    3218:	90 91 c3 1a 	lds	r25, 0x1AC3
    321c:	9e 01       	movw	r18, r28
    321e:	2f 5f       	subi	r18, 0xFF	; 255
    3220:	3f 4f       	sbci	r19, 0xFF	; 255
    3222:	b9 01       	movw	r22, r18
    3224:	4f ef       	ldi	r20, 0xFF	; 255
    3226:	5f ef       	ldi	r21, 0xFF	; 255
    3228:	20 e0       	ldi	r18, 0x00	; 0
    322a:	0e 94 a8 0c 	call	0x1950	; 0x1950 <xQueueGenericSend>

}
    322e:	0f 90       	pop	r0
    3230:	cf 91       	pop	r28
    3232:	df 91       	pop	r29
    3234:	08 95       	ret

00003236 <USART_TransmitString>:

void USART_TransmitString(char* str){
    3236:	df 93       	push	r29
    3238:	cf 93       	push	r28
    323a:	0f 92       	push	r0
    323c:	0f 92       	push	r0
    323e:	cd b7       	in	r28, 0x3d	; 61
    3240:	de b7       	in	r29, 0x3e	; 62
    3242:	9a 83       	std	Y+2, r25	; 0x02
    3244:	89 83       	std	Y+1, r24	; 0x01
    3246:	0a c0       	rjmp	.+20     	; 0x325c <USART_TransmitString+0x26>
    while(*str) {
        USART_AddToQueue(*str);
    3248:	e9 81       	ldd	r30, Y+1	; 0x01
    324a:	fa 81       	ldd	r31, Y+2	; 0x02
    324c:	80 81       	ld	r24, Z
    324e:	0e 94 04 19 	call	0x3208	; 0x3208 <USART_AddToQueue>
        str++;
    3252:	89 81       	ldd	r24, Y+1	; 0x01
    3254:	9a 81       	ldd	r25, Y+2	; 0x02
    3256:	01 96       	adiw	r24, 0x01	; 1
    3258:	9a 83       	std	Y+2, r25	; 0x02
    325a:	89 83       	std	Y+1, r24	; 0x01
    xQueueSendToBack(USART_WriteQueue,&data,portMAX_DELAY);

}

void USART_TransmitString(char* str){
    while(*str) {
    325c:	e9 81       	ldd	r30, Y+1	; 0x01
    325e:	fa 81       	ldd	r31, Y+2	; 0x02
    3260:	80 81       	ld	r24, Z
    3262:	88 23       	and	r24, r24
    3264:	89 f7       	brne	.-30     	; 0x3248 <USART_TransmitString+0x12>
        USART_AddToQueue(*str);
        str++;
    }
}
    3266:	0f 90       	pop	r0
    3268:	0f 90       	pop	r0
    326a:	cf 91       	pop	r28
    326c:	df 91       	pop	r29
    326e:	08 95       	ret

00003270 <vTaskUSARTWrite>:

void vTaskUSARTWrite(void *pvParameters){
    3270:	df 93       	push	r29
    3272:	cf 93       	push	r28
    3274:	00 d0       	rcall	.+0      	; 0x3276 <vTaskUSARTWrite+0x6>
    3276:	cd b7       	in	r28, 0x3d	; 61
    3278:	de b7       	in	r29, 0x3e	; 62
    327a:	9b 83       	std	Y+3, r25	; 0x03
    327c:	8a 83       	std	Y+2, r24	; 0x02
    uint8_t data;
    while(1){
    xQueueReceive(USART_WriteQueue,&data,portMAX_DELAY);
    327e:	80 91 c2 1a 	lds	r24, 0x1AC2
    3282:	90 91 c3 1a 	lds	r25, 0x1AC3
    3286:	9e 01       	movw	r18, r28
    3288:	2f 5f       	subi	r18, 0xFF	; 255
    328a:	3f 4f       	sbci	r19, 0xFF	; 255
    328c:	b9 01       	movw	r22, r18
    328e:	4f ef       	ldi	r20, 0xFF	; 255
    3290:	5f ef       	ldi	r21, 0xFF	; 255
    3292:	20 e0       	ldi	r18, 0x00	; 0
    3294:	0e 94 97 0d 	call	0x1b2e	; 0x1b2e <xQueueGenericReceive>

        while(!(UCSR1A & (1<<UDRE1)));
    3298:	e8 ec       	ldi	r30, 0xC8	; 200
    329a:	f0 e0       	ldi	r31, 0x00	; 0
    329c:	80 81       	ld	r24, Z
    329e:	88 2f       	mov	r24, r24
    32a0:	90 e0       	ldi	r25, 0x00	; 0
    32a2:	80 72       	andi	r24, 0x20	; 32
    32a4:	90 70       	andi	r25, 0x00	; 0
    32a6:	00 97       	sbiw	r24, 0x00	; 0
    32a8:	b9 f3       	breq	.-18     	; 0x3298 <vTaskUSARTWrite+0x28>
        UDR1 = data;
    32aa:	ee ec       	ldi	r30, 0xCE	; 206
    32ac:	f0 e0       	ldi	r31, 0x00	; 0
    32ae:	89 81       	ldd	r24, Y+1	; 0x01
    32b0:	80 83       	st	Z, r24
    32b2:	e5 cf       	rjmp	.-54     	; 0x327e <vTaskUSARTWrite+0xe>

000032b4 <USART_LogChar>:

    }
}

void USART_LogChar(uint8_t data){
    32b4:	df 93       	push	r29
    32b6:	cf 93       	push	r28
    32b8:	0f 92       	push	r0
    32ba:	cd b7       	in	r28, 0x3d	; 61
    32bc:	de b7       	in	r29, 0x3e	; 62
    32be:	89 83       	std	Y+1, r24	; 0x01
    xQueueSendToBack(USART_WriteQueueLog,&data,portMAX_DELAY);
    32c0:	80 91 c0 1a 	lds	r24, 0x1AC0
    32c4:	90 91 c1 1a 	lds	r25, 0x1AC1
    32c8:	9e 01       	movw	r18, r28
    32ca:	2f 5f       	subi	r18, 0xFF	; 255
    32cc:	3f 4f       	sbci	r19, 0xFF	; 255
    32ce:	b9 01       	movw	r22, r18
    32d0:	4f ef       	ldi	r20, 0xFF	; 255
    32d2:	5f ef       	ldi	r21, 0xFF	; 255
    32d4:	20 e0       	ldi	r18, 0x00	; 0
    32d6:	0e 94 a8 0c 	call	0x1950	; 0x1950 <xQueueGenericSend>
}
    32da:	0f 90       	pop	r0
    32dc:	cf 91       	pop	r28
    32de:	df 91       	pop	r29
    32e0:	08 95       	ret

000032e2 <USART_LogString>:

void USART_LogString(char* str){
    32e2:	df 93       	push	r29
    32e4:	cf 93       	push	r28
    32e6:	0f 92       	push	r0
    32e8:	0f 92       	push	r0
    32ea:	cd b7       	in	r28, 0x3d	; 61
    32ec:	de b7       	in	r29, 0x3e	; 62
    32ee:	9a 83       	std	Y+2, r25	; 0x02
    32f0:	89 83       	std	Y+1, r24	; 0x01
    32f2:	0a c0       	rjmp	.+20     	; 0x3308 <USART_LogString+0x26>
    while(*str){
        USART_LogChar(*str);
    32f4:	e9 81       	ldd	r30, Y+1	; 0x01
    32f6:	fa 81       	ldd	r31, Y+2	; 0x02
    32f8:	80 81       	ld	r24, Z
    32fa:	0e 94 5a 19 	call	0x32b4	; 0x32b4 <USART_LogChar>
        str++;
    32fe:	89 81       	ldd	r24, Y+1	; 0x01
    3300:	9a 81       	ldd	r25, Y+2	; 0x02
    3302:	01 96       	adiw	r24, 0x01	; 1
    3304:	9a 83       	std	Y+2, r25	; 0x02
    3306:	89 83       	std	Y+1, r24	; 0x01
void USART_LogChar(uint8_t data){
    xQueueSendToBack(USART_WriteQueueLog,&data,portMAX_DELAY);
}

void USART_LogString(char* str){
    while(*str){
    3308:	e9 81       	ldd	r30, Y+1	; 0x01
    330a:	fa 81       	ldd	r31, Y+2	; 0x02
    330c:	80 81       	ld	r24, Z
    330e:	88 23       	and	r24, r24
    3310:	89 f7       	brne	.-30     	; 0x32f4 <USART_LogString+0x12>
        USART_LogChar(*str);
        str++;
    }
}
    3312:	0f 90       	pop	r0
    3314:	0f 90       	pop	r0
    3316:	cf 91       	pop	r28
    3318:	df 91       	pop	r29
    331a:	08 95       	ret

0000331c <vTaskUSARTLog>:

void vTaskUSARTLog(void *pvParameters){
    331c:	df 93       	push	r29
    331e:	cf 93       	push	r28
    3320:	00 d0       	rcall	.+0      	; 0x3322 <vTaskUSARTLog+0x6>
    3322:	cd b7       	in	r28, 0x3d	; 61
    3324:	de b7       	in	r29, 0x3e	; 62
    3326:	9b 83       	std	Y+3, r25	; 0x03
    3328:	8a 83       	std	Y+2, r24	; 0x02
    uint8_t data;
    while(1){
    xQueueReceive(USART_WriteQueueLog,&data,portMAX_DELAY);
    332a:	80 91 c0 1a 	lds	r24, 0x1AC0
    332e:	90 91 c1 1a 	lds	r25, 0x1AC1
    3332:	9e 01       	movw	r18, r28
    3334:	2f 5f       	subi	r18, 0xFF	; 255
    3336:	3f 4f       	sbci	r19, 0xFF	; 255
    3338:	b9 01       	movw	r22, r18
    333a:	4f ef       	ldi	r20, 0xFF	; 255
    333c:	5f ef       	ldi	r21, 0xFF	; 255
    333e:	20 e0       	ldi	r18, 0x00	; 0
    3340:	0e 94 97 0d 	call	0x1b2e	; 0x1b2e <xQueueGenericReceive>

        while(!(UCSR0A & (1<<UDRE0)));
    3344:	e0 ec       	ldi	r30, 0xC0	; 192
    3346:	f0 e0       	ldi	r31, 0x00	; 0
    3348:	80 81       	ld	r24, Z
    334a:	88 2f       	mov	r24, r24
    334c:	90 e0       	ldi	r25, 0x00	; 0
    334e:	80 72       	andi	r24, 0x20	; 32
    3350:	90 70       	andi	r25, 0x00	; 0
    3352:	00 97       	sbiw	r24, 0x00	; 0
    3354:	b9 f3       	breq	.-18     	; 0x3344 <vTaskUSARTLog+0x28>
        UDR0 = data;
    3356:	e6 ec       	ldi	r30, 0xC6	; 198
    3358:	f0 e0       	ldi	r31, 0x00	; 0
    335a:	89 81       	ldd	r24, Y+1	; 0x01
    335c:	80 83       	st	Z, r24
    335e:	e5 cf       	rjmp	.-54     	; 0x332a <vTaskUSARTLog+0xe>

00003360 <vTaskUSARTRead>:

    }

}

void vTaskUSARTRead(void *pvParameters){
    3360:	df 93       	push	r29
    3362:	cf 93       	push	r28
    3364:	cd b7       	in	r28, 0x3d	; 61
    3366:	de b7       	in	r29, 0x3e	; 62
    3368:	c6 55       	subi	r28, 0x56	; 86
    336a:	d0 40       	sbci	r29, 0x00	; 0
    336c:	0f b6       	in	r0, 0x3f	; 63
    336e:	f8 94       	cli
    3370:	de bf       	out	0x3e, r29	; 62
    3372:	0f be       	out	0x3f, r0	; 63
    3374:	cd bf       	out	0x3d, r28	; 61
    3376:	fe 01       	movw	r30, r28
    3378:	eb 5a       	subi	r30, 0xAB	; 171
    337a:	ff 4f       	sbci	r31, 0xFF	; 255
    337c:	91 83       	std	Z+1, r25	; 0x01
    337e:	80 83       	st	Z, r24
    char size;
    char groupID;
    char cmd;
    unsigned int timeout;

    PORTB = 0;
    3380:	e5 e2       	ldi	r30, 0x25	; 37
    3382:	f0 e0       	ldi	r31, 0x00	; 0
    3384:	10 82       	st	Z, r1

    Command command;
    Response response;
    while(1){
        PORTB = 0;
    3386:	e5 e2       	ldi	r30, 0x25	; 37
    3388:	f0 e0       	ldi	r31, 0x00	; 0
    338a:	10 82       	st	Z, r1
        //Get Header
        bytesRecieved = 0;
    338c:	1f 82       	std	Y+7, r1	; 0x07
        timeout = 0;
    338e:	1a 82       	std	Y+2, r1	; 0x02
    3390:	19 82       	std	Y+1, r1	; 0x01
    3392:	29 c0       	rjmp	.+82     	; 0x33e6 <vTaskUSARTRead+0x86>
        while(bytesRecieved < 4){
            //if there is data to be read...
            if((UCSR1A & (1<<RXC1))){
    3394:	e8 ec       	ldi	r30, 0xC8	; 200
    3396:	f0 e0       	ldi	r31, 0x00	; 0
    3398:	80 81       	ld	r24, Z
    339a:	88 23       	and	r24, r24
    339c:	b4 f4       	brge	.+44     	; 0x33ca <vTaskUSARTRead+0x6a>
                rxData = UDR1;
    339e:	ee ec       	ldi	r30, 0xCE	; 206
    33a0:	f0 e0       	ldi	r31, 0x00	; 0
    33a2:	80 81       	ld	r24, Z
    33a4:	8e 83       	std	Y+6, r24	; 0x06
            //if(xQueueReceive(USART_ReadQueue,&rxData,portMAX_DELAY) == pdTRUE){
                buffer[bytesRecieved] = rxData;
    33a6:	8f 81       	ldd	r24, Y+7	; 0x07
    33a8:	28 2f       	mov	r18, r24
    33aa:	33 27       	eor	r19, r19
    33ac:	27 fd       	sbrc	r18, 7
    33ae:	30 95       	com	r19
    33b0:	ce 01       	movw	r24, r28
    33b2:	08 96       	adiw	r24, 0x08	; 8
    33b4:	fc 01       	movw	r30, r24
    33b6:	e2 0f       	add	r30, r18
    33b8:	f3 1f       	adc	r31, r19
    33ba:	8e 81       	ldd	r24, Y+6	; 0x06
    33bc:	80 83       	st	Z, r24
                //USART_AddToQueue(rxData);
                bytesRecieved++;
    33be:	8f 81       	ldd	r24, Y+7	; 0x07
    33c0:	8f 5f       	subi	r24, 0xFF	; 255
    33c2:	8f 83       	std	Y+7, r24	; 0x07
                timeout = 0;
    33c4:	1a 82       	std	Y+2, r1	; 0x02
    33c6:	19 82       	std	Y+1, r1	; 0x01
    33c8:	05 c0       	rjmp	.+10     	; 0x33d4 <vTaskUSARTRead+0x74>
            } else {
                timeout++;
    33ca:	89 81       	ldd	r24, Y+1	; 0x01
    33cc:	9a 81       	ldd	r25, Y+2	; 0x02
    33ce:	01 96       	adiw	r24, 0x01	; 1
    33d0:	9a 83       	std	Y+2, r25	; 0x02
    33d2:	89 83       	std	Y+1, r24	; 0x01
            }
            if(timeout > 50000){
    33d4:	89 81       	ldd	r24, Y+1	; 0x01
    33d6:	9a 81       	ldd	r25, Y+2	; 0x02
    33d8:	23 ec       	ldi	r18, 0xC3	; 195
    33da:	81 35       	cpi	r24, 0x51	; 81
    33dc:	92 07       	cpc	r25, r18
    33de:	18 f0       	brcs	.+6      	; 0x33e6 <vTaskUSARTRead+0x86>
                timeout = 0;
    33e0:	1a 82       	std	Y+2, r1	; 0x02
    33e2:	19 82       	std	Y+1, r1	; 0x01
                bytesRecieved = 0;
    33e4:	1f 82       	std	Y+7, r1	; 0x07
    while(1){
        PORTB = 0;
        //Get Header
        bytesRecieved = 0;
        timeout = 0;
        while(bytesRecieved < 4){
    33e6:	8f 81       	ldd	r24, Y+7	; 0x07
    33e8:	84 30       	cpi	r24, 0x04	; 4
    33ea:	a4 f2       	brlt	.-88     	; 0x3394 <vTaskUSARTRead+0x34>
                bytesRecieved = 0;


            }
        }
        PORTB = 0;
    33ec:	e5 e2       	ldi	r30, 0x25	; 37
    33ee:	f0 e0       	ldi	r31, 0x00	; 0
    33f0:	10 82       	st	Z, r1
        if(calcChecksum(buffer,3) != buffer[3]){
    33f2:	ce 01       	movw	r24, r28
    33f4:	08 96       	adiw	r24, 0x08	; 8
    33f6:	63 e0       	ldi	r22, 0x03	; 3
    33f8:	0e 94 ff 1a 	call	0x35fe	; 0x35fe <calcChecksum>
    33fc:	98 2f       	mov	r25, r24
    33fe:	8b 85       	ldd	r24, Y+11	; 0x0b
    3400:	98 17       	cp	r25, r24
    3402:	19 f0       	breq	.+6      	; 0x340a <vTaskUSARTRead+0xaa>
            sendNACK();
    3404:	0e 94 df 1a 	call	0x35be	; 0x35be <sendNACK>
    3408:	be cf       	rjmp	.-132    	; 0x3386 <vTaskUSARTRead+0x26>
        } else {
            sendACK();
    340a:	0e 94 d5 1a 	call	0x35aa	; 0x35aa <sendACK>
            bytesRecieved = 0;
    340e:	1f 82       	std	Y+7, r1	; 0x07
            command.groupID = buffer[0];
    3410:	88 85       	ldd	r24, Y+8	; 0x08
    3412:	88 8b       	std	Y+16, r24	; 0x10
            command.cmd = buffer[1];
    3414:	89 85       	ldd	r24, Y+9	; 0x09
    3416:	89 8b       	std	Y+17, r24	; 0x11
            command.crc = buffer[3];
    3418:	8b 85       	ldd	r24, Y+11	; 0x0b
    341a:	8a 8b       	std	Y+18, r24	; 0x12
            size = buffer[2];
    341c:	8a 85       	ldd	r24, Y+10	; 0x0a
    341e:	8d 83       	std	Y+5, r24	; 0x05
            timeout = 0;
    3420:	1a 82       	std	Y+2, r1	; 0x02
    3422:	19 82       	std	Y+1, r1	; 0x01
            if(size != 0){
    3424:	8d 81       	ldd	r24, Y+5	; 0x05
    3426:	88 23       	and	r24, r24
    3428:	09 f4       	brne	.+2      	; 0x342c <vTaskUSARTRead+0xcc>
    342a:	5d c0       	rjmp	.+186    	; 0x34e6 <vTaskUSARTRead+0x186>
    342c:	1d c0       	rjmp	.+58     	; 0x3468 <vTaskUSARTRead+0x108>
                while(1) {
                    while((bytesRecieved < size+1) && (timeout < 50)){  //1 for crc
                        if(UCSR1A & (1<<RXC1)){
    342e:	e8 ec       	ldi	r30, 0xC8	; 200
    3430:	f0 e0       	ldi	r31, 0x00	; 0
    3432:	80 81       	ld	r24, Z
    3434:	88 23       	and	r24, r24
    3436:	a4 f4       	brge	.+40     	; 0x3460 <vTaskUSARTRead+0x100>
                            rxData = UDR1;
    3438:	ee ec       	ldi	r30, 0xCE	; 206
    343a:	f0 e0       	ldi	r31, 0x00	; 0
    343c:	80 81       	ld	r24, Z
    343e:	8e 83       	std	Y+6, r24	; 0x06

                            //PORTB = 0xFF;
                        //if(xQueueReceive(USART_ReadQueue,&rxData,portMAX_DELAY) == pdTRUE){
                            buffer[bytesRecieved] = rxData;
    3440:	8f 81       	ldd	r24, Y+7	; 0x07
    3442:	28 2f       	mov	r18, r24
    3444:	33 27       	eor	r19, r19
    3446:	27 fd       	sbrc	r18, 7
    3448:	30 95       	com	r19
    344a:	ce 01       	movw	r24, r28
    344c:	08 96       	adiw	r24, 0x08	; 8
    344e:	fc 01       	movw	r30, r24
    3450:	e2 0f       	add	r30, r18
    3452:	f3 1f       	adc	r31, r19
    3454:	8e 81       	ldd	r24, Y+6	; 0x06
    3456:	80 83       	st	Z, r24
                            bytesRecieved++;
    3458:	8f 81       	ldd	r24, Y+7	; 0x07
    345a:	8f 5f       	subi	r24, 0xFF	; 255
    345c:	8f 83       	std	Y+7, r24	; 0x07
    345e:	04 c0       	rjmp	.+8      	; 0x3468 <vTaskUSARTRead+0x108>
                        } else {
                            //timeout++;
                            timeout = 1;
    3460:	81 e0       	ldi	r24, 0x01	; 1
    3462:	90 e0       	ldi	r25, 0x00	; 0
    3464:	9a 83       	std	Y+2, r25	; 0x02
    3466:	89 83       	std	Y+1, r24	; 0x01
            command.crc = buffer[3];
            size = buffer[2];
            timeout = 0;
            if(size != 0){
                while(1) {
                    while((bytesRecieved < size+1) && (timeout < 50)){  //1 for crc
    3468:	8f 81       	ldd	r24, Y+7	; 0x07
    346a:	28 2f       	mov	r18, r24
    346c:	33 27       	eor	r19, r19
    346e:	27 fd       	sbrc	r18, 7
    3470:	30 95       	com	r19
    3472:	8d 81       	ldd	r24, Y+5	; 0x05
    3474:	99 27       	eor	r25, r25
    3476:	87 fd       	sbrc	r24, 7
    3478:	90 95       	com	r25
    347a:	01 96       	adiw	r24, 0x01	; 1
    347c:	28 17       	cp	r18, r24
    347e:	39 07       	cpc	r19, r25
    3480:	2c f4       	brge	.+10     	; 0x348c <vTaskUSARTRead+0x12c>
    3482:	89 81       	ldd	r24, Y+1	; 0x01
    3484:	9a 81       	ldd	r25, Y+2	; 0x02
    3486:	82 33       	cpi	r24, 0x32	; 50
    3488:	91 05       	cpc	r25, r1
    348a:	88 f2       	brcs	.-94     	; 0x342e <vTaskUSARTRead+0xce>
                        } else {
                            //timeout++;
                            timeout = 1;
                        }
                    } 
                    if(timeout >= 50){
    348c:	89 81       	ldd	r24, Y+1	; 0x01
    348e:	9a 81       	ldd	r25, Y+2	; 0x02
    3490:	82 33       	cpi	r24, 0x32	; 50
    3492:	91 05       	cpc	r25, r1
    3494:	40 f5       	brcc	.+80     	; 0x34e6 <vTaskUSARTRead+0x186>
                        break;
                    }
                    if(calcChecksum(buffer,size) != buffer[size]){
    3496:	2d 81       	ldd	r18, Y+5	; 0x05
    3498:	ce 01       	movw	r24, r28
    349a:	08 96       	adiw	r24, 0x08	; 8
    349c:	62 2f       	mov	r22, r18
    349e:	0e 94 ff 1a 	call	0x35fe	; 0x35fe <calcChecksum>
    34a2:	48 2f       	mov	r20, r24
    34a4:	8d 81       	ldd	r24, Y+5	; 0x05
    34a6:	28 2f       	mov	r18, r24
    34a8:	33 27       	eor	r19, r19
    34aa:	27 fd       	sbrc	r18, 7
    34ac:	30 95       	com	r19
    34ae:	ce 01       	movw	r24, r28
    34b0:	08 96       	adiw	r24, 0x08	; 8
    34b2:	fc 01       	movw	r30, r24
    34b4:	e2 0f       	add	r30, r18
    34b6:	f3 1f       	adc	r31, r19
    34b8:	80 81       	ld	r24, Z
    34ba:	48 17       	cp	r20, r24
    34bc:	21 f0       	breq	.+8      	; 0x34c6 <vTaskUSARTRead+0x166>
                        sendNACK();
    34be:	0e 94 df 1a 	call	0x35be	; 0x35be <sendNACK>
                        bytesRecieved = 0;
    34c2:	1f 82       	std	Y+7, r1	; 0x07
    34c4:	d1 cf       	rjmp	.-94     	; 0x3468 <vTaskUSARTRead+0x108>
                    } else {
                        //PORTB = buffer[0];
                        sendACK();
    34c6:	0e 94 d5 1a 	call	0x35aa	; 0x35aa <sendACK>
                        memcpy(command.payload,buffer,size);
    34ca:	8d 81       	ldd	r24, Y+5	; 0x05
    34cc:	48 2f       	mov	r20, r24
    34ce:	55 27       	eor	r21, r21
    34d0:	47 fd       	sbrc	r20, 7
    34d2:	50 95       	com	r21
    34d4:	ce 01       	movw	r24, r28
    34d6:	40 96       	adiw	r24, 0x10	; 16
    34d8:	03 96       	adiw	r24, 0x03	; 3
    34da:	9e 01       	movw	r18, r28
    34dc:	28 5f       	subi	r18, 0xF8	; 248
    34de:	3f 4f       	sbci	r19, 0xFF	; 255
    34e0:	b9 01       	movw	r22, r18
    34e2:	0e 94 11 20 	call	0x4022	; 0x4022 <memcpy>
                        break;
                    }
                }
            }
            processCommand(&command,&response);
    34e6:	ce 01       	movw	r24, r28
    34e8:	40 96       	adiw	r24, 0x10	; 16
    34ea:	9e 01       	movw	r18, r28
    34ec:	2d 5c       	subi	r18, 0xCD	; 205
    34ee:	3f 4f       	sbci	r19, 0xFF	; 255
    34f0:	b9 01       	movw	r22, r18
    34f2:	0e 94 01 1d 	call	0x3a02	; 0x3a02 <processCommand>
            sendResponse(&response);
    34f6:	ce 01       	movw	r24, r28
    34f8:	c3 96       	adiw	r24, 0x33	; 51
    34fa:	0e 94 80 1a 	call	0x3500	; 0x3500 <sendResponse>
    34fe:	43 cf       	rjmp	.-378    	; 0x3386 <vTaskUSARTRead+0x26>

00003500 <sendResponse>:

    }

}

void sendResponse(Response* response){
    3500:	df 93       	push	r29
    3502:	cf 93       	push	r28
    3504:	00 d0       	rcall	.+0      	; 0x3506 <sendResponse+0x6>
    3506:	00 d0       	rcall	.+0      	; 0x3508 <sendResponse+0x8>
    3508:	cd b7       	in	r28, 0x3d	; 61
    350a:	de b7       	in	r29, 0x3e	; 62
    350c:	9e 83       	std	Y+6, r25	; 0x06
    350e:	8d 83       	std	Y+5, r24	; 0x05
    char checksumBuffer[2];
    int i;
    while(1){
        USART_AddToQueue(response->commandBack);
    3510:	ed 81       	ldd	r30, Y+5	; 0x05
    3512:	fe 81       	ldd	r31, Y+6	; 0x06
    3514:	80 81       	ld	r24, Z
    3516:	0e 94 04 19 	call	0x3208	; 0x3208 <USART_AddToQueue>
        USART_AddToQueue(response->size);
    351a:	ed 81       	ldd	r30, Y+5	; 0x05
    351c:	fe 81       	ldd	r31, Y+6	; 0x06
    351e:	81 81       	ldd	r24, Z+1	; 0x01
    3520:	0e 94 04 19 	call	0x3208	; 0x3208 <USART_AddToQueue>
        checksumBuffer[0] = response->commandBack;
    3524:	ed 81       	ldd	r30, Y+5	; 0x05
    3526:	fe 81       	ldd	r31, Y+6	; 0x06
    3528:	80 81       	ld	r24, Z
    352a:	8b 83       	std	Y+3, r24	; 0x03
        checksumBuffer[1] = response->size;
    352c:	ed 81       	ldd	r30, Y+5	; 0x05
    352e:	fe 81       	ldd	r31, Y+6	; 0x06
    3530:	81 81       	ldd	r24, Z+1	; 0x01
    3532:	8c 83       	std	Y+4, r24	; 0x04
        USART_AddToQueue(calcChecksum(checksumBuffer,2));
    3534:	ce 01       	movw	r24, r28
    3536:	03 96       	adiw	r24, 0x03	; 3
    3538:	62 e0       	ldi	r22, 0x02	; 2
    353a:	0e 94 ff 1a 	call	0x35fe	; 0x35fe <calcChecksum>
    353e:	0e 94 04 19 	call	0x3208	; 0x3208 <USART_AddToQueue>
        if(waitForChecksum() == 0){
    3542:	0e 94 e9 1a 	call	0x35d2	; 0x35d2 <waitForChecksum>
    3546:	88 23       	and	r24, r24
    3548:	19 f7       	brne	.-58     	; 0x3510 <sendResponse+0x10>
            break;
        }
    }

    for(i=0;i<response->size;i++){
    354a:	1a 82       	std	Y+2, r1	; 0x02
    354c:	19 82       	std	Y+1, r1	; 0x01
    354e:	10 c0       	rjmp	.+32     	; 0x3570 <sendResponse+0x70>
        USART_AddToQueue(response->payload[i]);
    3550:	29 81       	ldd	r18, Y+1	; 0x01
    3552:	3a 81       	ldd	r19, Y+2	; 0x02
    3554:	8d 81       	ldd	r24, Y+5	; 0x05
    3556:	9e 81       	ldd	r25, Y+6	; 0x06
    3558:	82 0f       	add	r24, r18
    355a:	93 1f       	adc	r25, r19
    355c:	fc 01       	movw	r30, r24
    355e:	32 96       	adiw	r30, 0x02	; 2
    3560:	80 81       	ld	r24, Z
    3562:	0e 94 04 19 	call	0x3208	; 0x3208 <USART_AddToQueue>
        if(waitForChecksum() == 0){
            break;
        }
    }

    for(i=0;i<response->size;i++){
    3566:	89 81       	ldd	r24, Y+1	; 0x01
    3568:	9a 81       	ldd	r25, Y+2	; 0x02
    356a:	01 96       	adiw	r24, 0x01	; 1
    356c:	9a 83       	std	Y+2, r25	; 0x02
    356e:	89 83       	std	Y+1, r24	; 0x01
    3570:	ed 81       	ldd	r30, Y+5	; 0x05
    3572:	fe 81       	ldd	r31, Y+6	; 0x06
    3574:	81 81       	ldd	r24, Z+1	; 0x01
    3576:	28 2f       	mov	r18, r24
    3578:	33 27       	eor	r19, r19
    357a:	27 fd       	sbrc	r18, 7
    357c:	30 95       	com	r19
    357e:	89 81       	ldd	r24, Y+1	; 0x01
    3580:	9a 81       	ldd	r25, Y+2	; 0x02
    3582:	82 17       	cp	r24, r18
    3584:	93 07       	cpc	r25, r19
    3586:	24 f3       	brlt	.-56     	; 0x3550 <sendResponse+0x50>
        USART_AddToQueue(response->payload[i]);
        //USART_AddToQueue()
    }
    USART_AddToQueue(calcChecksum(response->payload,12));
    3588:	8d 81       	ldd	r24, Y+5	; 0x05
    358a:	9e 81       	ldd	r25, Y+6	; 0x06
    358c:	02 96       	adiw	r24, 0x02	; 2
    358e:	6c e0       	ldi	r22, 0x0C	; 12
    3590:	0e 94 ff 1a 	call	0x35fe	; 0x35fe <calcChecksum>
    3594:	0e 94 04 19 	call	0x3208	; 0x3208 <USART_AddToQueue>


}
    3598:	26 96       	adiw	r28, 0x06	; 6
    359a:	0f b6       	in	r0, 0x3f	; 63
    359c:	f8 94       	cli
    359e:	de bf       	out	0x3e, r29	; 62
    35a0:	0f be       	out	0x3f, r0	; 63
    35a2:	cd bf       	out	0x3d, r28	; 61
    35a4:	cf 91       	pop	r28
    35a6:	df 91       	pop	r29
    35a8:	08 95       	ret

000035aa <sendACK>:

void sendACK(){
    35aa:	df 93       	push	r29
    35ac:	cf 93       	push	r28
    35ae:	cd b7       	in	r28, 0x3d	; 61
    35b0:	de b7       	in	r29, 0x3e	; 62
    USART_AddToQueue(128);
    35b2:	80 e8       	ldi	r24, 0x80	; 128
    35b4:	0e 94 04 19 	call	0x3208	; 0x3208 <USART_AddToQueue>
}
    35b8:	cf 91       	pop	r28
    35ba:	df 91       	pop	r29
    35bc:	08 95       	ret

000035be <sendNACK>:

void sendNACK(){
    35be:	df 93       	push	r29
    35c0:	cf 93       	push	r28
    35c2:	cd b7       	in	r28, 0x3d	; 61
    35c4:	de b7       	in	r29, 0x3e	; 62
    USART_AddToQueue(0);
    35c6:	80 e0       	ldi	r24, 0x00	; 0
    35c8:	0e 94 04 19 	call	0x3208	; 0x3208 <USART_AddToQueue>
}
    35cc:	cf 91       	pop	r28
    35ce:	df 91       	pop	r29
    35d0:	08 95       	ret

000035d2 <waitForChecksum>:

char waitForChecksum(){
    35d2:	df 93       	push	r29
    35d4:	cf 93       	push	r28
    35d6:	cd b7       	in	r28, 0x3d	; 61
    35d8:	de b7       	in	r29, 0x3e	; 62
    while(1){
        if(UCSR1A & (1<<RXC1)){
    35da:	e8 ec       	ldi	r30, 0xC8	; 200
    35dc:	f0 e0       	ldi	r31, 0x00	; 0
    35de:	80 81       	ld	r24, Z
    35e0:	88 23       	and	r24, r24
    35e2:	44 f4       	brge	.+16     	; 0x35f4 <waitForChecksum+0x22>
            if(UDR1 = 0xFF) {
    35e4:	ee ec       	ldi	r30, 0xCE	; 206
    35e6:	f0 e0       	ldi	r31, 0x00	; 0
    35e8:	8f ef       	ldi	r24, 0xFF	; 255
    35ea:	80 83       	st	Z, r24
                return 0;
    35ec:	80 e0       	ldi	r24, 0x00	; 0
        } else {
            vTaskDelay(1);
        }

    }
}
    35ee:	cf 91       	pop	r28
    35f0:	df 91       	pop	r29
    35f2:	08 95       	ret
            } else {
                return -1;
            }

        } else {
            vTaskDelay(1);
    35f4:	81 e0       	ldi	r24, 0x01	; 1
    35f6:	90 e0       	ldi	r25, 0x00	; 0
    35f8:	0e 94 b4 03 	call	0x768	; 0x768 <vTaskDelay>
    35fc:	ee cf       	rjmp	.-36     	; 0x35da <waitForChecksum+0x8>

000035fe <calcChecksum>:
        }

    }
}

uint8_t calcChecksum(uint8_t* buffer,uint8_t size){
    35fe:	df 93       	push	r29
    3600:	cf 93       	push	r28
    3602:	00 d0       	rcall	.+0      	; 0x3604 <calcChecksum+0x6>
    3604:	0f 92       	push	r0
    3606:	0f 92       	push	r0
    3608:	cd b7       	in	r28, 0x3d	; 61
    360a:	de b7       	in	r29, 0x3e	; 62
    360c:	9b 83       	std	Y+3, r25	; 0x03
    360e:	8a 83       	std	Y+2, r24	; 0x02
    3610:	6c 83       	std	Y+4, r22	; 0x04
    uint8_t checksum = 0;
    3612:	19 82       	std	Y+1, r1	; 0x01
    3614:	0b c0       	rjmp	.+22     	; 0x362c <calcChecksum+0x2e>
    while(size-- > 0){
        checksum += *(buffer++);
    3616:	ea 81       	ldd	r30, Y+2	; 0x02
    3618:	fb 81       	ldd	r31, Y+3	; 0x03
    361a:	90 81       	ld	r25, Z
    361c:	89 81       	ldd	r24, Y+1	; 0x01
    361e:	89 0f       	add	r24, r25
    3620:	89 83       	std	Y+1, r24	; 0x01
    3622:	8a 81       	ldd	r24, Y+2	; 0x02
    3624:	9b 81       	ldd	r25, Y+3	; 0x03
    3626:	01 96       	adiw	r24, 0x01	; 1
    3628:	9b 83       	std	Y+3, r25	; 0x03
    362a:	8a 83       	std	Y+2, r24	; 0x02
    }
}

uint8_t calcChecksum(uint8_t* buffer,uint8_t size){
    uint8_t checksum = 0;
    while(size-- > 0){
    362c:	8c 81       	ldd	r24, Y+4	; 0x04
    362e:	8d 83       	std	Y+5, r24	; 0x05
    3630:	8d 81       	ldd	r24, Y+5	; 0x05
    3632:	88 23       	and	r24, r24
    3634:	11 f0       	breq	.+4      	; 0x363a <calcChecksum+0x3c>
    3636:	81 e0       	ldi	r24, 0x01	; 1
    3638:	8d 83       	std	Y+5, r24	; 0x05
    363a:	8d 81       	ldd	r24, Y+5	; 0x05
    363c:	9c 81       	ldd	r25, Y+4	; 0x04
    363e:	91 50       	subi	r25, 0x01	; 1
    3640:	9c 83       	std	Y+4, r25	; 0x04
    3642:	88 23       	and	r24, r24
    3644:	41 f7       	brne	.-48     	; 0x3616 <calcChecksum+0x18>
        checksum += *(buffer++);
    }
    return checksum;
    3646:	89 81       	ldd	r24, Y+1	; 0x01
    3648:	0f 90       	pop	r0
    364a:	0f 90       	pop	r0
    364c:	0f 90       	pop	r0
    364e:	0f 90       	pop	r0
    3650:	0f 90       	pop	r0
    3652:	cf 91       	pop	r28
    3654:	df 91       	pop	r29
    3656:	08 95       	ret

00003658 <commandIntegCheck>:
#include "protocol.h"
#include "Components/Sonar/Sonar.h"


//function to CRC the command structure
char commandIntegCheck(Command *command) {
    3658:	df 93       	push	r29
    365a:	cf 93       	push	r28
    365c:	0f 92       	push	r0
    365e:	0f 92       	push	r0
    3660:	cd b7       	in	r28, 0x3d	; 61
    3662:	de b7       	in	r29, 0x3e	; 62
    3664:	9a 83       	std	Y+2, r25	; 0x02
    3666:	89 83       	std	Y+1, r24	; 0x01
   //CRC the command with 0x00 in place of the CRC
   //return success for now
   return 1;
    3668:	81 e0       	ldi	r24, 0x01	; 1
}
    366a:	0f 90       	pop	r0
    366c:	0f 90       	pop	r0
    366e:	cf 91       	pop	r28
    3670:	df 91       	pop	r29
    3672:	08 95       	ret

00003674 <processUltrasonicCommand>:

char processUltrasonicCommand(char commandCode, void* commandData,char* size, void* responseData) {
    3674:	df 93       	push	r29
    3676:	cf 93       	push	r28
    3678:	cd b7       	in	r28, 0x3d	; 61
    367a:	de b7       	in	r29, 0x3e	; 62
    367c:	29 97       	sbiw	r28, 0x09	; 9
    367e:	0f b6       	in	r0, 0x3f	; 63
    3680:	f8 94       	cli
    3682:	de bf       	out	0x3e, r29	; 62
    3684:	0f be       	out	0x3f, r0	; 63
    3686:	cd bf       	out	0x3d, r28	; 61
    3688:	89 83       	std	Y+1, r24	; 0x01
    368a:	7b 83       	std	Y+3, r23	; 0x03
    368c:	6a 83       	std	Y+2, r22	; 0x02
    368e:	5d 83       	std	Y+5, r21	; 0x05
    3690:	4c 83       	std	Y+4, r20	; 0x04
    3692:	3f 83       	std	Y+7, r19	; 0x07
    3694:	2e 83       	std	Y+6, r18	; 0x06
   switch(commandCode) {
    3696:	89 81       	ldd	r24, Y+1	; 0x01
    3698:	28 2f       	mov	r18, r24
    369a:	33 27       	eor	r19, r19
    369c:	27 fd       	sbrc	r18, 7
    369e:	30 95       	com	r19
    36a0:	39 87       	std	Y+9, r19	; 0x09
    36a2:	28 87       	std	Y+8, r18	; 0x08
    36a4:	88 85       	ldd	r24, Y+8	; 0x08
    36a6:	99 85       	ldd	r25, Y+9	; 0x09
    36a8:	82 30       	cpi	r24, 0x02	; 2
    36aa:	91 05       	cpc	r25, r1
    36ac:	99 f0       	breq	.+38     	; 0x36d4 <processUltrasonicCommand+0x60>
    36ae:	28 85       	ldd	r18, Y+8	; 0x08
    36b0:	39 85       	ldd	r19, Y+9	; 0x09
    36b2:	23 30       	cpi	r18, 0x03	; 3
    36b4:	31 05       	cpc	r19, r1
    36b6:	b9 f0       	breq	.+46     	; 0x36e6 <processUltrasonicCommand+0x72>
    36b8:	88 85       	ldd	r24, Y+8	; 0x08
    36ba:	99 85       	ldd	r25, Y+9	; 0x09
    36bc:	81 30       	cpi	r24, 0x01	; 1
    36be:	91 05       	cpc	r25, r1
    36c0:	d1 f4       	brne	.+52     	; 0x36f6 <processUltrasonicCommand+0x82>
      case GET_ALL_SENSORS:
         getAllSensors((int*) responseData);
    36c2:	8e 81       	ldd	r24, Y+6	; 0x06
    36c4:	9f 81       	ldd	r25, Y+7	; 0x07
    36c6:	0e 94 af 1e 	call	0x3d5e	; 0x3d5e <getAllSensors>
         *size = 12;
    36ca:	ec 81       	ldd	r30, Y+4	; 0x04
    36cc:	fd 81       	ldd	r31, Y+5	; 0x05
    36ce:	8c e0       	ldi	r24, 0x0C	; 12
    36d0:	80 83       	st	Z, r24
    36d2:	11 c0       	rjmp	.+34     	; 0x36f6 <processUltrasonicCommand+0x82>
         break;
      case GET_CERTAIN_SENSORS:
         getCertainSensor(((char*)commandData)[0], (int*) responseData);
    36d4:	ea 81       	ldd	r30, Y+2	; 0x02
    36d6:	fb 81       	ldd	r31, Y+3	; 0x03
    36d8:	80 81       	ld	r24, Z
    36da:	2e 81       	ldd	r18, Y+6	; 0x06
    36dc:	3f 81       	ldd	r19, Y+7	; 0x07
    36de:	b9 01       	movw	r22, r18
    36e0:	0e 94 e4 1e 	call	0x3dc8	; 0x3dc8 <getCertainSensor>
    36e4:	08 c0       	rjmp	.+16     	; 0x36f6 <processUltrasonicCommand+0x82>
         break;
      case GET_SENSOR_GROUP:
         getSensorGroup(((char*)commandData)[0], (int*) responseData);
    36e6:	ea 81       	ldd	r30, Y+2	; 0x02
    36e8:	fb 81       	ldd	r31, Y+3	; 0x03
    36ea:	80 81       	ld	r24, Z
    36ec:	2e 81       	ldd	r18, Y+6	; 0x06
    36ee:	3f 81       	ldd	r19, Y+7	; 0x07
    36f0:	b9 01       	movw	r22, r18
    36f2:	0e 94 12 1f 	call	0x3e24	; 0x3e24 <getSensorGroup>
         break;
   }
   //return success for now...
   return 1;
    36f6:	81 e0       	ldi	r24, 0x01	; 1
}
    36f8:	29 96       	adiw	r28, 0x09	; 9
    36fa:	0f b6       	in	r0, 0x3f	; 63
    36fc:	f8 94       	cli
    36fe:	de bf       	out	0x3e, r29	; 62
    3700:	0f be       	out	0x3f, r0	; 63
    3702:	cd bf       	out	0x3d, r28	; 61
    3704:	cf 91       	pop	r28
    3706:	df 91       	pop	r29
    3708:	08 95       	ret

0000370a <processSpeedCommand>:

char processSpeedCommand(char commandCode, void* commandData, void* responseData) {
    370a:	df 93       	push	r29
    370c:	cf 93       	push	r28
    370e:	cd b7       	in	r28, 0x3d	; 61
    3710:	de b7       	in	r29, 0x3e	; 62
    3712:	27 97       	sbiw	r28, 0x07	; 7
    3714:	0f b6       	in	r0, 0x3f	; 63
    3716:	f8 94       	cli
    3718:	de bf       	out	0x3e, r29	; 62
    371a:	0f be       	out	0x3f, r0	; 63
    371c:	cd bf       	out	0x3d, r28	; 61
    371e:	89 83       	std	Y+1, r24	; 0x01
    3720:	7b 83       	std	Y+3, r23	; 0x03
    3722:	6a 83       	std	Y+2, r22	; 0x02
    3724:	5d 83       	std	Y+5, r21	; 0x05
    3726:	4c 83       	std	Y+4, r20	; 0x04
   switch(commandCode) {
    3728:	89 81       	ldd	r24, Y+1	; 0x01
    372a:	28 2f       	mov	r18, r24
    372c:	33 27       	eor	r19, r19
    372e:	27 fd       	sbrc	r18, 7
    3730:	30 95       	com	r19
    3732:	3f 83       	std	Y+7, r19	; 0x07
    3734:	2e 83       	std	Y+6, r18	; 0x06
    3736:	8e 81       	ldd	r24, Y+6	; 0x06
    3738:	9f 81       	ldd	r25, Y+7	; 0x07
    373a:	00 97       	sbiw	r24, 0x00	; 0
    373c:	31 f0       	breq	.+12     	; 0x374a <processSpeedCommand+0x40>
    373e:	2e 81       	ldd	r18, Y+6	; 0x06
    3740:	3f 81       	ldd	r19, Y+7	; 0x07
    3742:	21 30       	cpi	r18, 0x01	; 1
    3744:	31 05       	cpc	r19, r1
    3746:	31 f0       	breq	.+12     	; 0x3754 <processSpeedCommand+0x4a>
    3748:	0d c0       	rjmp	.+26     	; 0x3764 <processSpeedCommand+0x5a>
      case GET_SPEED:
         getSpeed((char*) responseData);
    374a:	8c 81       	ldd	r24, Y+4	; 0x04
    374c:	9d 81       	ldd	r25, Y+5	; 0x05
    374e:	0e 94 89 1f 	call	0x3f12	; 0x3f12 <getSpeed>
    3752:	08 c0       	rjmp	.+16     	; 0x3764 <processSpeedCommand+0x5a>
         break;
      case SET_SPEED:
         setSpeed(((char*)commandData)[0]);
    3754:	ea 81       	ldd	r30, Y+2	; 0x02
    3756:	fb 81       	ldd	r31, Y+3	; 0x03
    3758:	80 81       	ld	r24, Z
    375a:	99 27       	eor	r25, r25
    375c:	87 fd       	sbrc	r24, 7
    375e:	90 95       	com	r25
    3760:	0e 94 9a 1f 	call	0x3f34	; 0x3f34 <setSpeed>
         break;
   }
   //return success for now
   return 1;
    3764:	81 e0       	ldi	r24, 0x01	; 1
}
    3766:	27 96       	adiw	r28, 0x07	; 7
    3768:	0f b6       	in	r0, 0x3f	; 63
    376a:	f8 94       	cli
    376c:	de bf       	out	0x3e, r29	; 62
    376e:	0f be       	out	0x3f, r0	; 63
    3770:	cd bf       	out	0x3d, r28	; 61
    3772:	cf 91       	pop	r28
    3774:	df 91       	pop	r29
    3776:	08 95       	ret

00003778 <processSteeringCommand>:

char processSteeringCommand(char commandCode, void* commandData, void* responseData) {
    3778:	df 93       	push	r29
    377a:	cf 93       	push	r28
    377c:	cd b7       	in	r28, 0x3d	; 61
    377e:	de b7       	in	r29, 0x3e	; 62
    3780:	27 97       	sbiw	r28, 0x07	; 7
    3782:	0f b6       	in	r0, 0x3f	; 63
    3784:	f8 94       	cli
    3786:	de bf       	out	0x3e, r29	; 62
    3788:	0f be       	out	0x3f, r0	; 63
    378a:	cd bf       	out	0x3d, r28	; 61
    378c:	89 83       	std	Y+1, r24	; 0x01
    378e:	7b 83       	std	Y+3, r23	; 0x03
    3790:	6a 83       	std	Y+2, r22	; 0x02
    3792:	5d 83       	std	Y+5, r21	; 0x05
    3794:	4c 83       	std	Y+4, r20	; 0x04
   switch(commandCode) {
    3796:	89 81       	ldd	r24, Y+1	; 0x01
    3798:	28 2f       	mov	r18, r24
    379a:	33 27       	eor	r19, r19
    379c:	27 fd       	sbrc	r18, 7
    379e:	30 95       	com	r19
    37a0:	3f 83       	std	Y+7, r19	; 0x07
    37a2:	2e 83       	std	Y+6, r18	; 0x06
    37a4:	8e 81       	ldd	r24, Y+6	; 0x06
    37a6:	9f 81       	ldd	r25, Y+7	; 0x07
    37a8:	82 30       	cpi	r24, 0x02	; 2
    37aa:	91 05       	cpc	r25, r1
    37ac:	41 f1       	breq	.+80     	; 0x37fe <processSteeringCommand+0x86>
    37ae:	2e 81       	ldd	r18, Y+6	; 0x06
    37b0:	3f 81       	ldd	r19, Y+7	; 0x07
    37b2:	23 30       	cpi	r18, 0x03	; 3
    37b4:	31 05       	cpc	r19, r1
    37b6:	54 f4       	brge	.+20     	; 0x37cc <processSteeringCommand+0x54>
    37b8:	8e 81       	ldd	r24, Y+6	; 0x06
    37ba:	9f 81       	ldd	r25, Y+7	; 0x07
    37bc:	00 97       	sbiw	r24, 0x00	; 0
    37be:	89 f0       	breq	.+34     	; 0x37e2 <processSteeringCommand+0x6a>
    37c0:	2e 81       	ldd	r18, Y+6	; 0x06
    37c2:	3f 81       	ldd	r19, Y+7	; 0x07
    37c4:	21 30       	cpi	r18, 0x01	; 1
    37c6:	31 05       	cpc	r19, r1
    37c8:	a9 f0       	breq	.+42     	; 0x37f4 <processSteeringCommand+0x7c>
    37ca:	51 c0       	rjmp	.+162    	; 0x386e <processSteeringCommand+0xf6>
    37cc:	8e 81       	ldd	r24, Y+6	; 0x06
    37ce:	9f 81       	ldd	r25, Y+7	; 0x07
    37d0:	83 30       	cpi	r24, 0x03	; 3
    37d2:	91 05       	cpc	r25, r1
    37d4:	c9 f0       	breq	.+50     	; 0x3808 <processSteeringCommand+0x90>
    37d6:	2e 81       	ldd	r18, Y+6	; 0x06
    37d8:	3f 81       	ldd	r19, Y+7	; 0x07
    37da:	24 30       	cpi	r18, 0x04	; 4
    37dc:	31 05       	cpc	r19, r1
    37de:	99 f1       	breq	.+102    	; 0x3846 <processSteeringCommand+0xce>
    37e0:	46 c0       	rjmp	.+140    	; 0x386e <processSteeringCommand+0xf6>
      case SET_ANGLE:
         setAngle(*((char*)commandData));
    37e2:	ea 81       	ldd	r30, Y+2	; 0x02
    37e4:	fb 81       	ldd	r31, Y+3	; 0x03
    37e6:	80 81       	ld	r24, Z
    37e8:	99 27       	eor	r25, r25
    37ea:	87 fd       	sbrc	r24, 7
    37ec:	90 95       	com	r25
    37ee:	0e 94 a5 1f 	call	0x3f4a	; 0x3f4a <setAngle>
    37f2:	3d c0       	rjmp	.+122    	; 0x386e <processSteeringCommand+0xf6>
         break;
      case GET_ANGLE:
         getAngle((char*) responseData);
    37f4:	8c 81       	ldd	r24, Y+4	; 0x04
    37f6:	9d 81       	ldd	r25, Y+5	; 0x05
    37f8:	0e 94 b0 1f 	call	0x3f60	; 0x3f60 <getAngle>
    37fc:	38 c0       	rjmp	.+112    	; 0x386e <processSteeringCommand+0xf6>
         break;
      case GET_DESIRED_ANGLE:
         getDesiredAngle((char*) responseData);
    37fe:	8c 81       	ldd	r24, Y+4	; 0x04
    3800:	9d 81       	ldd	r25, Y+5	; 0x05
    3802:	0e 94 c1 1f 	call	0x3f82	; 0x3f82 <getDesiredAngle>
    3806:	33 c0       	rjmp	.+102    	; 0x386e <processSteeringCommand+0xf6>
         break;
      case CHANGE_PID:
         changePID(((char*)commandData)[0], ((char*)commandData)[1], ((char*)commandData)[2]);
    3808:	ea 81       	ldd	r30, Y+2	; 0x02
    380a:	fb 81       	ldd	r31, Y+3	; 0x03
    380c:	80 81       	ld	r24, Z
    380e:	68 2f       	mov	r22, r24
    3810:	77 27       	eor	r23, r23
    3812:	67 fd       	sbrc	r22, 7
    3814:	70 95       	com	r23
    3816:	8a 81       	ldd	r24, Y+2	; 0x02
    3818:	9b 81       	ldd	r25, Y+3	; 0x03
    381a:	fc 01       	movw	r30, r24
    381c:	31 96       	adiw	r30, 0x01	; 1
    381e:	80 81       	ld	r24, Z
    3820:	48 2f       	mov	r20, r24
    3822:	55 27       	eor	r21, r21
    3824:	47 fd       	sbrc	r20, 7
    3826:	50 95       	com	r21
    3828:	8a 81       	ldd	r24, Y+2	; 0x02
    382a:	9b 81       	ldd	r25, Y+3	; 0x03
    382c:	fc 01       	movw	r30, r24
    382e:	32 96       	adiw	r30, 0x02	; 2
    3830:	80 81       	ld	r24, Z
    3832:	28 2f       	mov	r18, r24
    3834:	33 27       	eor	r19, r19
    3836:	27 fd       	sbrc	r18, 7
    3838:	30 95       	com	r19
    383a:	cb 01       	movw	r24, r22
    383c:	ba 01       	movw	r22, r20
    383e:	a9 01       	movw	r20, r18
    3840:	0e 94 d2 1f 	call	0x3fa4	; 0x3fa4 <changePID>
    3844:	14 c0       	rjmp	.+40     	; 0x386e <processSteeringCommand+0xf6>
         break;
      case SET_LIMITS:
         setLimits(((char*)commandData)[0], ((char*)commandData)[1]);
    3846:	ea 81       	ldd	r30, Y+2	; 0x02
    3848:	fb 81       	ldd	r31, Y+3	; 0x03
    384a:	80 81       	ld	r24, Z
    384c:	48 2f       	mov	r20, r24
    384e:	55 27       	eor	r21, r21
    3850:	47 fd       	sbrc	r20, 7
    3852:	50 95       	com	r21
    3854:	8a 81       	ldd	r24, Y+2	; 0x02
    3856:	9b 81       	ldd	r25, Y+3	; 0x03
    3858:	fc 01       	movw	r30, r24
    385a:	31 96       	adiw	r30, 0x01	; 1
    385c:	80 81       	ld	r24, Z
    385e:	28 2f       	mov	r18, r24
    3860:	33 27       	eor	r19, r19
    3862:	27 fd       	sbrc	r18, 7
    3864:	30 95       	com	r19
    3866:	ca 01       	movw	r24, r20
    3868:	b9 01       	movw	r22, r18
    386a:	0e 94 e1 1f 	call	0x3fc2	; 0x3fc2 <setLimits>
         break;
   }
   //return success for now
   return 1;
    386e:	81 e0       	ldi	r24, 0x01	; 1
}
    3870:	27 96       	adiw	r28, 0x07	; 7
    3872:	0f b6       	in	r0, 0x3f	; 63
    3874:	f8 94       	cli
    3876:	de bf       	out	0x3e, r29	; 62
    3878:	0f be       	out	0x3f, r0	; 63
    387a:	cd bf       	out	0x3d, r28	; 61
    387c:	cf 91       	pop	r28
    387e:	df 91       	pop	r29
    3880:	08 95       	ret

00003882 <processFNRCommand>:

char processFNRCommand(char commandCode, void* commandData, void* responseData) {
    3882:	df 93       	push	r29
    3884:	cf 93       	push	r28
    3886:	cd b7       	in	r28, 0x3d	; 61
    3888:	de b7       	in	r29, 0x3e	; 62
    388a:	28 97       	sbiw	r28, 0x08	; 8
    388c:	0f b6       	in	r0, 0x3f	; 63
    388e:	f8 94       	cli
    3890:	de bf       	out	0x3e, r29	; 62
    3892:	0f be       	out	0x3f, r0	; 63
    3894:	cd bf       	out	0x3d, r28	; 61
    3896:	89 83       	std	Y+1, r24	; 0x01
    3898:	7b 83       	std	Y+3, r23	; 0x03
    389a:	6a 83       	std	Y+2, r22	; 0x02
    389c:	5d 83       	std	Y+5, r21	; 0x05
    389e:	4c 83       	std	Y+4, r20	; 0x04
   switch(commandCode) {
    38a0:	89 81       	ldd	r24, Y+1	; 0x01
    38a2:	28 2f       	mov	r18, r24
    38a4:	33 27       	eor	r19, r19
    38a6:	27 fd       	sbrc	r18, 7
    38a8:	30 95       	com	r19
    38aa:	3f 83       	std	Y+7, r19	; 0x07
    38ac:	2e 83       	std	Y+6, r18	; 0x06
    38ae:	8e 81       	ldd	r24, Y+6	; 0x06
    38b0:	9f 81       	ldd	r25, Y+7	; 0x07
    38b2:	00 97       	sbiw	r24, 0x00	; 0
    38b4:	31 f0       	breq	.+12     	; 0x38c2 <processFNRCommand+0x40>
    38b6:	2e 81       	ldd	r18, Y+6	; 0x06
    38b8:	3f 81       	ldd	r19, Y+7	; 0x07
    38ba:	21 30       	cpi	r18, 0x01	; 1
    38bc:	31 05       	cpc	r19, r1
    38be:	51 f0       	breq	.+20     	; 0x38d4 <processFNRCommand+0x52>
    38c0:	0d c0       	rjmp	.+26     	; 0x38dc <processFNRCommand+0x5a>
      case SET_FNR:
         setFNR(*((char*)commandData));
    38c2:	ea 81       	ldd	r30, Y+2	; 0x02
    38c4:	fb 81       	ldd	r31, Y+3	; 0x03
    38c6:	80 81       	ld	r24, Z
    38c8:	99 27       	eor	r25, r25
    38ca:	87 fd       	sbrc	r24, 7
    38cc:	90 95       	com	r25
    38ce:	0e 94 7b 1d 	call	0x3af6	; 0x3af6 <setFNR>
    38d2:	04 c0       	rjmp	.+8      	; 0x38dc <processFNRCommand+0x5a>
         break;
      case GET_FNR:
         getFNR((char*) responseData);
    38d4:	8c 81       	ldd	r24, Y+4	; 0x04
    38d6:	9d 81       	ldd	r25, Y+5	; 0x05
    38d8:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <getFNR>
         break;
   }
}
    38dc:	28 96       	adiw	r28, 0x08	; 8
    38de:	0f b6       	in	r0, 0x3f	; 63
    38e0:	f8 94       	cli
    38e2:	de bf       	out	0x3e, r29	; 62
    38e4:	0f be       	out	0x3f, r0	; 63
    38e6:	cd bf       	out	0x3d, r28	; 61
    38e8:	cf 91       	pop	r28
    38ea:	df 91       	pop	r29
    38ec:	08 95       	ret

000038ee <processBrakeCommand>:

char processBrakeCommand(char commandCode, void* commandData, void* responseData) {
    38ee:	df 93       	push	r29
    38f0:	cf 93       	push	r28
    38f2:	cd b7       	in	r28, 0x3d	; 61
    38f4:	de b7       	in	r29, 0x3e	; 62
    38f6:	28 97       	sbiw	r28, 0x08	; 8
    38f8:	0f b6       	in	r0, 0x3f	; 63
    38fa:	f8 94       	cli
    38fc:	de bf       	out	0x3e, r29	; 62
    38fe:	0f be       	out	0x3f, r0	; 63
    3900:	cd bf       	out	0x3d, r28	; 61
    3902:	89 83       	std	Y+1, r24	; 0x01
    3904:	7b 83       	std	Y+3, r23	; 0x03
    3906:	6a 83       	std	Y+2, r22	; 0x02
    3908:	5d 83       	std	Y+5, r21	; 0x05
    390a:	4c 83       	std	Y+4, r20	; 0x04
   switch(commandCode) {
    390c:	89 81       	ldd	r24, Y+1	; 0x01
    390e:	28 2f       	mov	r18, r24
    3910:	33 27       	eor	r19, r19
    3912:	27 fd       	sbrc	r18, 7
    3914:	30 95       	com	r19
    3916:	3f 83       	std	Y+7, r19	; 0x07
    3918:	2e 83       	std	Y+6, r18	; 0x06
    391a:	8e 81       	ldd	r24, Y+6	; 0x06
    391c:	9f 81       	ldd	r25, Y+7	; 0x07
    391e:	00 97       	sbiw	r24, 0x00	; 0
    3920:	31 f0       	breq	.+12     	; 0x392e <processBrakeCommand+0x40>
    3922:	2e 81       	ldd	r18, Y+6	; 0x06
    3924:	3f 81       	ldd	r19, Y+7	; 0x07
    3926:	21 30       	cpi	r18, 0x01	; 1
    3928:	31 05       	cpc	r19, r1
    392a:	51 f0       	breq	.+20     	; 0x3940 <processBrakeCommand+0x52>
    392c:	0d c0       	rjmp	.+26     	; 0x3948 <processBrakeCommand+0x5a>
      case SET_BRAKE:
	 setBrake(*((char*)commandData));
    392e:	ea 81       	ldd	r30, Y+2	; 0x02
    3930:	fb 81       	ldd	r31, Y+3	; 0x03
    3932:	80 81       	ld	r24, Z
    3934:	99 27       	eor	r25, r25
    3936:	87 fd       	sbrc	r24, 7
    3938:	90 95       	com	r25
    393a:	0e 94 5f 1d 	call	0x3abe	; 0x3abe <setBrake>
    393e:	04 c0       	rjmp	.+8      	; 0x3948 <processBrakeCommand+0x5a>
	 break;
      case GET_BRAKE:
	 getBrake((char*) responseData);
    3940:	8c 81       	ldd	r24, Y+4	; 0x04
    3942:	9d 81       	ldd	r25, Y+5	; 0x05
    3944:	0e 94 6a 1d 	call	0x3ad4	; 0x3ad4 <getBrake>
	 break; 
   }
}
    3948:	28 96       	adiw	r28, 0x08	; 8
    394a:	0f b6       	in	r0, 0x3f	; 63
    394c:	f8 94       	cli
    394e:	de bf       	out	0x3e, r29	; 62
    3950:	0f be       	out	0x3f, r0	; 63
    3952:	cd bf       	out	0x3d, r28	; 61
    3954:	cf 91       	pop	r28
    3956:	df 91       	pop	r29
    3958:	08 95       	ret

0000395a <processBatteryCommand>:

char processBatteryCommand(char commandCode, void* commandData, void* responseData) {
    395a:	df 93       	push	r29
    395c:	cf 93       	push	r28
    395e:	cd b7       	in	r28, 0x3d	; 61
    3960:	de b7       	in	r29, 0x3e	; 62
    3962:	28 97       	sbiw	r28, 0x08	; 8
    3964:	0f b6       	in	r0, 0x3f	; 63
    3966:	f8 94       	cli
    3968:	de bf       	out	0x3e, r29	; 62
    396a:	0f be       	out	0x3f, r0	; 63
    396c:	cd bf       	out	0x3d, r28	; 61
    396e:	89 83       	std	Y+1, r24	; 0x01
    3970:	7b 83       	std	Y+3, r23	; 0x03
    3972:	6a 83       	std	Y+2, r22	; 0x02
    3974:	5d 83       	std	Y+5, r21	; 0x05
    3976:	4c 83       	std	Y+4, r20	; 0x04
   switch(commandCode) {
    3978:	89 81       	ldd	r24, Y+1	; 0x01
    397a:	28 2f       	mov	r18, r24
    397c:	33 27       	eor	r19, r19
    397e:	27 fd       	sbrc	r18, 7
    3980:	30 95       	com	r19
    3982:	3f 83       	std	Y+7, r19	; 0x07
    3984:	2e 83       	std	Y+6, r18	; 0x06
    3986:	8e 81       	ldd	r24, Y+6	; 0x06
    3988:	9f 81       	ldd	r25, Y+7	; 0x07
    398a:	00 97       	sbiw	r24, 0x00	; 0
    398c:	31 f0       	breq	.+12     	; 0x399a <processBatteryCommand+0x40>
    398e:	2e 81       	ldd	r18, Y+6	; 0x06
    3990:	3f 81       	ldd	r19, Y+7	; 0x07
    3992:	21 30       	cpi	r18, 0x01	; 1
    3994:	31 05       	cpc	r19, r1
    3996:	31 f0       	breq	.+12     	; 0x39a4 <processBatteryCommand+0x4a>
    3998:	09 c0       	rjmp	.+18     	; 0x39ac <processBatteryCommand+0x52>
      case GET_BATTERY_VOLTAGE:
         getBatteryVoltage((char*) responseData);
    399a:	8c 81       	ldd	r24, Y+4	; 0x04
    399c:	9d 81       	ldd	r25, Y+5	; 0x05
    399e:	0e 94 3d 1d 	call	0x3a7a	; 0x3a7a <getBatteryVoltage>
    39a2:	04 c0       	rjmp	.+8      	; 0x39ac <processBatteryCommand+0x52>
         break;
      case GET_STEERING_VOLTAGE:
         getSteeringVoltage((char*) responseData);
    39a4:	8c 81       	ldd	r24, Y+4	; 0x04
    39a6:	9d 81       	ldd	r25, Y+5	; 0x05
    39a8:	0e 94 4e 1d 	call	0x3a9c	; 0x3a9c <getSteeringVoltage>
         break;
   }
}
    39ac:	28 96       	adiw	r28, 0x08	; 8
    39ae:	0f b6       	in	r0, 0x3f	; 63
    39b0:	f8 94       	cli
    39b2:	de bf       	out	0x3e, r29	; 62
    39b4:	0f be       	out	0x3f, r0	; 63
    39b6:	cd bf       	out	0x3d, r28	; 61
    39b8:	cf 91       	pop	r28
    39ba:	df 91       	pop	r29
    39bc:	08 95       	ret

000039be <processLightCommand>:

char processLightCommand(char commandCode, void* commandData, void* responseDate) {
    39be:	df 93       	push	r29
    39c0:	cf 93       	push	r28
    39c2:	00 d0       	rcall	.+0      	; 0x39c4 <processLightCommand+0x6>
    39c4:	00 d0       	rcall	.+0      	; 0x39c6 <processLightCommand+0x8>
    39c6:	cd b7       	in	r28, 0x3d	; 61
    39c8:	de b7       	in	r29, 0x3e	; 62
    39ca:	89 83       	std	Y+1, r24	; 0x01
    39cc:	7b 83       	std	Y+3, r23	; 0x03
    39ce:	6a 83       	std	Y+2, r22	; 0x02
    39d0:	5d 83       	std	Y+5, r21	; 0x05
    39d2:	4c 83       	std	Y+4, r20	; 0x04
   switch(commandCode) {
    39d4:	89 81       	ldd	r24, Y+1	; 0x01
    39d6:	99 27       	eor	r25, r25
    39d8:	87 fd       	sbrc	r24, 7
    39da:	90 95       	com	r25
    39dc:	00 97       	sbiw	r24, 0x00	; 0
    39de:	41 f4       	brne	.+16     	; 0x39f0 <processLightCommand+0x32>
      case SET_LIGHT:
	 setLight(*((char*)commandData));
    39e0:	ea 81       	ldd	r30, Y+2	; 0x02
    39e2:	fb 81       	ldd	r31, Y+3	; 0x03
    39e4:	80 81       	ld	r24, Z
    39e6:	99 27       	eor	r25, r25
    39e8:	87 fd       	sbrc	r24, 7
    39ea:	90 95       	com	r25
    39ec:	0e 94 97 1d 	call	0x3b2e	; 0x3b2e <setLight>
         break;
   }
}
    39f0:	26 96       	adiw	r28, 0x06	; 6
    39f2:	0f b6       	in	r0, 0x3f	; 63
    39f4:	f8 94       	cli
    39f6:	de bf       	out	0x3e, r29	; 62
    39f8:	0f be       	out	0x3f, r0	; 63
    39fa:	cd bf       	out	0x3d, r28	; 61
    39fc:	cf 91       	pop	r28
    39fe:	df 91       	pop	r29
    3a00:	08 95       	ret

00003a02 <processCommand>:



//Function that will take in a command (as char array) and process it into a
//correct response to be stored into response
char processCommand(Command *command, Response *response) {
    3a02:	df 93       	push	r29
    3a04:	cf 93       	push	r28
    3a06:	00 d0       	rcall	.+0      	; 0x3a08 <processCommand+0x6>
    3a08:	0f 92       	push	r0
    3a0a:	0f 92       	push	r0
    3a0c:	cd b7       	in	r28, 0x3d	; 61
    3a0e:	de b7       	in	r29, 0x3e	; 62
    3a10:	9a 83       	std	Y+2, r25	; 0x02
    3a12:	89 83       	std	Y+1, r24	; 0x01
    3a14:	7c 83       	std	Y+4, r23	; 0x04
    3a16:	6b 83       	std	Y+3, r22	; 0x03
   if(commandIntegCheck(command)) {
    3a18:	89 81       	ldd	r24, Y+1	; 0x01
    3a1a:	9a 81       	ldd	r25, Y+2	; 0x02
    3a1c:	0e 94 2c 1b 	call	0x3658	; 0x3658 <commandIntegCheck>
    3a20:	88 23       	and	r24, r24
    3a22:	09 f1       	breq	.+66     	; 0x3a66 <processCommand+0x64>
      switch(command->groupID) {
    3a24:	e9 81       	ldd	r30, Y+1	; 0x01
    3a26:	fa 81       	ldd	r31, Y+2	; 0x02
    3a28:	80 81       	ld	r24, Z
    3a2a:	99 27       	eor	r25, r25
    3a2c:	87 fd       	sbrc	r24, 7
    3a2e:	90 95       	com	r25
    3a30:	81 30       	cpi	r24, 0x01	; 1
    3a32:	91 05       	cpc	r25, r1
    3a34:	a9 f4       	brne	.+42     	; 0x3a60 <processCommand+0x5e>
         case ULTRASONIC_GROUP:
            processUltrasonicCommand(command->cmd, command->payload,&response->size, response->payload);
    3a36:	e9 81       	ldd	r30, Y+1	; 0x01
    3a38:	fa 81       	ldd	r31, Y+2	; 0x02
    3a3a:	e1 81       	ldd	r30, Z+1	; 0x01
    3a3c:	89 81       	ldd	r24, Y+1	; 0x01
    3a3e:	9a 81       	ldd	r25, Y+2	; 0x02
    3a40:	bc 01       	movw	r22, r24
    3a42:	6d 5f       	subi	r22, 0xFD	; 253
    3a44:	7f 4f       	sbci	r23, 0xFF	; 255
    3a46:	8b 81       	ldd	r24, Y+3	; 0x03
    3a48:	9c 81       	ldd	r25, Y+4	; 0x04
    3a4a:	ac 01       	movw	r20, r24
    3a4c:	4f 5f       	subi	r20, 0xFF	; 255
    3a4e:	5f 4f       	sbci	r21, 0xFF	; 255
    3a50:	8b 81       	ldd	r24, Y+3	; 0x03
    3a52:	9c 81       	ldd	r25, Y+4	; 0x04
    3a54:	9c 01       	movw	r18, r24
    3a56:	2e 5f       	subi	r18, 0xFE	; 254
    3a58:	3f 4f       	sbci	r19, 0xFF	; 255
    3a5a:	8e 2f       	mov	r24, r30
    3a5c:	0e 94 3a 1b 	call	0x3674	; 0x3674 <processUltrasonicCommand>
         case ERROR_GROUP:
            /*do error things*/
            break;
      }
      //return a dummy success for now
      return 1;
    3a60:	81 e0       	ldi	r24, 0x01	; 1
    3a62:	8d 83       	std	Y+5, r24	; 0x05
    3a64:	01 c0       	rjmp	.+2      	; 0x3a68 <processCommand+0x66>
   } else {
      return 0;
    3a66:	1d 82       	std	Y+5, r1	; 0x05
    3a68:	8d 81       	ldd	r24, Y+5	; 0x05
   }
}
    3a6a:	0f 90       	pop	r0
    3a6c:	0f 90       	pop	r0
    3a6e:	0f 90       	pop	r0
    3a70:	0f 90       	pop	r0
    3a72:	0f 90       	pop	r0
    3a74:	cf 91       	pop	r28
    3a76:	df 91       	pop	r29
    3a78:	08 95       	ret

00003a7a <getBatteryVoltage>:

//battery controller functions

//read battery strength in a char. Might need to be unsigned, specs don't say
//anything regarding that.
char getBatteryVoltage(char *sensorResponse) {
    3a7a:	df 93       	push	r29
    3a7c:	cf 93       	push	r28
    3a7e:	0f 92       	push	r0
    3a80:	0f 92       	push	r0
    3a82:	cd b7       	in	r28, 0x3d	; 61
    3a84:	de b7       	in	r29, 0x3e	; 62
    3a86:	9a 83       	std	Y+2, r25	; 0x02
    3a88:	89 83       	std	Y+1, r24	; 0x01
   //fake battery reading
   *sensorResponse = 0;
    3a8a:	e9 81       	ldd	r30, Y+1	; 0x01
    3a8c:	fa 81       	ldd	r31, Y+2	; 0x02
    3a8e:	10 82       	st	Z, r1
   //return success
   return 1;
    3a90:	81 e0       	ldi	r24, 0x01	; 1
}
    3a92:	0f 90       	pop	r0
    3a94:	0f 90       	pop	r0
    3a96:	cf 91       	pop	r28
    3a98:	df 91       	pop	r29
    3a9a:	08 95       	ret

00003a9c <getSteeringVoltage>:

//gets voltage from steering?
char getSteeringVoltage(char *sensorResponse) {
    3a9c:	df 93       	push	r29
    3a9e:	cf 93       	push	r28
    3aa0:	0f 92       	push	r0
    3aa2:	0f 92       	push	r0
    3aa4:	cd b7       	in	r28, 0x3d	; 61
    3aa6:	de b7       	in	r29, 0x3e	; 62
    3aa8:	9a 83       	std	Y+2, r25	; 0x02
    3aaa:	89 83       	std	Y+1, r24	; 0x01
   //fake steering voltage reading
   *sensorResponse = 0;
    3aac:	e9 81       	ldd	r30, Y+1	; 0x01
    3aae:	fa 81       	ldd	r31, Y+2	; 0x02
    3ab0:	10 82       	st	Z, r1
   //return success
   return 1;
    3ab2:	81 e0       	ldi	r24, 0x01	; 1
}
    3ab4:	0f 90       	pop	r0
    3ab6:	0f 90       	pop	r0
    3ab8:	cf 91       	pop	r28
    3aba:	df 91       	pop	r29
    3abc:	08 95       	ret

00003abe <setBrake>:
//Brake controller functions. THERE IS CURRENTLY NO WAY TO GET THE DESIRED
//BRAKE TARGET IN THE SPECS

//set brake target
char setBrake(char gainTarget) {
    3abe:	df 93       	push	r29
    3ac0:	cf 93       	push	r28
    3ac2:	0f 92       	push	r0
    3ac4:	cd b7       	in	r28, 0x3d	; 61
    3ac6:	de b7       	in	r29, 0x3e	; 62
    3ac8:	89 83       	std	Y+1, r24	; 0x01
   //dummy function, nothing happens
   //return success
   return 1;
    3aca:	81 e0       	ldi	r24, 0x01	; 1
}
    3acc:	0f 90       	pop	r0
    3ace:	cf 91       	pop	r28
    3ad0:	df 91       	pop	r29
    3ad2:	08 95       	ret

00003ad4 <getBrake>:

//get what is assumed to be the current brake value?
char getBrake(char* sensorResponse) {
    3ad4:	df 93       	push	r29
    3ad6:	cf 93       	push	r28
    3ad8:	0f 92       	push	r0
    3ada:	0f 92       	push	r0
    3adc:	cd b7       	in	r28, 0x3d	; 61
    3ade:	de b7       	in	r29, 0x3e	; 62
    3ae0:	9a 83       	std	Y+2, r25	; 0x02
    3ae2:	89 83       	std	Y+1, r24	; 0x01
   //fake brake reading
   *sensorResponse = 0;
    3ae4:	e9 81       	ldd	r30, Y+1	; 0x01
    3ae6:	fa 81       	ldd	r31, Y+2	; 0x02
    3ae8:	10 82       	st	Z, r1
   //return success
   return 1;
    3aea:	81 e0       	ldi	r24, 0x01	; 1
}
    3aec:	0f 90       	pop	r0
    3aee:	0f 90       	pop	r0
    3af0:	cf 91       	pop	r28
    3af2:	df 91       	pop	r29
    3af4:	08 95       	ret

00003af6 <setFNR>:
//FNR controller functions

//set the FNR controller, inputs are either -1, 0, or 1.
char setFNR(char FNR) {
    3af6:	df 93       	push	r29
    3af8:	cf 93       	push	r28
    3afa:	0f 92       	push	r0
    3afc:	cd b7       	in	r28, 0x3d	; 61
    3afe:	de b7       	in	r29, 0x3e	; 62
    3b00:	89 83       	std	Y+1, r24	; 0x01
   //dummy function, nothing happens
   //return success
   return 1;
    3b02:	81 e0       	ldi	r24, 0x01	; 1
}
    3b04:	0f 90       	pop	r0
    3b06:	cf 91       	pop	r28
    3b08:	df 91       	pop	r29
    3b0a:	08 95       	ret

00003b0c <getFNR>:

//get the current FNR state. Function follows same format for consistancy
char getFNR(char *sensorResponse) {
    3b0c:	df 93       	push	r29
    3b0e:	cf 93       	push	r28
    3b10:	0f 92       	push	r0
    3b12:	0f 92       	push	r0
    3b14:	cd b7       	in	r28, 0x3d	; 61
    3b16:	de b7       	in	r29, 0x3e	; 62
    3b18:	9a 83       	std	Y+2, r25	; 0x02
    3b1a:	89 83       	std	Y+1, r24	; 0x01
   //fake reading
   *sensorResponse = 0;
    3b1c:	e9 81       	ldd	r30, Y+1	; 0x01
    3b1e:	fa 81       	ldd	r31, Y+2	; 0x02
    3b20:	10 82       	st	Z, r1
   //return success
   return 1;
    3b22:	81 e0       	ldi	r24, 0x01	; 1
}
    3b24:	0f 90       	pop	r0
    3b26:	0f 90       	pop	r0
    3b28:	cf 91       	pop	r28
    3b2a:	df 91       	pop	r29
    3b2c:	08 95       	ret

00003b2e <setLight>:
//light controller functions

//turn lights on and off
char setLight(char lightTarget) {
    3b2e:	df 93       	push	r29
    3b30:	cf 93       	push	r28
    3b32:	0f 92       	push	r0
    3b34:	cd b7       	in	r28, 0x3d	; 61
    3b36:	de b7       	in	r29, 0x3e	; 62
    3b38:	89 83       	std	Y+1, r24	; 0x01
   //dummy function, nothing happens
   //return success
   return 1;
    3b3a:	81 e0       	ldi	r24, 0x01	; 1
}
    3b3c:	0f 90       	pop	r0
    3b3e:	cf 91       	pop	r28
    3b40:	df 91       	pop	r29
    3b42:	08 95       	ret

00003b44 <setSonarData>:
extern int count;

unsigned char currSonar;
unsigned char lastSonarData = 0;
   
void setSonarData(int i,unsigned char data){
    3b44:	df 93       	push	r29
    3b46:	cf 93       	push	r28
    3b48:	00 d0       	rcall	.+0      	; 0x3b4a <setSonarData+0x6>
    3b4a:	cd b7       	in	r28, 0x3d	; 61
    3b4c:	de b7       	in	r29, 0x3e	; 62
    3b4e:	9a 83       	std	Y+2, r25	; 0x02
    3b50:	89 83       	std	Y+1, r24	; 0x01
    3b52:	6b 83       	std	Y+3, r22	; 0x03
// xSemaphoreTake(sonarDataMutex[i],portMAX_DELAY);
   sonarData[i] = data;
    3b54:	89 81       	ldd	r24, Y+1	; 0x01
    3b56:	9a 81       	ldd	r25, Y+2	; 0x02
    3b58:	fc 01       	movw	r30, r24
    3b5a:	ec 53       	subi	r30, 0x3C	; 60
    3b5c:	f5 4e       	sbci	r31, 0xE5	; 229
    3b5e:	8b 81       	ldd	r24, Y+3	; 0x03
    3b60:	80 83       	st	Z, r24
   //xSemaphoreGive(sonarDataMutex[i]);
}
    3b62:	0f 90       	pop	r0
    3b64:	0f 90       	pop	r0
    3b66:	0f 90       	pop	r0
    3b68:	cf 91       	pop	r28
    3b6a:	df 91       	pop	r29
    3b6c:	08 95       	ret

00003b6e <getSonarData>:

unsigned char getSonarData(int i){
    3b6e:	df 93       	push	r29
    3b70:	cf 93       	push	r28
    3b72:	0f 92       	push	r0
    3b74:	0f 92       	push	r0
    3b76:	cd b7       	in	r28, 0x3d	; 61
    3b78:	de b7       	in	r29, 0x3e	; 62
    3b7a:	9a 83       	std	Y+2, r25	; 0x02
    3b7c:	89 83       	std	Y+1, r24	; 0x01
   //xSemaphoreTake(sonarDataMutex[i],portMAX_DELAY);
   //return sonarData[i];
   return i + 2;
    3b7e:	89 81       	ldd	r24, Y+1	; 0x01
    3b80:	8e 5f       	subi	r24, 0xFE	; 254
   //xSemaphoreGive(sonarDataMutex[i]);
}
    3b82:	0f 90       	pop	r0
    3b84:	0f 90       	pop	r0
    3b86:	cf 91       	pop	r28
    3b88:	df 91       	pop	r29
    3b8a:	08 95       	ret

00003b8c <getTimerCount>:

unsigned char getTimerCount(){
    3b8c:	df 93       	push	r29
    3b8e:	cf 93       	push	r28
    3b90:	cd b7       	in	r28, 0x3d	; 61
    3b92:	de b7       	in	r29, 0x3e	; 62
   return TCNT0;
    3b94:	e6 e4       	ldi	r30, 0x46	; 70
    3b96:	f0 e0       	ldi	r31, 0x00	; 0
    3b98:	80 81       	ld	r24, Z
}
    3b9a:	cf 91       	pop	r28
    3b9c:	df 91       	pop	r29
    3b9e:	08 95       	ret

00003ba0 <__vector_11>:

inline void setTimerCount(unsigned char i){
   TCNT0 = i;
}

ISR(PCINT2_vect) {
    3ba0:	1f 92       	push	r1
    3ba2:	0f 92       	push	r0
    3ba4:	0f b6       	in	r0, 0x3f	; 63
    3ba6:	0f 92       	push	r0
    3ba8:	00 90 5b 00 	lds	r0, 0x005B
    3bac:	0f 92       	push	r0
    3bae:	11 24       	eor	r1, r1
    3bb0:	2f 93       	push	r18
    3bb2:	3f 93       	push	r19
    3bb4:	4f 93       	push	r20
    3bb6:	5f 93       	push	r21
    3bb8:	6f 93       	push	r22
    3bba:	7f 93       	push	r23
    3bbc:	8f 93       	push	r24
    3bbe:	9f 93       	push	r25
    3bc0:	af 93       	push	r26
    3bc2:	bf 93       	push	r27
    3bc4:	ef 93       	push	r30
    3bc6:	ff 93       	push	r31
    3bc8:	df 93       	push	r29
    3bca:	cf 93       	push	r28
    3bcc:	00 d0       	rcall	.+0      	; 0x3bce <__vector_11+0x2e>
    3bce:	cd b7       	in	r28, 0x3d	; 61
    3bd0:	de b7       	in	r29, 0x3e	; 62

   unsigned char beginCount;
   unsigned char currCount;
   char i=0;   
    3bd2:	19 82       	std	Y+1, r1	; 0x01

   if(PINK&(1<<currSonar)){
    3bd4:	e6 e0       	ldi	r30, 0x06	; 6
    3bd6:	f1 e0       	ldi	r31, 0x01	; 1
    3bd8:	80 81       	ld	r24, Z
    3bda:	28 2f       	mov	r18, r24
    3bdc:	30 e0       	ldi	r19, 0x00	; 0
    3bde:	80 91 d8 1a 	lds	r24, 0x1AD8
    3be2:	88 2f       	mov	r24, r24
    3be4:	90 e0       	ldi	r25, 0x00	; 0
    3be6:	a9 01       	movw	r20, r18
    3be8:	02 c0       	rjmp	.+4      	; 0x3bee <__vector_11+0x4e>
    3bea:	55 95       	asr	r21
    3bec:	47 95       	ror	r20
    3bee:	8a 95       	dec	r24
    3bf0:	e2 f7       	brpl	.-8      	; 0x3bea <__vector_11+0x4a>
    3bf2:	ca 01       	movw	r24, r20
    3bf4:	81 70       	andi	r24, 0x01	; 1
    3bf6:	90 70       	andi	r25, 0x00	; 0
    3bf8:	88 23       	and	r24, r24
    3bfa:	41 f0       	breq	.+16     	; 0x3c0c <__vector_11+0x6c>
      //USART_AddToQueue('U');
      beginCount = getTimerCount();
    3bfc:	0e 94 c6 1d 	call	0x3b8c	; 0x3b8c <getTimerCount>
    3c00:	8b 83       	std	Y+3, r24	; 0x03
      PORTE = 0xFF;
    3c02:	ee e2       	ldi	r30, 0x2E	; 46
    3c04:	f0 e0       	ldi	r31, 0x00	; 0
    3c06:	8f ef       	ldi	r24, 0xFF	; 255
    3c08:	80 83       	st	Z, r24
    3c0a:	1a c0       	rjmp	.+52     	; 0x3c40 <__vector_11+0xa0>
   } else {
      //USART_AddToQueue('D');
      currCount = getTimerCount();
    3c0c:	0e 94 c6 1d 	call	0x3b8c	; 0x3b8c <getTimerCount>
    3c10:	8a 83       	std	Y+2, r24	; 0x02
      if(currCount > beginCount){
    3c12:	9a 81       	ldd	r25, Y+2	; 0x02
    3c14:	8b 81       	ldd	r24, Y+3	; 0x03
    3c16:	89 17       	cp	r24, r25
    3c18:	28 f4       	brcc	.+10     	; 0x3c24 <__vector_11+0x84>
         lastSonarData = currCount - beginCount;
    3c1a:	8a 81       	ldd	r24, Y+2	; 0x02
    3c1c:	9b 81       	ldd	r25, Y+3	; 0x03
    3c1e:	89 1b       	sub	r24, r25
    3c20:	80 93 bb 1a 	sts	0x1ABB, r24
      }
      PORTE = 0;
    3c24:	ee e2       	ldi	r30, 0x2E	; 46
    3c26:	f0 e0       	ldi	r31, 0x00	; 0
    3c28:	10 82       	st	Z, r1
      xSemaphoreGiveFromISR(sonarSemaphore,0);
    3c2a:	80 91 ca 1a 	lds	r24, 0x1ACA
    3c2e:	90 91 cb 1a 	lds	r25, 0x1ACB
    3c32:	60 e0       	ldi	r22, 0x00	; 0
    3c34:	70 e0       	ldi	r23, 0x00	; 0
    3c36:	40 e0       	ldi	r20, 0x00	; 0
    3c38:	50 e0       	ldi	r21, 0x00	; 0
    3c3a:	20 e0       	ldi	r18, 0x00	; 0
    3c3c:	0e 94 46 0d 	call	0x1a8c	; 0x1a8c <xQueueGenericSendFromISR>
   }

}
    3c40:	0f 90       	pop	r0
    3c42:	0f 90       	pop	r0
    3c44:	0f 90       	pop	r0
    3c46:	cf 91       	pop	r28
    3c48:	df 91       	pop	r29
    3c4a:	ff 91       	pop	r31
    3c4c:	ef 91       	pop	r30
    3c4e:	bf 91       	pop	r27
    3c50:	af 91       	pop	r26
    3c52:	9f 91       	pop	r25
    3c54:	8f 91       	pop	r24
    3c56:	7f 91       	pop	r23
    3c58:	6f 91       	pop	r22
    3c5a:	5f 91       	pop	r21
    3c5c:	4f 91       	pop	r20
    3c5e:	3f 91       	pop	r19
    3c60:	2f 91       	pop	r18
    3c62:	0f 90       	pop	r0
    3c64:	00 92 5b 00 	sts	0x005B, r0
    3c68:	0f 90       	pop	r0
    3c6a:	0f be       	out	0x3f, r0	; 63
    3c6c:	0f 90       	pop	r0
    3c6e:	1f 90       	pop	r1
    3c70:	18 95       	reti

00003c72 <initializeSonarSensors>:

void initializeSonarSensors(){
    3c72:	df 93       	push	r29
    3c74:	cf 93       	push	r28
    3c76:	cd b7       	in	r28, 0x3d	; 61
    3c78:	de b7       	in	r29, 0x3e	; 62
   //DDRD &= 0xFE;   
   DIDR2 = 0;
    3c7a:	ed e7       	ldi	r30, 0x7D	; 125
    3c7c:	f0 e0       	ldi	r31, 0x00	; 0
    3c7e:	10 82       	st	Z, r1
   DDRK = 0;
    3c80:	e7 e0       	ldi	r30, 0x07	; 7
    3c82:	f1 e0       	ldi	r31, 0x01	; 1
    3c84:	10 82       	st	Z, r1
   DDRC = 0;
    3c86:	e7 e2       	ldi	r30, 0x27	; 39
    3c88:	f0 e0       	ldi	r31, 0x00	; 0
    3c8a:	10 82       	st	Z, r1

   PORTC = 0;
    3c8c:	e8 e2       	ldi	r30, 0x28	; 40
    3c8e:	f0 e0       	ldi	r31, 0x00	; 0
    3c90:	10 82       	st	Z, r1

   //EICRA = 1;
   //EIMSK = 1;

   PCMSK2 = 0xFF;
    3c92:	ed e6       	ldi	r30, 0x6D	; 109
    3c94:	f0 e0       	ldi	r31, 0x00	; 0
    3c96:	8f ef       	ldi	r24, 0xFF	; 255
    3c98:	80 83       	st	Z, r24
   PCICR = 0x7;
    3c9a:	e8 e6       	ldi	r30, 0x68	; 104
    3c9c:	f0 e0       	ldi	r31, 0x00	; 0
    3c9e:	87 e0       	ldi	r24, 0x07	; 7
    3ca0:	80 83       	st	Z, r24

   TCCR0A = 0;
    3ca2:	e4 e4       	ldi	r30, 0x44	; 68
    3ca4:	f0 e0       	ldi	r31, 0x00	; 0
    3ca6:	10 82       	st	Z, r1
   TCCR0B = 5;
    3ca8:	e5 e4       	ldi	r30, 0x45	; 69
    3caa:	f0 e0       	ldi	r31, 0x00	; 0
    3cac:	85 e0       	ldi	r24, 0x05	; 5
    3cae:	80 83       	st	Z, r24

}
    3cb0:	cf 91       	pop	r28
    3cb2:	df 91       	pop	r29
    3cb4:	08 95       	ret

00003cb6 <vTaskSonar>:

void vTaskSonar(void* parameter){
    3cb6:	df 93       	push	r29
    3cb8:	cf 93       	push	r28
    3cba:	00 d0       	rcall	.+0      	; 0x3cbc <vTaskSonar+0x6>
    3cbc:	0f 92       	push	r0
    3cbe:	cd b7       	in	r28, 0x3d	; 61
    3cc0:	de b7       	in	r29, 0x3e	; 62
    3cc2:	9c 83       	std	Y+4, r25	; 0x04
    3cc4:	8b 83       	std	Y+3, r24	; 0x03

   int i;
   initializeSonarSensors();
    3cc6:	0e 94 39 1e 	call	0x3c72	; 0x3c72 <initializeSonarSensors>
   
   vSemaphoreCreateBinary(sonarSemaphore);
    3cca:	81 e0       	ldi	r24, 0x01	; 1
    3ccc:	60 e0       	ldi	r22, 0x00	; 0
    3cce:	43 e0       	ldi	r20, 0x03	; 3
    3cd0:	0e 94 fe 0b 	call	0x17fc	; 0x17fc <xQueueGenericCreate>
    3cd4:	90 93 cb 1a 	sts	0x1ACB, r25
    3cd8:	80 93 ca 1a 	sts	0x1ACA, r24
    3cdc:	80 91 ca 1a 	lds	r24, 0x1ACA
    3ce0:	90 91 cb 1a 	lds	r25, 0x1ACB
    3ce4:	00 97       	sbiw	r24, 0x00	; 0
    3ce6:	59 f0       	breq	.+22     	; 0x3cfe <vTaskSonar+0x48>
    3ce8:	80 91 ca 1a 	lds	r24, 0x1ACA
    3cec:	90 91 cb 1a 	lds	r25, 0x1ACB
    3cf0:	60 e0       	ldi	r22, 0x00	; 0
    3cf2:	70 e0       	ldi	r23, 0x00	; 0
    3cf4:	40 e0       	ldi	r20, 0x00	; 0
    3cf6:	50 e0       	ldi	r21, 0x00	; 0
    3cf8:	20 e0       	ldi	r18, 0x00	; 0
    3cfa:	0e 94 a8 0c 	call	0x1950	; 0x1950 <xQueueGenericSend>
      
   currSonar = 0;
    3cfe:	10 92 d8 1a 	sts	0x1AD8, r1

   while(1){
      for(i=0;i<2;i++){
    3d02:	1a 82       	std	Y+2, r1	; 0x02
    3d04:	19 82       	std	Y+1, r1	; 0x01
    3d06:	25 c0       	rjmp	.+74     	; 0x3d52 <vTaskSonar+0x9c>
         currSonar = i;
    3d08:	89 81       	ldd	r24, Y+1	; 0x01
    3d0a:	80 93 d8 1a 	sts	0x1AD8, r24
         PORTC = (1<<i);
    3d0e:	e8 e2       	ldi	r30, 0x28	; 40
    3d10:	f0 e0       	ldi	r31, 0x00	; 0
    3d12:	81 e0       	ldi	r24, 0x01	; 1
    3d14:	90 e0       	ldi	r25, 0x00	; 0
    3d16:	09 80       	ldd	r0, Y+1	; 0x01
    3d18:	02 c0       	rjmp	.+4      	; 0x3d1e <vTaskSonar+0x68>
    3d1a:	88 0f       	add	r24, r24
    3d1c:	99 1f       	adc	r25, r25
    3d1e:	0a 94       	dec	r0
    3d20:	e2 f7       	brpl	.-8      	; 0x3d1a <vTaskSonar+0x64>
    3d22:	80 83       	st	Z, r24
         xSemaphoreTake(sonarSemaphore,portMAX_DELAY);
    3d24:	80 91 ca 1a 	lds	r24, 0x1ACA
    3d28:	90 91 cb 1a 	lds	r25, 0x1ACB
    3d2c:	60 e0       	ldi	r22, 0x00	; 0
    3d2e:	70 e0       	ldi	r23, 0x00	; 0
    3d30:	4f ef       	ldi	r20, 0xFF	; 255
    3d32:	5f ef       	ldi	r21, 0xFF	; 255
    3d34:	20 e0       	ldi	r18, 0x00	; 0
    3d36:	0e 94 97 0d 	call	0x1b2e	; 0x1b2e <xQueueGenericReceive>
         setSonarData(i,lastSonarData);
    3d3a:	20 91 bb 1a 	lds	r18, 0x1ABB
    3d3e:	89 81       	ldd	r24, Y+1	; 0x01
    3d40:	9a 81       	ldd	r25, Y+2	; 0x02
    3d42:	62 2f       	mov	r22, r18
    3d44:	0e 94 a2 1d 	call	0x3b44	; 0x3b44 <setSonarData>
   vSemaphoreCreateBinary(sonarSemaphore);
      
   currSonar = 0;

   while(1){
      for(i=0;i<2;i++){
    3d48:	89 81       	ldd	r24, Y+1	; 0x01
    3d4a:	9a 81       	ldd	r25, Y+2	; 0x02
    3d4c:	01 96       	adiw	r24, 0x01	; 1
    3d4e:	9a 83       	std	Y+2, r25	; 0x02
    3d50:	89 83       	std	Y+1, r24	; 0x01
    3d52:	89 81       	ldd	r24, Y+1	; 0x01
    3d54:	9a 81       	ldd	r25, Y+2	; 0x02
    3d56:	82 30       	cpi	r24, 0x02	; 2
    3d58:	91 05       	cpc	r25, r1
    3d5a:	b4 f2       	brlt	.-84     	; 0x3d08 <vTaskSonar+0x52>
    3d5c:	d2 cf       	rjmp	.-92     	; 0x3d02 <vTaskSonar+0x4c>

00003d5e <getAllSensors>:
      }
   }
            
} 

char getAllSensors(unsigned short* responseData){
    3d5e:	0f 93       	push	r16
    3d60:	1f 93       	push	r17
    3d62:	df 93       	push	r29
    3d64:	cf 93       	push	r28
    3d66:	00 d0       	rcall	.+0      	; 0x3d68 <getAllSensors+0xa>
    3d68:	0f 92       	push	r0
    3d6a:	0f 92       	push	r0
    3d6c:	cd b7       	in	r28, 0x3d	; 61
    3d6e:	de b7       	in	r29, 0x3e	; 62
    3d70:	9c 83       	std	Y+4, r25	; 0x04
    3d72:	8b 83       	std	Y+3, r24	; 0x03
   unsigned short i;
   for(i=0;i<6;i++){
    3d74:	1a 82       	std	Y+2, r1	; 0x02
    3d76:	19 82       	std	Y+1, r1	; 0x01
    3d78:	18 c0       	rjmp	.+48     	; 0x3daa <getAllSensors+0x4c>
      responseData[i] = getSonarData(i);
    3d7a:	89 81       	ldd	r24, Y+1	; 0x01
    3d7c:	9a 81       	ldd	r25, Y+2	; 0x02
    3d7e:	9c 01       	movw	r18, r24
    3d80:	22 0f       	add	r18, r18
    3d82:	33 1f       	adc	r19, r19
    3d84:	8b 81       	ldd	r24, Y+3	; 0x03
    3d86:	9c 81       	ldd	r25, Y+4	; 0x04
    3d88:	8c 01       	movw	r16, r24
    3d8a:	02 0f       	add	r16, r18
    3d8c:	13 1f       	adc	r17, r19
    3d8e:	89 81       	ldd	r24, Y+1	; 0x01
    3d90:	9a 81       	ldd	r25, Y+2	; 0x02
    3d92:	0e 94 b7 1d 	call	0x3b6e	; 0x3b6e <getSonarData>
    3d96:	88 2f       	mov	r24, r24
    3d98:	90 e0       	ldi	r25, 0x00	; 0
    3d9a:	f8 01       	movw	r30, r16
    3d9c:	91 83       	std	Z+1, r25	; 0x01
    3d9e:	80 83       	st	Z, r24
            
} 

char getAllSensors(unsigned short* responseData){
   unsigned short i;
   for(i=0;i<6;i++){
    3da0:	89 81       	ldd	r24, Y+1	; 0x01
    3da2:	9a 81       	ldd	r25, Y+2	; 0x02
    3da4:	01 96       	adiw	r24, 0x01	; 1
    3da6:	9a 83       	std	Y+2, r25	; 0x02
    3da8:	89 83       	std	Y+1, r24	; 0x01
    3daa:	89 81       	ldd	r24, Y+1	; 0x01
    3dac:	9a 81       	ldd	r25, Y+2	; 0x02
    3dae:	86 30       	cpi	r24, 0x06	; 6
    3db0:	91 05       	cpc	r25, r1
    3db2:	18 f3       	brcs	.-58     	; 0x3d7a <getAllSensors+0x1c>
      responseData[i] = getSonarData(i);
      //responseData[i] = i;
   }
}
    3db4:	0f 90       	pop	r0
    3db6:	0f 90       	pop	r0
    3db8:	0f 90       	pop	r0
    3dba:	0f 90       	pop	r0
    3dbc:	0f 90       	pop	r0
    3dbe:	cf 91       	pop	r28
    3dc0:	df 91       	pop	r29
    3dc2:	1f 91       	pop	r17
    3dc4:	0f 91       	pop	r16
    3dc6:	08 95       	ret

00003dc8 <getCertainSensor>:

char getCertainSensor(char commandData,int* responseData){
    3dc8:	0f 93       	push	r16
    3dca:	1f 93       	push	r17
    3dcc:	df 93       	push	r29
    3dce:	cf 93       	push	r28
    3dd0:	00 d0       	rcall	.+0      	; 0x3dd2 <getCertainSensor+0xa>
    3dd2:	0f 92       	push	r0
    3dd4:	cd b7       	in	r28, 0x3d	; 61
    3dd6:	de b7       	in	r29, 0x3e	; 62
    3dd8:	89 83       	std	Y+1, r24	; 0x01
    3dda:	7b 83       	std	Y+3, r23	; 0x03
    3ddc:	6a 83       	std	Y+2, r22	; 0x02
   if(commandData < 6){
    3dde:	89 81       	ldd	r24, Y+1	; 0x01
    3de0:	86 30       	cpi	r24, 0x06	; 6
    3de2:	bc f4       	brge	.+46     	; 0x3e12 <getCertainSensor+0x4a>
      responseData[commandData] = getSonarData(commandData);
    3de4:	89 81       	ldd	r24, Y+1	; 0x01
    3de6:	99 27       	eor	r25, r25
    3de8:	87 fd       	sbrc	r24, 7
    3dea:	90 95       	com	r25
    3dec:	9c 01       	movw	r18, r24
    3dee:	22 0f       	add	r18, r18
    3df0:	33 1f       	adc	r19, r19
    3df2:	8a 81       	ldd	r24, Y+2	; 0x02
    3df4:	9b 81       	ldd	r25, Y+3	; 0x03
    3df6:	8c 01       	movw	r16, r24
    3df8:	02 0f       	add	r16, r18
    3dfa:	13 1f       	adc	r17, r19
    3dfc:	89 81       	ldd	r24, Y+1	; 0x01
    3dfe:	99 27       	eor	r25, r25
    3e00:	87 fd       	sbrc	r24, 7
    3e02:	90 95       	com	r25
    3e04:	0e 94 b7 1d 	call	0x3b6e	; 0x3b6e <getSonarData>
    3e08:	88 2f       	mov	r24, r24
    3e0a:	90 e0       	ldi	r25, 0x00	; 0
    3e0c:	f8 01       	movw	r30, r16
    3e0e:	91 83       	std	Z+1, r25	; 0x01
    3e10:	80 83       	st	Z, r24
   }
}
    3e12:	0f 90       	pop	r0
    3e14:	0f 90       	pop	r0
    3e16:	0f 90       	pop	r0
    3e18:	0f 90       	pop	r0
    3e1a:	cf 91       	pop	r28
    3e1c:	df 91       	pop	r29
    3e1e:	1f 91       	pop	r17
    3e20:	0f 91       	pop	r16
    3e22:	08 95       	ret

00003e24 <getSensorGroup>:

char getSensorGroup(char commandData,int* responseData){
    3e24:	0f 93       	push	r16
    3e26:	1f 93       	push	r17
    3e28:	df 93       	push	r29
    3e2a:	cf 93       	push	r28
    3e2c:	00 d0       	rcall	.+0      	; 0x3e2e <getSensorGroup+0xa>
    3e2e:	00 d0       	rcall	.+0      	; 0x3e30 <getSensorGroup+0xc>
    3e30:	cd b7       	in	r28, 0x3d	; 61
    3e32:	de b7       	in	r29, 0x3e	; 62
    3e34:	89 83       	std	Y+1, r24	; 0x01
    3e36:	7b 83       	std	Y+3, r23	; 0x03
    3e38:	6a 83       	std	Y+2, r22	; 0x02

   switch(commandData){
    3e3a:	89 81       	ldd	r24, Y+1	; 0x01
    3e3c:	28 2f       	mov	r18, r24
    3e3e:	33 27       	eor	r19, r19
    3e40:	27 fd       	sbrc	r18, 7
    3e42:	30 95       	com	r19
    3e44:	3d 83       	std	Y+5, r19	; 0x05
    3e46:	2c 83       	std	Y+4, r18	; 0x04
    3e48:	8c 81       	ldd	r24, Y+4	; 0x04
    3e4a:	9d 81       	ldd	r25, Y+5	; 0x05
    3e4c:	81 30       	cpi	r24, 0x01	; 1
    3e4e:	91 05       	cpc	r25, r1
    3e50:	21 f1       	breq	.+72     	; 0x3e9a <getSensorGroup+0x76>
    3e52:	ec 81       	ldd	r30, Y+4	; 0x04
    3e54:	fd 81       	ldd	r31, Y+5	; 0x05
    3e56:	e2 30       	cpi	r30, 0x02	; 2
    3e58:	f1 05       	cpc	r31, r1
    3e5a:	c1 f1       	breq	.+112    	; 0x3ecc <getSensorGroup+0xa8>
    3e5c:	2c 81       	ldd	r18, Y+4	; 0x04
    3e5e:	3d 81       	ldd	r19, Y+5	; 0x05
    3e60:	21 15       	cp	r18, r1
    3e62:	31 05       	cpc	r19, r1
    3e64:	09 f0       	breq	.+2      	; 0x3e68 <getSensorGroup+0x44>
    3e66:	4a c0       	rjmp	.+148    	; 0x3efc <getSensorGroup+0xd8>
      case SONAR_GROUP_LEFT:
         responseData[0] = getSonarData(0);
    3e68:	80 e0       	ldi	r24, 0x00	; 0
    3e6a:	90 e0       	ldi	r25, 0x00	; 0
    3e6c:	0e 94 b7 1d 	call	0x3b6e	; 0x3b6e <getSonarData>
    3e70:	88 2f       	mov	r24, r24
    3e72:	90 e0       	ldi	r25, 0x00	; 0
    3e74:	ea 81       	ldd	r30, Y+2	; 0x02
    3e76:	fb 81       	ldd	r31, Y+3	; 0x03
    3e78:	91 83       	std	Z+1, r25	; 0x01
    3e7a:	80 83       	st	Z, r24
         responseData[1] = getSonarData(1);
    3e7c:	8a 81       	ldd	r24, Y+2	; 0x02
    3e7e:	9b 81       	ldd	r25, Y+3	; 0x03
    3e80:	8c 01       	movw	r16, r24
    3e82:	0e 5f       	subi	r16, 0xFE	; 254
    3e84:	1f 4f       	sbci	r17, 0xFF	; 255
    3e86:	81 e0       	ldi	r24, 0x01	; 1
    3e88:	90 e0       	ldi	r25, 0x00	; 0
    3e8a:	0e 94 b7 1d 	call	0x3b6e	; 0x3b6e <getSonarData>
    3e8e:	88 2f       	mov	r24, r24
    3e90:	90 e0       	ldi	r25, 0x00	; 0
    3e92:	f8 01       	movw	r30, r16
    3e94:	91 83       	std	Z+1, r25	; 0x01
    3e96:	80 83       	st	Z, r24
    3e98:	31 c0       	rjmp	.+98     	; 0x3efc <getSensorGroup+0xd8>
         break;
      case SONAR_GROUP_FRONT:
         responseData[0] = getSonarData(2);
    3e9a:	82 e0       	ldi	r24, 0x02	; 2
    3e9c:	90 e0       	ldi	r25, 0x00	; 0
    3e9e:	0e 94 b7 1d 	call	0x3b6e	; 0x3b6e <getSonarData>
    3ea2:	88 2f       	mov	r24, r24
    3ea4:	90 e0       	ldi	r25, 0x00	; 0
    3ea6:	ea 81       	ldd	r30, Y+2	; 0x02
    3ea8:	fb 81       	ldd	r31, Y+3	; 0x03
    3eaa:	91 83       	std	Z+1, r25	; 0x01
    3eac:	80 83       	st	Z, r24
         responseData[1] = getSonarData(3);
    3eae:	8a 81       	ldd	r24, Y+2	; 0x02
    3eb0:	9b 81       	ldd	r25, Y+3	; 0x03
    3eb2:	8c 01       	movw	r16, r24
    3eb4:	0e 5f       	subi	r16, 0xFE	; 254
    3eb6:	1f 4f       	sbci	r17, 0xFF	; 255
    3eb8:	83 e0       	ldi	r24, 0x03	; 3
    3eba:	90 e0       	ldi	r25, 0x00	; 0
    3ebc:	0e 94 b7 1d 	call	0x3b6e	; 0x3b6e <getSonarData>
    3ec0:	88 2f       	mov	r24, r24
    3ec2:	90 e0       	ldi	r25, 0x00	; 0
    3ec4:	f8 01       	movw	r30, r16
    3ec6:	91 83       	std	Z+1, r25	; 0x01
    3ec8:	80 83       	st	Z, r24
    3eca:	18 c0       	rjmp	.+48     	; 0x3efc <getSensorGroup+0xd8>
         break;
      case SONAR_GROUP_RIGHT:
         responseData[0] = getSonarData(4);
    3ecc:	84 e0       	ldi	r24, 0x04	; 4
    3ece:	90 e0       	ldi	r25, 0x00	; 0
    3ed0:	0e 94 b7 1d 	call	0x3b6e	; 0x3b6e <getSonarData>
    3ed4:	88 2f       	mov	r24, r24
    3ed6:	90 e0       	ldi	r25, 0x00	; 0
    3ed8:	ea 81       	ldd	r30, Y+2	; 0x02
    3eda:	fb 81       	ldd	r31, Y+3	; 0x03
    3edc:	91 83       	std	Z+1, r25	; 0x01
    3ede:	80 83       	st	Z, r24
         responseData[1] = getSonarData(5);
    3ee0:	8a 81       	ldd	r24, Y+2	; 0x02
    3ee2:	9b 81       	ldd	r25, Y+3	; 0x03
    3ee4:	8c 01       	movw	r16, r24
    3ee6:	0e 5f       	subi	r16, 0xFE	; 254
    3ee8:	1f 4f       	sbci	r17, 0xFF	; 255
    3eea:	85 e0       	ldi	r24, 0x05	; 5
    3eec:	90 e0       	ldi	r25, 0x00	; 0
    3eee:	0e 94 b7 1d 	call	0x3b6e	; 0x3b6e <getSonarData>
    3ef2:	88 2f       	mov	r24, r24
    3ef4:	90 e0       	ldi	r25, 0x00	; 0
    3ef6:	f8 01       	movw	r30, r16
    3ef8:	91 83       	std	Z+1, r25	; 0x01
    3efa:	80 83       	st	Z, r24
         break;
   }

    3efc:	26 96       	adiw	r28, 0x06	; 6
    3efe:	0f b6       	in	r0, 0x3f	; 63
    3f00:	f8 94       	cli
    3f02:	de bf       	out	0x3e, r29	; 62
    3f04:	0f be       	out	0x3f, r0	; 63
    3f06:	cd bf       	out	0x3d, r28	; 61
    3f08:	cf 91       	pop	r28
    3f0a:	df 91       	pop	r29
    3f0c:	1f 91       	pop	r17
    3f0e:	0f 91       	pop	r16
    3f10:	08 95       	ret

00003f12 <getSpeed>:
//Speed Sensor group

//get the speed of the vehicle
char getSpeed(char* sensorResponse) {
    3f12:	df 93       	push	r29
    3f14:	cf 93       	push	r28
    3f16:	0f 92       	push	r0
    3f18:	0f 92       	push	r0
    3f1a:	cd b7       	in	r28, 0x3d	; 61
    3f1c:	de b7       	in	r29, 0x3e	; 62
    3f1e:	9a 83       	std	Y+2, r25	; 0x02
    3f20:	89 83       	std	Y+1, r24	; 0x01
   //store dummy speed value
   *sensorResponse = 0;
    3f22:	e9 81       	ldd	r30, Y+1	; 0x01
    3f24:	fa 81       	ldd	r31, Y+2	; 0x02
    3f26:	10 82       	st	Z, r1
   //return success
   return 1;
    3f28:	81 e0       	ldi	r24, 0x01	; 1
}
    3f2a:	0f 90       	pop	r0
    3f2c:	0f 90       	pop	r0
    3f2e:	cf 91       	pop	r28
    3f30:	df 91       	pop	r29
    3f32:	08 95       	ret

00003f34 <setSpeed>:

//will set just the speed of the wheels of the car
char setSpeed(char speedTarget) {
    3f34:	df 93       	push	r29
    3f36:	cf 93       	push	r28
    3f38:	0f 92       	push	r0
    3f3a:	cd b7       	in	r28, 0x3d	; 61
    3f3c:	de b7       	in	r29, 0x3e	; 62
    3f3e:	89 83       	std	Y+1, r24	; 0x01
   //nothing done down here
   //return success
   return 1;
    3f40:	81 e0       	ldi	r24, 0x01	; 1
}
    3f42:	0f 90       	pop	r0
    3f44:	cf 91       	pop	r28
    3f46:	df 91       	pop	r29
    3f48:	08 95       	ret

00003f4a <setAngle>:

//Steering group

//JUST SETS ANGLE TARGET. Actual angle changing is lower level
char setAngle(char angleTarget) {
    3f4a:	df 93       	push	r29
    3f4c:	cf 93       	push	r28
    3f4e:	0f 92       	push	r0
    3f50:	cd b7       	in	r28, 0x3d	; 61
    3f52:	de b7       	in	r29, 0x3e	; 62
    3f54:	89 83       	std	Y+1, r24	; 0x01
   //dummy function, nothing will happen for now...
   //return success
   return 1;
    3f56:	81 e0       	ldi	r24, 0x01	; 1
}
    3f58:	0f 90       	pop	r0
    3f5a:	cf 91       	pop	r28
    3f5c:	df 91       	pop	r29
    3f5e:	08 95       	ret

00003f60 <getAngle>:

//get the current angle of the steering system
char getAngle(char* sensorResponse) {
    3f60:	df 93       	push	r29
    3f62:	cf 93       	push	r28
    3f64:	0f 92       	push	r0
    3f66:	0f 92       	push	r0
    3f68:	cd b7       	in	r28, 0x3d	; 61
    3f6a:	de b7       	in	r29, 0x3e	; 62
    3f6c:	9a 83       	std	Y+2, r25	; 0x02
    3f6e:	89 83       	std	Y+1, r24	; 0x01
   //store fake angle reading
   *sensorResponse = 0;
    3f70:	e9 81       	ldd	r30, Y+1	; 0x01
    3f72:	fa 81       	ldd	r31, Y+2	; 0x02
    3f74:	10 82       	st	Z, r1
   //return success
   return 1;
    3f76:	81 e0       	ldi	r24, 0x01	; 1
}
    3f78:	0f 90       	pop	r0
    3f7a:	0f 90       	pop	r0
    3f7c:	cf 91       	pop	r28
    3f7e:	df 91       	pop	r29
    3f80:	08 95       	ret

00003f82 <getDesiredAngle>:

//get the angle target. argument name is sensorResponse for the sake of consistancy
char getDesiredAngle(char* sensorResponse) {
    3f82:	df 93       	push	r29
    3f84:	cf 93       	push	r28
    3f86:	0f 92       	push	r0
    3f88:	0f 92       	push	r0
    3f8a:	cd b7       	in	r28, 0x3d	; 61
    3f8c:	de b7       	in	r29, 0x3e	; 62
    3f8e:	9a 83       	std	Y+2, r25	; 0x02
    3f90:	89 83       	std	Y+1, r24	; 0x01
   //fake response
   *sensorResponse = 0;
    3f92:	e9 81       	ldd	r30, Y+1	; 0x01
    3f94:	fa 81       	ldd	r31, Y+2	; 0x02
    3f96:	10 82       	st	Z, r1
   //return success
   return 1;
    3f98:	81 e0       	ldi	r24, 0x01	; 1
}
    3f9a:	0f 90       	pop	r0
    3f9c:	0f 90       	pop	r0
    3f9e:	cf 91       	pop	r28
    3fa0:	df 91       	pop	r29
    3fa2:	08 95       	ret

00003fa4 <changePID>:

//change the PID controller
char changePID(char P, char I, char D) {
    3fa4:	df 93       	push	r29
    3fa6:	cf 93       	push	r28
    3fa8:	00 d0       	rcall	.+0      	; 0x3faa <changePID+0x6>
    3faa:	cd b7       	in	r28, 0x3d	; 61
    3fac:	de b7       	in	r29, 0x3e	; 62
    3fae:	89 83       	std	Y+1, r24	; 0x01
    3fb0:	6a 83       	std	Y+2, r22	; 0x02
    3fb2:	4b 83       	std	Y+3, r20	; 0x03
   //dummy function, nothing happens
   //return success
   return 1;
    3fb4:	81 e0       	ldi	r24, 0x01	; 1
}
    3fb6:	0f 90       	pop	r0
    3fb8:	0f 90       	pop	r0
    3fba:	0f 90       	pop	r0
    3fbc:	cf 91       	pop	r28
    3fbe:	df 91       	pop	r29
    3fc0:	08 95       	ret

00003fc2 <setLimits>:

//not sure what this does. Also not sure why upper and lower are separated
//but its in the specs so...
char setLimits(char upper, char lower) {
    3fc2:	df 93       	push	r29
    3fc4:	cf 93       	push	r28
    3fc6:	0f 92       	push	r0
    3fc8:	0f 92       	push	r0
    3fca:	cd b7       	in	r28, 0x3d	; 61
    3fcc:	de b7       	in	r29, 0x3e	; 62
    3fce:	89 83       	std	Y+1, r24	; 0x01
    3fd0:	6a 83       	std	Y+2, r22	; 0x02
   //dummy function, nothing happens
   //return success
   return 1;
    3fd2:	81 e0       	ldi	r24, 0x01	; 1
}
    3fd4:	0f 90       	pop	r0
    3fd6:	0f 90       	pop	r0
    3fd8:	cf 91       	pop	r28
    3fda:	df 91       	pop	r29
    3fdc:	08 95       	ret

00003fde <__udivmodsi4>:
    3fde:	a1 e2       	ldi	r26, 0x21	; 33
    3fe0:	1a 2e       	mov	r1, r26
    3fe2:	aa 1b       	sub	r26, r26
    3fe4:	bb 1b       	sub	r27, r27
    3fe6:	fd 01       	movw	r30, r26
    3fe8:	0d c0       	rjmp	.+26     	; 0x4004 <__udivmodsi4_ep>

00003fea <__udivmodsi4_loop>:
    3fea:	aa 1f       	adc	r26, r26
    3fec:	bb 1f       	adc	r27, r27
    3fee:	ee 1f       	adc	r30, r30
    3ff0:	ff 1f       	adc	r31, r31
    3ff2:	a2 17       	cp	r26, r18
    3ff4:	b3 07       	cpc	r27, r19
    3ff6:	e4 07       	cpc	r30, r20
    3ff8:	f5 07       	cpc	r31, r21
    3ffa:	20 f0       	brcs	.+8      	; 0x4004 <__udivmodsi4_ep>
    3ffc:	a2 1b       	sub	r26, r18
    3ffe:	b3 0b       	sbc	r27, r19
    4000:	e4 0b       	sbc	r30, r20
    4002:	f5 0b       	sbc	r31, r21

00004004 <__udivmodsi4_ep>:
    4004:	66 1f       	adc	r22, r22
    4006:	77 1f       	adc	r23, r23
    4008:	88 1f       	adc	r24, r24
    400a:	99 1f       	adc	r25, r25
    400c:	1a 94       	dec	r1
    400e:	69 f7       	brne	.-38     	; 0x3fea <__udivmodsi4_loop>
    4010:	60 95       	com	r22
    4012:	70 95       	com	r23
    4014:	80 95       	com	r24
    4016:	90 95       	com	r25
    4018:	9b 01       	movw	r18, r22
    401a:	ac 01       	movw	r20, r24
    401c:	bd 01       	movw	r22, r26
    401e:	cf 01       	movw	r24, r30
    4020:	08 95       	ret

00004022 <memcpy>:
    4022:	fb 01       	movw	r30, r22
    4024:	dc 01       	movw	r26, r24
    4026:	02 c0       	rjmp	.+4      	; 0x402c <memcpy+0xa>
    4028:	01 90       	ld	r0, Z+
    402a:	0d 92       	st	X+, r0
    402c:	41 50       	subi	r20, 0x01	; 1
    402e:	50 40       	sbci	r21, 0x00	; 0
    4030:	d8 f7       	brcc	.-10     	; 0x4028 <memcpy+0x6>
    4032:	08 95       	ret

00004034 <memset>:
    4034:	dc 01       	movw	r26, r24
    4036:	01 c0       	rjmp	.+2      	; 0x403a <memset+0x6>
    4038:	6d 93       	st	X+, r22
    403a:	41 50       	subi	r20, 0x01	; 1
    403c:	50 40       	sbci	r21, 0x00	; 0
    403e:	e0 f7       	brcc	.-8      	; 0x4038 <memset+0x4>
    4040:	08 95       	ret

00004042 <strncpy>:
    4042:	fb 01       	movw	r30, r22
    4044:	dc 01       	movw	r26, r24
    4046:	41 50       	subi	r20, 0x01	; 1
    4048:	50 40       	sbci	r21, 0x00	; 0
    404a:	48 f0       	brcs	.+18     	; 0x405e <strncpy+0x1c>
    404c:	01 90       	ld	r0, Z+
    404e:	0d 92       	st	X+, r0
    4050:	00 20       	and	r0, r0
    4052:	c9 f7       	brne	.-14     	; 0x4046 <strncpy+0x4>
    4054:	01 c0       	rjmp	.+2      	; 0x4058 <strncpy+0x16>
    4056:	1d 92       	st	X+, r1
    4058:	41 50       	subi	r20, 0x01	; 1
    405a:	50 40       	sbci	r21, 0x00	; 0
    405c:	e0 f7       	brcc	.-8      	; 0x4056 <strncpy+0x14>
    405e:	08 95       	ret

00004060 <itoa>:
    4060:	fb 01       	movw	r30, r22
    4062:	9f 01       	movw	r18, r30
    4064:	e8 94       	clt
    4066:	42 30       	cpi	r20, 0x02	; 2
    4068:	c4 f0       	brlt	.+48     	; 0x409a <itoa+0x3a>
    406a:	45 32       	cpi	r20, 0x25	; 37
    406c:	b4 f4       	brge	.+44     	; 0x409a <itoa+0x3a>
    406e:	4a 30       	cpi	r20, 0x0A	; 10
    4070:	29 f4       	brne	.+10     	; 0x407c <itoa+0x1c>
    4072:	97 fb       	bst	r25, 7
    4074:	1e f4       	brtc	.+6      	; 0x407c <itoa+0x1c>
    4076:	90 95       	com	r25
    4078:	81 95       	neg	r24
    407a:	9f 4f       	sbci	r25, 0xFF	; 255
    407c:	64 2f       	mov	r22, r20
    407e:	77 27       	eor	r23, r23
    4080:	0e 94 61 20 	call	0x40c2	; 0x40c2 <__udivmodhi4>
    4084:	80 5d       	subi	r24, 0xD0	; 208
    4086:	8a 33       	cpi	r24, 0x3A	; 58
    4088:	0c f0       	brlt	.+2      	; 0x408c <itoa+0x2c>
    408a:	89 5d       	subi	r24, 0xD9	; 217
    408c:	81 93       	st	Z+, r24
    408e:	cb 01       	movw	r24, r22
    4090:	00 97       	sbiw	r24, 0x00	; 0
    4092:	a1 f7       	brne	.-24     	; 0x407c <itoa+0x1c>
    4094:	16 f4       	brtc	.+4      	; 0x409a <itoa+0x3a>
    4096:	5d e2       	ldi	r21, 0x2D	; 45
    4098:	51 93       	st	Z+, r21
    409a:	10 82       	st	Z, r1
    409c:	c9 01       	movw	r24, r18
    409e:	0c 94 51 20 	jmp	0x40a2	; 0x40a2 <strrev>

000040a2 <strrev>:
    40a2:	dc 01       	movw	r26, r24
    40a4:	fc 01       	movw	r30, r24
    40a6:	67 2f       	mov	r22, r23
    40a8:	71 91       	ld	r23, Z+
    40aa:	77 23       	and	r23, r23
    40ac:	e1 f7       	brne	.-8      	; 0x40a6 <strrev+0x4>
    40ae:	32 97       	sbiw	r30, 0x02	; 2
    40b0:	04 c0       	rjmp	.+8      	; 0x40ba <strrev+0x18>
    40b2:	7c 91       	ld	r23, X
    40b4:	6d 93       	st	X+, r22
    40b6:	70 83       	st	Z, r23
    40b8:	62 91       	ld	r22, -Z
    40ba:	ae 17       	cp	r26, r30
    40bc:	bf 07       	cpc	r27, r31
    40be:	c8 f3       	brcs	.-14     	; 0x40b2 <strrev+0x10>
    40c0:	08 95       	ret

000040c2 <__udivmodhi4>:
    40c2:	aa 1b       	sub	r26, r26
    40c4:	bb 1b       	sub	r27, r27
    40c6:	51 e1       	ldi	r21, 0x11	; 17
    40c8:	07 c0       	rjmp	.+14     	; 0x40d8 <__udivmodhi4_ep>

000040ca <__udivmodhi4_loop>:
    40ca:	aa 1f       	adc	r26, r26
    40cc:	bb 1f       	adc	r27, r27
    40ce:	a6 17       	cp	r26, r22
    40d0:	b7 07       	cpc	r27, r23
    40d2:	10 f0       	brcs	.+4      	; 0x40d8 <__udivmodhi4_ep>
    40d4:	a6 1b       	sub	r26, r22
    40d6:	b7 0b       	sbc	r27, r23

000040d8 <__udivmodhi4_ep>:
    40d8:	88 1f       	adc	r24, r24
    40da:	99 1f       	adc	r25, r25
    40dc:	5a 95       	dec	r21
    40de:	a9 f7       	brne	.-22     	; 0x40ca <__udivmodhi4_loop>
    40e0:	80 95       	com	r24
    40e2:	90 95       	com	r25
    40e4:	bc 01       	movw	r22, r24
    40e6:	cd 01       	movw	r24, r26
    40e8:	08 95       	ret

000040ea <_exit>:
    40ea:	f8 94       	cli

000040ec <__stop_program>:
    40ec:	ff cf       	rjmp	.-2      	; 0x40ec <__stop_program>
