
rtosdemo.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000002c  00800200  00004870  00004904  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00004870  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000018b5  0080022c  0080022c  00004930  2**0
                  ALLOC
  3 .stab         0000b6d0  00000000  00000000  00004930  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000437e  00000000  00000000  00010000  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  0001437e  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 8a 00 	jmp	0x114	; 0x114 <__ctors_end>
       4:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
       8:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
       c:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      10:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      14:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      18:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      1c:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      20:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      24:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      28:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      2c:	0c 94 69 20 	jmp	0x40d2	; 0x40d2 <__vector_11>
      30:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      34:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      38:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      3c:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      40:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      44:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      48:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      4c:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      50:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      54:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      58:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      5c:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      60:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      64:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      68:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      6c:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      70:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      74:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      78:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      7c:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      80:	0c 94 08 1a 	jmp	0x3410	; 0x3410 <__vector_32>
      84:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      88:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      8c:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      90:	0c 94 94 1a 	jmp	0x3528	; 0x3528 <__vector_36>
      94:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      98:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      9c:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      a0:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      a4:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      a8:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      ac:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      b0:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      b4:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      b8:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      bc:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      c0:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      c4:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      c8:	0c 94 fa 01 	jmp	0x3f4	; 0x3f4 <__vector_50>
      cc:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      d0:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      d4:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      d8:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      dc:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      e0:	0c 94 ab 00 	jmp	0x156	; 0x156 <__bad_interrupt>
      e4:	8b 1f       	adc	r24, r27
      e6:	b2 1f       	adc	r27, r18
      e8:	b2 1f       	adc	r27, r18
      ea:	b2 1f       	adc	r27, r18
      ec:	b2 1f       	adc	r27, r18
      ee:	b2 1f       	adc	r27, r18
      f0:	a2 1f       	adc	r26, r18
      f2:	b2 1f       	adc	r27, r18

000000f4 <__trampolines_start>:
      f4:	0c 94 02 21 	jmp	0x4204	; 0x4204 <vTaskSonar>
      f8:	0c 94 3c 02 	jmp	0x478	; 0x478 <vTaskFunction_1>
      fc:	0c 94 b6 09 	jmp	0x136c	; 0x136c <prvIdleTask>
     100:	0c 94 f0 1a 	jmp	0x35e0	; 0x35e0 <vTaskUSARTWrite>
     104:	0c 94 a2 1f 	jmp	0x3f44	; 0x3f44 <processCommand+0x86>
     108:	0c 94 8b 1f 	jmp	0x3f16	; 0x3f16 <processCommand+0x58>
     10c:	0c 94 50 1c 	jmp	0x38a0	; 0x38a0 <vTaskUSARTRead>
     110:	0c 94 b2 1f 	jmp	0x3f64	; 0x3f64 <processCommand+0xa6>

00000114 <__ctors_end>:
     114:	11 24       	eor	r1, r1
     116:	1f be       	out	0x3f, r1	; 63
     118:	cf ef       	ldi	r28, 0xFF	; 255
     11a:	d1 e2       	ldi	r29, 0x21	; 33
     11c:	de bf       	out	0x3e, r29	; 62
     11e:	cd bf       	out	0x3d, r28	; 61
     120:	00 e0       	ldi	r16, 0x00	; 0
     122:	0c bf       	out	0x3c, r16	; 60

00000124 <__do_copy_data>:
     124:	12 e0       	ldi	r17, 0x02	; 2
     126:	a0 e0       	ldi	r26, 0x00	; 0
     128:	b2 e0       	ldi	r27, 0x02	; 2
     12a:	e0 e7       	ldi	r30, 0x70	; 112
     12c:	f8 e4       	ldi	r31, 0x48	; 72
     12e:	00 e0       	ldi	r16, 0x00	; 0
     130:	0b bf       	out	0x3b, r16	; 59
     132:	02 c0       	rjmp	.+4      	; 0x138 <__do_copy_data+0x14>
     134:	07 90       	elpm	r0, Z+
     136:	0d 92       	st	X+, r0
     138:	ac 32       	cpi	r26, 0x2C	; 44
     13a:	b1 07       	cpc	r27, r17
     13c:	d9 f7       	brne	.-10     	; 0x134 <__do_copy_data+0x10>

0000013e <__do_clear_bss>:
     13e:	1a e1       	ldi	r17, 0x1A	; 26
     140:	ac e2       	ldi	r26, 0x2C	; 44
     142:	b2 e0       	ldi	r27, 0x02	; 2
     144:	01 c0       	rjmp	.+2      	; 0x148 <.do_clear_bss_start>

00000146 <.do_clear_bss_loop>:
     146:	1d 92       	st	X+, r1

00000148 <.do_clear_bss_start>:
     148:	a1 3e       	cpi	r26, 0xE1	; 225
     14a:	b1 07       	cpc	r27, r17
     14c:	e1 f7       	brne	.-8      	; 0x146 <.do_clear_bss_loop>
     14e:	0e 94 c5 00 	call	0x18a	; 0x18a <main>
     152:	0c 94 36 24 	jmp	0x486c	; 0x486c <_exit>

00000156 <__bad_interrupt>:
     156:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000015a <vApplicationTickHook>:
int count = 0;

int sonarTime;

void vApplicationTickHook()
{
     15a:	cf 93       	push	r28
     15c:	df 93       	push	r29
     15e:	cd b7       	in	r28, 0x3d	; 61
     160:	de b7       	in	r29, 0x3e	; 62
    count++;
     162:	80 91 2c 02 	lds	r24, 0x022C
     166:	90 91 2d 02 	lds	r25, 0x022D
     16a:	01 96       	adiw	r24, 0x01	; 1
     16c:	90 93 2d 02 	sts	0x022D, r25
     170:	80 93 2c 02 	sts	0x022C, r24
}
     174:	df 91       	pop	r29
     176:	cf 91       	pop	r28
     178:	08 95       	ret

0000017a <vApplicationStackOverflowHook>:

void vApplicationStackOverflowHook(){
     17a:	cf 93       	push	r28
     17c:	df 93       	push	r29
     17e:	cd b7       	in	r28, 0x3d	; 61
     180:	de b7       	in	r29, 0x3e	; 62
	return;
     182:	00 00       	nop
}
     184:	df 91       	pop	r29
     186:	cf 91       	pop	r28
     188:	08 95       	ret

0000018a <main>:
/*-----------------------------------------------------------*/

int main( void )
{
     18a:	af 92       	push	r10
     18c:	bf 92       	push	r11
     18e:	cf 92       	push	r12
     190:	df 92       	push	r13
     192:	ef 92       	push	r14
     194:	ff 92       	push	r15
     196:	0f 93       	push	r16
     198:	cf 93       	push	r28
     19a:	df 93       	push	r29
     19c:	00 d0       	rcall	.+0      	; 0x19e <main+0x14>
     19e:	00 d0       	rcall	.+0      	; 0x1a0 <main+0x16>
     1a0:	cd b7       	in	r28, 0x3d	; 61
     1a2:	de b7       	in	r29, 0x3e	; 62
    
    //- wimpy variable defs
	uint8_t val[2] = {0x3F, 0xFE};
     1a4:	8f e3       	ldi	r24, 0x3F	; 63
     1a6:	8d 83       	std	Y+5, r24	; 0x05
     1a8:	8e ef       	ldi	r24, 0xFE	; 254
     1aa:	8e 83       	std	Y+6, r24	; 0x06
    uint8_t *val0, *val1;
    
	//- avoid pesky warnings...
	val0 = val + 0;
     1ac:	ce 01       	movw	r24, r28
     1ae:	05 96       	adiw	r24, 0x05	; 5
     1b0:	9a 83       	std	Y+2, r25	; 0x02
     1b2:	89 83       	std	Y+1, r24	; 0x01
	val1 = val + 1;
     1b4:	ce 01       	movw	r24, r28
     1b6:	05 96       	adiw	r24, 0x05	; 5
     1b8:	01 96       	adiw	r24, 0x01	; 1
     1ba:	9c 83       	std	Y+4, r25	; 0x04
     1bc:	8b 83       	std	Y+3, r24	; 0x03
    
	DDRD = 0xFF;
     1be:	8a e2       	ldi	r24, 0x2A	; 42
     1c0:	90 e0       	ldi	r25, 0x00	; 0
     1c2:	2f ef       	ldi	r18, 0xFF	; 255
     1c4:	fc 01       	movw	r30, r24
     1c6:	20 83       	st	Z, r18
	DDRE = 0xFF;
     1c8:	8d e2       	ldi	r24, 0x2D	; 45
     1ca:	90 e0       	ldi	r25, 0x00	; 0
     1cc:	2f ef       	ldi	r18, 0xFF	; 255
     1ce:	fc 01       	movw	r30, r24
     1d0:	20 83       	st	Z, r18
	DDRB = 0xFF; 
     1d2:	84 e2       	ldi	r24, 0x24	; 36
     1d4:	90 e0       	ldi	r25, 0x00	; 0
     1d6:	2f ef       	ldi	r18, 0xFF	; 255
     1d8:	fc 01       	movw	r30, r24
     1da:	20 83       	st	Z, r18
	DDRK = 0;
     1dc:	87 e0       	ldi	r24, 0x07	; 7
     1de:	91 e0       	ldi	r25, 0x01	; 1
     1e0:	fc 01       	movw	r30, r24
     1e2:	10 82       	st	Z, r1

	PORTD = 0;
     1e4:	8b e2       	ldi	r24, 0x2B	; 43
     1e6:	90 e0       	ldi	r25, 0x00	; 0
     1e8:	fc 01       	movw	r30, r24
     1ea:	10 82       	st	Z, r1
	PORTE = 0;
     1ec:	8e e2       	ldi	r24, 0x2E	; 46
     1ee:	90 e0       	ldi	r25, 0x00	; 0
     1f0:	fc 01       	movw	r30, r24
     1f2:	10 82       	st	Z, r1
	PORTK = 2;
     1f4:	88 e0       	ldi	r24, 0x08	; 8
     1f6:	91 e0       	ldi	r25, 0x01	; 1
     1f8:	22 e0       	ldi	r18, 0x02	; 2
     1fa:	fc 01       	movw	r30, r24
     1fc:	20 83       	st	Z, r18

    //- init IO with goodness
	vIO_init();
     1fe:	0e 94 f2 02 	call	0x5e4	; 0x5e4 <vIO_init>

	//- Create a 
	xTaskCreate( (pdTASK_CODE) vTaskFunction_1, (signed char *) "T0", configMINIMAL_STACK_SIZE+1000,
     202:	8b 81       	ldd	r24, Y+3	; 0x03
     204:	9c 81       	ldd	r25, Y+4	; 0x04
     206:	a1 2c       	mov	r10, r1
     208:	b1 2c       	mov	r11, r1
     20a:	c1 2c       	mov	r12, r1
     20c:	d1 2c       	mov	r13, r1
     20e:	e1 2c       	mov	r14, r1
     210:	f1 2c       	mov	r15, r1
     212:	01 e0       	ldi	r16, 0x01	; 1
     214:	9c 01       	movw	r18, r24
     216:	4d e3       	ldi	r20, 0x3D	; 61
     218:	54 e0       	ldi	r21, 0x04	; 4
     21a:	62 e0       	ldi	r22, 0x02	; 2
     21c:	72 e0       	ldi	r23, 0x02	; 2
     21e:	8c e3       	ldi	r24, 0x3C	; 60
     220:	92 e0       	ldi	r25, 0x02	; 2
     222:	0e 94 02 03 	call	0x604	; 0x604 <xTaskGenericCreate>
                (void *) val1, 1, NULL );
	xTaskCreate( (pdTASK_CODE) vTaskPot, (signed char *) "T0", configMINIMAL_STACK_SIZE+1000,
                (void *) val1, 1, NULL );*/

 
   xTaskCreate( (pdTASK_CODE) vTaskSonar, (signed char *) "T1", configMINIMAL_STACK_SIZE+1000,
     226:	8b 81       	ldd	r24, Y+3	; 0x03
     228:	9c 81       	ldd	r25, Y+4	; 0x04
     22a:	a1 2c       	mov	r10, r1
     22c:	b1 2c       	mov	r11, r1
     22e:	c1 2c       	mov	r12, r1
     230:	d1 2c       	mov	r13, r1
     232:	e1 2c       	mov	r14, r1
     234:	f1 2c       	mov	r15, r1
     236:	01 e0       	ldi	r16, 0x01	; 1
     238:	9c 01       	movw	r18, r24
     23a:	4d e3       	ldi	r20, 0x3D	; 61
     23c:	54 e0       	ldi	r21, 0x04	; 4
     23e:	65 e0       	ldi	r22, 0x05	; 5
     240:	72 e0       	ldi	r23, 0x02	; 2
     242:	82 e0       	ldi	r24, 0x02	; 2
     244:	91 e2       	ldi	r25, 0x21	; 33
     246:	0e 94 02 03 	call	0x604	; 0x604 <xTaskGenericCreate>
                (void *) val1, 1, NULL );

   xTaskCreate( (pdTASK_CODE) vTaskUSARTWrite, (signed char *) "T2", configMINIMAL_STACK_SIZE+1000,
     24a:	8b 81       	ldd	r24, Y+3	; 0x03
     24c:	9c 81       	ldd	r25, Y+4	; 0x04
     24e:	a1 2c       	mov	r10, r1
     250:	b1 2c       	mov	r11, r1
     252:	c1 2c       	mov	r12, r1
     254:	d1 2c       	mov	r13, r1
     256:	e1 2c       	mov	r14, r1
     258:	f1 2c       	mov	r15, r1
     25a:	01 e0       	ldi	r16, 0x01	; 1
     25c:	9c 01       	movw	r18, r24
     25e:	4d e3       	ldi	r20, 0x3D	; 61
     260:	54 e0       	ldi	r21, 0x04	; 4
     262:	68 e0       	ldi	r22, 0x08	; 8
     264:	72 e0       	ldi	r23, 0x02	; 2
     266:	80 ef       	ldi	r24, 0xF0	; 240
     268:	9a e1       	ldi	r25, 0x1A	; 26
     26a:	0e 94 02 03 	call	0x604	; 0x604 <xTaskGenericCreate>
   				(void *) val1, 1, NULL);

   xTaskCreate( (pdTASK_CODE) vTaskUSARTRead, (signed char *) "T3", configMINIMAL_STACK_SIZE+1000,
     26e:	8b 81       	ldd	r24, Y+3	; 0x03
     270:	9c 81       	ldd	r25, Y+4	; 0x04
     272:	a1 2c       	mov	r10, r1
     274:	b1 2c       	mov	r11, r1
     276:	c1 2c       	mov	r12, r1
     278:	d1 2c       	mov	r13, r1
     27a:	e1 2c       	mov	r14, r1
     27c:	f1 2c       	mov	r15, r1
     27e:	01 e0       	ldi	r16, 0x01	; 1
     280:	9c 01       	movw	r18, r24
     282:	4d e3       	ldi	r20, 0x3D	; 61
     284:	54 e0       	ldi	r21, 0x04	; 4
     286:	6b e0       	ldi	r22, 0x0B	; 11
     288:	72 e0       	ldi	r23, 0x02	; 2
     28a:	80 e5       	ldi	r24, 0x50	; 80
     28c:	9c e1       	ldi	r25, 0x1C	; 28
     28e:	0e 94 02 03 	call	0x604	; 0x604 <xTaskGenericCreate>

//   xTaskCreate( (pdTASK_CODE) vTaskUSARTLog, (signed char *) "T4", configMINIMAL_STACK_SIZE+1000,
//   				(void *) val1, 1, NULL);
    
    //- kick off the scheduler
	vTaskStartScheduler();
     292:	0e 94 01 06 	call	0xc02	; 0xc02 <vTaskStartScheduler>
    
	return 0;
     296:	80 e0       	ldi	r24, 0x00	; 0
     298:	90 e0       	ldi	r25, 0x00	; 0
}
     29a:	26 96       	adiw	r28, 0x06	; 6
     29c:	0f b6       	in	r0, 0x3f	; 63
     29e:	f8 94       	cli
     2a0:	de bf       	out	0x3e, r29	; 62
     2a2:	0f be       	out	0x3f, r0	; 63
     2a4:	cd bf       	out	0x3d, r28	; 61
     2a6:	df 91       	pop	r29
     2a8:	cf 91       	pop	r28
     2aa:	0f 91       	pop	r16
     2ac:	ff 90       	pop	r15
     2ae:	ef 90       	pop	r14
     2b0:	df 90       	pop	r13
     2b2:	cf 90       	pop	r12
     2b4:	bf 90       	pop	r11
     2b6:	af 90       	pop	r10
     2b8:	08 95       	ret

000002ba <printHex>:
/*-----------------------------------------------------------*/

void printHex(int i){
     2ba:	cf 93       	push	r28
     2bc:	df 93       	push	r29
     2be:	cd b7       	in	r28, 0x3d	; 61
     2c0:	de b7       	in	r29, 0x3e	; 62
     2c2:	62 97       	sbiw	r28, 0x12	; 18
     2c4:	0f b6       	in	r0, 0x3f	; 63
     2c6:	f8 94       	cli
     2c8:	de bf       	out	0x3e, r29	; 62
     2ca:	0f be       	out	0x3f, r0	; 63
     2cc:	cd bf       	out	0x3d, r28	; 61
     2ce:	9a 8b       	std	Y+18, r25	; 0x12
     2d0:	89 8b       	std	Y+17, r24	; 0x11
	char hex[] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
     2d2:	20 e1       	ldi	r18, 0x10	; 16
     2d4:	ee e0       	ldi	r30, 0x0E	; 14
     2d6:	f2 e0       	ldi	r31, 0x02	; 2
     2d8:	ce 01       	movw	r24, r28
     2da:	01 96       	adiw	r24, 0x01	; 1
     2dc:	dc 01       	movw	r26, r24
     2de:	01 90       	ld	r0, Z+
     2e0:	0d 92       	st	X+, r0
     2e2:	2a 95       	dec	r18
     2e4:	e1 f7       	brne	.-8      	; 0x2de <printHex+0x24>

	USART_Write(hex[(i&0xF000) >> 12]);
     2e6:	89 89       	ldd	r24, Y+17	; 0x11
     2e8:	9a 89       	ldd	r25, Y+18	; 0x12
     2ea:	89 2f       	mov	r24, r25
     2ec:	99 27       	eor	r25, r25
     2ee:	82 95       	swap	r24
     2f0:	8f 70       	andi	r24, 0x0F	; 15
     2f2:	9e 01       	movw	r18, r28
     2f4:	2f 5f       	subi	r18, 0xFF	; 255
     2f6:	3f 4f       	sbci	r19, 0xFF	; 255
     2f8:	82 0f       	add	r24, r18
     2fa:	93 1f       	adc	r25, r19
     2fc:	fc 01       	movw	r30, r24
     2fe:	80 81       	ld	r24, Z
     300:	0e 94 4e 1a 	call	0x349c	; 0x349c <USART_Write>
	USART_Write(hex[(i&0xF00) >> 8]);
     304:	89 89       	ldd	r24, Y+17	; 0x11
     306:	9a 89       	ldd	r25, Y+18	; 0x12
     308:	88 27       	eor	r24, r24
     30a:	9f 70       	andi	r25, 0x0F	; 15
     30c:	89 2f       	mov	r24, r25
     30e:	99 0f       	add	r25, r25
     310:	99 0b       	sbc	r25, r25
     312:	9e 01       	movw	r18, r28
     314:	2f 5f       	subi	r18, 0xFF	; 255
     316:	3f 4f       	sbci	r19, 0xFF	; 255
     318:	82 0f       	add	r24, r18
     31a:	93 1f       	adc	r25, r19
     31c:	fc 01       	movw	r30, r24
     31e:	80 81       	ld	r24, Z
     320:	0e 94 4e 1a 	call	0x349c	; 0x349c <USART_Write>
	USART_Write(hex[(i&0xF0) >> 4]);
     324:	89 89       	ldd	r24, Y+17	; 0x11
     326:	9a 89       	ldd	r25, Y+18	; 0x12
     328:	80 7f       	andi	r24, 0xF0	; 240
     32a:	99 27       	eor	r25, r25
     32c:	95 95       	asr	r25
     32e:	87 95       	ror	r24
     330:	95 95       	asr	r25
     332:	87 95       	ror	r24
     334:	95 95       	asr	r25
     336:	87 95       	ror	r24
     338:	95 95       	asr	r25
     33a:	87 95       	ror	r24
     33c:	9e 01       	movw	r18, r28
     33e:	2f 5f       	subi	r18, 0xFF	; 255
     340:	3f 4f       	sbci	r19, 0xFF	; 255
     342:	82 0f       	add	r24, r18
     344:	93 1f       	adc	r25, r19
     346:	fc 01       	movw	r30, r24
     348:	80 81       	ld	r24, Z
     34a:	0e 94 4e 1a 	call	0x349c	; 0x349c <USART_Write>
	USART_Write(hex[i&0xF]);
     34e:	89 89       	ldd	r24, Y+17	; 0x11
     350:	9a 89       	ldd	r25, Y+18	; 0x12
     352:	8f 70       	andi	r24, 0x0F	; 15
     354:	99 27       	eor	r25, r25
     356:	9e 01       	movw	r18, r28
     358:	2f 5f       	subi	r18, 0xFF	; 255
     35a:	3f 4f       	sbci	r19, 0xFF	; 255
     35c:	82 0f       	add	r24, r18
     35e:	93 1f       	adc	r25, r19
     360:	fc 01       	movw	r30, r24
     362:	80 81       	ld	r24, Z
     364:	0e 94 4e 1a 	call	0x349c	; 0x349c <USART_Write>

}
     368:	62 96       	adiw	r28, 0x12	; 18
     36a:	0f b6       	in	r0, 0x3f	; 63
     36c:	f8 94       	cli
     36e:	de bf       	out	0x3e, r29	; 62
     370:	0f be       	out	0x3f, r0	; 63
     372:	cd bf       	out	0x3d, r28	; 61
     374:	df 91       	pop	r29
     376:	cf 91       	pop	r28
     378:	08 95       	ret

0000037a <printNum>:

void printNum(unsigned char i){
     37a:	cf 93       	push	r28
     37c:	df 93       	push	r29
     37e:	cd b7       	in	r28, 0x3d	; 61
     380:	de b7       	in	r29, 0x3e	; 62
     382:	2d 97       	sbiw	r28, 0x0d	; 13
     384:	0f b6       	in	r0, 0x3f	; 63
     386:	f8 94       	cli
     388:	de bf       	out	0x3e, r29	; 62
     38a:	0f be       	out	0x3f, r0	; 63
     38c:	cd bf       	out	0x3d, r28	; 61
     38e:	8d 87       	std	Y+13, r24	; 0x0d
    
    char str[10];
    memset(str,0,10);
     390:	ce 01       	movw	r24, r28
     392:	03 96       	adiw	r24, 0x03	; 3
     394:	4a e0       	ldi	r20, 0x0A	; 10
     396:	50 e0       	ldi	r21, 0x00	; 0
     398:	60 e0       	ldi	r22, 0x00	; 0
     39a:	70 e0       	ldi	r23, 0x00	; 0
     39c:	0e 94 db 23 	call	0x47b6	; 0x47b6 <memset>
    itoa(i,str,10);
     3a0:	8d 85       	ldd	r24, Y+13	; 0x0d
     3a2:	88 2f       	mov	r24, r24
     3a4:	90 e0       	ldi	r25, 0x00	; 0
     3a6:	9e 01       	movw	r18, r28
     3a8:	2d 5f       	subi	r18, 0xFD	; 253
     3aa:	3f 4f       	sbci	r19, 0xFF	; 255
     3ac:	4a e0       	ldi	r20, 0x0A	; 10
     3ae:	50 e0       	ldi	r21, 0x00	; 0
     3b0:	b9 01       	movw	r22, r18
     3b2:	0e 94 f1 23 	call	0x47e2	; 0x47e2 <itoa>
    char * irr = str;
     3b6:	ce 01       	movw	r24, r28
     3b8:	03 96       	adiw	r24, 0x03	; 3
     3ba:	9a 83       	std	Y+2, r25	; 0x02
     3bc:	89 83       	std	Y+1, r24	; 0x01
    while(*irr){
     3be:	0b c0       	rjmp	.+22     	; 0x3d6 <printNum+0x5c>
        USART_AddToQueue((unsigned char )*irr);
     3c0:	89 81       	ldd	r24, Y+1	; 0x01
     3c2:	9a 81       	ldd	r25, Y+2	; 0x02
     3c4:	fc 01       	movw	r30, r24
     3c6:	80 81       	ld	r24, Z
     3c8:	0e 94 bb 1a 	call	0x3576	; 0x3576 <USART_AddToQueue>
        irr++;
     3cc:	89 81       	ldd	r24, Y+1	; 0x01
     3ce:	9a 81       	ldd	r25, Y+2	; 0x02
     3d0:	01 96       	adiw	r24, 0x01	; 1
     3d2:	9a 83       	std	Y+2, r25	; 0x02
     3d4:	89 83       	std	Y+1, r24	; 0x01
    
    char str[10];
    memset(str,0,10);
    itoa(i,str,10);
    char * irr = str;
    while(*irr){
     3d6:	89 81       	ldd	r24, Y+1	; 0x01
     3d8:	9a 81       	ldd	r25, Y+2	; 0x02
     3da:	fc 01       	movw	r30, r24
     3dc:	80 81       	ld	r24, Z
     3de:	88 23       	and	r24, r24
     3e0:	79 f7       	brne	.-34     	; 0x3c0 <printNum+0x46>
        USART_AddToQueue((unsigned char )*irr);
        irr++;
    }
    
}
     3e2:	2d 96       	adiw	r28, 0x0d	; 13
     3e4:	0f b6       	in	r0, 0x3f	; 63
     3e6:	f8 94       	cli
     3e8:	de bf       	out	0x3e, r29	; 62
     3ea:	0f be       	out	0x3f, r0	; 63
     3ec:	cd bf       	out	0x3d, r28	; 61
     3ee:	df 91       	pop	r29
     3f0:	cf 91       	pop	r28
     3f2:	08 95       	ret

000003f4 <__vector_50>:

ISR(TIMER5_OVF_vect){
     3f4:	1f 92       	push	r1
     3f6:	0f 92       	push	r0
     3f8:	00 90 5f 00 	lds	r0, 0x005F
     3fc:	0f 92       	push	r0
     3fe:	11 24       	eor	r1, r1
     400:	00 90 5b 00 	lds	r0, 0x005B
     404:	0f 92       	push	r0
     406:	2f 93       	push	r18
     408:	3f 93       	push	r19
     40a:	8f 93       	push	r24
     40c:	9f 93       	push	r25
     40e:	ef 93       	push	r30
     410:	ff 93       	push	r31
     412:	cf 93       	push	r28
     414:	df 93       	push	r29
     416:	cd b7       	in	r28, 0x3d	; 61
     418:	de b7       	in	r29, 0x3e	; 62

	PORTB ^= 0xFF;
     41a:	85 e2       	ldi	r24, 0x25	; 37
     41c:	90 e0       	ldi	r25, 0x00	; 0
     41e:	25 e2       	ldi	r18, 0x25	; 37
     420:	30 e0       	ldi	r19, 0x00	; 0
     422:	f9 01       	movw	r30, r18
     424:	20 81       	ld	r18, Z
     426:	20 95       	com	r18
     428:	fc 01       	movw	r30, r24
     42a:	20 83       	st	Z, r18
	TCNT3L = 0;
     42c:	84 e9       	ldi	r24, 0x94	; 148
     42e:	90 e0       	ldi	r25, 0x00	; 0
     430:	fc 01       	movw	r30, r24
     432:	10 82       	st	Z, r1
	TCNT3H = 0;
     434:	85 e9       	ldi	r24, 0x95	; 149
     436:	90 e0       	ldi	r25, 0x00	; 0
     438:	fc 01       	movw	r30, r24
     43a:	10 82       	st	Z, r1

}
     43c:	df 91       	pop	r29
     43e:	cf 91       	pop	r28
     440:	ff 91       	pop	r31
     442:	ef 91       	pop	r30
     444:	9f 91       	pop	r25
     446:	8f 91       	pop	r24
     448:	3f 91       	pop	r19
     44a:	2f 91       	pop	r18
     44c:	0f 90       	pop	r0
     44e:	00 92 5b 00 	sts	0x005B, r0
     452:	0f 90       	pop	r0
     454:	00 92 5f 00 	sts	0x005F, r0
     458:	0f 90       	pop	r0
     45a:	1f 90       	pop	r1
     45c:	18 95       	reti

0000045e <getTimerCount2>:

unsigned int getTimerCount2(){
     45e:	cf 93       	push	r28
     460:	df 93       	push	r29
     462:	cd b7       	in	r28, 0x3d	; 61
     464:	de b7       	in	r29, 0x3e	; 62

	//volatile char timerLow = TCNT3L;

	return TCNT0;
     466:	86 e4       	ldi	r24, 0x46	; 70
     468:	90 e0       	ldi	r25, 0x00	; 0
     46a:	fc 01       	movw	r30, r24
     46c:	80 81       	ld	r24, Z
     46e:	88 2f       	mov	r24, r24
     470:	90 e0       	ldi	r25, 0x00	; 0

}
     472:	df 91       	pop	r29
     474:	cf 91       	pop	r28
     476:	08 95       	ret

00000478 <vTaskFunction_1>:

void vTaskFunction_1(void *pvParameters)
{	
     478:	cf 93       	push	r28
     47a:	df 93       	push	r29
     47c:	1f 92       	push	r1
     47e:	1f 92       	push	r1
     480:	cd b7       	in	r28, 0x3d	; 61
     482:	de b7       	in	r29, 0x3e	; 62
     484:	9a 83       	std	Y+2, r25	; 0x02
     486:	89 83       	std	Y+1, r24	; 0x01
   USART_Init(9600, 16000000);
     488:	40 e0       	ldi	r20, 0x00	; 0
     48a:	54 e2       	ldi	r21, 0x24	; 36
     48c:	64 ef       	ldi	r22, 0xF4	; 244
     48e:	70 e0       	ldi	r23, 0x00	; 0
     490:	80 e8       	ldi	r24, 0x80	; 128
     492:	95 e2       	ldi	r25, 0x25	; 37
     494:	0e 94 0b 1a 	call	0x3416	; 0x3416 <USART_Init>
	for(;;);
     498:	ff cf       	rjmp	.-2      	; 0x498 <vTaskFunction_1+0x20>

0000049a <vTaskFunction_2>:
		PORTL = 0x80;
		vTaskDelay(200);
	}
}

void vTaskFunction_2(void *pvParameters){
     49a:	cf 93       	push	r28
     49c:	df 93       	push	r29
     49e:	1f 92       	push	r1
     4a0:	1f 92       	push	r1
     4a2:	cd b7       	in	r28, 0x3d	; 61
     4a4:	de b7       	in	r29, 0x3e	; 62
     4a6:	9a 83       	std	Y+2, r25	; 0x02
     4a8:	89 83       	std	Y+1, r24	; 0x01
	DDRA = ~(1 << 3);
     4aa:	81 e2       	ldi	r24, 0x21	; 33
     4ac:	90 e0       	ldi	r25, 0x00	; 0
     4ae:	27 ef       	ldi	r18, 0xF7	; 247
     4b0:	fc 01       	movw	r30, r24
     4b2:	20 83       	st	Z, r18
	PORTA |= 3;
     4b4:	82 e2       	ldi	r24, 0x22	; 34
     4b6:	90 e0       	ldi	r25, 0x00	; 0
     4b8:	22 e2       	ldi	r18, 0x22	; 34
     4ba:	30 e0       	ldi	r19, 0x00	; 0
     4bc:	f9 01       	movw	r30, r18
     4be:	20 81       	ld	r18, Z
     4c0:	23 60       	ori	r18, 0x03	; 3
     4c2:	fc 01       	movw	r30, r24
     4c4:	20 83       	st	Z, r18
	for(;;){
		PORTA &= ~3;
     4c6:	82 e2       	ldi	r24, 0x22	; 34
     4c8:	90 e0       	ldi	r25, 0x00	; 0
     4ca:	22 e2       	ldi	r18, 0x22	; 34
     4cc:	30 e0       	ldi	r19, 0x00	; 0
     4ce:	f9 01       	movw	r30, r18
     4d0:	20 81       	ld	r18, Z
     4d2:	2c 7f       	andi	r18, 0xFC	; 252
     4d4:	fc 01       	movw	r30, r24
     4d6:	20 83       	st	Z, r18
		vTaskDelay(200); 
     4d8:	88 ec       	ldi	r24, 0xC8	; 200
     4da:	90 e0       	ldi	r25, 0x00	; 0
     4dc:	0e 94 6f 04 	call	0x8de	; 0x8de <vTaskDelay>
		PORTA &= ~3;
     4e0:	82 e2       	ldi	r24, 0x22	; 34
     4e2:	90 e0       	ldi	r25, 0x00	; 0
     4e4:	22 e2       	ldi	r18, 0x22	; 34
     4e6:	30 e0       	ldi	r19, 0x00	; 0
     4e8:	f9 01       	movw	r30, r18
     4ea:	20 81       	ld	r18, Z
     4ec:	2c 7f       	andi	r18, 0xFC	; 252
     4ee:	fc 01       	movw	r30, r24
     4f0:	20 83       	st	Z, r18
		PORTA |= 1;
     4f2:	82 e2       	ldi	r24, 0x22	; 34
     4f4:	90 e0       	ldi	r25, 0x00	; 0
     4f6:	22 e2       	ldi	r18, 0x22	; 34
     4f8:	30 e0       	ldi	r19, 0x00	; 0
     4fa:	f9 01       	movw	r30, r18
     4fc:	20 81       	ld	r18, Z
     4fe:	21 60       	ori	r18, 0x01	; 1
     500:	fc 01       	movw	r30, r24
     502:	20 83       	st	Z, r18
		vTaskDelay(200); 
     504:	88 ec       	ldi	r24, 0xC8	; 200
     506:	90 e0       	ldi	r25, 0x00	; 0
     508:	0e 94 6f 04 	call	0x8de	; 0x8de <vTaskDelay>
		PORTA &= ~3;
     50c:	82 e2       	ldi	r24, 0x22	; 34
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	22 e2       	ldi	r18, 0x22	; 34
     512:	30 e0       	ldi	r19, 0x00	; 0
     514:	f9 01       	movw	r30, r18
     516:	20 81       	ld	r18, Z
     518:	2c 7f       	andi	r18, 0xFC	; 252
     51a:	fc 01       	movw	r30, r24
     51c:	20 83       	st	Z, r18
		PORTA |= 2;
     51e:	82 e2       	ldi	r24, 0x22	; 34
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	22 e2       	ldi	r18, 0x22	; 34
     524:	30 e0       	ldi	r19, 0x00	; 0
     526:	f9 01       	movw	r30, r18
     528:	20 81       	ld	r18, Z
     52a:	22 60       	ori	r18, 0x02	; 2
     52c:	fc 01       	movw	r30, r24
     52e:	20 83       	st	Z, r18
		vTaskDelay(200);
     530:	88 ec       	ldi	r24, 0xC8	; 200
     532:	90 e0       	ldi	r25, 0x00	; 0
     534:	0e 94 6f 04 	call	0x8de	; 0x8de <vTaskDelay>
	}	
     538:	c6 cf       	rjmp	.-116    	; 0x4c6 <vTaskFunction_2+0x2c>

0000053a <vTaskFunction_3>:
}

void vTaskFunction_3(void *pvParameters){
     53a:	cf 93       	push	r28
     53c:	df 93       	push	r29
     53e:	1f 92       	push	r1
     540:	1f 92       	push	r1
     542:	cd b7       	in	r28, 0x3d	; 61
     544:	de b7       	in	r29, 0x3e	; 62
     546:	9a 83       	std	Y+2, r25	; 0x02
     548:	89 83       	std	Y+1, r24	; 0x01

	for(;;){
		if(PINA & 0x08){
     54a:	80 e2       	ldi	r24, 0x20	; 32
     54c:	90 e0       	ldi	r25, 0x00	; 0
     54e:	fc 01       	movw	r30, r24
     550:	80 81       	ld	r24, Z
     552:	88 2f       	mov	r24, r24
     554:	90 e0       	ldi	r25, 0x00	; 0
     556:	88 70       	andi	r24, 0x08	; 8
     558:	99 27       	eor	r25, r25
     55a:	00 97       	sbiw	r24, 0x00	; 0
     55c:	51 f0       	breq	.+20     	; 0x572 <vTaskFunction_3+0x38>
			PORTA |= 0x80;
     55e:	82 e2       	ldi	r24, 0x22	; 34
     560:	90 e0       	ldi	r25, 0x00	; 0
     562:	22 e2       	ldi	r18, 0x22	; 34
     564:	30 e0       	ldi	r19, 0x00	; 0
     566:	f9 01       	movw	r30, r18
     568:	20 81       	ld	r18, Z
     56a:	20 68       	ori	r18, 0x80	; 128
     56c:	fc 01       	movw	r30, r24
     56e:	20 83       	st	Z, r18
		} else {
			PORTA &= ~0x80;
		}
	}
     570:	ec cf       	rjmp	.-40     	; 0x54a <vTaskFunction_3+0x10>

	for(;;){
		if(PINA & 0x08){
			PORTA |= 0x80;
		} else {
			PORTA &= ~0x80;
     572:	82 e2       	ldi	r24, 0x22	; 34
     574:	90 e0       	ldi	r25, 0x00	; 0
     576:	22 e2       	ldi	r18, 0x22	; 34
     578:	30 e0       	ldi	r19, 0x00	; 0
     57a:	f9 01       	movw	r30, r18
     57c:	20 81       	ld	r18, Z
     57e:	2f 77       	andi	r18, 0x7F	; 127
     580:	fc 01       	movw	r30, r24
     582:	20 83       	st	Z, r18
		}
	}
     584:	e2 cf       	rjmp	.-60     	; 0x54a <vTaskFunction_3+0x10>

00000586 <vTaskPot>:

}

void vTaskPot(void *pvParameters){
     586:	cf 93       	push	r28
     588:	df 93       	push	r29
     58a:	00 d0       	rcall	.+0      	; 0x58c <vTaskPot+0x6>
     58c:	1f 92       	push	r1
     58e:	cd b7       	in	r28, 0x3d	; 61
     590:	de b7       	in	r29, 0x3e	; 62
     592:	9c 83       	std	Y+4, r25	; 0x04
     594:	8b 83       	std	Y+3, r24	; 0x03
	initializeSPI();
     596:	0e 94 be 22 	call	0x457c	; 0x457c <initializeSPI>
	int a = 0;
     59a:	1a 82       	std	Y+2, r1	; 0x02
     59c:	19 82       	std	Y+1, r1	; 0x01
	initSpeedController();
     59e:	0e 94 1a 22 	call	0x4434	; 0x4434 <initSpeedController>
		setPot(a);
		vTaskDelay(80);
		a++;
	}*/
	for(;;){
		setPot(1);
     5a2:	81 e0       	ldi	r24, 0x01	; 1
     5a4:	90 e0       	ldi	r25, 0x00	; 0
     5a6:	0e 94 25 22 	call	0x444a	; 0x444a <setPot>
		vTaskDelay(500);
     5aa:	84 ef       	ldi	r24, 0xF4	; 244
     5ac:	91 e0       	ldi	r25, 0x01	; 1
     5ae:	0e 94 6f 04 	call	0x8de	; 0x8de <vTaskDelay>
		setPot(0x40);
     5b2:	80 e4       	ldi	r24, 0x40	; 64
     5b4:	90 e0       	ldi	r25, 0x00	; 0
     5b6:	0e 94 25 22 	call	0x444a	; 0x444a <setPot>
		vTaskDelay(500);
     5ba:	84 ef       	ldi	r24, 0xF4	; 244
     5bc:	91 e0       	ldi	r25, 0x01	; 1
     5be:	0e 94 6f 04 	call	0x8de	; 0x8de <vTaskDelay>
		setPot(0x7F);
     5c2:	8f e7       	ldi	r24, 0x7F	; 127
     5c4:	90 e0       	ldi	r25, 0x00	; 0
     5c6:	0e 94 25 22 	call	0x444a	; 0x444a <setPot>
		vTaskDelay(500);
     5ca:	84 ef       	ldi	r24, 0xF4	; 244
     5cc:	91 e0       	ldi	r25, 0x01	; 1
     5ce:	0e 94 6f 04 	call	0x8de	; 0x8de <vTaskDelay>
		setPot(0x40);
     5d2:	80 e4       	ldi	r24, 0x40	; 64
     5d4:	90 e0       	ldi	r25, 0x00	; 0
     5d6:	0e 94 25 22 	call	0x444a	; 0x444a <setPot>
		vTaskDelay(500);
     5da:	84 ef       	ldi	r24, 0xF4	; 244
     5dc:	91 e0       	ldi	r25, 0x01	; 1
     5de:	0e 94 6f 04 	call	0x8de	; 0x8de <vTaskDelay>
	}
     5e2:	df cf       	rjmp	.-66     	; 0x5a2 <vTaskPot+0x1c>

000005e4 <vIO_init>:
}


void vIO_init(void)
{
     5e4:	cf 93       	push	r28
     5e6:	df 93       	push	r29
     5e8:	cd b7       	in	r28, 0x3d	; 61
     5ea:	de b7       	in	r29, 0x3e	; 62
    //- set PortB as output
	DDRB = 0xFF; 
     5ec:	84 e2       	ldi	r24, 0x24	; 36
     5ee:	90 e0       	ldi	r25, 0x00	; 0
     5f0:	2f ef       	ldi	r18, 0xFF	; 255
     5f2:	fc 01       	movw	r30, r24
     5f4:	20 83       	st	Z, r18
    PORTB = 0; 
     5f6:	85 e2       	ldi	r24, 0x25	; 37
     5f8:	90 e0       	ldi	r25, 0x00	; 0
     5fa:	fc 01       	movw	r30, r24
     5fc:	10 82       	st	Z, r1
}
     5fe:	df 91       	pop	r29
     600:	cf 91       	pop	r28
     602:	08 95       	ret

00000604 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
     604:	af 92       	push	r10
     606:	bf 92       	push	r11
     608:	cf 92       	push	r12
     60a:	df 92       	push	r13
     60c:	ef 92       	push	r14
     60e:	ff 92       	push	r15
     610:	0f 93       	push	r16
     612:	1f 93       	push	r17
     614:	cf 93       	push	r28
     616:	df 93       	push	r29
     618:	cd b7       	in	r28, 0x3d	; 61
     61a:	de b7       	in	r29, 0x3e	; 62
     61c:	64 97       	sbiw	r28, 0x14	; 20
     61e:	0f b6       	in	r0, 0x3f	; 63
     620:	f8 94       	cli
     622:	de bf       	out	0x3e, r29	; 62
     624:	0f be       	out	0x3f, r0	; 63
     626:	cd bf       	out	0x3d, r28	; 61
     628:	9f 83       	std	Y+7, r25	; 0x07
     62a:	8e 83       	std	Y+6, r24	; 0x06
     62c:	79 87       	std	Y+9, r23	; 0x09
     62e:	68 87       	std	Y+8, r22	; 0x08
     630:	5b 87       	std	Y+11, r21	; 0x0b
     632:	4a 87       	std	Y+10, r20	; 0x0a
     634:	3d 87       	std	Y+13, r19	; 0x0d
     636:	2c 87       	std	Y+12, r18	; 0x0c
     638:	0e 87       	std	Y+14, r16	; 0x0e
     63a:	f8 8a       	std	Y+16, r15	; 0x10
     63c:	ef 86       	std	Y+15, r14	; 0x0f
     63e:	da 8a       	std	Y+18, r13	; 0x12
     640:	c9 8a       	std	Y+17, r12	; 0x11
     642:	bc 8a       	std	Y+20, r11	; 0x14
     644:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
     646:	29 89       	ldd	r18, Y+17	; 0x11
     648:	3a 89       	ldd	r19, Y+18	; 0x12
     64a:	8a 85       	ldd	r24, Y+10	; 0x0a
     64c:	9b 85       	ldd	r25, Y+11	; 0x0b
     64e:	b9 01       	movw	r22, r18
     650:	0e 94 b8 0a 	call	0x1570	; 0x1570 <prvAllocateTCBAndStack>
     654:	9b 83       	std	Y+3, r25	; 0x03
     656:	8a 83       	std	Y+2, r24	; 0x02

	if( pxNewTCB != NULL )
     658:	8a 81       	ldd	r24, Y+2	; 0x02
     65a:	9b 81       	ldd	r25, Y+3	; 0x03
     65c:	00 97       	sbiw	r24, 0x00	; 0
     65e:	09 f4       	brne	.+2      	; 0x662 <xTaskGenericCreate+0x5e>
     660:	9f c0       	rjmp	.+318    	; 0x7a0 <xTaskGenericCreate+0x19c>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
     662:	8a 81       	ldd	r24, Y+2	; 0x02
     664:	9b 81       	ldd	r25, Y+3	; 0x03
     666:	fc 01       	movw	r30, r24
     668:	27 89       	ldd	r18, Z+23	; 0x17
     66a:	30 8d       	ldd	r19, Z+24	; 0x18
     66c:	8a 85       	ldd	r24, Y+10	; 0x0a
     66e:	9b 85       	ldd	r25, Y+11	; 0x0b
     670:	01 97       	sbiw	r24, 0x01	; 1
     672:	82 0f       	add	r24, r18
     674:	93 1f       	adc	r25, r19
     676:	9d 83       	std	Y+5, r25	; 0x05
     678:	8c 83       	std	Y+4, r24	; 0x04
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
     67a:	4a 85       	ldd	r20, Y+10	; 0x0a
     67c:	5b 85       	ldd	r21, Y+11	; 0x0b
     67e:	2b 89       	ldd	r18, Y+19	; 0x13
     680:	3c 89       	ldd	r19, Y+20	; 0x14
     682:	68 85       	ldd	r22, Y+8	; 0x08
     684:	79 85       	ldd	r23, Y+9	; 0x09
     686:	8a 81       	ldd	r24, Y+2	; 0x02
     688:	9b 81       	ldd	r25, Y+3	; 0x03
     68a:	8a 01       	movw	r16, r20
     68c:	4e 85       	ldd	r20, Y+14	; 0x0e
     68e:	0e 94 c8 09 	call	0x1390	; 0x1390 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     692:	4c 85       	ldd	r20, Y+12	; 0x0c
     694:	5d 85       	ldd	r21, Y+13	; 0x0d
     696:	2e 81       	ldd	r18, Y+6	; 0x06
     698:	3f 81       	ldd	r19, Y+7	; 0x07
     69a:	8c 81       	ldd	r24, Y+4	; 0x04
     69c:	9d 81       	ldd	r25, Y+5	; 0x05
     69e:	b9 01       	movw	r22, r18
     6a0:	0e 94 e0 16 	call	0x2dc0	; 0x2dc0 <pxPortInitialiseStack>
     6a4:	9c 01       	movw	r18, r24
     6a6:	8a 81       	ldd	r24, Y+2	; 0x02
     6a8:	9b 81       	ldd	r25, Y+3	; 0x03
     6aa:	fc 01       	movw	r30, r24
     6ac:	31 83       	std	Z+1, r19	; 0x01
     6ae:	20 83       	st	Z, r18
		#endif

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
     6b0:	8f 85       	ldd	r24, Y+15	; 0x0f
     6b2:	98 89       	ldd	r25, Y+16	; 0x10
     6b4:	00 97       	sbiw	r24, 0x00	; 0
     6b6:	39 f0       	breq	.+14     	; 0x6c6 <xTaskGenericCreate+0xc2>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
     6b8:	8f 85       	ldd	r24, Y+15	; 0x0f
     6ba:	98 89       	ldd	r25, Y+16	; 0x10
     6bc:	2a 81       	ldd	r18, Y+2	; 0x02
     6be:	3b 81       	ldd	r19, Y+3	; 0x03
     6c0:	fc 01       	movw	r30, r24
     6c2:	31 83       	std	Z+1, r19	; 0x01
     6c4:	20 83       	st	Z, r18
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
     6c6:	0f b6       	in	r0, 0x3f	; 63
     6c8:	f8 94       	cli
     6ca:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
     6cc:	80 91 7c 02 	lds	r24, 0x027C
     6d0:	8f 5f       	subi	r24, 0xFF	; 255
     6d2:	80 93 7c 02 	sts	0x027C, r24
			if( pxCurrentTCB == NULL )
     6d6:	80 91 2e 02 	lds	r24, 0x022E
     6da:	90 91 2f 02 	lds	r25, 0x022F
     6de:	00 97       	sbiw	r24, 0x00	; 0
     6e0:	69 f4       	brne	.+26     	; 0x6fc <xTaskGenericCreate+0xf8>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
     6e2:	8a 81       	ldd	r24, Y+2	; 0x02
     6e4:	9b 81       	ldd	r25, Y+3	; 0x03
     6e6:	90 93 2f 02 	sts	0x022F, r25
     6ea:	80 93 2e 02 	sts	0x022E, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
     6ee:	80 91 7c 02 	lds	r24, 0x027C
     6f2:	81 30       	cpi	r24, 0x01	; 1
     6f4:	b1 f4       	brne	.+44     	; 0x722 <xTaskGenericCreate+0x11e>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
     6f6:	0e 94 29 0a 	call	0x1452	; 0x1452 <prvInitialiseTaskLists>
     6fa:	13 c0       	rjmp	.+38     	; 0x722 <xTaskGenericCreate+0x11e>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
     6fc:	80 91 81 02 	lds	r24, 0x0281
     700:	88 23       	and	r24, r24
     702:	79 f4       	brne	.+30     	; 0x722 <xTaskGenericCreate+0x11e>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
     704:	80 91 2e 02 	lds	r24, 0x022E
     708:	90 91 2f 02 	lds	r25, 0x022F
     70c:	fc 01       	movw	r30, r24
     70e:	96 89       	ldd	r25, Z+22	; 0x16
     710:	8e 85       	ldd	r24, Y+14	; 0x0e
     712:	89 17       	cp	r24, r25
     714:	30 f0       	brcs	.+12     	; 0x722 <xTaskGenericCreate+0x11e>
					{
						pxCurrentTCB = pxNewTCB;
     716:	8a 81       	ldd	r24, Y+2	; 0x02
     718:	9b 81       	ldd	r25, Y+3	; 0x03
     71a:	90 93 2f 02 	sts	0x022F, r25
     71e:	80 93 2e 02 	sts	0x022E, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
     722:	8a 81       	ldd	r24, Y+2	; 0x02
     724:	9b 81       	ldd	r25, Y+3	; 0x03
     726:	fc 01       	movw	r30, r24
     728:	96 89       	ldd	r25, Z+22	; 0x16
     72a:	80 91 7f 02 	lds	r24, 0x027F
     72e:	89 17       	cp	r24, r25
     730:	30 f4       	brcc	.+12     	; 0x73e <xTaskGenericCreate+0x13a>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
     732:	8a 81       	ldd	r24, Y+2	; 0x02
     734:	9b 81       	ldd	r25, Y+3	; 0x03
     736:	fc 01       	movw	r30, r24
     738:	86 89       	ldd	r24, Z+22	; 0x16
     73a:	80 93 7f 02 	sts	0x027F, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
     73e:	80 91 86 02 	lds	r24, 0x0286
     742:	8f 5f       	subi	r24, 0xFF	; 255
     744:	80 93 86 02 	sts	0x0286, r24

			prvAddTaskToReadyQueue( pxNewTCB );
     748:	8a 81       	ldd	r24, Y+2	; 0x02
     74a:	9b 81       	ldd	r25, Y+3	; 0x03
     74c:	fc 01       	movw	r30, r24
     74e:	96 89       	ldd	r25, Z+22	; 0x16
     750:	80 91 80 02 	lds	r24, 0x0280
     754:	89 17       	cp	r24, r25
     756:	30 f4       	brcc	.+12     	; 0x764 <xTaskGenericCreate+0x160>
     758:	8a 81       	ldd	r24, Y+2	; 0x02
     75a:	9b 81       	ldd	r25, Y+3	; 0x03
     75c:	fc 01       	movw	r30, r24
     75e:	86 89       	ldd	r24, Z+22	; 0x16
     760:	80 93 80 02 	sts	0x0280, r24
     764:	8a 81       	ldd	r24, Y+2	; 0x02
     766:	9b 81       	ldd	r25, Y+3	; 0x03
     768:	ac 01       	movw	r20, r24
     76a:	4e 5f       	subi	r20, 0xFE	; 254
     76c:	5f 4f       	sbci	r21, 0xFF	; 255
     76e:	8a 81       	ldd	r24, Y+2	; 0x02
     770:	9b 81       	ldd	r25, Y+3	; 0x03
     772:	fc 01       	movw	r30, r24
     774:	86 89       	ldd	r24, Z+22	; 0x16
     776:	28 2f       	mov	r18, r24
     778:	30 e0       	ldi	r19, 0x00	; 0
     77a:	c9 01       	movw	r24, r18
     77c:	88 0f       	add	r24, r24
     77e:	99 1f       	adc	r25, r25
     780:	88 0f       	add	r24, r24
     782:	99 1f       	adc	r25, r25
     784:	88 0f       	add	r24, r24
     786:	99 1f       	adc	r25, r25
     788:	82 0f       	add	r24, r18
     78a:	93 1f       	adc	r25, r19
     78c:	80 5d       	subi	r24, 0xD0	; 208
     78e:	9d 4f       	sbci	r25, 0xFD	; 253
     790:	ba 01       	movw	r22, r20
     792:	0e 94 52 12 	call	0x24a4	; 0x24a4 <vListInsertEnd>

			xReturn = pdPASS;
     796:	81 e0       	ldi	r24, 0x01	; 1
     798:	89 83       	std	Y+1, r24	; 0x01
			portSETUP_TCB( pxNewTCB );
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
     79a:	0f 90       	pop	r0
     79c:	0f be       	out	0x3f, r0	; 63
     79e:	02 c0       	rjmp	.+4      	; 0x7a4 <xTaskGenericCreate+0x1a0>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     7a0:	8f ef       	ldi	r24, 0xFF	; 255
     7a2:	89 83       	std	Y+1, r24	; 0x01
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
     7a4:	89 81       	ldd	r24, Y+1	; 0x01
     7a6:	81 30       	cpi	r24, 0x01	; 1
     7a8:	79 f4       	brne	.+30     	; 0x7c8 <xTaskGenericCreate+0x1c4>
	{
		if( xSchedulerRunning != pdFALSE )
     7aa:	80 91 81 02 	lds	r24, 0x0281
     7ae:	88 23       	and	r24, r24
     7b0:	59 f0       	breq	.+22     	; 0x7c8 <xTaskGenericCreate+0x1c4>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
     7b2:	80 91 2e 02 	lds	r24, 0x022E
     7b6:	90 91 2f 02 	lds	r25, 0x022F
     7ba:	fc 01       	movw	r30, r24
     7bc:	96 89       	ldd	r25, Z+22	; 0x16
     7be:	8e 85       	ldd	r24, Y+14	; 0x0e
     7c0:	98 17       	cp	r25, r24
     7c2:	10 f4       	brcc	.+4      	; 0x7c8 <xTaskGenericCreate+0x1c4>
			{
				portYIELD_WITHIN_API();
     7c4:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <vPortYield>
			}
		}
	}

	return xReturn;
     7c8:	89 81       	ldd	r24, Y+1	; 0x01
}
     7ca:	64 96       	adiw	r28, 0x14	; 20
     7cc:	0f b6       	in	r0, 0x3f	; 63
     7ce:	f8 94       	cli
     7d0:	de bf       	out	0x3e, r29	; 62
     7d2:	0f be       	out	0x3f, r0	; 63
     7d4:	cd bf       	out	0x3d, r28	; 61
     7d6:	df 91       	pop	r29
     7d8:	cf 91       	pop	r28
     7da:	1f 91       	pop	r17
     7dc:	0f 91       	pop	r16
     7de:	ff 90       	pop	r15
     7e0:	ef 90       	pop	r14
     7e2:	df 90       	pop	r13
     7e4:	cf 90       	pop	r12
     7e6:	bf 90       	pop	r11
     7e8:	af 90       	pop	r10
     7ea:	08 95       	ret

000007ec <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
     7ec:	cf 93       	push	r28
     7ee:	df 93       	push	r29
     7f0:	cd b7       	in	r28, 0x3d	; 61
     7f2:	de b7       	in	r29, 0x3e	; 62
     7f4:	28 97       	sbiw	r28, 0x08	; 8
     7f6:	0f b6       	in	r0, 0x3f	; 63
     7f8:	f8 94       	cli
     7fa:	de bf       	out	0x3e, r29	; 62
     7fc:	0f be       	out	0x3f, r0	; 63
     7fe:	cd bf       	out	0x3d, r28	; 61
     800:	9e 83       	std	Y+6, r25	; 0x06
     802:	8d 83       	std	Y+5, r24	; 0x05
     804:	78 87       	std	Y+8, r23	; 0x08
     806:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
     808:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
     80a:	0e 94 43 06 	call	0xc86	; 0xc86 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     80e:	8d 81       	ldd	r24, Y+5	; 0x05
     810:	9e 81       	ldd	r25, Y+6	; 0x06
     812:	fc 01       	movw	r30, r24
     814:	20 81       	ld	r18, Z
     816:	31 81       	ldd	r19, Z+1	; 0x01
     818:	8f 81       	ldd	r24, Y+7	; 0x07
     81a:	98 85       	ldd	r25, Y+8	; 0x08
     81c:	82 0f       	add	r24, r18
     81e:	93 1f       	adc	r25, r19
     820:	9b 83       	std	Y+3, r25	; 0x03
     822:	8a 83       	std	Y+2, r24	; 0x02

			if( xTickCount < *pxPreviousWakeTime )
     824:	8d 81       	ldd	r24, Y+5	; 0x05
     826:	9e 81       	ldd	r25, Y+6	; 0x06
     828:	fc 01       	movw	r30, r24
     82a:	20 81       	ld	r18, Z
     82c:	31 81       	ldd	r19, Z+1	; 0x01
     82e:	80 91 7d 02 	lds	r24, 0x027D
     832:	90 91 7e 02 	lds	r25, 0x027E
     836:	82 17       	cp	r24, r18
     838:	93 07       	cpc	r25, r19
     83a:	b0 f4       	brcc	.+44     	; 0x868 <vTaskDelayUntil+0x7c>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
     83c:	8d 81       	ldd	r24, Y+5	; 0x05
     83e:	9e 81       	ldd	r25, Y+6	; 0x06
     840:	fc 01       	movw	r30, r24
     842:	20 81       	ld	r18, Z
     844:	31 81       	ldd	r19, Z+1	; 0x01
     846:	8a 81       	ldd	r24, Y+2	; 0x02
     848:	9b 81       	ldd	r25, Y+3	; 0x03
     84a:	82 17       	cp	r24, r18
     84c:	93 07       	cpc	r25, r19
     84e:	08 f5       	brcc	.+66     	; 0x892 <vTaskDelayUntil+0xa6>
     850:	80 91 7d 02 	lds	r24, 0x027D
     854:	90 91 7e 02 	lds	r25, 0x027E
     858:	2a 81       	ldd	r18, Y+2	; 0x02
     85a:	3b 81       	ldd	r19, Y+3	; 0x03
     85c:	82 17       	cp	r24, r18
     85e:	93 07       	cpc	r25, r19
     860:	c0 f4       	brcc	.+48     	; 0x892 <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
     862:	81 e0       	ldi	r24, 0x01	; 1
     864:	89 83       	std	Y+1, r24	; 0x01
     866:	15 c0       	rjmp	.+42     	; 0x892 <vTaskDelayUntil+0xa6>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
     868:	8d 81       	ldd	r24, Y+5	; 0x05
     86a:	9e 81       	ldd	r25, Y+6	; 0x06
     86c:	fc 01       	movw	r30, r24
     86e:	20 81       	ld	r18, Z
     870:	31 81       	ldd	r19, Z+1	; 0x01
     872:	8a 81       	ldd	r24, Y+2	; 0x02
     874:	9b 81       	ldd	r25, Y+3	; 0x03
     876:	82 17       	cp	r24, r18
     878:	93 07       	cpc	r25, r19
     87a:	48 f0       	brcs	.+18     	; 0x88e <vTaskDelayUntil+0xa2>
     87c:	80 91 7d 02 	lds	r24, 0x027D
     880:	90 91 7e 02 	lds	r25, 0x027E
     884:	2a 81       	ldd	r18, Y+2	; 0x02
     886:	3b 81       	ldd	r19, Y+3	; 0x03
     888:	82 17       	cp	r24, r18
     88a:	93 07       	cpc	r25, r19
     88c:	10 f4       	brcc	.+4      	; 0x892 <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
     88e:	81 e0       	ldi	r24, 0x01	; 1
     890:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     892:	8d 81       	ldd	r24, Y+5	; 0x05
     894:	9e 81       	ldd	r25, Y+6	; 0x06
     896:	2a 81       	ldd	r18, Y+2	; 0x02
     898:	3b 81       	ldd	r19, Y+3	; 0x03
     89a:	fc 01       	movw	r30, r24
     89c:	31 83       	std	Z+1, r19	; 0x01
     89e:	20 83       	st	Z, r18

			if( xShouldDelay != pdFALSE )
     8a0:	89 81       	ldd	r24, Y+1	; 0x01
     8a2:	88 23       	and	r24, r24
     8a4:	59 f0       	breq	.+22     	; 0x8bc <vTaskDelayUntil+0xd0>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
     8a6:	80 91 2e 02 	lds	r24, 0x022E
     8aa:	90 91 2f 02 	lds	r25, 0x022F
     8ae:	02 96       	adiw	r24, 0x02	; 2
     8b0:	0e 94 22 13 	call	0x2644	; 0x2644 <uxListRemove>
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
     8b4:	8a 81       	ldd	r24, Y+2	; 0x02
     8b6:	9b 81       	ldd	r25, Y+3	; 0x03
     8b8:	0e 94 6d 0a 	call	0x14da	; 0x14da <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     8bc:	0e 94 4f 06 	call	0xc9e	; 0xc9e <xTaskResumeAll>
     8c0:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     8c2:	8c 81       	ldd	r24, Y+4	; 0x04
     8c4:	88 23       	and	r24, r24
     8c6:	11 f4       	brne	.+4      	; 0x8cc <vTaskDelayUntil+0xe0>
		{
			portYIELD_WITHIN_API();
     8c8:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <vPortYield>
		}
	}
     8cc:	28 96       	adiw	r28, 0x08	; 8
     8ce:	0f b6       	in	r0, 0x3f	; 63
     8d0:	f8 94       	cli
     8d2:	de bf       	out	0x3e, r29	; 62
     8d4:	0f be       	out	0x3f, r0	; 63
     8d6:	cd bf       	out	0x3d, r28	; 61
     8d8:	df 91       	pop	r29
     8da:	cf 91       	pop	r28
     8dc:	08 95       	ret

000008de <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
     8de:	cf 93       	push	r28
     8e0:	df 93       	push	r29
     8e2:	00 d0       	rcall	.+0      	; 0x8e4 <vTaskDelay+0x6>
     8e4:	1f 92       	push	r1
     8e6:	1f 92       	push	r1
     8e8:	cd b7       	in	r28, 0x3d	; 61
     8ea:	de b7       	in	r29, 0x3e	; 62
     8ec:	9d 83       	std	Y+5, r25	; 0x05
     8ee:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
     8f0:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
     8f2:	8c 81       	ldd	r24, Y+4	; 0x04
     8f4:	9d 81       	ldd	r25, Y+5	; 0x05
     8f6:	00 97       	sbiw	r24, 0x00	; 0
     8f8:	d1 f0       	breq	.+52     	; 0x92e <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
     8fa:	0e 94 43 06 	call	0xc86	; 0xc86 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
     8fe:	20 91 7d 02 	lds	r18, 0x027D
     902:	30 91 7e 02 	lds	r19, 0x027E
     906:	8c 81       	ldd	r24, Y+4	; 0x04
     908:	9d 81       	ldd	r25, Y+5	; 0x05
     90a:	82 0f       	add	r24, r18
     90c:	93 1f       	adc	r25, r19
     90e:	9b 83       	std	Y+3, r25	; 0x03
     910:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
     912:	80 91 2e 02 	lds	r24, 0x022E
     916:	90 91 2f 02 	lds	r25, 0x022F
     91a:	02 96       	adiw	r24, 0x02	; 2
     91c:	0e 94 22 13 	call	0x2644	; 0x2644 <uxListRemove>
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
     920:	8a 81       	ldd	r24, Y+2	; 0x02
     922:	9b 81       	ldd	r25, Y+3	; 0x03
     924:	0e 94 6d 0a 	call	0x14da	; 0x14da <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     928:	0e 94 4f 06 	call	0xc9e	; 0xc9e <xTaskResumeAll>
     92c:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     92e:	89 81       	ldd	r24, Y+1	; 0x01
     930:	88 23       	and	r24, r24
     932:	11 f4       	brne	.+4      	; 0x938 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
     934:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <vPortYield>
		}
	}
     938:	0f 90       	pop	r0
     93a:	0f 90       	pop	r0
     93c:	0f 90       	pop	r0
     93e:	0f 90       	pop	r0
     940:	0f 90       	pop	r0
     942:	df 91       	pop	r29
     944:	cf 91       	pop	r28
     946:	08 95       	ret

00000948 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
     948:	cf 93       	push	r28
     94a:	df 93       	push	r29
     94c:	00 d0       	rcall	.+0      	; 0x94e <vTaskSuspend+0x6>
     94e:	1f 92       	push	r1
     950:	cd b7       	in	r28, 0x3d	; 61
     952:	de b7       	in	r29, 0x3e	; 62
     954:	9c 83       	std	Y+4, r25	; 0x04
     956:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
     958:	0f b6       	in	r0, 0x3f	; 63
     95a:	f8 94       	cli
     95c:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
     95e:	80 91 2e 02 	lds	r24, 0x022E
     962:	90 91 2f 02 	lds	r25, 0x022F
     966:	2b 81       	ldd	r18, Y+3	; 0x03
     968:	3c 81       	ldd	r19, Y+4	; 0x04
     96a:	28 17       	cp	r18, r24
     96c:	39 07       	cpc	r19, r25
     96e:	11 f4       	brne	.+4      	; 0x974 <vTaskSuspend+0x2c>
			{
				pxTaskToSuspend = NULL;
     970:	1c 82       	std	Y+4, r1	; 0x04
     972:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
     974:	8b 81       	ldd	r24, Y+3	; 0x03
     976:	9c 81       	ldd	r25, Y+4	; 0x04
     978:	00 97       	sbiw	r24, 0x00	; 0
     97a:	29 f4       	brne	.+10     	; 0x986 <vTaskSuspend+0x3e>
     97c:	80 91 2e 02 	lds	r24, 0x022E
     980:	90 91 2f 02 	lds	r25, 0x022F
     984:	02 c0       	rjmp	.+4      	; 0x98a <vTaskSuspend+0x42>
     986:	8b 81       	ldd	r24, Y+3	; 0x03
     988:	9c 81       	ldd	r25, Y+4	; 0x04
     98a:	9a 83       	std	Y+2, r25	; 0x02
     98c:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
     98e:	89 81       	ldd	r24, Y+1	; 0x01
     990:	9a 81       	ldd	r25, Y+2	; 0x02
     992:	02 96       	adiw	r24, 0x02	; 2
     994:	0e 94 22 13 	call	0x2644	; 0x2644 <uxListRemove>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
			}

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
     998:	89 81       	ldd	r24, Y+1	; 0x01
     99a:	9a 81       	ldd	r25, Y+2	; 0x02
     99c:	fc 01       	movw	r30, r24
     99e:	84 89       	ldd	r24, Z+20	; 0x14
     9a0:	95 89       	ldd	r25, Z+21	; 0x15
     9a2:	00 97       	sbiw	r24, 0x00	; 0
     9a4:	29 f0       	breq	.+10     	; 0x9b0 <vTaskSuspend+0x68>
			{
				uxListRemove( &( pxTCB->xEventListItem ) );
     9a6:	89 81       	ldd	r24, Y+1	; 0x01
     9a8:	9a 81       	ldd	r25, Y+2	; 0x02
     9aa:	0c 96       	adiw	r24, 0x0c	; 12
     9ac:	0e 94 22 13 	call	0x2644	; 0x2644 <uxListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
     9b0:	89 81       	ldd	r24, Y+1	; 0x01
     9b2:	9a 81       	ldd	r25, Y+2	; 0x02
     9b4:	02 96       	adiw	r24, 0x02	; 2
     9b6:	bc 01       	movw	r22, r24
     9b8:	83 e7       	ldi	r24, 0x73	; 115
     9ba:	92 e0       	ldi	r25, 0x02	; 2
     9bc:	0e 94 52 12 	call	0x24a4	; 0x24a4 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
     9c0:	0f 90       	pop	r0
     9c2:	0f be       	out	0x3f, r0	; 63

		if( ( void * ) pxTaskToSuspend == NULL )
     9c4:	8b 81       	ldd	r24, Y+3	; 0x03
     9c6:	9c 81       	ldd	r25, Y+4	; 0x04
     9c8:	00 97       	sbiw	r24, 0x00	; 0
     9ca:	a1 f4       	brne	.+40     	; 0x9f4 <vTaskSuspend+0xac>
		{
			if( xSchedulerRunning != pdFALSE )
     9cc:	80 91 81 02 	lds	r24, 0x0281
     9d0:	88 23       	and	r24, r24
     9d2:	19 f0       	breq	.+6      	; 0x9da <vTaskSuspend+0x92>
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
     9d4:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <vPortYield>
     9d8:	0d c0       	rjmp	.+26     	; 0x9f4 <vTaskSuspend+0xac>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
     9da:	90 91 73 02 	lds	r25, 0x0273
     9de:	80 91 7c 02 	lds	r24, 0x027C
     9e2:	98 17       	cp	r25, r24
     9e4:	29 f4       	brne	.+10     	; 0x9f0 <vTaskSuspend+0xa8>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
     9e6:	10 92 2f 02 	sts	0x022F, r1
     9ea:	10 92 2e 02 	sts	0x022E, r1
     9ee:	02 c0       	rjmp	.+4      	; 0x9f4 <vTaskSuspend+0xac>
				}
				else
				{
					vTaskSwitchContext();
     9f0:	0e 94 e5 07 	call	0xfca	; 0xfca <vTaskSwitchContext>
				}
			}
		}
	}
     9f4:	0f 90       	pop	r0
     9f6:	0f 90       	pop	r0
     9f8:	0f 90       	pop	r0
     9fa:	0f 90       	pop	r0
     9fc:	df 91       	pop	r29
     9fe:	cf 91       	pop	r28
     a00:	08 95       	ret

00000a02 <xTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
     a02:	cf 93       	push	r28
     a04:	df 93       	push	r29
     a06:	00 d0       	rcall	.+0      	; 0xa08 <xTaskIsTaskSuspended+0x6>
     a08:	1f 92       	push	r1
     a0a:	1f 92       	push	r1
     a0c:	cd b7       	in	r28, 0x3d	; 61
     a0e:	de b7       	in	r29, 0x3e	; 62
     a10:	9d 83       	std	Y+5, r25	; 0x05
     a12:	8c 83       	std	Y+4, r24	; 0x04
	portBASE_TYPE xReturn = pdFALSE;
     a14:	19 82       	std	Y+1, r1	; 0x01
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
     a16:	8c 81       	ldd	r24, Y+4	; 0x04
     a18:	9d 81       	ldd	r25, Y+5	; 0x05
     a1a:	9b 83       	std	Y+3, r25	; 0x03
     a1c:	8a 83       	std	Y+2, r24	; 0x02
		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
     a1e:	8a 81       	ldd	r24, Y+2	; 0x02
     a20:	9b 81       	ldd	r25, Y+3	; 0x03
     a22:	fc 01       	movw	r30, r24
     a24:	82 85       	ldd	r24, Z+10	; 0x0a
     a26:	93 85       	ldd	r25, Z+11	; 0x0b
     a28:	f2 e0       	ldi	r31, 0x02	; 2
     a2a:	83 37       	cpi	r24, 0x73	; 115
     a2c:	9f 07       	cpc	r25, r31
     a2e:	91 f4       	brne	.+36     	; 0xa54 <xTaskIsTaskSuspended+0x52>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
     a30:	8a 81       	ldd	r24, Y+2	; 0x02
     a32:	9b 81       	ldd	r25, Y+3	; 0x03
     a34:	fc 01       	movw	r30, r24
     a36:	84 89       	ldd	r24, Z+20	; 0x14
     a38:	95 89       	ldd	r25, Z+21	; 0x15
     a3a:	f2 e0       	ldi	r31, 0x02	; 2
     a3c:	8a 36       	cpi	r24, 0x6A	; 106
     a3e:	9f 07       	cpc	r25, r31
     a40:	49 f0       	breq	.+18     	; 0xa54 <xTaskIsTaskSuspended+0x52>
			{
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
     a42:	8a 81       	ldd	r24, Y+2	; 0x02
     a44:	9b 81       	ldd	r25, Y+3	; 0x03
     a46:	fc 01       	movw	r30, r24
     a48:	84 89       	ldd	r24, Z+20	; 0x14
     a4a:	95 89       	ldd	r25, Z+21	; 0x15
     a4c:	00 97       	sbiw	r24, 0x00	; 0
     a4e:	11 f4       	brne	.+4      	; 0xa54 <xTaskIsTaskSuspended+0x52>
				{
					xReturn = pdTRUE;
     a50:	81 e0       	ldi	r24, 0x01	; 1
     a52:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}

		return xReturn;
     a54:	89 81       	ldd	r24, Y+1	; 0x01
	}
     a56:	0f 90       	pop	r0
     a58:	0f 90       	pop	r0
     a5a:	0f 90       	pop	r0
     a5c:	0f 90       	pop	r0
     a5e:	0f 90       	pop	r0
     a60:	df 91       	pop	r29
     a62:	cf 91       	pop	r28
     a64:	08 95       	ret

00000a66 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
     a66:	cf 93       	push	r28
     a68:	df 93       	push	r29
     a6a:	00 d0       	rcall	.+0      	; 0xa6c <vTaskResume+0x6>
     a6c:	1f 92       	push	r1
     a6e:	cd b7       	in	r28, 0x3d	; 61
     a70:	de b7       	in	r29, 0x3e	; 62
     a72:	9c 83       	std	Y+4, r25	; 0x04
     a74:	8b 83       	std	Y+3, r24	; 0x03
		/* It does not make sense to resume the calling task. */
		configASSERT( pxTaskToResume );

		/* Remove the task from whichever list it is currently in, and place
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;
     a76:	8b 81       	ldd	r24, Y+3	; 0x03
     a78:	9c 81       	ldd	r25, Y+4	; 0x04
     a7a:	9a 83       	std	Y+2, r25	; 0x02
     a7c:	89 83       	std	Y+1, r24	; 0x01

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
     a7e:	89 81       	ldd	r24, Y+1	; 0x01
     a80:	9a 81       	ldd	r25, Y+2	; 0x02
     a82:	00 97       	sbiw	r24, 0x00	; 0
     a84:	09 f4       	brne	.+2      	; 0xa88 <vTaskResume+0x22>
     a86:	4f c0       	rjmp	.+158    	; 0xb26 <vTaskResume+0xc0>
     a88:	80 91 2e 02 	lds	r24, 0x022E
     a8c:	90 91 2f 02 	lds	r25, 0x022F
     a90:	29 81       	ldd	r18, Y+1	; 0x01
     a92:	3a 81       	ldd	r19, Y+2	; 0x02
     a94:	28 17       	cp	r18, r24
     a96:	39 07       	cpc	r19, r25
     a98:	09 f4       	brne	.+2      	; 0xa9c <vTaskResume+0x36>
     a9a:	45 c0       	rjmp	.+138    	; 0xb26 <vTaskResume+0xc0>
		{
			taskENTER_CRITICAL();
     a9c:	0f b6       	in	r0, 0x3f	; 63
     a9e:	f8 94       	cli
     aa0:	0f 92       	push	r0
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
     aa2:	89 81       	ldd	r24, Y+1	; 0x01
     aa4:	9a 81       	ldd	r25, Y+2	; 0x02
     aa6:	0e 94 01 05 	call	0xa02	; 0xa02 <xTaskIsTaskSuspended>
     aaa:	81 30       	cpi	r24, 0x01	; 1
     aac:	d1 f5       	brne	.+116    	; 0xb22 <vTaskResume+0xbc>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					uxListRemove(  &( pxTCB->xGenericListItem ) );
     aae:	89 81       	ldd	r24, Y+1	; 0x01
     ab0:	9a 81       	ldd	r25, Y+2	; 0x02
     ab2:	02 96       	adiw	r24, 0x02	; 2
     ab4:	0e 94 22 13 	call	0x2644	; 0x2644 <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
     ab8:	89 81       	ldd	r24, Y+1	; 0x01
     aba:	9a 81       	ldd	r25, Y+2	; 0x02
     abc:	fc 01       	movw	r30, r24
     abe:	96 89       	ldd	r25, Z+22	; 0x16
     ac0:	80 91 80 02 	lds	r24, 0x0280
     ac4:	89 17       	cp	r24, r25
     ac6:	30 f4       	brcc	.+12     	; 0xad4 <vTaskResume+0x6e>
     ac8:	89 81       	ldd	r24, Y+1	; 0x01
     aca:	9a 81       	ldd	r25, Y+2	; 0x02
     acc:	fc 01       	movw	r30, r24
     ace:	86 89       	ldd	r24, Z+22	; 0x16
     ad0:	80 93 80 02 	sts	0x0280, r24
     ad4:	89 81       	ldd	r24, Y+1	; 0x01
     ad6:	9a 81       	ldd	r25, Y+2	; 0x02
     ad8:	ac 01       	movw	r20, r24
     ada:	4e 5f       	subi	r20, 0xFE	; 254
     adc:	5f 4f       	sbci	r21, 0xFF	; 255
     ade:	89 81       	ldd	r24, Y+1	; 0x01
     ae0:	9a 81       	ldd	r25, Y+2	; 0x02
     ae2:	fc 01       	movw	r30, r24
     ae4:	86 89       	ldd	r24, Z+22	; 0x16
     ae6:	28 2f       	mov	r18, r24
     ae8:	30 e0       	ldi	r19, 0x00	; 0
     aea:	c9 01       	movw	r24, r18
     aec:	88 0f       	add	r24, r24
     aee:	99 1f       	adc	r25, r25
     af0:	88 0f       	add	r24, r24
     af2:	99 1f       	adc	r25, r25
     af4:	88 0f       	add	r24, r24
     af6:	99 1f       	adc	r25, r25
     af8:	82 0f       	add	r24, r18
     afa:	93 1f       	adc	r25, r19
     afc:	80 5d       	subi	r24, 0xD0	; 208
     afe:	9d 4f       	sbci	r25, 0xFD	; 253
     b00:	ba 01       	movw	r22, r20
     b02:	0e 94 52 12 	call	0x24a4	; 0x24a4 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     b06:	89 81       	ldd	r24, Y+1	; 0x01
     b08:	9a 81       	ldd	r25, Y+2	; 0x02
     b0a:	fc 01       	movw	r30, r24
     b0c:	26 89       	ldd	r18, Z+22	; 0x16
     b0e:	80 91 2e 02 	lds	r24, 0x022E
     b12:	90 91 2f 02 	lds	r25, 0x022F
     b16:	fc 01       	movw	r30, r24
     b18:	86 89       	ldd	r24, Z+22	; 0x16
     b1a:	28 17       	cp	r18, r24
     b1c:	10 f0       	brcs	.+4      	; 0xb22 <vTaskResume+0xbc>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
     b1e:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <vPortYield>
					}
				}
			}
			taskEXIT_CRITICAL();
     b22:	0f 90       	pop	r0
     b24:	0f be       	out	0x3f, r0	; 63
		}
	}
     b26:	0f 90       	pop	r0
     b28:	0f 90       	pop	r0
     b2a:	0f 90       	pop	r0
     b2c:	0f 90       	pop	r0
     b2e:	df 91       	pop	r29
     b30:	cf 91       	pop	r28
     b32:	08 95       	ret

00000b34 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
     b34:	cf 93       	push	r28
     b36:	df 93       	push	r29
     b38:	00 d0       	rcall	.+0      	; 0xb3a <xTaskResumeFromISR+0x6>
     b3a:	00 d0       	rcall	.+0      	; 0xb3c <xTaskResumeFromISR+0x8>
     b3c:	cd b7       	in	r28, 0x3d	; 61
     b3e:	de b7       	in	r29, 0x3e	; 62
     b40:	9e 83       	std	Y+6, r25	; 0x06
     b42:	8d 83       	std	Y+5, r24	; 0x05
	portBASE_TYPE xYieldRequired = pdFALSE;
     b44:	19 82       	std	Y+1, r1	; 0x01
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxSavedInterruptStatus;

		configASSERT( pxTaskToResume );

		pxTCB = ( tskTCB * ) pxTaskToResume;
     b46:	8d 81       	ldd	r24, Y+5	; 0x05
     b48:	9e 81       	ldd	r25, Y+6	; 0x06
     b4a:	9b 83       	std	Y+3, r25	; 0x03
     b4c:	8a 83       	std	Y+2, r24	; 0x02

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     b4e:	1c 82       	std	Y+4, r1	; 0x04
		{
			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
     b50:	8a 81       	ldd	r24, Y+2	; 0x02
     b52:	9b 81       	ldd	r25, Y+3	; 0x03
     b54:	0e 94 01 05 	call	0xa02	; 0xa02 <xTaskIsTaskSuspended>
     b58:	81 30       	cpi	r24, 0x01	; 1
     b5a:	09 f0       	breq	.+2      	; 0xb5e <xTaskResumeFromISR+0x2a>
     b5c:	48 c0       	rjmp	.+144    	; 0xbee <xTaskResumeFromISR+0xba>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     b5e:	80 91 82 02 	lds	r24, 0x0282
     b62:	88 23       	and	r24, r24
     b64:	e1 f5       	brne	.+120    	; 0xbde <xTaskResumeFromISR+0xaa>
				{
					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
     b66:	8a 81       	ldd	r24, Y+2	; 0x02
     b68:	9b 81       	ldd	r25, Y+3	; 0x03
     b6a:	fc 01       	movw	r30, r24
     b6c:	26 89       	ldd	r18, Z+22	; 0x16
     b6e:	80 91 2e 02 	lds	r24, 0x022E
     b72:	90 91 2f 02 	lds	r25, 0x022F
     b76:	fc 01       	movw	r30, r24
     b78:	96 89       	ldd	r25, Z+22	; 0x16
     b7a:	81 e0       	ldi	r24, 0x01	; 1
     b7c:	29 17       	cp	r18, r25
     b7e:	08 f4       	brcc	.+2      	; 0xb82 <xTaskResumeFromISR+0x4e>
     b80:	80 e0       	ldi	r24, 0x00	; 0
     b82:	89 83       	std	Y+1, r24	; 0x01
					uxListRemove(  &( pxTCB->xGenericListItem ) );
     b84:	8a 81       	ldd	r24, Y+2	; 0x02
     b86:	9b 81       	ldd	r25, Y+3	; 0x03
     b88:	02 96       	adiw	r24, 0x02	; 2
     b8a:	0e 94 22 13 	call	0x2644	; 0x2644 <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
     b8e:	8a 81       	ldd	r24, Y+2	; 0x02
     b90:	9b 81       	ldd	r25, Y+3	; 0x03
     b92:	fc 01       	movw	r30, r24
     b94:	96 89       	ldd	r25, Z+22	; 0x16
     b96:	80 91 80 02 	lds	r24, 0x0280
     b9a:	89 17       	cp	r24, r25
     b9c:	30 f4       	brcc	.+12     	; 0xbaa <xTaskResumeFromISR+0x76>
     b9e:	8a 81       	ldd	r24, Y+2	; 0x02
     ba0:	9b 81       	ldd	r25, Y+3	; 0x03
     ba2:	fc 01       	movw	r30, r24
     ba4:	86 89       	ldd	r24, Z+22	; 0x16
     ba6:	80 93 80 02 	sts	0x0280, r24
     baa:	8a 81       	ldd	r24, Y+2	; 0x02
     bac:	9b 81       	ldd	r25, Y+3	; 0x03
     bae:	ac 01       	movw	r20, r24
     bb0:	4e 5f       	subi	r20, 0xFE	; 254
     bb2:	5f 4f       	sbci	r21, 0xFF	; 255
     bb4:	8a 81       	ldd	r24, Y+2	; 0x02
     bb6:	9b 81       	ldd	r25, Y+3	; 0x03
     bb8:	fc 01       	movw	r30, r24
     bba:	86 89       	ldd	r24, Z+22	; 0x16
     bbc:	28 2f       	mov	r18, r24
     bbe:	30 e0       	ldi	r19, 0x00	; 0
     bc0:	c9 01       	movw	r24, r18
     bc2:	88 0f       	add	r24, r24
     bc4:	99 1f       	adc	r25, r25
     bc6:	88 0f       	add	r24, r24
     bc8:	99 1f       	adc	r25, r25
     bca:	88 0f       	add	r24, r24
     bcc:	99 1f       	adc	r25, r25
     bce:	82 0f       	add	r24, r18
     bd0:	93 1f       	adc	r25, r19
     bd2:	80 5d       	subi	r24, 0xD0	; 208
     bd4:	9d 4f       	sbci	r25, 0xFD	; 253
     bd6:	ba 01       	movw	r22, r20
     bd8:	0e 94 52 12 	call	0x24a4	; 0x24a4 <vListInsertEnd>
     bdc:	08 c0       	rjmp	.+16     	; 0xbee <xTaskResumeFromISR+0xba>
				else
				{
					/* We cannot access the delayed or ready lists, so will hold this
					task pending until the scheduler is resumed, at which point a
					yield will be performed if necessary. */
					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
     bde:	8a 81       	ldd	r24, Y+2	; 0x02
     be0:	9b 81       	ldd	r25, Y+3	; 0x03
     be2:	0c 96       	adiw	r24, 0x0c	; 12
     be4:	bc 01       	movw	r22, r24
     be6:	8a e6       	ldi	r24, 0x6A	; 106
     be8:	92 e0       	ldi	r25, 0x02	; 2
     bea:	0e 94 52 12 	call	0x24a4	; 0x24a4 <vListInsertEnd>
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
     bee:	89 81       	ldd	r24, Y+1	; 0x01
	}
     bf0:	26 96       	adiw	r28, 0x06	; 6
     bf2:	0f b6       	in	r0, 0x3f	; 63
     bf4:	f8 94       	cli
     bf6:	de bf       	out	0x3e, r29	; 62
     bf8:	0f be       	out	0x3f, r0	; 63
     bfa:	cd bf       	out	0x3d, r28	; 61
     bfc:	df 91       	pop	r29
     bfe:	cf 91       	pop	r28
     c00:	08 95       	ret

00000c02 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
     c02:	af 92       	push	r10
     c04:	bf 92       	push	r11
     c06:	cf 92       	push	r12
     c08:	df 92       	push	r13
     c0a:	ef 92       	push	r14
     c0c:	ff 92       	push	r15
     c0e:	0f 93       	push	r16
     c10:	cf 93       	push	r28
     c12:	df 93       	push	r29
     c14:	1f 92       	push	r1
     c16:	cd b7       	in	r28, 0x3d	; 61
     c18:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
     c1a:	a1 2c       	mov	r10, r1
     c1c:	b1 2c       	mov	r11, r1
     c1e:	c1 2c       	mov	r12, r1
     c20:	d1 2c       	mov	r13, r1
     c22:	e1 2c       	mov	r14, r1
     c24:	f1 2c       	mov	r15, r1
     c26:	00 e0       	ldi	r16, 0x00	; 0
     c28:	20 e0       	ldi	r18, 0x00	; 0
     c2a:	30 e0       	ldi	r19, 0x00	; 0
     c2c:	45 e5       	ldi	r20, 0x55	; 85
     c2e:	50 e0       	ldi	r21, 0x00	; 0
     c30:	6e e1       	ldi	r22, 0x1E	; 30
     c32:	72 e0       	ldi	r23, 0x02	; 2
     c34:	86 eb       	ldi	r24, 0xB6	; 182
     c36:	99 e0       	ldi	r25, 0x09	; 9
     c38:	0e 94 02 03 	call	0x604	; 0x604 <xTaskGenericCreate>
     c3c:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
     c3e:	89 81       	ldd	r24, Y+1	; 0x01
     c40:	81 30       	cpi	r24, 0x01	; 1
     c42:	51 f4       	brne	.+20     	; 0xc58 <vTaskStartScheduler+0x56>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
     c44:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
     c46:	81 e0       	ldi	r24, 0x01	; 1
     c48:	80 93 81 02 	sts	0x0281, r24
		xTickCount = ( portTickType ) 0U;
     c4c:	10 92 7e 02 	sts	0x027E, r1
     c50:	10 92 7d 02 	sts	0x027D, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     c54:	0e 94 a4 18 	call	0x3148	; 0x3148 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
     c58:	0f 90       	pop	r0
     c5a:	df 91       	pop	r29
     c5c:	cf 91       	pop	r28
     c5e:	0f 91       	pop	r16
     c60:	ff 90       	pop	r15
     c62:	ef 90       	pop	r14
     c64:	df 90       	pop	r13
     c66:	cf 90       	pop	r12
     c68:	bf 90       	pop	r11
     c6a:	af 90       	pop	r10
     c6c:	08 95       	ret

00000c6e <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
     c6e:	cf 93       	push	r28
     c70:	df 93       	push	r29
     c72:	cd b7       	in	r28, 0x3d	; 61
     c74:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
     c76:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
     c78:	10 92 81 02 	sts	0x0281, r1
	vPortEndScheduler();
     c7c:	0e 94 dd 18 	call	0x31ba	; 0x31ba <vPortEndScheduler>
}
     c80:	df 91       	pop	r29
     c82:	cf 91       	pop	r28
     c84:	08 95       	ret

00000c86 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
     c86:	cf 93       	push	r28
     c88:	df 93       	push	r29
     c8a:	cd b7       	in	r28, 0x3d	; 61
     c8c:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
     c8e:	80 91 82 02 	lds	r24, 0x0282
     c92:	8f 5f       	subi	r24, 0xFF	; 255
     c94:	80 93 82 02 	sts	0x0282, r24
}
     c98:	df 91       	pop	r29
     c9a:	cf 91       	pop	r28
     c9c:	08 95       	ret

00000c9e <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE != 0  */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
     c9e:	0f 93       	push	r16
     ca0:	1f 93       	push	r17
     ca2:	cf 93       	push	r28
     ca4:	df 93       	push	r29
     ca6:	1f 92       	push	r1
     ca8:	1f 92       	push	r1
     caa:	cd b7       	in	r28, 0x3d	; 61
     cac:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
     cae:	19 82       	std	Y+1, r1	; 0x01
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     cb0:	0f b6       	in	r0, 0x3f	; 63
     cb2:	f8 94       	cli
     cb4:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     cb6:	80 91 82 02 	lds	r24, 0x0282
     cba:	81 50       	subi	r24, 0x01	; 1
     cbc:	80 93 82 02 	sts	0x0282, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     cc0:	80 91 82 02 	lds	r24, 0x0282
     cc4:	88 23       	and	r24, r24
     cc6:	09 f0       	breq	.+2      	; 0xcca <xTaskResumeAll+0x2c>
     cc8:	64 c0       	rjmp	.+200    	; 0xd92 <xTaskResumeAll+0xf4>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
     cca:	80 91 7c 02 	lds	r24, 0x027C
     cce:	88 23       	and	r24, r24
     cd0:	09 f4       	brne	.+2      	; 0xcd4 <xTaskResumeAll+0x36>
     cd2:	5f c0       	rjmp	.+190    	; 0xd92 <xTaskResumeAll+0xf4>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
     cd4:	1a 82       	std	Y+2, r1	; 0x02

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
     cd6:	3a c0       	rjmp	.+116    	; 0xd4c <xTaskResumeAll+0xae>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
     cd8:	80 91 6f 02 	lds	r24, 0x026F
     cdc:	90 91 70 02 	lds	r25, 0x0270
     ce0:	fc 01       	movw	r30, r24
     ce2:	06 81       	ldd	r16, Z+6	; 0x06
     ce4:	17 81       	ldd	r17, Z+7	; 0x07
					uxListRemove( &( pxTCB->xEventListItem ) );
     ce6:	c8 01       	movw	r24, r16
     ce8:	0c 96       	adiw	r24, 0x0c	; 12
     cea:	0e 94 22 13 	call	0x2644	; 0x2644 <uxListRemove>
					uxListRemove( &( pxTCB->xGenericListItem ) );
     cee:	c8 01       	movw	r24, r16
     cf0:	02 96       	adiw	r24, 0x02	; 2
     cf2:	0e 94 22 13 	call	0x2644	; 0x2644 <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
     cf6:	f8 01       	movw	r30, r16
     cf8:	96 89       	ldd	r25, Z+22	; 0x16
     cfa:	80 91 80 02 	lds	r24, 0x0280
     cfe:	89 17       	cp	r24, r25
     d00:	20 f4       	brcc	.+8      	; 0xd0a <xTaskResumeAll+0x6c>
     d02:	f8 01       	movw	r30, r16
     d04:	86 89       	ldd	r24, Z+22	; 0x16
     d06:	80 93 80 02 	sts	0x0280, r24
     d0a:	a8 01       	movw	r20, r16
     d0c:	4e 5f       	subi	r20, 0xFE	; 254
     d0e:	5f 4f       	sbci	r21, 0xFF	; 255
     d10:	f8 01       	movw	r30, r16
     d12:	86 89       	ldd	r24, Z+22	; 0x16
     d14:	28 2f       	mov	r18, r24
     d16:	30 e0       	ldi	r19, 0x00	; 0
     d18:	c9 01       	movw	r24, r18
     d1a:	88 0f       	add	r24, r24
     d1c:	99 1f       	adc	r25, r25
     d1e:	88 0f       	add	r24, r24
     d20:	99 1f       	adc	r25, r25
     d22:	88 0f       	add	r24, r24
     d24:	99 1f       	adc	r25, r25
     d26:	82 0f       	add	r24, r18
     d28:	93 1f       	adc	r25, r19
     d2a:	80 5d       	subi	r24, 0xD0	; 208
     d2c:	9d 4f       	sbci	r25, 0xFD	; 253
     d2e:	ba 01       	movw	r22, r20
     d30:	0e 94 52 12 	call	0x24a4	; 0x24a4 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     d34:	f8 01       	movw	r30, r16
     d36:	26 89       	ldd	r18, Z+22	; 0x16
     d38:	80 91 2e 02 	lds	r24, 0x022E
     d3c:	90 91 2f 02 	lds	r25, 0x022F
     d40:	fc 01       	movw	r30, r24
     d42:	86 89       	ldd	r24, Z+22	; 0x16
     d44:	28 17       	cp	r18, r24
     d46:	10 f0       	brcs	.+4      	; 0xd4c <xTaskResumeAll+0xae>
					{
						xYieldRequired = pdTRUE;
     d48:	81 e0       	ldi	r24, 0x01	; 1
     d4a:	8a 83       	std	Y+2, r24	; 0x02
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
     d4c:	80 91 6a 02 	lds	r24, 0x026A
     d50:	88 23       	and	r24, r24
     d52:	11 f6       	brne	.-124    	; 0xcd8 <xTaskResumeAll+0x3a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
     d54:	80 91 83 02 	lds	r24, 0x0283
     d58:	88 23       	and	r24, r24
     d5a:	71 f0       	breq	.+28     	; 0xd78 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
     d5c:	07 c0       	rjmp	.+14     	; 0xd6c <xTaskResumeAll+0xce>
					{
						vTaskIncrementTick();
     d5e:	0e 94 08 07 	call	0xe10	; 0xe10 <vTaskIncrementTick>
						--uxMissedTicks;
     d62:	80 91 83 02 	lds	r24, 0x0283
     d66:	81 50       	subi	r24, 0x01	; 1
     d68:	80 93 83 02 	sts	0x0283, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
     d6c:	80 91 83 02 	lds	r24, 0x0283
     d70:	88 23       	and	r24, r24
     d72:	a9 f7       	brne	.-22     	; 0xd5e <xTaskResumeAll+0xc0>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
     d74:	81 e0       	ldi	r24, 0x01	; 1
     d76:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
     d78:	8a 81       	ldd	r24, Y+2	; 0x02
     d7a:	81 30       	cpi	r24, 0x01	; 1
     d7c:	21 f0       	breq	.+8      	; 0xd86 <xTaskResumeAll+0xe8>
     d7e:	80 91 84 02 	lds	r24, 0x0284
     d82:	81 30       	cpi	r24, 0x01	; 1
     d84:	31 f4       	brne	.+12     	; 0xd92 <xTaskResumeAll+0xf4>
				{
					xAlreadyYielded = pdTRUE;
     d86:	81 e0       	ldi	r24, 0x01	; 1
     d88:	89 83       	std	Y+1, r24	; 0x01
					xMissedYield = pdFALSE;
     d8a:	10 92 84 02 	sts	0x0284, r1
					portYIELD_WITHIN_API();
     d8e:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
     d92:	0f 90       	pop	r0
     d94:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
     d96:	89 81       	ldd	r24, Y+1	; 0x01
}
     d98:	0f 90       	pop	r0
     d9a:	0f 90       	pop	r0
     d9c:	df 91       	pop	r29
     d9e:	cf 91       	pop	r28
     da0:	1f 91       	pop	r17
     da2:	0f 91       	pop	r16
     da4:	08 95       	ret

00000da6 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
     da6:	cf 93       	push	r28
     da8:	df 93       	push	r29
     daa:	1f 92       	push	r1
     dac:	1f 92       	push	r1
     dae:	cd b7       	in	r28, 0x3d	; 61
     db0:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
     db2:	0f b6       	in	r0, 0x3f	; 63
     db4:	f8 94       	cli
     db6:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     db8:	80 91 7d 02 	lds	r24, 0x027D
     dbc:	90 91 7e 02 	lds	r25, 0x027E
     dc0:	9a 83       	std	Y+2, r25	; 0x02
     dc2:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
     dc4:	0f 90       	pop	r0
     dc6:	0f be       	out	0x3f, r0	; 63

	return xTicks;
     dc8:	89 81       	ldd	r24, Y+1	; 0x01
     dca:	9a 81       	ldd	r25, Y+2	; 0x02
}
     dcc:	0f 90       	pop	r0
     dce:	0f 90       	pop	r0
     dd0:	df 91       	pop	r29
     dd2:	cf 91       	pop	r28
     dd4:	08 95       	ret

00000dd6 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
     dd6:	cf 93       	push	r28
     dd8:	df 93       	push	r29
     dda:	00 d0       	rcall	.+0      	; 0xddc <xTaskGetTickCountFromISR+0x6>
     ddc:	cd b7       	in	r28, 0x3d	; 61
     dde:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     de0:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
     de2:	80 91 7d 02 	lds	r24, 0x027D
     de6:	90 91 7e 02 	lds	r25, 0x027E
     dea:	9b 83       	std	Y+3, r25	; 0x03
     dec:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
     dee:	8a 81       	ldd	r24, Y+2	; 0x02
     df0:	9b 81       	ldd	r25, Y+3	; 0x03
}
     df2:	0f 90       	pop	r0
     df4:	0f 90       	pop	r0
     df6:	0f 90       	pop	r0
     df8:	df 91       	pop	r29
     dfa:	cf 91       	pop	r28
     dfc:	08 95       	ret

00000dfe <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
     dfe:	cf 93       	push	r28
     e00:	df 93       	push	r29
     e02:	cd b7       	in	r28, 0x3d	; 61
     e04:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
     e06:	80 91 7c 02 	lds	r24, 0x027C
}
     e0a:	df 91       	pop	r29
     e0c:	cf 91       	pop	r28
     e0e:	08 95       	ret

00000e10 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
     e10:	cf 93       	push	r28
     e12:	df 93       	push	r29
     e14:	00 d0       	rcall	.+0      	; 0xe16 <vTaskIncrementTick+0x6>
     e16:	00 d0       	rcall	.+0      	; 0xe18 <vTaskIncrementTick+0x8>
     e18:	cd b7       	in	r28, 0x3d	; 61
     e1a:	de b7       	in	r29, 0x3e	; 62

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     e1c:	80 91 82 02 	lds	r24, 0x0282
     e20:	88 23       	and	r24, r24
     e22:	09 f0       	breq	.+2      	; 0xe26 <vTaskIncrementTick+0x16>
     e24:	c4 c0       	rjmp	.+392    	; 0xfae <vTaskIncrementTick+0x19e>
	{
		++xTickCount;
     e26:	80 91 7d 02 	lds	r24, 0x027D
     e2a:	90 91 7e 02 	lds	r25, 0x027E
     e2e:	01 96       	adiw	r24, 0x01	; 1
     e30:	90 93 7e 02 	sts	0x027E, r25
     e34:	80 93 7d 02 	sts	0x027D, r24
		if( xTickCount == ( portTickType ) 0U )
     e38:	80 91 7d 02 	lds	r24, 0x027D
     e3c:	90 91 7e 02 	lds	r25, 0x027E
     e40:	00 97       	sbiw	r24, 0x00	; 0
     e42:	e9 f5       	brne	.+122    	; 0xebe <vTaskIncrementTick+0xae>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
     e44:	80 91 66 02 	lds	r24, 0x0266
     e48:	90 91 67 02 	lds	r25, 0x0267
     e4c:	9a 83       	std	Y+2, r25	; 0x02
     e4e:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedTaskList = pxOverflowDelayedTaskList;
     e50:	80 91 68 02 	lds	r24, 0x0268
     e54:	90 91 69 02 	lds	r25, 0x0269
     e58:	90 93 67 02 	sts	0x0267, r25
     e5c:	80 93 66 02 	sts	0x0266, r24
			pxOverflowDelayedTaskList = pxTemp;
     e60:	89 81       	ldd	r24, Y+1	; 0x01
     e62:	9a 81       	ldd	r25, Y+2	; 0x02
     e64:	90 93 69 02 	sts	0x0269, r25
     e68:	80 93 68 02 	sts	0x0268, r24
			xNumOfOverflows++;
     e6c:	80 91 85 02 	lds	r24, 0x0285
     e70:	8f 5f       	subi	r24, 0xFF	; 255
     e72:	80 93 85 02 	sts	0x0285, r24

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     e76:	80 91 66 02 	lds	r24, 0x0266
     e7a:	90 91 67 02 	lds	r25, 0x0267
     e7e:	fc 01       	movw	r30, r24
     e80:	80 81       	ld	r24, Z
     e82:	88 23       	and	r24, r24
     e84:	39 f4       	brne	.+14     	; 0xe94 <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
     e86:	8f ef       	ldi	r24, 0xFF	; 255
     e88:	9f ef       	ldi	r25, 0xFF	; 255
     e8a:	90 93 01 02 	sts	0x0201, r25
     e8e:	80 93 00 02 	sts	0x0200, r24
     e92:	15 c0       	rjmp	.+42     	; 0xebe <vTaskIncrementTick+0xae>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     e94:	80 91 66 02 	lds	r24, 0x0266
     e98:	90 91 67 02 	lds	r25, 0x0267
     e9c:	fc 01       	movw	r30, r24
     e9e:	85 81       	ldd	r24, Z+5	; 0x05
     ea0:	96 81       	ldd	r25, Z+6	; 0x06
     ea2:	fc 01       	movw	r30, r24
     ea4:	86 81       	ldd	r24, Z+6	; 0x06
     ea6:	97 81       	ldd	r25, Z+7	; 0x07
     ea8:	9c 83       	std	Y+4, r25	; 0x04
     eaa:	8b 83       	std	Y+3, r24	; 0x03
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
     eac:	8b 81       	ldd	r24, Y+3	; 0x03
     eae:	9c 81       	ldd	r25, Y+4	; 0x04
     eb0:	fc 01       	movw	r30, r24
     eb2:	82 81       	ldd	r24, Z+2	; 0x02
     eb4:	93 81       	ldd	r25, Z+3	; 0x03
     eb6:	90 93 01 02 	sts	0x0201, r25
     eba:	80 93 00 02 	sts	0x0200, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
     ebe:	20 91 7d 02 	lds	r18, 0x027D
     ec2:	30 91 7e 02 	lds	r19, 0x027E
     ec6:	80 91 00 02 	lds	r24, 0x0200
     eca:	90 91 01 02 	lds	r25, 0x0201
     ece:	28 17       	cp	r18, r24
     ed0:	39 07       	cpc	r19, r25
     ed2:	08 f4       	brcc	.+2      	; 0xed6 <vTaskIncrementTick+0xc6>
     ed4:	6b c0       	rjmp	.+214    	; 0xfac <vTaskIncrementTick+0x19c>
     ed6:	80 91 66 02 	lds	r24, 0x0266
     eda:	90 91 67 02 	lds	r25, 0x0267
     ede:	fc 01       	movw	r30, r24
     ee0:	80 81       	ld	r24, Z
     ee2:	88 23       	and	r24, r24
     ee4:	39 f4       	brne	.+14     	; 0xef4 <vTaskIncrementTick+0xe4>
     ee6:	8f ef       	ldi	r24, 0xFF	; 255
     ee8:	9f ef       	ldi	r25, 0xFF	; 255
     eea:	90 93 01 02 	sts	0x0201, r25
     eee:	80 93 00 02 	sts	0x0200, r24
     ef2:	5c c0       	rjmp	.+184    	; 0xfac <vTaskIncrementTick+0x19c>
     ef4:	80 91 66 02 	lds	r24, 0x0266
     ef8:	90 91 67 02 	lds	r25, 0x0267
     efc:	fc 01       	movw	r30, r24
     efe:	85 81       	ldd	r24, Z+5	; 0x05
     f00:	96 81       	ldd	r25, Z+6	; 0x06
     f02:	fc 01       	movw	r30, r24
     f04:	86 81       	ldd	r24, Z+6	; 0x06
     f06:	97 81       	ldd	r25, Z+7	; 0x07
     f08:	9c 83       	std	Y+4, r25	; 0x04
     f0a:	8b 83       	std	Y+3, r24	; 0x03
     f0c:	8b 81       	ldd	r24, Y+3	; 0x03
     f0e:	9c 81       	ldd	r25, Y+4	; 0x04
     f10:	fc 01       	movw	r30, r24
     f12:	82 81       	ldd	r24, Z+2	; 0x02
     f14:	93 81       	ldd	r25, Z+3	; 0x03
     f16:	9e 83       	std	Y+6, r25	; 0x06
     f18:	8d 83       	std	Y+5, r24	; 0x05
     f1a:	20 91 7d 02 	lds	r18, 0x027D
     f1e:	30 91 7e 02 	lds	r19, 0x027E
     f22:	8d 81       	ldd	r24, Y+5	; 0x05
     f24:	9e 81       	ldd	r25, Y+6	; 0x06
     f26:	28 17       	cp	r18, r24
     f28:	39 07       	cpc	r19, r25
     f2a:	38 f4       	brcc	.+14     	; 0xf3a <vTaskIncrementTick+0x12a>
     f2c:	8d 81       	ldd	r24, Y+5	; 0x05
     f2e:	9e 81       	ldd	r25, Y+6	; 0x06
     f30:	90 93 01 02 	sts	0x0201, r25
     f34:	80 93 00 02 	sts	0x0200, r24
     f38:	39 c0       	rjmp	.+114    	; 0xfac <vTaskIncrementTick+0x19c>
     f3a:	8b 81       	ldd	r24, Y+3	; 0x03
     f3c:	9c 81       	ldd	r25, Y+4	; 0x04
     f3e:	02 96       	adiw	r24, 0x02	; 2
     f40:	0e 94 22 13 	call	0x2644	; 0x2644 <uxListRemove>
     f44:	8b 81       	ldd	r24, Y+3	; 0x03
     f46:	9c 81       	ldd	r25, Y+4	; 0x04
     f48:	fc 01       	movw	r30, r24
     f4a:	84 89       	ldd	r24, Z+20	; 0x14
     f4c:	95 89       	ldd	r25, Z+21	; 0x15
     f4e:	00 97       	sbiw	r24, 0x00	; 0
     f50:	29 f0       	breq	.+10     	; 0xf5c <vTaskIncrementTick+0x14c>
     f52:	8b 81       	ldd	r24, Y+3	; 0x03
     f54:	9c 81       	ldd	r25, Y+4	; 0x04
     f56:	0c 96       	adiw	r24, 0x0c	; 12
     f58:	0e 94 22 13 	call	0x2644	; 0x2644 <uxListRemove>
     f5c:	8b 81       	ldd	r24, Y+3	; 0x03
     f5e:	9c 81       	ldd	r25, Y+4	; 0x04
     f60:	fc 01       	movw	r30, r24
     f62:	96 89       	ldd	r25, Z+22	; 0x16
     f64:	80 91 80 02 	lds	r24, 0x0280
     f68:	89 17       	cp	r24, r25
     f6a:	30 f4       	brcc	.+12     	; 0xf78 <vTaskIncrementTick+0x168>
     f6c:	8b 81       	ldd	r24, Y+3	; 0x03
     f6e:	9c 81       	ldd	r25, Y+4	; 0x04
     f70:	fc 01       	movw	r30, r24
     f72:	86 89       	ldd	r24, Z+22	; 0x16
     f74:	80 93 80 02 	sts	0x0280, r24
     f78:	8b 81       	ldd	r24, Y+3	; 0x03
     f7a:	9c 81       	ldd	r25, Y+4	; 0x04
     f7c:	ac 01       	movw	r20, r24
     f7e:	4e 5f       	subi	r20, 0xFE	; 254
     f80:	5f 4f       	sbci	r21, 0xFF	; 255
     f82:	8b 81       	ldd	r24, Y+3	; 0x03
     f84:	9c 81       	ldd	r25, Y+4	; 0x04
     f86:	fc 01       	movw	r30, r24
     f88:	86 89       	ldd	r24, Z+22	; 0x16
     f8a:	28 2f       	mov	r18, r24
     f8c:	30 e0       	ldi	r19, 0x00	; 0
     f8e:	c9 01       	movw	r24, r18
     f90:	88 0f       	add	r24, r24
     f92:	99 1f       	adc	r25, r25
     f94:	88 0f       	add	r24, r24
     f96:	99 1f       	adc	r25, r25
     f98:	88 0f       	add	r24, r24
     f9a:	99 1f       	adc	r25, r25
     f9c:	82 0f       	add	r24, r18
     f9e:	93 1f       	adc	r25, r19
     fa0:	80 5d       	subi	r24, 0xD0	; 208
     fa2:	9d 4f       	sbci	r25, 0xFD	; 253
     fa4:	ba 01       	movw	r22, r20
     fa6:	0e 94 52 12 	call	0x24a4	; 0x24a4 <vListInsertEnd>
     faa:	95 cf       	rjmp	.-214    	; 0xed6 <vTaskIncrementTick+0xc6>
     fac:	05 c0       	rjmp	.+10     	; 0xfb8 <vTaskIncrementTick+0x1a8>
	}
	else
	{
		++uxMissedTicks;
     fae:	80 91 83 02 	lds	r24, 0x0283
     fb2:	8f 5f       	subi	r24, 0xFF	; 255
     fb4:	80 93 83 02 	sts	0x0283, r24
		{
			vApplicationTickHook();
		}
	}
	#endif
}
     fb8:	26 96       	adiw	r28, 0x06	; 6
     fba:	0f b6       	in	r0, 0x3f	; 63
     fbc:	f8 94       	cli
     fbe:	de bf       	out	0x3e, r29	; 62
     fc0:	0f be       	out	0x3f, r0	; 63
     fc2:	cd bf       	out	0x3d, r28	; 61
     fc4:	df 91       	pop	r29
     fc6:	cf 91       	pop	r28
     fc8:	08 95       	ret

00000fca <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
     fca:	cf 93       	push	r28
     fcc:	df 93       	push	r29
     fce:	1f 92       	push	r1
     fd0:	1f 92       	push	r1
     fd2:	cd b7       	in	r28, 0x3d	; 61
     fd4:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
     fd6:	80 91 82 02 	lds	r24, 0x0282
     fda:	88 23       	and	r24, r24
     fdc:	21 f0       	breq	.+8      	; 0xfe6 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
     fde:	81 e0       	ldi	r24, 0x01	; 1
     fe0:	80 93 84 02 	sts	0x0284, r24
     fe4:	7a c0       	rjmp	.+244    	; 0x10da <vTaskSwitchContext+0x110>
				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
				ulTaskSwitchedInTime = ulTempCounter;
		}
		#endif

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
     fe6:	80 91 2e 02 	lds	r24, 0x022E
     fea:	90 91 2f 02 	lds	r25, 0x022F
     fee:	fc 01       	movw	r30, r24
     ff0:	20 81       	ld	r18, Z
     ff2:	31 81       	ldd	r19, Z+1	; 0x01
     ff4:	80 91 2e 02 	lds	r24, 0x022E
     ff8:	90 91 2f 02 	lds	r25, 0x022F
     ffc:	fc 01       	movw	r30, r24
     ffe:	87 89       	ldd	r24, Z+23	; 0x17
    1000:	90 8d       	ldd	r25, Z+24	; 0x18
    1002:	82 17       	cp	r24, r18
    1004:	93 07       	cpc	r25, r19
    1006:	70 f0       	brcs	.+28     	; 0x1024 <vTaskSwitchContext+0x5a>
    1008:	80 91 2e 02 	lds	r24, 0x022E
    100c:	90 91 2f 02 	lds	r25, 0x022F
    1010:	9c 01       	movw	r18, r24
    1012:	27 5e       	subi	r18, 0xE7	; 231
    1014:	3f 4f       	sbci	r19, 0xFF	; 255
    1016:	80 91 2e 02 	lds	r24, 0x022E
    101a:	90 91 2f 02 	lds	r25, 0x022F
    101e:	b9 01       	movw	r22, r18
    1020:	0e 94 bd 00 	call	0x17a	; 0x17a <vApplicationStackOverflowHook>
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
    1024:	05 c0       	rjmp	.+10     	; 0x1030 <vTaskSwitchContext+0x66>
    1026:	80 91 80 02 	lds	r24, 0x0280
    102a:	81 50       	subi	r24, 0x01	; 1
    102c:	80 93 80 02 	sts	0x0280, r24
    1030:	80 91 80 02 	lds	r24, 0x0280
    1034:	28 2f       	mov	r18, r24
    1036:	30 e0       	ldi	r19, 0x00	; 0
    1038:	c9 01       	movw	r24, r18
    103a:	88 0f       	add	r24, r24
    103c:	99 1f       	adc	r25, r25
    103e:	88 0f       	add	r24, r24
    1040:	99 1f       	adc	r25, r25
    1042:	88 0f       	add	r24, r24
    1044:	99 1f       	adc	r25, r25
    1046:	82 0f       	add	r24, r18
    1048:	93 1f       	adc	r25, r19
    104a:	80 5d       	subi	r24, 0xD0	; 208
    104c:	9d 4f       	sbci	r25, 0xFD	; 253
    104e:	fc 01       	movw	r30, r24
    1050:	80 81       	ld	r24, Z
    1052:	88 23       	and	r24, r24
    1054:	41 f3       	breq	.-48     	; 0x1026 <vTaskSwitchContext+0x5c>
    1056:	80 91 80 02 	lds	r24, 0x0280
    105a:	28 2f       	mov	r18, r24
    105c:	30 e0       	ldi	r19, 0x00	; 0
    105e:	c9 01       	movw	r24, r18
    1060:	88 0f       	add	r24, r24
    1062:	99 1f       	adc	r25, r25
    1064:	88 0f       	add	r24, r24
    1066:	99 1f       	adc	r25, r25
    1068:	88 0f       	add	r24, r24
    106a:	99 1f       	adc	r25, r25
    106c:	82 0f       	add	r24, r18
    106e:	93 1f       	adc	r25, r19
    1070:	80 5d       	subi	r24, 0xD0	; 208
    1072:	9d 4f       	sbci	r25, 0xFD	; 253
    1074:	9a 83       	std	Y+2, r25	; 0x02
    1076:	89 83       	std	Y+1, r24	; 0x01
    1078:	89 81       	ldd	r24, Y+1	; 0x01
    107a:	9a 81       	ldd	r25, Y+2	; 0x02
    107c:	fc 01       	movw	r30, r24
    107e:	81 81       	ldd	r24, Z+1	; 0x01
    1080:	92 81       	ldd	r25, Z+2	; 0x02
    1082:	fc 01       	movw	r30, r24
    1084:	22 81       	ldd	r18, Z+2	; 0x02
    1086:	33 81       	ldd	r19, Z+3	; 0x03
    1088:	89 81       	ldd	r24, Y+1	; 0x01
    108a:	9a 81       	ldd	r25, Y+2	; 0x02
    108c:	fc 01       	movw	r30, r24
    108e:	32 83       	std	Z+2, r19	; 0x02
    1090:	21 83       	std	Z+1, r18	; 0x01
    1092:	89 81       	ldd	r24, Y+1	; 0x01
    1094:	9a 81       	ldd	r25, Y+2	; 0x02
    1096:	fc 01       	movw	r30, r24
    1098:	21 81       	ldd	r18, Z+1	; 0x01
    109a:	32 81       	ldd	r19, Z+2	; 0x02
    109c:	89 81       	ldd	r24, Y+1	; 0x01
    109e:	9a 81       	ldd	r25, Y+2	; 0x02
    10a0:	03 96       	adiw	r24, 0x03	; 3
    10a2:	28 17       	cp	r18, r24
    10a4:	39 07       	cpc	r19, r25
    10a6:	69 f4       	brne	.+26     	; 0x10c2 <vTaskSwitchContext+0xf8>
    10a8:	89 81       	ldd	r24, Y+1	; 0x01
    10aa:	9a 81       	ldd	r25, Y+2	; 0x02
    10ac:	fc 01       	movw	r30, r24
    10ae:	81 81       	ldd	r24, Z+1	; 0x01
    10b0:	92 81       	ldd	r25, Z+2	; 0x02
    10b2:	fc 01       	movw	r30, r24
    10b4:	22 81       	ldd	r18, Z+2	; 0x02
    10b6:	33 81       	ldd	r19, Z+3	; 0x03
    10b8:	89 81       	ldd	r24, Y+1	; 0x01
    10ba:	9a 81       	ldd	r25, Y+2	; 0x02
    10bc:	fc 01       	movw	r30, r24
    10be:	32 83       	std	Z+2, r19	; 0x02
    10c0:	21 83       	std	Z+1, r18	; 0x01
    10c2:	89 81       	ldd	r24, Y+1	; 0x01
    10c4:	9a 81       	ldd	r25, Y+2	; 0x02
    10c6:	fc 01       	movw	r30, r24
    10c8:	81 81       	ldd	r24, Z+1	; 0x01
    10ca:	92 81       	ldd	r25, Z+2	; 0x02
    10cc:	fc 01       	movw	r30, r24
    10ce:	86 81       	ldd	r24, Z+6	; 0x06
    10d0:	97 81       	ldd	r25, Z+7	; 0x07
    10d2:	90 93 2f 02 	sts	0x022F, r25
    10d6:	80 93 2e 02 	sts	0x022E, r24

		traceTASK_SWITCHED_IN();
	}
}
    10da:	0f 90       	pop	r0
    10dc:	0f 90       	pop	r0
    10de:	df 91       	pop	r29
    10e0:	cf 91       	pop	r28
    10e2:	08 95       	ret

000010e4 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    10e4:	cf 93       	push	r28
    10e6:	df 93       	push	r29
    10e8:	00 d0       	rcall	.+0      	; 0x10ea <vTaskPlaceOnEventList+0x6>
    10ea:	00 d0       	rcall	.+0      	; 0x10ec <vTaskPlaceOnEventList+0x8>
    10ec:	cd b7       	in	r28, 0x3d	; 61
    10ee:	de b7       	in	r29, 0x3e	; 62
    10f0:	9c 83       	std	Y+4, r25	; 0x04
    10f2:	8b 83       	std	Y+3, r24	; 0x03
    10f4:	7e 83       	std	Y+6, r23	; 0x06
    10f6:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    10f8:	80 91 2e 02 	lds	r24, 0x022E
    10fc:	90 91 2f 02 	lds	r25, 0x022F
    1100:	9c 01       	movw	r18, r24
    1102:	24 5f       	subi	r18, 0xF4	; 244
    1104:	3f 4f       	sbci	r19, 0xFF	; 255
    1106:	8b 81       	ldd	r24, Y+3	; 0x03
    1108:	9c 81       	ldd	r25, Y+4	; 0x04
    110a:	b9 01       	movw	r22, r18
    110c:	0e 94 a9 12 	call	0x2552	; 0x2552 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    1110:	80 91 2e 02 	lds	r24, 0x022E
    1114:	90 91 2f 02 	lds	r25, 0x022F
    1118:	02 96       	adiw	r24, 0x02	; 2
    111a:	0e 94 22 13 	call	0x2644	; 0x2644 <uxListRemove>
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    111e:	8d 81       	ldd	r24, Y+5	; 0x05
    1120:	9e 81       	ldd	r25, Y+6	; 0x06
    1122:	8f 3f       	cpi	r24, 0xFF	; 255
    1124:	2f ef       	ldi	r18, 0xFF	; 255
    1126:	92 07       	cpc	r25, r18
    1128:	59 f4       	brne	.+22     	; 0x1140 <vTaskPlaceOnEventList+0x5c>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    112a:	80 91 2e 02 	lds	r24, 0x022E
    112e:	90 91 2f 02 	lds	r25, 0x022F
    1132:	02 96       	adiw	r24, 0x02	; 2
    1134:	bc 01       	movw	r22, r24
    1136:	83 e7       	ldi	r24, 0x73	; 115
    1138:	92 e0       	ldi	r25, 0x02	; 2
    113a:	0e 94 52 12 	call	0x24a4	; 0x24a4 <vListInsertEnd>
    113e:	0e c0       	rjmp	.+28     	; 0x115c <vTaskPlaceOnEventList+0x78>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    1140:	20 91 7d 02 	lds	r18, 0x027D
    1144:	30 91 7e 02 	lds	r19, 0x027E
    1148:	8d 81       	ldd	r24, Y+5	; 0x05
    114a:	9e 81       	ldd	r25, Y+6	; 0x06
    114c:	82 0f       	add	r24, r18
    114e:	93 1f       	adc	r25, r19
    1150:	9a 83       	std	Y+2, r25	; 0x02
    1152:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    1154:	89 81       	ldd	r24, Y+1	; 0x01
    1156:	9a 81       	ldd	r25, Y+2	; 0x02
    1158:	0e 94 6d 0a 	call	0x14da	; 0x14da <prvAddCurrentTaskToDelayedList>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
    115c:	26 96       	adiw	r28, 0x06	; 6
    115e:	0f b6       	in	r0, 0x3f	; 63
    1160:	f8 94       	cli
    1162:	de bf       	out	0x3e, r29	; 62
    1164:	0f be       	out	0x3f, r0	; 63
    1166:	cd bf       	out	0x3d, r28	; 61
    1168:	df 91       	pop	r29
    116a:	cf 91       	pop	r28
    116c:	08 95       	ret

0000116e <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    116e:	cf 93       	push	r28
    1170:	df 93       	push	r29
    1172:	00 d0       	rcall	.+0      	; 0x1174 <xTaskRemoveFromEventList+0x6>
    1174:	1f 92       	push	r1
    1176:	1f 92       	push	r1
    1178:	cd b7       	in	r28, 0x3d	; 61
    117a:	de b7       	in	r29, 0x3e	; 62
    117c:	9d 83       	std	Y+5, r25	; 0x05
    117e:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1180:	8c 81       	ldd	r24, Y+4	; 0x04
    1182:	9d 81       	ldd	r25, Y+5	; 0x05
    1184:	fc 01       	movw	r30, r24
    1186:	85 81       	ldd	r24, Z+5	; 0x05
    1188:	96 81       	ldd	r25, Z+6	; 0x06
    118a:	fc 01       	movw	r30, r24
    118c:	86 81       	ldd	r24, Z+6	; 0x06
    118e:	97 81       	ldd	r25, Z+7	; 0x07
    1190:	9b 83       	std	Y+3, r25	; 0x03
    1192:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1194:	8a 81       	ldd	r24, Y+2	; 0x02
    1196:	9b 81       	ldd	r25, Y+3	; 0x03
    1198:	0c 96       	adiw	r24, 0x0c	; 12
    119a:	0e 94 22 13 	call	0x2644	; 0x2644 <uxListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    119e:	80 91 82 02 	lds	r24, 0x0282
    11a2:	88 23       	and	r24, r24
    11a4:	69 f5       	brne	.+90     	; 0x1200 <xTaskRemoveFromEventList+0x92>
	{
		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    11a6:	8a 81       	ldd	r24, Y+2	; 0x02
    11a8:	9b 81       	ldd	r25, Y+3	; 0x03
    11aa:	02 96       	adiw	r24, 0x02	; 2
    11ac:	0e 94 22 13 	call	0x2644	; 0x2644 <uxListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    11b0:	8a 81       	ldd	r24, Y+2	; 0x02
    11b2:	9b 81       	ldd	r25, Y+3	; 0x03
    11b4:	fc 01       	movw	r30, r24
    11b6:	96 89       	ldd	r25, Z+22	; 0x16
    11b8:	80 91 80 02 	lds	r24, 0x0280
    11bc:	89 17       	cp	r24, r25
    11be:	30 f4       	brcc	.+12     	; 0x11cc <xTaskRemoveFromEventList+0x5e>
    11c0:	8a 81       	ldd	r24, Y+2	; 0x02
    11c2:	9b 81       	ldd	r25, Y+3	; 0x03
    11c4:	fc 01       	movw	r30, r24
    11c6:	86 89       	ldd	r24, Z+22	; 0x16
    11c8:	80 93 80 02 	sts	0x0280, r24
    11cc:	8a 81       	ldd	r24, Y+2	; 0x02
    11ce:	9b 81       	ldd	r25, Y+3	; 0x03
    11d0:	ac 01       	movw	r20, r24
    11d2:	4e 5f       	subi	r20, 0xFE	; 254
    11d4:	5f 4f       	sbci	r21, 0xFF	; 255
    11d6:	8a 81       	ldd	r24, Y+2	; 0x02
    11d8:	9b 81       	ldd	r25, Y+3	; 0x03
    11da:	fc 01       	movw	r30, r24
    11dc:	86 89       	ldd	r24, Z+22	; 0x16
    11de:	28 2f       	mov	r18, r24
    11e0:	30 e0       	ldi	r19, 0x00	; 0
    11e2:	c9 01       	movw	r24, r18
    11e4:	88 0f       	add	r24, r24
    11e6:	99 1f       	adc	r25, r25
    11e8:	88 0f       	add	r24, r24
    11ea:	99 1f       	adc	r25, r25
    11ec:	88 0f       	add	r24, r24
    11ee:	99 1f       	adc	r25, r25
    11f0:	82 0f       	add	r24, r18
    11f2:	93 1f       	adc	r25, r19
    11f4:	80 5d       	subi	r24, 0xD0	; 208
    11f6:	9d 4f       	sbci	r25, 0xFD	; 253
    11f8:	ba 01       	movw	r22, r20
    11fa:	0e 94 52 12 	call	0x24a4	; 0x24a4 <vListInsertEnd>
    11fe:	08 c0       	rjmp	.+16     	; 0x1210 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1200:	8a 81       	ldd	r24, Y+2	; 0x02
    1202:	9b 81       	ldd	r25, Y+3	; 0x03
    1204:	0c 96       	adiw	r24, 0x0c	; 12
    1206:	bc 01       	movw	r22, r24
    1208:	8a e6       	ldi	r24, 0x6A	; 106
    120a:	92 e0       	ldi	r25, 0x02	; 2
    120c:	0e 94 52 12 	call	0x24a4	; 0x24a4 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1210:	8a 81       	ldd	r24, Y+2	; 0x02
    1212:	9b 81       	ldd	r25, Y+3	; 0x03
    1214:	fc 01       	movw	r30, r24
    1216:	26 89       	ldd	r18, Z+22	; 0x16
    1218:	80 91 2e 02 	lds	r24, 0x022E
    121c:	90 91 2f 02 	lds	r25, 0x022F
    1220:	fc 01       	movw	r30, r24
    1222:	86 89       	ldd	r24, Z+22	; 0x16
    1224:	28 17       	cp	r18, r24
    1226:	18 f0       	brcs	.+6      	; 0x122e <xTaskRemoveFromEventList+0xc0>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    1228:	81 e0       	ldi	r24, 0x01	; 1
    122a:	89 83       	std	Y+1, r24	; 0x01
    122c:	01 c0       	rjmp	.+2      	; 0x1230 <xTaskRemoveFromEventList+0xc2>
	}
	else
	{
		xReturn = pdFALSE;
    122e:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    1230:	89 81       	ldd	r24, Y+1	; 0x01
}
    1232:	0f 90       	pop	r0
    1234:	0f 90       	pop	r0
    1236:	0f 90       	pop	r0
    1238:	0f 90       	pop	r0
    123a:	0f 90       	pop	r0
    123c:	df 91       	pop	r29
    123e:	cf 91       	pop	r28
    1240:	08 95       	ret

00001242 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    1242:	cf 93       	push	r28
    1244:	df 93       	push	r29
    1246:	1f 92       	push	r1
    1248:	1f 92       	push	r1
    124a:	cd b7       	in	r28, 0x3d	; 61
    124c:	de b7       	in	r29, 0x3e	; 62
    124e:	9a 83       	std	Y+2, r25	; 0x02
    1250:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1252:	20 91 85 02 	lds	r18, 0x0285
    1256:	89 81       	ldd	r24, Y+1	; 0x01
    1258:	9a 81       	ldd	r25, Y+2	; 0x02
    125a:	fc 01       	movw	r30, r24
    125c:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    125e:	20 91 7d 02 	lds	r18, 0x027D
    1262:	30 91 7e 02 	lds	r19, 0x027E
    1266:	89 81       	ldd	r24, Y+1	; 0x01
    1268:	9a 81       	ldd	r25, Y+2	; 0x02
    126a:	fc 01       	movw	r30, r24
    126c:	32 83       	std	Z+2, r19	; 0x02
    126e:	21 83       	std	Z+1, r18	; 0x01
}
    1270:	0f 90       	pop	r0
    1272:	0f 90       	pop	r0
    1274:	df 91       	pop	r29
    1276:	cf 91       	pop	r28
    1278:	08 95       	ret

0000127a <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    127a:	cf 93       	push	r28
    127c:	df 93       	push	r29
    127e:	00 d0       	rcall	.+0      	; 0x1280 <xTaskCheckForTimeOut+0x6>
    1280:	1f 92       	push	r1
    1282:	1f 92       	push	r1
    1284:	cd b7       	in	r28, 0x3d	; 61
    1286:	de b7       	in	r29, 0x3e	; 62
    1288:	9b 83       	std	Y+3, r25	; 0x03
    128a:	8a 83       	std	Y+2, r24	; 0x02
    128c:	7d 83       	std	Y+5, r23	; 0x05
    128e:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1290:	0f b6       	in	r0, 0x3f	; 63
    1292:	f8 94       	cli
    1294:	0f 92       	push	r0
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    1296:	8c 81       	ldd	r24, Y+4	; 0x04
    1298:	9d 81       	ldd	r25, Y+5	; 0x05
    129a:	fc 01       	movw	r30, r24
    129c:	80 81       	ld	r24, Z
    129e:	91 81       	ldd	r25, Z+1	; 0x01
    12a0:	8f 3f       	cpi	r24, 0xFF	; 255
    12a2:	ff ef       	ldi	r31, 0xFF	; 255
    12a4:	9f 07       	cpc	r25, r31
    12a6:	11 f4       	brne	.+4      	; 0x12ac <xTaskCheckForTimeOut+0x32>
			{
				xReturn = pdFALSE;
    12a8:	19 82       	std	Y+1, r1	; 0x01
    12aa:	4b c0       	rjmp	.+150    	; 0x1342 <xTaskCheckForTimeOut+0xc8>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    12ac:	8a 81       	ldd	r24, Y+2	; 0x02
    12ae:	9b 81       	ldd	r25, Y+3	; 0x03
    12b0:	fc 01       	movw	r30, r24
    12b2:	90 81       	ld	r25, Z
    12b4:	80 91 85 02 	lds	r24, 0x0285
    12b8:	98 17       	cp	r25, r24
    12ba:	79 f0       	breq	.+30     	; 0x12da <xTaskCheckForTimeOut+0x60>
    12bc:	8a 81       	ldd	r24, Y+2	; 0x02
    12be:	9b 81       	ldd	r25, Y+3	; 0x03
    12c0:	fc 01       	movw	r30, r24
    12c2:	21 81       	ldd	r18, Z+1	; 0x01
    12c4:	32 81       	ldd	r19, Z+2	; 0x02
    12c6:	80 91 7d 02 	lds	r24, 0x027D
    12ca:	90 91 7e 02 	lds	r25, 0x027E
    12ce:	82 17       	cp	r24, r18
    12d0:	93 07       	cpc	r25, r19
    12d2:	18 f0       	brcs	.+6      	; 0x12da <xTaskCheckForTimeOut+0x60>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    12d4:	81 e0       	ldi	r24, 0x01	; 1
    12d6:	89 83       	std	Y+1, r24	; 0x01
    12d8:	34 c0       	rjmp	.+104    	; 0x1342 <xTaskCheckForTimeOut+0xc8>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    12da:	20 91 7d 02 	lds	r18, 0x027D
    12de:	30 91 7e 02 	lds	r19, 0x027E
    12e2:	8a 81       	ldd	r24, Y+2	; 0x02
    12e4:	9b 81       	ldd	r25, Y+3	; 0x03
    12e6:	fc 01       	movw	r30, r24
    12e8:	81 81       	ldd	r24, Z+1	; 0x01
    12ea:	92 81       	ldd	r25, Z+2	; 0x02
    12ec:	28 1b       	sub	r18, r24
    12ee:	39 0b       	sbc	r19, r25
    12f0:	8c 81       	ldd	r24, Y+4	; 0x04
    12f2:	9d 81       	ldd	r25, Y+5	; 0x05
    12f4:	fc 01       	movw	r30, r24
    12f6:	80 81       	ld	r24, Z
    12f8:	91 81       	ldd	r25, Z+1	; 0x01
    12fa:	28 17       	cp	r18, r24
    12fc:	39 07       	cpc	r19, r25
    12fe:	f8 f4       	brcc	.+62     	; 0x133e <xTaskCheckForTimeOut+0xc4>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    1300:	8c 81       	ldd	r24, Y+4	; 0x04
    1302:	9d 81       	ldd	r25, Y+5	; 0x05
    1304:	fc 01       	movw	r30, r24
    1306:	20 81       	ld	r18, Z
    1308:	31 81       	ldd	r19, Z+1	; 0x01
    130a:	8a 81       	ldd	r24, Y+2	; 0x02
    130c:	9b 81       	ldd	r25, Y+3	; 0x03
    130e:	fc 01       	movw	r30, r24
    1310:	41 81       	ldd	r20, Z+1	; 0x01
    1312:	52 81       	ldd	r21, Z+2	; 0x02
    1314:	80 91 7d 02 	lds	r24, 0x027D
    1318:	90 91 7e 02 	lds	r25, 0x027E
    131c:	ba 01       	movw	r22, r20
    131e:	68 1b       	sub	r22, r24
    1320:	79 0b       	sbc	r23, r25
    1322:	cb 01       	movw	r24, r22
    1324:	28 0f       	add	r18, r24
    1326:	39 1f       	adc	r19, r25
    1328:	8c 81       	ldd	r24, Y+4	; 0x04
    132a:	9d 81       	ldd	r25, Y+5	; 0x05
    132c:	fc 01       	movw	r30, r24
    132e:	31 83       	std	Z+1, r19	; 0x01
    1330:	20 83       	st	Z, r18
			vTaskSetTimeOutState( pxTimeOut );
    1332:	8a 81       	ldd	r24, Y+2	; 0x02
    1334:	9b 81       	ldd	r25, Y+3	; 0x03
    1336:	0e 94 21 09 	call	0x1242	; 0x1242 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    133a:	19 82       	std	Y+1, r1	; 0x01
    133c:	02 c0       	rjmp	.+4      	; 0x1342 <xTaskCheckForTimeOut+0xc8>
		}
		else
		{
			xReturn = pdTRUE;
    133e:	81 e0       	ldi	r24, 0x01	; 1
    1340:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    1342:	0f 90       	pop	r0
    1344:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1346:	89 81       	ldd	r24, Y+1	; 0x01
}
    1348:	0f 90       	pop	r0
    134a:	0f 90       	pop	r0
    134c:	0f 90       	pop	r0
    134e:	0f 90       	pop	r0
    1350:	0f 90       	pop	r0
    1352:	df 91       	pop	r29
    1354:	cf 91       	pop	r28
    1356:	08 95       	ret

00001358 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    1358:	cf 93       	push	r28
    135a:	df 93       	push	r29
    135c:	cd b7       	in	r28, 0x3d	; 61
    135e:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    1360:	81 e0       	ldi	r24, 0x01	; 1
    1362:	80 93 84 02 	sts	0x0284, r24
}
    1366:	df 91       	pop	r29
    1368:	cf 91       	pop	r28
    136a:	08 95       	ret

0000136c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    136c:	cf 93       	push	r28
    136e:	df 93       	push	r29
    1370:	1f 92       	push	r1
    1372:	1f 92       	push	r1
    1374:	cd b7       	in	r28, 0x3d	; 61
    1376:	de b7       	in	r29, 0x3e	; 62
    1378:	9a 83       	std	Y+2, r25	; 0x02
    137a:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    137c:	0e 94 66 0a 	call	0x14cc	; 0x14cc <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    1380:	80 91 30 02 	lds	r24, 0x0230
    1384:	82 30       	cpi	r24, 0x02	; 2
    1386:	18 f0       	brcs	.+6      	; 0x138e <prvIdleTask+0x22>
			{
				taskYIELD();
    1388:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <vPortYield>
				}
				xTaskResumeAll();
			}
		}
		#endif
	}
    138c:	f7 cf       	rjmp	.-18     	; 0x137c <prvIdleTask+0x10>
    138e:	f6 cf       	rjmp	.-20     	; 0x137c <prvIdleTask+0x10>

00001390 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    1390:	0f 93       	push	r16
    1392:	1f 93       	push	r17
    1394:	cf 93       	push	r28
    1396:	df 93       	push	r29
    1398:	cd b7       	in	r28, 0x3d	; 61
    139a:	de b7       	in	r29, 0x3e	; 62
    139c:	29 97       	sbiw	r28, 0x09	; 9
    139e:	0f b6       	in	r0, 0x3f	; 63
    13a0:	f8 94       	cli
    13a2:	de bf       	out	0x3e, r29	; 62
    13a4:	0f be       	out	0x3f, r0	; 63
    13a6:	cd bf       	out	0x3d, r28	; 61
    13a8:	9a 83       	std	Y+2, r25	; 0x02
    13aa:	89 83       	std	Y+1, r24	; 0x01
    13ac:	7c 83       	std	Y+4, r23	; 0x04
    13ae:	6b 83       	std	Y+3, r22	; 0x03
    13b0:	4d 83       	std	Y+5, r20	; 0x05
    13b2:	3f 83       	std	Y+7, r19	; 0x07
    13b4:	2e 83       	std	Y+6, r18	; 0x06
    13b6:	19 87       	std	Y+9, r17	; 0x09
    13b8:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    13ba:	89 81       	ldd	r24, Y+1	; 0x01
    13bc:	9a 81       	ldd	r25, Y+2	; 0x02
    13be:	49 96       	adiw	r24, 0x19	; 25
    13c0:	2b 81       	ldd	r18, Y+3	; 0x03
    13c2:	3c 81       	ldd	r19, Y+4	; 0x04
    13c4:	40 e1       	ldi	r20, 0x10	; 16
    13c6:	50 e0       	ldi	r21, 0x00	; 0
    13c8:	b9 01       	movw	r22, r18
    13ca:	0e 94 e2 23 	call	0x47c4	; 0x47c4 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    13ce:	89 81       	ldd	r24, Y+1	; 0x01
    13d0:	9a 81       	ldd	r25, Y+2	; 0x02
    13d2:	fc 01       	movw	r30, r24
    13d4:	10 a6       	std	Z+40, r1	; 0x28

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    13d6:	8d 81       	ldd	r24, Y+5	; 0x05
    13d8:	84 30       	cpi	r24, 0x04	; 4
    13da:	10 f0       	brcs	.+4      	; 0x13e0 <prvInitialiseTCBVariables+0x50>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    13dc:	83 e0       	ldi	r24, 0x03	; 3
    13de:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    13e0:	89 81       	ldd	r24, Y+1	; 0x01
    13e2:	9a 81       	ldd	r25, Y+2	; 0x02
    13e4:	2d 81       	ldd	r18, Y+5	; 0x05
    13e6:	fc 01       	movw	r30, r24
    13e8:	26 8b       	std	Z+22, r18	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    13ea:	89 81       	ldd	r24, Y+1	; 0x01
    13ec:	9a 81       	ldd	r25, Y+2	; 0x02
    13ee:	2d 81       	ldd	r18, Y+5	; 0x05
    13f0:	fc 01       	movw	r30, r24
    13f2:	21 a7       	std	Z+41, r18	; 0x29
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    13f4:	89 81       	ldd	r24, Y+1	; 0x01
    13f6:	9a 81       	ldd	r25, Y+2	; 0x02
    13f8:	02 96       	adiw	r24, 0x02	; 2
    13fa:	0e 94 40 12 	call	0x2480	; 0x2480 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    13fe:	89 81       	ldd	r24, Y+1	; 0x01
    1400:	9a 81       	ldd	r25, Y+2	; 0x02
    1402:	0c 96       	adiw	r24, 0x0c	; 12
    1404:	0e 94 40 12 	call	0x2480	; 0x2480 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    1408:	89 81       	ldd	r24, Y+1	; 0x01
    140a:	9a 81       	ldd	r25, Y+2	; 0x02
    140c:	29 81       	ldd	r18, Y+1	; 0x01
    140e:	3a 81       	ldd	r19, Y+2	; 0x02
    1410:	fc 01       	movw	r30, r24
    1412:	31 87       	std	Z+9, r19	; 0x09
    1414:	20 87       	std	Z+8, r18	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    1416:	8d 81       	ldd	r24, Y+5	; 0x05
    1418:	88 2f       	mov	r24, r24
    141a:	90 e0       	ldi	r25, 0x00	; 0
    141c:	24 e0       	ldi	r18, 0x04	; 4
    141e:	30 e0       	ldi	r19, 0x00	; 0
    1420:	28 1b       	sub	r18, r24
    1422:	39 0b       	sbc	r19, r25
    1424:	89 81       	ldd	r24, Y+1	; 0x01
    1426:	9a 81       	ldd	r25, Y+2	; 0x02
    1428:	fc 01       	movw	r30, r24
    142a:	35 87       	std	Z+13, r19	; 0x0d
    142c:	24 87       	std	Z+12, r18	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    142e:	89 81       	ldd	r24, Y+1	; 0x01
    1430:	9a 81       	ldd	r25, Y+2	; 0x02
    1432:	29 81       	ldd	r18, Y+1	; 0x01
    1434:	3a 81       	ldd	r19, Y+2	; 0x02
    1436:	fc 01       	movw	r30, r24
    1438:	33 8b       	std	Z+19, r19	; 0x13
    143a:	22 8b       	std	Z+18, r18	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    143c:	29 96       	adiw	r28, 0x09	; 9
    143e:	0f b6       	in	r0, 0x3f	; 63
    1440:	f8 94       	cli
    1442:	de bf       	out	0x3e, r29	; 62
    1444:	0f be       	out	0x3f, r0	; 63
    1446:	cd bf       	out	0x3d, r28	; 61
    1448:	df 91       	pop	r29
    144a:	cf 91       	pop	r28
    144c:	1f 91       	pop	r17
    144e:	0f 91       	pop	r16
    1450:	08 95       	ret

00001452 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    1452:	cf 93       	push	r28
    1454:	df 93       	push	r29
    1456:	1f 92       	push	r1
    1458:	cd b7       	in	r28, 0x3d	; 61
    145a:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    145c:	19 82       	std	Y+1, r1	; 0x01
    145e:	13 c0       	rjmp	.+38     	; 0x1486 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    1460:	89 81       	ldd	r24, Y+1	; 0x01
    1462:	28 2f       	mov	r18, r24
    1464:	30 e0       	ldi	r19, 0x00	; 0
    1466:	c9 01       	movw	r24, r18
    1468:	88 0f       	add	r24, r24
    146a:	99 1f       	adc	r25, r25
    146c:	88 0f       	add	r24, r24
    146e:	99 1f       	adc	r25, r25
    1470:	88 0f       	add	r24, r24
    1472:	99 1f       	adc	r25, r25
    1474:	82 0f       	add	r24, r18
    1476:	93 1f       	adc	r25, r19
    1478:	80 5d       	subi	r24, 0xD0	; 208
    147a:	9d 4f       	sbci	r25, 0xFD	; 253
    147c:	0e 94 0a 12 	call	0x2414	; 0x2414 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    1480:	89 81       	ldd	r24, Y+1	; 0x01
    1482:	8f 5f       	subi	r24, 0xFF	; 255
    1484:	89 83       	std	Y+1, r24	; 0x01
    1486:	89 81       	ldd	r24, Y+1	; 0x01
    1488:	84 30       	cpi	r24, 0x04	; 4
    148a:	50 f3       	brcs	.-44     	; 0x1460 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    148c:	84 e5       	ldi	r24, 0x54	; 84
    148e:	92 e0       	ldi	r25, 0x02	; 2
    1490:	0e 94 0a 12 	call	0x2414	; 0x2414 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    1494:	8d e5       	ldi	r24, 0x5D	; 93
    1496:	92 e0       	ldi	r25, 0x02	; 2
    1498:	0e 94 0a 12 	call	0x2414	; 0x2414 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    149c:	8a e6       	ldi	r24, 0x6A	; 106
    149e:	92 e0       	ldi	r25, 0x02	; 2
    14a0:	0e 94 0a 12 	call	0x2414	; 0x2414 <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
    14a4:	83 e7       	ldi	r24, 0x73	; 115
    14a6:	92 e0       	ldi	r25, 0x02	; 2
    14a8:	0e 94 0a 12 	call	0x2414	; 0x2414 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    14ac:	84 e5       	ldi	r24, 0x54	; 84
    14ae:	92 e0       	ldi	r25, 0x02	; 2
    14b0:	90 93 67 02 	sts	0x0267, r25
    14b4:	80 93 66 02 	sts	0x0266, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    14b8:	8d e5       	ldi	r24, 0x5D	; 93
    14ba:	92 e0       	ldi	r25, 0x02	; 2
    14bc:	90 93 69 02 	sts	0x0269, r25
    14c0:	80 93 68 02 	sts	0x0268, r24
}
    14c4:	0f 90       	pop	r0
    14c6:	df 91       	pop	r29
    14c8:	cf 91       	pop	r28
    14ca:	08 95       	ret

000014cc <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    14cc:	cf 93       	push	r28
    14ce:	df 93       	push	r29
    14d0:	cd b7       	in	r28, 0x3d	; 61
    14d2:	de b7       	in	r29, 0x3e	; 62
				prvDeleteTCB( pxTCB );
			}
		}
	}
	#endif
}
    14d4:	df 91       	pop	r29
    14d6:	cf 91       	pop	r28
    14d8:	08 95       	ret

000014da <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    14da:	cf 93       	push	r28
    14dc:	df 93       	push	r29
    14de:	1f 92       	push	r1
    14e0:	1f 92       	push	r1
    14e2:	cd b7       	in	r28, 0x3d	; 61
    14e4:	de b7       	in	r29, 0x3e	; 62
    14e6:	9a 83       	std	Y+2, r25	; 0x02
    14e8:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    14ea:	80 91 2e 02 	lds	r24, 0x022E
    14ee:	90 91 2f 02 	lds	r25, 0x022F
    14f2:	29 81       	ldd	r18, Y+1	; 0x01
    14f4:	3a 81       	ldd	r19, Y+2	; 0x02
    14f6:	fc 01       	movw	r30, r24
    14f8:	33 83       	std	Z+3, r19	; 0x03
    14fa:	22 83       	std	Z+2, r18	; 0x02

	if( xTimeToWake < xTickCount )
    14fc:	80 91 7d 02 	lds	r24, 0x027D
    1500:	90 91 7e 02 	lds	r25, 0x027E
    1504:	29 81       	ldd	r18, Y+1	; 0x01
    1506:	3a 81       	ldd	r19, Y+2	; 0x02
    1508:	28 17       	cp	r18, r24
    150a:	39 07       	cpc	r19, r25
    150c:	78 f4       	brcc	.+30     	; 0x152c <prvAddCurrentTaskToDelayedList+0x52>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    150e:	80 91 2e 02 	lds	r24, 0x022E
    1512:	90 91 2f 02 	lds	r25, 0x022F
    1516:	9c 01       	movw	r18, r24
    1518:	2e 5f       	subi	r18, 0xFE	; 254
    151a:	3f 4f       	sbci	r19, 0xFF	; 255
    151c:	80 91 68 02 	lds	r24, 0x0268
    1520:	90 91 69 02 	lds	r25, 0x0269
    1524:	b9 01       	movw	r22, r18
    1526:	0e 94 a9 12 	call	0x2552	; 0x2552 <vListInsert>
    152a:	1d c0       	rjmp	.+58     	; 0x1566 <prvAddCurrentTaskToDelayedList+0x8c>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    152c:	80 91 2e 02 	lds	r24, 0x022E
    1530:	90 91 2f 02 	lds	r25, 0x022F
    1534:	9c 01       	movw	r18, r24
    1536:	2e 5f       	subi	r18, 0xFE	; 254
    1538:	3f 4f       	sbci	r19, 0xFF	; 255
    153a:	80 91 66 02 	lds	r24, 0x0266
    153e:	90 91 67 02 	lds	r25, 0x0267
    1542:	b9 01       	movw	r22, r18
    1544:	0e 94 a9 12 	call	0x2552	; 0x2552 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    1548:	80 91 00 02 	lds	r24, 0x0200
    154c:	90 91 01 02 	lds	r25, 0x0201
    1550:	29 81       	ldd	r18, Y+1	; 0x01
    1552:	3a 81       	ldd	r19, Y+2	; 0x02
    1554:	28 17       	cp	r18, r24
    1556:	39 07       	cpc	r19, r25
    1558:	30 f4       	brcc	.+12     	; 0x1566 <prvAddCurrentTaskToDelayedList+0x8c>
		{
			xNextTaskUnblockTime = xTimeToWake;
    155a:	89 81       	ldd	r24, Y+1	; 0x01
    155c:	9a 81       	ldd	r25, Y+2	; 0x02
    155e:	90 93 01 02 	sts	0x0201, r25
    1562:	80 93 00 02 	sts	0x0200, r24
		}
	}
}
    1566:	0f 90       	pop	r0
    1568:	0f 90       	pop	r0
    156a:	df 91       	pop	r29
    156c:	cf 91       	pop	r28
    156e:	08 95       	ret

00001570 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    1570:	cf 93       	push	r28
    1572:	df 93       	push	r29
    1574:	00 d0       	rcall	.+0      	; 0x1576 <prvAllocateTCBAndStack+0x6>
    1576:	00 d0       	rcall	.+0      	; 0x1578 <prvAllocateTCBAndStack+0x8>
    1578:	cd b7       	in	r28, 0x3d	; 61
    157a:	de b7       	in	r29, 0x3e	; 62
    157c:	9c 83       	std	Y+4, r25	; 0x04
    157e:	8b 83       	std	Y+3, r24	; 0x03
    1580:	7e 83       	std	Y+6, r23	; 0x06
    1582:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    1584:	8a e2       	ldi	r24, 0x2A	; 42
    1586:	90 e0       	ldi	r25, 0x00	; 0
    1588:	0e 94 71 16 	call	0x2ce2	; 0x2ce2 <pvPortMalloc>
    158c:	9a 83       	std	Y+2, r25	; 0x02
    158e:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    1590:	89 81       	ldd	r24, Y+1	; 0x01
    1592:	9a 81       	ldd	r25, Y+2	; 0x02
    1594:	00 97       	sbiw	r24, 0x00	; 0
    1596:	51 f1       	breq	.+84     	; 0x15ec <prvAllocateTCBAndStack+0x7c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    1598:	8d 81       	ldd	r24, Y+5	; 0x05
    159a:	9e 81       	ldd	r25, Y+6	; 0x06
    159c:	00 97       	sbiw	r24, 0x00	; 0
    159e:	29 f4       	brne	.+10     	; 0x15aa <prvAllocateTCBAndStack+0x3a>
    15a0:	8b 81       	ldd	r24, Y+3	; 0x03
    15a2:	9c 81       	ldd	r25, Y+4	; 0x04
    15a4:	0e 94 71 16 	call	0x2ce2	; 0x2ce2 <pvPortMalloc>
    15a8:	02 c0       	rjmp	.+4      	; 0x15ae <prvAllocateTCBAndStack+0x3e>
    15aa:	8d 81       	ldd	r24, Y+5	; 0x05
    15ac:	9e 81       	ldd	r25, Y+6	; 0x06
    15ae:	29 81       	ldd	r18, Y+1	; 0x01
    15b0:	3a 81       	ldd	r19, Y+2	; 0x02
    15b2:	f9 01       	movw	r30, r18
    15b4:	90 8f       	std	Z+24, r25	; 0x18
    15b6:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    15b8:	89 81       	ldd	r24, Y+1	; 0x01
    15ba:	9a 81       	ldd	r25, Y+2	; 0x02
    15bc:	fc 01       	movw	r30, r24
    15be:	87 89       	ldd	r24, Z+23	; 0x17
    15c0:	90 8d       	ldd	r25, Z+24	; 0x18
    15c2:	00 97       	sbiw	r24, 0x00	; 0
    15c4:	39 f4       	brne	.+14     	; 0x15d4 <prvAllocateTCBAndStack+0x64>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    15c6:	89 81       	ldd	r24, Y+1	; 0x01
    15c8:	9a 81       	ldd	r25, Y+2	; 0x02
    15ca:	0e 94 b7 16 	call	0x2d6e	; 0x2d6e <vPortFree>
			pxNewTCB = NULL;
    15ce:	1a 82       	std	Y+2, r1	; 0x02
    15d0:	19 82       	std	Y+1, r1	; 0x01
    15d2:	0c c0       	rjmp	.+24     	; 0x15ec <prvAllocateTCBAndStack+0x7c>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    15d4:	89 81       	ldd	r24, Y+1	; 0x01
    15d6:	9a 81       	ldd	r25, Y+2	; 0x02
    15d8:	fc 01       	movw	r30, r24
    15da:	87 89       	ldd	r24, Z+23	; 0x17
    15dc:	90 8d       	ldd	r25, Z+24	; 0x18
    15de:	2b 81       	ldd	r18, Y+3	; 0x03
    15e0:	3c 81       	ldd	r19, Y+4	; 0x04
    15e2:	a9 01       	movw	r20, r18
    15e4:	65 ea       	ldi	r22, 0xA5	; 165
    15e6:	70 e0       	ldi	r23, 0x00	; 0
    15e8:	0e 94 db 23 	call	0x47b6	; 0x47b6 <memset>
		}
	}

	return pxNewTCB;
    15ec:	89 81       	ldd	r24, Y+1	; 0x01
    15ee:	9a 81       	ldd	r25, Y+2	; 0x02
}
    15f0:	26 96       	adiw	r28, 0x06	; 6
    15f2:	0f b6       	in	r0, 0x3f	; 63
    15f4:	f8 94       	cli
    15f6:	de bf       	out	0x3e, r29	; 62
    15f8:	0f be       	out	0x3f, r0	; 63
    15fa:	cd bf       	out	0x3d, r28	; 61
    15fc:	df 91       	pop	r29
    15fe:	cf 91       	pop	r28
    1600:	08 95       	ret

00001602 <usTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
    1602:	0f 93       	push	r16
    1604:	1f 93       	push	r17
    1606:	cf 93       	push	r28
    1608:	df 93       	push	r29
    160a:	1f 92       	push	r1
    160c:	1f 92       	push	r1
    160e:	cd b7       	in	r28, 0x3d	; 61
    1610:	de b7       	in	r29, 0x3e	; 62
    1612:	9a 83       	std	Y+2, r25	; 0x02
    1614:	89 83       	std	Y+1, r24	; 0x01
	register unsigned short usCount = 0U;
    1616:	00 e0       	ldi	r16, 0x00	; 0
    1618:	10 e0       	ldi	r17, 0x00	; 0

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    161a:	09 c0       	rjmp	.+18     	; 0x162e <usTaskCheckFreeStackSpace+0x2c>
		{
			pucStackByte -= portSTACK_GROWTH;
    161c:	89 81       	ldd	r24, Y+1	; 0x01
    161e:	9a 81       	ldd	r25, Y+2	; 0x02
    1620:	01 96       	adiw	r24, 0x01	; 1
    1622:	9a 83       	std	Y+2, r25	; 0x02
    1624:	89 83       	std	Y+1, r24	; 0x01
			usCount++;
    1626:	c8 01       	movw	r24, r16
    1628:	8c 01       	movw	r16, r24
    162a:	0f 5f       	subi	r16, 0xFF	; 255
    162c:	1f 4f       	sbci	r17, 0xFF	; 255

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    162e:	89 81       	ldd	r24, Y+1	; 0x01
    1630:	9a 81       	ldd	r25, Y+2	; 0x02
    1632:	fc 01       	movw	r30, r24
    1634:	80 81       	ld	r24, Z
    1636:	85 3a       	cpi	r24, 0xA5	; 165
    1638:	89 f3       	breq	.-30     	; 0x161c <usTaskCheckFreeStackSpace+0x1a>
			usCount++;
		}

		usCount /= sizeof( portSTACK_TYPE );

		return usCount;
    163a:	c8 01       	movw	r24, r16
	}
    163c:	0f 90       	pop	r0
    163e:	0f 90       	pop	r0
    1640:	df 91       	pop	r29
    1642:	cf 91       	pop	r28
    1644:	1f 91       	pop	r17
    1646:	0f 91       	pop	r16
    1648:	08 95       	ret

0000164a <uxTaskGetStackHighWaterMark>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
	{
    164a:	cf 93       	push	r28
    164c:	df 93       	push	r29
    164e:	cd b7       	in	r28, 0x3d	; 61
    1650:	de b7       	in	r29, 0x3e	; 62
    1652:	27 97       	sbiw	r28, 0x07	; 7
    1654:	0f b6       	in	r0, 0x3f	; 63
    1656:	f8 94       	cli
    1658:	de bf       	out	0x3e, r29	; 62
    165a:	0f be       	out	0x3f, r0	; 63
    165c:	cd bf       	out	0x3d, r28	; 61
    165e:	9f 83       	std	Y+7, r25	; 0x07
    1660:	8e 83       	std	Y+6, r24	; 0x06
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    1662:	8e 81       	ldd	r24, Y+6	; 0x06
    1664:	9f 81       	ldd	r25, Y+7	; 0x07
    1666:	00 97       	sbiw	r24, 0x00	; 0
    1668:	29 f4       	brne	.+10     	; 0x1674 <uxTaskGetStackHighWaterMark+0x2a>
    166a:	80 91 2e 02 	lds	r24, 0x022E
    166e:	90 91 2f 02 	lds	r25, 0x022F
    1672:	02 c0       	rjmp	.+4      	; 0x1678 <uxTaskGetStackHighWaterMark+0x2e>
    1674:	8e 81       	ldd	r24, Y+6	; 0x06
    1676:	9f 81       	ldd	r25, Y+7	; 0x07
    1678:	9a 83       	std	Y+2, r25	; 0x02
    167a:	89 83       	std	Y+1, r24	; 0x01

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    167c:	89 81       	ldd	r24, Y+1	; 0x01
    167e:	9a 81       	ldd	r25, Y+2	; 0x02
    1680:	fc 01       	movw	r30, r24
    1682:	87 89       	ldd	r24, Z+23	; 0x17
    1684:	90 8d       	ldd	r25, Z+24	; 0x18
    1686:	9c 83       	std	Y+4, r25	; 0x04
    1688:	8b 83       	std	Y+3, r24	; 0x03
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
		}
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
    168a:	8b 81       	ldd	r24, Y+3	; 0x03
    168c:	9c 81       	ldd	r25, Y+4	; 0x04
    168e:	0e 94 01 0b 	call	0x1602	; 0x1602 <usTaskCheckFreeStackSpace>
    1692:	8d 83       	std	Y+5, r24	; 0x05

		return uxReturn;
    1694:	8d 81       	ldd	r24, Y+5	; 0x05
	}
    1696:	27 96       	adiw	r28, 0x07	; 7
    1698:	0f b6       	in	r0, 0x3f	; 63
    169a:	f8 94       	cli
    169c:	de bf       	out	0x3e, r29	; 62
    169e:	0f be       	out	0x3f, r0	; 63
    16a0:	cd bf       	out	0x3d, r28	; 61
    16a2:	df 91       	pop	r29
    16a4:	cf 91       	pop	r28
    16a6:	08 95       	ret

000016a8 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	xTaskHandle xTaskGetCurrentTaskHandle( void )
	{
    16a8:	cf 93       	push	r28
    16aa:	df 93       	push	r29
    16ac:	1f 92       	push	r1
    16ae:	1f 92       	push	r1
    16b0:	cd b7       	in	r28, 0x3d	; 61
    16b2:	de b7       	in	r29, 0x3e	; 62
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    16b4:	80 91 2e 02 	lds	r24, 0x022E
    16b8:	90 91 2f 02 	lds	r25, 0x022F
    16bc:	9a 83       	std	Y+2, r25	; 0x02
    16be:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    16c0:	89 81       	ldd	r24, Y+1	; 0x01
    16c2:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    16c4:	0f 90       	pop	r0
    16c6:	0f 90       	pop	r0
    16c8:	df 91       	pop	r29
    16ca:	cf 91       	pop	r28
    16cc:	08 95       	ret

000016ce <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    16ce:	cf 93       	push	r28
    16d0:	df 93       	push	r29
    16d2:	00 d0       	rcall	.+0      	; 0x16d4 <vTaskPriorityInherit+0x6>
    16d4:	1f 92       	push	r1
    16d6:	cd b7       	in	r28, 0x3d	; 61
    16d8:	de b7       	in	r29, 0x3e	; 62
    16da:	9c 83       	std	Y+4, r25	; 0x04
    16dc:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
    16de:	8b 81       	ldd	r24, Y+3	; 0x03
    16e0:	9c 81       	ldd	r25, Y+4	; 0x04
    16e2:	9a 83       	std	Y+2, r25	; 0x02
    16e4:	89 83       	std	Y+1, r24	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    16e6:	8b 81       	ldd	r24, Y+3	; 0x03
    16e8:	9c 81       	ldd	r25, Y+4	; 0x04
    16ea:	00 97       	sbiw	r24, 0x00	; 0
    16ec:	09 f4       	brne	.+2      	; 0x16f0 <vTaskPriorityInherit+0x22>
    16ee:	78 c0       	rjmp	.+240    	; 0x17e0 <vTaskPriorityInherit+0x112>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    16f0:	89 81       	ldd	r24, Y+1	; 0x01
    16f2:	9a 81       	ldd	r25, Y+2	; 0x02
    16f4:	fc 01       	movw	r30, r24
    16f6:	26 89       	ldd	r18, Z+22	; 0x16
    16f8:	80 91 2e 02 	lds	r24, 0x022E
    16fc:	90 91 2f 02 	lds	r25, 0x022F
    1700:	fc 01       	movw	r30, r24
    1702:	86 89       	ldd	r24, Z+22	; 0x16
    1704:	28 17       	cp	r18, r24
    1706:	08 f0       	brcs	.+2      	; 0x170a <vTaskPriorityInherit+0x3c>
    1708:	6b c0       	rjmp	.+214    	; 0x17e0 <vTaskPriorityInherit+0x112>
			{
				/* Adjust the mutex holder state to account for its new priority. */
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    170a:	80 91 2e 02 	lds	r24, 0x022E
    170e:	90 91 2f 02 	lds	r25, 0x022F
    1712:	fc 01       	movw	r30, r24
    1714:	86 89       	ldd	r24, Z+22	; 0x16
    1716:	88 2f       	mov	r24, r24
    1718:	90 e0       	ldi	r25, 0x00	; 0
    171a:	24 e0       	ldi	r18, 0x04	; 4
    171c:	30 e0       	ldi	r19, 0x00	; 0
    171e:	28 1b       	sub	r18, r24
    1720:	39 0b       	sbc	r19, r25
    1722:	89 81       	ldd	r24, Y+1	; 0x01
    1724:	9a 81       	ldd	r25, Y+2	; 0x02
    1726:	fc 01       	movw	r30, r24
    1728:	35 87       	std	Z+13, r19	; 0x0d
    172a:	24 87       	std	Z+12, r18	; 0x0c

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    172c:	89 81       	ldd	r24, Y+1	; 0x01
    172e:	9a 81       	ldd	r25, Y+2	; 0x02
    1730:	fc 01       	movw	r30, r24
    1732:	42 85       	ldd	r20, Z+10	; 0x0a
    1734:	53 85       	ldd	r21, Z+11	; 0x0b
    1736:	89 81       	ldd	r24, Y+1	; 0x01
    1738:	9a 81       	ldd	r25, Y+2	; 0x02
    173a:	fc 01       	movw	r30, r24
    173c:	86 89       	ldd	r24, Z+22	; 0x16
    173e:	28 2f       	mov	r18, r24
    1740:	30 e0       	ldi	r19, 0x00	; 0
    1742:	c9 01       	movw	r24, r18
    1744:	88 0f       	add	r24, r24
    1746:	99 1f       	adc	r25, r25
    1748:	88 0f       	add	r24, r24
    174a:	99 1f       	adc	r25, r25
    174c:	88 0f       	add	r24, r24
    174e:	99 1f       	adc	r25, r25
    1750:	82 0f       	add	r24, r18
    1752:	93 1f       	adc	r25, r19
    1754:	80 5d       	subi	r24, 0xD0	; 208
    1756:	9d 4f       	sbci	r25, 0xFD	; 253
    1758:	48 17       	cp	r20, r24
    175a:	59 07       	cpc	r21, r25
    175c:	b9 f5       	brne	.+110    	; 0x17cc <vTaskPriorityInherit+0xfe>
				{
					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    175e:	89 81       	ldd	r24, Y+1	; 0x01
    1760:	9a 81       	ldd	r25, Y+2	; 0x02
    1762:	02 96       	adiw	r24, 0x02	; 2
    1764:	0e 94 22 13 	call	0x2644	; 0x2644 <uxListRemove>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    1768:	80 91 2e 02 	lds	r24, 0x022E
    176c:	90 91 2f 02 	lds	r25, 0x022F
    1770:	fc 01       	movw	r30, r24
    1772:	26 89       	ldd	r18, Z+22	; 0x16
    1774:	89 81       	ldd	r24, Y+1	; 0x01
    1776:	9a 81       	ldd	r25, Y+2	; 0x02
    1778:	fc 01       	movw	r30, r24
    177a:	26 8b       	std	Z+22, r18	; 0x16
					prvAddTaskToReadyQueue( pxTCB );
    177c:	89 81       	ldd	r24, Y+1	; 0x01
    177e:	9a 81       	ldd	r25, Y+2	; 0x02
    1780:	fc 01       	movw	r30, r24
    1782:	96 89       	ldd	r25, Z+22	; 0x16
    1784:	80 91 80 02 	lds	r24, 0x0280
    1788:	89 17       	cp	r24, r25
    178a:	30 f4       	brcc	.+12     	; 0x1798 <vTaskPriorityInherit+0xca>
    178c:	89 81       	ldd	r24, Y+1	; 0x01
    178e:	9a 81       	ldd	r25, Y+2	; 0x02
    1790:	fc 01       	movw	r30, r24
    1792:	86 89       	ldd	r24, Z+22	; 0x16
    1794:	80 93 80 02 	sts	0x0280, r24
    1798:	89 81       	ldd	r24, Y+1	; 0x01
    179a:	9a 81       	ldd	r25, Y+2	; 0x02
    179c:	ac 01       	movw	r20, r24
    179e:	4e 5f       	subi	r20, 0xFE	; 254
    17a0:	5f 4f       	sbci	r21, 0xFF	; 255
    17a2:	89 81       	ldd	r24, Y+1	; 0x01
    17a4:	9a 81       	ldd	r25, Y+2	; 0x02
    17a6:	fc 01       	movw	r30, r24
    17a8:	86 89       	ldd	r24, Z+22	; 0x16
    17aa:	28 2f       	mov	r18, r24
    17ac:	30 e0       	ldi	r19, 0x00	; 0
    17ae:	c9 01       	movw	r24, r18
    17b0:	88 0f       	add	r24, r24
    17b2:	99 1f       	adc	r25, r25
    17b4:	88 0f       	add	r24, r24
    17b6:	99 1f       	adc	r25, r25
    17b8:	88 0f       	add	r24, r24
    17ba:	99 1f       	adc	r25, r25
    17bc:	82 0f       	add	r24, r18
    17be:	93 1f       	adc	r25, r19
    17c0:	80 5d       	subi	r24, 0xD0	; 208
    17c2:	9d 4f       	sbci	r25, 0xFD	; 253
    17c4:	ba 01       	movw	r22, r20
    17c6:	0e 94 52 12 	call	0x24a4	; 0x24a4 <vListInsertEnd>
    17ca:	0a c0       	rjmp	.+20     	; 0x17e0 <vTaskPriorityInherit+0x112>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    17cc:	80 91 2e 02 	lds	r24, 0x022E
    17d0:	90 91 2f 02 	lds	r25, 0x022F
    17d4:	fc 01       	movw	r30, r24
    17d6:	26 89       	ldd	r18, Z+22	; 0x16
    17d8:	89 81       	ldd	r24, Y+1	; 0x01
    17da:	9a 81       	ldd	r25, Y+2	; 0x02
    17dc:	fc 01       	movw	r30, r24
    17de:	26 8b       	std	Z+22, r18	; 0x16
				}

				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
			}
		}
	}
    17e0:	0f 90       	pop	r0
    17e2:	0f 90       	pop	r0
    17e4:	0f 90       	pop	r0
    17e6:	0f 90       	pop	r0
    17e8:	df 91       	pop	r29
    17ea:	cf 91       	pop	r28
    17ec:	08 95       	ret

000017ee <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    17ee:	cf 93       	push	r28
    17f0:	df 93       	push	r29
    17f2:	00 d0       	rcall	.+0      	; 0x17f4 <vTaskPriorityDisinherit+0x6>
    17f4:	1f 92       	push	r1
    17f6:	cd b7       	in	r28, 0x3d	; 61
    17f8:	de b7       	in	r29, 0x3e	; 62
    17fa:	9c 83       	std	Y+4, r25	; 0x04
    17fc:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
    17fe:	8b 81       	ldd	r24, Y+3	; 0x03
    1800:	9c 81       	ldd	r25, Y+4	; 0x04
    1802:	9a 83       	std	Y+2, r25	; 0x02
    1804:	89 83       	std	Y+1, r24	; 0x01

		if( pxMutexHolder != NULL )
    1806:	8b 81       	ldd	r24, Y+3	; 0x03
    1808:	9c 81       	ldd	r25, Y+4	; 0x04
    180a:	00 97       	sbiw	r24, 0x00	; 0
    180c:	09 f4       	brne	.+2      	; 0x1810 <vTaskPriorityDisinherit+0x22>
    180e:	4e c0       	rjmp	.+156    	; 0x18ac <vTaskPriorityDisinherit+0xbe>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    1810:	89 81       	ldd	r24, Y+1	; 0x01
    1812:	9a 81       	ldd	r25, Y+2	; 0x02
    1814:	fc 01       	movw	r30, r24
    1816:	26 89       	ldd	r18, Z+22	; 0x16
    1818:	89 81       	ldd	r24, Y+1	; 0x01
    181a:	9a 81       	ldd	r25, Y+2	; 0x02
    181c:	fc 01       	movw	r30, r24
    181e:	81 a5       	ldd	r24, Z+41	; 0x29
    1820:	28 17       	cp	r18, r24
    1822:	09 f4       	brne	.+2      	; 0x1826 <vTaskPriorityDisinherit+0x38>
    1824:	43 c0       	rjmp	.+134    	; 0x18ac <vTaskPriorityDisinherit+0xbe>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    1826:	89 81       	ldd	r24, Y+1	; 0x01
    1828:	9a 81       	ldd	r25, Y+2	; 0x02
    182a:	02 96       	adiw	r24, 0x02	; 2
    182c:	0e 94 22 13 	call	0x2644	; 0x2644 <uxListRemove>
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    1830:	89 81       	ldd	r24, Y+1	; 0x01
    1832:	9a 81       	ldd	r25, Y+2	; 0x02
    1834:	fc 01       	movw	r30, r24
    1836:	21 a5       	ldd	r18, Z+41	; 0x29
    1838:	89 81       	ldd	r24, Y+1	; 0x01
    183a:	9a 81       	ldd	r25, Y+2	; 0x02
    183c:	fc 01       	movw	r30, r24
    183e:	26 8b       	std	Z+22, r18	; 0x16
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    1840:	89 81       	ldd	r24, Y+1	; 0x01
    1842:	9a 81       	ldd	r25, Y+2	; 0x02
    1844:	fc 01       	movw	r30, r24
    1846:	86 89       	ldd	r24, Z+22	; 0x16
    1848:	88 2f       	mov	r24, r24
    184a:	90 e0       	ldi	r25, 0x00	; 0
    184c:	24 e0       	ldi	r18, 0x04	; 4
    184e:	30 e0       	ldi	r19, 0x00	; 0
    1850:	28 1b       	sub	r18, r24
    1852:	39 0b       	sbc	r19, r25
    1854:	89 81       	ldd	r24, Y+1	; 0x01
    1856:	9a 81       	ldd	r25, Y+2	; 0x02
    1858:	fc 01       	movw	r30, r24
    185a:	35 87       	std	Z+13, r19	; 0x0d
    185c:	24 87       	std	Z+12, r18	; 0x0c
				prvAddTaskToReadyQueue( pxTCB );
    185e:	89 81       	ldd	r24, Y+1	; 0x01
    1860:	9a 81       	ldd	r25, Y+2	; 0x02
    1862:	fc 01       	movw	r30, r24
    1864:	96 89       	ldd	r25, Z+22	; 0x16
    1866:	80 91 80 02 	lds	r24, 0x0280
    186a:	89 17       	cp	r24, r25
    186c:	30 f4       	brcc	.+12     	; 0x187a <vTaskPriorityDisinherit+0x8c>
    186e:	89 81       	ldd	r24, Y+1	; 0x01
    1870:	9a 81       	ldd	r25, Y+2	; 0x02
    1872:	fc 01       	movw	r30, r24
    1874:	86 89       	ldd	r24, Z+22	; 0x16
    1876:	80 93 80 02 	sts	0x0280, r24
    187a:	89 81       	ldd	r24, Y+1	; 0x01
    187c:	9a 81       	ldd	r25, Y+2	; 0x02
    187e:	ac 01       	movw	r20, r24
    1880:	4e 5f       	subi	r20, 0xFE	; 254
    1882:	5f 4f       	sbci	r21, 0xFF	; 255
    1884:	89 81       	ldd	r24, Y+1	; 0x01
    1886:	9a 81       	ldd	r25, Y+2	; 0x02
    1888:	fc 01       	movw	r30, r24
    188a:	86 89       	ldd	r24, Z+22	; 0x16
    188c:	28 2f       	mov	r18, r24
    188e:	30 e0       	ldi	r19, 0x00	; 0
    1890:	c9 01       	movw	r24, r18
    1892:	88 0f       	add	r24, r24
    1894:	99 1f       	adc	r25, r25
    1896:	88 0f       	add	r24, r24
    1898:	99 1f       	adc	r25, r25
    189a:	88 0f       	add	r24, r24
    189c:	99 1f       	adc	r25, r25
    189e:	82 0f       	add	r24, r18
    18a0:	93 1f       	adc	r25, r19
    18a2:	80 5d       	subi	r24, 0xD0	; 208
    18a4:	9d 4f       	sbci	r25, 0xFD	; 253
    18a6:	ba 01       	movw	r22, r20
    18a8:	0e 94 52 12 	call	0x24a4	; 0x24a4 <vListInsertEnd>
			}
		}
	}
    18ac:	0f 90       	pop	r0
    18ae:	0f 90       	pop	r0
    18b0:	0f 90       	pop	r0
    18b2:	0f 90       	pop	r0
    18b4:	df 91       	pop	r29
    18b6:	cf 91       	pop	r28
    18b8:	08 95       	ret

000018ba <xQueueGenericReset>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle pxQueue, portBASE_TYPE xNewQueue )
{
    18ba:	cf 93       	push	r28
    18bc:	df 93       	push	r29
    18be:	00 d0       	rcall	.+0      	; 0x18c0 <xQueueGenericReset+0x6>
    18c0:	cd b7       	in	r28, 0x3d	; 61
    18c2:	de b7       	in	r29, 0x3e	; 62
    18c4:	9a 83       	std	Y+2, r25	; 0x02
    18c6:	89 83       	std	Y+1, r24	; 0x01
    18c8:	6b 83       	std	Y+3, r22	; 0x03
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    18ca:	0f b6       	in	r0, 0x3f	; 63
    18cc:	f8 94       	cli
    18ce:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    18d0:	89 81       	ldd	r24, Y+1	; 0x01
    18d2:	9a 81       	ldd	r25, Y+2	; 0x02
    18d4:	fc 01       	movw	r30, r24
    18d6:	20 81       	ld	r18, Z
    18d8:	31 81       	ldd	r19, Z+1	; 0x01
    18da:	89 81       	ldd	r24, Y+1	; 0x01
    18dc:	9a 81       	ldd	r25, Y+2	; 0x02
    18de:	fc 01       	movw	r30, r24
    18e0:	83 8d       	ldd	r24, Z+27	; 0x1b
    18e2:	68 2f       	mov	r22, r24
    18e4:	70 e0       	ldi	r23, 0x00	; 0
    18e6:	89 81       	ldd	r24, Y+1	; 0x01
    18e8:	9a 81       	ldd	r25, Y+2	; 0x02
    18ea:	fc 01       	movw	r30, r24
    18ec:	84 8d       	ldd	r24, Z+28	; 0x1c
    18ee:	48 2f       	mov	r20, r24
    18f0:	50 e0       	ldi	r21, 0x00	; 0
    18f2:	64 9f       	mul	r22, r20
    18f4:	c0 01       	movw	r24, r0
    18f6:	65 9f       	mul	r22, r21
    18f8:	90 0d       	add	r25, r0
    18fa:	74 9f       	mul	r23, r20
    18fc:	90 0d       	add	r25, r0
    18fe:	11 24       	eor	r1, r1
    1900:	28 0f       	add	r18, r24
    1902:	39 1f       	adc	r19, r25
    1904:	89 81       	ldd	r24, Y+1	; 0x01
    1906:	9a 81       	ldd	r25, Y+2	; 0x02
    1908:	fc 01       	movw	r30, r24
    190a:	33 83       	std	Z+3, r19	; 0x03
    190c:	22 83       	std	Z+2, r18	; 0x02
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    190e:	89 81       	ldd	r24, Y+1	; 0x01
    1910:	9a 81       	ldd	r25, Y+2	; 0x02
    1912:	fc 01       	movw	r30, r24
    1914:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1916:	89 81       	ldd	r24, Y+1	; 0x01
    1918:	9a 81       	ldd	r25, Y+2	; 0x02
    191a:	fc 01       	movw	r30, r24
    191c:	20 81       	ld	r18, Z
    191e:	31 81       	ldd	r19, Z+1	; 0x01
    1920:	89 81       	ldd	r24, Y+1	; 0x01
    1922:	9a 81       	ldd	r25, Y+2	; 0x02
    1924:	fc 01       	movw	r30, r24
    1926:	35 83       	std	Z+5, r19	; 0x05
    1928:	24 83       	std	Z+4, r18	; 0x04
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
    192a:	89 81       	ldd	r24, Y+1	; 0x01
    192c:	9a 81       	ldd	r25, Y+2	; 0x02
    192e:	fc 01       	movw	r30, r24
    1930:	20 81       	ld	r18, Z
    1932:	31 81       	ldd	r19, Z+1	; 0x01
    1934:	89 81       	ldd	r24, Y+1	; 0x01
    1936:	9a 81       	ldd	r25, Y+2	; 0x02
    1938:	fc 01       	movw	r30, r24
    193a:	83 8d       	ldd	r24, Z+27	; 0x1b
    193c:	88 2f       	mov	r24, r24
    193e:	90 e0       	ldi	r25, 0x00	; 0
    1940:	bc 01       	movw	r22, r24
    1942:	61 50       	subi	r22, 0x01	; 1
    1944:	71 09       	sbc	r23, r1
    1946:	89 81       	ldd	r24, Y+1	; 0x01
    1948:	9a 81       	ldd	r25, Y+2	; 0x02
    194a:	fc 01       	movw	r30, r24
    194c:	84 8d       	ldd	r24, Z+28	; 0x1c
    194e:	48 2f       	mov	r20, r24
    1950:	50 e0       	ldi	r21, 0x00	; 0
    1952:	64 9f       	mul	r22, r20
    1954:	c0 01       	movw	r24, r0
    1956:	65 9f       	mul	r22, r21
    1958:	90 0d       	add	r25, r0
    195a:	74 9f       	mul	r23, r20
    195c:	90 0d       	add	r25, r0
    195e:	11 24       	eor	r1, r1
    1960:	28 0f       	add	r18, r24
    1962:	39 1f       	adc	r19, r25
    1964:	89 81       	ldd	r24, Y+1	; 0x01
    1966:	9a 81       	ldd	r25, Y+2	; 0x02
    1968:	fc 01       	movw	r30, r24
    196a:	37 83       	std	Z+7, r19	; 0x07
    196c:	26 83       	std	Z+6, r18	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    196e:	89 81       	ldd	r24, Y+1	; 0x01
    1970:	9a 81       	ldd	r25, Y+2	; 0x02
    1972:	2f ef       	ldi	r18, 0xFF	; 255
    1974:	fc 01       	movw	r30, r24
    1976:	25 8f       	std	Z+29, r18	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    1978:	89 81       	ldd	r24, Y+1	; 0x01
    197a:	9a 81       	ldd	r25, Y+2	; 0x02
    197c:	2f ef       	ldi	r18, 0xFF	; 255
    197e:	fc 01       	movw	r30, r24
    1980:	26 8f       	std	Z+30, r18	; 0x1e

		if( xNewQueue == pdFALSE )
    1982:	8b 81       	ldd	r24, Y+3	; 0x03
    1984:	88 23       	and	r24, r24
    1986:	81 f4       	brne	.+32     	; 0x19a8 <xQueueGenericReset+0xee>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to	write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1988:	89 81       	ldd	r24, Y+1	; 0x01
    198a:	9a 81       	ldd	r25, Y+2	; 0x02
    198c:	fc 01       	movw	r30, r24
    198e:	80 85       	ldd	r24, Z+8	; 0x08
    1990:	88 23       	and	r24, r24
    1992:	a1 f0       	breq	.+40     	; 0x19bc <xQueueGenericReset+0x102>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1994:	89 81       	ldd	r24, Y+1	; 0x01
    1996:	9a 81       	ldd	r25, Y+2	; 0x02
    1998:	08 96       	adiw	r24, 0x08	; 8
    199a:	0e 94 b7 08 	call	0x116e	; 0x116e <xTaskRemoveFromEventList>
    199e:	81 30       	cpi	r24, 0x01	; 1
    19a0:	69 f4       	brne	.+26     	; 0x19bc <xQueueGenericReset+0x102>
				{
					portYIELD_WITHIN_API();
    19a2:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <vPortYield>
    19a6:	0a c0       	rjmp	.+20     	; 0x19bc <xQueueGenericReset+0x102>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    19a8:	89 81       	ldd	r24, Y+1	; 0x01
    19aa:	9a 81       	ldd	r25, Y+2	; 0x02
    19ac:	08 96       	adiw	r24, 0x08	; 8
    19ae:	0e 94 0a 12 	call	0x2414	; 0x2414 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    19b2:	89 81       	ldd	r24, Y+1	; 0x01
    19b4:	9a 81       	ldd	r25, Y+2	; 0x02
    19b6:	41 96       	adiw	r24, 0x11	; 17
    19b8:	0e 94 0a 12 	call	0x2414	; 0x2414 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    19bc:	0f 90       	pop	r0
    19be:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    19c0:	81 e0       	ldi	r24, 0x01	; 1
}
    19c2:	0f 90       	pop	r0
    19c4:	0f 90       	pop	r0
    19c6:	0f 90       	pop	r0
    19c8:	df 91       	pop	r29
    19ca:	cf 91       	pop	r28
    19cc:	08 95       	ret

000019ce <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
    19ce:	cf 93       	push	r28
    19d0:	df 93       	push	r29
    19d2:	cd b7       	in	r28, 0x3d	; 61
    19d4:	de b7       	in	r29, 0x3e	; 62
    19d6:	29 97       	sbiw	r28, 0x09	; 9
    19d8:	0f b6       	in	r0, 0x3f	; 63
    19da:	f8 94       	cli
    19dc:	de bf       	out	0x3e, r29	; 62
    19de:	0f be       	out	0x3f, r0	; 63
    19e0:	cd bf       	out	0x3d, r28	; 61
    19e2:	8f 83       	std	Y+7, r24	; 0x07
    19e4:	68 87       	std	Y+8, r22	; 0x08
    19e6:	49 87       	std	Y+9, r20	; 0x09
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    19e8:	1a 82       	std	Y+2, r1	; 0x02
    19ea:	19 82       	std	Y+1, r1	; 0x01
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    19ec:	8f 81       	ldd	r24, Y+7	; 0x07
    19ee:	88 23       	and	r24, r24
    19f0:	09 f4       	brne	.+2      	; 0x19f4 <xQueueGenericCreate+0x26>
    19f2:	43 c0       	rjmp	.+134    	; 0x1a7a <xQueueGenericCreate+0xac>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    19f4:	8f e1       	ldi	r24, 0x1F	; 31
    19f6:	90 e0       	ldi	r25, 0x00	; 0
    19f8:	0e 94 71 16 	call	0x2ce2	; 0x2ce2 <pvPortMalloc>
    19fc:	9c 83       	std	Y+4, r25	; 0x04
    19fe:	8b 83       	std	Y+3, r24	; 0x03
		if( pxNewQueue != NULL )
    1a00:	8b 81       	ldd	r24, Y+3	; 0x03
    1a02:	9c 81       	ldd	r25, Y+4	; 0x04
    1a04:	00 97       	sbiw	r24, 0x00	; 0
    1a06:	c9 f1       	breq	.+114    	; 0x1a7a <xQueueGenericCreate+0xac>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    1a08:	8f 81       	ldd	r24, Y+7	; 0x07
    1a0a:	48 2f       	mov	r20, r24
    1a0c:	50 e0       	ldi	r21, 0x00	; 0
    1a0e:	88 85       	ldd	r24, Y+8	; 0x08
    1a10:	28 2f       	mov	r18, r24
    1a12:	30 e0       	ldi	r19, 0x00	; 0
    1a14:	42 9f       	mul	r20, r18
    1a16:	c0 01       	movw	r24, r0
    1a18:	43 9f       	mul	r20, r19
    1a1a:	90 0d       	add	r25, r0
    1a1c:	52 9f       	mul	r21, r18
    1a1e:	90 0d       	add	r25, r0
    1a20:	11 24       	eor	r1, r1
    1a22:	01 96       	adiw	r24, 0x01	; 1
    1a24:	9e 83       	std	Y+6, r25	; 0x06
    1a26:	8d 83       	std	Y+5, r24	; 0x05

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    1a28:	8d 81       	ldd	r24, Y+5	; 0x05
    1a2a:	9e 81       	ldd	r25, Y+6	; 0x06
    1a2c:	0e 94 71 16 	call	0x2ce2	; 0x2ce2 <pvPortMalloc>
    1a30:	9c 01       	movw	r18, r24
    1a32:	8b 81       	ldd	r24, Y+3	; 0x03
    1a34:	9c 81       	ldd	r25, Y+4	; 0x04
    1a36:	fc 01       	movw	r30, r24
    1a38:	31 83       	std	Z+1, r19	; 0x01
    1a3a:	20 83       	st	Z, r18
			if( pxNewQueue->pcHead != NULL )
    1a3c:	8b 81       	ldd	r24, Y+3	; 0x03
    1a3e:	9c 81       	ldd	r25, Y+4	; 0x04
    1a40:	fc 01       	movw	r30, r24
    1a42:	80 81       	ld	r24, Z
    1a44:	91 81       	ldd	r25, Z+1	; 0x01
    1a46:	00 97       	sbiw	r24, 0x00	; 0
    1a48:	a1 f0       	breq	.+40     	; 0x1a72 <xQueueGenericCreate+0xa4>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    1a4a:	8b 81       	ldd	r24, Y+3	; 0x03
    1a4c:	9c 81       	ldd	r25, Y+4	; 0x04
    1a4e:	2f 81       	ldd	r18, Y+7	; 0x07
    1a50:	fc 01       	movw	r30, r24
    1a52:	23 8f       	std	Z+27, r18	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1a54:	8b 81       	ldd	r24, Y+3	; 0x03
    1a56:	9c 81       	ldd	r25, Y+4	; 0x04
    1a58:	28 85       	ldd	r18, Y+8	; 0x08
    1a5a:	fc 01       	movw	r30, r24
    1a5c:	24 8f       	std	Z+28, r18	; 0x1c
				xQueueGenericReset( pxNewQueue, pdTRUE );
    1a5e:	8b 81       	ldd	r24, Y+3	; 0x03
    1a60:	9c 81       	ldd	r25, Y+4	; 0x04
    1a62:	61 e0       	ldi	r22, 0x01	; 1
    1a64:	0e 94 5d 0c 	call	0x18ba	; 0x18ba <xQueueGenericReset>
					pxNewQueue->ucQueueType = ucQueueType;
				}
				#endif /* configUSE_TRACE_FACILITY */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    1a68:	8b 81       	ldd	r24, Y+3	; 0x03
    1a6a:	9c 81       	ldd	r25, Y+4	; 0x04
    1a6c:	9a 83       	std	Y+2, r25	; 0x02
    1a6e:	89 83       	std	Y+1, r24	; 0x01
    1a70:	04 c0       	rjmp	.+8      	; 0x1a7a <xQueueGenericCreate+0xac>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    1a72:	8b 81       	ldd	r24, Y+3	; 0x03
    1a74:	9c 81       	ldd	r25, Y+4	; 0x04
    1a76:	0e 94 b7 16 	call	0x2d6e	; 0x2d6e <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    1a7a:	89 81       	ldd	r24, Y+1	; 0x01
    1a7c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1a7e:	29 96       	adiw	r28, 0x09	; 9
    1a80:	0f b6       	in	r0, 0x3f	; 63
    1a82:	f8 94       	cli
    1a84:	de bf       	out	0x3e, r29	; 62
    1a86:	0f be       	out	0x3f, r0	; 63
    1a88:	cd bf       	out	0x3d, r28	; 61
    1a8a:	df 91       	pop	r29
    1a8c:	cf 91       	pop	r28
    1a8e:	08 95       	ret

00001a90 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
	{
    1a90:	cf 93       	push	r28
    1a92:	df 93       	push	r29
    1a94:	00 d0       	rcall	.+0      	; 0x1a96 <xQueueCreateMutex+0x6>
    1a96:	cd b7       	in	r28, 0x3d	; 61
    1a98:	de b7       	in	r29, 0x3e	; 62
    1a9a:	8b 83       	std	Y+3, r24	; 0x03
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    1a9c:	8f e1       	ldi	r24, 0x1F	; 31
    1a9e:	90 e0       	ldi	r25, 0x00	; 0
    1aa0:	0e 94 71 16 	call	0x2ce2	; 0x2ce2 <pvPortMalloc>
    1aa4:	9a 83       	std	Y+2, r25	; 0x02
    1aa6:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    1aa8:	89 81       	ldd	r24, Y+1	; 0x01
    1aaa:	9a 81       	ldd	r25, Y+2	; 0x02
    1aac:	00 97       	sbiw	r24, 0x00	; 0
    1aae:	f1 f1       	breq	.+124    	; 0x1b2c <xQueueCreateMutex+0x9c>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    1ab0:	89 81       	ldd	r24, Y+1	; 0x01
    1ab2:	9a 81       	ldd	r25, Y+2	; 0x02
    1ab4:	fc 01       	movw	r30, r24
    1ab6:	13 82       	std	Z+3, r1	; 0x03
    1ab8:	12 82       	std	Z+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    1aba:	89 81       	ldd	r24, Y+1	; 0x01
    1abc:	9a 81       	ldd	r25, Y+2	; 0x02
    1abe:	fc 01       	movw	r30, r24
    1ac0:	11 82       	std	Z+1, r1	; 0x01
    1ac2:	10 82       	st	Z, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    1ac4:	89 81       	ldd	r24, Y+1	; 0x01
    1ac6:	9a 81       	ldd	r25, Y+2	; 0x02
    1ac8:	fc 01       	movw	r30, r24
    1aca:	15 82       	std	Z+5, r1	; 0x05
    1acc:	14 82       	std	Z+4, r1	; 0x04
			pxNewQueue->pcReadFrom = NULL;
    1ace:	89 81       	ldd	r24, Y+1	; 0x01
    1ad0:	9a 81       	ldd	r25, Y+2	; 0x02
    1ad2:	fc 01       	movw	r30, r24
    1ad4:	17 82       	std	Z+7, r1	; 0x07
    1ad6:	16 82       	std	Z+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1ad8:	89 81       	ldd	r24, Y+1	; 0x01
    1ada:	9a 81       	ldd	r25, Y+2	; 0x02
    1adc:	fc 01       	movw	r30, r24
    1ade:	12 8e       	std	Z+26, r1	; 0x1a
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
    1ae0:	89 81       	ldd	r24, Y+1	; 0x01
    1ae2:	9a 81       	ldd	r25, Y+2	; 0x02
    1ae4:	21 e0       	ldi	r18, 0x01	; 1
    1ae6:	fc 01       	movw	r30, r24
    1ae8:	23 8f       	std	Z+27, r18	; 0x1b
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
    1aea:	89 81       	ldd	r24, Y+1	; 0x01
    1aec:	9a 81       	ldd	r25, Y+2	; 0x02
    1aee:	fc 01       	movw	r30, r24
    1af0:	14 8e       	std	Z+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    1af2:	89 81       	ldd	r24, Y+1	; 0x01
    1af4:	9a 81       	ldd	r25, Y+2	; 0x02
    1af6:	2f ef       	ldi	r18, 0xFF	; 255
    1af8:	fc 01       	movw	r30, r24
    1afa:	25 8f       	std	Z+29, r18	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    1afc:	89 81       	ldd	r24, Y+1	; 0x01
    1afe:	9a 81       	ldd	r25, Y+2	; 0x02
    1b00:	2f ef       	ldi	r18, 0xFF	; 255
    1b02:	fc 01       	movw	r30, r24
    1b04:	26 8f       	std	Z+30, r18	; 0x1e
				pxNewQueue->ucQueueType = ucQueueType;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1b06:	89 81       	ldd	r24, Y+1	; 0x01
    1b08:	9a 81       	ldd	r25, Y+2	; 0x02
    1b0a:	08 96       	adiw	r24, 0x08	; 8
    1b0c:	0e 94 0a 12 	call	0x2414	; 0x2414 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1b10:	89 81       	ldd	r24, Y+1	; 0x01
    1b12:	9a 81       	ldd	r25, Y+2	; 0x02
    1b14:	41 96       	adiw	r24, 0x11	; 17
    1b16:	0e 94 0a 12 	call	0x2414	; 0x2414 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
    1b1a:	89 81       	ldd	r24, Y+1	; 0x01
    1b1c:	9a 81       	ldd	r25, Y+2	; 0x02
    1b1e:	20 e0       	ldi	r18, 0x00	; 0
    1b20:	40 e0       	ldi	r20, 0x00	; 0
    1b22:	50 e0       	ldi	r21, 0x00	; 0
    1b24:	60 e0       	ldi	r22, 0x00	; 0
    1b26:	70 e0       	ldi	r23, 0x00	; 0
    1b28:	0e 94 9e 0d 	call	0x1b3c	; 0x1b3c <xQueueGenericSend>
		{
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
    1b2c:	89 81       	ldd	r24, Y+1	; 0x01
    1b2e:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    1b30:	0f 90       	pop	r0
    1b32:	0f 90       	pop	r0
    1b34:	0f 90       	pop	r0
    1b36:	df 91       	pop	r29
    1b38:	cf 91       	pop	r28
    1b3a:	08 95       	ret

00001b3c <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    1b3c:	cf 93       	push	r28
    1b3e:	df 93       	push	r29
    1b40:	cd b7       	in	r28, 0x3d	; 61
    1b42:	de b7       	in	r29, 0x3e	; 62
    1b44:	2b 97       	sbiw	r28, 0x0b	; 11
    1b46:	0f b6       	in	r0, 0x3f	; 63
    1b48:	f8 94       	cli
    1b4a:	de bf       	out	0x3e, r29	; 62
    1b4c:	0f be       	out	0x3f, r0	; 63
    1b4e:	cd bf       	out	0x3d, r28	; 61
    1b50:	9e 83       	std	Y+6, r25	; 0x06
    1b52:	8d 83       	std	Y+5, r24	; 0x05
    1b54:	78 87       	std	Y+8, r23	; 0x08
    1b56:	6f 83       	std	Y+7, r22	; 0x07
    1b58:	5a 87       	std	Y+10, r21	; 0x0a
    1b5a:	49 87       	std	Y+9, r20	; 0x09
    1b5c:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1b5e:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1b60:	0f b6       	in	r0, 0x3f	; 63
    1b62:	f8 94       	cli
    1b64:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1b66:	8d 81       	ldd	r24, Y+5	; 0x05
    1b68:	9e 81       	ldd	r25, Y+6	; 0x06
    1b6a:	fc 01       	movw	r30, r24
    1b6c:	22 8d       	ldd	r18, Z+26	; 0x1a
    1b6e:	8d 81       	ldd	r24, Y+5	; 0x05
    1b70:	9e 81       	ldd	r25, Y+6	; 0x06
    1b72:	fc 01       	movw	r30, r24
    1b74:	83 8d       	ldd	r24, Z+27	; 0x1b
    1b76:	28 17       	cp	r18, r24
    1b78:	d8 f4       	brcc	.+54     	; 0x1bb0 <xQueueGenericSend+0x74>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1b7a:	2f 81       	ldd	r18, Y+7	; 0x07
    1b7c:	38 85       	ldd	r19, Y+8	; 0x08
    1b7e:	8d 81       	ldd	r24, Y+5	; 0x05
    1b80:	9e 81       	ldd	r25, Y+6	; 0x06
    1b82:	4b 85       	ldd	r20, Y+11	; 0x0b
    1b84:	b9 01       	movw	r22, r18
    1b86:	0e 94 28 10 	call	0x2050	; 0x2050 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b8a:	8d 81       	ldd	r24, Y+5	; 0x05
    1b8c:	9e 81       	ldd	r25, Y+6	; 0x06
    1b8e:	fc 01       	movw	r30, r24
    1b90:	81 89       	ldd	r24, Z+17	; 0x11
    1b92:	88 23       	and	r24, r24
    1b94:	49 f0       	breq	.+18     	; 0x1ba8 <xQueueGenericSend+0x6c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1b96:	8d 81       	ldd	r24, Y+5	; 0x05
    1b98:	9e 81       	ldd	r25, Y+6	; 0x06
    1b9a:	41 96       	adiw	r24, 0x11	; 17
    1b9c:	0e 94 b7 08 	call	0x116e	; 0x116e <xTaskRemoveFromEventList>
    1ba0:	81 30       	cpi	r24, 0x01	; 1
    1ba2:	11 f4       	brne	.+4      	; 0x1ba8 <xQueueGenericSend+0x6c>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    1ba4:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    1ba8:	0f 90       	pop	r0
    1baa:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    1bac:	81 e0       	ldi	r24, 0x01	; 1
    1bae:	61 c0       	rjmp	.+194    	; 0x1c72 <xQueueGenericSend+0x136>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1bb0:	89 85       	ldd	r24, Y+9	; 0x09
    1bb2:	9a 85       	ldd	r25, Y+10	; 0x0a
    1bb4:	00 97       	sbiw	r24, 0x00	; 0
    1bb6:	21 f4       	brne	.+8      	; 0x1bc0 <xQueueGenericSend+0x84>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1bb8:	0f 90       	pop	r0
    1bba:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1bbc:	80 e0       	ldi	r24, 0x00	; 0
    1bbe:	59 c0       	rjmp	.+178    	; 0x1c72 <xQueueGenericSend+0x136>
				}
				else if( xEntryTimeSet == pdFALSE )
    1bc0:	89 81       	ldd	r24, Y+1	; 0x01
    1bc2:	88 23       	and	r24, r24
    1bc4:	31 f4       	brne	.+12     	; 0x1bd2 <xQueueGenericSend+0x96>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1bc6:	ce 01       	movw	r24, r28
    1bc8:	02 96       	adiw	r24, 0x02	; 2
    1bca:	0e 94 21 09 	call	0x1242	; 0x1242 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1bce:	81 e0       	ldi	r24, 0x01	; 1
    1bd0:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    1bd2:	0f 90       	pop	r0
    1bd4:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1bd6:	0e 94 43 06 	call	0xc86	; 0xc86 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1bda:	0f b6       	in	r0, 0x3f	; 63
    1bdc:	f8 94       	cli
    1bde:	0f 92       	push	r0
    1be0:	8d 81       	ldd	r24, Y+5	; 0x05
    1be2:	9e 81       	ldd	r25, Y+6	; 0x06
    1be4:	fc 01       	movw	r30, r24
    1be6:	85 8d       	ldd	r24, Z+29	; 0x1d
    1be8:	8f 3f       	cpi	r24, 0xFF	; 255
    1bea:	21 f4       	brne	.+8      	; 0x1bf4 <xQueueGenericSend+0xb8>
    1bec:	8d 81       	ldd	r24, Y+5	; 0x05
    1bee:	9e 81       	ldd	r25, Y+6	; 0x06
    1bf0:	fc 01       	movw	r30, r24
    1bf2:	15 8e       	std	Z+29, r1	; 0x1d
    1bf4:	8d 81       	ldd	r24, Y+5	; 0x05
    1bf6:	9e 81       	ldd	r25, Y+6	; 0x06
    1bf8:	fc 01       	movw	r30, r24
    1bfa:	86 8d       	ldd	r24, Z+30	; 0x1e
    1bfc:	8f 3f       	cpi	r24, 0xFF	; 255
    1bfe:	21 f4       	brne	.+8      	; 0x1c08 <xQueueGenericSend+0xcc>
    1c00:	8d 81       	ldd	r24, Y+5	; 0x05
    1c02:	9e 81       	ldd	r25, Y+6	; 0x06
    1c04:	fc 01       	movw	r30, r24
    1c06:	16 8e       	std	Z+30, r1	; 0x1e
    1c08:	0f 90       	pop	r0
    1c0a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1c0c:	9e 01       	movw	r18, r28
    1c0e:	27 5f       	subi	r18, 0xF7	; 247
    1c10:	3f 4f       	sbci	r19, 0xFF	; 255
    1c12:	ce 01       	movw	r24, r28
    1c14:	02 96       	adiw	r24, 0x02	; 2
    1c16:	b9 01       	movw	r22, r18
    1c18:	0e 94 3d 09 	call	0x127a	; 0x127a <xTaskCheckForTimeOut>
    1c1c:	88 23       	and	r24, r24
    1c1e:	01 f5       	brne	.+64     	; 0x1c60 <xQueueGenericSend+0x124>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1c20:	8d 81       	ldd	r24, Y+5	; 0x05
    1c22:	9e 81       	ldd	r25, Y+6	; 0x06
    1c24:	0e 94 cf 11 	call	0x239e	; 0x239e <prvIsQueueFull>
    1c28:	88 23       	and	r24, r24
    1c2a:	99 f0       	breq	.+38     	; 0x1c52 <xQueueGenericSend+0x116>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1c2c:	29 85       	ldd	r18, Y+9	; 0x09
    1c2e:	3a 85       	ldd	r19, Y+10	; 0x0a
    1c30:	8d 81       	ldd	r24, Y+5	; 0x05
    1c32:	9e 81       	ldd	r25, Y+6	; 0x06
    1c34:	08 96       	adiw	r24, 0x08	; 8
    1c36:	b9 01       	movw	r22, r18
    1c38:	0e 94 72 08 	call	0x10e4	; 0x10e4 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1c3c:	8d 81       	ldd	r24, Y+5	; 0x05
    1c3e:	9e 81       	ldd	r25, Y+6	; 0x06
    1c40:	0e 94 37 11 	call	0x226e	; 0x226e <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1c44:	0e 94 4f 06 	call	0xc9e	; 0xc9e <xTaskResumeAll>
    1c48:	88 23       	and	r24, r24
    1c4a:	91 f4       	brne	.+36     	; 0x1c70 <xQueueGenericSend+0x134>
				{
					portYIELD_WITHIN_API();
    1c4c:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <vPortYield>
    1c50:	0f c0       	rjmp	.+30     	; 0x1c70 <xQueueGenericSend+0x134>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1c52:	8d 81       	ldd	r24, Y+5	; 0x05
    1c54:	9e 81       	ldd	r25, Y+6	; 0x06
    1c56:	0e 94 37 11 	call	0x226e	; 0x226e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1c5a:	0e 94 4f 06 	call	0xc9e	; 0xc9e <xTaskResumeAll>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
    1c5e:	80 cf       	rjmp	.-256    	; 0x1b60 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1c60:	8d 81       	ldd	r24, Y+5	; 0x05
    1c62:	9e 81       	ldd	r25, Y+6	; 0x06
    1c64:	0e 94 37 11 	call	0x226e	; 0x226e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1c68:	0e 94 4f 06 	call	0xc9e	; 0xc9e <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1c6c:	80 e0       	ldi	r24, 0x00	; 0
    1c6e:	01 c0       	rjmp	.+2      	; 0x1c72 <xQueueGenericSend+0x136>
		}
	}
    1c70:	77 cf       	rjmp	.-274    	; 0x1b60 <xQueueGenericSend+0x24>
}
    1c72:	2b 96       	adiw	r28, 0x0b	; 11
    1c74:	0f b6       	in	r0, 0x3f	; 63
    1c76:	f8 94       	cli
    1c78:	de bf       	out	0x3e, r29	; 62
    1c7a:	0f be       	out	0x3f, r0	; 63
    1c7c:	cd bf       	out	0x3d, r28	; 61
    1c7e:	df 91       	pop	r29
    1c80:	cf 91       	pop	r28
    1c82:	08 95       	ret

00001c84 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1c84:	cf 93       	push	r28
    1c86:	df 93       	push	r29
    1c88:	cd b7       	in	r28, 0x3d	; 61
    1c8a:	de b7       	in	r29, 0x3e	; 62
    1c8c:	29 97       	sbiw	r28, 0x09	; 9
    1c8e:	0f b6       	in	r0, 0x3f	; 63
    1c90:	f8 94       	cli
    1c92:	de bf       	out	0x3e, r29	; 62
    1c94:	0f be       	out	0x3f, r0	; 63
    1c96:	cd bf       	out	0x3d, r28	; 61
    1c98:	9c 83       	std	Y+4, r25	; 0x04
    1c9a:	8b 83       	std	Y+3, r24	; 0x03
    1c9c:	7e 83       	std	Y+6, r23	; 0x06
    1c9e:	6d 83       	std	Y+5, r22	; 0x05
    1ca0:	58 87       	std	Y+8, r21	; 0x08
    1ca2:	4f 83       	std	Y+7, r20	; 0x07
    1ca4:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1ca6:	1a 82       	std	Y+2, r1	; 0x02
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1ca8:	8b 81       	ldd	r24, Y+3	; 0x03
    1caa:	9c 81       	ldd	r25, Y+4	; 0x04
    1cac:	fc 01       	movw	r30, r24
    1cae:	22 8d       	ldd	r18, Z+26	; 0x1a
    1cb0:	8b 81       	ldd	r24, Y+3	; 0x03
    1cb2:	9c 81       	ldd	r25, Y+4	; 0x04
    1cb4:	fc 01       	movw	r30, r24
    1cb6:	83 8d       	ldd	r24, Z+27	; 0x1b
    1cb8:	28 17       	cp	r18, r24
    1cba:	90 f5       	brcc	.+100    	; 0x1d20 <xQueueGenericSendFromISR+0x9c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1cbc:	2d 81       	ldd	r18, Y+5	; 0x05
    1cbe:	3e 81       	ldd	r19, Y+6	; 0x06
    1cc0:	8b 81       	ldd	r24, Y+3	; 0x03
    1cc2:	9c 81       	ldd	r25, Y+4	; 0x04
    1cc4:	49 85       	ldd	r20, Y+9	; 0x09
    1cc6:	b9 01       	movw	r22, r18
    1cc8:	0e 94 28 10 	call	0x2050	; 0x2050 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1ccc:	8b 81       	ldd	r24, Y+3	; 0x03
    1cce:	9c 81       	ldd	r25, Y+4	; 0x04
    1cd0:	fc 01       	movw	r30, r24
    1cd2:	86 8d       	ldd	r24, Z+30	; 0x1e
    1cd4:	8f 3f       	cpi	r24, 0xFF	; 255
    1cd6:	b9 f4       	brne	.+46     	; 0x1d06 <xQueueGenericSendFromISR+0x82>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1cd8:	8b 81       	ldd	r24, Y+3	; 0x03
    1cda:	9c 81       	ldd	r25, Y+4	; 0x04
    1cdc:	fc 01       	movw	r30, r24
    1cde:	81 89       	ldd	r24, Z+17	; 0x11
    1ce0:	88 23       	and	r24, r24
    1ce2:	d9 f0       	breq	.+54     	; 0x1d1a <xQueueGenericSendFromISR+0x96>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1ce4:	8b 81       	ldd	r24, Y+3	; 0x03
    1ce6:	9c 81       	ldd	r25, Y+4	; 0x04
    1ce8:	41 96       	adiw	r24, 0x11	; 17
    1cea:	0e 94 b7 08 	call	0x116e	; 0x116e <xTaskRemoveFromEventList>
    1cee:	88 23       	and	r24, r24
    1cf0:	a1 f0       	breq	.+40     	; 0x1d1a <xQueueGenericSendFromISR+0x96>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						if( pxHigherPriorityTaskWoken != NULL )
    1cf2:	8f 81       	ldd	r24, Y+7	; 0x07
    1cf4:	98 85       	ldd	r25, Y+8	; 0x08
    1cf6:	00 97       	sbiw	r24, 0x00	; 0
    1cf8:	81 f0       	breq	.+32     	; 0x1d1a <xQueueGenericSendFromISR+0x96>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1cfa:	8f 81       	ldd	r24, Y+7	; 0x07
    1cfc:	98 85       	ldd	r25, Y+8	; 0x08
    1cfe:	21 e0       	ldi	r18, 0x01	; 1
    1d00:	fc 01       	movw	r30, r24
    1d02:	20 83       	st	Z, r18
    1d04:	0a c0       	rjmp	.+20     	; 0x1d1a <xQueueGenericSendFromISR+0x96>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1d06:	8b 81       	ldd	r24, Y+3	; 0x03
    1d08:	9c 81       	ldd	r25, Y+4	; 0x04
    1d0a:	fc 01       	movw	r30, r24
    1d0c:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d0e:	21 e0       	ldi	r18, 0x01	; 1
    1d10:	28 0f       	add	r18, r24
    1d12:	8b 81       	ldd	r24, Y+3	; 0x03
    1d14:	9c 81       	ldd	r25, Y+4	; 0x04
    1d16:	fc 01       	movw	r30, r24
    1d18:	26 8f       	std	Z+30, r18	; 0x1e
			}

			xReturn = pdPASS;
    1d1a:	81 e0       	ldi	r24, 0x01	; 1
    1d1c:	89 83       	std	Y+1, r24	; 0x01
    1d1e:	01 c0       	rjmp	.+2      	; 0x1d22 <xQueueGenericSendFromISR+0x9e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1d20:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1d22:	89 81       	ldd	r24, Y+1	; 0x01
}
    1d24:	29 96       	adiw	r28, 0x09	; 9
    1d26:	0f b6       	in	r0, 0x3f	; 63
    1d28:	f8 94       	cli
    1d2a:	de bf       	out	0x3e, r29	; 62
    1d2c:	0f be       	out	0x3f, r0	; 63
    1d2e:	cd bf       	out	0x3d, r28	; 61
    1d30:	df 91       	pop	r29
    1d32:	cf 91       	pop	r28
    1d34:	08 95       	ret

00001d36 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1d36:	cf 93       	push	r28
    1d38:	df 93       	push	r29
    1d3a:	cd b7       	in	r28, 0x3d	; 61
    1d3c:	de b7       	in	r29, 0x3e	; 62
    1d3e:	2d 97       	sbiw	r28, 0x0d	; 13
    1d40:	0f b6       	in	r0, 0x3f	; 63
    1d42:	f8 94       	cli
    1d44:	de bf       	out	0x3e, r29	; 62
    1d46:	0f be       	out	0x3f, r0	; 63
    1d48:	cd bf       	out	0x3d, r28	; 61
    1d4a:	98 87       	std	Y+8, r25	; 0x08
    1d4c:	8f 83       	std	Y+7, r24	; 0x07
    1d4e:	7a 87       	std	Y+10, r23	; 0x0a
    1d50:	69 87       	std	Y+9, r22	; 0x09
    1d52:	5c 87       	std	Y+12, r21	; 0x0c
    1d54:	4b 87       	std	Y+11, r20	; 0x0b
    1d56:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1d58:	19 82       	std	Y+1, r1	; 0x01
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1d5a:	0f b6       	in	r0, 0x3f	; 63
    1d5c:	f8 94       	cli
    1d5e:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1d60:	8f 81       	ldd	r24, Y+7	; 0x07
    1d62:	98 85       	ldd	r25, Y+8	; 0x08
    1d64:	fc 01       	movw	r30, r24
    1d66:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d68:	88 23       	and	r24, r24
    1d6a:	09 f4       	brne	.+2      	; 0x1d6e <xQueueGenericReceive+0x38>
    1d6c:	54 c0       	rjmp	.+168    	; 0x1e16 <xQueueGenericReceive+0xe0>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1d6e:	8f 81       	ldd	r24, Y+7	; 0x07
    1d70:	98 85       	ldd	r25, Y+8	; 0x08
    1d72:	fc 01       	movw	r30, r24
    1d74:	86 81       	ldd	r24, Z+6	; 0x06
    1d76:	97 81       	ldd	r25, Z+7	; 0x07
    1d78:	9b 83       	std	Y+3, r25	; 0x03
    1d7a:	8a 83       	std	Y+2, r24	; 0x02

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1d7c:	29 85       	ldd	r18, Y+9	; 0x09
    1d7e:	3a 85       	ldd	r19, Y+10	; 0x0a
    1d80:	8f 81       	ldd	r24, Y+7	; 0x07
    1d82:	98 85       	ldd	r25, Y+8	; 0x08
    1d84:	b9 01       	movw	r22, r18
    1d86:	0e 94 e6 10 	call	0x21cc	; 0x21cc <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1d8a:	8d 85       	ldd	r24, Y+13	; 0x0d
    1d8c:	88 23       	and	r24, r24
    1d8e:	49 f5       	brne	.+82     	; 0x1de2 <xQueueGenericReceive+0xac>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1d90:	8f 81       	ldd	r24, Y+7	; 0x07
    1d92:	98 85       	ldd	r25, Y+8	; 0x08
    1d94:	fc 01       	movw	r30, r24
    1d96:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d98:	2f ef       	ldi	r18, 0xFF	; 255
    1d9a:	28 0f       	add	r18, r24
    1d9c:	8f 81       	ldd	r24, Y+7	; 0x07
    1d9e:	98 85       	ldd	r25, Y+8	; 0x08
    1da0:	fc 01       	movw	r30, r24
    1da2:	22 8f       	std	Z+26, r18	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1da4:	8f 81       	ldd	r24, Y+7	; 0x07
    1da6:	98 85       	ldd	r25, Y+8	; 0x08
    1da8:	fc 01       	movw	r30, r24
    1daa:	80 81       	ld	r24, Z
    1dac:	91 81       	ldd	r25, Z+1	; 0x01
    1dae:	00 97       	sbiw	r24, 0x00	; 0
    1db0:	41 f4       	brne	.+16     	; 0x1dc2 <xQueueGenericReceive+0x8c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    1db2:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <xTaskGetCurrentTaskHandle>
    1db6:	9c 01       	movw	r18, r24
    1db8:	8f 81       	ldd	r24, Y+7	; 0x07
    1dba:	98 85       	ldd	r25, Y+8	; 0x08
    1dbc:	fc 01       	movw	r30, r24
    1dbe:	33 83       	std	Z+3, r19	; 0x03
    1dc0:	22 83       	std	Z+2, r18	; 0x02
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1dc2:	8f 81       	ldd	r24, Y+7	; 0x07
    1dc4:	98 85       	ldd	r25, Y+8	; 0x08
    1dc6:	fc 01       	movw	r30, r24
    1dc8:	80 85       	ldd	r24, Z+8	; 0x08
    1dca:	88 23       	and	r24, r24
    1dcc:	01 f1       	breq	.+64     	; 0x1e0e <xQueueGenericReceive+0xd8>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1dce:	8f 81       	ldd	r24, Y+7	; 0x07
    1dd0:	98 85       	ldd	r25, Y+8	; 0x08
    1dd2:	08 96       	adiw	r24, 0x08	; 8
    1dd4:	0e 94 b7 08 	call	0x116e	; 0x116e <xTaskRemoveFromEventList>
    1dd8:	81 30       	cpi	r24, 0x01	; 1
    1dda:	c9 f4       	brne	.+50     	; 0x1e0e <xQueueGenericReceive+0xd8>
						{
							portYIELD_WITHIN_API();
    1ddc:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <vPortYield>
    1de0:	16 c0       	rjmp	.+44     	; 0x1e0e <xQueueGenericReceive+0xd8>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1de2:	8f 81       	ldd	r24, Y+7	; 0x07
    1de4:	98 85       	ldd	r25, Y+8	; 0x08
    1de6:	2a 81       	ldd	r18, Y+2	; 0x02
    1de8:	3b 81       	ldd	r19, Y+3	; 0x03
    1dea:	fc 01       	movw	r30, r24
    1dec:	37 83       	std	Z+7, r19	; 0x07
    1dee:	26 83       	std	Z+6, r18	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1df0:	8f 81       	ldd	r24, Y+7	; 0x07
    1df2:	98 85       	ldd	r25, Y+8	; 0x08
    1df4:	fc 01       	movw	r30, r24
    1df6:	81 89       	ldd	r24, Z+17	; 0x11
    1df8:	88 23       	and	r24, r24
    1dfa:	49 f0       	breq	.+18     	; 0x1e0e <xQueueGenericReceive+0xd8>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1dfc:	8f 81       	ldd	r24, Y+7	; 0x07
    1dfe:	98 85       	ldd	r25, Y+8	; 0x08
    1e00:	41 96       	adiw	r24, 0x11	; 17
    1e02:	0e 94 b7 08 	call	0x116e	; 0x116e <xTaskRemoveFromEventList>
    1e06:	88 23       	and	r24, r24
    1e08:	11 f0       	breq	.+4      	; 0x1e0e <xQueueGenericReceive+0xd8>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1e0a:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <vPortYield>
						}
					}
				}

				taskEXIT_CRITICAL();
    1e0e:	0f 90       	pop	r0
    1e10:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1e12:	81 e0       	ldi	r24, 0x01	; 1
    1e14:	74 c0       	rjmp	.+232    	; 0x1efe <xQueueGenericReceive+0x1c8>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1e16:	8b 85       	ldd	r24, Y+11	; 0x0b
    1e18:	9c 85       	ldd	r25, Y+12	; 0x0c
    1e1a:	00 97       	sbiw	r24, 0x00	; 0
    1e1c:	21 f4       	brne	.+8      	; 0x1e26 <xQueueGenericReceive+0xf0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1e1e:	0f 90       	pop	r0
    1e20:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1e22:	80 e0       	ldi	r24, 0x00	; 0
    1e24:	6c c0       	rjmp	.+216    	; 0x1efe <xQueueGenericReceive+0x1c8>
				}
				else if( xEntryTimeSet == pdFALSE )
    1e26:	89 81       	ldd	r24, Y+1	; 0x01
    1e28:	88 23       	and	r24, r24
    1e2a:	31 f4       	brne	.+12     	; 0x1e38 <xQueueGenericReceive+0x102>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1e2c:	ce 01       	movw	r24, r28
    1e2e:	04 96       	adiw	r24, 0x04	; 4
    1e30:	0e 94 21 09 	call	0x1242	; 0x1242 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1e34:	81 e0       	ldi	r24, 0x01	; 1
    1e36:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    1e38:	0f 90       	pop	r0
    1e3a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1e3c:	0e 94 43 06 	call	0xc86	; 0xc86 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1e40:	0f b6       	in	r0, 0x3f	; 63
    1e42:	f8 94       	cli
    1e44:	0f 92       	push	r0
    1e46:	8f 81       	ldd	r24, Y+7	; 0x07
    1e48:	98 85       	ldd	r25, Y+8	; 0x08
    1e4a:	fc 01       	movw	r30, r24
    1e4c:	85 8d       	ldd	r24, Z+29	; 0x1d
    1e4e:	8f 3f       	cpi	r24, 0xFF	; 255
    1e50:	21 f4       	brne	.+8      	; 0x1e5a <xQueueGenericReceive+0x124>
    1e52:	8f 81       	ldd	r24, Y+7	; 0x07
    1e54:	98 85       	ldd	r25, Y+8	; 0x08
    1e56:	fc 01       	movw	r30, r24
    1e58:	15 8e       	std	Z+29, r1	; 0x1d
    1e5a:	8f 81       	ldd	r24, Y+7	; 0x07
    1e5c:	98 85       	ldd	r25, Y+8	; 0x08
    1e5e:	fc 01       	movw	r30, r24
    1e60:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e62:	8f 3f       	cpi	r24, 0xFF	; 255
    1e64:	21 f4       	brne	.+8      	; 0x1e6e <xQueueGenericReceive+0x138>
    1e66:	8f 81       	ldd	r24, Y+7	; 0x07
    1e68:	98 85       	ldd	r25, Y+8	; 0x08
    1e6a:	fc 01       	movw	r30, r24
    1e6c:	16 8e       	std	Z+30, r1	; 0x1e
    1e6e:	0f 90       	pop	r0
    1e70:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1e72:	9e 01       	movw	r18, r28
    1e74:	25 5f       	subi	r18, 0xF5	; 245
    1e76:	3f 4f       	sbci	r19, 0xFF	; 255
    1e78:	ce 01       	movw	r24, r28
    1e7a:	04 96       	adiw	r24, 0x04	; 4
    1e7c:	b9 01       	movw	r22, r18
    1e7e:	0e 94 3d 09 	call	0x127a	; 0x127a <xTaskCheckForTimeOut>
    1e82:	88 23       	and	r24, r24
    1e84:	99 f5       	brne	.+102    	; 0x1eec <xQueueGenericReceive+0x1b6>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1e86:	8f 81       	ldd	r24, Y+7	; 0x07
    1e88:	98 85       	ldd	r25, Y+8	; 0x08
    1e8a:	0e 94 9c 11 	call	0x2338	; 0x2338 <prvIsQueueEmpty>
    1e8e:	88 23       	and	r24, r24
    1e90:	31 f1       	breq	.+76     	; 0x1ede <xQueueGenericReceive+0x1a8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1e92:	8f 81       	ldd	r24, Y+7	; 0x07
    1e94:	98 85       	ldd	r25, Y+8	; 0x08
    1e96:	fc 01       	movw	r30, r24
    1e98:	80 81       	ld	r24, Z
    1e9a:	91 81       	ldd	r25, Z+1	; 0x01
    1e9c:	00 97       	sbiw	r24, 0x00	; 0
    1e9e:	61 f4       	brne	.+24     	; 0x1eb8 <xQueueGenericReceive+0x182>
					{
						portENTER_CRITICAL();
    1ea0:	0f b6       	in	r0, 0x3f	; 63
    1ea2:	f8 94       	cli
    1ea4:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1ea6:	8f 81       	ldd	r24, Y+7	; 0x07
    1ea8:	98 85       	ldd	r25, Y+8	; 0x08
    1eaa:	fc 01       	movw	r30, r24
    1eac:	82 81       	ldd	r24, Z+2	; 0x02
    1eae:	93 81       	ldd	r25, Z+3	; 0x03
    1eb0:	0e 94 67 0b 	call	0x16ce	; 0x16ce <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    1eb4:	0f 90       	pop	r0
    1eb6:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1eb8:	2b 85       	ldd	r18, Y+11	; 0x0b
    1eba:	3c 85       	ldd	r19, Y+12	; 0x0c
    1ebc:	8f 81       	ldd	r24, Y+7	; 0x07
    1ebe:	98 85       	ldd	r25, Y+8	; 0x08
    1ec0:	41 96       	adiw	r24, 0x11	; 17
    1ec2:	b9 01       	movw	r22, r18
    1ec4:	0e 94 72 08 	call	0x10e4	; 0x10e4 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1ec8:	8f 81       	ldd	r24, Y+7	; 0x07
    1eca:	98 85       	ldd	r25, Y+8	; 0x08
    1ecc:	0e 94 37 11 	call	0x226e	; 0x226e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1ed0:	0e 94 4f 06 	call	0xc9e	; 0xc9e <xTaskResumeAll>
    1ed4:	88 23       	and	r24, r24
    1ed6:	91 f4       	brne	.+36     	; 0x1efc <xQueueGenericReceive+0x1c6>
				{
					portYIELD_WITHIN_API();
    1ed8:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <vPortYield>
    1edc:	0f c0       	rjmp	.+30     	; 0x1efc <xQueueGenericReceive+0x1c6>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1ede:	8f 81       	ldd	r24, Y+7	; 0x07
    1ee0:	98 85       	ldd	r25, Y+8	; 0x08
    1ee2:	0e 94 37 11 	call	0x226e	; 0x226e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1ee6:	0e 94 4f 06 	call	0xc9e	; 0xc9e <xTaskResumeAll>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
    1eea:	37 cf       	rjmp	.-402    	; 0x1d5a <xQueueGenericReceive+0x24>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1eec:	8f 81       	ldd	r24, Y+7	; 0x07
    1eee:	98 85       	ldd	r25, Y+8	; 0x08
    1ef0:	0e 94 37 11 	call	0x226e	; 0x226e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1ef4:	0e 94 4f 06 	call	0xc9e	; 0xc9e <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1ef8:	80 e0       	ldi	r24, 0x00	; 0
    1efa:	01 c0       	rjmp	.+2      	; 0x1efe <xQueueGenericReceive+0x1c8>
		}
	}
    1efc:	2e cf       	rjmp	.-420    	; 0x1d5a <xQueueGenericReceive+0x24>
}
    1efe:	2d 96       	adiw	r28, 0x0d	; 13
    1f00:	0f b6       	in	r0, 0x3f	; 63
    1f02:	f8 94       	cli
    1f04:	de bf       	out	0x3e, r29	; 62
    1f06:	0f be       	out	0x3f, r0	; 63
    1f08:	cd bf       	out	0x3d, r28	; 61
    1f0a:	df 91       	pop	r29
    1f0c:	cf 91       	pop	r28
    1f0e:	08 95       	ret

00001f10 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
{
    1f10:	cf 93       	push	r28
    1f12:	df 93       	push	r29
    1f14:	cd b7       	in	r28, 0x3d	; 61
    1f16:	de b7       	in	r29, 0x3e	; 62
    1f18:	28 97       	sbiw	r28, 0x08	; 8
    1f1a:	0f b6       	in	r0, 0x3f	; 63
    1f1c:	f8 94       	cli
    1f1e:	de bf       	out	0x3e, r29	; 62
    1f20:	0f be       	out	0x3f, r0	; 63
    1f22:	cd bf       	out	0x3d, r28	; 61
    1f24:	9c 83       	std	Y+4, r25	; 0x04
    1f26:	8b 83       	std	Y+3, r24	; 0x03
    1f28:	7e 83       	std	Y+6, r23	; 0x06
    1f2a:	6d 83       	std	Y+5, r22	; 0x05
    1f2c:	58 87       	std	Y+8, r21	; 0x08
    1f2e:	4f 83       	std	Y+7, r20	; 0x07
unsigned portBASE_TYPE uxSavedInterruptStatus;

	configASSERT( pxQueue );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1f30:	1a 82       	std	Y+2, r1	; 0x02
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1f32:	8b 81       	ldd	r24, Y+3	; 0x03
    1f34:	9c 81       	ldd	r25, Y+4	; 0x04
    1f36:	fc 01       	movw	r30, r24
    1f38:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f3a:	88 23       	and	r24, r24
    1f3c:	d9 f1       	breq	.+118    	; 0x1fb4 <xQueueReceiveFromISR+0xa4>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1f3e:	2d 81       	ldd	r18, Y+5	; 0x05
    1f40:	3e 81       	ldd	r19, Y+6	; 0x06
    1f42:	8b 81       	ldd	r24, Y+3	; 0x03
    1f44:	9c 81       	ldd	r25, Y+4	; 0x04
    1f46:	b9 01       	movw	r22, r18
    1f48:	0e 94 e6 10 	call	0x21cc	; 0x21cc <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1f4c:	8b 81       	ldd	r24, Y+3	; 0x03
    1f4e:	9c 81       	ldd	r25, Y+4	; 0x04
    1f50:	fc 01       	movw	r30, r24
    1f52:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f54:	2f ef       	ldi	r18, 0xFF	; 255
    1f56:	28 0f       	add	r18, r24
    1f58:	8b 81       	ldd	r24, Y+3	; 0x03
    1f5a:	9c 81       	ldd	r25, Y+4	; 0x04
    1f5c:	fc 01       	movw	r30, r24
    1f5e:	22 8f       	std	Z+26, r18	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1f60:	8b 81       	ldd	r24, Y+3	; 0x03
    1f62:	9c 81       	ldd	r25, Y+4	; 0x04
    1f64:	fc 01       	movw	r30, r24
    1f66:	85 8d       	ldd	r24, Z+29	; 0x1d
    1f68:	8f 3f       	cpi	r24, 0xFF	; 255
    1f6a:	b9 f4       	brne	.+46     	; 0x1f9a <xQueueReceiveFromISR+0x8a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1f6c:	8b 81       	ldd	r24, Y+3	; 0x03
    1f6e:	9c 81       	ldd	r25, Y+4	; 0x04
    1f70:	fc 01       	movw	r30, r24
    1f72:	80 85       	ldd	r24, Z+8	; 0x08
    1f74:	88 23       	and	r24, r24
    1f76:	d9 f0       	breq	.+54     	; 0x1fae <xQueueReceiveFromISR+0x9e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1f78:	8b 81       	ldd	r24, Y+3	; 0x03
    1f7a:	9c 81       	ldd	r25, Y+4	; 0x04
    1f7c:	08 96       	adiw	r24, 0x08	; 8
    1f7e:	0e 94 b7 08 	call	0x116e	; 0x116e <xTaskRemoveFromEventList>
    1f82:	88 23       	and	r24, r24
    1f84:	a1 f0       	breq	.+40     	; 0x1fae <xQueueReceiveFromISR+0x9e>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1f86:	8f 81       	ldd	r24, Y+7	; 0x07
    1f88:	98 85       	ldd	r25, Y+8	; 0x08
    1f8a:	00 97       	sbiw	r24, 0x00	; 0
    1f8c:	81 f0       	breq	.+32     	; 0x1fae <xQueueReceiveFromISR+0x9e>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1f8e:	8f 81       	ldd	r24, Y+7	; 0x07
    1f90:	98 85       	ldd	r25, Y+8	; 0x08
    1f92:	21 e0       	ldi	r18, 0x01	; 1
    1f94:	fc 01       	movw	r30, r24
    1f96:	20 83       	st	Z, r18
    1f98:	0a c0       	rjmp	.+20     	; 0x1fae <xQueueReceiveFromISR+0x9e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1f9a:	8b 81       	ldd	r24, Y+3	; 0x03
    1f9c:	9c 81       	ldd	r25, Y+4	; 0x04
    1f9e:	fc 01       	movw	r30, r24
    1fa0:	85 8d       	ldd	r24, Z+29	; 0x1d
    1fa2:	21 e0       	ldi	r18, 0x01	; 1
    1fa4:	28 0f       	add	r18, r24
    1fa6:	8b 81       	ldd	r24, Y+3	; 0x03
    1fa8:	9c 81       	ldd	r25, Y+4	; 0x04
    1faa:	fc 01       	movw	r30, r24
    1fac:	25 8f       	std	Z+29, r18	; 0x1d
			}

			xReturn = pdPASS;
    1fae:	81 e0       	ldi	r24, 0x01	; 1
    1fb0:	89 83       	std	Y+1, r24	; 0x01
    1fb2:	01 c0       	rjmp	.+2      	; 0x1fb6 <xQueueReceiveFromISR+0xa6>
		}
		else
		{
			xReturn = pdFAIL;
    1fb4:	19 82       	std	Y+1, r1	; 0x01
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1fb6:	89 81       	ldd	r24, Y+1	; 0x01
}
    1fb8:	28 96       	adiw	r28, 0x08	; 8
    1fba:	0f b6       	in	r0, 0x3f	; 63
    1fbc:	f8 94       	cli
    1fbe:	de bf       	out	0x3e, r29	; 62
    1fc0:	0f be       	out	0x3f, r0	; 63
    1fc2:	cd bf       	out	0x3d, r28	; 61
    1fc4:	df 91       	pop	r29
    1fc6:	cf 91       	pop	r28
    1fc8:	08 95       	ret

00001fca <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    1fca:	cf 93       	push	r28
    1fcc:	df 93       	push	r29
    1fce:	00 d0       	rcall	.+0      	; 0x1fd0 <uxQueueMessagesWaiting+0x6>
    1fd0:	cd b7       	in	r28, 0x3d	; 61
    1fd2:	de b7       	in	r29, 0x3e	; 62
    1fd4:	9b 83       	std	Y+3, r25	; 0x03
    1fd6:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1fd8:	0f b6       	in	r0, 0x3f	; 63
    1fda:	f8 94       	cli
    1fdc:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1fde:	8a 81       	ldd	r24, Y+2	; 0x02
    1fe0:	9b 81       	ldd	r25, Y+3	; 0x03
    1fe2:	fc 01       	movw	r30, r24
    1fe4:	82 8d       	ldd	r24, Z+26	; 0x1a
    1fe6:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1fe8:	0f 90       	pop	r0
    1fea:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1fec:	89 81       	ldd	r24, Y+1	; 0x01
}
    1fee:	0f 90       	pop	r0
    1ff0:	0f 90       	pop	r0
    1ff2:	0f 90       	pop	r0
    1ff4:	df 91       	pop	r29
    1ff6:	cf 91       	pop	r28
    1ff8:	08 95       	ret

00001ffa <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    1ffa:	cf 93       	push	r28
    1ffc:	df 93       	push	r29
    1ffe:	00 d0       	rcall	.+0      	; 0x2000 <uxQueueMessagesWaitingFromISR+0x6>
    2000:	cd b7       	in	r28, 0x3d	; 61
    2002:	de b7       	in	r29, 0x3e	; 62
    2004:	9b 83       	std	Y+3, r25	; 0x03
    2006:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    2008:	8a 81       	ldd	r24, Y+2	; 0x02
    200a:	9b 81       	ldd	r25, Y+3	; 0x03
    200c:	fc 01       	movw	r30, r24
    200e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2010:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    2012:	89 81       	ldd	r24, Y+1	; 0x01
}
    2014:	0f 90       	pop	r0
    2016:	0f 90       	pop	r0
    2018:	0f 90       	pop	r0
    201a:	df 91       	pop	r29
    201c:	cf 91       	pop	r28
    201e:	08 95       	ret

00002020 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    2020:	cf 93       	push	r28
    2022:	df 93       	push	r29
    2024:	1f 92       	push	r1
    2026:	1f 92       	push	r1
    2028:	cd b7       	in	r28, 0x3d	; 61
    202a:	de b7       	in	r29, 0x3e	; 62
    202c:	9a 83       	std	Y+2, r25	; 0x02
    202e:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    2030:	89 81       	ldd	r24, Y+1	; 0x01
    2032:	9a 81       	ldd	r25, Y+2	; 0x02
    2034:	fc 01       	movw	r30, r24
    2036:	80 81       	ld	r24, Z
    2038:	91 81       	ldd	r25, Z+1	; 0x01
    203a:	0e 94 b7 16 	call	0x2d6e	; 0x2d6e <vPortFree>
	vPortFree( pxQueue );
    203e:	89 81       	ldd	r24, Y+1	; 0x01
    2040:	9a 81       	ldd	r25, Y+2	; 0x02
    2042:	0e 94 b7 16 	call	0x2d6e	; 0x2d6e <vPortFree>
}
    2046:	0f 90       	pop	r0
    2048:	0f 90       	pop	r0
    204a:	df 91       	pop	r29
    204c:	cf 91       	pop	r28
    204e:	08 95       	ret

00002050 <prvCopyDataToQueue>:

#endif
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    2050:	cf 93       	push	r28
    2052:	df 93       	push	r29
    2054:	00 d0       	rcall	.+0      	; 0x2056 <prvCopyDataToQueue+0x6>
    2056:	1f 92       	push	r1
    2058:	1f 92       	push	r1
    205a:	cd b7       	in	r28, 0x3d	; 61
    205c:	de b7       	in	r29, 0x3e	; 62
    205e:	9a 83       	std	Y+2, r25	; 0x02
    2060:	89 83       	std	Y+1, r24	; 0x01
    2062:	7c 83       	std	Y+4, r23	; 0x04
    2064:	6b 83       	std	Y+3, r22	; 0x03
    2066:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    2068:	89 81       	ldd	r24, Y+1	; 0x01
    206a:	9a 81       	ldd	r25, Y+2	; 0x02
    206c:	fc 01       	movw	r30, r24
    206e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2070:	88 23       	and	r24, r24
    2072:	a9 f4       	brne	.+42     	; 0x209e <prvCopyDataToQueue+0x4e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2074:	89 81       	ldd	r24, Y+1	; 0x01
    2076:	9a 81       	ldd	r25, Y+2	; 0x02
    2078:	fc 01       	movw	r30, r24
    207a:	80 81       	ld	r24, Z
    207c:	91 81       	ldd	r25, Z+1	; 0x01
    207e:	00 97       	sbiw	r24, 0x00	; 0
    2080:	09 f0       	breq	.+2      	; 0x2084 <prvCopyDataToQueue+0x34>
    2082:	92 c0       	rjmp	.+292    	; 0x21a8 <prvCopyDataToQueue+0x158>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    2084:	89 81       	ldd	r24, Y+1	; 0x01
    2086:	9a 81       	ldd	r25, Y+2	; 0x02
    2088:	fc 01       	movw	r30, r24
    208a:	82 81       	ldd	r24, Z+2	; 0x02
    208c:	93 81       	ldd	r25, Z+3	; 0x03
    208e:	0e 94 f7 0b 	call	0x17ee	; 0x17ee <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    2092:	89 81       	ldd	r24, Y+1	; 0x01
    2094:	9a 81       	ldd	r25, Y+2	; 0x02
    2096:	fc 01       	movw	r30, r24
    2098:	13 82       	std	Z+3, r1	; 0x03
    209a:	12 82       	std	Z+2, r1	; 0x02
    209c:	85 c0       	rjmp	.+266    	; 0x21a8 <prvCopyDataToQueue+0x158>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    209e:	8d 81       	ldd	r24, Y+5	; 0x05
    20a0:	88 23       	and	r24, r24
    20a2:	d9 f5       	brne	.+118    	; 0x211a <prvCopyDataToQueue+0xca>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    20a4:	89 81       	ldd	r24, Y+1	; 0x01
    20a6:	9a 81       	ldd	r25, Y+2	; 0x02
    20a8:	fc 01       	movw	r30, r24
    20aa:	84 8d       	ldd	r24, Z+28	; 0x1c
    20ac:	48 2f       	mov	r20, r24
    20ae:	50 e0       	ldi	r21, 0x00	; 0
    20b0:	89 81       	ldd	r24, Y+1	; 0x01
    20b2:	9a 81       	ldd	r25, Y+2	; 0x02
    20b4:	fc 01       	movw	r30, r24
    20b6:	84 81       	ldd	r24, Z+4	; 0x04
    20b8:	95 81       	ldd	r25, Z+5	; 0x05
    20ba:	2b 81       	ldd	r18, Y+3	; 0x03
    20bc:	3c 81       	ldd	r19, Y+4	; 0x04
    20be:	b9 01       	movw	r22, r18
    20c0:	0e 94 d2 23 	call	0x47a4	; 0x47a4 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    20c4:	89 81       	ldd	r24, Y+1	; 0x01
    20c6:	9a 81       	ldd	r25, Y+2	; 0x02
    20c8:	fc 01       	movw	r30, r24
    20ca:	24 81       	ldd	r18, Z+4	; 0x04
    20cc:	35 81       	ldd	r19, Z+5	; 0x05
    20ce:	89 81       	ldd	r24, Y+1	; 0x01
    20d0:	9a 81       	ldd	r25, Y+2	; 0x02
    20d2:	fc 01       	movw	r30, r24
    20d4:	84 8d       	ldd	r24, Z+28	; 0x1c
    20d6:	88 2f       	mov	r24, r24
    20d8:	90 e0       	ldi	r25, 0x00	; 0
    20da:	28 0f       	add	r18, r24
    20dc:	39 1f       	adc	r19, r25
    20de:	89 81       	ldd	r24, Y+1	; 0x01
    20e0:	9a 81       	ldd	r25, Y+2	; 0x02
    20e2:	fc 01       	movw	r30, r24
    20e4:	35 83       	std	Z+5, r19	; 0x05
    20e6:	24 83       	std	Z+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    20e8:	89 81       	ldd	r24, Y+1	; 0x01
    20ea:	9a 81       	ldd	r25, Y+2	; 0x02
    20ec:	fc 01       	movw	r30, r24
    20ee:	24 81       	ldd	r18, Z+4	; 0x04
    20f0:	35 81       	ldd	r19, Z+5	; 0x05
    20f2:	89 81       	ldd	r24, Y+1	; 0x01
    20f4:	9a 81       	ldd	r25, Y+2	; 0x02
    20f6:	fc 01       	movw	r30, r24
    20f8:	82 81       	ldd	r24, Z+2	; 0x02
    20fa:	93 81       	ldd	r25, Z+3	; 0x03
    20fc:	28 17       	cp	r18, r24
    20fe:	39 07       	cpc	r19, r25
    2100:	08 f4       	brcc	.+2      	; 0x2104 <prvCopyDataToQueue+0xb4>
    2102:	52 c0       	rjmp	.+164    	; 0x21a8 <prvCopyDataToQueue+0x158>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    2104:	89 81       	ldd	r24, Y+1	; 0x01
    2106:	9a 81       	ldd	r25, Y+2	; 0x02
    2108:	fc 01       	movw	r30, r24
    210a:	20 81       	ld	r18, Z
    210c:	31 81       	ldd	r19, Z+1	; 0x01
    210e:	89 81       	ldd	r24, Y+1	; 0x01
    2110:	9a 81       	ldd	r25, Y+2	; 0x02
    2112:	fc 01       	movw	r30, r24
    2114:	35 83       	std	Z+5, r19	; 0x05
    2116:	24 83       	std	Z+4, r18	; 0x04
    2118:	47 c0       	rjmp	.+142    	; 0x21a8 <prvCopyDataToQueue+0x158>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    211a:	89 81       	ldd	r24, Y+1	; 0x01
    211c:	9a 81       	ldd	r25, Y+2	; 0x02
    211e:	fc 01       	movw	r30, r24
    2120:	84 8d       	ldd	r24, Z+28	; 0x1c
    2122:	48 2f       	mov	r20, r24
    2124:	50 e0       	ldi	r21, 0x00	; 0
    2126:	89 81       	ldd	r24, Y+1	; 0x01
    2128:	9a 81       	ldd	r25, Y+2	; 0x02
    212a:	fc 01       	movw	r30, r24
    212c:	86 81       	ldd	r24, Z+6	; 0x06
    212e:	97 81       	ldd	r25, Z+7	; 0x07
    2130:	2b 81       	ldd	r18, Y+3	; 0x03
    2132:	3c 81       	ldd	r19, Y+4	; 0x04
    2134:	b9 01       	movw	r22, r18
    2136:	0e 94 d2 23 	call	0x47a4	; 0x47a4 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    213a:	89 81       	ldd	r24, Y+1	; 0x01
    213c:	9a 81       	ldd	r25, Y+2	; 0x02
    213e:	fc 01       	movw	r30, r24
    2140:	26 81       	ldd	r18, Z+6	; 0x06
    2142:	37 81       	ldd	r19, Z+7	; 0x07
    2144:	89 81       	ldd	r24, Y+1	; 0x01
    2146:	9a 81       	ldd	r25, Y+2	; 0x02
    2148:	fc 01       	movw	r30, r24
    214a:	84 8d       	ldd	r24, Z+28	; 0x1c
    214c:	88 2f       	mov	r24, r24
    214e:	90 e0       	ldi	r25, 0x00	; 0
    2150:	91 95       	neg	r25
    2152:	81 95       	neg	r24
    2154:	91 09       	sbc	r25, r1
    2156:	28 0f       	add	r18, r24
    2158:	39 1f       	adc	r19, r25
    215a:	89 81       	ldd	r24, Y+1	; 0x01
    215c:	9a 81       	ldd	r25, Y+2	; 0x02
    215e:	fc 01       	movw	r30, r24
    2160:	37 83       	std	Z+7, r19	; 0x07
    2162:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    2164:	89 81       	ldd	r24, Y+1	; 0x01
    2166:	9a 81       	ldd	r25, Y+2	; 0x02
    2168:	fc 01       	movw	r30, r24
    216a:	26 81       	ldd	r18, Z+6	; 0x06
    216c:	37 81       	ldd	r19, Z+7	; 0x07
    216e:	89 81       	ldd	r24, Y+1	; 0x01
    2170:	9a 81       	ldd	r25, Y+2	; 0x02
    2172:	fc 01       	movw	r30, r24
    2174:	80 81       	ld	r24, Z
    2176:	91 81       	ldd	r25, Z+1	; 0x01
    2178:	28 17       	cp	r18, r24
    217a:	39 07       	cpc	r19, r25
    217c:	a8 f4       	brcc	.+42     	; 0x21a8 <prvCopyDataToQueue+0x158>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    217e:	89 81       	ldd	r24, Y+1	; 0x01
    2180:	9a 81       	ldd	r25, Y+2	; 0x02
    2182:	fc 01       	movw	r30, r24
    2184:	22 81       	ldd	r18, Z+2	; 0x02
    2186:	33 81       	ldd	r19, Z+3	; 0x03
    2188:	89 81       	ldd	r24, Y+1	; 0x01
    218a:	9a 81       	ldd	r25, Y+2	; 0x02
    218c:	fc 01       	movw	r30, r24
    218e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2190:	88 2f       	mov	r24, r24
    2192:	90 e0       	ldi	r25, 0x00	; 0
    2194:	91 95       	neg	r25
    2196:	81 95       	neg	r24
    2198:	91 09       	sbc	r25, r1
    219a:	28 0f       	add	r18, r24
    219c:	39 1f       	adc	r19, r25
    219e:	89 81       	ldd	r24, Y+1	; 0x01
    21a0:	9a 81       	ldd	r25, Y+2	; 0x02
    21a2:	fc 01       	movw	r30, r24
    21a4:	37 83       	std	Z+7, r19	; 0x07
    21a6:	26 83       	std	Z+6, r18	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    21a8:	89 81       	ldd	r24, Y+1	; 0x01
    21aa:	9a 81       	ldd	r25, Y+2	; 0x02
    21ac:	fc 01       	movw	r30, r24
    21ae:	82 8d       	ldd	r24, Z+26	; 0x1a
    21b0:	21 e0       	ldi	r18, 0x01	; 1
    21b2:	28 0f       	add	r18, r24
    21b4:	89 81       	ldd	r24, Y+1	; 0x01
    21b6:	9a 81       	ldd	r25, Y+2	; 0x02
    21b8:	fc 01       	movw	r30, r24
    21ba:	22 8f       	std	Z+26, r18	; 0x1a
}
    21bc:	0f 90       	pop	r0
    21be:	0f 90       	pop	r0
    21c0:	0f 90       	pop	r0
    21c2:	0f 90       	pop	r0
    21c4:	0f 90       	pop	r0
    21c6:	df 91       	pop	r29
    21c8:	cf 91       	pop	r28
    21ca:	08 95       	ret

000021cc <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    21cc:	cf 93       	push	r28
    21ce:	df 93       	push	r29
    21d0:	00 d0       	rcall	.+0      	; 0x21d2 <prvCopyDataFromQueue+0x6>
    21d2:	1f 92       	push	r1
    21d4:	cd b7       	in	r28, 0x3d	; 61
    21d6:	de b7       	in	r29, 0x3e	; 62
    21d8:	9a 83       	std	Y+2, r25	; 0x02
    21da:	89 83       	std	Y+1, r24	; 0x01
    21dc:	7c 83       	std	Y+4, r23	; 0x04
    21de:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    21e0:	89 81       	ldd	r24, Y+1	; 0x01
    21e2:	9a 81       	ldd	r25, Y+2	; 0x02
    21e4:	fc 01       	movw	r30, r24
    21e6:	80 81       	ld	r24, Z
    21e8:	91 81       	ldd	r25, Z+1	; 0x01
    21ea:	00 97       	sbiw	r24, 0x00	; 0
    21ec:	c9 f1       	breq	.+114    	; 0x2260 <__stack+0x61>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    21ee:	89 81       	ldd	r24, Y+1	; 0x01
    21f0:	9a 81       	ldd	r25, Y+2	; 0x02
    21f2:	fc 01       	movw	r30, r24
    21f4:	26 81       	ldd	r18, Z+6	; 0x06
    21f6:	37 81       	ldd	r19, Z+7	; 0x07
    21f8:	89 81       	ldd	r24, Y+1	; 0x01
    21fa:	9a 81       	ldd	r25, Y+2	; 0x02
    21fc:	fc 01       	movw	r30, r24
    21fe:	84 8d       	ldd	r24, Z+28	; 0x1c
    2200:	88 2f       	mov	r24, r24
    2202:	90 e0       	ldi	r25, 0x00	; 0
    2204:	28 0f       	add	r18, r24
    2206:	39 1f       	adc	r19, r25
    2208:	89 81       	ldd	r24, Y+1	; 0x01
    220a:	9a 81       	ldd	r25, Y+2	; 0x02
    220c:	fc 01       	movw	r30, r24
    220e:	37 83       	std	Z+7, r19	; 0x07
    2210:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    2212:	89 81       	ldd	r24, Y+1	; 0x01
    2214:	9a 81       	ldd	r25, Y+2	; 0x02
    2216:	fc 01       	movw	r30, r24
    2218:	26 81       	ldd	r18, Z+6	; 0x06
    221a:	37 81       	ldd	r19, Z+7	; 0x07
    221c:	89 81       	ldd	r24, Y+1	; 0x01
    221e:	9a 81       	ldd	r25, Y+2	; 0x02
    2220:	fc 01       	movw	r30, r24
    2222:	82 81       	ldd	r24, Z+2	; 0x02
    2224:	93 81       	ldd	r25, Z+3	; 0x03
    2226:	28 17       	cp	r18, r24
    2228:	39 07       	cpc	r19, r25
    222a:	50 f0       	brcs	.+20     	; 0x2240 <__stack+0x41>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    222c:	89 81       	ldd	r24, Y+1	; 0x01
    222e:	9a 81       	ldd	r25, Y+2	; 0x02
    2230:	fc 01       	movw	r30, r24
    2232:	20 81       	ld	r18, Z
    2234:	31 81       	ldd	r19, Z+1	; 0x01
    2236:	89 81       	ldd	r24, Y+1	; 0x01
    2238:	9a 81       	ldd	r25, Y+2	; 0x02
    223a:	fc 01       	movw	r30, r24
    223c:	37 83       	std	Z+7, r19	; 0x07
    223e:	26 83       	std	Z+6, r18	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    2240:	89 81       	ldd	r24, Y+1	; 0x01
    2242:	9a 81       	ldd	r25, Y+2	; 0x02
    2244:	fc 01       	movw	r30, r24
    2246:	84 8d       	ldd	r24, Z+28	; 0x1c
    2248:	48 2f       	mov	r20, r24
    224a:	50 e0       	ldi	r21, 0x00	; 0
    224c:	89 81       	ldd	r24, Y+1	; 0x01
    224e:	9a 81       	ldd	r25, Y+2	; 0x02
    2250:	fc 01       	movw	r30, r24
    2252:	26 81       	ldd	r18, Z+6	; 0x06
    2254:	37 81       	ldd	r19, Z+7	; 0x07
    2256:	8b 81       	ldd	r24, Y+3	; 0x03
    2258:	9c 81       	ldd	r25, Y+4	; 0x04
    225a:	b9 01       	movw	r22, r18
    225c:	0e 94 d2 23 	call	0x47a4	; 0x47a4 <memcpy>
	}
}
    2260:	0f 90       	pop	r0
    2262:	0f 90       	pop	r0
    2264:	0f 90       	pop	r0
    2266:	0f 90       	pop	r0
    2268:	df 91       	pop	r29
    226a:	cf 91       	pop	r28
    226c:	08 95       	ret

0000226e <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    226e:	cf 93       	push	r28
    2270:	df 93       	push	r29
    2272:	1f 92       	push	r1
    2274:	1f 92       	push	r1
    2276:	cd b7       	in	r28, 0x3d	; 61
    2278:	de b7       	in	r29, 0x3e	; 62
    227a:	9a 83       	std	Y+2, r25	; 0x02
    227c:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    227e:	0f b6       	in	r0, 0x3f	; 63
    2280:	f8 94       	cli
    2282:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2284:	1b c0       	rjmp	.+54     	; 0x22bc <prvUnlockQueue+0x4e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2286:	89 81       	ldd	r24, Y+1	; 0x01
    2288:	9a 81       	ldd	r25, Y+2	; 0x02
    228a:	fc 01       	movw	r30, r24
    228c:	81 89       	ldd	r24, Z+17	; 0x11
    228e:	88 23       	and	r24, r24
    2290:	a1 f0       	breq	.+40     	; 0x22ba <prvUnlockQueue+0x4c>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2292:	89 81       	ldd	r24, Y+1	; 0x01
    2294:	9a 81       	ldd	r25, Y+2	; 0x02
    2296:	41 96       	adiw	r24, 0x11	; 17
    2298:	0e 94 b7 08 	call	0x116e	; 0x116e <xTaskRemoveFromEventList>
    229c:	88 23       	and	r24, r24
    229e:	11 f0       	breq	.+4      	; 0x22a4 <prvUnlockQueue+0x36>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    22a0:	0e 94 ac 09 	call	0x1358	; 0x1358 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    22a4:	89 81       	ldd	r24, Y+1	; 0x01
    22a6:	9a 81       	ldd	r25, Y+2	; 0x02
    22a8:	fc 01       	movw	r30, r24
    22aa:	86 8d       	ldd	r24, Z+30	; 0x1e
    22ac:	2f ef       	ldi	r18, 0xFF	; 255
    22ae:	28 0f       	add	r18, r24
    22b0:	89 81       	ldd	r24, Y+1	; 0x01
    22b2:	9a 81       	ldd	r25, Y+2	; 0x02
    22b4:	fc 01       	movw	r30, r24
    22b6:	26 8f       	std	Z+30, r18	; 0x1e
    22b8:	01 c0       	rjmp	.+2      	; 0x22bc <prvUnlockQueue+0x4e>
			}
			else
			{
				break;
    22ba:	06 c0       	rjmp	.+12     	; 0x22c8 <prvUnlockQueue+0x5a>
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    22bc:	89 81       	ldd	r24, Y+1	; 0x01
    22be:	9a 81       	ldd	r25, Y+2	; 0x02
    22c0:	fc 01       	movw	r30, r24
    22c2:	86 8d       	ldd	r24, Z+30	; 0x1e
    22c4:	18 16       	cp	r1, r24
    22c6:	fc f2       	brlt	.-66     	; 0x2286 <prvUnlockQueue+0x18>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    22c8:	89 81       	ldd	r24, Y+1	; 0x01
    22ca:	9a 81       	ldd	r25, Y+2	; 0x02
    22cc:	2f ef       	ldi	r18, 0xFF	; 255
    22ce:	fc 01       	movw	r30, r24
    22d0:	26 8f       	std	Z+30, r18	; 0x1e
	}
	taskEXIT_CRITICAL();
    22d2:	0f 90       	pop	r0
    22d4:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    22d6:	0f b6       	in	r0, 0x3f	; 63
    22d8:	f8 94       	cli
    22da:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    22dc:	1b c0       	rjmp	.+54     	; 0x2314 <prvUnlockQueue+0xa6>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    22de:	89 81       	ldd	r24, Y+1	; 0x01
    22e0:	9a 81       	ldd	r25, Y+2	; 0x02
    22e2:	fc 01       	movw	r30, r24
    22e4:	80 85       	ldd	r24, Z+8	; 0x08
    22e6:	88 23       	and	r24, r24
    22e8:	a1 f0       	breq	.+40     	; 0x2312 <prvUnlockQueue+0xa4>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    22ea:	89 81       	ldd	r24, Y+1	; 0x01
    22ec:	9a 81       	ldd	r25, Y+2	; 0x02
    22ee:	08 96       	adiw	r24, 0x08	; 8
    22f0:	0e 94 b7 08 	call	0x116e	; 0x116e <xTaskRemoveFromEventList>
    22f4:	88 23       	and	r24, r24
    22f6:	11 f0       	breq	.+4      	; 0x22fc <prvUnlockQueue+0x8e>
				{
					vTaskMissedYield();
    22f8:	0e 94 ac 09 	call	0x1358	; 0x1358 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    22fc:	89 81       	ldd	r24, Y+1	; 0x01
    22fe:	9a 81       	ldd	r25, Y+2	; 0x02
    2300:	fc 01       	movw	r30, r24
    2302:	85 8d       	ldd	r24, Z+29	; 0x1d
    2304:	2f ef       	ldi	r18, 0xFF	; 255
    2306:	28 0f       	add	r18, r24
    2308:	89 81       	ldd	r24, Y+1	; 0x01
    230a:	9a 81       	ldd	r25, Y+2	; 0x02
    230c:	fc 01       	movw	r30, r24
    230e:	25 8f       	std	Z+29, r18	; 0x1d
    2310:	01 c0       	rjmp	.+2      	; 0x2314 <prvUnlockQueue+0xa6>
			}
			else
			{
				break;
    2312:	06 c0       	rjmp	.+12     	; 0x2320 <prvUnlockQueue+0xb2>
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2314:	89 81       	ldd	r24, Y+1	; 0x01
    2316:	9a 81       	ldd	r25, Y+2	; 0x02
    2318:	fc 01       	movw	r30, r24
    231a:	85 8d       	ldd	r24, Z+29	; 0x1d
    231c:	18 16       	cp	r1, r24
    231e:	fc f2       	brlt	.-66     	; 0x22de <prvUnlockQueue+0x70>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    2320:	89 81       	ldd	r24, Y+1	; 0x01
    2322:	9a 81       	ldd	r25, Y+2	; 0x02
    2324:	2f ef       	ldi	r18, 0xFF	; 255
    2326:	fc 01       	movw	r30, r24
    2328:	25 8f       	std	Z+29, r18	; 0x1d
	}
	taskEXIT_CRITICAL();
    232a:	0f 90       	pop	r0
    232c:	0f be       	out	0x3f, r0	; 63
}
    232e:	0f 90       	pop	r0
    2330:	0f 90       	pop	r0
    2332:	df 91       	pop	r29
    2334:	cf 91       	pop	r28
    2336:	08 95       	ret

00002338 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    2338:	cf 93       	push	r28
    233a:	df 93       	push	r29
    233c:	00 d0       	rcall	.+0      	; 0x233e <prvIsQueueEmpty+0x6>
    233e:	cd b7       	in	r28, 0x3d	; 61
    2340:	de b7       	in	r29, 0x3e	; 62
    2342:	9b 83       	std	Y+3, r25	; 0x03
    2344:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    2346:	0f b6       	in	r0, 0x3f	; 63
    2348:	f8 94       	cli
    234a:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    234c:	8a 81       	ldd	r24, Y+2	; 0x02
    234e:	9b 81       	ldd	r25, Y+3	; 0x03
    2350:	fc 01       	movw	r30, r24
    2352:	92 8d       	ldd	r25, Z+26	; 0x1a
    2354:	81 e0       	ldi	r24, 0x01	; 1
    2356:	99 23       	and	r25, r25
    2358:	09 f0       	breq	.+2      	; 0x235c <prvIsQueueEmpty+0x24>
    235a:	80 e0       	ldi	r24, 0x00	; 0
    235c:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    235e:	0f 90       	pop	r0
    2360:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2362:	89 81       	ldd	r24, Y+1	; 0x01
}
    2364:	0f 90       	pop	r0
    2366:	0f 90       	pop	r0
    2368:	0f 90       	pop	r0
    236a:	df 91       	pop	r29
    236c:	cf 91       	pop	r28
    236e:	08 95       	ret

00002370 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    2370:	cf 93       	push	r28
    2372:	df 93       	push	r29
    2374:	00 d0       	rcall	.+0      	; 0x2376 <xQueueIsQueueEmptyFromISR+0x6>
    2376:	cd b7       	in	r28, 0x3d	; 61
    2378:	de b7       	in	r29, 0x3e	; 62
    237a:	9b 83       	std	Y+3, r25	; 0x03
    237c:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    237e:	8a 81       	ldd	r24, Y+2	; 0x02
    2380:	9b 81       	ldd	r25, Y+3	; 0x03
    2382:	fc 01       	movw	r30, r24
    2384:	92 8d       	ldd	r25, Z+26	; 0x1a
    2386:	81 e0       	ldi	r24, 0x01	; 1
    2388:	99 23       	and	r25, r25
    238a:	09 f0       	breq	.+2      	; 0x238e <xQueueIsQueueEmptyFromISR+0x1e>
    238c:	80 e0       	ldi	r24, 0x00	; 0
    238e:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    2390:	89 81       	ldd	r24, Y+1	; 0x01
}
    2392:	0f 90       	pop	r0
    2394:	0f 90       	pop	r0
    2396:	0f 90       	pop	r0
    2398:	df 91       	pop	r29
    239a:	cf 91       	pop	r28
    239c:	08 95       	ret

0000239e <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    239e:	cf 93       	push	r28
    23a0:	df 93       	push	r29
    23a2:	00 d0       	rcall	.+0      	; 0x23a4 <prvIsQueueFull+0x6>
    23a4:	cd b7       	in	r28, 0x3d	; 61
    23a6:	de b7       	in	r29, 0x3e	; 62
    23a8:	9b 83       	std	Y+3, r25	; 0x03
    23aa:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    23ac:	0f b6       	in	r0, 0x3f	; 63
    23ae:	f8 94       	cli
    23b0:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    23b2:	8a 81       	ldd	r24, Y+2	; 0x02
    23b4:	9b 81       	ldd	r25, Y+3	; 0x03
    23b6:	fc 01       	movw	r30, r24
    23b8:	22 8d       	ldd	r18, Z+26	; 0x1a
    23ba:	8a 81       	ldd	r24, Y+2	; 0x02
    23bc:	9b 81       	ldd	r25, Y+3	; 0x03
    23be:	fc 01       	movw	r30, r24
    23c0:	93 8d       	ldd	r25, Z+27	; 0x1b
    23c2:	81 e0       	ldi	r24, 0x01	; 1
    23c4:	29 17       	cp	r18, r25
    23c6:	09 f0       	breq	.+2      	; 0x23ca <prvIsQueueFull+0x2c>
    23c8:	80 e0       	ldi	r24, 0x00	; 0
    23ca:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    23cc:	0f 90       	pop	r0
    23ce:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    23d0:	89 81       	ldd	r24, Y+1	; 0x01
}
    23d2:	0f 90       	pop	r0
    23d4:	0f 90       	pop	r0
    23d6:	0f 90       	pop	r0
    23d8:	df 91       	pop	r29
    23da:	cf 91       	pop	r28
    23dc:	08 95       	ret

000023de <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    23de:	cf 93       	push	r28
    23e0:	df 93       	push	r29
    23e2:	00 d0       	rcall	.+0      	; 0x23e4 <xQueueIsQueueFullFromISR+0x6>
    23e4:	cd b7       	in	r28, 0x3d	; 61
    23e6:	de b7       	in	r29, 0x3e	; 62
    23e8:	9b 83       	std	Y+3, r25	; 0x03
    23ea:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    23ec:	8a 81       	ldd	r24, Y+2	; 0x02
    23ee:	9b 81       	ldd	r25, Y+3	; 0x03
    23f0:	fc 01       	movw	r30, r24
    23f2:	22 8d       	ldd	r18, Z+26	; 0x1a
    23f4:	8a 81       	ldd	r24, Y+2	; 0x02
    23f6:	9b 81       	ldd	r25, Y+3	; 0x03
    23f8:	fc 01       	movw	r30, r24
    23fa:	93 8d       	ldd	r25, Z+27	; 0x1b
    23fc:	81 e0       	ldi	r24, 0x01	; 1
    23fe:	29 17       	cp	r18, r25
    2400:	09 f0       	breq	.+2      	; 0x2404 <xQueueIsQueueFullFromISR+0x26>
    2402:	80 e0       	ldi	r24, 0x00	; 0
    2404:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    2406:	89 81       	ldd	r24, Y+1	; 0x01
}
    2408:	0f 90       	pop	r0
    240a:	0f 90       	pop	r0
    240c:	0f 90       	pop	r0
    240e:	df 91       	pop	r29
    2410:	cf 91       	pop	r28
    2412:	08 95       	ret

00002414 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    2414:	cf 93       	push	r28
    2416:	df 93       	push	r29
    2418:	1f 92       	push	r1
    241a:	1f 92       	push	r1
    241c:	cd b7       	in	r28, 0x3d	; 61
    241e:	de b7       	in	r29, 0x3e	; 62
    2420:	9a 83       	std	Y+2, r25	; 0x02
    2422:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    2424:	89 81       	ldd	r24, Y+1	; 0x01
    2426:	9a 81       	ldd	r25, Y+2	; 0x02
    2428:	9c 01       	movw	r18, r24
    242a:	2d 5f       	subi	r18, 0xFD	; 253
    242c:	3f 4f       	sbci	r19, 0xFF	; 255
    242e:	89 81       	ldd	r24, Y+1	; 0x01
    2430:	9a 81       	ldd	r25, Y+2	; 0x02
    2432:	fc 01       	movw	r30, r24
    2434:	32 83       	std	Z+2, r19	; 0x02
    2436:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2438:	89 81       	ldd	r24, Y+1	; 0x01
    243a:	9a 81       	ldd	r25, Y+2	; 0x02
    243c:	2f ef       	ldi	r18, 0xFF	; 255
    243e:	3f ef       	ldi	r19, 0xFF	; 255
    2440:	fc 01       	movw	r30, r24
    2442:	34 83       	std	Z+4, r19	; 0x04
    2444:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    2446:	89 81       	ldd	r24, Y+1	; 0x01
    2448:	9a 81       	ldd	r25, Y+2	; 0x02
    244a:	9c 01       	movw	r18, r24
    244c:	2d 5f       	subi	r18, 0xFD	; 253
    244e:	3f 4f       	sbci	r19, 0xFF	; 255
    2450:	89 81       	ldd	r24, Y+1	; 0x01
    2452:	9a 81       	ldd	r25, Y+2	; 0x02
    2454:	fc 01       	movw	r30, r24
    2456:	36 83       	std	Z+6, r19	; 0x06
    2458:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    245a:	89 81       	ldd	r24, Y+1	; 0x01
    245c:	9a 81       	ldd	r25, Y+2	; 0x02
    245e:	9c 01       	movw	r18, r24
    2460:	2d 5f       	subi	r18, 0xFD	; 253
    2462:	3f 4f       	sbci	r19, 0xFF	; 255
    2464:	89 81       	ldd	r24, Y+1	; 0x01
    2466:	9a 81       	ldd	r25, Y+2	; 0x02
    2468:	fc 01       	movw	r30, r24
    246a:	30 87       	std	Z+8, r19	; 0x08
    246c:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    246e:	89 81       	ldd	r24, Y+1	; 0x01
    2470:	9a 81       	ldd	r25, Y+2	; 0x02
    2472:	fc 01       	movw	r30, r24
    2474:	10 82       	st	Z, r1
}
    2476:	0f 90       	pop	r0
    2478:	0f 90       	pop	r0
    247a:	df 91       	pop	r29
    247c:	cf 91       	pop	r28
    247e:	08 95       	ret

00002480 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    2480:	cf 93       	push	r28
    2482:	df 93       	push	r29
    2484:	1f 92       	push	r1
    2486:	1f 92       	push	r1
    2488:	cd b7       	in	r28, 0x3d	; 61
    248a:	de b7       	in	r29, 0x3e	; 62
    248c:	9a 83       	std	Y+2, r25	; 0x02
    248e:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    2490:	89 81       	ldd	r24, Y+1	; 0x01
    2492:	9a 81       	ldd	r25, Y+2	; 0x02
    2494:	fc 01       	movw	r30, r24
    2496:	11 86       	std	Z+9, r1	; 0x09
    2498:	10 86       	std	Z+8, r1	; 0x08
}
    249a:	0f 90       	pop	r0
    249c:	0f 90       	pop	r0
    249e:	df 91       	pop	r29
    24a0:	cf 91       	pop	r28
    24a2:	08 95       	ret

000024a4 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    24a4:	cf 93       	push	r28
    24a6:	df 93       	push	r29
    24a8:	00 d0       	rcall	.+0      	; 0x24aa <vListInsertEnd+0x6>
    24aa:	00 d0       	rcall	.+0      	; 0x24ac <vListInsertEnd+0x8>
    24ac:	cd b7       	in	r28, 0x3d	; 61
    24ae:	de b7       	in	r29, 0x3e	; 62
    24b0:	9c 83       	std	Y+4, r25	; 0x04
    24b2:	8b 83       	std	Y+3, r24	; 0x03
    24b4:	7e 83       	std	Y+6, r23	; 0x06
    24b6:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    24b8:	8b 81       	ldd	r24, Y+3	; 0x03
    24ba:	9c 81       	ldd	r25, Y+4	; 0x04
    24bc:	fc 01       	movw	r30, r24
    24be:	81 81       	ldd	r24, Z+1	; 0x01
    24c0:	92 81       	ldd	r25, Z+2	; 0x02
    24c2:	9a 83       	std	Y+2, r25	; 0x02
    24c4:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    24c6:	89 81       	ldd	r24, Y+1	; 0x01
    24c8:	9a 81       	ldd	r25, Y+2	; 0x02
    24ca:	fc 01       	movw	r30, r24
    24cc:	22 81       	ldd	r18, Z+2	; 0x02
    24ce:	33 81       	ldd	r19, Z+3	; 0x03
    24d0:	8d 81       	ldd	r24, Y+5	; 0x05
    24d2:	9e 81       	ldd	r25, Y+6	; 0x06
    24d4:	fc 01       	movw	r30, r24
    24d6:	33 83       	std	Z+3, r19	; 0x03
    24d8:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    24da:	8b 81       	ldd	r24, Y+3	; 0x03
    24dc:	9c 81       	ldd	r25, Y+4	; 0x04
    24de:	fc 01       	movw	r30, r24
    24e0:	21 81       	ldd	r18, Z+1	; 0x01
    24e2:	32 81       	ldd	r19, Z+2	; 0x02
    24e4:	8d 81       	ldd	r24, Y+5	; 0x05
    24e6:	9e 81       	ldd	r25, Y+6	; 0x06
    24e8:	fc 01       	movw	r30, r24
    24ea:	35 83       	std	Z+5, r19	; 0x05
    24ec:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    24ee:	89 81       	ldd	r24, Y+1	; 0x01
    24f0:	9a 81       	ldd	r25, Y+2	; 0x02
    24f2:	fc 01       	movw	r30, r24
    24f4:	82 81       	ldd	r24, Z+2	; 0x02
    24f6:	93 81       	ldd	r25, Z+3	; 0x03
    24f8:	2d 81       	ldd	r18, Y+5	; 0x05
    24fa:	3e 81       	ldd	r19, Y+6	; 0x06
    24fc:	fc 01       	movw	r30, r24
    24fe:	35 83       	std	Z+5, r19	; 0x05
    2500:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    2502:	89 81       	ldd	r24, Y+1	; 0x01
    2504:	9a 81       	ldd	r25, Y+2	; 0x02
    2506:	2d 81       	ldd	r18, Y+5	; 0x05
    2508:	3e 81       	ldd	r19, Y+6	; 0x06
    250a:	fc 01       	movw	r30, r24
    250c:	33 83       	std	Z+3, r19	; 0x03
    250e:	22 83       	std	Z+2, r18	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    2510:	8b 81       	ldd	r24, Y+3	; 0x03
    2512:	9c 81       	ldd	r25, Y+4	; 0x04
    2514:	2d 81       	ldd	r18, Y+5	; 0x05
    2516:	3e 81       	ldd	r19, Y+6	; 0x06
    2518:	fc 01       	movw	r30, r24
    251a:	32 83       	std	Z+2, r19	; 0x02
    251c:	21 83       	std	Z+1, r18	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    251e:	8d 81       	ldd	r24, Y+5	; 0x05
    2520:	9e 81       	ldd	r25, Y+6	; 0x06
    2522:	2b 81       	ldd	r18, Y+3	; 0x03
    2524:	3c 81       	ldd	r19, Y+4	; 0x04
    2526:	fc 01       	movw	r30, r24
    2528:	31 87       	std	Z+9, r19	; 0x09
    252a:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    252c:	8b 81       	ldd	r24, Y+3	; 0x03
    252e:	9c 81       	ldd	r25, Y+4	; 0x04
    2530:	fc 01       	movw	r30, r24
    2532:	80 81       	ld	r24, Z
    2534:	21 e0       	ldi	r18, 0x01	; 1
    2536:	28 0f       	add	r18, r24
    2538:	8b 81       	ldd	r24, Y+3	; 0x03
    253a:	9c 81       	ldd	r25, Y+4	; 0x04
    253c:	fc 01       	movw	r30, r24
    253e:	20 83       	st	Z, r18
}
    2540:	26 96       	adiw	r28, 0x06	; 6
    2542:	0f b6       	in	r0, 0x3f	; 63
    2544:	f8 94       	cli
    2546:	de bf       	out	0x3e, r29	; 62
    2548:	0f be       	out	0x3f, r0	; 63
    254a:	cd bf       	out	0x3d, r28	; 61
    254c:	df 91       	pop	r29
    254e:	cf 91       	pop	r28
    2550:	08 95       	ret

00002552 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    2552:	cf 93       	push	r28
    2554:	df 93       	push	r29
    2556:	cd b7       	in	r28, 0x3d	; 61
    2558:	de b7       	in	r29, 0x3e	; 62
    255a:	28 97       	sbiw	r28, 0x08	; 8
    255c:	0f b6       	in	r0, 0x3f	; 63
    255e:	f8 94       	cli
    2560:	de bf       	out	0x3e, r29	; 62
    2562:	0f be       	out	0x3f, r0	; 63
    2564:	cd bf       	out	0x3d, r28	; 61
    2566:	9e 83       	std	Y+6, r25	; 0x06
    2568:	8d 83       	std	Y+5, r24	; 0x05
    256a:	78 87       	std	Y+8, r23	; 0x08
    256c:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    256e:	8f 81       	ldd	r24, Y+7	; 0x07
    2570:	98 85       	ldd	r25, Y+8	; 0x08
    2572:	fc 01       	movw	r30, r24
    2574:	80 81       	ld	r24, Z
    2576:	91 81       	ldd	r25, Z+1	; 0x01
    2578:	9c 83       	std	Y+4, r25	; 0x04
    257a:	8b 83       	std	Y+3, r24	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    257c:	8b 81       	ldd	r24, Y+3	; 0x03
    257e:	9c 81       	ldd	r25, Y+4	; 0x04
    2580:	8f 3f       	cpi	r24, 0xFF	; 255
    2582:	ff ef       	ldi	r31, 0xFF	; 255
    2584:	9f 07       	cpc	r25, r31
    2586:	41 f4       	brne	.+16     	; 0x2598 <vListInsert+0x46>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    2588:	8d 81       	ldd	r24, Y+5	; 0x05
    258a:	9e 81       	ldd	r25, Y+6	; 0x06
    258c:	fc 01       	movw	r30, r24
    258e:	87 81       	ldd	r24, Z+7	; 0x07
    2590:	90 85       	ldd	r25, Z+8	; 0x08
    2592:	9a 83       	std	Y+2, r25	; 0x02
    2594:	89 83       	std	Y+1, r24	; 0x01
    2596:	1a c0       	rjmp	.+52     	; 0x25cc <vListInsert+0x7a>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    2598:	8d 81       	ldd	r24, Y+5	; 0x05
    259a:	9e 81       	ldd	r25, Y+6	; 0x06
    259c:	03 96       	adiw	r24, 0x03	; 3
    259e:	9a 83       	std	Y+2, r25	; 0x02
    25a0:	89 83       	std	Y+1, r24	; 0x01
    25a2:	07 c0       	rjmp	.+14     	; 0x25b2 <vListInsert+0x60>
    25a4:	89 81       	ldd	r24, Y+1	; 0x01
    25a6:	9a 81       	ldd	r25, Y+2	; 0x02
    25a8:	fc 01       	movw	r30, r24
    25aa:	82 81       	ldd	r24, Z+2	; 0x02
    25ac:	93 81       	ldd	r25, Z+3	; 0x03
    25ae:	9a 83       	std	Y+2, r25	; 0x02
    25b0:	89 83       	std	Y+1, r24	; 0x01
    25b2:	89 81       	ldd	r24, Y+1	; 0x01
    25b4:	9a 81       	ldd	r25, Y+2	; 0x02
    25b6:	fc 01       	movw	r30, r24
    25b8:	82 81       	ldd	r24, Z+2	; 0x02
    25ba:	93 81       	ldd	r25, Z+3	; 0x03
    25bc:	fc 01       	movw	r30, r24
    25be:	20 81       	ld	r18, Z
    25c0:	31 81       	ldd	r19, Z+1	; 0x01
    25c2:	8b 81       	ldd	r24, Y+3	; 0x03
    25c4:	9c 81       	ldd	r25, Y+4	; 0x04
    25c6:	82 17       	cp	r24, r18
    25c8:	93 07       	cpc	r25, r19
    25ca:	60 f7       	brcc	.-40     	; 0x25a4 <vListInsert+0x52>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    25cc:	89 81       	ldd	r24, Y+1	; 0x01
    25ce:	9a 81       	ldd	r25, Y+2	; 0x02
    25d0:	fc 01       	movw	r30, r24
    25d2:	22 81       	ldd	r18, Z+2	; 0x02
    25d4:	33 81       	ldd	r19, Z+3	; 0x03
    25d6:	8f 81       	ldd	r24, Y+7	; 0x07
    25d8:	98 85       	ldd	r25, Y+8	; 0x08
    25da:	fc 01       	movw	r30, r24
    25dc:	33 83       	std	Z+3, r19	; 0x03
    25de:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    25e0:	8f 81       	ldd	r24, Y+7	; 0x07
    25e2:	98 85       	ldd	r25, Y+8	; 0x08
    25e4:	fc 01       	movw	r30, r24
    25e6:	82 81       	ldd	r24, Z+2	; 0x02
    25e8:	93 81       	ldd	r25, Z+3	; 0x03
    25ea:	2f 81       	ldd	r18, Y+7	; 0x07
    25ec:	38 85       	ldd	r19, Y+8	; 0x08
    25ee:	fc 01       	movw	r30, r24
    25f0:	35 83       	std	Z+5, r19	; 0x05
    25f2:	24 83       	std	Z+4, r18	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    25f4:	8f 81       	ldd	r24, Y+7	; 0x07
    25f6:	98 85       	ldd	r25, Y+8	; 0x08
    25f8:	29 81       	ldd	r18, Y+1	; 0x01
    25fa:	3a 81       	ldd	r19, Y+2	; 0x02
    25fc:	fc 01       	movw	r30, r24
    25fe:	35 83       	std	Z+5, r19	; 0x05
    2600:	24 83       	std	Z+4, r18	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    2602:	89 81       	ldd	r24, Y+1	; 0x01
    2604:	9a 81       	ldd	r25, Y+2	; 0x02
    2606:	2f 81       	ldd	r18, Y+7	; 0x07
    2608:	38 85       	ldd	r19, Y+8	; 0x08
    260a:	fc 01       	movw	r30, r24
    260c:	33 83       	std	Z+3, r19	; 0x03
    260e:	22 83       	std	Z+2, r18	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2610:	8f 81       	ldd	r24, Y+7	; 0x07
    2612:	98 85       	ldd	r25, Y+8	; 0x08
    2614:	2d 81       	ldd	r18, Y+5	; 0x05
    2616:	3e 81       	ldd	r19, Y+6	; 0x06
    2618:	fc 01       	movw	r30, r24
    261a:	31 87       	std	Z+9, r19	; 0x09
    261c:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    261e:	8d 81       	ldd	r24, Y+5	; 0x05
    2620:	9e 81       	ldd	r25, Y+6	; 0x06
    2622:	fc 01       	movw	r30, r24
    2624:	80 81       	ld	r24, Z
    2626:	21 e0       	ldi	r18, 0x01	; 1
    2628:	28 0f       	add	r18, r24
    262a:	8d 81       	ldd	r24, Y+5	; 0x05
    262c:	9e 81       	ldd	r25, Y+6	; 0x06
    262e:	fc 01       	movw	r30, r24
    2630:	20 83       	st	Z, r18
}
    2632:	28 96       	adiw	r28, 0x08	; 8
    2634:	0f b6       	in	r0, 0x3f	; 63
    2636:	f8 94       	cli
    2638:	de bf       	out	0x3e, r29	; 62
    263a:	0f be       	out	0x3f, r0	; 63
    263c:	cd bf       	out	0x3d, r28	; 61
    263e:	df 91       	pop	r29
    2640:	cf 91       	pop	r28
    2642:	08 95       	ret

00002644 <uxListRemove>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
{
    2644:	cf 93       	push	r28
    2646:	df 93       	push	r29
    2648:	00 d0       	rcall	.+0      	; 0x264a <uxListRemove+0x6>
    264a:	1f 92       	push	r1
    264c:	cd b7       	in	r28, 0x3d	; 61
    264e:	de b7       	in	r29, 0x3e	; 62
    2650:	9c 83       	std	Y+4, r25	; 0x04
    2652:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2654:	8b 81       	ldd	r24, Y+3	; 0x03
    2656:	9c 81       	ldd	r25, Y+4	; 0x04
    2658:	fc 01       	movw	r30, r24
    265a:	82 81       	ldd	r24, Z+2	; 0x02
    265c:	93 81       	ldd	r25, Z+3	; 0x03
    265e:	2b 81       	ldd	r18, Y+3	; 0x03
    2660:	3c 81       	ldd	r19, Y+4	; 0x04
    2662:	f9 01       	movw	r30, r18
    2664:	24 81       	ldd	r18, Z+4	; 0x04
    2666:	35 81       	ldd	r19, Z+5	; 0x05
    2668:	fc 01       	movw	r30, r24
    266a:	35 83       	std	Z+5, r19	; 0x05
    266c:	24 83       	std	Z+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    266e:	8b 81       	ldd	r24, Y+3	; 0x03
    2670:	9c 81       	ldd	r25, Y+4	; 0x04
    2672:	fc 01       	movw	r30, r24
    2674:	84 81       	ldd	r24, Z+4	; 0x04
    2676:	95 81       	ldd	r25, Z+5	; 0x05
    2678:	2b 81       	ldd	r18, Y+3	; 0x03
    267a:	3c 81       	ldd	r19, Y+4	; 0x04
    267c:	f9 01       	movw	r30, r18
    267e:	22 81       	ldd	r18, Z+2	; 0x02
    2680:	33 81       	ldd	r19, Z+3	; 0x03
    2682:	fc 01       	movw	r30, r24
    2684:	33 83       	std	Z+3, r19	; 0x03
    2686:	22 83       	std	Z+2, r18	; 0x02

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    2688:	8b 81       	ldd	r24, Y+3	; 0x03
    268a:	9c 81       	ldd	r25, Y+4	; 0x04
    268c:	fc 01       	movw	r30, r24
    268e:	80 85       	ldd	r24, Z+8	; 0x08
    2690:	91 85       	ldd	r25, Z+9	; 0x09
    2692:	9a 83       	std	Y+2, r25	; 0x02
    2694:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2696:	89 81       	ldd	r24, Y+1	; 0x01
    2698:	9a 81       	ldd	r25, Y+2	; 0x02
    269a:	fc 01       	movw	r30, r24
    269c:	21 81       	ldd	r18, Z+1	; 0x01
    269e:	32 81       	ldd	r19, Z+2	; 0x02
    26a0:	8b 81       	ldd	r24, Y+3	; 0x03
    26a2:	9c 81       	ldd	r25, Y+4	; 0x04
    26a4:	28 17       	cp	r18, r24
    26a6:	39 07       	cpc	r19, r25
    26a8:	51 f4       	brne	.+20     	; 0x26be <uxListRemove+0x7a>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    26aa:	8b 81       	ldd	r24, Y+3	; 0x03
    26ac:	9c 81       	ldd	r25, Y+4	; 0x04
    26ae:	fc 01       	movw	r30, r24
    26b0:	24 81       	ldd	r18, Z+4	; 0x04
    26b2:	35 81       	ldd	r19, Z+5	; 0x05
    26b4:	89 81       	ldd	r24, Y+1	; 0x01
    26b6:	9a 81       	ldd	r25, Y+2	; 0x02
    26b8:	fc 01       	movw	r30, r24
    26ba:	32 83       	std	Z+2, r19	; 0x02
    26bc:	21 83       	std	Z+1, r18	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    26be:	8b 81       	ldd	r24, Y+3	; 0x03
    26c0:	9c 81       	ldd	r25, Y+4	; 0x04
    26c2:	fc 01       	movw	r30, r24
    26c4:	11 86       	std	Z+9, r1	; 0x09
    26c6:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    26c8:	89 81       	ldd	r24, Y+1	; 0x01
    26ca:	9a 81       	ldd	r25, Y+2	; 0x02
    26cc:	fc 01       	movw	r30, r24
    26ce:	80 81       	ld	r24, Z
    26d0:	2f ef       	ldi	r18, 0xFF	; 255
    26d2:	28 0f       	add	r18, r24
    26d4:	89 81       	ldd	r24, Y+1	; 0x01
    26d6:	9a 81       	ldd	r25, Y+2	; 0x02
    26d8:	fc 01       	movw	r30, r24
    26da:	20 83       	st	Z, r18

	return pxList->uxNumberOfItems;
    26dc:	89 81       	ldd	r24, Y+1	; 0x01
    26de:	9a 81       	ldd	r25, Y+2	; 0x02
    26e0:	fc 01       	movw	r30, r24
    26e2:	80 81       	ld	r24, Z
}
    26e4:	0f 90       	pop	r0
    26e6:	0f 90       	pop	r0
    26e8:	0f 90       	pop	r0
    26ea:	0f 90       	pop	r0
    26ec:	df 91       	pop	r29
    26ee:	cf 91       	pop	r28
    26f0:	08 95       	ret

000026f2 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    26f2:	cf 93       	push	r28
    26f4:	df 93       	push	r29
    26f6:	cd b7       	in	r28, 0x3d	; 61
    26f8:	de b7       	in	r29, 0x3e	; 62
    26fa:	27 97       	sbiw	r28, 0x07	; 7
    26fc:	0f b6       	in	r0, 0x3f	; 63
    26fe:	f8 94       	cli
    2700:	de bf       	out	0x3e, r29	; 62
    2702:	0f be       	out	0x3f, r0	; 63
    2704:	cd bf       	out	0x3d, r28	; 61
    2706:	9d 83       	std	Y+5, r25	; 0x05
    2708:	8c 83       	std	Y+4, r24	; 0x04
    270a:	6e 83       	std	Y+6, r22	; 0x06
    270c:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    270e:	8a e1       	ldi	r24, 0x1A	; 26
    2710:	90 e0       	ldi	r25, 0x00	; 0
    2712:	0e 94 71 16 	call	0x2ce2	; 0x2ce2 <pvPortMalloc>
    2716:	9b 83       	std	Y+3, r25	; 0x03
    2718:	8a 83       	std	Y+2, r24	; 0x02
	if( pxCoRoutine )
    271a:	8a 81       	ldd	r24, Y+2	; 0x02
    271c:	9b 81       	ldd	r25, Y+3	; 0x03
    271e:	00 97       	sbiw	r24, 0x00	; 0
    2720:	09 f4       	brne	.+2      	; 0x2724 <xCoRoutineCreate+0x32>
    2722:	77 c0       	rjmp	.+238    	; 0x2812 <xCoRoutineCreate+0x120>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    2724:	80 91 87 02 	lds	r24, 0x0287
    2728:	90 91 88 02 	lds	r25, 0x0288
    272c:	00 97       	sbiw	r24, 0x00	; 0
    272e:	41 f4       	brne	.+16     	; 0x2740 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    2730:	8a 81       	ldd	r24, Y+2	; 0x02
    2732:	9b 81       	ldd	r25, Y+3	; 0x03
    2734:	90 93 88 02 	sts	0x0288, r25
    2738:	80 93 87 02 	sts	0x0287, r24
			prvInitialiseCoRoutineLists();
    273c:	0e 94 ff 15 	call	0x2bfe	; 0x2bfe <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    2740:	8e 81       	ldd	r24, Y+6	; 0x06
    2742:	82 30       	cpi	r24, 0x02	; 2
    2744:	10 f0       	brcs	.+4      	; 0x274a <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    2746:	81 e0       	ldi	r24, 0x01	; 1
    2748:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    274a:	8a 81       	ldd	r24, Y+2	; 0x02
    274c:	9b 81       	ldd	r25, Y+3	; 0x03
    274e:	fc 01       	movw	r30, r24
    2750:	11 8e       	std	Z+25, r1	; 0x19
    2752:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    2754:	8a 81       	ldd	r24, Y+2	; 0x02
    2756:	9b 81       	ldd	r25, Y+3	; 0x03
    2758:	2e 81       	ldd	r18, Y+6	; 0x06
    275a:	fc 01       	movw	r30, r24
    275c:	26 8b       	std	Z+22, r18	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    275e:	8a 81       	ldd	r24, Y+2	; 0x02
    2760:	9b 81       	ldd	r25, Y+3	; 0x03
    2762:	2f 81       	ldd	r18, Y+7	; 0x07
    2764:	fc 01       	movw	r30, r24
    2766:	27 8b       	std	Z+23, r18	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    2768:	8a 81       	ldd	r24, Y+2	; 0x02
    276a:	9b 81       	ldd	r25, Y+3	; 0x03
    276c:	2c 81       	ldd	r18, Y+4	; 0x04
    276e:	3d 81       	ldd	r19, Y+5	; 0x05
    2770:	fc 01       	movw	r30, r24
    2772:	31 83       	std	Z+1, r19	; 0x01
    2774:	20 83       	st	Z, r18

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    2776:	8a 81       	ldd	r24, Y+2	; 0x02
    2778:	9b 81       	ldd	r25, Y+3	; 0x03
    277a:	02 96       	adiw	r24, 0x02	; 2
    277c:	0e 94 40 12 	call	0x2480	; 0x2480 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    2780:	8a 81       	ldd	r24, Y+2	; 0x02
    2782:	9b 81       	ldd	r25, Y+3	; 0x03
    2784:	0c 96       	adiw	r24, 0x0c	; 12
    2786:	0e 94 40 12 	call	0x2480	; 0x2480 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    278a:	8a 81       	ldd	r24, Y+2	; 0x02
    278c:	9b 81       	ldd	r25, Y+3	; 0x03
    278e:	2a 81       	ldd	r18, Y+2	; 0x02
    2790:	3b 81       	ldd	r19, Y+3	; 0x03
    2792:	fc 01       	movw	r30, r24
    2794:	31 87       	std	Z+9, r19	; 0x09
    2796:	20 87       	std	Z+8, r18	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    2798:	8a 81       	ldd	r24, Y+2	; 0x02
    279a:	9b 81       	ldd	r25, Y+3	; 0x03
    279c:	2a 81       	ldd	r18, Y+2	; 0x02
    279e:	3b 81       	ldd	r19, Y+3	; 0x03
    27a0:	fc 01       	movw	r30, r24
    27a2:	33 8b       	std	Z+19, r19	; 0x13
    27a4:	22 8b       	std	Z+18, r18	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    27a6:	8e 81       	ldd	r24, Y+6	; 0x06
    27a8:	88 2f       	mov	r24, r24
    27aa:	90 e0       	ldi	r25, 0x00	; 0
    27ac:	24 e0       	ldi	r18, 0x04	; 4
    27ae:	30 e0       	ldi	r19, 0x00	; 0
    27b0:	28 1b       	sub	r18, r24
    27b2:	39 0b       	sbc	r19, r25
    27b4:	8a 81       	ldd	r24, Y+2	; 0x02
    27b6:	9b 81       	ldd	r25, Y+3	; 0x03
    27b8:	fc 01       	movw	r30, r24
    27ba:	35 87       	std	Z+13, r19	; 0x0d
    27bc:	24 87       	std	Z+12, r18	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    27be:	8a 81       	ldd	r24, Y+2	; 0x02
    27c0:	9b 81       	ldd	r25, Y+3	; 0x03
    27c2:	fc 01       	movw	r30, r24
    27c4:	96 89       	ldd	r25, Z+22	; 0x16
    27c6:	80 91 ba 02 	lds	r24, 0x02BA
    27ca:	89 17       	cp	r24, r25
    27cc:	30 f4       	brcc	.+12     	; 0x27da <xCoRoutineCreate+0xe8>
    27ce:	8a 81       	ldd	r24, Y+2	; 0x02
    27d0:	9b 81       	ldd	r25, Y+3	; 0x03
    27d2:	fc 01       	movw	r30, r24
    27d4:	86 89       	ldd	r24, Z+22	; 0x16
    27d6:	80 93 ba 02 	sts	0x02BA, r24
    27da:	8a 81       	ldd	r24, Y+2	; 0x02
    27dc:	9b 81       	ldd	r25, Y+3	; 0x03
    27de:	ac 01       	movw	r20, r24
    27e0:	4e 5f       	subi	r20, 0xFE	; 254
    27e2:	5f 4f       	sbci	r21, 0xFF	; 255
    27e4:	8a 81       	ldd	r24, Y+2	; 0x02
    27e6:	9b 81       	ldd	r25, Y+3	; 0x03
    27e8:	fc 01       	movw	r30, r24
    27ea:	86 89       	ldd	r24, Z+22	; 0x16
    27ec:	28 2f       	mov	r18, r24
    27ee:	30 e0       	ldi	r19, 0x00	; 0
    27f0:	c9 01       	movw	r24, r18
    27f2:	88 0f       	add	r24, r24
    27f4:	99 1f       	adc	r25, r25
    27f6:	88 0f       	add	r24, r24
    27f8:	99 1f       	adc	r25, r25
    27fa:	88 0f       	add	r24, r24
    27fc:	99 1f       	adc	r25, r25
    27fe:	82 0f       	add	r24, r18
    2800:	93 1f       	adc	r25, r19
    2802:	87 57       	subi	r24, 0x77	; 119
    2804:	9d 4f       	sbci	r25, 0xFD	; 253
    2806:	ba 01       	movw	r22, r20
    2808:	0e 94 52 12 	call	0x24a4	; 0x24a4 <vListInsertEnd>

		xReturn = pdPASS;
    280c:	81 e0       	ldi	r24, 0x01	; 1
    280e:	89 83       	std	Y+1, r24	; 0x01
    2810:	02 c0       	rjmp	.+4      	; 0x2816 <xCoRoutineCreate+0x124>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2812:	8f ef       	ldi	r24, 0xFF	; 255
    2814:	89 83       	std	Y+1, r24	; 0x01
	}
	
	return xReturn;	
    2816:	89 81       	ldd	r24, Y+1	; 0x01
}
    2818:	27 96       	adiw	r28, 0x07	; 7
    281a:	0f b6       	in	r0, 0x3f	; 63
    281c:	f8 94       	cli
    281e:	de bf       	out	0x3e, r29	; 62
    2820:	0f be       	out	0x3f, r0	; 63
    2822:	cd bf       	out	0x3d, r28	; 61
    2824:	df 91       	pop	r29
    2826:	cf 91       	pop	r28
    2828:	08 95       	ret

0000282a <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    282a:	cf 93       	push	r28
    282c:	df 93       	push	r29
    282e:	00 d0       	rcall	.+0      	; 0x2830 <vCoRoutineAddToDelayedList+0x6>
    2830:	00 d0       	rcall	.+0      	; 0x2832 <vCoRoutineAddToDelayedList+0x8>
    2832:	cd b7       	in	r28, 0x3d	; 61
    2834:	de b7       	in	r29, 0x3e	; 62
    2836:	9c 83       	std	Y+4, r25	; 0x04
    2838:	8b 83       	std	Y+3, r24	; 0x03
    283a:	7e 83       	std	Y+6, r23	; 0x06
    283c:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    283e:	20 91 bb 02 	lds	r18, 0x02BB
    2842:	30 91 bc 02 	lds	r19, 0x02BC
    2846:	8b 81       	ldd	r24, Y+3	; 0x03
    2848:	9c 81       	ldd	r25, Y+4	; 0x04
    284a:	82 0f       	add	r24, r18
    284c:	93 1f       	adc	r25, r19
    284e:	9a 83       	std	Y+2, r25	; 0x02
    2850:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2852:	80 91 87 02 	lds	r24, 0x0287
    2856:	90 91 88 02 	lds	r25, 0x0288
    285a:	02 96       	adiw	r24, 0x02	; 2
    285c:	0e 94 22 13 	call	0x2644	; 0x2644 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    2860:	80 91 87 02 	lds	r24, 0x0287
    2864:	90 91 88 02 	lds	r25, 0x0288
    2868:	29 81       	ldd	r18, Y+1	; 0x01
    286a:	3a 81       	ldd	r19, Y+2	; 0x02
    286c:	fc 01       	movw	r30, r24
    286e:	33 83       	std	Z+3, r19	; 0x03
    2870:	22 83       	std	Z+2, r18	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    2872:	80 91 bb 02 	lds	r24, 0x02BB
    2876:	90 91 bc 02 	lds	r25, 0x02BC
    287a:	29 81       	ldd	r18, Y+1	; 0x01
    287c:	3a 81       	ldd	r19, Y+2	; 0x02
    287e:	28 17       	cp	r18, r24
    2880:	39 07       	cpc	r19, r25
    2882:	78 f4       	brcc	.+30     	; 0x28a2 <vCoRoutineAddToDelayedList+0x78>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2884:	80 91 87 02 	lds	r24, 0x0287
    2888:	90 91 88 02 	lds	r25, 0x0288
    288c:	9c 01       	movw	r18, r24
    288e:	2e 5f       	subi	r18, 0xFE	; 254
    2890:	3f 4f       	sbci	r19, 0xFF	; 255
    2892:	80 91 af 02 	lds	r24, 0x02AF
    2896:	90 91 b0 02 	lds	r25, 0x02B0
    289a:	b9 01       	movw	r22, r18
    289c:	0e 94 a9 12 	call	0x2552	; 0x2552 <vListInsert>
    28a0:	0e c0       	rjmp	.+28     	; 0x28be <vCoRoutineAddToDelayedList+0x94>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    28a2:	80 91 87 02 	lds	r24, 0x0287
    28a6:	90 91 88 02 	lds	r25, 0x0288
    28aa:	9c 01       	movw	r18, r24
    28ac:	2e 5f       	subi	r18, 0xFE	; 254
    28ae:	3f 4f       	sbci	r19, 0xFF	; 255
    28b0:	80 91 ad 02 	lds	r24, 0x02AD
    28b4:	90 91 ae 02 	lds	r25, 0x02AE
    28b8:	b9 01       	movw	r22, r18
    28ba:	0e 94 a9 12 	call	0x2552	; 0x2552 <vListInsert>
	}

	if( pxEventList )
    28be:	8d 81       	ldd	r24, Y+5	; 0x05
    28c0:	9e 81       	ldd	r25, Y+6	; 0x06
    28c2:	00 97       	sbiw	r24, 0x00	; 0
    28c4:	61 f0       	breq	.+24     	; 0x28de <vCoRoutineAddToDelayedList+0xb4>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    28c6:	80 91 87 02 	lds	r24, 0x0287
    28ca:	90 91 88 02 	lds	r25, 0x0288
    28ce:	9c 01       	movw	r18, r24
    28d0:	24 5f       	subi	r18, 0xF4	; 244
    28d2:	3f 4f       	sbci	r19, 0xFF	; 255
    28d4:	8d 81       	ldd	r24, Y+5	; 0x05
    28d6:	9e 81       	ldd	r25, Y+6	; 0x06
    28d8:	b9 01       	movw	r22, r18
    28da:	0e 94 a9 12 	call	0x2552	; 0x2552 <vListInsert>
	}
}
    28de:	26 96       	adiw	r28, 0x06	; 6
    28e0:	0f b6       	in	r0, 0x3f	; 63
    28e2:	f8 94       	cli
    28e4:	de bf       	out	0x3e, r29	; 62
    28e6:	0f be       	out	0x3f, r0	; 63
    28e8:	cd bf       	out	0x3d, r28	; 61
    28ea:	df 91       	pop	r29
    28ec:	cf 91       	pop	r28
    28ee:	08 95       	ret

000028f0 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    28f0:	cf 93       	push	r28
    28f2:	df 93       	push	r29
    28f4:	1f 92       	push	r1
    28f6:	1f 92       	push	r1
    28f8:	cd b7       	in	r28, 0x3d	; 61
    28fa:	de b7       	in	r29, 0x3e	; 62
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    28fc:	3c c0       	rjmp	.+120    	; 0x2976 <prvCheckPendingReadyList+0x86>
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    28fe:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    2900:	80 91 b6 02 	lds	r24, 0x02B6
    2904:	90 91 b7 02 	lds	r25, 0x02B7
    2908:	fc 01       	movw	r30, r24
    290a:	86 81       	ldd	r24, Z+6	; 0x06
    290c:	97 81       	ldd	r25, Z+7	; 0x07
    290e:	9a 83       	std	Y+2, r25	; 0x02
    2910:	89 83       	std	Y+1, r24	; 0x01
			uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2912:	89 81       	ldd	r24, Y+1	; 0x01
    2914:	9a 81       	ldd	r25, Y+2	; 0x02
    2916:	0c 96       	adiw	r24, 0x0c	; 12
    2918:	0e 94 22 13 	call	0x2644	; 0x2644 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    291c:	78 94       	sei

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    291e:	89 81       	ldd	r24, Y+1	; 0x01
    2920:	9a 81       	ldd	r25, Y+2	; 0x02
    2922:	02 96       	adiw	r24, 0x02	; 2
    2924:	0e 94 22 13 	call	0x2644	; 0x2644 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    2928:	89 81       	ldd	r24, Y+1	; 0x01
    292a:	9a 81       	ldd	r25, Y+2	; 0x02
    292c:	fc 01       	movw	r30, r24
    292e:	96 89       	ldd	r25, Z+22	; 0x16
    2930:	80 91 ba 02 	lds	r24, 0x02BA
    2934:	89 17       	cp	r24, r25
    2936:	30 f4       	brcc	.+12     	; 0x2944 <prvCheckPendingReadyList+0x54>
    2938:	89 81       	ldd	r24, Y+1	; 0x01
    293a:	9a 81       	ldd	r25, Y+2	; 0x02
    293c:	fc 01       	movw	r30, r24
    293e:	86 89       	ldd	r24, Z+22	; 0x16
    2940:	80 93 ba 02 	sts	0x02BA, r24
    2944:	89 81       	ldd	r24, Y+1	; 0x01
    2946:	9a 81       	ldd	r25, Y+2	; 0x02
    2948:	ac 01       	movw	r20, r24
    294a:	4e 5f       	subi	r20, 0xFE	; 254
    294c:	5f 4f       	sbci	r21, 0xFF	; 255
    294e:	89 81       	ldd	r24, Y+1	; 0x01
    2950:	9a 81       	ldd	r25, Y+2	; 0x02
    2952:	fc 01       	movw	r30, r24
    2954:	86 89       	ldd	r24, Z+22	; 0x16
    2956:	28 2f       	mov	r18, r24
    2958:	30 e0       	ldi	r19, 0x00	; 0
    295a:	c9 01       	movw	r24, r18
    295c:	88 0f       	add	r24, r24
    295e:	99 1f       	adc	r25, r25
    2960:	88 0f       	add	r24, r24
    2962:	99 1f       	adc	r25, r25
    2964:	88 0f       	add	r24, r24
    2966:	99 1f       	adc	r25, r25
    2968:	82 0f       	add	r24, r18
    296a:	93 1f       	adc	r25, r19
    296c:	87 57       	subi	r24, 0x77	; 119
    296e:	9d 4f       	sbci	r25, 0xFD	; 253
    2970:	ba 01       	movw	r22, r20
    2972:	0e 94 52 12 	call	0x24a4	; 0x24a4 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    2976:	80 91 b1 02 	lds	r24, 0x02B1
    297a:	88 23       	and	r24, r24
    297c:	09 f0       	breq	.+2      	; 0x2980 <prvCheckPendingReadyList+0x90>
    297e:	bf cf       	rjmp	.-130    	; 0x28fe <prvCheckPendingReadyList+0xe>
		portENABLE_INTERRUPTS();

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    2980:	0f 90       	pop	r0
    2982:	0f 90       	pop	r0
    2984:	df 91       	pop	r29
    2986:	cf 91       	pop	r28
    2988:	08 95       	ret

0000298a <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    298a:	cf 93       	push	r28
    298c:	df 93       	push	r29
    298e:	00 d0       	rcall	.+0      	; 0x2990 <prvCheckDelayedList+0x6>
    2990:	1f 92       	push	r1
    2992:	cd b7       	in	r28, 0x3d	; 61
    2994:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    2996:	0e 94 d3 06 	call	0xda6	; 0xda6 <xTaskGetTickCount>
    299a:	9c 01       	movw	r18, r24
    299c:	80 91 bd 02 	lds	r24, 0x02BD
    29a0:	90 91 be 02 	lds	r25, 0x02BE
    29a4:	a9 01       	movw	r20, r18
    29a6:	48 1b       	sub	r20, r24
    29a8:	59 0b       	sbc	r21, r25
    29aa:	ca 01       	movw	r24, r20
    29ac:	90 93 c0 02 	sts	0x02C0, r25
    29b0:	80 93 bf 02 	sts	0x02BF, r24
	while( xPassedTicks )
    29b4:	8a c0       	rjmp	.+276    	; 0x2aca <prvCheckDelayedList+0x140>
	{
		xCoRoutineTickCount++;
    29b6:	80 91 bb 02 	lds	r24, 0x02BB
    29ba:	90 91 bc 02 	lds	r25, 0x02BC
    29be:	01 96       	adiw	r24, 0x01	; 1
    29c0:	90 93 bc 02 	sts	0x02BC, r25
    29c4:	80 93 bb 02 	sts	0x02BB, r24
		xPassedTicks--;
    29c8:	80 91 bf 02 	lds	r24, 0x02BF
    29cc:	90 91 c0 02 	lds	r25, 0x02C0
    29d0:	01 97       	sbiw	r24, 0x01	; 1
    29d2:	90 93 c0 02 	sts	0x02C0, r25
    29d6:	80 93 bf 02 	sts	0x02BF, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    29da:	80 91 bb 02 	lds	r24, 0x02BB
    29de:	90 91 bc 02 	lds	r25, 0x02BC
    29e2:	00 97       	sbiw	r24, 0x00	; 0
    29e4:	a9 f4       	brne	.+42     	; 0x2a10 <prvCheckDelayedList+0x86>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    29e6:	80 91 ad 02 	lds	r24, 0x02AD
    29ea:	90 91 ae 02 	lds	r25, 0x02AE
    29ee:	9a 83       	std	Y+2, r25	; 0x02
    29f0:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    29f2:	80 91 af 02 	lds	r24, 0x02AF
    29f6:	90 91 b0 02 	lds	r25, 0x02B0
    29fa:	90 93 ae 02 	sts	0x02AE, r25
    29fe:	80 93 ad 02 	sts	0x02AD, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    2a02:	89 81       	ldd	r24, Y+1	; 0x01
    2a04:	9a 81       	ldd	r25, Y+2	; 0x02
    2a06:	90 93 b0 02 	sts	0x02B0, r25
    2a0a:	80 93 af 02 	sts	0x02AF, r24
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    2a0e:	54 c0       	rjmp	.+168    	; 0x2ab8 <prvCheckDelayedList+0x12e>
    2a10:	53 c0       	rjmp	.+166    	; 0x2ab8 <prvCheckDelayedList+0x12e>
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    2a12:	80 91 ad 02 	lds	r24, 0x02AD
    2a16:	90 91 ae 02 	lds	r25, 0x02AE
    2a1a:	fc 01       	movw	r30, r24
    2a1c:	85 81       	ldd	r24, Z+5	; 0x05
    2a1e:	96 81       	ldd	r25, Z+6	; 0x06
    2a20:	fc 01       	movw	r30, r24
    2a22:	86 81       	ldd	r24, Z+6	; 0x06
    2a24:	97 81       	ldd	r25, Z+7	; 0x07
    2a26:	9c 83       	std	Y+4, r25	; 0x04
    2a28:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    2a2a:	8b 81       	ldd	r24, Y+3	; 0x03
    2a2c:	9c 81       	ldd	r25, Y+4	; 0x04
    2a2e:	fc 01       	movw	r30, r24
    2a30:	22 81       	ldd	r18, Z+2	; 0x02
    2a32:	33 81       	ldd	r19, Z+3	; 0x03
    2a34:	80 91 bb 02 	lds	r24, 0x02BB
    2a38:	90 91 bc 02 	lds	r25, 0x02BC
    2a3c:	82 17       	cp	r24, r18
    2a3e:	93 07       	cpc	r25, r19
    2a40:	08 f4       	brcc	.+2      	; 0x2a44 <prvCheckDelayedList+0xba>
			{			
				/* Timeout not yet expired. */																			
				break;																				
    2a42:	43 c0       	rjmp	.+134    	; 0x2aca <prvCheckDelayedList+0x140>
			}																						

			portDISABLE_INTERRUPTS();
    2a44:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				uxListRemove( &( pxCRCB->xGenericListItem ) );											
    2a46:	8b 81       	ldd	r24, Y+3	; 0x03
    2a48:	9c 81       	ldd	r25, Y+4	; 0x04
    2a4a:	02 96       	adiw	r24, 0x02	; 2
    2a4c:	0e 94 22 13 	call	0x2644	; 0x2644 <uxListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    2a50:	8b 81       	ldd	r24, Y+3	; 0x03
    2a52:	9c 81       	ldd	r25, Y+4	; 0x04
    2a54:	fc 01       	movw	r30, r24
    2a56:	84 89       	ldd	r24, Z+20	; 0x14
    2a58:	95 89       	ldd	r25, Z+21	; 0x15
    2a5a:	00 97       	sbiw	r24, 0x00	; 0
    2a5c:	29 f0       	breq	.+10     	; 0x2a68 <prvCheckDelayedList+0xde>
				{															
					uxListRemove( &( pxCRCB->xEventListItem ) );											
    2a5e:	8b 81       	ldd	r24, Y+3	; 0x03
    2a60:	9c 81       	ldd	r25, Y+4	; 0x04
    2a62:	0c 96       	adiw	r24, 0x0c	; 12
    2a64:	0e 94 22 13 	call	0x2644	; 0x2644 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    2a68:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    2a6a:	8b 81       	ldd	r24, Y+3	; 0x03
    2a6c:	9c 81       	ldd	r25, Y+4	; 0x04
    2a6e:	fc 01       	movw	r30, r24
    2a70:	96 89       	ldd	r25, Z+22	; 0x16
    2a72:	80 91 ba 02 	lds	r24, 0x02BA
    2a76:	89 17       	cp	r24, r25
    2a78:	30 f4       	brcc	.+12     	; 0x2a86 <prvCheckDelayedList+0xfc>
    2a7a:	8b 81       	ldd	r24, Y+3	; 0x03
    2a7c:	9c 81       	ldd	r25, Y+4	; 0x04
    2a7e:	fc 01       	movw	r30, r24
    2a80:	86 89       	ldd	r24, Z+22	; 0x16
    2a82:	80 93 ba 02 	sts	0x02BA, r24
    2a86:	8b 81       	ldd	r24, Y+3	; 0x03
    2a88:	9c 81       	ldd	r25, Y+4	; 0x04
    2a8a:	ac 01       	movw	r20, r24
    2a8c:	4e 5f       	subi	r20, 0xFE	; 254
    2a8e:	5f 4f       	sbci	r21, 0xFF	; 255
    2a90:	8b 81       	ldd	r24, Y+3	; 0x03
    2a92:	9c 81       	ldd	r25, Y+4	; 0x04
    2a94:	fc 01       	movw	r30, r24
    2a96:	86 89       	ldd	r24, Z+22	; 0x16
    2a98:	28 2f       	mov	r18, r24
    2a9a:	30 e0       	ldi	r19, 0x00	; 0
    2a9c:	c9 01       	movw	r24, r18
    2a9e:	88 0f       	add	r24, r24
    2aa0:	99 1f       	adc	r25, r25
    2aa2:	88 0f       	add	r24, r24
    2aa4:	99 1f       	adc	r25, r25
    2aa6:	88 0f       	add	r24, r24
    2aa8:	99 1f       	adc	r25, r25
    2aaa:	82 0f       	add	r24, r18
    2aac:	93 1f       	adc	r25, r19
    2aae:	87 57       	subi	r24, 0x77	; 119
    2ab0:	9d 4f       	sbci	r25, 0xFD	; 253
    2ab2:	ba 01       	movw	r22, r20
    2ab4:	0e 94 52 12 	call	0x24a4	; 0x24a4 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    2ab8:	80 91 ad 02 	lds	r24, 0x02AD
    2abc:	90 91 ae 02 	lds	r25, 0x02AE
    2ac0:	fc 01       	movw	r30, r24
    2ac2:	80 81       	ld	r24, Z
    2ac4:	88 23       	and	r24, r24
    2ac6:	09 f0       	breq	.+2      	; 0x2aca <prvCheckDelayedList+0x140>
    2ac8:	a4 cf       	rjmp	.-184    	; 0x2a12 <prvCheckDelayedList+0x88>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    2aca:	80 91 bf 02 	lds	r24, 0x02BF
    2ace:	90 91 c0 02 	lds	r25, 0x02C0
    2ad2:	00 97       	sbiw	r24, 0x00	; 0
    2ad4:	09 f0       	breq	.+2      	; 0x2ad8 <prvCheckDelayedList+0x14e>
    2ad6:	6f cf       	rjmp	.-290    	; 0x29b6 <prvCheckDelayedList+0x2c>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    2ad8:	80 91 bb 02 	lds	r24, 0x02BB
    2adc:	90 91 bc 02 	lds	r25, 0x02BC
    2ae0:	90 93 be 02 	sts	0x02BE, r25
    2ae4:	80 93 bd 02 	sts	0x02BD, r24
}
    2ae8:	0f 90       	pop	r0
    2aea:	0f 90       	pop	r0
    2aec:	0f 90       	pop	r0
    2aee:	0f 90       	pop	r0
    2af0:	df 91       	pop	r29
    2af2:	cf 91       	pop	r28
    2af4:	08 95       	ret

00002af6 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    2af6:	cf 93       	push	r28
    2af8:	df 93       	push	r29
    2afa:	1f 92       	push	r1
    2afc:	1f 92       	push	r1
    2afe:	cd b7       	in	r28, 0x3d	; 61
    2b00:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    2b02:	0e 94 78 14 	call	0x28f0	; 0x28f0 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    2b06:	0e 94 c5 14 	call	0x298a	; 0x298a <prvCheckDelayedList>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2b0a:	0a c0       	rjmp	.+20     	; 0x2b20 <vCoRoutineSchedule+0x2a>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    2b0c:	80 91 ba 02 	lds	r24, 0x02BA
    2b10:	88 23       	and	r24, r24
    2b12:	09 f4       	brne	.+2      	; 0x2b16 <vCoRoutineSchedule+0x20>
		{
			/* No more co-routines to check. */
			return;
    2b14:	6f c0       	rjmp	.+222    	; 0x2bf4 <vCoRoutineSchedule+0xfe>
		}
		--uxTopCoRoutineReadyPriority;
    2b16:	80 91 ba 02 	lds	r24, 0x02BA
    2b1a:	81 50       	subi	r24, 0x01	; 1
    2b1c:	80 93 ba 02 	sts	0x02BA, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2b20:	80 91 ba 02 	lds	r24, 0x02BA
    2b24:	28 2f       	mov	r18, r24
    2b26:	30 e0       	ldi	r19, 0x00	; 0
    2b28:	c9 01       	movw	r24, r18
    2b2a:	88 0f       	add	r24, r24
    2b2c:	99 1f       	adc	r25, r25
    2b2e:	88 0f       	add	r24, r24
    2b30:	99 1f       	adc	r25, r25
    2b32:	88 0f       	add	r24, r24
    2b34:	99 1f       	adc	r25, r25
    2b36:	82 0f       	add	r24, r18
    2b38:	93 1f       	adc	r25, r19
    2b3a:	87 57       	subi	r24, 0x77	; 119
    2b3c:	9d 4f       	sbci	r25, 0xFD	; 253
    2b3e:	fc 01       	movw	r30, r24
    2b40:	80 81       	ld	r24, Z
    2b42:	88 23       	and	r24, r24
    2b44:	19 f3       	breq	.-58     	; 0x2b0c <vCoRoutineSchedule+0x16>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    2b46:	80 91 ba 02 	lds	r24, 0x02BA
    2b4a:	28 2f       	mov	r18, r24
    2b4c:	30 e0       	ldi	r19, 0x00	; 0
    2b4e:	c9 01       	movw	r24, r18
    2b50:	88 0f       	add	r24, r24
    2b52:	99 1f       	adc	r25, r25
    2b54:	88 0f       	add	r24, r24
    2b56:	99 1f       	adc	r25, r25
    2b58:	88 0f       	add	r24, r24
    2b5a:	99 1f       	adc	r25, r25
    2b5c:	82 0f       	add	r24, r18
    2b5e:	93 1f       	adc	r25, r19
    2b60:	87 57       	subi	r24, 0x77	; 119
    2b62:	9d 4f       	sbci	r25, 0xFD	; 253
    2b64:	9a 83       	std	Y+2, r25	; 0x02
    2b66:	89 83       	std	Y+1, r24	; 0x01
    2b68:	89 81       	ldd	r24, Y+1	; 0x01
    2b6a:	9a 81       	ldd	r25, Y+2	; 0x02
    2b6c:	fc 01       	movw	r30, r24
    2b6e:	81 81       	ldd	r24, Z+1	; 0x01
    2b70:	92 81       	ldd	r25, Z+2	; 0x02
    2b72:	fc 01       	movw	r30, r24
    2b74:	22 81       	ldd	r18, Z+2	; 0x02
    2b76:	33 81       	ldd	r19, Z+3	; 0x03
    2b78:	89 81       	ldd	r24, Y+1	; 0x01
    2b7a:	9a 81       	ldd	r25, Y+2	; 0x02
    2b7c:	fc 01       	movw	r30, r24
    2b7e:	32 83       	std	Z+2, r19	; 0x02
    2b80:	21 83       	std	Z+1, r18	; 0x01
    2b82:	89 81       	ldd	r24, Y+1	; 0x01
    2b84:	9a 81       	ldd	r25, Y+2	; 0x02
    2b86:	fc 01       	movw	r30, r24
    2b88:	21 81       	ldd	r18, Z+1	; 0x01
    2b8a:	32 81       	ldd	r19, Z+2	; 0x02
    2b8c:	89 81       	ldd	r24, Y+1	; 0x01
    2b8e:	9a 81       	ldd	r25, Y+2	; 0x02
    2b90:	03 96       	adiw	r24, 0x03	; 3
    2b92:	28 17       	cp	r18, r24
    2b94:	39 07       	cpc	r19, r25
    2b96:	69 f4       	brne	.+26     	; 0x2bb2 <vCoRoutineSchedule+0xbc>
    2b98:	89 81       	ldd	r24, Y+1	; 0x01
    2b9a:	9a 81       	ldd	r25, Y+2	; 0x02
    2b9c:	fc 01       	movw	r30, r24
    2b9e:	81 81       	ldd	r24, Z+1	; 0x01
    2ba0:	92 81       	ldd	r25, Z+2	; 0x02
    2ba2:	fc 01       	movw	r30, r24
    2ba4:	22 81       	ldd	r18, Z+2	; 0x02
    2ba6:	33 81       	ldd	r19, Z+3	; 0x03
    2ba8:	89 81       	ldd	r24, Y+1	; 0x01
    2baa:	9a 81       	ldd	r25, Y+2	; 0x02
    2bac:	fc 01       	movw	r30, r24
    2bae:	32 83       	std	Z+2, r19	; 0x02
    2bb0:	21 83       	std	Z+1, r18	; 0x01
    2bb2:	89 81       	ldd	r24, Y+1	; 0x01
    2bb4:	9a 81       	ldd	r25, Y+2	; 0x02
    2bb6:	fc 01       	movw	r30, r24
    2bb8:	81 81       	ldd	r24, Z+1	; 0x01
    2bba:	92 81       	ldd	r25, Z+2	; 0x02
    2bbc:	fc 01       	movw	r30, r24
    2bbe:	86 81       	ldd	r24, Z+6	; 0x06
    2bc0:	97 81       	ldd	r25, Z+7	; 0x07
    2bc2:	90 93 88 02 	sts	0x0288, r25
    2bc6:	80 93 87 02 	sts	0x0287, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2bca:	80 91 87 02 	lds	r24, 0x0287
    2bce:	90 91 88 02 	lds	r25, 0x0288
    2bd2:	fc 01       	movw	r30, r24
    2bd4:	20 81       	ld	r18, Z
    2bd6:	31 81       	ldd	r19, Z+1	; 0x01
    2bd8:	80 91 87 02 	lds	r24, 0x0287
    2bdc:	90 91 88 02 	lds	r25, 0x0288
    2be0:	fc 01       	movw	r30, r24
    2be2:	47 89       	ldd	r20, Z+23	; 0x17
    2be4:	80 91 87 02 	lds	r24, 0x0287
    2be8:	90 91 88 02 	lds	r25, 0x0288
    2bec:	64 2f       	mov	r22, r20
    2bee:	f9 01       	movw	r30, r18
    2bf0:	19 95       	eicall

	return;
    2bf2:	00 00       	nop
}
    2bf4:	0f 90       	pop	r0
    2bf6:	0f 90       	pop	r0
    2bf8:	df 91       	pop	r29
    2bfa:	cf 91       	pop	r28
    2bfc:	08 95       	ret

00002bfe <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    2bfe:	cf 93       	push	r28
    2c00:	df 93       	push	r29
    2c02:	1f 92       	push	r1
    2c04:	cd b7       	in	r28, 0x3d	; 61
    2c06:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2c08:	19 82       	std	Y+1, r1	; 0x01
    2c0a:	13 c0       	rjmp	.+38     	; 0x2c32 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    2c0c:	89 81       	ldd	r24, Y+1	; 0x01
    2c0e:	28 2f       	mov	r18, r24
    2c10:	30 e0       	ldi	r19, 0x00	; 0
    2c12:	c9 01       	movw	r24, r18
    2c14:	88 0f       	add	r24, r24
    2c16:	99 1f       	adc	r25, r25
    2c18:	88 0f       	add	r24, r24
    2c1a:	99 1f       	adc	r25, r25
    2c1c:	88 0f       	add	r24, r24
    2c1e:	99 1f       	adc	r25, r25
    2c20:	82 0f       	add	r24, r18
    2c22:	93 1f       	adc	r25, r19
    2c24:	87 57       	subi	r24, 0x77	; 119
    2c26:	9d 4f       	sbci	r25, 0xFD	; 253
    2c28:	0e 94 0a 12 	call	0x2414	; 0x2414 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2c2c:	89 81       	ldd	r24, Y+1	; 0x01
    2c2e:	8f 5f       	subi	r24, 0xFF	; 255
    2c30:	89 83       	std	Y+1, r24	; 0x01
    2c32:	89 81       	ldd	r24, Y+1	; 0x01
    2c34:	82 30       	cpi	r24, 0x02	; 2
    2c36:	50 f3       	brcs	.-44     	; 0x2c0c <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    2c38:	8b e9       	ldi	r24, 0x9B	; 155
    2c3a:	92 e0       	ldi	r25, 0x02	; 2
    2c3c:	0e 94 0a 12 	call	0x2414	; 0x2414 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    2c40:	84 ea       	ldi	r24, 0xA4	; 164
    2c42:	92 e0       	ldi	r25, 0x02	; 2
    2c44:	0e 94 0a 12 	call	0x2414	; 0x2414 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    2c48:	81 eb       	ldi	r24, 0xB1	; 177
    2c4a:	92 e0       	ldi	r25, 0x02	; 2
    2c4c:	0e 94 0a 12 	call	0x2414	; 0x2414 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    2c50:	8b e9       	ldi	r24, 0x9B	; 155
    2c52:	92 e0       	ldi	r25, 0x02	; 2
    2c54:	90 93 ae 02 	sts	0x02AE, r25
    2c58:	80 93 ad 02 	sts	0x02AD, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    2c5c:	84 ea       	ldi	r24, 0xA4	; 164
    2c5e:	92 e0       	ldi	r25, 0x02	; 2
    2c60:	90 93 b0 02 	sts	0x02B0, r25
    2c64:	80 93 af 02 	sts	0x02AF, r24
}
    2c68:	0f 90       	pop	r0
    2c6a:	df 91       	pop	r29
    2c6c:	cf 91       	pop	r28
    2c6e:	08 95       	ret

00002c70 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    2c70:	cf 93       	push	r28
    2c72:	df 93       	push	r29
    2c74:	00 d0       	rcall	.+0      	; 0x2c76 <xCoRoutineRemoveFromEventList+0x6>
    2c76:	1f 92       	push	r1
    2c78:	1f 92       	push	r1
    2c7a:	cd b7       	in	r28, 0x3d	; 61
    2c7c:	de b7       	in	r29, 0x3e	; 62
    2c7e:	9d 83       	std	Y+5, r25	; 0x05
    2c80:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2c82:	8c 81       	ldd	r24, Y+4	; 0x04
    2c84:	9d 81       	ldd	r25, Y+5	; 0x05
    2c86:	fc 01       	movw	r30, r24
    2c88:	85 81       	ldd	r24, Z+5	; 0x05
    2c8a:	96 81       	ldd	r25, Z+6	; 0x06
    2c8c:	fc 01       	movw	r30, r24
    2c8e:	86 81       	ldd	r24, Z+6	; 0x06
    2c90:	97 81       	ldd	r25, Z+7	; 0x07
    2c92:	9b 83       	std	Y+3, r25	; 0x03
    2c94:	8a 83       	std	Y+2, r24	; 0x02
	uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2c96:	8a 81       	ldd	r24, Y+2	; 0x02
    2c98:	9b 81       	ldd	r25, Y+3	; 0x03
    2c9a:	0c 96       	adiw	r24, 0x0c	; 12
    2c9c:	0e 94 22 13 	call	0x2644	; 0x2644 <uxListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    2ca0:	8a 81       	ldd	r24, Y+2	; 0x02
    2ca2:	9b 81       	ldd	r25, Y+3	; 0x03
    2ca4:	0c 96       	adiw	r24, 0x0c	; 12
    2ca6:	bc 01       	movw	r22, r24
    2ca8:	81 eb       	ldi	r24, 0xB1	; 177
    2caa:	92 e0       	ldi	r25, 0x02	; 2
    2cac:	0e 94 52 12 	call	0x24a4	; 0x24a4 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    2cb0:	8a 81       	ldd	r24, Y+2	; 0x02
    2cb2:	9b 81       	ldd	r25, Y+3	; 0x03
    2cb4:	fc 01       	movw	r30, r24
    2cb6:	26 89       	ldd	r18, Z+22	; 0x16
    2cb8:	80 91 87 02 	lds	r24, 0x0287
    2cbc:	90 91 88 02 	lds	r25, 0x0288
    2cc0:	fc 01       	movw	r30, r24
    2cc2:	86 89       	ldd	r24, Z+22	; 0x16
    2cc4:	28 17       	cp	r18, r24
    2cc6:	18 f0       	brcs	.+6      	; 0x2cce <xCoRoutineRemoveFromEventList+0x5e>
	{
		xReturn = pdTRUE;
    2cc8:	81 e0       	ldi	r24, 0x01	; 1
    2cca:	89 83       	std	Y+1, r24	; 0x01
    2ccc:	01 c0       	rjmp	.+2      	; 0x2cd0 <xCoRoutineRemoveFromEventList+0x60>
	}
	else
	{
		xReturn = pdFALSE;
    2cce:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2cd0:	89 81       	ldd	r24, Y+1	; 0x01
}
    2cd2:	0f 90       	pop	r0
    2cd4:	0f 90       	pop	r0
    2cd6:	0f 90       	pop	r0
    2cd8:	0f 90       	pop	r0
    2cda:	0f 90       	pop	r0
    2cdc:	df 91       	pop	r29
    2cde:	cf 91       	pop	r28
    2ce0:	08 95       	ret

00002ce2 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2ce2:	cf 93       	push	r28
    2ce4:	df 93       	push	r29
    2ce6:	00 d0       	rcall	.+0      	; 0x2ce8 <pvPortMalloc+0x6>
    2ce8:	1f 92       	push	r1
    2cea:	cd b7       	in	r28, 0x3d	; 61
    2cec:	de b7       	in	r29, 0x3e	; 62
    2cee:	9c 83       	std	Y+4, r25	; 0x04
    2cf0:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    2cf2:	1a 82       	std	Y+2, r1	; 0x02
    2cf4:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    2cf6:	0e 94 43 06 	call	0xc86	; 0xc86 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    2cfa:	20 91 c1 1a 	lds	r18, 0x1AC1
    2cfe:	30 91 c2 1a 	lds	r19, 0x1AC2
    2d02:	8b 81       	ldd	r24, Y+3	; 0x03
    2d04:	9c 81       	ldd	r25, Y+4	; 0x04
    2d06:	82 0f       	add	r24, r18
    2d08:	93 1f       	adc	r25, r19
    2d0a:	81 15       	cp	r24, r1
    2d0c:	28 e1       	ldi	r18, 0x18	; 24
    2d0e:	92 07       	cpc	r25, r18
    2d10:	18 f5       	brcc	.+70     	; 0x2d58 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
    2d12:	20 91 c1 1a 	lds	r18, 0x1AC1
    2d16:	30 91 c2 1a 	lds	r19, 0x1AC2
    2d1a:	8b 81       	ldd	r24, Y+3	; 0x03
    2d1c:	9c 81       	ldd	r25, Y+4	; 0x04
    2d1e:	28 0f       	add	r18, r24
    2d20:	39 1f       	adc	r19, r25
    2d22:	80 91 c1 1a 	lds	r24, 0x1AC1
    2d26:	90 91 c2 1a 	lds	r25, 0x1AC2
	#endif

	vTaskSuspendAll();
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    2d2a:	82 17       	cp	r24, r18
    2d2c:	93 07       	cpc	r25, r19
    2d2e:	a0 f4       	brcc	.+40     	; 0x2d58 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    2d30:	80 91 c1 1a 	lds	r24, 0x1AC1
    2d34:	90 91 c2 1a 	lds	r25, 0x1AC2
    2d38:	8f 53       	subi	r24, 0x3F	; 63
    2d3a:	9d 4f       	sbci	r25, 0xFD	; 253
    2d3c:	9a 83       	std	Y+2, r25	; 0x02
    2d3e:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    2d40:	20 91 c1 1a 	lds	r18, 0x1AC1
    2d44:	30 91 c2 1a 	lds	r19, 0x1AC2
    2d48:	8b 81       	ldd	r24, Y+3	; 0x03
    2d4a:	9c 81       	ldd	r25, Y+4	; 0x04
    2d4c:	82 0f       	add	r24, r18
    2d4e:	93 1f       	adc	r25, r19
    2d50:	90 93 c2 1a 	sts	0x1AC2, r25
    2d54:	80 93 c1 1a 	sts	0x1AC1, r24
		}
	}
	xTaskResumeAll();
    2d58:	0e 94 4f 06 	call	0xc9e	; 0xc9e <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    2d5c:	89 81       	ldd	r24, Y+1	; 0x01
    2d5e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2d60:	0f 90       	pop	r0
    2d62:	0f 90       	pop	r0
    2d64:	0f 90       	pop	r0
    2d66:	0f 90       	pop	r0
    2d68:	df 91       	pop	r29
    2d6a:	cf 91       	pop	r28
    2d6c:	08 95       	ret

00002d6e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2d6e:	cf 93       	push	r28
    2d70:	df 93       	push	r29
    2d72:	1f 92       	push	r1
    2d74:	1f 92       	push	r1
    2d76:	cd b7       	in	r28, 0x3d	; 61
    2d78:	de b7       	in	r29, 0x3e	; 62
    2d7a:	9a 83       	std	Y+2, r25	; 0x02
    2d7c:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    2d7e:	0f 90       	pop	r0
    2d80:	0f 90       	pop	r0
    2d82:	df 91       	pop	r29
    2d84:	cf 91       	pop	r28
    2d86:	08 95       	ret

00002d88 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    2d88:	cf 93       	push	r28
    2d8a:	df 93       	push	r29
    2d8c:	cd b7       	in	r28, 0x3d	; 61
    2d8e:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    2d90:	10 92 c2 1a 	sts	0x1AC2, r1
    2d94:	10 92 c1 1a 	sts	0x1AC1, r1
}
    2d98:	df 91       	pop	r29
    2d9a:	cf 91       	pop	r28
    2d9c:	08 95       	ret

00002d9e <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    2d9e:	cf 93       	push	r28
    2da0:	df 93       	push	r29
    2da2:	cd b7       	in	r28, 0x3d	; 61
    2da4:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    2da6:	80 91 c1 1a 	lds	r24, 0x1AC1
    2daa:	90 91 c2 1a 	lds	r25, 0x1AC2
    2dae:	20 e0       	ldi	r18, 0x00	; 0
    2db0:	38 e1       	ldi	r19, 0x18	; 24
    2db2:	a9 01       	movw	r20, r18
    2db4:	48 1b       	sub	r20, r24
    2db6:	59 0b       	sbc	r21, r25
    2db8:	ca 01       	movw	r24, r20
}
    2dba:	df 91       	pop	r29
    2dbc:	cf 91       	pop	r28
    2dbe:	08 95       	ret

00002dc0 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    2dc0:	cf 93       	push	r28
    2dc2:	df 93       	push	r29
    2dc4:	cd b7       	in	r28, 0x3d	; 61
    2dc6:	de b7       	in	r29, 0x3e	; 62
    2dc8:	28 97       	sbiw	r28, 0x08	; 8
    2dca:	0f b6       	in	r0, 0x3f	; 63
    2dcc:	f8 94       	cli
    2dce:	de bf       	out	0x3e, r29	; 62
    2dd0:	0f be       	out	0x3f, r0	; 63
    2dd2:	cd bf       	out	0x3d, r28	; 61
    2dd4:	9c 83       	std	Y+4, r25	; 0x04
    2dd6:	8b 83       	std	Y+3, r24	; 0x03
    2dd8:	7e 83       	std	Y+6, r23	; 0x06
    2dda:	6d 83       	std	Y+5, r22	; 0x05
    2ddc:	58 87       	std	Y+8, r21	; 0x08
    2dde:	4f 83       	std	Y+7, r20	; 0x07
#endif

	/* Place a few bytes of known values on the bottom of the stack.
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2de0:	8b 81       	ldd	r24, Y+3	; 0x03
    2de2:	9c 81       	ldd	r25, Y+4	; 0x04
    2de4:	21 e1       	ldi	r18, 0x11	; 17
    2de6:	fc 01       	movw	r30, r24
    2de8:	20 83       	st	Z, r18
	pxTopOfStack--;
    2dea:	8b 81       	ldd	r24, Y+3	; 0x03
    2dec:	9c 81       	ldd	r25, Y+4	; 0x04
    2dee:	01 97       	sbiw	r24, 0x01	; 1
    2df0:	9c 83       	std	Y+4, r25	; 0x04
    2df2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    2df4:	8b 81       	ldd	r24, Y+3	; 0x03
    2df6:	9c 81       	ldd	r25, Y+4	; 0x04
    2df8:	22 e2       	ldi	r18, 0x22	; 34
    2dfa:	fc 01       	movw	r30, r24
    2dfc:	20 83       	st	Z, r18
	pxTopOfStack--;
    2dfe:	8b 81       	ldd	r24, Y+3	; 0x03
    2e00:	9c 81       	ldd	r25, Y+4	; 0x04
    2e02:	01 97       	sbiw	r24, 0x01	; 1
    2e04:	9c 83       	std	Y+4, r25	; 0x04
    2e06:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    2e08:	8b 81       	ldd	r24, Y+3	; 0x03
    2e0a:	9c 81       	ldd	r25, Y+4	; 0x04
    2e0c:	23 e3       	ldi	r18, 0x33	; 51
    2e0e:	fc 01       	movw	r30, r24
    2e10:	20 83       	st	Z, r18
	pxTopOfStack--;
    2e12:	8b 81       	ldd	r24, Y+3	; 0x03
    2e14:	9c 81       	ldd	r25, Y+4	; 0x04
    2e16:	01 97       	sbiw	r24, 0x01	; 1
    2e18:	9c 83       	std	Y+4, r25	; 0x04
    2e1a:	8b 83       	std	Y+3, r24	; 0x03
	 * of flash. We do this by adding the .task label in the linker script.
	 *
	 * In order to do this properly, we would need to get a full 3-byte pointer to
	 * pxCode.  That requires a change to GCC.  Not likely to happen any time soon.
	 */
	usAddress = ( unsigned portSHORT ) pxCode;
    2e1c:	8d 81       	ldd	r24, Y+5	; 0x05
    2e1e:	9e 81       	ldd	r25, Y+6	; 0x06
    2e20:	9a 83       	std	Y+2, r25	; 0x02
    2e22:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    2e24:	29 81       	ldd	r18, Y+1	; 0x01
    2e26:	8b 81       	ldd	r24, Y+3	; 0x03
    2e28:	9c 81       	ldd	r25, Y+4	; 0x04
    2e2a:	fc 01       	movw	r30, r24
    2e2c:	20 83       	st	Z, r18
	pxTopOfStack--;
    2e2e:	8b 81       	ldd	r24, Y+3	; 0x03
    2e30:	9c 81       	ldd	r25, Y+4	; 0x04
    2e32:	01 97       	sbiw	r24, 0x01	; 1
    2e34:	9c 83       	std	Y+4, r25	; 0x04
    2e36:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2e38:	89 81       	ldd	r24, Y+1	; 0x01
    2e3a:	9a 81       	ldd	r25, Y+2	; 0x02
    2e3c:	89 2f       	mov	r24, r25
    2e3e:	99 27       	eor	r25, r25
    2e40:	9a 83       	std	Y+2, r25	; 0x02
    2e42:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    2e44:	29 81       	ldd	r18, Y+1	; 0x01
    2e46:	8b 81       	ldd	r24, Y+3	; 0x03
    2e48:	9c 81       	ldd	r25, Y+4	; 0x04
    2e4a:	fc 01       	movw	r30, r24
    2e4c:	20 83       	st	Z, r18
	pxTopOfStack--;
    2e4e:	8b 81       	ldd	r24, Y+3	; 0x03
    2e50:	9c 81       	ldd	r25, Y+4	; 0x04
    2e52:	01 97       	sbiw	r24, 0x01	; 1
    2e54:	9c 83       	std	Y+4, r25	; 0x04
    2e56:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = 0;
    2e58:	8b 81       	ldd	r24, Y+3	; 0x03
    2e5a:	9c 81       	ldd	r25, Y+4	; 0x04
    2e5c:	fc 01       	movw	r30, r24
    2e5e:	10 82       	st	Z, r1
	pxTopOfStack--;
    2e60:	8b 81       	ldd	r24, Y+3	; 0x03
    2e62:	9c 81       	ldd	r25, Y+4	; 0x04
    2e64:	01 97       	sbiw	r24, 0x01	; 1
    2e66:	9c 83       	std	Y+4, r25	; 0x04
    2e68:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    2e6a:	8b 81       	ldd	r24, Y+3	; 0x03
    2e6c:	9c 81       	ldd	r25, Y+4	; 0x04
    2e6e:	fc 01       	movw	r30, r24
    2e70:	10 82       	st	Z, r1
	pxTopOfStack--;
    2e72:	8b 81       	ldd	r24, Y+3	; 0x03
    2e74:	9c 81       	ldd	r25, Y+4	; 0x04
    2e76:	01 97       	sbiw	r24, 0x01	; 1
    2e78:	9c 83       	std	Y+4, r25	; 0x04
    2e7a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2e7c:	8b 81       	ldd	r24, Y+3	; 0x03
    2e7e:	9c 81       	ldd	r25, Y+4	; 0x04
    2e80:	20 e8       	ldi	r18, 0x80	; 128
    2e82:	fc 01       	movw	r30, r24
    2e84:	20 83       	st	Z, r18
	pxTopOfStack--;
    2e86:	8b 81       	ldd	r24, Y+3	; 0x03
    2e88:	9c 81       	ldd	r25, Y+4	; 0x04
    2e8a:	01 97       	sbiw	r24, 0x01	; 1
    2e8c:	9c 83       	std	Y+4, r25	; 0x04
    2e8e:	8b 83       	std	Y+3, r24	; 0x03
#if defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

	/* If we have an ATmega256x, we are also saving the RAMPZ and EIND registers.
	 * We should default those to 0.
	 */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* EIND */
    2e90:	8b 81       	ldd	r24, Y+3	; 0x03
    2e92:	9c 81       	ldd	r25, Y+4	; 0x04
    2e94:	fc 01       	movw	r30, r24
    2e96:	10 82       	st	Z, r1
	pxTopOfStack--;
    2e98:	8b 81       	ldd	r24, Y+3	; 0x03
    2e9a:	9c 81       	ldd	r25, Y+4	; 0x04
    2e9c:	01 97       	sbiw	r24, 0x01	; 1
    2e9e:	9c 83       	std	Y+4, r25	; 0x04
    2ea0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* RAMPZ */
    2ea2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ea4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ea6:	fc 01       	movw	r30, r24
    2ea8:	10 82       	st	Z, r1
	pxTopOfStack--;
    2eaa:	8b 81       	ldd	r24, Y+3	; 0x03
    2eac:	9c 81       	ldd	r25, Y+4	; 0x04
    2eae:	01 97       	sbiw	r24, 0x01	; 1
    2eb0:	9c 83       	std	Y+4, r25	; 0x04
    2eb2:	8b 83       	std	Y+3, r24	; 0x03

#endif

	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    2eb4:	8b 81       	ldd	r24, Y+3	; 0x03
    2eb6:	9c 81       	ldd	r25, Y+4	; 0x04
    2eb8:	fc 01       	movw	r30, r24
    2eba:	10 82       	st	Z, r1
	pxTopOfStack--;
    2ebc:	8b 81       	ldd	r24, Y+3	; 0x03
    2ebe:	9c 81       	ldd	r25, Y+4	; 0x04
    2ec0:	01 97       	sbiw	r24, 0x01	; 1
    2ec2:	9c 83       	std	Y+4, r25	; 0x04
    2ec4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    2ec6:	8b 81       	ldd	r24, Y+3	; 0x03
    2ec8:	9c 81       	ldd	r25, Y+4	; 0x04
    2eca:	22 e0       	ldi	r18, 0x02	; 2
    2ecc:	fc 01       	movw	r30, r24
    2ece:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ed0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ed2:	9c 81       	ldd	r25, Y+4	; 0x04
    2ed4:	01 97       	sbiw	r24, 0x01	; 1
    2ed6:	9c 83       	std	Y+4, r25	; 0x04
    2ed8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    2eda:	8b 81       	ldd	r24, Y+3	; 0x03
    2edc:	9c 81       	ldd	r25, Y+4	; 0x04
    2ede:	23 e0       	ldi	r18, 0x03	; 3
    2ee0:	fc 01       	movw	r30, r24
    2ee2:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ee4:	8b 81       	ldd	r24, Y+3	; 0x03
    2ee6:	9c 81       	ldd	r25, Y+4	; 0x04
    2ee8:	01 97       	sbiw	r24, 0x01	; 1
    2eea:	9c 83       	std	Y+4, r25	; 0x04
    2eec:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    2eee:	8b 81       	ldd	r24, Y+3	; 0x03
    2ef0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ef2:	24 e0       	ldi	r18, 0x04	; 4
    2ef4:	fc 01       	movw	r30, r24
    2ef6:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ef8:	8b 81       	ldd	r24, Y+3	; 0x03
    2efa:	9c 81       	ldd	r25, Y+4	; 0x04
    2efc:	01 97       	sbiw	r24, 0x01	; 1
    2efe:	9c 83       	std	Y+4, r25	; 0x04
    2f00:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    2f02:	8b 81       	ldd	r24, Y+3	; 0x03
    2f04:	9c 81       	ldd	r25, Y+4	; 0x04
    2f06:	25 e0       	ldi	r18, 0x05	; 5
    2f08:	fc 01       	movw	r30, r24
    2f0a:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f0c:	8b 81       	ldd	r24, Y+3	; 0x03
    2f0e:	9c 81       	ldd	r25, Y+4	; 0x04
    2f10:	01 97       	sbiw	r24, 0x01	; 1
    2f12:	9c 83       	std	Y+4, r25	; 0x04
    2f14:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    2f16:	8b 81       	ldd	r24, Y+3	; 0x03
    2f18:	9c 81       	ldd	r25, Y+4	; 0x04
    2f1a:	26 e0       	ldi	r18, 0x06	; 6
    2f1c:	fc 01       	movw	r30, r24
    2f1e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f20:	8b 81       	ldd	r24, Y+3	; 0x03
    2f22:	9c 81       	ldd	r25, Y+4	; 0x04
    2f24:	01 97       	sbiw	r24, 0x01	; 1
    2f26:	9c 83       	std	Y+4, r25	; 0x04
    2f28:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    2f2a:	8b 81       	ldd	r24, Y+3	; 0x03
    2f2c:	9c 81       	ldd	r25, Y+4	; 0x04
    2f2e:	27 e0       	ldi	r18, 0x07	; 7
    2f30:	fc 01       	movw	r30, r24
    2f32:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f34:	8b 81       	ldd	r24, Y+3	; 0x03
    2f36:	9c 81       	ldd	r25, Y+4	; 0x04
    2f38:	01 97       	sbiw	r24, 0x01	; 1
    2f3a:	9c 83       	std	Y+4, r25	; 0x04
    2f3c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    2f3e:	8b 81       	ldd	r24, Y+3	; 0x03
    2f40:	9c 81       	ldd	r25, Y+4	; 0x04
    2f42:	28 e0       	ldi	r18, 0x08	; 8
    2f44:	fc 01       	movw	r30, r24
    2f46:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f48:	8b 81       	ldd	r24, Y+3	; 0x03
    2f4a:	9c 81       	ldd	r25, Y+4	; 0x04
    2f4c:	01 97       	sbiw	r24, 0x01	; 1
    2f4e:	9c 83       	std	Y+4, r25	; 0x04
    2f50:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    2f52:	8b 81       	ldd	r24, Y+3	; 0x03
    2f54:	9c 81       	ldd	r25, Y+4	; 0x04
    2f56:	29 e0       	ldi	r18, 0x09	; 9
    2f58:	fc 01       	movw	r30, r24
    2f5a:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f5c:	8b 81       	ldd	r24, Y+3	; 0x03
    2f5e:	9c 81       	ldd	r25, Y+4	; 0x04
    2f60:	01 97       	sbiw	r24, 0x01	; 1
    2f62:	9c 83       	std	Y+4, r25	; 0x04
    2f64:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    2f66:	8b 81       	ldd	r24, Y+3	; 0x03
    2f68:	9c 81       	ldd	r25, Y+4	; 0x04
    2f6a:	20 e1       	ldi	r18, 0x10	; 16
    2f6c:	fc 01       	movw	r30, r24
    2f6e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f70:	8b 81       	ldd	r24, Y+3	; 0x03
    2f72:	9c 81       	ldd	r25, Y+4	; 0x04
    2f74:	01 97       	sbiw	r24, 0x01	; 1
    2f76:	9c 83       	std	Y+4, r25	; 0x04
    2f78:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    2f7a:	8b 81       	ldd	r24, Y+3	; 0x03
    2f7c:	9c 81       	ldd	r25, Y+4	; 0x04
    2f7e:	21 e1       	ldi	r18, 0x11	; 17
    2f80:	fc 01       	movw	r30, r24
    2f82:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f84:	8b 81       	ldd	r24, Y+3	; 0x03
    2f86:	9c 81       	ldd	r25, Y+4	; 0x04
    2f88:	01 97       	sbiw	r24, 0x01	; 1
    2f8a:	9c 83       	std	Y+4, r25	; 0x04
    2f8c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    2f8e:	8b 81       	ldd	r24, Y+3	; 0x03
    2f90:	9c 81       	ldd	r25, Y+4	; 0x04
    2f92:	22 e1       	ldi	r18, 0x12	; 18
    2f94:	fc 01       	movw	r30, r24
    2f96:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f98:	8b 81       	ldd	r24, Y+3	; 0x03
    2f9a:	9c 81       	ldd	r25, Y+4	; 0x04
    2f9c:	01 97       	sbiw	r24, 0x01	; 1
    2f9e:	9c 83       	std	Y+4, r25	; 0x04
    2fa0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    2fa2:	8b 81       	ldd	r24, Y+3	; 0x03
    2fa4:	9c 81       	ldd	r25, Y+4	; 0x04
    2fa6:	23 e1       	ldi	r18, 0x13	; 19
    2fa8:	fc 01       	movw	r30, r24
    2faa:	20 83       	st	Z, r18
	pxTopOfStack--;
    2fac:	8b 81       	ldd	r24, Y+3	; 0x03
    2fae:	9c 81       	ldd	r25, Y+4	; 0x04
    2fb0:	01 97       	sbiw	r24, 0x01	; 1
    2fb2:	9c 83       	std	Y+4, r25	; 0x04
    2fb4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    2fb6:	8b 81       	ldd	r24, Y+3	; 0x03
    2fb8:	9c 81       	ldd	r25, Y+4	; 0x04
    2fba:	24 e1       	ldi	r18, 0x14	; 20
    2fbc:	fc 01       	movw	r30, r24
    2fbe:	20 83       	st	Z, r18
	pxTopOfStack--;
    2fc0:	8b 81       	ldd	r24, Y+3	; 0x03
    2fc2:	9c 81       	ldd	r25, Y+4	; 0x04
    2fc4:	01 97       	sbiw	r24, 0x01	; 1
    2fc6:	9c 83       	std	Y+4, r25	; 0x04
    2fc8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    2fca:	8b 81       	ldd	r24, Y+3	; 0x03
    2fcc:	9c 81       	ldd	r25, Y+4	; 0x04
    2fce:	25 e1       	ldi	r18, 0x15	; 21
    2fd0:	fc 01       	movw	r30, r24
    2fd2:	20 83       	st	Z, r18
	pxTopOfStack--;
    2fd4:	8b 81       	ldd	r24, Y+3	; 0x03
    2fd6:	9c 81       	ldd	r25, Y+4	; 0x04
    2fd8:	01 97       	sbiw	r24, 0x01	; 1
    2fda:	9c 83       	std	Y+4, r25	; 0x04
    2fdc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    2fde:	8b 81       	ldd	r24, Y+3	; 0x03
    2fe0:	9c 81       	ldd	r25, Y+4	; 0x04
    2fe2:	26 e1       	ldi	r18, 0x16	; 22
    2fe4:	fc 01       	movw	r30, r24
    2fe6:	20 83       	st	Z, r18
	pxTopOfStack--;
    2fe8:	8b 81       	ldd	r24, Y+3	; 0x03
    2fea:	9c 81       	ldd	r25, Y+4	; 0x04
    2fec:	01 97       	sbiw	r24, 0x01	; 1
    2fee:	9c 83       	std	Y+4, r25	; 0x04
    2ff0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    2ff2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ff4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ff6:	27 e1       	ldi	r18, 0x17	; 23
    2ff8:	fc 01       	movw	r30, r24
    2ffa:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ffc:	8b 81       	ldd	r24, Y+3	; 0x03
    2ffe:	9c 81       	ldd	r25, Y+4	; 0x04
    3000:	01 97       	sbiw	r24, 0x01	; 1
    3002:	9c 83       	std	Y+4, r25	; 0x04
    3004:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    3006:	8b 81       	ldd	r24, Y+3	; 0x03
    3008:	9c 81       	ldd	r25, Y+4	; 0x04
    300a:	28 e1       	ldi	r18, 0x18	; 24
    300c:	fc 01       	movw	r30, r24
    300e:	20 83       	st	Z, r18
	pxTopOfStack--;
    3010:	8b 81       	ldd	r24, Y+3	; 0x03
    3012:	9c 81       	ldd	r25, Y+4	; 0x04
    3014:	01 97       	sbiw	r24, 0x01	; 1
    3016:	9c 83       	std	Y+4, r25	; 0x04
    3018:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    301a:	8b 81       	ldd	r24, Y+3	; 0x03
    301c:	9c 81       	ldd	r25, Y+4	; 0x04
    301e:	29 e1       	ldi	r18, 0x19	; 25
    3020:	fc 01       	movw	r30, r24
    3022:	20 83       	st	Z, r18
	pxTopOfStack--;
    3024:	8b 81       	ldd	r24, Y+3	; 0x03
    3026:	9c 81       	ldd	r25, Y+4	; 0x04
    3028:	01 97       	sbiw	r24, 0x01	; 1
    302a:	9c 83       	std	Y+4, r25	; 0x04
    302c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    302e:	8b 81       	ldd	r24, Y+3	; 0x03
    3030:	9c 81       	ldd	r25, Y+4	; 0x04
    3032:	20 e2       	ldi	r18, 0x20	; 32
    3034:	fc 01       	movw	r30, r24
    3036:	20 83       	st	Z, r18
	pxTopOfStack--;
    3038:	8b 81       	ldd	r24, Y+3	; 0x03
    303a:	9c 81       	ldd	r25, Y+4	; 0x04
    303c:	01 97       	sbiw	r24, 0x01	; 1
    303e:	9c 83       	std	Y+4, r25	; 0x04
    3040:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    3042:	8b 81       	ldd	r24, Y+3	; 0x03
    3044:	9c 81       	ldd	r25, Y+4	; 0x04
    3046:	21 e2       	ldi	r18, 0x21	; 33
    3048:	fc 01       	movw	r30, r24
    304a:	20 83       	st	Z, r18
	pxTopOfStack--;
    304c:	8b 81       	ldd	r24, Y+3	; 0x03
    304e:	9c 81       	ldd	r25, Y+4	; 0x04
    3050:	01 97       	sbiw	r24, 0x01	; 1
    3052:	9c 83       	std	Y+4, r25	; 0x04
    3054:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    3056:	8b 81       	ldd	r24, Y+3	; 0x03
    3058:	9c 81       	ldd	r25, Y+4	; 0x04
    305a:	22 e2       	ldi	r18, 0x22	; 34
    305c:	fc 01       	movw	r30, r24
    305e:	20 83       	st	Z, r18
	pxTopOfStack--;
    3060:	8b 81       	ldd	r24, Y+3	; 0x03
    3062:	9c 81       	ldd	r25, Y+4	; 0x04
    3064:	01 97       	sbiw	r24, 0x01	; 1
    3066:	9c 83       	std	Y+4, r25	; 0x04
    3068:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    306a:	8b 81       	ldd	r24, Y+3	; 0x03
    306c:	9c 81       	ldd	r25, Y+4	; 0x04
    306e:	23 e2       	ldi	r18, 0x23	; 35
    3070:	fc 01       	movw	r30, r24
    3072:	20 83       	st	Z, r18
	pxTopOfStack--;
    3074:	8b 81       	ldd	r24, Y+3	; 0x03
    3076:	9c 81       	ldd	r25, Y+4	; 0x04
    3078:	01 97       	sbiw	r24, 0x01	; 1
    307a:	9c 83       	std	Y+4, r25	; 0x04
    307c:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    307e:	8f 81       	ldd	r24, Y+7	; 0x07
    3080:	98 85       	ldd	r25, Y+8	; 0x08
    3082:	9a 83       	std	Y+2, r25	; 0x02
    3084:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    3086:	29 81       	ldd	r18, Y+1	; 0x01
    3088:	8b 81       	ldd	r24, Y+3	; 0x03
    308a:	9c 81       	ldd	r25, Y+4	; 0x04
    308c:	fc 01       	movw	r30, r24
    308e:	20 83       	st	Z, r18
	pxTopOfStack--;
    3090:	8b 81       	ldd	r24, Y+3	; 0x03
    3092:	9c 81       	ldd	r25, Y+4	; 0x04
    3094:	01 97       	sbiw	r24, 0x01	; 1
    3096:	9c 83       	std	Y+4, r25	; 0x04
    3098:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    309a:	89 81       	ldd	r24, Y+1	; 0x01
    309c:	9a 81       	ldd	r25, Y+2	; 0x02
    309e:	89 2f       	mov	r24, r25
    30a0:	99 27       	eor	r25, r25
    30a2:	9a 83       	std	Y+2, r25	; 0x02
    30a4:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    30a6:	29 81       	ldd	r18, Y+1	; 0x01
    30a8:	8b 81       	ldd	r24, Y+3	; 0x03
    30aa:	9c 81       	ldd	r25, Y+4	; 0x04
    30ac:	fc 01       	movw	r30, r24
    30ae:	20 83       	st	Z, r18
	pxTopOfStack--;
    30b0:	8b 81       	ldd	r24, Y+3	; 0x03
    30b2:	9c 81       	ldd	r25, Y+4	; 0x04
    30b4:	01 97       	sbiw	r24, 0x01	; 1
    30b6:	9c 83       	std	Y+4, r25	; 0x04
    30b8:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    30ba:	8b 81       	ldd	r24, Y+3	; 0x03
    30bc:	9c 81       	ldd	r25, Y+4	; 0x04
    30be:	26 e2       	ldi	r18, 0x26	; 38
    30c0:	fc 01       	movw	r30, r24
    30c2:	20 83       	st	Z, r18
	pxTopOfStack--;
    30c4:	8b 81       	ldd	r24, Y+3	; 0x03
    30c6:	9c 81       	ldd	r25, Y+4	; 0x04
    30c8:	01 97       	sbiw	r24, 0x01	; 1
    30ca:	9c 83       	std	Y+4, r25	; 0x04
    30cc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    30ce:	8b 81       	ldd	r24, Y+3	; 0x03
    30d0:	9c 81       	ldd	r25, Y+4	; 0x04
    30d2:	27 e2       	ldi	r18, 0x27	; 39
    30d4:	fc 01       	movw	r30, r24
    30d6:	20 83       	st	Z, r18
	pxTopOfStack--;
    30d8:	8b 81       	ldd	r24, Y+3	; 0x03
    30da:	9c 81       	ldd	r25, Y+4	; 0x04
    30dc:	01 97       	sbiw	r24, 0x01	; 1
    30de:	9c 83       	std	Y+4, r25	; 0x04
    30e0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    30e2:	8b 81       	ldd	r24, Y+3	; 0x03
    30e4:	9c 81       	ldd	r25, Y+4	; 0x04
    30e6:	28 e2       	ldi	r18, 0x28	; 40
    30e8:	fc 01       	movw	r30, r24
    30ea:	20 83       	st	Z, r18
	pxTopOfStack--;
    30ec:	8b 81       	ldd	r24, Y+3	; 0x03
    30ee:	9c 81       	ldd	r25, Y+4	; 0x04
    30f0:	01 97       	sbiw	r24, 0x01	; 1
    30f2:	9c 83       	std	Y+4, r25	; 0x04
    30f4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    30f6:	8b 81       	ldd	r24, Y+3	; 0x03
    30f8:	9c 81       	ldd	r25, Y+4	; 0x04
    30fa:	29 e2       	ldi	r18, 0x29	; 41
    30fc:	fc 01       	movw	r30, r24
    30fe:	20 83       	st	Z, r18
	pxTopOfStack--;
    3100:	8b 81       	ldd	r24, Y+3	; 0x03
    3102:	9c 81       	ldd	r25, Y+4	; 0x04
    3104:	01 97       	sbiw	r24, 0x01	; 1
    3106:	9c 83       	std	Y+4, r25	; 0x04
    3108:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    310a:	8b 81       	ldd	r24, Y+3	; 0x03
    310c:	9c 81       	ldd	r25, Y+4	; 0x04
    310e:	20 e3       	ldi	r18, 0x30	; 48
    3110:	fc 01       	movw	r30, r24
    3112:	20 83       	st	Z, r18
	pxTopOfStack--;
    3114:	8b 81       	ldd	r24, Y+3	; 0x03
    3116:	9c 81       	ldd	r25, Y+4	; 0x04
    3118:	01 97       	sbiw	r24, 0x01	; 1
    311a:	9c 83       	std	Y+4, r25	; 0x04
    311c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    311e:	8b 81       	ldd	r24, Y+3	; 0x03
    3120:	9c 81       	ldd	r25, Y+4	; 0x04
    3122:	21 e3       	ldi	r18, 0x31	; 49
    3124:	fc 01       	movw	r30, r24
    3126:	20 83       	st	Z, r18
	pxTopOfStack--;
    3128:	8b 81       	ldd	r24, Y+3	; 0x03
    312a:	9c 81       	ldd	r25, Y+4	; 0x04
    312c:	01 97       	sbiw	r24, 0x01	; 1
    312e:	9c 83       	std	Y+4, r25	; 0x04
    3130:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    3132:	8b 81       	ldd	r24, Y+3	; 0x03
    3134:	9c 81       	ldd	r25, Y+4	; 0x04
}
    3136:	28 96       	adiw	r28, 0x08	; 8
    3138:	0f b6       	in	r0, 0x3f	; 63
    313a:	f8 94       	cli
    313c:	de bf       	out	0x3e, r29	; 62
    313e:	0f be       	out	0x3f, r0	; 63
    3140:	cd bf       	out	0x3d, r28	; 61
    3142:	df 91       	pop	r29
    3144:	cf 91       	pop	r28
    3146:	08 95       	ret

00003148 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    3148:	cf 93       	push	r28
    314a:	df 93       	push	r29
    314c:	cd b7       	in	r28, 0x3d	; 61
    314e:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    3150:	0e 94 a8 19 	call	0x3350	; 0x3350 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    3154:	a0 91 2e 02 	lds	r26, 0x022E
    3158:	b0 91 2f 02 	lds	r27, 0x022F
    315c:	cd 91       	ld	r28, X+
    315e:	cd bf       	out	0x3d, r28	; 61
    3160:	dd 91       	ld	r29, X+
    3162:	de bf       	out	0x3e, r29	; 62
    3164:	ff 91       	pop	r31
    3166:	ef 91       	pop	r30
    3168:	df 91       	pop	r29
    316a:	cf 91       	pop	r28
    316c:	bf 91       	pop	r27
    316e:	af 91       	pop	r26
    3170:	9f 91       	pop	r25
    3172:	8f 91       	pop	r24
    3174:	7f 91       	pop	r23
    3176:	6f 91       	pop	r22
    3178:	5f 91       	pop	r21
    317a:	4f 91       	pop	r20
    317c:	3f 91       	pop	r19
    317e:	2f 91       	pop	r18
    3180:	1f 91       	pop	r17
    3182:	0f 91       	pop	r16
    3184:	ff 90       	pop	r15
    3186:	ef 90       	pop	r14
    3188:	df 90       	pop	r13
    318a:	cf 90       	pop	r12
    318c:	bf 90       	pop	r11
    318e:	af 90       	pop	r10
    3190:	9f 90       	pop	r9
    3192:	8f 90       	pop	r8
    3194:	7f 90       	pop	r7
    3196:	6f 90       	pop	r6
    3198:	5f 90       	pop	r5
    319a:	4f 90       	pop	r4
    319c:	3f 90       	pop	r3
    319e:	2f 90       	pop	r2
    31a0:	1f 90       	pop	r1
    31a2:	0f 90       	pop	r0
    31a4:	0c be       	out	0x3c, r0	; 60
    31a6:	0f 90       	pop	r0
    31a8:	0b be       	out	0x3b, r0	; 59
    31aa:	0f 90       	pop	r0
    31ac:	0f be       	out	0x3f, r0	; 63
    31ae:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    31b0:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    31b2:	81 e0       	ldi	r24, 0x01	; 1
}
    31b4:	df 91       	pop	r29
    31b6:	cf 91       	pop	r28
    31b8:	08 95       	ret

000031ba <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    31ba:	cf 93       	push	r28
    31bc:	df 93       	push	r29
    31be:	cd b7       	in	r28, 0x3d	; 61
    31c0:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    31c2:	df 91       	pop	r29
    31c4:	cf 91       	pop	r28
    31c6:	08 95       	ret

000031c8 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    31c8:	0f 92       	push	r0
    31ca:	0f b6       	in	r0, 0x3f	; 63
    31cc:	f8 94       	cli
    31ce:	0f 92       	push	r0
    31d0:	0b b6       	in	r0, 0x3b	; 59
    31d2:	0f 92       	push	r0
    31d4:	0c b6       	in	r0, 0x3c	; 60
    31d6:	0f 92       	push	r0
    31d8:	1f 92       	push	r1
    31da:	11 24       	eor	r1, r1
    31dc:	2f 92       	push	r2
    31de:	3f 92       	push	r3
    31e0:	4f 92       	push	r4
    31e2:	5f 92       	push	r5
    31e4:	6f 92       	push	r6
    31e6:	7f 92       	push	r7
    31e8:	8f 92       	push	r8
    31ea:	9f 92       	push	r9
    31ec:	af 92       	push	r10
    31ee:	bf 92       	push	r11
    31f0:	cf 92       	push	r12
    31f2:	df 92       	push	r13
    31f4:	ef 92       	push	r14
    31f6:	ff 92       	push	r15
    31f8:	0f 93       	push	r16
    31fa:	1f 93       	push	r17
    31fc:	2f 93       	push	r18
    31fe:	3f 93       	push	r19
    3200:	4f 93       	push	r20
    3202:	5f 93       	push	r21
    3204:	6f 93       	push	r22
    3206:	7f 93       	push	r23
    3208:	8f 93       	push	r24
    320a:	9f 93       	push	r25
    320c:	af 93       	push	r26
    320e:	bf 93       	push	r27
    3210:	cf 93       	push	r28
    3212:	df 93       	push	r29
    3214:	ef 93       	push	r30
    3216:	ff 93       	push	r31
    3218:	a0 91 2e 02 	lds	r26, 0x022E
    321c:	b0 91 2f 02 	lds	r27, 0x022F
    3220:	0d b6       	in	r0, 0x3d	; 61
    3222:	0d 92       	st	X+, r0
    3224:	0e b6       	in	r0, 0x3e	; 62
    3226:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    3228:	0e 94 e5 07 	call	0xfca	; 0xfca <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    322c:	a0 91 2e 02 	lds	r26, 0x022E
    3230:	b0 91 2f 02 	lds	r27, 0x022F
    3234:	cd 91       	ld	r28, X+
    3236:	cd bf       	out	0x3d, r28	; 61
    3238:	dd 91       	ld	r29, X+
    323a:	de bf       	out	0x3e, r29	; 62
    323c:	ff 91       	pop	r31
    323e:	ef 91       	pop	r30
    3240:	df 91       	pop	r29
    3242:	cf 91       	pop	r28
    3244:	bf 91       	pop	r27
    3246:	af 91       	pop	r26
    3248:	9f 91       	pop	r25
    324a:	8f 91       	pop	r24
    324c:	7f 91       	pop	r23
    324e:	6f 91       	pop	r22
    3250:	5f 91       	pop	r21
    3252:	4f 91       	pop	r20
    3254:	3f 91       	pop	r19
    3256:	2f 91       	pop	r18
    3258:	1f 91       	pop	r17
    325a:	0f 91       	pop	r16
    325c:	ff 90       	pop	r15
    325e:	ef 90       	pop	r14
    3260:	df 90       	pop	r13
    3262:	cf 90       	pop	r12
    3264:	bf 90       	pop	r11
    3266:	af 90       	pop	r10
    3268:	9f 90       	pop	r9
    326a:	8f 90       	pop	r8
    326c:	7f 90       	pop	r7
    326e:	6f 90       	pop	r6
    3270:	5f 90       	pop	r5
    3272:	4f 90       	pop	r4
    3274:	3f 90       	pop	r3
    3276:	2f 90       	pop	r2
    3278:	1f 90       	pop	r1
    327a:	0f 90       	pop	r0
    327c:	0c be       	out	0x3c, r0	; 60
    327e:	0f 90       	pop	r0
    3280:	0b be       	out	0x3b, r0	; 59
    3282:	0f 90       	pop	r0
    3284:	0f be       	out	0x3f, r0	; 63
    3286:	0f 90       	pop	r0

	asm volatile ( "ret" );
    3288:	08 95       	ret

0000328a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    328a:	0f 92       	push	r0
    328c:	0f b6       	in	r0, 0x3f	; 63
    328e:	f8 94       	cli
    3290:	0f 92       	push	r0
    3292:	0b b6       	in	r0, 0x3b	; 59
    3294:	0f 92       	push	r0
    3296:	0c b6       	in	r0, 0x3c	; 60
    3298:	0f 92       	push	r0
    329a:	1f 92       	push	r1
    329c:	11 24       	eor	r1, r1
    329e:	2f 92       	push	r2
    32a0:	3f 92       	push	r3
    32a2:	4f 92       	push	r4
    32a4:	5f 92       	push	r5
    32a6:	6f 92       	push	r6
    32a8:	7f 92       	push	r7
    32aa:	8f 92       	push	r8
    32ac:	9f 92       	push	r9
    32ae:	af 92       	push	r10
    32b0:	bf 92       	push	r11
    32b2:	cf 92       	push	r12
    32b4:	df 92       	push	r13
    32b6:	ef 92       	push	r14
    32b8:	ff 92       	push	r15
    32ba:	0f 93       	push	r16
    32bc:	1f 93       	push	r17
    32be:	2f 93       	push	r18
    32c0:	3f 93       	push	r19
    32c2:	4f 93       	push	r20
    32c4:	5f 93       	push	r21
    32c6:	6f 93       	push	r22
    32c8:	7f 93       	push	r23
    32ca:	8f 93       	push	r24
    32cc:	9f 93       	push	r25
    32ce:	af 93       	push	r26
    32d0:	bf 93       	push	r27
    32d2:	cf 93       	push	r28
    32d4:	df 93       	push	r29
    32d6:	ef 93       	push	r30
    32d8:	ff 93       	push	r31
    32da:	a0 91 2e 02 	lds	r26, 0x022E
    32de:	b0 91 2f 02 	lds	r27, 0x022F
    32e2:	0d b6       	in	r0, 0x3d	; 61
    32e4:	0d 92       	st	X+, r0
    32e6:	0e b6       	in	r0, 0x3e	; 62
    32e8:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    32ea:	0e 94 08 07 	call	0xe10	; 0xe10 <vTaskIncrementTick>
	vTaskSwitchContext();
    32ee:	0e 94 e5 07 	call	0xfca	; 0xfca <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    32f2:	a0 91 2e 02 	lds	r26, 0x022E
    32f6:	b0 91 2f 02 	lds	r27, 0x022F
    32fa:	cd 91       	ld	r28, X+
    32fc:	cd bf       	out	0x3d, r28	; 61
    32fe:	dd 91       	ld	r29, X+
    3300:	de bf       	out	0x3e, r29	; 62
    3302:	ff 91       	pop	r31
    3304:	ef 91       	pop	r30
    3306:	df 91       	pop	r29
    3308:	cf 91       	pop	r28
    330a:	bf 91       	pop	r27
    330c:	af 91       	pop	r26
    330e:	9f 91       	pop	r25
    3310:	8f 91       	pop	r24
    3312:	7f 91       	pop	r23
    3314:	6f 91       	pop	r22
    3316:	5f 91       	pop	r21
    3318:	4f 91       	pop	r20
    331a:	3f 91       	pop	r19
    331c:	2f 91       	pop	r18
    331e:	1f 91       	pop	r17
    3320:	0f 91       	pop	r16
    3322:	ff 90       	pop	r15
    3324:	ef 90       	pop	r14
    3326:	df 90       	pop	r13
    3328:	cf 90       	pop	r12
    332a:	bf 90       	pop	r11
    332c:	af 90       	pop	r10
    332e:	9f 90       	pop	r9
    3330:	8f 90       	pop	r8
    3332:	7f 90       	pop	r7
    3334:	6f 90       	pop	r6
    3336:	5f 90       	pop	r5
    3338:	4f 90       	pop	r4
    333a:	3f 90       	pop	r3
    333c:	2f 90       	pop	r2
    333e:	1f 90       	pop	r1
    3340:	0f 90       	pop	r0
    3342:	0c be       	out	0x3c, r0	; 60
    3344:	0f 90       	pop	r0
    3346:	0b be       	out	0x3b, r0	; 59
    3348:	0f 90       	pop	r0
    334a:	0f be       	out	0x3f, r0	; 63
    334c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    334e:	08 95       	ret

00003350 <prvSetupTimerInterrupt>:

/*
 * Setup timer 0 or 3 or 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    3350:	cf 93       	push	r28
    3352:	df 93       	push	r29
    3354:	00 d0       	rcall	.+0      	; 0x3356 <prvSetupTimerInterrupt+0x6>
    3356:	00 d0       	rcall	.+0      	; 0x3358 <prvSetupTimerInterrupt+0x8>
    3358:	cd b7       	in	r28, 0x3d	; 61
    335a:	de b7       	in	r29, 0x3e	; 62

    /* Using 8bit Timer0 or 16bit Timer1 or Timer3 to generate the tick. */

    // ulCompareMatch 40,000 = 20,000,000 / 500; 20MHz
    // ulCompareMatch 110,592 = 22,118,400 / 200; 22.1184 MHz
    ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    335c:	80 e0       	ldi	r24, 0x00	; 0
    335e:	9d e7       	ldi	r25, 0x7D	; 125
    3360:	a0 e0       	ldi	r26, 0x00	; 0
    3362:	b0 e0       	ldi	r27, 0x00	; 0
    3364:	89 83       	std	Y+1, r24	; 0x01
    3366:	9a 83       	std	Y+2, r25	; 0x02
    3368:	ab 83       	std	Y+3, r26	; 0x03
    336a:	bc 83       	std	Y+4, r27	; 0x04

    /* We only have 8 or 16 bits so have to scale 64 or 256 to get our required tick rate. */
    //ulCompareMatch = 625 /= portCLOCK_PRESCALER; 20MHz with 64 prescale
    //ulCompareMatch = 108 /= portCLOCK_PRESCALER; 22.1184 MHz with 1024 prescale
    ulCompareMatch /= portCLOCK_PRESCALER;
    336c:	89 81       	ldd	r24, Y+1	; 0x01
    336e:	9a 81       	ldd	r25, Y+2	; 0x02
    3370:	ab 81       	ldd	r26, Y+3	; 0x03
    3372:	bc 81       	ldd	r27, Y+4	; 0x04
    3374:	68 94       	set
    3376:	15 f8       	bld	r1, 5
    3378:	b6 95       	lsr	r27
    337a:	a7 95       	ror	r26
    337c:	97 95       	ror	r25
    337e:	87 95       	ror	r24
    3380:	16 94       	lsr	r1
    3382:	d1 f7       	brne	.-12     	; 0x3378 <prvSetupTimerInterrupt+0x28>
    3384:	89 83       	std	Y+1, r24	; 0x01
    3386:	9a 83       	std	Y+2, r25	; 0x02
    3388:	ab 83       	std	Y+3, r26	; 0x03
    338a:	bc 83       	std	Y+4, r27	; 0x04

    /* Adjust for correct value. */
    ulCompareMatch -= ( unsigned portLONG ) 1;
    338c:	89 81       	ldd	r24, Y+1	; 0x01
    338e:	9a 81       	ldd	r25, Y+2	; 0x02
    3390:	ab 81       	ldd	r26, Y+3	; 0x03
    3392:	bc 81       	ldd	r27, Y+4	; 0x04
    3394:	01 97       	sbiw	r24, 0x01	; 1
    3396:	a1 09       	sbc	r26, r1
    3398:	b1 09       	sbc	r27, r1
    339a:	89 83       	std	Y+1, r24	; 0x01
    339c:	9a 83       	std	Y+2, r25	; 0x02
    339e:	ab 83       	std	Y+3, r26	; 0x03
    33a0:	bc 83       	std	Y+4, r27	; 0x04

    /* Setup compare match value for compare match A.  Interrupts are disabled
    before this is called so we need not worry here. */
    ucLowByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
    33a2:	89 81       	ldd	r24, Y+1	; 0x01
    33a4:	8d 83       	std	Y+5, r24	; 0x05
    //  OCR3AL = ucLowByte;

    // the HiByte is only needed, if a 16 Bit counter is being utilized
#ifdef portOCRH

    ulCompareMatch >>= 8;
    33a6:	89 81       	ldd	r24, Y+1	; 0x01
    33a8:	9a 81       	ldd	r25, Y+2	; 0x02
    33aa:	ab 81       	ldd	r26, Y+3	; 0x03
    33ac:	bc 81       	ldd	r27, Y+4	; 0x04
    33ae:	89 2f       	mov	r24, r25
    33b0:	9a 2f       	mov	r25, r26
    33b2:	ab 2f       	mov	r26, r27
    33b4:	bb 27       	eor	r27, r27
    33b6:	89 83       	std	Y+1, r24	; 0x01
    33b8:	9a 83       	std	Y+2, r25	; 0x02
    33ba:	ab 83       	std	Y+3, r26	; 0x03
    33bc:	bc 83       	std	Y+4, r27	; 0x04
    ucHighByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
    33be:	89 81       	ldd	r24, Y+1	; 0x01
    33c0:	8e 83       	std	Y+6, r24	; 0x06
    portOCRH = ucHighByte;
    33c2:	89 e9       	ldi	r24, 0x99	; 153
    33c4:	90 e0       	ldi	r25, 0x00	; 0
    33c6:	2e 81       	ldd	r18, Y+6	; 0x06
    33c8:	fc 01       	movw	r30, r24
    33ca:	20 83       	st	Z, r18

#endif

    portOCRL = ucLowByte;
    33cc:	88 e9       	ldi	r24, 0x98	; 152
    33ce:	90 e0       	ldi	r25, 0x00	; 0
    33d0:	2d 81       	ldd	r18, Y+5	; 0x05
    33d2:	fc 01       	movw	r30, r24
    33d4:	20 83       	st	Z, r18
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	portTCCRb = ucLowByte;

#elif defined( portUSE_TIMER3 )
	/* Setup clock source and compare match behaviour. Assuming  640 / 1280 /1281 / 1284p / 2560 / 2561 (with Timer3) */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    33d6:	8b e0       	ldi	r24, 0x0B	; 11
    33d8:	8d 83       	std	Y+5, r24	; 0x05
	portTCCRb = ucLowByte;
    33da:	81 e9       	ldi	r24, 0x91	; 145
    33dc:	90 e0       	ldi	r25, 0x00	; 0
    33de:	2d 81       	ldd	r18, Y+5	; 0x05
    33e0:	fc 01       	movw	r30, r24
    33e2:	20 83       	st	Z, r18
#endif

    /* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
    ucLowByte = portTIMSK;
    33e4:	81 e7       	ldi	r24, 0x71	; 113
    33e6:	90 e0       	ldi	r25, 0x00	; 0
    33e8:	fc 01       	movw	r30, r24
    33ea:	80 81       	ld	r24, Z
    33ec:	8d 83       	std	Y+5, r24	; 0x05
    ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    33ee:	8d 81       	ldd	r24, Y+5	; 0x05
    33f0:	82 60       	ori	r24, 0x02	; 2
    33f2:	8d 83       	std	Y+5, r24	; 0x05
    portTIMSK = ucLowByte;
    33f4:	81 e7       	ldi	r24, 0x71	; 113
    33f6:	90 e0       	ldi	r25, 0x00	; 0
    33f8:	2d 81       	ldd	r18, Y+5	; 0x05
    33fa:	fc 01       	movw	r30, r24
    33fc:	20 83       	st	Z, r18

}
    33fe:	26 96       	adiw	r28, 0x06	; 6
    3400:	0f b6       	in	r0, 0x3f	; 63
    3402:	f8 94       	cli
    3404:	de bf       	out	0x3e, r29	; 62
    3406:	0f be       	out	0x3f, r0	; 63
    3408:	cd bf       	out	0x3d, r28	; 61
    340a:	df 91       	pop	r29
    340c:	cf 91       	pop	r28
    340e:	08 95       	ret

00003410 <__vector_32>:

	#elif defined( portUSE_TIMER3 )
		#warning "Timer3 used for PRE-EMPTIVE scheduler."
		ISR(TIMER3_COMPA_vect, ISR_NAKED)
		{
			vPortYieldFromTick();
    3410:	0e 94 45 19 	call	0x328a	; 0x328a <vPortYieldFromTick>
			asm volatile ( "reti" );
    3414:	18 95       	reti

00003416 <USART_Init>:
*  the specified baud rate and clk speed.
*
* Param buadin: The desired Baud rate.
* Param clk_seedin: The clk speed of the ATmega328p
************************************/
void USART_Init(uint16_t baudin, uint32_t clk_speedin) {
    3416:	cf 93       	push	r28
    3418:	df 93       	push	r29
    341a:	00 d0       	rcall	.+0      	; 0x341c <USART_Init+0x6>
    341c:	00 d0       	rcall	.+0      	; 0x341e <USART_Init+0x8>
    341e:	cd b7       	in	r28, 0x3d	; 61
    3420:	de b7       	in	r29, 0x3e	; 62
    3422:	9a 83       	std	Y+2, r25	; 0x02
    3424:	89 83       	std	Y+1, r24	; 0x01
    3426:	4b 83       	std	Y+3, r20	; 0x03
    3428:	5c 83       	std	Y+4, r21	; 0x04
    342a:	6d 83       	std	Y+5, r22	; 0x05
    342c:	7e 83       	std	Y+6, r23	; 0x06
    USART_WriteQueue = xQueueCreate(64,sizeof(uint8_t));
    342e:	40 e0       	ldi	r20, 0x00	; 0
    3430:	61 e0       	ldi	r22, 0x01	; 1
    3432:	80 e4       	ldi	r24, 0x40	; 64
    3434:	0e 94 e7 0c 	call	0x19ce	; 0x19ce <xQueueGenericCreate>
    3438:	90 93 cb 1a 	sts	0x1ACB, r25
    343c:	80 93 ca 1a 	sts	0x1ACA, r24
    USART_ReadQueue = xQueueCreate(8,sizeof(uint8_t));
    3440:	40 e0       	ldi	r20, 0x00	; 0
    3442:	61 e0       	ldi	r22, 0x01	; 1
    3444:	88 e0       	ldi	r24, 0x08	; 8
    3446:	0e 94 e7 0c 	call	0x19ce	; 0x19ce <xQueueGenericCreate>
    344a:	90 93 c7 1a 	sts	0x1AC7, r25
    344e:	80 93 c6 1a 	sts	0x1AC6, r24

    //uint32_t ubrr = clk_speedin/(16UL)/baudin-1;
    //UBRR1H = (unsigned char)(ubrr>>8) ;// & 0x7F;
    //UBRR1L = (unsigned char)ubrr;
    
    UBRR2H = 0; //115200
    3452:	85 ed       	ldi	r24, 0xD5	; 213
    3454:	90 e0       	ldi	r25, 0x00	; 0
    3456:	fc 01       	movw	r30, r24
    3458:	10 82       	st	Z, r1
    UBRR2L = 8;
    345a:	84 ed       	ldi	r24, 0xD4	; 212
    345c:	90 e0       	ldi	r25, 0x00	; 0
    345e:	28 e0       	ldi	r18, 0x08	; 8
    3460:	fc 01       	movw	r30, r24
    3462:	20 83       	st	Z, r18

    /* Enable receiver and transmitter */
    UCSR2B = (1<<RXEN2)|(1<<TXEN2);//|(1<<RXCIE1);
    3464:	81 ed       	ldi	r24, 0xD1	; 209
    3466:	90 e0       	ldi	r25, 0x00	; 0
    3468:	28 e1       	ldi	r18, 0x18	; 24
    346a:	fc 01       	movw	r30, r24
    346c:	20 83       	st	Z, r18
    /* Set frame format: 8data, 1stop bit */
    UCSR2C = (1<<UCSZ21)|(1<<UCSZ20);
    346e:	82 ed       	ldi	r24, 0xD2	; 210
    3470:	90 e0       	ldi	r25, 0x00	; 0
    3472:	26 e0       	ldi	r18, 0x06	; 6
    3474:	fc 01       	movw	r30, r24
    3476:	20 83       	st	Z, r18
	 // clear U2X0 for Synchronous operation
    UCSR2A &= ~(1<<U2X2);
    3478:	80 ed       	ldi	r24, 0xD0	; 208
    347a:	90 e0       	ldi	r25, 0x00	; 0
    347c:	20 ed       	ldi	r18, 0xD0	; 208
    347e:	30 e0       	ldi	r19, 0x00	; 0
    3480:	f9 01       	movw	r30, r18
    3482:	20 81       	ld	r18, Z
    3484:	2d 7f       	andi	r18, 0xFD	; 253
    3486:	fc 01       	movw	r30, r24
    3488:	20 83       	st	Z, r18
    /* Set frame format: 8data, 1stop bit */
    //UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);
    // clear U2X0 for Synchronous operation
    //UCSR0A &= ~(1<<U2X0);*/

}
    348a:	26 96       	adiw	r28, 0x06	; 6
    348c:	0f b6       	in	r0, 0x3f	; 63
    348e:	f8 94       	cli
    3490:	de bf       	out	0x3e, r29	; 62
    3492:	0f be       	out	0x3f, r0	; 63
    3494:	cd bf       	out	0x3d, r28	; 61
    3496:	df 91       	pop	r29
    3498:	cf 91       	pop	r28
    349a:	08 95       	ret

0000349c <USART_Write>:

/*the send function will put 8bits on the trans line. */
void USART_Write(uint8_t data) {
    349c:	cf 93       	push	r28
    349e:	df 93       	push	r29
    34a0:	1f 92       	push	r1
    34a2:	cd b7       	in	r28, 0x3d	; 61
    34a4:	de b7       	in	r29, 0x3e	; 62
    34a6:	89 83       	std	Y+1, r24	; 0x01
		/* Wait for empty transmit buffer */
		while ( !( UCSR2A & (1<<UDRE2)) )
    34a8:	00 00       	nop
    34aa:	80 ed       	ldi	r24, 0xD0	; 208
    34ac:	90 e0       	ldi	r25, 0x00	; 0
    34ae:	fc 01       	movw	r30, r24
    34b0:	80 81       	ld	r24, Z
    34b2:	88 2f       	mov	r24, r24
    34b4:	90 e0       	ldi	r25, 0x00	; 0
    34b6:	80 72       	andi	r24, 0x20	; 32
    34b8:	99 27       	eor	r25, r25
    34ba:	00 97       	sbiw	r24, 0x00	; 0
    34bc:	b1 f3       	breq	.-20     	; 0x34aa <USART_Write+0xe>
		;
		/* Put data into buffer, sends the data */
		UDR2 = data;
    34be:	86 ed       	ldi	r24, 0xD6	; 214
    34c0:	90 e0       	ldi	r25, 0x00	; 0
    34c2:	29 81       	ldd	r18, Y+1	; 0x01
    34c4:	fc 01       	movw	r30, r24
    34c6:	20 83       	st	Z, r18
}
    34c8:	0f 90       	pop	r0
    34ca:	df 91       	pop	r29
    34cc:	cf 91       	pop	r28
    34ce:	08 95       	ret

000034d0 <USART_Write_Unprotected>:

/*the send function will put 8bits on the trans line. */
void USART_Write_Unprotected(uint8_t data) {
    34d0:	cf 93       	push	r28
    34d2:	df 93       	push	r29
    34d4:	1f 92       	push	r1
    34d6:	cd b7       	in	r28, 0x3d	; 61
    34d8:	de b7       	in	r29, 0x3e	; 62
    34da:	89 83       	std	Y+1, r24	; 0x01
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)) )
    34dc:	00 00       	nop
    34de:	80 ec       	ldi	r24, 0xC0	; 192
    34e0:	90 e0       	ldi	r25, 0x00	; 0
    34e2:	fc 01       	movw	r30, r24
    34e4:	80 81       	ld	r24, Z
    34e6:	88 2f       	mov	r24, r24
    34e8:	90 e0       	ldi	r25, 0x00	; 0
    34ea:	80 72       	andi	r24, 0x20	; 32
    34ec:	99 27       	eor	r25, r25
    34ee:	00 97       	sbiw	r24, 0x00	; 0
    34f0:	b1 f3       	breq	.-20     	; 0x34de <USART_Write_Unprotected+0xe>
	;
	/* Put data into buffer, sends the data */
	UDR0 = data;
    34f2:	86 ec       	ldi	r24, 0xC6	; 198
    34f4:	90 e0       	ldi	r25, 0x00	; 0
    34f6:	29 81       	ldd	r18, Y+1	; 0x01
    34f8:	fc 01       	movw	r30, r24
    34fa:	20 83       	st	Z, r18
}
    34fc:	0f 90       	pop	r0
    34fe:	df 91       	pop	r29
    3500:	cf 91       	pop	r28
    3502:	08 95       	ret

00003504 <USART_Read>:
Therefore you may not get control back after this is called 
until a much later time. It may be helpful to use the 
istheredata() function to check before calling this function
        @return 8bit data packet from sender
*/
uint8_t USART_Read(void) {
    3504:	cf 93       	push	r28
    3506:	df 93       	push	r29
    3508:	cd b7       	in	r28, 0x3d	; 61
    350a:	de b7       	in	r29, 0x3e	; 62
    /* Wait for data to be received */
    while ( !(UCSR2A & (1<<RXC2)) )
    350c:	00 00       	nop
    350e:	80 ed       	ldi	r24, 0xD0	; 208
    3510:	90 e0       	ldi	r25, 0x00	; 0
    3512:	fc 01       	movw	r30, r24
    3514:	80 81       	ld	r24, Z
    3516:	88 23       	and	r24, r24
    3518:	d4 f7       	brge	.-12     	; 0x350e <USART_Read+0xa>
        ;
    /* Get and return received data from buffer */
    return UDR2;
    351a:	86 ed       	ldi	r24, 0xD6	; 214
    351c:	90 e0       	ldi	r25, 0x00	; 0
    351e:	fc 01       	movw	r30, r24
    3520:	80 81       	ld	r24, Z
}
    3522:	df 91       	pop	r29
    3524:	cf 91       	pop	r28
    3526:	08 95       	ret

00003528 <__vector_36>:


ISR(USART1_RX_vect){
    3528:	1f 92       	push	r1
    352a:	0f 92       	push	r0
    352c:	00 90 5f 00 	lds	r0, 0x005F
    3530:	0f 92       	push	r0
    3532:	11 24       	eor	r1, r1
    3534:	00 90 5b 00 	lds	r0, 0x005B
    3538:	0f 92       	push	r0
    353a:	8f 93       	push	r24
    353c:	9f 93       	push	r25
    353e:	ef 93       	push	r30
    3540:	ff 93       	push	r31
    3542:	cf 93       	push	r28
    3544:	df 93       	push	r29
    3546:	1f 92       	push	r1
    3548:	cd b7       	in	r28, 0x3d	; 61
    354a:	de b7       	in	r29, 0x3e	; 62
    uint8_t data;
    data = UDR1;
    354c:	8e ec       	ldi	r24, 0xCE	; 206
    354e:	90 e0       	ldi	r25, 0x00	; 0
    3550:	fc 01       	movw	r30, r24
    3552:	80 81       	ld	r24, Z
    3554:	89 83       	std	Y+1, r24	; 0x01
    //UDR1 = data;
    

  //  USART_AddToQueue(data);
    //xQueueSendToBackFromISR(USART_ReadQueue,&data,NULL);
}
    3556:	0f 90       	pop	r0
    3558:	df 91       	pop	r29
    355a:	cf 91       	pop	r28
    355c:	ff 91       	pop	r31
    355e:	ef 91       	pop	r30
    3560:	9f 91       	pop	r25
    3562:	8f 91       	pop	r24
    3564:	0f 90       	pop	r0
    3566:	00 92 5b 00 	sts	0x005B, r0
    356a:	0f 90       	pop	r0
    356c:	00 92 5f 00 	sts	0x005F, r0
    3570:	0f 90       	pop	r0
    3572:	1f 90       	pop	r1
    3574:	18 95       	reti

00003576 <USART_AddToQueue>:

void USART_AddToQueue(uint8_t data){
    3576:	cf 93       	push	r28
    3578:	df 93       	push	r29
    357a:	1f 92       	push	r1
    357c:	cd b7       	in	r28, 0x3d	; 61
    357e:	de b7       	in	r29, 0x3e	; 62
    3580:	89 83       	std	Y+1, r24	; 0x01
    
    xQueueSendToBack(USART_WriteQueue,&data,portMAX_DELAY);
    3582:	80 91 ca 1a 	lds	r24, 0x1ACA
    3586:	90 91 cb 1a 	lds	r25, 0x1ACB
    358a:	20 e0       	ldi	r18, 0x00	; 0
    358c:	4f ef       	ldi	r20, 0xFF	; 255
    358e:	5f ef       	ldi	r21, 0xFF	; 255
    3590:	be 01       	movw	r22, r28
    3592:	6f 5f       	subi	r22, 0xFF	; 255
    3594:	7f 4f       	sbci	r23, 0xFF	; 255
    3596:	0e 94 9e 0d 	call	0x1b3c	; 0x1b3c <xQueueGenericSend>

}
    359a:	0f 90       	pop	r0
    359c:	df 91       	pop	r29
    359e:	cf 91       	pop	r28
    35a0:	08 95       	ret

000035a2 <USART_TransmitString>:

void USART_TransmitString(char* str){
    35a2:	cf 93       	push	r28
    35a4:	df 93       	push	r29
    35a6:	1f 92       	push	r1
    35a8:	1f 92       	push	r1
    35aa:	cd b7       	in	r28, 0x3d	; 61
    35ac:	de b7       	in	r29, 0x3e	; 62
    35ae:	9a 83       	std	Y+2, r25	; 0x02
    35b0:	89 83       	std	Y+1, r24	; 0x01
    while(*str) {
    35b2:	0b c0       	rjmp	.+22     	; 0x35ca <USART_TransmitString+0x28>
        USART_AddToQueue(*str);
    35b4:	89 81       	ldd	r24, Y+1	; 0x01
    35b6:	9a 81       	ldd	r25, Y+2	; 0x02
    35b8:	fc 01       	movw	r30, r24
    35ba:	80 81       	ld	r24, Z
    35bc:	0e 94 bb 1a 	call	0x3576	; 0x3576 <USART_AddToQueue>
        str++;
    35c0:	89 81       	ldd	r24, Y+1	; 0x01
    35c2:	9a 81       	ldd	r25, Y+2	; 0x02
    35c4:	01 96       	adiw	r24, 0x01	; 1
    35c6:	9a 83       	std	Y+2, r25	; 0x02
    35c8:	89 83       	std	Y+1, r24	; 0x01
    xQueueSendToBack(USART_WriteQueue,&data,portMAX_DELAY);

}

void USART_TransmitString(char* str){
    while(*str) {
    35ca:	89 81       	ldd	r24, Y+1	; 0x01
    35cc:	9a 81       	ldd	r25, Y+2	; 0x02
    35ce:	fc 01       	movw	r30, r24
    35d0:	80 81       	ld	r24, Z
    35d2:	88 23       	and	r24, r24
    35d4:	79 f7       	brne	.-34     	; 0x35b4 <USART_TransmitString+0x12>
        USART_AddToQueue(*str);
        str++;
    }
}
    35d6:	0f 90       	pop	r0
    35d8:	0f 90       	pop	r0
    35da:	df 91       	pop	r29
    35dc:	cf 91       	pop	r28
    35de:	08 95       	ret

000035e0 <vTaskUSARTWrite>:

void vTaskUSARTWrite(void *pvParameters){
    35e0:	cf 93       	push	r28
    35e2:	df 93       	push	r29
    35e4:	00 d0       	rcall	.+0      	; 0x35e6 <vTaskUSARTWrite+0x6>
    35e6:	cd b7       	in	r28, 0x3d	; 61
    35e8:	de b7       	in	r29, 0x3e	; 62
    35ea:	9b 83       	std	Y+3, r25	; 0x03
    35ec:	8a 83       	std	Y+2, r24	; 0x02
    uint8_t data;
    while(1){
    xQueueReceive(USART_WriteQueue,&data,portMAX_DELAY);
    35ee:	80 91 ca 1a 	lds	r24, 0x1ACA
    35f2:	90 91 cb 1a 	lds	r25, 0x1ACB
    35f6:	20 e0       	ldi	r18, 0x00	; 0
    35f8:	4f ef       	ldi	r20, 0xFF	; 255
    35fa:	5f ef       	ldi	r21, 0xFF	; 255
    35fc:	be 01       	movw	r22, r28
    35fe:	6f 5f       	subi	r22, 0xFF	; 255
    3600:	7f 4f       	sbci	r23, 0xFF	; 255
    3602:	0e 94 9b 0e 	call	0x1d36	; 0x1d36 <xQueueGenericReceive>

        while(!(UCSR1A & (1<<UDRE1)));
    3606:	00 00       	nop
    3608:	88 ec       	ldi	r24, 0xC8	; 200
    360a:	90 e0       	ldi	r25, 0x00	; 0
    360c:	fc 01       	movw	r30, r24
    360e:	80 81       	ld	r24, Z
    3610:	88 2f       	mov	r24, r24
    3612:	90 e0       	ldi	r25, 0x00	; 0
    3614:	80 72       	andi	r24, 0x20	; 32
    3616:	99 27       	eor	r25, r25
    3618:	00 97       	sbiw	r24, 0x00	; 0
    361a:	b1 f3       	breq	.-20     	; 0x3608 <vTaskUSARTWrite+0x28>
        UDR1 = data;
    361c:	8e ec       	ldi	r24, 0xCE	; 206
    361e:	90 e0       	ldi	r25, 0x00	; 0
    3620:	29 81       	ldd	r18, Y+1	; 0x01
    3622:	fc 01       	movw	r30, r24
    3624:	20 83       	st	Z, r18

    }
    3626:	e3 cf       	rjmp	.-58     	; 0x35ee <vTaskUSARTWrite+0xe>

00003628 <USART_LogChar>:
}

void USART_LogChar(uint8_t data){
    3628:	cf 93       	push	r28
    362a:	df 93       	push	r29
    362c:	1f 92       	push	r1
    362e:	cd b7       	in	r28, 0x3d	; 61
    3630:	de b7       	in	r29, 0x3e	; 62
    3632:	89 83       	std	Y+1, r24	; 0x01
    xQueueSendToBack(USART_WriteQueueLog,&data,portMAX_DELAY);
    3634:	80 91 c8 1a 	lds	r24, 0x1AC8
    3638:	90 91 c9 1a 	lds	r25, 0x1AC9
    363c:	20 e0       	ldi	r18, 0x00	; 0
    363e:	4f ef       	ldi	r20, 0xFF	; 255
    3640:	5f ef       	ldi	r21, 0xFF	; 255
    3642:	be 01       	movw	r22, r28
    3644:	6f 5f       	subi	r22, 0xFF	; 255
    3646:	7f 4f       	sbci	r23, 0xFF	; 255
    3648:	0e 94 9e 0d 	call	0x1b3c	; 0x1b3c <xQueueGenericSend>
}
    364c:	0f 90       	pop	r0
    364e:	df 91       	pop	r29
    3650:	cf 91       	pop	r28
    3652:	08 95       	ret

00003654 <USART_LogString>:

void USART_LogString(char* str){
    3654:	cf 93       	push	r28
    3656:	df 93       	push	r29
    3658:	1f 92       	push	r1
    365a:	1f 92       	push	r1
    365c:	cd b7       	in	r28, 0x3d	; 61
    365e:	de b7       	in	r29, 0x3e	; 62
    3660:	9a 83       	std	Y+2, r25	; 0x02
    3662:	89 83       	std	Y+1, r24	; 0x01
    while(*str){
    3664:	0b c0       	rjmp	.+22     	; 0x367c <USART_LogString+0x28>
        USART_LogChar(*str);
    3666:	89 81       	ldd	r24, Y+1	; 0x01
    3668:	9a 81       	ldd	r25, Y+2	; 0x02
    366a:	fc 01       	movw	r30, r24
    366c:	80 81       	ld	r24, Z
    366e:	0e 94 14 1b 	call	0x3628	; 0x3628 <USART_LogChar>
        str++;
    3672:	89 81       	ldd	r24, Y+1	; 0x01
    3674:	9a 81       	ldd	r25, Y+2	; 0x02
    3676:	01 96       	adiw	r24, 0x01	; 1
    3678:	9a 83       	std	Y+2, r25	; 0x02
    367a:	89 83       	std	Y+1, r24	; 0x01
void USART_LogChar(uint8_t data){
    xQueueSendToBack(USART_WriteQueueLog,&data,portMAX_DELAY);
}

void USART_LogString(char* str){
    while(*str){
    367c:	89 81       	ldd	r24, Y+1	; 0x01
    367e:	9a 81       	ldd	r25, Y+2	; 0x02
    3680:	fc 01       	movw	r30, r24
    3682:	80 81       	ld	r24, Z
    3684:	88 23       	and	r24, r24
    3686:	79 f7       	brne	.-34     	; 0x3666 <USART_LogString+0x12>
        USART_LogChar(*str);
        str++;
    }
}
    3688:	0f 90       	pop	r0
    368a:	0f 90       	pop	r0
    368c:	df 91       	pop	r29
    368e:	cf 91       	pop	r28
    3690:	08 95       	ret

00003692 <vTaskUSARTLog>:

void vTaskUSARTLog(void *pvParameters){
    3692:	cf 93       	push	r28
    3694:	df 93       	push	r29
    3696:	00 d0       	rcall	.+0      	; 0x3698 <vTaskUSARTLog+0x6>
    3698:	cd b7       	in	r28, 0x3d	; 61
    369a:	de b7       	in	r29, 0x3e	; 62
    369c:	9b 83       	std	Y+3, r25	; 0x03
    369e:	8a 83       	std	Y+2, r24	; 0x02
    uint8_t data;
    while(1){
        xQueueReceive(USART_WriteQueueLog,&data,portMAX_DELAY);
    36a0:	80 91 c8 1a 	lds	r24, 0x1AC8
    36a4:	90 91 c9 1a 	lds	r25, 0x1AC9
    36a8:	20 e0       	ldi	r18, 0x00	; 0
    36aa:	4f ef       	ldi	r20, 0xFF	; 255
    36ac:	5f ef       	ldi	r21, 0xFF	; 255
    36ae:	be 01       	movw	r22, r28
    36b0:	6f 5f       	subi	r22, 0xFF	; 255
    36b2:	7f 4f       	sbci	r23, 0xFF	; 255
    36b4:	0e 94 9b 0e 	call	0x1d36	; 0x1d36 <xQueueGenericReceive>

        while(!(UCSR0A & (1<<UDRE0)));
    36b8:	00 00       	nop
    36ba:	80 ec       	ldi	r24, 0xC0	; 192
    36bc:	90 e0       	ldi	r25, 0x00	; 0
    36be:	fc 01       	movw	r30, r24
    36c0:	80 81       	ld	r24, Z
    36c2:	88 2f       	mov	r24, r24
    36c4:	90 e0       	ldi	r25, 0x00	; 0
    36c6:	80 72       	andi	r24, 0x20	; 32
    36c8:	99 27       	eor	r25, r25
    36ca:	00 97       	sbiw	r24, 0x00	; 0
    36cc:	b1 f3       	breq	.-20     	; 0x36ba <vTaskUSARTLog+0x28>
        UDR0 = data;
    36ce:	86 ec       	ldi	r24, 0xC6	; 198
    36d0:	90 e0       	ldi	r25, 0x00	; 0
    36d2:	29 81       	ldd	r18, Y+1	; 0x01
    36d4:	fc 01       	movw	r30, r24
    36d6:	20 83       	st	Z, r18

    }
    36d8:	e3 cf       	rjmp	.-58     	; 0x36a0 <vTaskUSARTLog+0xe>

000036da <USART_GetChar>:

}

uint8_t USART_GetChar(){
    36da:	cf 93       	push	r28
    36dc:	df 93       	push	r29
    36de:	1f 92       	push	r1
    36e0:	cd b7       	in	r28, 0x3d	; 61
    36e2:	de b7       	in	r29, 0x3e	; 62
    uint8_t data;
    if(xQueueReceive(USART_ReadQueue,&data,1) == pdTRUE){
    36e4:	80 91 c6 1a 	lds	r24, 0x1AC6
    36e8:	90 91 c7 1a 	lds	r25, 0x1AC7
    36ec:	20 e0       	ldi	r18, 0x00	; 0
    36ee:	41 e0       	ldi	r20, 0x01	; 1
    36f0:	50 e0       	ldi	r21, 0x00	; 0
    36f2:	be 01       	movw	r22, r28
    36f4:	6f 5f       	subi	r22, 0xFF	; 255
    36f6:	7f 4f       	sbci	r23, 0xFF	; 255
    36f8:	0e 94 9b 0e 	call	0x1d36	; 0x1d36 <xQueueGenericReceive>
    36fc:	81 30       	cpi	r24, 0x01	; 1
    36fe:	11 f4       	brne	.+4      	; 0x3704 <USART_GetChar+0x2a>
        //USART_AddToQueue('~');
        return data;
    3700:	89 81       	ldd	r24, Y+1	; 0x01
    3702:	01 c0       	rjmp	.+2      	; 0x3706 <USART_GetChar+0x2c>
    } else {
        return 255;
    3704:	8f ef       	ldi	r24, 0xFF	; 255
    }
}
    3706:	0f 90       	pop	r0
    3708:	df 91       	pop	r29
    370a:	cf 91       	pop	r28
    370c:	08 95       	ret

0000370e <delay>:

void delay(int a){
    370e:	cf 93       	push	r28
    3710:	df 93       	push	r29
    3712:	00 d0       	rcall	.+0      	; 0x3714 <delay+0x6>
    3714:	1f 92       	push	r1
    3716:	cd b7       	in	r28, 0x3d	; 61
    3718:	de b7       	in	r29, 0x3e	; 62
    371a:	9c 83       	std	Y+4, r25	; 0x04
    371c:	8b 83       	std	Y+3, r24	; 0x03
	int i;
	for(i = 0;i < a;i++);
    371e:	1a 82       	std	Y+2, r1	; 0x02
    3720:	19 82       	std	Y+1, r1	; 0x01
    3722:	05 c0       	rjmp	.+10     	; 0x372e <delay+0x20>
    3724:	89 81       	ldd	r24, Y+1	; 0x01
    3726:	9a 81       	ldd	r25, Y+2	; 0x02
    3728:	01 96       	adiw	r24, 0x01	; 1
    372a:	9a 83       	std	Y+2, r25	; 0x02
    372c:	89 83       	std	Y+1, r24	; 0x01
    372e:	29 81       	ldd	r18, Y+1	; 0x01
    3730:	3a 81       	ldd	r19, Y+2	; 0x02
    3732:	8b 81       	ldd	r24, Y+3	; 0x03
    3734:	9c 81       	ldd	r25, Y+4	; 0x04
    3736:	28 17       	cp	r18, r24
    3738:	39 07       	cpc	r19, r25
    373a:	a4 f3       	brlt	.-24     	; 0x3724 <delay+0x16>
}
    373c:	0f 90       	pop	r0
    373e:	0f 90       	pop	r0
    3740:	0f 90       	pop	r0
    3742:	0f 90       	pop	r0
    3744:	df 91       	pop	r29
    3746:	cf 91       	pop	r28
    3748:	08 95       	ret

0000374a <sendACK>:

void sendACK(){
    374a:	cf 93       	push	r28
    374c:	df 93       	push	r29
    374e:	cd b7       	in	r28, 0x3d	; 61
    3750:	de b7       	in	r29, 0x3e	; 62
    USART_Write(ACK_BYTE);
    3752:	80 e8       	ldi	r24, 0x80	; 128
    3754:	0e 94 4e 1a 	call	0x349c	; 0x349c <USART_Write>
}
    3758:	df 91       	pop	r29
    375a:	cf 91       	pop	r28
    375c:	08 95       	ret

0000375e <sendNACK>:

void sendNACK(){
    375e:	cf 93       	push	r28
    3760:	df 93       	push	r29
    3762:	cd b7       	in	r28, 0x3d	; 61
    3764:	de b7       	in	r29, 0x3e	; 62
    USART_Write(NACK_BYTE);
    3766:	80 e0       	ldi	r24, 0x00	; 0
    3768:	0e 94 4e 1a 	call	0x349c	; 0x349c <USART_Write>
}
    376c:	df 91       	pop	r29
    376e:	cf 91       	pop	r28
    3770:	08 95       	ret

00003772 <recievePayload>:

int recievePayload(int size,unsigned char *buffer){
    3772:	cf 93       	push	r28
    3774:	df 93       	push	r29
    3776:	cd b7       	in	r28, 0x3d	; 61
    3778:	de b7       	in	r29, 0x3e	; 62
    377a:	2d 97       	sbiw	r28, 0x0d	; 13
    377c:	0f b6       	in	r0, 0x3f	; 63
    377e:	f8 94       	cli
    3780:	de bf       	out	0x3e, r29	; 62
    3782:	0f be       	out	0x3f, r0	; 63
    3784:	cd bf       	out	0x3d, r28	; 61
    3786:	9b 87       	std	Y+11, r25	; 0x0b
    3788:	8a 87       	std	Y+10, r24	; 0x0a
    378a:	7d 87       	std	Y+13, r23	; 0x0d
    378c:	6c 87       	std	Y+12, r22	; 0x0c

	int bytesRecieved = 0;
    378e:	1a 82       	std	Y+2, r1	; 0x02
    3790:	19 82       	std	Y+1, r1	; 0x01
	int numTries = 0;
    3792:	1c 82       	std	Y+4, r1	; 0x04
    3794:	1b 82       	std	Y+3, r1	; 0x03
	const int maxNumTries = 3;
    3796:	83 e0       	ldi	r24, 0x03	; 3
    3798:	90 e0       	ldi	r25, 0x00	; 0
    379a:	98 87       	std	Y+8, r25	; 0x08
    379c:	8f 83       	std	Y+7, r24	; 0x07
	unsigned char data;
	int timeout;

	while(numTries < maxNumTries){
    379e:	6d c0       	rjmp	.+218    	; 0x387a <recievePayload+0x108>
		while(bytesRecieved < size){
    37a0:	2e c0       	rjmp	.+92     	; 0x37fe <recievePayload+0x8c>
			timeout = 50;
    37a2:	82 e3       	ldi	r24, 0x32	; 50
    37a4:	90 e0       	ldi	r25, 0x00	; 0
    37a6:	9e 83       	std	Y+6, r25	; 0x06
    37a8:	8d 83       	std	Y+5, r24	; 0x05
			while ( !(UCSR2A & (1<<RXC2)) ){
    37aa:	10 c0       	rjmp	.+32     	; 0x37cc <recievePayload+0x5a>
  				timeout--;
    37ac:	8d 81       	ldd	r24, Y+5	; 0x05
    37ae:	9e 81       	ldd	r25, Y+6	; 0x06
    37b0:	01 97       	sbiw	r24, 0x01	; 1
    37b2:	9e 83       	std	Y+6, r25	; 0x06
    37b4:	8d 83       	std	Y+5, r24	; 0x05
     			if(timeout == 0){
    37b6:	8d 81       	ldd	r24, Y+5	; 0x05
    37b8:	9e 81       	ldd	r25, Y+6	; 0x06
    37ba:	00 97       	sbiw	r24, 0x00	; 0
    37bc:	19 f4       	brne	.+6      	; 0x37c4 <recievePayload+0x52>
					return -1;
    37be:	8f ef       	ldi	r24, 0xFF	; 255
    37c0:	9f ef       	ldi	r25, 0xFF	; 255
    37c2:	65 c0       	rjmp	.+202    	; 0x388e <recievePayload+0x11c>
     			}
     			vTaskDelay(1);
    37c4:	81 e0       	ldi	r24, 0x01	; 1
    37c6:	90 e0       	ldi	r25, 0x00	; 0
    37c8:	0e 94 6f 04 	call	0x8de	; 0x8de <vTaskDelay>
	int timeout;

	while(numTries < maxNumTries){
		while(bytesRecieved < size){
			timeout = 50;
			while ( !(UCSR2A & (1<<RXC2)) ){
    37cc:	80 ed       	ldi	r24, 0xD0	; 208
    37ce:	90 e0       	ldi	r25, 0x00	; 0
    37d0:	fc 01       	movw	r30, r24
    37d2:	80 81       	ld	r24, Z
    37d4:	88 23       	and	r24, r24
    37d6:	54 f7       	brge	.-44     	; 0x37ac <recievePayload+0x3a>
     			if(timeout == 0){
					return -1;
     			}
     			vTaskDelay(1);
   		}
			data = UDR2;
    37d8:	86 ed       	ldi	r24, 0xD6	; 214
    37da:	90 e0       	ldi	r25, 0x00	; 0
    37dc:	fc 01       	movw	r30, r24
    37de:	80 81       	ld	r24, Z
    37e0:	89 87       	std	Y+9, r24	; 0x09
			buffer[bytesRecieved] = data;
    37e2:	89 81       	ldd	r24, Y+1	; 0x01
    37e4:	9a 81       	ldd	r25, Y+2	; 0x02
    37e6:	2c 85       	ldd	r18, Y+12	; 0x0c
    37e8:	3d 85       	ldd	r19, Y+13	; 0x0d
    37ea:	82 0f       	add	r24, r18
    37ec:	93 1f       	adc	r25, r19
    37ee:	29 85       	ldd	r18, Y+9	; 0x09
    37f0:	fc 01       	movw	r30, r24
    37f2:	20 83       	st	Z, r18
			bytesRecieved++;
    37f4:	89 81       	ldd	r24, Y+1	; 0x01
    37f6:	9a 81       	ldd	r25, Y+2	; 0x02
    37f8:	01 96       	adiw	r24, 0x01	; 1
    37fa:	9a 83       	std	Y+2, r25	; 0x02
    37fc:	89 83       	std	Y+1, r24	; 0x01
	const int maxNumTries = 3;
	unsigned char data;
	int timeout;

	while(numTries < maxNumTries){
		while(bytesRecieved < size){
    37fe:	29 81       	ldd	r18, Y+1	; 0x01
    3800:	3a 81       	ldd	r19, Y+2	; 0x02
    3802:	8a 85       	ldd	r24, Y+10	; 0x0a
    3804:	9b 85       	ldd	r25, Y+11	; 0x0b
    3806:	28 17       	cp	r18, r24
    3808:	39 07       	cpc	r19, r25
    380a:	5c f2       	brlt	.-106    	; 0x37a2 <recievePayload+0x30>
			data = UDR2;
			buffer[bytesRecieved] = data;
			bytesRecieved++;
		}
		
		timeout = 50;
    380c:	82 e3       	ldi	r24, 0x32	; 50
    380e:	90 e0       	ldi	r25, 0x00	; 0
    3810:	9e 83       	std	Y+6, r25	; 0x06
    3812:	8d 83       	std	Y+5, r24	; 0x05
		while ( !(UCSR2A & (1<<RXC2)) ){
    3814:	10 c0       	rjmp	.+32     	; 0x3836 <recievePayload+0xc4>
  			timeout--;
    3816:	8d 81       	ldd	r24, Y+5	; 0x05
    3818:	9e 81       	ldd	r25, Y+6	; 0x06
    381a:	01 97       	sbiw	r24, 0x01	; 1
    381c:	9e 83       	std	Y+6, r25	; 0x06
    381e:	8d 83       	std	Y+5, r24	; 0x05
     		if(timeout == 0){
    3820:	8d 81       	ldd	r24, Y+5	; 0x05
    3822:	9e 81       	ldd	r25, Y+6	; 0x06
    3824:	00 97       	sbiw	r24, 0x00	; 0
    3826:	19 f4       	brne	.+6      	; 0x382e <recievePayload+0xbc>
				return -1;
    3828:	8f ef       	ldi	r24, 0xFF	; 255
    382a:	9f ef       	ldi	r25, 0xFF	; 255
    382c:	30 c0       	rjmp	.+96     	; 0x388e <recievePayload+0x11c>
     		}
     		vTaskDelay(1);
    382e:	81 e0       	ldi	r24, 0x01	; 1
    3830:	90 e0       	ldi	r25, 0x00	; 0
    3832:	0e 94 6f 04 	call	0x8de	; 0x8de <vTaskDelay>
			buffer[bytesRecieved] = data;
			bytesRecieved++;
		}
		
		timeout = 50;
		while ( !(UCSR2A & (1<<RXC2)) ){
    3836:	80 ed       	ldi	r24, 0xD0	; 208
    3838:	90 e0       	ldi	r25, 0x00	; 0
    383a:	fc 01       	movw	r30, r24
    383c:	80 81       	ld	r24, Z
    383e:	88 23       	and	r24, r24
    3840:	54 f7       	brge	.-44     	; 0x3816 <recievePayload+0xa4>
     		if(timeout == 0){
				return -1;
     		}
     		vTaskDelay(1);
   	}	
		data = UDR2;
    3842:	86 ed       	ldi	r24, 0xD6	; 214
    3844:	90 e0       	ldi	r25, 0x00	; 0
    3846:	fc 01       	movw	r30, r24
    3848:	80 81       	ld	r24, Z
    384a:	89 87       	std	Y+9, r24	; 0x09
		if(data != calcChecksum(buffer,size)){
    384c:	2a 85       	ldd	r18, Y+10	; 0x0a
    384e:	8c 85       	ldd	r24, Y+12	; 0x0c
    3850:	9d 85       	ldd	r25, Y+13	; 0x0d
    3852:	62 2f       	mov	r22, r18
    3854:	0e 94 90 1d 	call	0x3b20	; 0x3b20 <calcChecksum>
    3858:	98 2f       	mov	r25, r24
    385a:	89 85       	ldd	r24, Y+9	; 0x09
    385c:	98 17       	cp	r25, r24
    385e:	41 f0       	breq	.+16     	; 0x3870 <recievePayload+0xfe>
			sendNACK();
    3860:	0e 94 af 1b 	call	0x375e	; 0x375e <sendNACK>
			numTries++;
    3864:	8b 81       	ldd	r24, Y+3	; 0x03
    3866:	9c 81       	ldd	r25, Y+4	; 0x04
    3868:	01 96       	adiw	r24, 0x01	; 1
    386a:	9c 83       	std	Y+4, r25	; 0x04
    386c:	8b 83       	std	Y+3, r24	; 0x03
    386e:	05 c0       	rjmp	.+10     	; 0x387a <recievePayload+0x108>
		} else {
			sendACK();
    3870:	0e 94 a5 1b 	call	0x374a	; 0x374a <sendACK>
			return 0;
    3874:	80 e0       	ldi	r24, 0x00	; 0
    3876:	90 e0       	ldi	r25, 0x00	; 0
    3878:	0a c0       	rjmp	.+20     	; 0x388e <recievePayload+0x11c>
	int numTries = 0;
	const int maxNumTries = 3;
	unsigned char data;
	int timeout;

	while(numTries < maxNumTries){
    387a:	2b 81       	ldd	r18, Y+3	; 0x03
    387c:	3c 81       	ldd	r19, Y+4	; 0x04
    387e:	8f 81       	ldd	r24, Y+7	; 0x07
    3880:	98 85       	ldd	r25, Y+8	; 0x08
    3882:	28 17       	cp	r18, r24
    3884:	39 07       	cpc	r19, r25
    3886:	0c f4       	brge	.+2      	; 0x388a <recievePayload+0x118>
    3888:	8b cf       	rjmp	.-234    	; 0x37a0 <recievePayload+0x2e>
		} else {
			sendACK();
			return 0;
		}
	}
	return -1;
    388a:	8f ef       	ldi	r24, 0xFF	; 255
    388c:	9f ef       	ldi	r25, 0xFF	; 255
}
    388e:	2d 96       	adiw	r28, 0x0d	; 13
    3890:	0f b6       	in	r0, 0x3f	; 63
    3892:	f8 94       	cli
    3894:	de bf       	out	0x3e, r29	; 62
    3896:	0f be       	out	0x3f, r0	; 63
    3898:	cd bf       	out	0x3d, r28	; 61
    389a:	df 91       	pop	r29
    389c:	cf 91       	pop	r28
    389e:	08 95       	ret

000038a0 <vTaskUSARTRead>:

void vTaskUSARTRead(void *pvParameters){
    38a0:	cf 93       	push	r28
    38a2:	df 93       	push	r29
    38a4:	cd b7       	in	r28, 0x3d	; 61
    38a6:	de b7       	in	r29, 0x3e	; 62
    38a8:	cc 55       	subi	r28, 0x5C	; 92
    38aa:	d1 09       	sbc	r29, r1
    38ac:	0f b6       	in	r0, 0x3f	; 63
    38ae:	f8 94       	cli
    38b0:	de bf       	out	0x3e, r29	; 62
    38b2:	0f be       	out	0x3f, r0	; 63
    38b4:	cd bf       	out	0x3d, r28	; 61
    38b6:	9e 01       	movw	r18, r28
    38b8:	25 5a       	subi	r18, 0xA5	; 165
    38ba:	3f 4f       	sbci	r19, 0xFF	; 255
    38bc:	f9 01       	movw	r30, r18
    38be:	91 83       	std	Z+1, r25	; 0x01
    38c0:	80 83       	st	Z, r24
    unsigned char size;
    char groupID;
    char cmd;
    unsigned int timeout;

	DDRB = 0xFF;
    38c2:	84 e2       	ldi	r24, 0x24	; 36
    38c4:	90 e0       	ldi	r25, 0x00	; 0
    38c6:	2f ef       	ldi	r18, 0xFF	; 255
    38c8:	fc 01       	movw	r30, r24
    38ca:	20 83       	st	Z, r18

    Command command;
    Response response;
    while(1){
        bytesRecieved = 0;
    38cc:	19 82       	std	Y+1, r1	; 0x01
        int timeout = 30;
    38ce:	8e e1       	ldi	r24, 0x1E	; 30
    38d0:	90 e0       	ldi	r25, 0x00	; 0
    38d2:	9b 83       	std	Y+3, r25	; 0x03
    38d4:	8a 83       	std	Y+2, r24	; 0x02
        while(bytesRecieved < 4){
    38d6:	2d c0       	rjmp	.+90     	; 0x3932 <vTaskUSARTRead+0x92>
            
            while ( !(UCSR2A & (1<<RXC2)) ){
    38d8:	12 c0       	rjmp	.+36     	; 0x38fe <vTaskUSARTRead+0x5e>
                timeout--;
    38da:	8a 81       	ldd	r24, Y+2	; 0x02
    38dc:	9b 81       	ldd	r25, Y+3	; 0x03
    38de:	01 97       	sbiw	r24, 0x01	; 1
    38e0:	9b 83       	std	Y+3, r25	; 0x03
    38e2:	8a 83       	std	Y+2, r24	; 0x02
                if(timeout == 0){
    38e4:	8a 81       	ldd	r24, Y+2	; 0x02
    38e6:	9b 81       	ldd	r25, Y+3	; 0x03
    38e8:	00 97       	sbiw	r24, 0x00	; 0
    38ea:	29 f4       	brne	.+10     	; 0x38f6 <vTaskUSARTRead+0x56>
                    bytesRecieved = 0;
    38ec:	19 82       	std	Y+1, r1	; 0x01
                    timeout = 30;
    38ee:	8e e1       	ldi	r24, 0x1E	; 30
    38f0:	90 e0       	ldi	r25, 0x00	; 0
    38f2:	9b 83       	std	Y+3, r25	; 0x03
    38f4:	8a 83       	std	Y+2, r24	; 0x02
                }
                vTaskDelay(1);
    38f6:	81 e0       	ldi	r24, 0x01	; 1
    38f8:	90 e0       	ldi	r25, 0x00	; 0
    38fa:	0e 94 6f 04 	call	0x8de	; 0x8de <vTaskDelay>
    while(1){
        bytesRecieved = 0;
        int timeout = 30;
        while(bytesRecieved < 4){
            
            while ( !(UCSR2A & (1<<RXC2)) ){
    38fe:	80 ed       	ldi	r24, 0xD0	; 208
    3900:	90 e0       	ldi	r25, 0x00	; 0
    3902:	fc 01       	movw	r30, r24
    3904:	80 81       	ld	r24, Z
    3906:	88 23       	and	r24, r24
    3908:	44 f7       	brge	.-48     	; 0x38da <vTaskUSARTRead+0x3a>
                    bytesRecieved = 0;
                    timeout = 30;
                }
                vTaskDelay(1);
            }
            data = UDR2;
    390a:	86 ed       	ldi	r24, 0xD6	; 214
    390c:	90 e0       	ldi	r25, 0x00	; 0
    390e:	fc 01       	movw	r30, r24
    3910:	80 81       	ld	r24, Z
    3912:	8c 83       	std	Y+4, r24	; 0x04
            buffer[bytesRecieved] = data;
    3914:	89 81       	ldd	r24, Y+1	; 0x01
    3916:	99 27       	eor	r25, r25
    3918:	87 fd       	sbrc	r24, 7
    391a:	90 95       	com	r25
    391c:	9e 01       	movw	r18, r28
    391e:	2a 5f       	subi	r18, 0xFA	; 250
    3920:	3f 4f       	sbci	r19, 0xFF	; 255
    3922:	82 0f       	add	r24, r18
    3924:	93 1f       	adc	r25, r19
    3926:	2c 81       	ldd	r18, Y+4	; 0x04
    3928:	fc 01       	movw	r30, r24
    392a:	20 83       	st	Z, r18
            bytesRecieved++;        
    392c:	89 81       	ldd	r24, Y+1	; 0x01
    392e:	8f 5f       	subi	r24, 0xFF	; 255
    3930:	89 83       	std	Y+1, r24	; 0x01
    Command command;
    Response response;
    while(1){
        bytesRecieved = 0;
        int timeout = 30;
        while(bytesRecieved < 4){
    3932:	89 81       	ldd	r24, Y+1	; 0x01
    3934:	84 30       	cpi	r24, 0x04	; 4
    3936:	84 f2       	brlt	.-96     	; 0x38d8 <vTaskUSARTRead+0x38>
            data = UDR2;
            buffer[bytesRecieved] = data;
            bytesRecieved++;        
        }

        if(calcChecksum(buffer,3) != buffer[3]){
    3938:	ce 01       	movw	r24, r28
    393a:	06 96       	adiw	r24, 0x06	; 6
    393c:	63 e0       	ldi	r22, 0x03	; 3
    393e:	0e 94 90 1d 	call	0x3b20	; 0x3b20 <calcChecksum>
    3942:	98 2f       	mov	r25, r24
    3944:	89 85       	ldd	r24, Y+9	; 0x09
    3946:	98 17       	cp	r25, r24
    3948:	21 f0       	breq	.+8      	; 0x3952 <vTaskUSARTRead+0xb2>
            sendNACK();
    394a:	0e 94 af 1b 	call	0x375e	; 0x375e <sendNACK>
            bytesRecieved = 0;
    394e:	19 82       	std	Y+1, r1	; 0x01
    3950:	29 c0       	rjmp	.+82     	; 0x39a4 <vTaskUSARTRead+0x104>
        } else {
            sendACK();
    3952:	0e 94 a5 1b 	call	0x374a	; 0x374a <sendACK>
            bytesRecieved = 0;
    3956:	19 82       	std	Y+1, r1	; 0x01
				command.groupID = buffer[0];
    3958:	8e 81       	ldd	r24, Y+6	; 0x06
    395a:	8e 8b       	std	Y+22, r24	; 0x16
				command.cmd = buffer[1];
    395c:	8f 81       	ldd	r24, Y+7	; 0x07
    395e:	8f 8b       	std	Y+23, r24	; 0x17
				size = buffer[2];
    3960:	88 85       	ldd	r24, Y+8	; 0x08
    3962:	8d 83       	std	Y+5, r24	; 0x05

				if(size > 0){ //No dynamic memory allocations. 16 is the size of the buffer
    3964:	8d 81       	ldd	r24, Y+5	; 0x05
    3966:	88 23       	and	r24, r24
    3968:	81 f0       	breq	.+32     	; 0x398a <vTaskUSARTRead+0xea>
					if(recievePayload(size,command.payload) == -1){
    396a:	8d 81       	ldd	r24, Y+5	; 0x05
    396c:	88 2f       	mov	r24, r24
    396e:	90 e0       	ldi	r25, 0x00	; 0
    3970:	9e 01       	movw	r18, r28
    3972:	2a 5e       	subi	r18, 0xEA	; 234
    3974:	3f 4f       	sbci	r19, 0xFF	; 255
    3976:	2d 5f       	subi	r18, 0xFD	; 253
    3978:	3f 4f       	sbci	r19, 0xFF	; 255
    397a:	b9 01       	movw	r22, r18
    397c:	0e 94 b9 1b 	call	0x3772	; 0x3772 <recievePayload>
    3980:	8f 3f       	cpi	r24, 0xFF	; 255
    3982:	ff ef       	ldi	r31, 0xFF	; 255
    3984:	9f 07       	cpc	r25, r31
    3986:	09 f4       	brne	.+2      	; 0x398a <vTaskUSARTRead+0xea>
						continue;	//Restart comms
    3988:	0d c0       	rjmp	.+26     	; 0x39a4 <vTaskUSARTRead+0x104>
					}
				}
				
 
            processCommand(&command,&response);
    398a:	9e 01       	movw	r18, r28
    398c:	27 5c       	subi	r18, 0xC7	; 199
    398e:	3f 4f       	sbci	r19, 0xFF	; 255
    3990:	ce 01       	movw	r24, r28
    3992:	46 96       	adiw	r24, 0x16	; 22
    3994:	b9 01       	movw	r22, r18
    3996:	0e 94 5f 1f 	call	0x3ebe	; 0x3ebe <processCommand>
            sendResponse(&response);
    399a:	ce 01       	movw	r24, r28
    399c:	c9 96       	adiw	r24, 0x39	; 57
    399e:	0e 94 d3 1c 	call	0x39a6	; 0x39a6 <sendResponse>

        }

    }
    39a2:	94 cf       	rjmp	.-216    	; 0x38cc <vTaskUSARTRead+0x2c>
    39a4:	93 cf       	rjmp	.-218    	; 0x38cc <vTaskUSARTRead+0x2c>

000039a6 <sendResponse>:

}

int sendResponse(Response* response){
    39a6:	cf 93       	push	r28
    39a8:	df 93       	push	r29
    39aa:	cd b7       	in	r28, 0x3d	; 61
    39ac:	de b7       	in	r29, 0x3e	; 62
    39ae:	28 97       	sbiw	r28, 0x08	; 8
    39b0:	0f b6       	in	r0, 0x3f	; 63
    39b2:	f8 94       	cli
    39b4:	de bf       	out	0x3e, r29	; 62
    39b6:	0f be       	out	0x3f, r0	; 63
    39b8:	cd bf       	out	0x3d, r28	; 61
    39ba:	98 87       	std	Y+8, r25	; 0x08
    39bc:	8f 83       	std	Y+7, r24	; 0x07
    char checksumBuffer[2];
    int i;
    int timeout = 50;
    39be:	82 e3       	ldi	r24, 0x32	; 50
    39c0:	90 e0       	ldi	r25, 0x00	; 0
    39c2:	9c 83       	std	Y+4, r25	; 0x04
    39c4:	8b 83       	std	Y+3, r24	; 0x03
    while(1){
        	USART_Write(response->commandBack);
    39c6:	8f 81       	ldd	r24, Y+7	; 0x07
    39c8:	98 85       	ldd	r25, Y+8	; 0x08
    39ca:	fc 01       	movw	r30, r24
    39cc:	80 81       	ld	r24, Z
    39ce:	0e 94 4e 1a 	call	0x349c	; 0x349c <USART_Write>
			vTaskDelay(1);
    39d2:	81 e0       	ldi	r24, 0x01	; 1
    39d4:	90 e0       	ldi	r25, 0x00	; 0
    39d6:	0e 94 6f 04 	call	0x8de	; 0x8de <vTaskDelay>
        	USART_Write(response->size);
    39da:	8f 81       	ldd	r24, Y+7	; 0x07
    39dc:	98 85       	ldd	r25, Y+8	; 0x08
    39de:	fc 01       	movw	r30, r24
    39e0:	81 81       	ldd	r24, Z+1	; 0x01
    39e2:	0e 94 4e 1a 	call	0x349c	; 0x349c <USART_Write>
			vTaskDelay(1);
    39e6:	81 e0       	ldi	r24, 0x01	; 1
    39e8:	90 e0       	ldi	r25, 0x00	; 0
    39ea:	0e 94 6f 04 	call	0x8de	; 0x8de <vTaskDelay>
        	checksumBuffer[0] = response->commandBack;
    39ee:	8f 81       	ldd	r24, Y+7	; 0x07
    39f0:	98 85       	ldd	r25, Y+8	; 0x08
    39f2:	fc 01       	movw	r30, r24
    39f4:	80 81       	ld	r24, Z
    39f6:	8d 83       	std	Y+5, r24	; 0x05
        	checksumBuffer[1] = response->size;
    39f8:	8f 81       	ldd	r24, Y+7	; 0x07
    39fa:	98 85       	ldd	r25, Y+8	; 0x08
    39fc:	fc 01       	movw	r30, r24
    39fe:	81 81       	ldd	r24, Z+1	; 0x01
    3a00:	8e 83       	std	Y+6, r24	; 0x06
        	USART_Write(calcChecksum(checksumBuffer,2));
    3a02:	ce 01       	movw	r24, r28
    3a04:	05 96       	adiw	r24, 0x05	; 5
    3a06:	62 e0       	ldi	r22, 0x02	; 2
    3a08:	0e 94 90 1d 	call	0x3b20	; 0x3b20 <calcChecksum>
    3a0c:	0e 94 4e 1a 	call	0x349c	; 0x349c <USART_Write>
        	switch(waitForAck()){
    3a10:	0e 94 66 1d 	call	0x3acc	; 0x3acc <waitForAck>
    3a14:	99 27       	eor	r25, r25
    3a16:	87 fd       	sbrc	r24, 7
    3a18:	90 95       	com	r25
    3a1a:	00 97       	sbiw	r24, 0x00	; 0
    3a1c:	59 f0       	breq	.+22     	; 0x3a34 <sendResponse+0x8e>
    3a1e:	81 30       	cpi	r24, 0x01	; 1
    3a20:	91 05       	cpc	r25, r1
    3a22:	a9 f0       	breq	.+42     	; 0x3a4e <sendResponse+0xa8>
    3a24:	8f 3f       	cpi	r24, 0xFF	; 255
    3a26:	ff ef       	ldi	r31, 0xFF	; 255
    3a28:	9f 07       	cpc	r25, r31
    3a2a:	09 f0       	breq	.+2      	; 0x3a2e <sendResponse+0x88>
           	timeout--;
           	if(!timeout){
              	return -1;
           	}
        	}
    }
    3a2c:	cc cf       	rjmp	.-104    	; 0x39c6 <sendResponse+0x20>
        	USART_Write(calcChecksum(checksumBuffer,2));
        	switch(waitForAck()){
        	case 1:
           	goto outOfWhile;
        	case -1:
           	return -1;
    3a2e:	8f ef       	ldi	r24, 0xFF	; 255
    3a30:	9f ef       	ldi	r25, 0xFF	; 255
    3a32:	43 c0       	rjmp	.+134    	; 0x3aba <sendResponse+0x114>
        	case 0:
           	timeout--;
    3a34:	8b 81       	ldd	r24, Y+3	; 0x03
    3a36:	9c 81       	ldd	r25, Y+4	; 0x04
    3a38:	01 97       	sbiw	r24, 0x01	; 1
    3a3a:	9c 83       	std	Y+4, r25	; 0x04
    3a3c:	8b 83       	std	Y+3, r24	; 0x03
           	if(!timeout){
    3a3e:	8b 81       	ldd	r24, Y+3	; 0x03
    3a40:	9c 81       	ldd	r25, Y+4	; 0x04
    3a42:	00 97       	sbiw	r24, 0x00	; 0
    3a44:	19 f4       	brne	.+6      	; 0x3a4c <sendResponse+0xa6>
              	return -1;
    3a46:	8f ef       	ldi	r24, 0xFF	; 255
    3a48:	9f ef       	ldi	r25, 0xFF	; 255
    3a4a:	37 c0       	rjmp	.+110    	; 0x3aba <sendResponse+0x114>
           	}
        	}
    }
    3a4c:	bc cf       	rjmp	.-136    	; 0x39c6 <sendResponse+0x20>
        	checksumBuffer[0] = response->commandBack;
        	checksumBuffer[1] = response->size;
        	USART_Write(calcChecksum(checksumBuffer,2));
        	switch(waitForAck()){
        	case 1:
           	goto outOfWhile;
    3a4e:	00 00       	nop
    }

    outOfWhile:


    for(i=0;i<response->size;i++){
    3a50:	1a 82       	std	Y+2, r1	; 0x02
    3a52:	19 82       	std	Y+1, r1	; 0x01
    3a54:	14 c0       	rjmp	.+40     	; 0x3a7e <sendResponse+0xd8>
        USART_Write(response->payload[i]);
    3a56:	2f 81       	ldd	r18, Y+7	; 0x07
    3a58:	38 85       	ldd	r19, Y+8	; 0x08
    3a5a:	89 81       	ldd	r24, Y+1	; 0x01
    3a5c:	9a 81       	ldd	r25, Y+2	; 0x02
    3a5e:	82 0f       	add	r24, r18
    3a60:	93 1f       	adc	r25, r19
    3a62:	02 96       	adiw	r24, 0x02	; 2
    3a64:	fc 01       	movw	r30, r24
    3a66:	80 81       	ld	r24, Z
    3a68:	0e 94 4e 1a 	call	0x349c	; 0x349c <USART_Write>
			vTaskDelay(1);
    3a6c:	81 e0       	ldi	r24, 0x01	; 1
    3a6e:	90 e0       	ldi	r25, 0x00	; 0
    3a70:	0e 94 6f 04 	call	0x8de	; 0x8de <vTaskDelay>
    }

    outOfWhile:


    for(i=0;i<response->size;i++){
    3a74:	89 81       	ldd	r24, Y+1	; 0x01
    3a76:	9a 81       	ldd	r25, Y+2	; 0x02
    3a78:	01 96       	adiw	r24, 0x01	; 1
    3a7a:	9a 83       	std	Y+2, r25	; 0x02
    3a7c:	89 83       	std	Y+1, r24	; 0x01
    3a7e:	8f 81       	ldd	r24, Y+7	; 0x07
    3a80:	98 85       	ldd	r25, Y+8	; 0x08
    3a82:	fc 01       	movw	r30, r24
    3a84:	81 81       	ldd	r24, Z+1	; 0x01
    3a86:	28 2f       	mov	r18, r24
    3a88:	33 27       	eor	r19, r19
    3a8a:	27 fd       	sbrc	r18, 7
    3a8c:	30 95       	com	r19
    3a8e:	89 81       	ldd	r24, Y+1	; 0x01
    3a90:	9a 81       	ldd	r25, Y+2	; 0x02
    3a92:	82 17       	cp	r24, r18
    3a94:	93 07       	cpc	r25, r19
    3a96:	fc f2       	brlt	.-66     	; 0x3a56 <sendResponse+0xb0>
        USART_Write(response->payload[i]);
			vTaskDelay(1);
		  //USART_AddToQueue(0x30 | (i + 2));
        //USART_AddToQueue()
    }
    USART_Write(calcChecksum((uint8_t*)response->payload,response->size));
    3a98:	8f 81       	ldd	r24, Y+7	; 0x07
    3a9a:	98 85       	ldd	r25, Y+8	; 0x08
    3a9c:	fc 01       	movw	r30, r24
    3a9e:	81 81       	ldd	r24, Z+1	; 0x01
    3aa0:	28 2f       	mov	r18, r24
    3aa2:	8f 81       	ldd	r24, Y+7	; 0x07
    3aa4:	98 85       	ldd	r25, Y+8	; 0x08
    3aa6:	02 96       	adiw	r24, 0x02	; 2
    3aa8:	62 2f       	mov	r22, r18
    3aaa:	0e 94 90 1d 	call	0x3b20	; 0x3b20 <calcChecksum>
    3aae:	0e 94 4e 1a 	call	0x349c	; 0x349c <USART_Write>
	 

    waitForAck();
    3ab2:	0e 94 66 1d 	call	0x3acc	; 0x3acc <waitForAck>

    return 0;
    3ab6:	80 e0       	ldi	r24, 0x00	; 0
    3ab8:	90 e0       	ldi	r25, 0x00	; 0

}
    3aba:	28 96       	adiw	r28, 0x08	; 8
    3abc:	0f b6       	in	r0, 0x3f	; 63
    3abe:	f8 94       	cli
    3ac0:	de bf       	out	0x3e, r29	; 62
    3ac2:	0f be       	out	0x3f, r0	; 63
    3ac4:	cd bf       	out	0x3d, r28	; 61
    3ac6:	df 91       	pop	r29
    3ac8:	cf 91       	pop	r28
    3aca:	08 95       	ret

00003acc <waitForAck>:

char waitForAck(){
    3acc:	cf 93       	push	r28
    3ace:	df 93       	push	r29
    3ad0:	1f 92       	push	r1
    3ad2:	1f 92       	push	r1
    3ad4:	cd b7       	in	r28, 0x3d	; 61
    3ad6:	de b7       	in	r29, 0x3e	; 62
    int timeout = 5000;
    3ad8:	88 e8       	ldi	r24, 0x88	; 136
    3ada:	93 e1       	ldi	r25, 0x13	; 19
    3adc:	9a 83       	std	Y+2, r25	; 0x02
    3ade:	89 83       	std	Y+1, r24	; 0x01
    while ( !(UCSR2A & (1<<RXC2)) ){
    3ae0:	0b c0       	rjmp	.+22     	; 0x3af8 <waitForAck+0x2c>
        timeout--;
    3ae2:	89 81       	ldd	r24, Y+1	; 0x01
    3ae4:	9a 81       	ldd	r25, Y+2	; 0x02
    3ae6:	01 97       	sbiw	r24, 0x01	; 1
    3ae8:	9a 83       	std	Y+2, r25	; 0x02
    3aea:	89 83       	std	Y+1, r24	; 0x01
        if(!timeout){
    3aec:	89 81       	ldd	r24, Y+1	; 0x01
    3aee:	9a 81       	ldd	r25, Y+2	; 0x02
    3af0:	00 97       	sbiw	r24, 0x00	; 0
    3af2:	11 f4       	brne	.+4      	; 0x3af8 <waitForAck+0x2c>
            return -1;
    3af4:	8f ef       	ldi	r24, 0xFF	; 255
    3af6:	0f c0       	rjmp	.+30     	; 0x3b16 <waitForAck+0x4a>

}

char waitForAck(){
    int timeout = 5000;
    while ( !(UCSR2A & (1<<RXC2)) ){
    3af8:	80 ed       	ldi	r24, 0xD0	; 208
    3afa:	90 e0       	ldi	r25, 0x00	; 0
    3afc:	fc 01       	movw	r30, r24
    3afe:	80 81       	ld	r24, Z
    3b00:	88 23       	and	r24, r24
    3b02:	7c f7       	brge	.-34     	; 0x3ae2 <waitForAck+0x16>
        timeout--;
        if(!timeout){
            return -1;
        }
    }
    if(UDR2 == ACK_BYTE){
    3b04:	86 ed       	ldi	r24, 0xD6	; 214
    3b06:	90 e0       	ldi	r25, 0x00	; 0
    3b08:	fc 01       	movw	r30, r24
    3b0a:	80 81       	ld	r24, Z
    3b0c:	80 38       	cpi	r24, 0x80	; 128
    3b0e:	11 f4       	brne	.+4      	; 0x3b14 <waitForAck+0x48>
        return 1;
    3b10:	81 e0       	ldi	r24, 0x01	; 1
    3b12:	01 c0       	rjmp	.+2      	; 0x3b16 <waitForAck+0x4a>
    } else {
        return 0;
    3b14:	80 e0       	ldi	r24, 0x00	; 0
    }
}
    3b16:	0f 90       	pop	r0
    3b18:	0f 90       	pop	r0
    3b1a:	df 91       	pop	r29
    3b1c:	cf 91       	pop	r28
    3b1e:	08 95       	ret

00003b20 <calcChecksum>:

uint8_t calcChecksum(uint8_t* buffer,uint8_t size){
    3b20:	cf 93       	push	r28
    3b22:	df 93       	push	r29
    3b24:	00 d0       	rcall	.+0      	; 0x3b26 <calcChecksum+0x6>
    3b26:	00 d0       	rcall	.+0      	; 0x3b28 <calcChecksum+0x8>
    3b28:	cd b7       	in	r28, 0x3d	; 61
    3b2a:	de b7       	in	r29, 0x3e	; 62
    3b2c:	9d 83       	std	Y+5, r25	; 0x05
    3b2e:	8c 83       	std	Y+4, r24	; 0x04
    3b30:	6e 83       	std	Y+6, r22	; 0x06
    uint8_t checksum = 0;
    3b32:	19 82       	std	Y+1, r1	; 0x01
    for(int i = 0; i < size; i++) {
    3b34:	1b 82       	std	Y+3, r1	; 0x03
    3b36:	1a 82       	std	Y+2, r1	; 0x02
    3b38:	11 c0       	rjmp	.+34     	; 0x3b5c <calcChecksum+0x3c>
        checksum += *(buffer++);
    3b3a:	8c 81       	ldd	r24, Y+4	; 0x04
    3b3c:	9d 81       	ldd	r25, Y+5	; 0x05
    3b3e:	9c 01       	movw	r18, r24
    3b40:	2f 5f       	subi	r18, 0xFF	; 255
    3b42:	3f 4f       	sbci	r19, 0xFF	; 255
    3b44:	3d 83       	std	Y+5, r19	; 0x05
    3b46:	2c 83       	std	Y+4, r18	; 0x04
    3b48:	fc 01       	movw	r30, r24
    3b4a:	80 81       	ld	r24, Z
    3b4c:	99 81       	ldd	r25, Y+1	; 0x01
    3b4e:	89 0f       	add	r24, r25
    3b50:	89 83       	std	Y+1, r24	; 0x01
    }
}

uint8_t calcChecksum(uint8_t* buffer,uint8_t size){
    uint8_t checksum = 0;
    for(int i = 0; i < size; i++) {
    3b52:	8a 81       	ldd	r24, Y+2	; 0x02
    3b54:	9b 81       	ldd	r25, Y+3	; 0x03
    3b56:	01 96       	adiw	r24, 0x01	; 1
    3b58:	9b 83       	std	Y+3, r25	; 0x03
    3b5a:	8a 83       	std	Y+2, r24	; 0x02
    3b5c:	8e 81       	ldd	r24, Y+6	; 0x06
    3b5e:	28 2f       	mov	r18, r24
    3b60:	30 e0       	ldi	r19, 0x00	; 0
    3b62:	8a 81       	ldd	r24, Y+2	; 0x02
    3b64:	9b 81       	ldd	r25, Y+3	; 0x03
    3b66:	82 17       	cp	r24, r18
    3b68:	93 07       	cpc	r25, r19
    3b6a:	3c f3       	brlt	.-50     	; 0x3b3a <calcChecksum+0x1a>
        checksum += *(buffer++);
    }
    return checksum;
    3b6c:	89 81       	ldd	r24, Y+1	; 0x01
}
    3b6e:	26 96       	adiw	r28, 0x06	; 6
    3b70:	0f b6       	in	r0, 0x3f	; 63
    3b72:	f8 94       	cli
    3b74:	de bf       	out	0x3e, r29	; 62
    3b76:	0f be       	out	0x3f, r0	; 63
    3b78:	cd bf       	out	0x3d, r28	; 61
    3b7a:	df 91       	pop	r29
    3b7c:	cf 91       	pop	r28
    3b7e:	08 95       	ret

00003b80 <commandIntegCheck>:
#include "protocol.h"
#include "Components/Sonar/Sonar.h"


//function to CRC the command structure
char commandIntegCheck(Command *command) {
    3b80:	cf 93       	push	r28
    3b82:	df 93       	push	r29
    3b84:	1f 92       	push	r1
    3b86:	1f 92       	push	r1
    3b88:	cd b7       	in	r28, 0x3d	; 61
    3b8a:	de b7       	in	r29, 0x3e	; 62
    3b8c:	9a 83       	std	Y+2, r25	; 0x02
    3b8e:	89 83       	std	Y+1, r24	; 0x01
   //CRC the command with 0x00 in place of the CRC
   //return success for now
   return 1;
    3b90:	81 e0       	ldi	r24, 0x01	; 1
}
    3b92:	0f 90       	pop	r0
    3b94:	0f 90       	pop	r0
    3b96:	df 91       	pop	r29
    3b98:	cf 91       	pop	r28
    3b9a:	08 95       	ret

00003b9c <processUltrasonicCommand>:

char processUltrasonicCommand(char commandCode, void* commandData,char* size, void* responseData) {
    3b9c:	cf 93       	push	r28
    3b9e:	df 93       	push	r29
    3ba0:	cd b7       	in	r28, 0x3d	; 61
    3ba2:	de b7       	in	r29, 0x3e	; 62
    3ba4:	27 97       	sbiw	r28, 0x07	; 7
    3ba6:	0f b6       	in	r0, 0x3f	; 63
    3ba8:	f8 94       	cli
    3baa:	de bf       	out	0x3e, r29	; 62
    3bac:	0f be       	out	0x3f, r0	; 63
    3bae:	cd bf       	out	0x3d, r28	; 61
    3bb0:	89 83       	std	Y+1, r24	; 0x01
    3bb2:	7b 83       	std	Y+3, r23	; 0x03
    3bb4:	6a 83       	std	Y+2, r22	; 0x02
    3bb6:	5d 83       	std	Y+5, r21	; 0x05
    3bb8:	4c 83       	std	Y+4, r20	; 0x04
    3bba:	3f 83       	std	Y+7, r19	; 0x07
    3bbc:	2e 83       	std	Y+6, r18	; 0x06
   switch(commandCode) {
    3bbe:	89 81       	ldd	r24, Y+1	; 0x01
    3bc0:	99 27       	eor	r25, r25
    3bc2:	87 fd       	sbrc	r24, 7
    3bc4:	90 95       	com	r25
    3bc6:	82 30       	cpi	r24, 0x02	; 2
    3bc8:	91 05       	cpc	r25, r1
    3bca:	81 f0       	breq	.+32     	; 0x3bec <processUltrasonicCommand+0x50>
    3bcc:	83 30       	cpi	r24, 0x03	; 3
    3bce:	91 05       	cpc	r25, r1
    3bd0:	c1 f0       	breq	.+48     	; 0x3c02 <processUltrasonicCommand+0x66>
    3bd2:	81 30       	cpi	r24, 0x01	; 1
    3bd4:	91 05       	cpc	r25, r1
    3bd6:	01 f5       	brne	.+64     	; 0x3c18 <processUltrasonicCommand+0x7c>
      case GET_ALL_SENSORS:
         getAllSensors((int*) responseData);
    3bd8:	8e 81       	ldd	r24, Y+6	; 0x06
    3bda:	9f 81       	ldd	r25, Y+7	; 0x07
    3bdc:	0e 94 57 21 	call	0x42ae	; 0x42ae <getAllSensors>
         *size = 12;
    3be0:	8c 81       	ldd	r24, Y+4	; 0x04
    3be2:	9d 81       	ldd	r25, Y+5	; 0x05
    3be4:	2c e0       	ldi	r18, 0x0C	; 12
    3be6:	fc 01       	movw	r30, r24
    3be8:	20 83       	st	Z, r18
         break;
    3bea:	16 c0       	rjmp	.+44     	; 0x3c18 <processUltrasonicCommand+0x7c>
      case GET_CERTAIN_SENSORS:
         getCertainSensor(((char*)commandData)[0], (int*) responseData);
    3bec:	8a 81       	ldd	r24, Y+2	; 0x02
    3bee:	9b 81       	ldd	r25, Y+3	; 0x03
    3bf0:	fc 01       	movw	r30, r24
    3bf2:	20 81       	ld	r18, Z
    3bf4:	8e 81       	ldd	r24, Y+6	; 0x06
    3bf6:	9f 81       	ldd	r25, Y+7	; 0x07
    3bf8:	bc 01       	movw	r22, r24
    3bfa:	82 2f       	mov	r24, r18
    3bfc:	0e 94 82 21 	call	0x4304	; 0x4304 <getCertainSensor>
         break;
    3c00:	0b c0       	rjmp	.+22     	; 0x3c18 <processUltrasonicCommand+0x7c>
      case GET_SENSOR_GROUP:
         getSensorGroup(((char*)commandData)[0], (int*) responseData);
    3c02:	8a 81       	ldd	r24, Y+2	; 0x02
    3c04:	9b 81       	ldd	r25, Y+3	; 0x03
    3c06:	fc 01       	movw	r30, r24
    3c08:	20 81       	ld	r18, Z
    3c0a:	8e 81       	ldd	r24, Y+6	; 0x06
    3c0c:	9f 81       	ldd	r25, Y+7	; 0x07
    3c0e:	bc 01       	movw	r22, r24
    3c10:	82 2f       	mov	r24, r18
    3c12:	0e 94 ad 21 	call	0x435a	; 0x435a <getSensorGroup>
         break;
    3c16:	00 00       	nop
   }
   //return success for now...
   return 1;
    3c18:	81 e0       	ldi	r24, 0x01	; 1
}
    3c1a:	27 96       	adiw	r28, 0x07	; 7
    3c1c:	0f b6       	in	r0, 0x3f	; 63
    3c1e:	f8 94       	cli
    3c20:	de bf       	out	0x3e, r29	; 62
    3c22:	0f be       	out	0x3f, r0	; 63
    3c24:	cd bf       	out	0x3d, r28	; 61
    3c26:	df 91       	pop	r29
    3c28:	cf 91       	pop	r28
    3c2a:	08 95       	ret

00003c2c <processSpeedCommand>:

char processSpeedCommand(char commandCode, void* commandData, void* responseData) {
    3c2c:	cf 93       	push	r28
    3c2e:	df 93       	push	r29
    3c30:	00 d0       	rcall	.+0      	; 0x3c32 <processSpeedCommand+0x6>
    3c32:	1f 92       	push	r1
    3c34:	1f 92       	push	r1
    3c36:	cd b7       	in	r28, 0x3d	; 61
    3c38:	de b7       	in	r29, 0x3e	; 62
    3c3a:	89 83       	std	Y+1, r24	; 0x01
    3c3c:	7b 83       	std	Y+3, r23	; 0x03
    3c3e:	6a 83       	std	Y+2, r22	; 0x02
    3c40:	5d 83       	std	Y+5, r21	; 0x05
    3c42:	4c 83       	std	Y+4, r20	; 0x04
   switch(commandCode) {
    3c44:	89 81       	ldd	r24, Y+1	; 0x01
    3c46:	99 27       	eor	r25, r25
    3c48:	87 fd       	sbrc	r24, 7
    3c4a:	90 95       	com	r25
    3c4c:	00 97       	sbiw	r24, 0x00	; 0
    3c4e:	21 f0       	breq	.+8      	; 0x3c58 <processSpeedCommand+0x2c>
    3c50:	81 30       	cpi	r24, 0x01	; 1
    3c52:	91 05       	cpc	r25, r1
    3c54:	31 f0       	breq	.+12     	; 0x3c62 <processSpeedCommand+0x36>
    3c56:	0f c0       	rjmp	.+30     	; 0x3c76 <processSpeedCommand+0x4a>
      case GET_SPEED:
         getSpeed((char*) responseData);
    3c58:	8c 81       	ldd	r24, Y+4	; 0x04
    3c5a:	9d 81       	ldd	r25, Y+5	; 0x05
    3c5c:	0e 94 55 22 	call	0x44aa	; 0x44aa <getSpeed>
         break;
    3c60:	0a c0       	rjmp	.+20     	; 0x3c76 <processSpeedCommand+0x4a>
      case SET_SPEED:
         setSpeed(((char*)commandData)[0]);
    3c62:	8a 81       	ldd	r24, Y+2	; 0x02
    3c64:	9b 81       	ldd	r25, Y+3	; 0x03
    3c66:	fc 01       	movw	r30, r24
    3c68:	80 81       	ld	r24, Z
    3c6a:	99 27       	eor	r25, r25
    3c6c:	87 fd       	sbrc	r24, 7
    3c6e:	90 95       	com	r25
    3c70:	0e 94 67 22 	call	0x44ce	; 0x44ce <setSpeed>
         break;
    3c74:	00 00       	nop
   }
   //return success for now
   return 1;
    3c76:	81 e0       	ldi	r24, 0x01	; 1
}
    3c78:	0f 90       	pop	r0
    3c7a:	0f 90       	pop	r0
    3c7c:	0f 90       	pop	r0
    3c7e:	0f 90       	pop	r0
    3c80:	0f 90       	pop	r0
    3c82:	df 91       	pop	r29
    3c84:	cf 91       	pop	r28
    3c86:	08 95       	ret

00003c88 <processSteeringCommand>:

char processSteeringCommand(char commandCode, void* commandData, void* responseData) {
    3c88:	cf 93       	push	r28
    3c8a:	df 93       	push	r29
    3c8c:	00 d0       	rcall	.+0      	; 0x3c8e <processSteeringCommand+0x6>
    3c8e:	1f 92       	push	r1
    3c90:	1f 92       	push	r1
    3c92:	cd b7       	in	r28, 0x3d	; 61
    3c94:	de b7       	in	r29, 0x3e	; 62
    3c96:	89 83       	std	Y+1, r24	; 0x01
    3c98:	7b 83       	std	Y+3, r23	; 0x03
    3c9a:	6a 83       	std	Y+2, r22	; 0x02
    3c9c:	5d 83       	std	Y+5, r21	; 0x05
    3c9e:	4c 83       	std	Y+4, r20	; 0x04
   switch(commandCode) {
    3ca0:	89 81       	ldd	r24, Y+1	; 0x01
    3ca2:	99 27       	eor	r25, r25
    3ca4:	87 fd       	sbrc	r24, 7
    3ca6:	90 95       	com	r25
    3ca8:	82 30       	cpi	r24, 0x02	; 2
    3caa:	91 05       	cpc	r25, r1
    3cac:	f9 f0       	breq	.+62     	; 0x3cec <processSteeringCommand+0x64>
    3cae:	83 30       	cpi	r24, 0x03	; 3
    3cb0:	91 05       	cpc	r25, r1
    3cb2:	34 f4       	brge	.+12     	; 0x3cc0 <processSteeringCommand+0x38>
    3cb4:	00 97       	sbiw	r24, 0x00	; 0
    3cb6:	59 f0       	breq	.+22     	; 0x3cce <processSteeringCommand+0x46>
    3cb8:	81 30       	cpi	r24, 0x01	; 1
    3cba:	91 05       	cpc	r25, r1
    3cbc:	91 f0       	breq	.+36     	; 0x3ce2 <processSteeringCommand+0x5a>
    3cbe:	4c c0       	rjmp	.+152    	; 0x3d58 <processSteeringCommand+0xd0>
    3cc0:	83 30       	cpi	r24, 0x03	; 3
    3cc2:	91 05       	cpc	r25, r1
    3cc4:	c1 f0       	breq	.+48     	; 0x3cf6 <processSteeringCommand+0x6e>
    3cc6:	84 30       	cpi	r24, 0x04	; 4
    3cc8:	91 05       	cpc	r25, r1
    3cca:	91 f1       	breq	.+100    	; 0x3d30 <processSteeringCommand+0xa8>
    3ccc:	45 c0       	rjmp	.+138    	; 0x3d58 <processSteeringCommand+0xd0>
      case SET_ANGLE:
         setAngle(*((char*)commandData));
    3cce:	8a 81       	ldd	r24, Y+2	; 0x02
    3cd0:	9b 81       	ldd	r25, Y+3	; 0x03
    3cd2:	fc 01       	movw	r30, r24
    3cd4:	80 81       	ld	r24, Z
    3cd6:	99 27       	eor	r25, r25
    3cd8:	87 fd       	sbrc	r24, 7
    3cda:	90 95       	com	r25
    3cdc:	0e 94 72 22 	call	0x44e4	; 0x44e4 <setAngle>
         break;
    3ce0:	3b c0       	rjmp	.+118    	; 0x3d58 <processSteeringCommand+0xd0>
      case GET_ANGLE:
         getAngle((char*) responseData);
    3ce2:	8c 81       	ldd	r24, Y+4	; 0x04
    3ce4:	9d 81       	ldd	r25, Y+5	; 0x05
    3ce6:	0e 94 7d 22 	call	0x44fa	; 0x44fa <getAngle>
         break;
    3cea:	36 c0       	rjmp	.+108    	; 0x3d58 <processSteeringCommand+0xd0>
      case GET_DESIRED_ANGLE:
         getDesiredAngle((char*) responseData);
    3cec:	8c 81       	ldd	r24, Y+4	; 0x04
    3cee:	9d 81       	ldd	r25, Y+5	; 0x05
    3cf0:	0e 94 8f 22 	call	0x451e	; 0x451e <getDesiredAngle>
         break;
    3cf4:	31 c0       	rjmp	.+98     	; 0x3d58 <processSteeringCommand+0xd0>
      case CHANGE_PID:
         changePID(((char*)commandData)[0], ((char*)commandData)[1], ((char*)commandData)[2]);
    3cf6:	8a 81       	ldd	r24, Y+2	; 0x02
    3cf8:	9b 81       	ldd	r25, Y+3	; 0x03
    3cfa:	02 96       	adiw	r24, 0x02	; 2
    3cfc:	fc 01       	movw	r30, r24
    3cfe:	80 81       	ld	r24, Z
    3d00:	48 2f       	mov	r20, r24
    3d02:	55 27       	eor	r21, r21
    3d04:	47 fd       	sbrc	r20, 7
    3d06:	50 95       	com	r21
    3d08:	8a 81       	ldd	r24, Y+2	; 0x02
    3d0a:	9b 81       	ldd	r25, Y+3	; 0x03
    3d0c:	01 96       	adiw	r24, 0x01	; 1
    3d0e:	fc 01       	movw	r30, r24
    3d10:	80 81       	ld	r24, Z
    3d12:	28 2f       	mov	r18, r24
    3d14:	33 27       	eor	r19, r19
    3d16:	27 fd       	sbrc	r18, 7
    3d18:	30 95       	com	r19
    3d1a:	8a 81       	ldd	r24, Y+2	; 0x02
    3d1c:	9b 81       	ldd	r25, Y+3	; 0x03
    3d1e:	fc 01       	movw	r30, r24
    3d20:	80 81       	ld	r24, Z
    3d22:	99 27       	eor	r25, r25
    3d24:	87 fd       	sbrc	r24, 7
    3d26:	90 95       	com	r25
    3d28:	b9 01       	movw	r22, r18
    3d2a:	0e 94 a1 22 	call	0x4542	; 0x4542 <changePID>
         break;
    3d2e:	14 c0       	rjmp	.+40     	; 0x3d58 <processSteeringCommand+0xd0>
      case SET_LIMITS:
         setLimits(((char*)commandData)[0], ((char*)commandData)[1]);
    3d30:	8a 81       	ldd	r24, Y+2	; 0x02
    3d32:	9b 81       	ldd	r25, Y+3	; 0x03
    3d34:	01 96       	adiw	r24, 0x01	; 1
    3d36:	fc 01       	movw	r30, r24
    3d38:	80 81       	ld	r24, Z
    3d3a:	28 2f       	mov	r18, r24
    3d3c:	33 27       	eor	r19, r19
    3d3e:	27 fd       	sbrc	r18, 7
    3d40:	30 95       	com	r19
    3d42:	8a 81       	ldd	r24, Y+2	; 0x02
    3d44:	9b 81       	ldd	r25, Y+3	; 0x03
    3d46:	fc 01       	movw	r30, r24
    3d48:	80 81       	ld	r24, Z
    3d4a:	99 27       	eor	r25, r25
    3d4c:	87 fd       	sbrc	r24, 7
    3d4e:	90 95       	com	r25
    3d50:	b9 01       	movw	r22, r18
    3d52:	0e 94 b0 22 	call	0x4560	; 0x4560 <setLimits>
         break;
    3d56:	00 00       	nop
   }
   //return success for now
   return 1;
    3d58:	81 e0       	ldi	r24, 0x01	; 1
}
    3d5a:	0f 90       	pop	r0
    3d5c:	0f 90       	pop	r0
    3d5e:	0f 90       	pop	r0
    3d60:	0f 90       	pop	r0
    3d62:	0f 90       	pop	r0
    3d64:	df 91       	pop	r29
    3d66:	cf 91       	pop	r28
    3d68:	08 95       	ret

00003d6a <processFNRCommand>:

char processFNRCommand(char commandCode, void* commandData, void* responseData) {
    3d6a:	cf 93       	push	r28
    3d6c:	df 93       	push	r29
    3d6e:	00 d0       	rcall	.+0      	; 0x3d70 <processFNRCommand+0x6>
    3d70:	1f 92       	push	r1
    3d72:	1f 92       	push	r1
    3d74:	cd b7       	in	r28, 0x3d	; 61
    3d76:	de b7       	in	r29, 0x3e	; 62
    3d78:	89 83       	std	Y+1, r24	; 0x01
    3d7a:	7b 83       	std	Y+3, r23	; 0x03
    3d7c:	6a 83       	std	Y+2, r22	; 0x02
    3d7e:	5d 83       	std	Y+5, r21	; 0x05
    3d80:	4c 83       	std	Y+4, r20	; 0x04
   switch(commandCode) {
    3d82:	89 81       	ldd	r24, Y+1	; 0x01
    3d84:	99 27       	eor	r25, r25
    3d86:	87 fd       	sbrc	r24, 7
    3d88:	90 95       	com	r25
    3d8a:	00 97       	sbiw	r24, 0x00	; 0
    3d8c:	21 f0       	breq	.+8      	; 0x3d96 <processFNRCommand+0x2c>
    3d8e:	81 30       	cpi	r24, 0x01	; 1
    3d90:	91 05       	cpc	r25, r1
    3d92:	59 f0       	breq	.+22     	; 0x3daa <processFNRCommand+0x40>
    3d94:	0f c0       	rjmp	.+30     	; 0x3db4 <processFNRCommand+0x4a>
      case SET_FNR:
         setFNR(*((char*)commandData));
    3d96:	8a 81       	ldd	r24, Y+2	; 0x02
    3d98:	9b 81       	ldd	r25, Y+3	; 0x03
    3d9a:	fc 01       	movw	r30, r24
    3d9c:	80 81       	ld	r24, Z
    3d9e:	99 27       	eor	r25, r25
    3da0:	87 fd       	sbrc	r24, 7
    3da2:	90 95       	com	r25
    3da4:	0e 94 fc 1f 	call	0x3ff8	; 0x3ff8 <setFNR>
         break;
    3da8:	05 c0       	rjmp	.+10     	; 0x3db4 <processFNRCommand+0x4a>
      case GET_FNR:
         getFNR((char*) responseData);
    3daa:	8c 81       	ldd	r24, Y+4	; 0x04
    3dac:	9d 81       	ldd	r25, Y+5	; 0x05
    3dae:	0e 94 07 20 	call	0x400e	; 0x400e <getFNR>
         break;
    3db2:	00 00       	nop
   }
}
    3db4:	0f 90       	pop	r0
    3db6:	0f 90       	pop	r0
    3db8:	0f 90       	pop	r0
    3dba:	0f 90       	pop	r0
    3dbc:	0f 90       	pop	r0
    3dbe:	df 91       	pop	r29
    3dc0:	cf 91       	pop	r28
    3dc2:	08 95       	ret

00003dc4 <processBrakeCommand>:

char processBrakeCommand(char commandCode, void* commandData, void* responseData) {
    3dc4:	cf 93       	push	r28
    3dc6:	df 93       	push	r29
    3dc8:	00 d0       	rcall	.+0      	; 0x3dca <processBrakeCommand+0x6>
    3dca:	1f 92       	push	r1
    3dcc:	1f 92       	push	r1
    3dce:	cd b7       	in	r28, 0x3d	; 61
    3dd0:	de b7       	in	r29, 0x3e	; 62
    3dd2:	89 83       	std	Y+1, r24	; 0x01
    3dd4:	7b 83       	std	Y+3, r23	; 0x03
    3dd6:	6a 83       	std	Y+2, r22	; 0x02
    3dd8:	5d 83       	std	Y+5, r21	; 0x05
    3dda:	4c 83       	std	Y+4, r20	; 0x04
   switch(commandCode) {
    3ddc:	89 81       	ldd	r24, Y+1	; 0x01
    3dde:	99 27       	eor	r25, r25
    3de0:	87 fd       	sbrc	r24, 7
    3de2:	90 95       	com	r25
    3de4:	00 97       	sbiw	r24, 0x00	; 0
    3de6:	21 f0       	breq	.+8      	; 0x3df0 <processBrakeCommand+0x2c>
    3de8:	81 30       	cpi	r24, 0x01	; 1
    3dea:	91 05       	cpc	r25, r1
    3dec:	59 f0       	breq	.+22     	; 0x3e04 <processBrakeCommand+0x40>
    3dee:	0f c0       	rjmp	.+30     	; 0x3e0e <processBrakeCommand+0x4a>
      case SET_BRAKE:
	 setBrake(*((char*)commandData));
    3df0:	8a 81       	ldd	r24, Y+2	; 0x02
    3df2:	9b 81       	ldd	r25, Y+3	; 0x03
    3df4:	fc 01       	movw	r30, r24
    3df6:	80 81       	ld	r24, Z
    3df8:	99 27       	eor	r25, r25
    3dfa:	87 fd       	sbrc	r24, 7
    3dfc:	90 95       	com	r25
    3dfe:	0e 94 df 1f 	call	0x3fbe	; 0x3fbe <setBrake>
	 break;
    3e02:	05 c0       	rjmp	.+10     	; 0x3e0e <processBrakeCommand+0x4a>
      case GET_BRAKE:
	 getBrake((char*) responseData);
    3e04:	8c 81       	ldd	r24, Y+4	; 0x04
    3e06:	9d 81       	ldd	r25, Y+5	; 0x05
    3e08:	0e 94 ea 1f 	call	0x3fd4	; 0x3fd4 <getBrake>
	 break; 
    3e0c:	00 00       	nop
   }
}
    3e0e:	0f 90       	pop	r0
    3e10:	0f 90       	pop	r0
    3e12:	0f 90       	pop	r0
    3e14:	0f 90       	pop	r0
    3e16:	0f 90       	pop	r0
    3e18:	df 91       	pop	r29
    3e1a:	cf 91       	pop	r28
    3e1c:	08 95       	ret

00003e1e <processBatteryCommand>:

char processBatteryCommand(char commandCode, void* commandData, void* responseData) {
    3e1e:	cf 93       	push	r28
    3e20:	df 93       	push	r29
    3e22:	00 d0       	rcall	.+0      	; 0x3e24 <processBatteryCommand+0x6>
    3e24:	1f 92       	push	r1
    3e26:	1f 92       	push	r1
    3e28:	cd b7       	in	r28, 0x3d	; 61
    3e2a:	de b7       	in	r29, 0x3e	; 62
    3e2c:	89 83       	std	Y+1, r24	; 0x01
    3e2e:	7b 83       	std	Y+3, r23	; 0x03
    3e30:	6a 83       	std	Y+2, r22	; 0x02
    3e32:	5d 83       	std	Y+5, r21	; 0x05
    3e34:	4c 83       	std	Y+4, r20	; 0x04
   switch(commandCode) {
    3e36:	89 81       	ldd	r24, Y+1	; 0x01
    3e38:	99 27       	eor	r25, r25
    3e3a:	87 fd       	sbrc	r24, 7
    3e3c:	90 95       	com	r25
    3e3e:	00 97       	sbiw	r24, 0x00	; 0
    3e40:	21 f0       	breq	.+8      	; 0x3e4a <processBatteryCommand+0x2c>
    3e42:	81 30       	cpi	r24, 0x01	; 1
    3e44:	91 05       	cpc	r25, r1
    3e46:	31 f0       	breq	.+12     	; 0x3e54 <processBatteryCommand+0x36>
    3e48:	0a c0       	rjmp	.+20     	; 0x3e5e <processBatteryCommand+0x40>
      case GET_BATTERY_VOLTAGE:
         getBatteryVoltage((char*) responseData);
    3e4a:	8c 81       	ldd	r24, Y+4	; 0x04
    3e4c:	9d 81       	ldd	r25, Y+5	; 0x05
    3e4e:	0e 94 bb 1f 	call	0x3f76	; 0x3f76 <getBatteryVoltage>
         break;
    3e52:	05 c0       	rjmp	.+10     	; 0x3e5e <processBatteryCommand+0x40>
      case GET_STEERING_VOLTAGE:
         getSteeringVoltage((char*) responseData);
    3e54:	8c 81       	ldd	r24, Y+4	; 0x04
    3e56:	9d 81       	ldd	r25, Y+5	; 0x05
    3e58:	0e 94 cd 1f 	call	0x3f9a	; 0x3f9a <getSteeringVoltage>
         break;
    3e5c:	00 00       	nop
   }
}
    3e5e:	0f 90       	pop	r0
    3e60:	0f 90       	pop	r0
    3e62:	0f 90       	pop	r0
    3e64:	0f 90       	pop	r0
    3e66:	0f 90       	pop	r0
    3e68:	df 91       	pop	r29
    3e6a:	cf 91       	pop	r28
    3e6c:	08 95       	ret

00003e6e <processLightCommand>:

char processLightCommand(char commandCode, void* commandData, Response* responseData) {
    3e6e:	cf 93       	push	r28
    3e70:	df 93       	push	r29
    3e72:	00 d0       	rcall	.+0      	; 0x3e74 <processLightCommand+0x6>
    3e74:	1f 92       	push	r1
    3e76:	1f 92       	push	r1
    3e78:	cd b7       	in	r28, 0x3d	; 61
    3e7a:	de b7       	in	r29, 0x3e	; 62
    3e7c:	89 83       	std	Y+1, r24	; 0x01
    3e7e:	7b 83       	std	Y+3, r23	; 0x03
    3e80:	6a 83       	std	Y+2, r22	; 0x02
    3e82:	5d 83       	std	Y+5, r21	; 0x05
    3e84:	4c 83       	std	Y+4, r20	; 0x04
	responseData->size = 0;
    3e86:	8c 81       	ldd	r24, Y+4	; 0x04
    3e88:	9d 81       	ldd	r25, Y+5	; 0x05
    3e8a:	fc 01       	movw	r30, r24
    3e8c:	11 82       	std	Z+1, r1	; 0x01
   switch(commandCode) {
    3e8e:	89 81       	ldd	r24, Y+1	; 0x01
    3e90:	99 27       	eor	r25, r25
    3e92:	87 fd       	sbrc	r24, 7
    3e94:	90 95       	com	r25
    3e96:	00 97       	sbiw	r24, 0x00	; 0
    3e98:	51 f4       	brne	.+20     	; 0x3eae <processLightCommand+0x40>
   case SET_LIGHT:
	 	setLight(*((char*)commandData));
    3e9a:	8a 81       	ldd	r24, Y+2	; 0x02
    3e9c:	9b 81       	ldd	r25, Y+3	; 0x03
    3e9e:	fc 01       	movw	r30, r24
    3ea0:	80 81       	ld	r24, Z
    3ea2:	99 27       	eor	r25, r25
    3ea4:	87 fd       	sbrc	r24, 7
    3ea6:	90 95       	com	r25
    3ea8:	0e 94 19 20 	call	0x4032	; 0x4032 <setLight>
      break;
    3eac:	00 00       	nop
   }
}
    3eae:	0f 90       	pop	r0
    3eb0:	0f 90       	pop	r0
    3eb2:	0f 90       	pop	r0
    3eb4:	0f 90       	pop	r0
    3eb6:	0f 90       	pop	r0
    3eb8:	df 91       	pop	r29
    3eba:	cf 91       	pop	r28
    3ebc:	08 95       	ret

00003ebe <processCommand>:



//Function that will take in a command (as char array) and process it into a
//correct response to be stored into response
char processCommand(Command *command, Response *response) {
    3ebe:	cf 93       	push	r28
    3ec0:	df 93       	push	r29
    3ec2:	00 d0       	rcall	.+0      	; 0x3ec4 <processCommand+0x6>
    3ec4:	1f 92       	push	r1
    3ec6:	cd b7       	in	r28, 0x3d	; 61
    3ec8:	de b7       	in	r29, 0x3e	; 62
    3eca:	9a 83       	std	Y+2, r25	; 0x02
    3ecc:	89 83       	std	Y+1, r24	; 0x01
    3ece:	7c 83       	std	Y+4, r23	; 0x04
    3ed0:	6b 83       	std	Y+3, r22	; 0x03
	response->commandBack = command->cmd;
    3ed2:	89 81       	ldd	r24, Y+1	; 0x01
    3ed4:	9a 81       	ldd	r25, Y+2	; 0x02
    3ed6:	dc 01       	movw	r26, r24
    3ed8:	11 96       	adiw	r26, 0x01	; 1
    3eda:	2c 91       	ld	r18, X
    3edc:	8b 81       	ldd	r24, Y+3	; 0x03
    3ede:	9c 81       	ldd	r25, Y+4	; 0x04
    3ee0:	fc 01       	movw	r30, r24
    3ee2:	20 83       	st	Z, r18
   switch(command->groupID) {
    3ee4:	89 81       	ldd	r24, Y+1	; 0x01
    3ee6:	9a 81       	ldd	r25, Y+2	; 0x02
    3ee8:	dc 01       	movw	r26, r24
    3eea:	8c 91       	ld	r24, X
    3eec:	99 27       	eor	r25, r25
    3eee:	87 fd       	sbrc	r24, 7
    3ef0:	90 95       	com	r25
    3ef2:	aa 27       	eor	r26, r26
    3ef4:	97 fd       	sbrc	r25, 7
    3ef6:	a0 95       	com	r26
    3ef8:	ba 2f       	mov	r27, r26
    3efa:	41 e0       	ldi	r20, 0x01	; 1
    3efc:	50 e0       	ldi	r21, 0x00	; 0
    3efe:	27 e0       	ldi	r18, 0x07	; 7
    3f00:	30 e0       	ldi	r19, 0x00	; 0
    3f02:	84 1b       	sub	r24, r20
    3f04:	95 0b       	sbc	r25, r21
    3f06:	28 17       	cp	r18, r24
    3f08:	39 07       	cpc	r19, r25
    3f0a:	68 f1       	brcs	.+90     	; 0x3f66 <processCommand+0xa8>
    3f0c:	8e 58       	subi	r24, 0x8E	; 142
    3f0e:	9f 4f       	sbci	r25, 0xFF	; 255
    3f10:	fc 01       	movw	r30, r24
    3f12:	0c 94 cc 23 	jmp	0x4798	; 0x4798 <__tablejump2__>
      case ULTRASONIC_GROUP:
         processUltrasonicCommand(command->cmd, command->payload,&response->size, response->payload);
    3f16:	8b 81       	ldd	r24, Y+3	; 0x03
    3f18:	9c 81       	ldd	r25, Y+4	; 0x04
    3f1a:	9c 01       	movw	r18, r24
    3f1c:	2e 5f       	subi	r18, 0xFE	; 254
    3f1e:	3f 4f       	sbci	r19, 0xFF	; 255
    3f20:	8b 81       	ldd	r24, Y+3	; 0x03
    3f22:	9c 81       	ldd	r25, Y+4	; 0x04
    3f24:	ac 01       	movw	r20, r24
    3f26:	4f 5f       	subi	r20, 0xFF	; 255
    3f28:	5f 4f       	sbci	r21, 0xFF	; 255
    3f2a:	89 81       	ldd	r24, Y+1	; 0x01
    3f2c:	9a 81       	ldd	r25, Y+2	; 0x02
    3f2e:	03 96       	adiw	r24, 0x03	; 3
    3f30:	69 81       	ldd	r22, Y+1	; 0x01
    3f32:	7a 81       	ldd	r23, Y+2	; 0x02
    3f34:	db 01       	movw	r26, r22
    3f36:	11 96       	adiw	r26, 0x01	; 1
    3f38:	ec 91       	ld	r30, X
    3f3a:	bc 01       	movw	r22, r24
    3f3c:	8e 2f       	mov	r24, r30
    3f3e:	0e 94 ce 1d 	call	0x3b9c	; 0x3b9c <processUltrasonicCommand>
         break;
    3f42:	11 c0       	rjmp	.+34     	; 0x3f66 <processCommand+0xa8>
         break;
      case BATTERY_GROUP:
         /*do battery things*/
         break;
      case LIGHTS_GROUP:
	      processLightCommand(command->cmd,command->payload,response);
    3f44:	89 81       	ldd	r24, Y+1	; 0x01
    3f46:	9a 81       	ldd	r25, Y+2	; 0x02
    3f48:	03 96       	adiw	r24, 0x03	; 3
    3f4a:	29 81       	ldd	r18, Y+1	; 0x01
    3f4c:	3a 81       	ldd	r19, Y+2	; 0x02
    3f4e:	d9 01       	movw	r26, r18
    3f50:	11 96       	adiw	r26, 0x01	; 1
    3f52:	ec 91       	ld	r30, X
    3f54:	2b 81       	ldd	r18, Y+3	; 0x03
    3f56:	3c 81       	ldd	r19, Y+4	; 0x04
    3f58:	a9 01       	movw	r20, r18
    3f5a:	bc 01       	movw	r22, r24
    3f5c:	8e 2f       	mov	r24, r30
    3f5e:	0e 94 37 1f 	call	0x3e6e	; 0x3e6e <processLightCommand>
         break;
    3f62:	01 c0       	rjmp	.+2      	; 0x3f66 <processCommand+0xa8>
      case ERROR_GROUP:
         /*do error things*/
         break;
    3f64:	00 00       	nop
   }
   //return a dummy success for now
   return 1;
    3f66:	81 e0       	ldi	r24, 0x01	; 1
}
    3f68:	0f 90       	pop	r0
    3f6a:	0f 90       	pop	r0
    3f6c:	0f 90       	pop	r0
    3f6e:	0f 90       	pop	r0
    3f70:	df 91       	pop	r29
    3f72:	cf 91       	pop	r28
    3f74:	08 95       	ret

00003f76 <getBatteryVoltage>:

//battery controller functions

//read battery strength in a char. Might need to be unsigned, specs don't say
//anything regarding that.
char getBatteryVoltage(char *sensorResponse) {
    3f76:	cf 93       	push	r28
    3f78:	df 93       	push	r29
    3f7a:	1f 92       	push	r1
    3f7c:	1f 92       	push	r1
    3f7e:	cd b7       	in	r28, 0x3d	; 61
    3f80:	de b7       	in	r29, 0x3e	; 62
    3f82:	9a 83       	std	Y+2, r25	; 0x02
    3f84:	89 83       	std	Y+1, r24	; 0x01
   //fake battery reading
   *sensorResponse = 0;
    3f86:	89 81       	ldd	r24, Y+1	; 0x01
    3f88:	9a 81       	ldd	r25, Y+2	; 0x02
    3f8a:	fc 01       	movw	r30, r24
    3f8c:	10 82       	st	Z, r1
   //return success
   return 1;
    3f8e:	81 e0       	ldi	r24, 0x01	; 1
}
    3f90:	0f 90       	pop	r0
    3f92:	0f 90       	pop	r0
    3f94:	df 91       	pop	r29
    3f96:	cf 91       	pop	r28
    3f98:	08 95       	ret

00003f9a <getSteeringVoltage>:

//gets voltage from steering?
char getSteeringVoltage(char *sensorResponse) {
    3f9a:	cf 93       	push	r28
    3f9c:	df 93       	push	r29
    3f9e:	1f 92       	push	r1
    3fa0:	1f 92       	push	r1
    3fa2:	cd b7       	in	r28, 0x3d	; 61
    3fa4:	de b7       	in	r29, 0x3e	; 62
    3fa6:	9a 83       	std	Y+2, r25	; 0x02
    3fa8:	89 83       	std	Y+1, r24	; 0x01
   //fake steering voltage reading
   *sensorResponse = 0;
    3faa:	89 81       	ldd	r24, Y+1	; 0x01
    3fac:	9a 81       	ldd	r25, Y+2	; 0x02
    3fae:	fc 01       	movw	r30, r24
    3fb0:	10 82       	st	Z, r1
   //return success
   return 1;
    3fb2:	81 e0       	ldi	r24, 0x01	; 1
}
    3fb4:	0f 90       	pop	r0
    3fb6:	0f 90       	pop	r0
    3fb8:	df 91       	pop	r29
    3fba:	cf 91       	pop	r28
    3fbc:	08 95       	ret

00003fbe <setBrake>:
//Brake controller functions. THERE IS CURRENTLY NO WAY TO GET THE DESIRED
//BRAKE TARGET IN THE SPECS

//set brake target
char setBrake(char gainTarget) {
    3fbe:	cf 93       	push	r28
    3fc0:	df 93       	push	r29
    3fc2:	1f 92       	push	r1
    3fc4:	cd b7       	in	r28, 0x3d	; 61
    3fc6:	de b7       	in	r29, 0x3e	; 62
    3fc8:	89 83       	std	Y+1, r24	; 0x01
   //dummy function, nothing happens
   //return success
   return 1;
    3fca:	81 e0       	ldi	r24, 0x01	; 1
}
    3fcc:	0f 90       	pop	r0
    3fce:	df 91       	pop	r29
    3fd0:	cf 91       	pop	r28
    3fd2:	08 95       	ret

00003fd4 <getBrake>:

//get what is assumed to be the current brake value?
char getBrake(char* sensorResponse) {
    3fd4:	cf 93       	push	r28
    3fd6:	df 93       	push	r29
    3fd8:	1f 92       	push	r1
    3fda:	1f 92       	push	r1
    3fdc:	cd b7       	in	r28, 0x3d	; 61
    3fde:	de b7       	in	r29, 0x3e	; 62
    3fe0:	9a 83       	std	Y+2, r25	; 0x02
    3fe2:	89 83       	std	Y+1, r24	; 0x01
   //fake brake reading
   *sensorResponse = 0;
    3fe4:	89 81       	ldd	r24, Y+1	; 0x01
    3fe6:	9a 81       	ldd	r25, Y+2	; 0x02
    3fe8:	fc 01       	movw	r30, r24
    3fea:	10 82       	st	Z, r1
   //return success
   return 1;
    3fec:	81 e0       	ldi	r24, 0x01	; 1
}
    3fee:	0f 90       	pop	r0
    3ff0:	0f 90       	pop	r0
    3ff2:	df 91       	pop	r29
    3ff4:	cf 91       	pop	r28
    3ff6:	08 95       	ret

00003ff8 <setFNR>:
//FNR controller functions
#include <avr/io.h>

//set the FNR controller, inputs are either -1, 0, or 1.
char setFNR(char FNR) {
    3ff8:	cf 93       	push	r28
    3ffa:	df 93       	push	r29
    3ffc:	1f 92       	push	r1
    3ffe:	cd b7       	in	r28, 0x3d	; 61
    4000:	de b7       	in	r29, 0x3e	; 62
    4002:	89 83       	std	Y+1, r24	; 0x01
   //dummy function, nothing happens
   //return success
   return 1;
    4004:	81 e0       	ldi	r24, 0x01	; 1
}
    4006:	0f 90       	pop	r0
    4008:	df 91       	pop	r29
    400a:	cf 91       	pop	r28
    400c:	08 95       	ret

0000400e <getFNR>:

//get the current FNR state. Function follows same format for consistancy
char getFNR(char *sensorResponse) {
    400e:	cf 93       	push	r28
    4010:	df 93       	push	r29
    4012:	1f 92       	push	r1
    4014:	1f 92       	push	r1
    4016:	cd b7       	in	r28, 0x3d	; 61
    4018:	de b7       	in	r29, 0x3e	; 62
    401a:	9a 83       	std	Y+2, r25	; 0x02
    401c:	89 83       	std	Y+1, r24	; 0x01
   //fake reading
   *sensorResponse = 0;
    401e:	89 81       	ldd	r24, Y+1	; 0x01
    4020:	9a 81       	ldd	r25, Y+2	; 0x02
    4022:	fc 01       	movw	r30, r24
    4024:	10 82       	st	Z, r1
   //return success
   return 1;
    4026:	81 e0       	ldi	r24, 0x01	; 1
}
    4028:	0f 90       	pop	r0
    402a:	0f 90       	pop	r0
    402c:	df 91       	pop	r29
    402e:	cf 91       	pop	r28
    4030:	08 95       	ret

00004032 <setLight>:
//light controller functions
#include <avr/io.h>

//turn lights on and off
char setLight(unsigned char lightTarget) {
    4032:	cf 93       	push	r28
    4034:	df 93       	push	r29
    4036:	1f 92       	push	r1
    4038:	cd b7       	in	r28, 0x3d	; 61
    403a:	de b7       	in	r29, 0x3e	; 62
    403c:	89 83       	std	Y+1, r24	; 0x01
   //dummy function, nothing happens
	//PORTB ^= 0x80;
	if(lightTarget == 1){
    403e:	89 81       	ldd	r24, Y+1	; 0x01
    4040:	81 30       	cpi	r24, 0x01	; 1
    4042:	51 f4       	brne	.+20     	; 0x4058 <setLight+0x26>
		PORTB |= 0x80;
    4044:	85 e2       	ldi	r24, 0x25	; 37
    4046:	90 e0       	ldi	r25, 0x00	; 0
    4048:	25 e2       	ldi	r18, 0x25	; 37
    404a:	30 e0       	ldi	r19, 0x00	; 0
    404c:	f9 01       	movw	r30, r18
    404e:	20 81       	ld	r18, Z
    4050:	20 68       	ori	r18, 0x80	; 128
    4052:	fc 01       	movw	r30, r24
    4054:	20 83       	st	Z, r18
    4056:	09 c0       	rjmp	.+18     	; 0x406a <setLight+0x38>
	} else {
		PORTB &= ~0x80;
    4058:	85 e2       	ldi	r24, 0x25	; 37
    405a:	90 e0       	ldi	r25, 0x00	; 0
    405c:	25 e2       	ldi	r18, 0x25	; 37
    405e:	30 e0       	ldi	r19, 0x00	; 0
    4060:	f9 01       	movw	r30, r18
    4062:	20 81       	ld	r18, Z
    4064:	2f 77       	andi	r18, 0x7F	; 127
    4066:	fc 01       	movw	r30, r24
    4068:	20 83       	st	Z, r18
	}
   return 1;
    406a:	81 e0       	ldi	r24, 0x01	; 1
}
    406c:	0f 90       	pop	r0
    406e:	df 91       	pop	r29
    4070:	cf 91       	pop	r28
    4072:	08 95       	ret

00004074 <setSonarData>:
extern int count;

unsigned char currSonar;
unsigned char lastSonarData = 0;
   
void setSonarData(int i,unsigned char data){
    4074:	cf 93       	push	r28
    4076:	df 93       	push	r29
    4078:	00 d0       	rcall	.+0      	; 0x407a <setSonarData+0x6>
    407a:	cd b7       	in	r28, 0x3d	; 61
    407c:	de b7       	in	r29, 0x3e	; 62
    407e:	9a 83       	std	Y+2, r25	; 0x02
    4080:	89 83       	std	Y+1, r24	; 0x01
    4082:	6b 83       	std	Y+3, r22	; 0x03
// xSemaphoreTake(sonarDataMutex[i],portMAX_DELAY);
   sonarData[i] = data;
    4084:	89 81       	ldd	r24, Y+1	; 0x01
    4086:	9a 81       	ldd	r25, Y+2	; 0x02
    4088:	84 53       	subi	r24, 0x34	; 52
    408a:	95 4e       	sbci	r25, 0xE5	; 229
    408c:	2b 81       	ldd	r18, Y+3	; 0x03
    408e:	fc 01       	movw	r30, r24
    4090:	20 83       	st	Z, r18
   //xSemaphoreGive(sonarDataMutex[i]);
}
    4092:	0f 90       	pop	r0
    4094:	0f 90       	pop	r0
    4096:	0f 90       	pop	r0
    4098:	df 91       	pop	r29
    409a:	cf 91       	pop	r28
    409c:	08 95       	ret

0000409e <getSonarData>:

unsigned char getSonarData(int i){
    409e:	cf 93       	push	r28
    40a0:	df 93       	push	r29
    40a2:	1f 92       	push	r1
    40a4:	1f 92       	push	r1
    40a6:	cd b7       	in	r28, 0x3d	; 61
    40a8:	de b7       	in	r29, 0x3e	; 62
    40aa:	9a 83       	std	Y+2, r25	; 0x02
    40ac:	89 83       	std	Y+1, r24	; 0x01
   //xSemaphoreTake(sonarDataMutex[i],portMAX_DELAY);
   //return sonarData[i];
   return i + 2;
    40ae:	89 81       	ldd	r24, Y+1	; 0x01
    40b0:	8e 5f       	subi	r24, 0xFE	; 254
   //xSemaphoreGive(sonarDataMutex[i]);
}
    40b2:	0f 90       	pop	r0
    40b4:	0f 90       	pop	r0
    40b6:	df 91       	pop	r29
    40b8:	cf 91       	pop	r28
    40ba:	08 95       	ret

000040bc <getTimerCount>:

unsigned char getTimerCount(){
    40bc:	cf 93       	push	r28
    40be:	df 93       	push	r29
    40c0:	cd b7       	in	r28, 0x3d	; 61
    40c2:	de b7       	in	r29, 0x3e	; 62
   return TCNT0;
    40c4:	86 e4       	ldi	r24, 0x46	; 70
    40c6:	90 e0       	ldi	r25, 0x00	; 0
    40c8:	fc 01       	movw	r30, r24
    40ca:	80 81       	ld	r24, Z
}
    40cc:	df 91       	pop	r29
    40ce:	cf 91       	pop	r28
    40d0:	08 95       	ret

000040d2 <__vector_11>:

inline void setTimerCount(unsigned char i){
   TCNT0 = i;
}

ISR(PCINT2_vect) {
    40d2:	1f 92       	push	r1
    40d4:	0f 92       	push	r0
    40d6:	00 90 5f 00 	lds	r0, 0x005F
    40da:	0f 92       	push	r0
    40dc:	11 24       	eor	r1, r1
    40de:	00 90 5b 00 	lds	r0, 0x005B
    40e2:	0f 92       	push	r0
    40e4:	2f 93       	push	r18
    40e6:	3f 93       	push	r19
    40e8:	4f 93       	push	r20
    40ea:	5f 93       	push	r21
    40ec:	6f 93       	push	r22
    40ee:	7f 93       	push	r23
    40f0:	8f 93       	push	r24
    40f2:	9f 93       	push	r25
    40f4:	af 93       	push	r26
    40f6:	bf 93       	push	r27
    40f8:	ef 93       	push	r30
    40fa:	ff 93       	push	r31
    40fc:	cf 93       	push	r28
    40fe:	df 93       	push	r29
    4100:	00 d0       	rcall	.+0      	; 0x4102 <__vector_11+0x30>
    4102:	cd b7       	in	r28, 0x3d	; 61
    4104:	de b7       	in	r29, 0x3e	; 62

   unsigned char beginCount;
   unsigned char currCount;
   char i=0;   
    4106:	19 82       	std	Y+1, r1	; 0x01

   if(PINK&(1<<currSonar)){
    4108:	86 e0       	ldi	r24, 0x06	; 6
    410a:	91 e0       	ldi	r25, 0x01	; 1
    410c:	fc 01       	movw	r30, r24
    410e:	80 81       	ld	r24, Z
    4110:	88 2f       	mov	r24, r24
    4112:	90 e0       	ldi	r25, 0x00	; 0
    4114:	20 91 e0 1a 	lds	r18, 0x1AE0
    4118:	22 2f       	mov	r18, r18
    411a:	30 e0       	ldi	r19, 0x00	; 0
    411c:	02 2e       	mov	r0, r18
    411e:	02 c0       	rjmp	.+4      	; 0x4124 <__vector_11+0x52>
    4120:	95 95       	asr	r25
    4122:	87 95       	ror	r24
    4124:	0a 94       	dec	r0
    4126:	e2 f7       	brpl	.-8      	; 0x4120 <__vector_11+0x4e>
    4128:	81 70       	andi	r24, 0x01	; 1
    412a:	99 27       	eor	r25, r25
    412c:	00 97       	sbiw	r24, 0x00	; 0
    412e:	49 f0       	breq	.+18     	; 0x4142 <__vector_11+0x70>
      //USART_AddToQueue('U');
      beginCount = getTimerCount();
    4130:	0e 94 5e 20 	call	0x40bc	; 0x40bc <getTimerCount>
    4134:	8a 83       	std	Y+2, r24	; 0x02
      PORTE = 0xFF;
    4136:	8e e2       	ldi	r24, 0x2E	; 46
    4138:	90 e0       	ldi	r25, 0x00	; 0
    413a:	2f ef       	ldi	r18, 0xFF	; 255
    413c:	fc 01       	movw	r30, r24
    413e:	20 83       	st	Z, r18
    4140:	1d c0       	rjmp	.+58     	; 0x417c <__vector_11+0xaa>
   } else {
      //USART_AddToQueue('D');
      currCount = getTimerCount();
    4142:	0e 94 5e 20 	call	0x40bc	; 0x40bc <getTimerCount>
    4146:	8b 83       	std	Y+3, r24	; 0x03
      if(currCount > beginCount){
    4148:	9b 81       	ldd	r25, Y+3	; 0x03
    414a:	8a 81       	ldd	r24, Y+2	; 0x02
    414c:	89 17       	cp	r24, r25
    414e:	38 f4       	brcc	.+14     	; 0x415e <__vector_11+0x8c>
         lastSonarData = currCount - beginCount;
    4150:	9b 81       	ldd	r25, Y+3	; 0x03
    4152:	8a 81       	ldd	r24, Y+2	; 0x02
    4154:	f9 2f       	mov	r31, r25
    4156:	f8 1b       	sub	r31, r24
    4158:	8f 2f       	mov	r24, r31
    415a:	80 93 c3 1a 	sts	0x1AC3, r24
      }
      PORTE = 0;
    415e:	8e e2       	ldi	r24, 0x2E	; 46
    4160:	90 e0       	ldi	r25, 0x00	; 0
    4162:	fc 01       	movw	r30, r24
    4164:	10 82       	st	Z, r1
      xSemaphoreGiveFromISR(sonarSemaphore,0);
    4166:	80 91 d2 1a 	lds	r24, 0x1AD2
    416a:	90 91 d3 1a 	lds	r25, 0x1AD3
    416e:	20 e0       	ldi	r18, 0x00	; 0
    4170:	40 e0       	ldi	r20, 0x00	; 0
    4172:	50 e0       	ldi	r21, 0x00	; 0
    4174:	60 e0       	ldi	r22, 0x00	; 0
    4176:	70 e0       	ldi	r23, 0x00	; 0
    4178:	0e 94 42 0e 	call	0x1c84	; 0x1c84 <xQueueGenericSendFromISR>
   }

}
    417c:	0f 90       	pop	r0
    417e:	0f 90       	pop	r0
    4180:	0f 90       	pop	r0
    4182:	df 91       	pop	r29
    4184:	cf 91       	pop	r28
    4186:	ff 91       	pop	r31
    4188:	ef 91       	pop	r30
    418a:	bf 91       	pop	r27
    418c:	af 91       	pop	r26
    418e:	9f 91       	pop	r25
    4190:	8f 91       	pop	r24
    4192:	7f 91       	pop	r23
    4194:	6f 91       	pop	r22
    4196:	5f 91       	pop	r21
    4198:	4f 91       	pop	r20
    419a:	3f 91       	pop	r19
    419c:	2f 91       	pop	r18
    419e:	0f 90       	pop	r0
    41a0:	00 92 5b 00 	sts	0x005B, r0
    41a4:	0f 90       	pop	r0
    41a6:	00 92 5f 00 	sts	0x005F, r0
    41aa:	0f 90       	pop	r0
    41ac:	1f 90       	pop	r1
    41ae:	18 95       	reti

000041b0 <initializeSonarSensors>:

void initializeSonarSensors(){
    41b0:	cf 93       	push	r28
    41b2:	df 93       	push	r29
    41b4:	cd b7       	in	r28, 0x3d	; 61
    41b6:	de b7       	in	r29, 0x3e	; 62
   //DDRD &= 0xFE;   
   DIDR2 = 0;
    41b8:	8d e7       	ldi	r24, 0x7D	; 125
    41ba:	90 e0       	ldi	r25, 0x00	; 0
    41bc:	fc 01       	movw	r30, r24
    41be:	10 82       	st	Z, r1
   DDRK = 0;
    41c0:	87 e0       	ldi	r24, 0x07	; 7
    41c2:	91 e0       	ldi	r25, 0x01	; 1
    41c4:	fc 01       	movw	r30, r24
    41c6:	10 82       	st	Z, r1
   DDRC = 0;
    41c8:	87 e2       	ldi	r24, 0x27	; 39
    41ca:	90 e0       	ldi	r25, 0x00	; 0
    41cc:	fc 01       	movw	r30, r24
    41ce:	10 82       	st	Z, r1

   PORTC = 0;
    41d0:	88 e2       	ldi	r24, 0x28	; 40
    41d2:	90 e0       	ldi	r25, 0x00	; 0
    41d4:	fc 01       	movw	r30, r24
    41d6:	10 82       	st	Z, r1

   //EICRA = 1;
   //EIMSK = 1;

   PCMSK2 = 0xFF;
    41d8:	8d e6       	ldi	r24, 0x6D	; 109
    41da:	90 e0       	ldi	r25, 0x00	; 0
    41dc:	2f ef       	ldi	r18, 0xFF	; 255
    41de:	fc 01       	movw	r30, r24
    41e0:	20 83       	st	Z, r18
   PCICR = 0x7;
    41e2:	88 e6       	ldi	r24, 0x68	; 104
    41e4:	90 e0       	ldi	r25, 0x00	; 0
    41e6:	27 e0       	ldi	r18, 0x07	; 7
    41e8:	fc 01       	movw	r30, r24
    41ea:	20 83       	st	Z, r18

   TCCR0A = 0;
    41ec:	84 e4       	ldi	r24, 0x44	; 68
    41ee:	90 e0       	ldi	r25, 0x00	; 0
    41f0:	fc 01       	movw	r30, r24
    41f2:	10 82       	st	Z, r1
   TCCR0B = 5;
    41f4:	85 e4       	ldi	r24, 0x45	; 69
    41f6:	90 e0       	ldi	r25, 0x00	; 0
    41f8:	25 e0       	ldi	r18, 0x05	; 5
    41fa:	fc 01       	movw	r30, r24
    41fc:	20 83       	st	Z, r18

}
    41fe:	df 91       	pop	r29
    4200:	cf 91       	pop	r28
    4202:	08 95       	ret

00004204 <vTaskSonar>:

void vTaskSonar(void* parameter){
    4204:	cf 93       	push	r28
    4206:	df 93       	push	r29
    4208:	00 d0       	rcall	.+0      	; 0x420a <vTaskSonar+0x6>
    420a:	1f 92       	push	r1
    420c:	cd b7       	in	r28, 0x3d	; 61
    420e:	de b7       	in	r29, 0x3e	; 62
    4210:	9c 83       	std	Y+4, r25	; 0x04
    4212:	8b 83       	std	Y+3, r24	; 0x03

   int i;
   initializeSonarSensors();
    4214:	0e 94 d8 20 	call	0x41b0	; 0x41b0 <initializeSonarSensors>
   
   vSemaphoreCreateBinary(sonarSemaphore);
    4218:	43 e0       	ldi	r20, 0x03	; 3
    421a:	60 e0       	ldi	r22, 0x00	; 0
    421c:	81 e0       	ldi	r24, 0x01	; 1
    421e:	0e 94 e7 0c 	call	0x19ce	; 0x19ce <xQueueGenericCreate>
    4222:	90 93 d3 1a 	sts	0x1AD3, r25
    4226:	80 93 d2 1a 	sts	0x1AD2, r24
    422a:	80 91 d2 1a 	lds	r24, 0x1AD2
    422e:	90 91 d3 1a 	lds	r25, 0x1AD3
    4232:	00 97       	sbiw	r24, 0x00	; 0
    4234:	59 f0       	breq	.+22     	; 0x424c <vTaskSonar+0x48>
    4236:	80 91 d2 1a 	lds	r24, 0x1AD2
    423a:	90 91 d3 1a 	lds	r25, 0x1AD3
    423e:	20 e0       	ldi	r18, 0x00	; 0
    4240:	40 e0       	ldi	r20, 0x00	; 0
    4242:	50 e0       	ldi	r21, 0x00	; 0
    4244:	60 e0       	ldi	r22, 0x00	; 0
    4246:	70 e0       	ldi	r23, 0x00	; 0
    4248:	0e 94 9e 0d 	call	0x1b3c	; 0x1b3c <xQueueGenericSend>
      
   currSonar = 0;
    424c:	10 92 e0 1a 	sts	0x1AE0, r1

   while(1){
      for(i=0;i<2;i++){
    4250:	1a 82       	std	Y+2, r1	; 0x02
    4252:	19 82       	std	Y+1, r1	; 0x01
    4254:	26 c0       	rjmp	.+76     	; 0x42a2 <vTaskSonar+0x9e>
         currSonar = i;
    4256:	89 81       	ldd	r24, Y+1	; 0x01
    4258:	80 93 e0 1a 	sts	0x1AE0, r24
         PORTC = (1<<i);
    425c:	88 e2       	ldi	r24, 0x28	; 40
    425e:	90 e0       	ldi	r25, 0x00	; 0
    4260:	21 e0       	ldi	r18, 0x01	; 1
    4262:	30 e0       	ldi	r19, 0x00	; 0
    4264:	09 80       	ldd	r0, Y+1	; 0x01
    4266:	02 c0       	rjmp	.+4      	; 0x426c <vTaskSonar+0x68>
    4268:	22 0f       	add	r18, r18
    426a:	33 1f       	adc	r19, r19
    426c:	0a 94       	dec	r0
    426e:	e2 f7       	brpl	.-8      	; 0x4268 <vTaskSonar+0x64>
    4270:	fc 01       	movw	r30, r24
    4272:	20 83       	st	Z, r18
         xSemaphoreTake(sonarSemaphore,portMAX_DELAY);
    4274:	80 91 d2 1a 	lds	r24, 0x1AD2
    4278:	90 91 d3 1a 	lds	r25, 0x1AD3
    427c:	20 e0       	ldi	r18, 0x00	; 0
    427e:	4f ef       	ldi	r20, 0xFF	; 255
    4280:	5f ef       	ldi	r21, 0xFF	; 255
    4282:	60 e0       	ldi	r22, 0x00	; 0
    4284:	70 e0       	ldi	r23, 0x00	; 0
    4286:	0e 94 9b 0e 	call	0x1d36	; 0x1d36 <xQueueGenericReceive>
         setSonarData(i,lastSonarData);
    428a:	20 91 c3 1a 	lds	r18, 0x1AC3
    428e:	89 81       	ldd	r24, Y+1	; 0x01
    4290:	9a 81       	ldd	r25, Y+2	; 0x02
    4292:	62 2f       	mov	r22, r18
    4294:	0e 94 3a 20 	call	0x4074	; 0x4074 <setSonarData>
   vSemaphoreCreateBinary(sonarSemaphore);
      
   currSonar = 0;

   while(1){
      for(i=0;i<2;i++){
    4298:	89 81       	ldd	r24, Y+1	; 0x01
    429a:	9a 81       	ldd	r25, Y+2	; 0x02
    429c:	01 96       	adiw	r24, 0x01	; 1
    429e:	9a 83       	std	Y+2, r25	; 0x02
    42a0:	89 83       	std	Y+1, r24	; 0x01
    42a2:	89 81       	ldd	r24, Y+1	; 0x01
    42a4:	9a 81       	ldd	r25, Y+2	; 0x02
    42a6:	82 30       	cpi	r24, 0x02	; 2
    42a8:	91 05       	cpc	r25, r1
    42aa:	ac f2       	brlt	.-86     	; 0x4256 <vTaskSonar+0x52>
         currSonar = i;
         PORTC = (1<<i);
         xSemaphoreTake(sonarSemaphore,portMAX_DELAY);
         setSonarData(i,lastSonarData);
      }
   }
    42ac:	d1 cf       	rjmp	.-94     	; 0x4250 <vTaskSonar+0x4c>

000042ae <getAllSensors>:
            
} 

char getAllSensors(unsigned short* responseData){
    42ae:	cf 93       	push	r28
    42b0:	df 93       	push	r29
    42b2:	00 d0       	rcall	.+0      	; 0x42b4 <getAllSensors+0x6>
    42b4:	1f 92       	push	r1
    42b6:	cd b7       	in	r28, 0x3d	; 61
    42b8:	de b7       	in	r29, 0x3e	; 62
    42ba:	9c 83       	std	Y+4, r25	; 0x04
    42bc:	8b 83       	std	Y+3, r24	; 0x03
   unsigned short i;
   for(i=0;i<6;i++){
    42be:	1a 82       	std	Y+2, r1	; 0x02
    42c0:	19 82       	std	Y+1, r1	; 0x01
    42c2:	14 c0       	rjmp	.+40     	; 0x42ec <getAllSensors+0x3e>
      //responseData[i] = getSonarData(i);
      responseData[i] = i+1;
    42c4:	89 81       	ldd	r24, Y+1	; 0x01
    42c6:	9a 81       	ldd	r25, Y+2	; 0x02
    42c8:	88 0f       	add	r24, r24
    42ca:	99 1f       	adc	r25, r25
    42cc:	2b 81       	ldd	r18, Y+3	; 0x03
    42ce:	3c 81       	ldd	r19, Y+4	; 0x04
    42d0:	82 0f       	add	r24, r18
    42d2:	93 1f       	adc	r25, r19
    42d4:	29 81       	ldd	r18, Y+1	; 0x01
    42d6:	3a 81       	ldd	r19, Y+2	; 0x02
    42d8:	2f 5f       	subi	r18, 0xFF	; 255
    42da:	3f 4f       	sbci	r19, 0xFF	; 255
    42dc:	fc 01       	movw	r30, r24
    42de:	31 83       	std	Z+1, r19	; 0x01
    42e0:	20 83       	st	Z, r18
            
} 

char getAllSensors(unsigned short* responseData){
   unsigned short i;
   for(i=0;i<6;i++){
    42e2:	89 81       	ldd	r24, Y+1	; 0x01
    42e4:	9a 81       	ldd	r25, Y+2	; 0x02
    42e6:	01 96       	adiw	r24, 0x01	; 1
    42e8:	9a 83       	std	Y+2, r25	; 0x02
    42ea:	89 83       	std	Y+1, r24	; 0x01
    42ec:	89 81       	ldd	r24, Y+1	; 0x01
    42ee:	9a 81       	ldd	r25, Y+2	; 0x02
    42f0:	86 30       	cpi	r24, 0x06	; 6
    42f2:	91 05       	cpc	r25, r1
    42f4:	38 f3       	brcs	.-50     	; 0x42c4 <getAllSensors+0x16>
      //responseData[i] = getSonarData(i);
      responseData[i] = i+1;
   }
}
    42f6:	0f 90       	pop	r0
    42f8:	0f 90       	pop	r0
    42fa:	0f 90       	pop	r0
    42fc:	0f 90       	pop	r0
    42fe:	df 91       	pop	r29
    4300:	cf 91       	pop	r28
    4302:	08 95       	ret

00004304 <getCertainSensor>:

char getCertainSensor(char commandData,int* responseData){
    4304:	0f 93       	push	r16
    4306:	1f 93       	push	r17
    4308:	cf 93       	push	r28
    430a:	df 93       	push	r29
    430c:	00 d0       	rcall	.+0      	; 0x430e <getCertainSensor+0xa>
    430e:	cd b7       	in	r28, 0x3d	; 61
    4310:	de b7       	in	r29, 0x3e	; 62
    4312:	89 83       	std	Y+1, r24	; 0x01
    4314:	7b 83       	std	Y+3, r23	; 0x03
    4316:	6a 83       	std	Y+2, r22	; 0x02
   if(commandData < 6){
    4318:	89 81       	ldd	r24, Y+1	; 0x01
    431a:	86 30       	cpi	r24, 0x06	; 6
    431c:	b4 f4       	brge	.+44     	; 0x434a <getCertainSensor+0x46>
      responseData[commandData] = getSonarData(commandData);
    431e:	89 81       	ldd	r24, Y+1	; 0x01
    4320:	99 27       	eor	r25, r25
    4322:	87 fd       	sbrc	r24, 7
    4324:	90 95       	com	r25
    4326:	88 0f       	add	r24, r24
    4328:	99 1f       	adc	r25, r25
    432a:	2a 81       	ldd	r18, Y+2	; 0x02
    432c:	3b 81       	ldd	r19, Y+3	; 0x03
    432e:	89 01       	movw	r16, r18
    4330:	08 0f       	add	r16, r24
    4332:	19 1f       	adc	r17, r25
    4334:	89 81       	ldd	r24, Y+1	; 0x01
    4336:	99 27       	eor	r25, r25
    4338:	87 fd       	sbrc	r24, 7
    433a:	90 95       	com	r25
    433c:	0e 94 4f 20 	call	0x409e	; 0x409e <getSonarData>
    4340:	88 2f       	mov	r24, r24
    4342:	90 e0       	ldi	r25, 0x00	; 0
    4344:	f8 01       	movw	r30, r16
    4346:	91 83       	std	Z+1, r25	; 0x01
    4348:	80 83       	st	Z, r24
   }
}
    434a:	0f 90       	pop	r0
    434c:	0f 90       	pop	r0
    434e:	0f 90       	pop	r0
    4350:	df 91       	pop	r29
    4352:	cf 91       	pop	r28
    4354:	1f 91       	pop	r17
    4356:	0f 91       	pop	r16
    4358:	08 95       	ret

0000435a <getSensorGroup>:

char getSensorGroup(char commandData,int* responseData){
    435a:	0f 93       	push	r16
    435c:	1f 93       	push	r17
    435e:	cf 93       	push	r28
    4360:	df 93       	push	r29
    4362:	00 d0       	rcall	.+0      	; 0x4364 <getSensorGroup+0xa>
    4364:	cd b7       	in	r28, 0x3d	; 61
    4366:	de b7       	in	r29, 0x3e	; 62
    4368:	89 83       	std	Y+1, r24	; 0x01
    436a:	7b 83       	std	Y+3, r23	; 0x03
    436c:	6a 83       	std	Y+2, r22	; 0x02

   switch(commandData){
    436e:	89 81       	ldd	r24, Y+1	; 0x01
    4370:	99 27       	eor	r25, r25
    4372:	87 fd       	sbrc	r24, 7
    4374:	90 95       	com	r25
    4376:	81 30       	cpi	r24, 0x01	; 1
    4378:	91 05       	cpc	r25, r1
    437a:	01 f1       	breq	.+64     	; 0x43bc <getSensorGroup+0x62>
    437c:	82 30       	cpi	r24, 0x02	; 2
    437e:	91 05       	cpc	r25, r1
    4380:	b9 f1       	breq	.+110    	; 0x43f0 <getSensorGroup+0x96>
    4382:	00 97       	sbiw	r24, 0x00	; 0
    4384:	09 f0       	breq	.+2      	; 0x4388 <getSensorGroup+0x2e>
    4386:	4e c0       	rjmp	.+156    	; 0x4424 <getSensorGroup+0xca>
      case SONAR_GROUP_LEFT:
         responseData[0] = getSonarData(0);
    4388:	80 e0       	ldi	r24, 0x00	; 0
    438a:	90 e0       	ldi	r25, 0x00	; 0
    438c:	0e 94 4f 20 	call	0x409e	; 0x409e <getSonarData>
    4390:	28 2f       	mov	r18, r24
    4392:	30 e0       	ldi	r19, 0x00	; 0
    4394:	8a 81       	ldd	r24, Y+2	; 0x02
    4396:	9b 81       	ldd	r25, Y+3	; 0x03
    4398:	fc 01       	movw	r30, r24
    439a:	31 83       	std	Z+1, r19	; 0x01
    439c:	20 83       	st	Z, r18
         responseData[1] = getSonarData(1);
    439e:	8a 81       	ldd	r24, Y+2	; 0x02
    43a0:	9b 81       	ldd	r25, Y+3	; 0x03
    43a2:	8c 01       	movw	r16, r24
    43a4:	0e 5f       	subi	r16, 0xFE	; 254
    43a6:	1f 4f       	sbci	r17, 0xFF	; 255
    43a8:	81 e0       	ldi	r24, 0x01	; 1
    43aa:	90 e0       	ldi	r25, 0x00	; 0
    43ac:	0e 94 4f 20 	call	0x409e	; 0x409e <getSonarData>
    43b0:	88 2f       	mov	r24, r24
    43b2:	90 e0       	ldi	r25, 0x00	; 0
    43b4:	f8 01       	movw	r30, r16
    43b6:	91 83       	std	Z+1, r25	; 0x01
    43b8:	80 83       	st	Z, r24
         break;
    43ba:	34 c0       	rjmp	.+104    	; 0x4424 <getSensorGroup+0xca>
      case SONAR_GROUP_FRONT:
         responseData[0] = getSonarData(2);
    43bc:	82 e0       	ldi	r24, 0x02	; 2
    43be:	90 e0       	ldi	r25, 0x00	; 0
    43c0:	0e 94 4f 20 	call	0x409e	; 0x409e <getSonarData>
    43c4:	28 2f       	mov	r18, r24
    43c6:	30 e0       	ldi	r19, 0x00	; 0
    43c8:	8a 81       	ldd	r24, Y+2	; 0x02
    43ca:	9b 81       	ldd	r25, Y+3	; 0x03
    43cc:	fc 01       	movw	r30, r24
    43ce:	31 83       	std	Z+1, r19	; 0x01
    43d0:	20 83       	st	Z, r18
         responseData[1] = getSonarData(3);
    43d2:	8a 81       	ldd	r24, Y+2	; 0x02
    43d4:	9b 81       	ldd	r25, Y+3	; 0x03
    43d6:	8c 01       	movw	r16, r24
    43d8:	0e 5f       	subi	r16, 0xFE	; 254
    43da:	1f 4f       	sbci	r17, 0xFF	; 255
    43dc:	83 e0       	ldi	r24, 0x03	; 3
    43de:	90 e0       	ldi	r25, 0x00	; 0
    43e0:	0e 94 4f 20 	call	0x409e	; 0x409e <getSonarData>
    43e4:	88 2f       	mov	r24, r24
    43e6:	90 e0       	ldi	r25, 0x00	; 0
    43e8:	f8 01       	movw	r30, r16
    43ea:	91 83       	std	Z+1, r25	; 0x01
    43ec:	80 83       	st	Z, r24
         break;
    43ee:	1a c0       	rjmp	.+52     	; 0x4424 <getSensorGroup+0xca>
      case SONAR_GROUP_RIGHT:
         responseData[0] = getSonarData(4);
    43f0:	84 e0       	ldi	r24, 0x04	; 4
    43f2:	90 e0       	ldi	r25, 0x00	; 0
    43f4:	0e 94 4f 20 	call	0x409e	; 0x409e <getSonarData>
    43f8:	28 2f       	mov	r18, r24
    43fa:	30 e0       	ldi	r19, 0x00	; 0
    43fc:	8a 81       	ldd	r24, Y+2	; 0x02
    43fe:	9b 81       	ldd	r25, Y+3	; 0x03
    4400:	fc 01       	movw	r30, r24
    4402:	31 83       	std	Z+1, r19	; 0x01
    4404:	20 83       	st	Z, r18
         responseData[1] = getSonarData(5);
    4406:	8a 81       	ldd	r24, Y+2	; 0x02
    4408:	9b 81       	ldd	r25, Y+3	; 0x03
    440a:	8c 01       	movw	r16, r24
    440c:	0e 5f       	subi	r16, 0xFE	; 254
    440e:	1f 4f       	sbci	r17, 0xFF	; 255
    4410:	85 e0       	ldi	r24, 0x05	; 5
    4412:	90 e0       	ldi	r25, 0x00	; 0
    4414:	0e 94 4f 20 	call	0x409e	; 0x409e <getSonarData>
    4418:	88 2f       	mov	r24, r24
    441a:	90 e0       	ldi	r25, 0x00	; 0
    441c:	f8 01       	movw	r30, r16
    441e:	91 83       	std	Z+1, r25	; 0x01
    4420:	80 83       	st	Z, r24
         break;
    4422:	00 00       	nop
   }

    4424:	0f 90       	pop	r0
    4426:	0f 90       	pop	r0
    4428:	0f 90       	pop	r0
    442a:	df 91       	pop	r29
    442c:	cf 91       	pop	r28
    442e:	1f 91       	pop	r17
    4430:	0f 91       	pop	r16
    4432:	08 95       	ret

00004434 <initSpeedController>:
//Speed Sensor group

#include "spi.h"

void initSpeedController(){
    4434:	cf 93       	push	r28
    4436:	df 93       	push	r29
    4438:	cd b7       	in	r28, 0x3d	; 61
    443a:	de b7       	in	r29, 0x3e	; 62
	SPIsendShort(0x400F);
    443c:	8f e0       	ldi	r24, 0x0F	; 15
    443e:	90 e4       	ldi	r25, 0x40	; 64
    4440:	0e 94 74 23 	call	0x46e8	; 0x46e8 <SPIsendShort>
}
    4444:	df 91       	pop	r29
    4446:	cf 91       	pop	r28
    4448:	08 95       	ret

0000444a <setPot>:

void setPot(int value){
    444a:	cf 93       	push	r28
    444c:	df 93       	push	r29
    444e:	00 d0       	rcall	.+0      	; 0x4450 <setPot+0x6>
    4450:	1f 92       	push	r1
    4452:	cd b7       	in	r28, 0x3d	; 61
    4454:	de b7       	in	r29, 0x3e	; 62
    4456:	9c 83       	std	Y+4, r25	; 0x04
    4458:	8b 83       	std	Y+3, r24	; 0x03
	unsigned short data = 0;
    445a:	1a 82       	std	Y+2, r1	; 0x02
    445c:	19 82       	std	Y+1, r1	; 0x01
	data = value & 0xFF;
    445e:	8b 81       	ldd	r24, Y+3	; 0x03
    4460:	9c 81       	ldd	r25, Y+4	; 0x04
    4462:	99 27       	eor	r25, r25
    4464:	9a 83       	std	Y+2, r25	; 0x02
    4466:	89 83       	std	Y+1, r24	; 0x01

	SPIsendShort(data);
    4468:	89 81       	ldd	r24, Y+1	; 0x01
    446a:	9a 81       	ldd	r25, Y+2	; 0x02
    446c:	0e 94 74 23 	call	0x46e8	; 0x46e8 <SPIsendShort>
}
    4470:	0f 90       	pop	r0
    4472:	0f 90       	pop	r0
    4474:	0f 90       	pop	r0
    4476:	0f 90       	pop	r0
    4478:	df 91       	pop	r29
    447a:	cf 91       	pop	r28
    447c:	08 95       	ret

0000447e <decrementPot>:

void decrementPot(){
    447e:	cf 93       	push	r28
    4480:	df 93       	push	r29
    4482:	cd b7       	in	r28, 0x3d	; 61
    4484:	de b7       	in	r29, 0x3e	; 62
	SPIsendByte(0x06);
    4486:	86 e0       	ldi	r24, 0x06	; 6
    4488:	90 e0       	ldi	r25, 0x00	; 0
    448a:	0e 94 2e 23 	call	0x465c	; 0x465c <SPIsendByte>
}
    448e:	df 91       	pop	r29
    4490:	cf 91       	pop	r28
    4492:	08 95       	ret

00004494 <incrementPot>:

void incrementPot(){
    4494:	cf 93       	push	r28
    4496:	df 93       	push	r29
    4498:	cd b7       	in	r28, 0x3d	; 61
    449a:	de b7       	in	r29, 0x3e	; 62
	SPIsendByte(0x0A);
    449c:	8a e0       	ldi	r24, 0x0A	; 10
    449e:	90 e0       	ldi	r25, 0x00	; 0
    44a0:	0e 94 2e 23 	call	0x465c	; 0x465c <SPIsendByte>
}
    44a4:	df 91       	pop	r29
    44a6:	cf 91       	pop	r28
    44a8:	08 95       	ret

000044aa <getSpeed>:

//get the speed of the vehicle
char getSpeed(char* sensorResponse) {
    44aa:	cf 93       	push	r28
    44ac:	df 93       	push	r29
    44ae:	1f 92       	push	r1
    44b0:	1f 92       	push	r1
    44b2:	cd b7       	in	r28, 0x3d	; 61
    44b4:	de b7       	in	r29, 0x3e	; 62
    44b6:	9a 83       	std	Y+2, r25	; 0x02
    44b8:	89 83       	std	Y+1, r24	; 0x01
   //store dummy speed value
   *sensorResponse = 0;
    44ba:	89 81       	ldd	r24, Y+1	; 0x01
    44bc:	9a 81       	ldd	r25, Y+2	; 0x02
    44be:	fc 01       	movw	r30, r24
    44c0:	10 82       	st	Z, r1
   //return success
   return 1;
    44c2:	81 e0       	ldi	r24, 0x01	; 1
}
    44c4:	0f 90       	pop	r0
    44c6:	0f 90       	pop	r0
    44c8:	df 91       	pop	r29
    44ca:	cf 91       	pop	r28
    44cc:	08 95       	ret

000044ce <setSpeed>:

//will set just the speed of the wheels of the car
char setSpeed(char speedTarget) {
    44ce:	cf 93       	push	r28
    44d0:	df 93       	push	r29
    44d2:	1f 92       	push	r1
    44d4:	cd b7       	in	r28, 0x3d	; 61
    44d6:	de b7       	in	r29, 0x3e	; 62
    44d8:	89 83       	std	Y+1, r24	; 0x01
   //nothing done down here
   //return success
   return 1;
    44da:	81 e0       	ldi	r24, 0x01	; 1
}
    44dc:	0f 90       	pop	r0
    44de:	df 91       	pop	r29
    44e0:	cf 91       	pop	r28
    44e2:	08 95       	ret

000044e4 <setAngle>:

//Steering group

//JUST SETS ANGLE TARGET. Actual angle changing is lower level
char setAngle(char angleTarget) {
    44e4:	cf 93       	push	r28
    44e6:	df 93       	push	r29
    44e8:	1f 92       	push	r1
    44ea:	cd b7       	in	r28, 0x3d	; 61
    44ec:	de b7       	in	r29, 0x3e	; 62
    44ee:	89 83       	std	Y+1, r24	; 0x01
   //dummy function, nothing will happen for now...
   //return success
   return 1;
    44f0:	81 e0       	ldi	r24, 0x01	; 1
}
    44f2:	0f 90       	pop	r0
    44f4:	df 91       	pop	r29
    44f6:	cf 91       	pop	r28
    44f8:	08 95       	ret

000044fa <getAngle>:

//get the current angle of the steering system
char getAngle(char* sensorResponse) {
    44fa:	cf 93       	push	r28
    44fc:	df 93       	push	r29
    44fe:	1f 92       	push	r1
    4500:	1f 92       	push	r1
    4502:	cd b7       	in	r28, 0x3d	; 61
    4504:	de b7       	in	r29, 0x3e	; 62
    4506:	9a 83       	std	Y+2, r25	; 0x02
    4508:	89 83       	std	Y+1, r24	; 0x01
   //store fake angle reading
   *sensorResponse = 0;
    450a:	89 81       	ldd	r24, Y+1	; 0x01
    450c:	9a 81       	ldd	r25, Y+2	; 0x02
    450e:	fc 01       	movw	r30, r24
    4510:	10 82       	st	Z, r1
   //return success
   return 1;
    4512:	81 e0       	ldi	r24, 0x01	; 1
}
    4514:	0f 90       	pop	r0
    4516:	0f 90       	pop	r0
    4518:	df 91       	pop	r29
    451a:	cf 91       	pop	r28
    451c:	08 95       	ret

0000451e <getDesiredAngle>:

//get the angle target. argument name is sensorResponse for the sake of consistancy
char getDesiredAngle(char* sensorResponse) {
    451e:	cf 93       	push	r28
    4520:	df 93       	push	r29
    4522:	1f 92       	push	r1
    4524:	1f 92       	push	r1
    4526:	cd b7       	in	r28, 0x3d	; 61
    4528:	de b7       	in	r29, 0x3e	; 62
    452a:	9a 83       	std	Y+2, r25	; 0x02
    452c:	89 83       	std	Y+1, r24	; 0x01
   //fake response
   *sensorResponse = 0;
    452e:	89 81       	ldd	r24, Y+1	; 0x01
    4530:	9a 81       	ldd	r25, Y+2	; 0x02
    4532:	fc 01       	movw	r30, r24
    4534:	10 82       	st	Z, r1
   //return success
   return 1;
    4536:	81 e0       	ldi	r24, 0x01	; 1
}
    4538:	0f 90       	pop	r0
    453a:	0f 90       	pop	r0
    453c:	df 91       	pop	r29
    453e:	cf 91       	pop	r28
    4540:	08 95       	ret

00004542 <changePID>:

//change the PID controller
char changePID(char P, char I, char D) {
    4542:	cf 93       	push	r28
    4544:	df 93       	push	r29
    4546:	00 d0       	rcall	.+0      	; 0x4548 <changePID+0x6>
    4548:	cd b7       	in	r28, 0x3d	; 61
    454a:	de b7       	in	r29, 0x3e	; 62
    454c:	89 83       	std	Y+1, r24	; 0x01
    454e:	6a 83       	std	Y+2, r22	; 0x02
    4550:	4b 83       	std	Y+3, r20	; 0x03
   //dummy function, nothing happens
   //return success
   return 1;
    4552:	81 e0       	ldi	r24, 0x01	; 1
}
    4554:	0f 90       	pop	r0
    4556:	0f 90       	pop	r0
    4558:	0f 90       	pop	r0
    455a:	df 91       	pop	r29
    455c:	cf 91       	pop	r28
    455e:	08 95       	ret

00004560 <setLimits>:

//not sure what this does. Also not sure why upper and lower are separated
//but its in the specs so...
char setLimits(char upper, char lower) {
    4560:	cf 93       	push	r28
    4562:	df 93       	push	r29
    4564:	1f 92       	push	r1
    4566:	1f 92       	push	r1
    4568:	cd b7       	in	r28, 0x3d	; 61
    456a:	de b7       	in	r29, 0x3e	; 62
    456c:	89 83       	std	Y+1, r24	; 0x01
    456e:	6a 83       	std	Y+2, r22	; 0x02
   //dummy function, nothing happens
   //return success
   return 1;
    4570:	81 e0       	ldi	r24, 0x01	; 1
}
    4572:	0f 90       	pop	r0
    4574:	0f 90       	pop	r0
    4576:	df 91       	pop	r29
    4578:	cf 91       	pop	r28
    457a:	08 95       	ret

0000457c <initializeSPI>:
const static int mosi_pin = 2;
const static int miso_pin = 3;
const static int sck_pin = 1;
const static int ss_pin = 0; 

void initializeSPI(){
    457c:	cf 93       	push	r28
    457e:	df 93       	push	r29
    4580:	cd b7       	in	r28, 0x3d	; 61
    4582:	de b7       	in	r29, 0x3e	; 62
	SPCR = (1 << SPE)|(1 << MSTR)|(1 << SPR1)|(1 << SPR0);
    4584:	8c e4       	ldi	r24, 0x4C	; 76
    4586:	90 e0       	ldi	r25, 0x00	; 0
    4588:	23 e5       	ldi	r18, 0x53	; 83
    458a:	fc 01       	movw	r30, r24
    458c:	20 83       	st	Z, r18
	DDRB |= (1 << ss_pin)|(1 << sck_pin)|(1 << mosi_pin);
    458e:	84 e2       	ldi	r24, 0x24	; 36
    4590:	90 e0       	ldi	r25, 0x00	; 0
    4592:	24 e2       	ldi	r18, 0x24	; 36
    4594:	30 e0       	ldi	r19, 0x00	; 0
    4596:	f9 01       	movw	r30, r18
    4598:	20 81       	ld	r18, Z
    459a:	62 2f       	mov	r22, r18
    459c:	40 e0       	ldi	r20, 0x00	; 0
    459e:	50 e0       	ldi	r21, 0x00	; 0
    45a0:	21 e0       	ldi	r18, 0x01	; 1
    45a2:	30 e0       	ldi	r19, 0x00	; 0
    45a4:	02 c0       	rjmp	.+4      	; 0x45aa <initializeSPI+0x2e>
    45a6:	22 0f       	add	r18, r18
    45a8:	33 1f       	adc	r19, r19
    45aa:	4a 95       	dec	r20
    45ac:	e2 f7       	brpl	.-8      	; 0x45a6 <initializeSPI+0x2a>
    45ae:	72 2f       	mov	r23, r18
    45b0:	41 e0       	ldi	r20, 0x01	; 1
    45b2:	50 e0       	ldi	r21, 0x00	; 0
    45b4:	21 e0       	ldi	r18, 0x01	; 1
    45b6:	30 e0       	ldi	r19, 0x00	; 0
    45b8:	02 c0       	rjmp	.+4      	; 0x45be <initializeSPI+0x42>
    45ba:	22 0f       	add	r18, r18
    45bc:	33 1f       	adc	r19, r19
    45be:	4a 95       	dec	r20
    45c0:	e2 f7       	brpl	.-8      	; 0x45ba <initializeSPI+0x3e>
    45c2:	72 2b       	or	r23, r18
    45c4:	42 e0       	ldi	r20, 0x02	; 2
    45c6:	50 e0       	ldi	r21, 0x00	; 0
    45c8:	21 e0       	ldi	r18, 0x01	; 1
    45ca:	30 e0       	ldi	r19, 0x00	; 0
    45cc:	02 c0       	rjmp	.+4      	; 0x45d2 <initializeSPI+0x56>
    45ce:	22 0f       	add	r18, r18
    45d0:	33 1f       	adc	r19, r19
    45d2:	4a 95       	dec	r20
    45d4:	e2 f7       	brpl	.-8      	; 0x45ce <initializeSPI+0x52>
    45d6:	27 2b       	or	r18, r23
    45d8:	26 2b       	or	r18, r22
    45da:	fc 01       	movw	r30, r24
    45dc:	20 83       	st	Z, r18
	DDRB &= ~(1 << miso_pin);
    45de:	84 e2       	ldi	r24, 0x24	; 36
    45e0:	90 e0       	ldi	r25, 0x00	; 0
    45e2:	24 e2       	ldi	r18, 0x24	; 36
    45e4:	30 e0       	ldi	r19, 0x00	; 0
    45e6:	f9 01       	movw	r30, r18
    45e8:	20 81       	ld	r18, Z
    45ea:	62 2f       	mov	r22, r18
    45ec:	43 e0       	ldi	r20, 0x03	; 3
    45ee:	50 e0       	ldi	r21, 0x00	; 0
    45f0:	21 e0       	ldi	r18, 0x01	; 1
    45f2:	30 e0       	ldi	r19, 0x00	; 0
    45f4:	02 c0       	rjmp	.+4      	; 0x45fa <initializeSPI+0x7e>
    45f6:	22 0f       	add	r18, r18
    45f8:	33 1f       	adc	r19, r19
    45fa:	4a 95       	dec	r20
    45fc:	e2 f7       	brpl	.-8      	; 0x45f6 <initializeSPI+0x7a>
    45fe:	20 95       	com	r18
    4600:	26 23       	and	r18, r22
    4602:	fc 01       	movw	r30, r24
    4604:	20 83       	st	Z, r18
	PORTB |= 1 << ss_pin;
    4606:	85 e2       	ldi	r24, 0x25	; 37
    4608:	90 e0       	ldi	r25, 0x00	; 0
    460a:	25 e2       	ldi	r18, 0x25	; 37
    460c:	30 e0       	ldi	r19, 0x00	; 0
    460e:	f9 01       	movw	r30, r18
    4610:	20 81       	ld	r18, Z
    4612:	62 2f       	mov	r22, r18
    4614:	40 e0       	ldi	r20, 0x00	; 0
    4616:	50 e0       	ldi	r21, 0x00	; 0
    4618:	21 e0       	ldi	r18, 0x01	; 1
    461a:	30 e0       	ldi	r19, 0x00	; 0
    461c:	02 c0       	rjmp	.+4      	; 0x4622 <initializeSPI+0xa6>
    461e:	22 0f       	add	r18, r18
    4620:	33 1f       	adc	r19, r19
    4622:	4a 95       	dec	r20
    4624:	e2 f7       	brpl	.-8      	; 0x461e <initializeSPI+0xa2>
    4626:	26 2b       	or	r18, r22
    4628:	fc 01       	movw	r30, r24
    462a:	20 83       	st	Z, r18
	PORTB &= ~(1 << sck_pin);
    462c:	85 e2       	ldi	r24, 0x25	; 37
    462e:	90 e0       	ldi	r25, 0x00	; 0
    4630:	25 e2       	ldi	r18, 0x25	; 37
    4632:	30 e0       	ldi	r19, 0x00	; 0
    4634:	f9 01       	movw	r30, r18
    4636:	20 81       	ld	r18, Z
    4638:	62 2f       	mov	r22, r18
    463a:	41 e0       	ldi	r20, 0x01	; 1
    463c:	50 e0       	ldi	r21, 0x00	; 0
    463e:	21 e0       	ldi	r18, 0x01	; 1
    4640:	30 e0       	ldi	r19, 0x00	; 0
    4642:	04 2e       	mov	r0, r20
    4644:	02 c0       	rjmp	.+4      	; 0x464a <initializeSPI+0xce>
    4646:	22 0f       	add	r18, r18
    4648:	33 1f       	adc	r19, r19
    464a:	0a 94       	dec	r0
    464c:	e2 f7       	brpl	.-8      	; 0x4646 <initializeSPI+0xca>
    464e:	20 95       	com	r18
    4650:	26 23       	and	r18, r22
    4652:	fc 01       	movw	r30, r24
    4654:	20 83       	st	Z, r18
}
    4656:	df 91       	pop	r29
    4658:	cf 91       	pop	r28
    465a:	08 95       	ret

0000465c <SPIsendByte>:

void SPIsendByte(unsigned char byte){
    465c:	cf 93       	push	r28
    465e:	df 93       	push	r29
    4660:	1f 92       	push	r1
    4662:	cd b7       	in	r28, 0x3d	; 61
    4664:	de b7       	in	r29, 0x3e	; 62
    4666:	89 83       	std	Y+1, r24	; 0x01
	PORTB &= ~(1 << ss_pin);
    4668:	85 e2       	ldi	r24, 0x25	; 37
    466a:	90 e0       	ldi	r25, 0x00	; 0
    466c:	25 e2       	ldi	r18, 0x25	; 37
    466e:	30 e0       	ldi	r19, 0x00	; 0
    4670:	f9 01       	movw	r30, r18
    4672:	20 81       	ld	r18, Z
    4674:	62 2f       	mov	r22, r18
    4676:	40 e0       	ldi	r20, 0x00	; 0
    4678:	50 e0       	ldi	r21, 0x00	; 0
    467a:	21 e0       	ldi	r18, 0x01	; 1
    467c:	30 e0       	ldi	r19, 0x00	; 0
    467e:	02 c0       	rjmp	.+4      	; 0x4684 <SPIsendByte+0x28>
    4680:	22 0f       	add	r18, r18
    4682:	33 1f       	adc	r19, r19
    4684:	4a 95       	dec	r20
    4686:	e2 f7       	brpl	.-8      	; 0x4680 <SPIsendByte+0x24>
    4688:	20 95       	com	r18
    468a:	26 23       	and	r18, r22
    468c:	fc 01       	movw	r30, r24
    468e:	20 83       	st	Z, r18
	vTaskDelay(1);
    4690:	81 e0       	ldi	r24, 0x01	; 1
    4692:	90 e0       	ldi	r25, 0x00	; 0
    4694:	0e 94 6f 04 	call	0x8de	; 0x8de <vTaskDelay>
	SPDR = byte;
    4698:	8e e4       	ldi	r24, 0x4E	; 78
    469a:	90 e0       	ldi	r25, 0x00	; 0
    469c:	29 81       	ldd	r18, Y+1	; 0x01
    469e:	fc 01       	movw	r30, r24
    46a0:	20 83       	st	Z, r18
	while((SPSR & (1 << SPIF)) == 0)
    46a2:	00 00       	nop
    46a4:	8d e4       	ldi	r24, 0x4D	; 77
    46a6:	90 e0       	ldi	r25, 0x00	; 0
    46a8:	fc 01       	movw	r30, r24
    46aa:	80 81       	ld	r24, Z
    46ac:	88 23       	and	r24, r24
    46ae:	d4 f7       	brge	.-12     	; 0x46a4 <SPIsendByte+0x48>
	;
	vTaskDelay(1);
    46b0:	81 e0       	ldi	r24, 0x01	; 1
    46b2:	90 e0       	ldi	r25, 0x00	; 0
    46b4:	0e 94 6f 04 	call	0x8de	; 0x8de <vTaskDelay>
	PORTB |= (1 << ss_pin);
    46b8:	85 e2       	ldi	r24, 0x25	; 37
    46ba:	90 e0       	ldi	r25, 0x00	; 0
    46bc:	25 e2       	ldi	r18, 0x25	; 37
    46be:	30 e0       	ldi	r19, 0x00	; 0
    46c0:	f9 01       	movw	r30, r18
    46c2:	20 81       	ld	r18, Z
    46c4:	62 2f       	mov	r22, r18
    46c6:	40 e0       	ldi	r20, 0x00	; 0
    46c8:	50 e0       	ldi	r21, 0x00	; 0
    46ca:	21 e0       	ldi	r18, 0x01	; 1
    46cc:	30 e0       	ldi	r19, 0x00	; 0
    46ce:	04 2e       	mov	r0, r20
    46d0:	02 c0       	rjmp	.+4      	; 0x46d6 <SPIsendByte+0x7a>
    46d2:	22 0f       	add	r18, r18
    46d4:	33 1f       	adc	r19, r19
    46d6:	0a 94       	dec	r0
    46d8:	e2 f7       	brpl	.-8      	; 0x46d2 <SPIsendByte+0x76>
    46da:	26 2b       	or	r18, r22
    46dc:	fc 01       	movw	r30, r24
    46de:	20 83       	st	Z, r18

}
    46e0:	0f 90       	pop	r0
    46e2:	df 91       	pop	r29
    46e4:	cf 91       	pop	r28
    46e6:	08 95       	ret

000046e8 <SPIsendShort>:

void SPIsendShort(unsigned short data){
    46e8:	cf 93       	push	r28
    46ea:	df 93       	push	r29
    46ec:	1f 92       	push	r1
    46ee:	1f 92       	push	r1
    46f0:	cd b7       	in	r28, 0x3d	; 61
    46f2:	de b7       	in	r29, 0x3e	; 62
    46f4:	9a 83       	std	Y+2, r25	; 0x02
    46f6:	89 83       	std	Y+1, r24	; 0x01
	PORTB &= ~(1 << ss_pin);
    46f8:	85 e2       	ldi	r24, 0x25	; 37
    46fa:	90 e0       	ldi	r25, 0x00	; 0
    46fc:	25 e2       	ldi	r18, 0x25	; 37
    46fe:	30 e0       	ldi	r19, 0x00	; 0
    4700:	f9 01       	movw	r30, r18
    4702:	20 81       	ld	r18, Z
    4704:	62 2f       	mov	r22, r18
    4706:	40 e0       	ldi	r20, 0x00	; 0
    4708:	50 e0       	ldi	r21, 0x00	; 0
    470a:	21 e0       	ldi	r18, 0x01	; 1
    470c:	30 e0       	ldi	r19, 0x00	; 0
    470e:	02 c0       	rjmp	.+4      	; 0x4714 <SPIsendShort+0x2c>
    4710:	22 0f       	add	r18, r18
    4712:	33 1f       	adc	r19, r19
    4714:	4a 95       	dec	r20
    4716:	e2 f7       	brpl	.-8      	; 0x4710 <SPIsendShort+0x28>
    4718:	20 95       	com	r18
    471a:	26 23       	and	r18, r22
    471c:	fc 01       	movw	r30, r24
    471e:	20 83       	st	Z, r18
	vTaskDelay(2);
    4720:	82 e0       	ldi	r24, 0x02	; 2
    4722:	90 e0       	ldi	r25, 0x00	; 0
    4724:	0e 94 6f 04 	call	0x8de	; 0x8de <vTaskDelay>
	SPDR = (data >> 8);
    4728:	8e e4       	ldi	r24, 0x4E	; 78
    472a:	90 e0       	ldi	r25, 0x00	; 0
    472c:	29 81       	ldd	r18, Y+1	; 0x01
    472e:	3a 81       	ldd	r19, Y+2	; 0x02
    4730:	23 2f       	mov	r18, r19
    4732:	33 27       	eor	r19, r19
    4734:	fc 01       	movw	r30, r24
    4736:	20 83       	st	Z, r18
	while((SPSR & (1 << SPIF)) == 0)
    4738:	00 00       	nop
    473a:	8d e4       	ldi	r24, 0x4D	; 77
    473c:	90 e0       	ldi	r25, 0x00	; 0
    473e:	fc 01       	movw	r30, r24
    4740:	80 81       	ld	r24, Z
    4742:	88 23       	and	r24, r24
    4744:	d4 f7       	brge	.-12     	; 0x473a <SPIsendShort+0x52>
	;
	SPDR = data & 0xFF;
    4746:	8e e4       	ldi	r24, 0x4E	; 78
    4748:	90 e0       	ldi	r25, 0x00	; 0
    474a:	29 81       	ldd	r18, Y+1	; 0x01
    474c:	fc 01       	movw	r30, r24
    474e:	20 83       	st	Z, r18
	while((SPSR & (1 << SPIF)) == 0)
    4750:	00 00       	nop
    4752:	8d e4       	ldi	r24, 0x4D	; 77
    4754:	90 e0       	ldi	r25, 0x00	; 0
    4756:	fc 01       	movw	r30, r24
    4758:	80 81       	ld	r24, Z
    475a:	88 23       	and	r24, r24
    475c:	d4 f7       	brge	.-12     	; 0x4752 <SPIsendShort+0x6a>
	;
	vTaskDelay(2);
    475e:	82 e0       	ldi	r24, 0x02	; 2
    4760:	90 e0       	ldi	r25, 0x00	; 0
    4762:	0e 94 6f 04 	call	0x8de	; 0x8de <vTaskDelay>
	PORTB |= (1 << ss_pin);
    4766:	85 e2       	ldi	r24, 0x25	; 37
    4768:	90 e0       	ldi	r25, 0x00	; 0
    476a:	25 e2       	ldi	r18, 0x25	; 37
    476c:	30 e0       	ldi	r19, 0x00	; 0
    476e:	f9 01       	movw	r30, r18
    4770:	20 81       	ld	r18, Z
    4772:	62 2f       	mov	r22, r18
    4774:	40 e0       	ldi	r20, 0x00	; 0
    4776:	50 e0       	ldi	r21, 0x00	; 0
    4778:	21 e0       	ldi	r18, 0x01	; 1
    477a:	30 e0       	ldi	r19, 0x00	; 0
    477c:	04 2e       	mov	r0, r20
    477e:	02 c0       	rjmp	.+4      	; 0x4784 <SPIsendShort+0x9c>
    4780:	22 0f       	add	r18, r18
    4782:	33 1f       	adc	r19, r19
    4784:	0a 94       	dec	r0
    4786:	e2 f7       	brpl	.-8      	; 0x4780 <SPIsendShort+0x98>
    4788:	26 2b       	or	r18, r22
    478a:	fc 01       	movw	r30, r24
    478c:	20 83       	st	Z, r18
}
    478e:	0f 90       	pop	r0
    4790:	0f 90       	pop	r0
    4792:	df 91       	pop	r29
    4794:	cf 91       	pop	r28
    4796:	08 95       	ret

00004798 <__tablejump2__>:
    4798:	ee 0f       	add	r30, r30
    479a:	ff 1f       	adc	r31, r31

0000479c <__tablejump__>:
    479c:	05 90       	lpm	r0, Z+
    479e:	f4 91       	lpm	r31, Z
    47a0:	e0 2d       	mov	r30, r0
    47a2:	19 94       	eijmp

000047a4 <memcpy>:
    47a4:	fb 01       	movw	r30, r22
    47a6:	dc 01       	movw	r26, r24
    47a8:	02 c0       	rjmp	.+4      	; 0x47ae <memcpy+0xa>
    47aa:	01 90       	ld	r0, Z+
    47ac:	0d 92       	st	X+, r0
    47ae:	41 50       	subi	r20, 0x01	; 1
    47b0:	50 40       	sbci	r21, 0x00	; 0
    47b2:	d8 f7       	brcc	.-10     	; 0x47aa <memcpy+0x6>
    47b4:	08 95       	ret

000047b6 <memset>:
    47b6:	dc 01       	movw	r26, r24
    47b8:	01 c0       	rjmp	.+2      	; 0x47bc <memset+0x6>
    47ba:	6d 93       	st	X+, r22
    47bc:	41 50       	subi	r20, 0x01	; 1
    47be:	50 40       	sbci	r21, 0x00	; 0
    47c0:	e0 f7       	brcc	.-8      	; 0x47ba <memset+0x4>
    47c2:	08 95       	ret

000047c4 <strncpy>:
    47c4:	fb 01       	movw	r30, r22
    47c6:	dc 01       	movw	r26, r24
    47c8:	41 50       	subi	r20, 0x01	; 1
    47ca:	50 40       	sbci	r21, 0x00	; 0
    47cc:	48 f0       	brcs	.+18     	; 0x47e0 <strncpy+0x1c>
    47ce:	01 90       	ld	r0, Z+
    47d0:	0d 92       	st	X+, r0
    47d2:	00 20       	and	r0, r0
    47d4:	c9 f7       	brne	.-14     	; 0x47c8 <strncpy+0x4>
    47d6:	01 c0       	rjmp	.+2      	; 0x47da <strncpy+0x16>
    47d8:	1d 92       	st	X+, r1
    47da:	41 50       	subi	r20, 0x01	; 1
    47dc:	50 40       	sbci	r21, 0x00	; 0
    47de:	e0 f7       	brcc	.-8      	; 0x47d8 <strncpy+0x14>
    47e0:	08 95       	ret

000047e2 <itoa>:
    47e2:	fb 01       	movw	r30, r22
    47e4:	9f 01       	movw	r18, r30
    47e6:	e8 94       	clt
    47e8:	42 30       	cpi	r20, 0x02	; 2
    47ea:	c4 f0       	brlt	.+48     	; 0x481c <itoa+0x3a>
    47ec:	45 32       	cpi	r20, 0x25	; 37
    47ee:	b4 f4       	brge	.+44     	; 0x481c <itoa+0x3a>
    47f0:	4a 30       	cpi	r20, 0x0A	; 10
    47f2:	29 f4       	brne	.+10     	; 0x47fe <itoa+0x1c>
    47f4:	97 fb       	bst	r25, 7
    47f6:	1e f4       	brtc	.+6      	; 0x47fe <itoa+0x1c>
    47f8:	90 95       	com	r25
    47fa:	81 95       	neg	r24
    47fc:	9f 4f       	sbci	r25, 0xFF	; 255
    47fe:	64 2f       	mov	r22, r20
    4800:	77 27       	eor	r23, r23
    4802:	0e 94 22 24 	call	0x4844	; 0x4844 <__udivmodhi4>
    4806:	80 5d       	subi	r24, 0xD0	; 208
    4808:	8a 33       	cpi	r24, 0x3A	; 58
    480a:	0c f0       	brlt	.+2      	; 0x480e <itoa+0x2c>
    480c:	89 5d       	subi	r24, 0xD9	; 217
    480e:	81 93       	st	Z+, r24
    4810:	cb 01       	movw	r24, r22
    4812:	00 97       	sbiw	r24, 0x00	; 0
    4814:	a1 f7       	brne	.-24     	; 0x47fe <itoa+0x1c>
    4816:	16 f4       	brtc	.+4      	; 0x481c <itoa+0x3a>
    4818:	5d e2       	ldi	r21, 0x2D	; 45
    481a:	51 93       	st	Z+, r21
    481c:	10 82       	st	Z, r1
    481e:	c9 01       	movw	r24, r18
    4820:	0c 94 12 24 	jmp	0x4824	; 0x4824 <strrev>

00004824 <strrev>:
    4824:	dc 01       	movw	r26, r24
    4826:	fc 01       	movw	r30, r24
    4828:	67 2f       	mov	r22, r23
    482a:	71 91       	ld	r23, Z+
    482c:	77 23       	and	r23, r23
    482e:	e1 f7       	brne	.-8      	; 0x4828 <strrev+0x4>
    4830:	32 97       	sbiw	r30, 0x02	; 2
    4832:	04 c0       	rjmp	.+8      	; 0x483c <strrev+0x18>
    4834:	7c 91       	ld	r23, X
    4836:	6d 93       	st	X+, r22
    4838:	70 83       	st	Z, r23
    483a:	62 91       	ld	r22, -Z
    483c:	ae 17       	cp	r26, r30
    483e:	bf 07       	cpc	r27, r31
    4840:	c8 f3       	brcs	.-14     	; 0x4834 <strrev+0x10>
    4842:	08 95       	ret

00004844 <__udivmodhi4>:
    4844:	aa 1b       	sub	r26, r26
    4846:	bb 1b       	sub	r27, r27
    4848:	51 e1       	ldi	r21, 0x11	; 17
    484a:	07 c0       	rjmp	.+14     	; 0x485a <__udivmodhi4_ep>

0000484c <__udivmodhi4_loop>:
    484c:	aa 1f       	adc	r26, r26
    484e:	bb 1f       	adc	r27, r27
    4850:	a6 17       	cp	r26, r22
    4852:	b7 07       	cpc	r27, r23
    4854:	10 f0       	brcs	.+4      	; 0x485a <__udivmodhi4_ep>
    4856:	a6 1b       	sub	r26, r22
    4858:	b7 0b       	sbc	r27, r23

0000485a <__udivmodhi4_ep>:
    485a:	88 1f       	adc	r24, r24
    485c:	99 1f       	adc	r25, r25
    485e:	5a 95       	dec	r21
    4860:	a9 f7       	brne	.-22     	; 0x484c <__udivmodhi4_loop>
    4862:	80 95       	com	r24
    4864:	90 95       	com	r25
    4866:	bc 01       	movw	r22, r24
    4868:	cd 01       	movw	r24, r26
    486a:	08 95       	ret

0000486c <_exit>:
    486c:	f8 94       	cli

0000486e <__stop_program>:
    486e:	ff cf       	rjmp	.-2      	; 0x486e <__stop_program>
