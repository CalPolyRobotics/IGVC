
rtosdemo.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001a  00800200  00003e96  00003f2a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003e96  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000018b3  0080021a  0080021a  00003f44  2**0
                  ALLOC
  3 .stab         00008670  00000000  00000000  00003f44  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00003cbe  00000000  00000000  0000c5b4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 72 00 	jmp	0xe4	; 0xe4 <__ctors_end>
       4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
       8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
       c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      10:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      14:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      18:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      1c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      20:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      24:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      28:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      2c:	0c 94 a4 1c 	jmp	0x3948	; 0x3948 <__vector_11>
      30:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      34:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      38:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      3c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      40:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      44:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      48:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      4c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      50:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      54:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      58:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      5c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      60:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      64:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      68:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      6c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      70:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      74:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      78:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      7c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      80:	0c 94 2b 18 	jmp	0x3056	; 0x3056 <__vector_32>
      84:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      88:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      8c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      90:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      94:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      98:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      9c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      a0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      a4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      a8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      ac:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      b0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      b4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      b8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      bc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      c0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      c4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      c8:	0c 94 ee 01 	jmp	0x3dc	; 0x3dc <__vector_50>
      cc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      d0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      d4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      d8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      dc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      e0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	12 e0       	ldi	r17, 0x02	; 2
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	e6 e9       	ldi	r30, 0x96	; 150
      fc:	fe e3       	ldi	r31, 0x3E	; 62
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	aa 31       	cpi	r26, 0x1A	; 26
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
     10e:	1a e1       	ldi	r17, 0x1A	; 26
     110:	aa e1       	ldi	r26, 0x1A	; 26
     112:	b2 e0       	ldi	r27, 0x02	; 2
     114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
     116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
     118:	ad 3c       	cpi	r26, 0xCD	; 205
     11a:	b1 07       	cpc	r27, r17
     11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
     11e:	0e 94 ac 00 	call	0x158	; 0x158 <main>
     122:	0c 94 49 1f 	jmp	0x3e92	; 0x3e92 <_exit>

00000126 <__bad_interrupt>:
     126:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000012a <vApplicationTickHook>:
int count = 0;

int sonarTime;

void vApplicationTickHook()
{
     12a:	df 93       	push	r29
     12c:	cf 93       	push	r28
     12e:	cd b7       	in	r28, 0x3d	; 61
     130:	de b7       	in	r29, 0x3e	; 62
    count++;
     132:	80 91 1a 02 	lds	r24, 0x021A
     136:	90 91 1b 02 	lds	r25, 0x021B
     13a:	01 96       	adiw	r24, 0x01	; 1
     13c:	90 93 1b 02 	sts	0x021B, r25
     140:	80 93 1a 02 	sts	0x021A, r24
}
     144:	cf 91       	pop	r28
     146:	df 91       	pop	r29
     148:	08 95       	ret

0000014a <vApplicationStackOverflowHook>:

void vApplicationStackOverflowHook(){
     14a:	df 93       	push	r29
     14c:	cf 93       	push	r28
     14e:	cd b7       	in	r28, 0x3d	; 61
     150:	de b7       	in	r29, 0x3e	; 62
	return;
}
     152:	cf 91       	pop	r28
     154:	df 91       	pop	r29
     156:	08 95       	ret

00000158 <main>:
/*-----------------------------------------------------------*/

int main( void )
{
     158:	af 92       	push	r10
     15a:	bf 92       	push	r11
     15c:	cf 92       	push	r12
     15e:	df 92       	push	r13
     160:	ef 92       	push	r14
     162:	ff 92       	push	r15
     164:	0f 93       	push	r16
     166:	df 93       	push	r29
     168:	cf 93       	push	r28
     16a:	00 d0       	rcall	.+0      	; 0x16c <main+0x14>
     16c:	00 d0       	rcall	.+0      	; 0x16e <main+0x16>
     16e:	cd b7       	in	r28, 0x3d	; 61
     170:	de b7       	in	r29, 0x3e	; 62
    
    //- wimpy variable defs
	uint8_t val[2] = {0x3F, 0xFE};
     172:	8f e3       	ldi	r24, 0x3F	; 63
     174:	8d 83       	std	Y+5, r24	; 0x05
     176:	8e ef       	ldi	r24, 0xFE	; 254
     178:	8e 83       	std	Y+6, r24	; 0x06
    uint8_t *val0, *val1;
    
	//- avoid pesky warnings...
	val0 = val + 0;
     17a:	ce 01       	movw	r24, r28
     17c:	05 96       	adiw	r24, 0x05	; 5
     17e:	9c 83       	std	Y+4, r25	; 0x04
     180:	8b 83       	std	Y+3, r24	; 0x03
	val1 = val + 1;
     182:	ce 01       	movw	r24, r28
     184:	05 96       	adiw	r24, 0x05	; 5
     186:	01 96       	adiw	r24, 0x01	; 1
     188:	9a 83       	std	Y+2, r25	; 0x02
     18a:	89 83       	std	Y+1, r24	; 0x01
    
	DDRD = 0xFF;
     18c:	ea e2       	ldi	r30, 0x2A	; 42
     18e:	f0 e0       	ldi	r31, 0x00	; 0
     190:	8f ef       	ldi	r24, 0xFF	; 255
     192:	80 83       	st	Z, r24
	DDRE = 0xFF;
     194:	ed e2       	ldi	r30, 0x2D	; 45
     196:	f0 e0       	ldi	r31, 0x00	; 0
     198:	8f ef       	ldi	r24, 0xFF	; 255
     19a:	80 83       	st	Z, r24
	DDRK = 0;
     19c:	e7 e0       	ldi	r30, 0x07	; 7
     19e:	f1 e0       	ldi	r31, 0x01	; 1
     1a0:	10 82       	st	Z, r1

	PORTD = 0;
     1a2:	eb e2       	ldi	r30, 0x2B	; 43
     1a4:	f0 e0       	ldi	r31, 0x00	; 0
     1a6:	10 82       	st	Z, r1
	PORTE = 0;
     1a8:	ee e2       	ldi	r30, 0x2E	; 46
     1aa:	f0 e0       	ldi	r31, 0x00	; 0
     1ac:	10 82       	st	Z, r1
	PORTK = 2;
     1ae:	e8 e0       	ldi	r30, 0x08	; 8
     1b0:	f1 e0       	ldi	r31, 0x01	; 1
     1b2:	82 e0       	ldi	r24, 0x02	; 2
     1b4:	80 83       	st	Z, r24

    //- init IO with goodness
	vIO_init();
     1b6:	0e 94 3f 02 	call	0x47e	; 0x47e <vIO_init>

	//- Create a 
	xTaskCreate( (pdTASK_CODE) vTaskFunction_1, (signed char *) "T0", configMINIMAL_STACK_SIZE+1000,
     1ba:	87 e2       	ldi	r24, 0x27	; 39
     1bc:	92 e0       	ldi	r25, 0x02	; 2
     1be:	20 e0       	ldi	r18, 0x00	; 0
     1c0:	32 e0       	ldi	r19, 0x02	; 2
     1c2:	e9 81       	ldd	r30, Y+1	; 0x01
     1c4:	fa 81       	ldd	r31, Y+2	; 0x02
     1c6:	b9 01       	movw	r22, r18
     1c8:	4d e3       	ldi	r20, 0x3D	; 61
     1ca:	54 e0       	ldi	r21, 0x04	; 4
     1cc:	9f 01       	movw	r18, r30
     1ce:	01 e0       	ldi	r16, 0x01	; 1
     1d0:	ee 24       	eor	r14, r14
     1d2:	ff 24       	eor	r15, r15
     1d4:	cc 24       	eor	r12, r12
     1d6:	dd 24       	eor	r13, r13
     1d8:	aa 24       	eor	r10, r10
     1da:	bb 24       	eor	r11, r11
     1dc:	0e 94 4d 02 	call	0x49a	; 0x49a <xTaskGenericCreate>
                (void *) val1, 1, NULL );
    
   xTaskCreate( (pdTASK_CODE) vTaskSonar, (signed char *) "T0", configMINIMAL_STACK_SIZE,
     1e0:	8f e2       	ldi	r24, 0x2F	; 47
     1e2:	9d e1       	ldi	r25, 0x1D	; 29
     1e4:	20 e0       	ldi	r18, 0x00	; 0
     1e6:	32 e0       	ldi	r19, 0x02	; 2
     1e8:	e9 81       	ldd	r30, Y+1	; 0x01
     1ea:	fa 81       	ldd	r31, Y+2	; 0x02
     1ec:	b9 01       	movw	r22, r18
     1ee:	45 e5       	ldi	r20, 0x55	; 85
     1f0:	50 e0       	ldi	r21, 0x00	; 0
     1f2:	9f 01       	movw	r18, r30
     1f4:	01 e0       	ldi	r16, 0x01	; 1
     1f6:	ee 24       	eor	r14, r14
     1f8:	ff 24       	eor	r15, r15
     1fa:	cc 24       	eor	r12, r12
     1fc:	dd 24       	eor	r13, r13
     1fe:	aa 24       	eor	r10, r10
     200:	bb 24       	eor	r11, r11
     202:	0e 94 4d 02 	call	0x49a	; 0x49a <xTaskGenericCreate>
                (void *) val1, 1, NULL );

   xTaskCreate( (pdTASK_CODE) vTaskUARTWrite, (signed char *) "T0", configMINIMAL_STACK_SIZE,
     206:	82 e3       	ldi	r24, 0x32	; 50
     208:	99 e1       	ldi	r25, 0x19	; 25
     20a:	20 e0       	ldi	r18, 0x00	; 0
     20c:	32 e0       	ldi	r19, 0x02	; 2
     20e:	e9 81       	ldd	r30, Y+1	; 0x01
     210:	fa 81       	ldd	r31, Y+2	; 0x02
     212:	b9 01       	movw	r22, r18
     214:	45 e5       	ldi	r20, 0x55	; 85
     216:	50 e0       	ldi	r21, 0x00	; 0
     218:	9f 01       	movw	r18, r30
     21a:	01 e0       	ldi	r16, 0x01	; 1
     21c:	ee 24       	eor	r14, r14
     21e:	ff 24       	eor	r15, r15
     220:	cc 24       	eor	r12, r12
     222:	dd 24       	eor	r13, r13
     224:	aa 24       	eor	r10, r10
     226:	bb 24       	eor	r11, r11
     228:	0e 94 4d 02 	call	0x49a	; 0x49a <xTaskGenericCreate>
   				(void *) val1, 1, NULL);

   xTaskCreate( (pdTASK_CODE) vTaskUARTRead, (signed char *) "T0", configMINIMAL_STACK_SIZE,
     22c:	8b e5       	ldi	r24, 0x5B	; 91
     22e:	99 e1       	ldi	r25, 0x19	; 25
     230:	20 e0       	ldi	r18, 0x00	; 0
     232:	32 e0       	ldi	r19, 0x02	; 2
     234:	e9 81       	ldd	r30, Y+1	; 0x01
     236:	fa 81       	ldd	r31, Y+2	; 0x02
     238:	b9 01       	movw	r22, r18
     23a:	45 e5       	ldi	r20, 0x55	; 85
     23c:	50 e0       	ldi	r21, 0x00	; 0
     23e:	9f 01       	movw	r18, r30
     240:	01 e0       	ldi	r16, 0x01	; 1
     242:	ee 24       	eor	r14, r14
     244:	ff 24       	eor	r15, r15
     246:	cc 24       	eor	r12, r12
     248:	dd 24       	eor	r13, r13
     24a:	aa 24       	eor	r10, r10
     24c:	bb 24       	eor	r11, r11
     24e:	0e 94 4d 02 	call	0x49a	; 0x49a <xTaskGenericCreate>
   				(void *) val1, 1, NULL);

    
    //- kick off the scheduler
	vTaskStartScheduler();
     252:	0e 94 42 05 	call	0xa84	; 0xa84 <vTaskStartScheduler>
    
	return 0;
     256:	80 e0       	ldi	r24, 0x00	; 0
     258:	90 e0       	ldi	r25, 0x00	; 0
}
     25a:	26 96       	adiw	r28, 0x06	; 6
     25c:	0f b6       	in	r0, 0x3f	; 63
     25e:	f8 94       	cli
     260:	de bf       	out	0x3e, r29	; 62
     262:	0f be       	out	0x3f, r0	; 63
     264:	cd bf       	out	0x3d, r28	; 61
     266:	cf 91       	pop	r28
     268:	df 91       	pop	r29
     26a:	0f 91       	pop	r16
     26c:	ff 90       	pop	r15
     26e:	ef 90       	pop	r14
     270:	df 90       	pop	r13
     272:	cf 90       	pop	r12
     274:	bf 90       	pop	r11
     276:	af 90       	pop	r10
     278:	08 95       	ret

0000027a <printHex>:
/*-----------------------------------------------------------*/

void printHex(int i){
     27a:	df 93       	push	r29
     27c:	cf 93       	push	r28
     27e:	cd b7       	in	r28, 0x3d	; 61
     280:	de b7       	in	r29, 0x3e	; 62
     282:	67 97       	sbiw	r28, 0x17	; 23
     284:	0f b6       	in	r0, 0x3f	; 63
     286:	f8 94       	cli
     288:	de bf       	out	0x3e, r29	; 62
     28a:	0f be       	out	0x3f, r0	; 63
     28c:	cd bf       	out	0x3d, r28	; 61
     28e:	9a 8b       	std	Y+18, r25	; 0x12
     290:	89 8b       	std	Y+17, r24	; 0x11
	char hex[] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
     292:	ce 01       	movw	r24, r28
     294:	01 96       	adiw	r24, 0x01	; 1
     296:	9c 8b       	std	Y+20, r25	; 0x14
     298:	8b 8b       	std	Y+19, r24	; 0x13
     29a:	e3 e0       	ldi	r30, 0x03	; 3
     29c:	f2 e0       	ldi	r31, 0x02	; 2
     29e:	fe 8b       	std	Y+22, r31	; 0x16
     2a0:	ed 8b       	std	Y+21, r30	; 0x15
     2a2:	f0 e1       	ldi	r31, 0x10	; 16
     2a4:	ff 8b       	std	Y+23, r31	; 0x17
     2a6:	ed 89       	ldd	r30, Y+21	; 0x15
     2a8:	fe 89       	ldd	r31, Y+22	; 0x16
     2aa:	00 80       	ld	r0, Z
     2ac:	8d 89       	ldd	r24, Y+21	; 0x15
     2ae:	9e 89       	ldd	r25, Y+22	; 0x16
     2b0:	01 96       	adiw	r24, 0x01	; 1
     2b2:	9e 8b       	std	Y+22, r25	; 0x16
     2b4:	8d 8b       	std	Y+21, r24	; 0x15
     2b6:	eb 89       	ldd	r30, Y+19	; 0x13
     2b8:	fc 89       	ldd	r31, Y+20	; 0x14
     2ba:	00 82       	st	Z, r0
     2bc:	8b 89       	ldd	r24, Y+19	; 0x13
     2be:	9c 89       	ldd	r25, Y+20	; 0x14
     2c0:	01 96       	adiw	r24, 0x01	; 1
     2c2:	9c 8b       	std	Y+20, r25	; 0x14
     2c4:	8b 8b       	std	Y+19, r24	; 0x13
     2c6:	9f 89       	ldd	r25, Y+23	; 0x17
     2c8:	91 50       	subi	r25, 0x01	; 1
     2ca:	9f 8b       	std	Y+23, r25	; 0x17
     2cc:	ef 89       	ldd	r30, Y+23	; 0x17
     2ce:	ee 23       	and	r30, r30
     2d0:	51 f7       	brne	.-44     	; 0x2a6 <printHex+0x2c>

	USART_Write(hex[(i&0xF000) >> 12]);
     2d2:	89 89       	ldd	r24, Y+17	; 0x11
     2d4:	9a 89       	ldd	r25, Y+18	; 0x12
     2d6:	9c 01       	movw	r18, r24
     2d8:	23 2f       	mov	r18, r19
     2da:	33 27       	eor	r19, r19
     2dc:	22 95       	swap	r18
     2de:	2f 70       	andi	r18, 0x0F	; 15
     2e0:	ce 01       	movw	r24, r28
     2e2:	01 96       	adiw	r24, 0x01	; 1
     2e4:	fc 01       	movw	r30, r24
     2e6:	e2 0f       	add	r30, r18
     2e8:	f3 1f       	adc	r31, r19
     2ea:	80 81       	ld	r24, Z
     2ec:	0e 94 9f 18 	call	0x313e	; 0x313e <USART_Write>
	USART_Write(hex[(i&0xF00) >> 8]);
     2f0:	89 89       	ldd	r24, Y+17	; 0x11
     2f2:	9a 89       	ldd	r25, Y+18	; 0x12
     2f4:	80 70       	andi	r24, 0x00	; 0
     2f6:	9f 70       	andi	r25, 0x0F	; 15
     2f8:	29 2f       	mov	r18, r25
     2fa:	33 27       	eor	r19, r19
     2fc:	27 fd       	sbrc	r18, 7
     2fe:	3a 95       	dec	r19
     300:	ce 01       	movw	r24, r28
     302:	01 96       	adiw	r24, 0x01	; 1
     304:	fc 01       	movw	r30, r24
     306:	e2 0f       	add	r30, r18
     308:	f3 1f       	adc	r31, r19
     30a:	80 81       	ld	r24, Z
     30c:	0e 94 9f 18 	call	0x313e	; 0x313e <USART_Write>
	USART_Write(hex[(i&0xF0) >> 4]);
     310:	89 89       	ldd	r24, Y+17	; 0x11
     312:	9a 89       	ldd	r25, Y+18	; 0x12
     314:	80 7f       	andi	r24, 0xF0	; 240
     316:	90 70       	andi	r25, 0x00	; 0
     318:	9c 01       	movw	r18, r24
     31a:	35 95       	asr	r19
     31c:	27 95       	ror	r18
     31e:	35 95       	asr	r19
     320:	27 95       	ror	r18
     322:	35 95       	asr	r19
     324:	27 95       	ror	r18
     326:	35 95       	asr	r19
     328:	27 95       	ror	r18
     32a:	ce 01       	movw	r24, r28
     32c:	01 96       	adiw	r24, 0x01	; 1
     32e:	fc 01       	movw	r30, r24
     330:	e2 0f       	add	r30, r18
     332:	f3 1f       	adc	r31, r19
     334:	80 81       	ld	r24, Z
     336:	0e 94 9f 18 	call	0x313e	; 0x313e <USART_Write>
	USART_Write(hex[i&0xF]);
     33a:	89 89       	ldd	r24, Y+17	; 0x11
     33c:	9a 89       	ldd	r25, Y+18	; 0x12
     33e:	9c 01       	movw	r18, r24
     340:	2f 70       	andi	r18, 0x0F	; 15
     342:	30 70       	andi	r19, 0x00	; 0
     344:	ce 01       	movw	r24, r28
     346:	01 96       	adiw	r24, 0x01	; 1
     348:	fc 01       	movw	r30, r24
     34a:	e2 0f       	add	r30, r18
     34c:	f3 1f       	adc	r31, r19
     34e:	80 81       	ld	r24, Z
     350:	0e 94 9f 18 	call	0x313e	; 0x313e <USART_Write>

}
     354:	67 96       	adiw	r28, 0x17	; 23
     356:	0f b6       	in	r0, 0x3f	; 63
     358:	f8 94       	cli
     35a:	de bf       	out	0x3e, r29	; 62
     35c:	0f be       	out	0x3f, r0	; 63
     35e:	cd bf       	out	0x3d, r28	; 61
     360:	cf 91       	pop	r28
     362:	df 91       	pop	r29
     364:	08 95       	ret

00000366 <printNum>:

void printNum(unsigned char i){
     366:	df 93       	push	r29
     368:	cf 93       	push	r28
     36a:	cd b7       	in	r28, 0x3d	; 61
     36c:	de b7       	in	r29, 0x3e	; 62
     36e:	2d 97       	sbiw	r28, 0x0d	; 13
     370:	0f b6       	in	r0, 0x3f	; 63
     372:	f8 94       	cli
     374:	de bf       	out	0x3e, r29	; 62
     376:	0f be       	out	0x3f, r0	; 63
     378:	cd bf       	out	0x3d, r28	; 61
     37a:	8d 87       	std	Y+13, r24	; 0x0d
    
    char str[10];
    memset(str,0,10);
     37c:	ce 01       	movw	r24, r28
     37e:	03 96       	adiw	r24, 0x03	; 3
     380:	60 e0       	ldi	r22, 0x00	; 0
     382:	70 e0       	ldi	r23, 0x00	; 0
     384:	4a e0       	ldi	r20, 0x0A	; 10
     386:	50 e0       	ldi	r21, 0x00	; 0
     388:	0e 94 ee 1e 	call	0x3ddc	; 0x3ddc <memset>
    itoa(i,str,9);
     38c:	8d 85       	ldd	r24, Y+13	; 0x0d
     38e:	88 2f       	mov	r24, r24
     390:	90 e0       	ldi	r25, 0x00	; 0
     392:	9e 01       	movw	r18, r28
     394:	2d 5f       	subi	r18, 0xFD	; 253
     396:	3f 4f       	sbci	r19, 0xFF	; 255
     398:	b9 01       	movw	r22, r18
     39a:	49 e0       	ldi	r20, 0x09	; 9
     39c:	50 e0       	ldi	r21, 0x00	; 0
     39e:	0e 94 04 1f 	call	0x3e08	; 0x3e08 <itoa>
    char * irr = str;
     3a2:	ce 01       	movw	r24, r28
     3a4:	03 96       	adiw	r24, 0x03	; 3
     3a6:	9a 83       	std	Y+2, r25	; 0x02
     3a8:	89 83       	std	Y+1, r24	; 0x01
     3aa:	0a c0       	rjmp	.+20     	; 0x3c0 <printNum+0x5a>
    while(*irr){
        USART_Write((unsigned char )*irr);
     3ac:	e9 81       	ldd	r30, Y+1	; 0x01
     3ae:	fa 81       	ldd	r31, Y+2	; 0x02
     3b0:	80 81       	ld	r24, Z
     3b2:	0e 94 9f 18 	call	0x313e	; 0x313e <USART_Write>
        irr++;
     3b6:	89 81       	ldd	r24, Y+1	; 0x01
     3b8:	9a 81       	ldd	r25, Y+2	; 0x02
     3ba:	01 96       	adiw	r24, 0x01	; 1
     3bc:	9a 83       	std	Y+2, r25	; 0x02
     3be:	89 83       	std	Y+1, r24	; 0x01
    
    char str[10];
    memset(str,0,10);
    itoa(i,str,9);
    char * irr = str;
    while(*irr){
     3c0:	e9 81       	ldd	r30, Y+1	; 0x01
     3c2:	fa 81       	ldd	r31, Y+2	; 0x02
     3c4:	80 81       	ld	r24, Z
     3c6:	88 23       	and	r24, r24
     3c8:	89 f7       	brne	.-30     	; 0x3ac <printNum+0x46>
        USART_Write((unsigned char )*irr);
        irr++;
    }
    
}
     3ca:	2d 96       	adiw	r28, 0x0d	; 13
     3cc:	0f b6       	in	r0, 0x3f	; 63
     3ce:	f8 94       	cli
     3d0:	de bf       	out	0x3e, r29	; 62
     3d2:	0f be       	out	0x3f, r0	; 63
     3d4:	cd bf       	out	0x3d, r28	; 61
     3d6:	cf 91       	pop	r28
     3d8:	df 91       	pop	r29
     3da:	08 95       	ret

000003dc <__vector_50>:

ISR(TIMER5_OVF_vect){
     3dc:	1f 92       	push	r1
     3de:	0f 92       	push	r0
     3e0:	0f b6       	in	r0, 0x3f	; 63
     3e2:	0f 92       	push	r0
     3e4:	00 90 5b 00 	lds	r0, 0x005B
     3e8:	0f 92       	push	r0
     3ea:	11 24       	eor	r1, r1
     3ec:	8f 93       	push	r24
     3ee:	af 93       	push	r26
     3f0:	bf 93       	push	r27
     3f2:	ef 93       	push	r30
     3f4:	ff 93       	push	r31
     3f6:	df 93       	push	r29
     3f8:	cf 93       	push	r28
     3fa:	cd b7       	in	r28, 0x3d	; 61
     3fc:	de b7       	in	r29, 0x3e	; 62

	PORTB ^= 0xFF;
     3fe:	a5 e2       	ldi	r26, 0x25	; 37
     400:	b0 e0       	ldi	r27, 0x00	; 0
     402:	e5 e2       	ldi	r30, 0x25	; 37
     404:	f0 e0       	ldi	r31, 0x00	; 0
     406:	80 81       	ld	r24, Z
     408:	80 95       	com	r24
     40a:	8c 93       	st	X, r24
	TCNT3L = 0;
     40c:	e4 e9       	ldi	r30, 0x94	; 148
     40e:	f0 e0       	ldi	r31, 0x00	; 0
     410:	10 82       	st	Z, r1
	TCNT3H = 0;
     412:	e5 e9       	ldi	r30, 0x95	; 149
     414:	f0 e0       	ldi	r31, 0x00	; 0
     416:	10 82       	st	Z, r1

}
     418:	cf 91       	pop	r28
     41a:	df 91       	pop	r29
     41c:	ff 91       	pop	r31
     41e:	ef 91       	pop	r30
     420:	bf 91       	pop	r27
     422:	af 91       	pop	r26
     424:	8f 91       	pop	r24
     426:	0f 90       	pop	r0
     428:	00 92 5b 00 	sts	0x005B, r0
     42c:	0f 90       	pop	r0
     42e:	0f be       	out	0x3f, r0	; 63
     430:	0f 90       	pop	r0
     432:	1f 90       	pop	r1
     434:	18 95       	reti

00000436 <getTimerCount2>:

unsigned int getTimerCount2(){
     436:	df 93       	push	r29
     438:	cf 93       	push	r28
     43a:	cd b7       	in	r28, 0x3d	; 61
     43c:	de b7       	in	r29, 0x3e	; 62

	//volatile char timerLow = TCNT3L;

	return TCNT0;
     43e:	e6 e4       	ldi	r30, 0x46	; 70
     440:	f0 e0       	ldi	r31, 0x00	; 0
     442:	80 81       	ld	r24, Z
     444:	88 2f       	mov	r24, r24
     446:	90 e0       	ldi	r25, 0x00	; 0

}
     448:	cf 91       	pop	r28
     44a:	df 91       	pop	r29
     44c:	08 95       	ret

0000044e <vTaskFunction_1>:

void vTaskFunction_1(void *pvParameters)
{	
     44e:	df 93       	push	r29
     450:	cf 93       	push	r28
     452:	0f 92       	push	r0
     454:	0f 92       	push	r0
     456:	cd b7       	in	r28, 0x3d	; 61
     458:	de b7       	in	r29, 0x3e	; 62
     45a:	9a 83       	std	Y+2, r25	; 0x02
     45c:	89 83       	std	Y+1, r24	; 0x01
    USART_Init(9600, 16000000);
     45e:	80 e8       	ldi	r24, 0x80	; 128
     460:	95 e2       	ldi	r25, 0x25	; 37
     462:	40 e0       	ldi	r20, 0x00	; 0
     464:	54 e2       	ldi	r21, 0x24	; 36
     466:	64 ef       	ldi	r22, 0xF4	; 244
     468:	70 e0       	ldi	r23, 0x00	; 0
     46a:	0e 94 2e 18 	call	0x305c	; 0x305c <USART_Init>
	//static const char* str = "Hello World\n";
	for(;;){
		//PORTB = 0;
		USART_AddToQueue('%');
     46e:	85 e2       	ldi	r24, 0x25	; 37
     470:	0e 94 fe 18 	call	0x31fc	; 0x31fc <USART_AddToQueue>
		//USART_TransmitString("Hello World!\n");

		//USART_TransmitString("H\n");
		vTaskDelay(25);
     474:	89 e1       	ldi	r24, 0x19	; 25
     476:	90 e0       	ldi	r25, 0x00	; 0
     478:	0e 94 ae 03 	call	0x75c	; 0x75c <vTaskDelay>
     47c:	f8 cf       	rjmp	.-16     	; 0x46e <vTaskFunction_1+0x20>

0000047e <vIO_init>:
        // UDR0;
    }
}

void vIO_init(void)
{
     47e:	df 93       	push	r29
     480:	cf 93       	push	r28
     482:	cd b7       	in	r28, 0x3d	; 61
     484:	de b7       	in	r29, 0x3e	; 62
    //- set PortB as output
	DDRB = 0xFF; 
     486:	e4 e2       	ldi	r30, 0x24	; 36
     488:	f0 e0       	ldi	r31, 0x00	; 0
     48a:	8f ef       	ldi	r24, 0xFF	; 255
     48c:	80 83       	st	Z, r24
    PORTB = 0; 
     48e:	e5 e2       	ldi	r30, 0x25	; 37
     490:	f0 e0       	ldi	r31, 0x00	; 0
     492:	10 82       	st	Z, r1
}
     494:	cf 91       	pop	r28
     496:	df 91       	pop	r29
     498:	08 95       	ret

0000049a <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
     49a:	af 92       	push	r10
     49c:	bf 92       	push	r11
     49e:	cf 92       	push	r12
     4a0:	df 92       	push	r13
     4a2:	ef 92       	push	r14
     4a4:	ff 92       	push	r15
     4a6:	0f 93       	push	r16
     4a8:	1f 93       	push	r17
     4aa:	df 93       	push	r29
     4ac:	cf 93       	push	r28
     4ae:	cd b7       	in	r28, 0x3d	; 61
     4b0:	de b7       	in	r29, 0x3e	; 62
     4b2:	64 97       	sbiw	r28, 0x14	; 20
     4b4:	0f b6       	in	r0, 0x3f	; 63
     4b6:	f8 94       	cli
     4b8:	de bf       	out	0x3e, r29	; 62
     4ba:	0f be       	out	0x3f, r0	; 63
     4bc:	cd bf       	out	0x3d, r28	; 61
     4be:	9f 83       	std	Y+7, r25	; 0x07
     4c0:	8e 83       	std	Y+6, r24	; 0x06
     4c2:	79 87       	std	Y+9, r23	; 0x09
     4c4:	68 87       	std	Y+8, r22	; 0x08
     4c6:	5b 87       	std	Y+11, r21	; 0x0b
     4c8:	4a 87       	std	Y+10, r20	; 0x0a
     4ca:	3d 87       	std	Y+13, r19	; 0x0d
     4cc:	2c 87       	std	Y+12, r18	; 0x0c
     4ce:	0e 87       	std	Y+14, r16	; 0x0e
     4d0:	f8 8a       	std	Y+16, r15	; 0x10
     4d2:	ef 86       	std	Y+15, r14	; 0x0f
     4d4:	da 8a       	std	Y+18, r13	; 0x12
     4d6:	c9 8a       	std	Y+17, r12	; 0x11
     4d8:	bc 8a       	std	Y+20, r11	; 0x14
     4da:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
     4dc:	8a 85       	ldd	r24, Y+10	; 0x0a
     4de:	9b 85       	ldd	r25, Y+11	; 0x0b
     4e0:	29 89       	ldd	r18, Y+17	; 0x11
     4e2:	3a 89       	ldd	r19, Y+18	; 0x12
     4e4:	b9 01       	movw	r22, r18
     4e6:	0e 94 dc 09 	call	0x13b8	; 0x13b8 <prvAllocateTCBAndStack>
     4ea:	9c 83       	std	Y+4, r25	; 0x04
     4ec:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
     4ee:	8b 81       	ldd	r24, Y+3	; 0x03
     4f0:	9c 81       	ldd	r25, Y+4	; 0x04
     4f2:	00 97       	sbiw	r24, 0x00	; 0
     4f4:	09 f4       	brne	.+2      	; 0x4f8 <xTaskGenericCreate+0x5e>
     4f6:	99 c0       	rjmp	.+306    	; 0x62a <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
     4f8:	eb 81       	ldd	r30, Y+3	; 0x03
     4fa:	fc 81       	ldd	r31, Y+4	; 0x04
     4fc:	27 89       	ldd	r18, Z+23	; 0x17
     4fe:	30 8d       	ldd	r19, Z+24	; 0x18
     500:	8a 85       	ldd	r24, Y+10	; 0x0a
     502:	9b 85       	ldd	r25, Y+11	; 0x0b
     504:	01 97       	sbiw	r24, 0x01	; 1
     506:	82 0f       	add	r24, r18
     508:	93 1f       	adc	r25, r19
     50a:	9a 83       	std	Y+2, r25	; 0x02
     50c:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
     50e:	8b 81       	ldd	r24, Y+3	; 0x03
     510:	9c 81       	ldd	r25, Y+4	; 0x04
     512:	28 85       	ldd	r18, Y+8	; 0x08
     514:	39 85       	ldd	r19, Y+9	; 0x09
     516:	eb 89       	ldd	r30, Y+19	; 0x13
     518:	fc 89       	ldd	r31, Y+20	; 0x14
     51a:	aa 85       	ldd	r26, Y+10	; 0x0a
     51c:	bb 85       	ldd	r27, Y+11	; 0x0b
     51e:	b9 01       	movw	r22, r18
     520:	4e 85       	ldd	r20, Y+14	; 0x0e
     522:	9f 01       	movw	r18, r30
     524:	8d 01       	movw	r16, r26
     526:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     52a:	89 81       	ldd	r24, Y+1	; 0x01
     52c:	9a 81       	ldd	r25, Y+2	; 0x02
     52e:	2e 81       	ldd	r18, Y+6	; 0x06
     530:	3f 81       	ldd	r19, Y+7	; 0x07
     532:	4c 85       	ldd	r20, Y+12	; 0x0c
     534:	5d 85       	ldd	r21, Y+13	; 0x0d
     536:	b9 01       	movw	r22, r18
     538:	0e 94 31 15 	call	0x2a62	; 0x2a62 <pxPortInitialiseStack>
     53c:	eb 81       	ldd	r30, Y+3	; 0x03
     53e:	fc 81       	ldd	r31, Y+4	; 0x04
     540:	91 83       	std	Z+1, r25	; 0x01
     542:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
     544:	8f 85       	ldd	r24, Y+15	; 0x0f
     546:	98 89       	ldd	r25, Y+16	; 0x10
     548:	00 97       	sbiw	r24, 0x00	; 0
     54a:	31 f0       	breq	.+12     	; 0x558 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
     54c:	ef 85       	ldd	r30, Y+15	; 0x0f
     54e:	f8 89       	ldd	r31, Y+16	; 0x10
     550:	8b 81       	ldd	r24, Y+3	; 0x03
     552:	9c 81       	ldd	r25, Y+4	; 0x04
     554:	91 83       	std	Z+1, r25	; 0x01
     556:	80 83       	st	Z, r24
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
     558:	0f b6       	in	r0, 0x3f	; 63
     55a:	f8 94       	cli
     55c:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
     55e:	80 91 1e 02 	lds	r24, 0x021E
     562:	8f 5f       	subi	r24, 0xFF	; 255
     564:	80 93 1e 02 	sts	0x021E, r24
			if( pxCurrentTCB == NULL )
     568:	80 91 1c 02 	lds	r24, 0x021C
     56c:	90 91 1d 02 	lds	r25, 0x021D
     570:	00 97       	sbiw	r24, 0x00	; 0
     572:	69 f4       	brne	.+26     	; 0x58e <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
     574:	8b 81       	ldd	r24, Y+3	; 0x03
     576:	9c 81       	ldd	r25, Y+4	; 0x04
     578:	90 93 1d 02 	sts	0x021D, r25
     57c:	80 93 1c 02 	sts	0x021C, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
     580:	80 91 1e 02 	lds	r24, 0x021E
     584:	81 30       	cpi	r24, 0x01	; 1
     586:	a9 f4       	brne	.+42     	; 0x5b2 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
     588:	0e 94 4e 09 	call	0x129c	; 0x129c <prvInitialiseTaskLists>
     58c:	12 c0       	rjmp	.+36     	; 0x5b2 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
     58e:	80 91 23 02 	lds	r24, 0x0223
     592:	88 23       	and	r24, r24
     594:	71 f4       	brne	.+28     	; 0x5b2 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
     596:	e0 91 1c 02 	lds	r30, 0x021C
     59a:	f0 91 1d 02 	lds	r31, 0x021D
     59e:	96 89       	ldd	r25, Z+22	; 0x16
     5a0:	8e 85       	ldd	r24, Y+14	; 0x0e
     5a2:	89 17       	cp	r24, r25
     5a4:	30 f0       	brcs	.+12     	; 0x5b2 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
     5a6:	8b 81       	ldd	r24, Y+3	; 0x03
     5a8:	9c 81       	ldd	r25, Y+4	; 0x04
     5aa:	90 93 1d 02 	sts	0x021D, r25
     5ae:	80 93 1c 02 	sts	0x021C, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
     5b2:	eb 81       	ldd	r30, Y+3	; 0x03
     5b4:	fc 81       	ldd	r31, Y+4	; 0x04
     5b6:	96 89       	ldd	r25, Z+22	; 0x16
     5b8:	80 91 21 02 	lds	r24, 0x0221
     5bc:	89 17       	cp	r24, r25
     5be:	28 f4       	brcc	.+10     	; 0x5ca <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
     5c0:	eb 81       	ldd	r30, Y+3	; 0x03
     5c2:	fc 81       	ldd	r31, Y+4	; 0x04
     5c4:	86 89       	ldd	r24, Z+22	; 0x16
     5c6:	80 93 21 02 	sts	0x0221, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
     5ca:	80 91 28 02 	lds	r24, 0x0228
     5ce:	8f 5f       	subi	r24, 0xFF	; 255
     5d0:	80 93 28 02 	sts	0x0228, r24

			prvAddTaskToReadyQueue( pxNewTCB );
     5d4:	eb 81       	ldd	r30, Y+3	; 0x03
     5d6:	fc 81       	ldd	r31, Y+4	; 0x04
     5d8:	96 89       	ldd	r25, Z+22	; 0x16
     5da:	80 91 22 02 	lds	r24, 0x0222
     5de:	89 17       	cp	r24, r25
     5e0:	28 f4       	brcc	.+10     	; 0x5ec <xTaskGenericCreate+0x152>
     5e2:	eb 81       	ldd	r30, Y+3	; 0x03
     5e4:	fc 81       	ldd	r31, Y+4	; 0x04
     5e6:	86 89       	ldd	r24, Z+22	; 0x16
     5e8:	80 93 22 02 	sts	0x0222, r24
     5ec:	eb 81       	ldd	r30, Y+3	; 0x03
     5ee:	fc 81       	ldd	r31, Y+4	; 0x04
     5f0:	86 89       	ldd	r24, Z+22	; 0x16
     5f2:	28 2f       	mov	r18, r24
     5f4:	30 e0       	ldi	r19, 0x00	; 0
     5f6:	c9 01       	movw	r24, r18
     5f8:	88 0f       	add	r24, r24
     5fa:	99 1f       	adc	r25, r25
     5fc:	88 0f       	add	r24, r24
     5fe:	99 1f       	adc	r25, r25
     600:	88 0f       	add	r24, r24
     602:	99 1f       	adc	r25, r25
     604:	82 0f       	add	r24, r18
     606:	93 1f       	adc	r25, r19
     608:	ac 01       	movw	r20, r24
     60a:	47 5d       	subi	r20, 0xD7	; 215
     60c:	5d 4f       	sbci	r21, 0xFD	; 253
     60e:	8b 81       	ldd	r24, Y+3	; 0x03
     610:	9c 81       	ldd	r25, Y+4	; 0x04
     612:	9c 01       	movw	r18, r24
     614:	2e 5f       	subi	r18, 0xFE	; 254
     616:	3f 4f       	sbci	r19, 0xFF	; 255
     618:	ca 01       	movw	r24, r20
     61a:	b9 01       	movw	r22, r18
     61c:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <vListInsertEnd>

			xReturn = pdPASS;
     620:	81 e0       	ldi	r24, 0x01	; 1
     622:	8d 83       	std	Y+5, r24	; 0x05
			portSETUP_TCB( pxNewTCB );
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
     624:	0f 90       	pop	r0
     626:	0f be       	out	0x3f, r0	; 63
     628:	02 c0       	rjmp	.+4      	; 0x62e <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     62a:	8f ef       	ldi	r24, 0xFF	; 255
     62c:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
     62e:	8d 81       	ldd	r24, Y+5	; 0x05
     630:	81 30       	cpi	r24, 0x01	; 1
     632:	71 f4       	brne	.+28     	; 0x650 <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
     634:	80 91 23 02 	lds	r24, 0x0223
     638:	88 23       	and	r24, r24
     63a:	51 f0       	breq	.+20     	; 0x650 <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
     63c:	e0 91 1c 02 	lds	r30, 0x021C
     640:	f0 91 1d 02 	lds	r31, 0x021D
     644:	96 89       	ldd	r25, Z+22	; 0x16
     646:	8e 85       	ldd	r24, Y+14	; 0x0e
     648:	98 17       	cp	r25, r24
     64a:	10 f4       	brcc	.+4      	; 0x650 <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
     64c:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <vPortYield>
			}
		}
	}

	return xReturn;
     650:	8d 81       	ldd	r24, Y+5	; 0x05
}
     652:	64 96       	adiw	r28, 0x14	; 20
     654:	0f b6       	in	r0, 0x3f	; 63
     656:	f8 94       	cli
     658:	de bf       	out	0x3e, r29	; 62
     65a:	0f be       	out	0x3f, r0	; 63
     65c:	cd bf       	out	0x3d, r28	; 61
     65e:	cf 91       	pop	r28
     660:	df 91       	pop	r29
     662:	1f 91       	pop	r17
     664:	0f 91       	pop	r16
     666:	ff 90       	pop	r15
     668:	ef 90       	pop	r14
     66a:	df 90       	pop	r13
     66c:	cf 90       	pop	r12
     66e:	bf 90       	pop	r11
     670:	af 90       	pop	r10
     672:	08 95       	ret

00000674 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
     674:	df 93       	push	r29
     676:	cf 93       	push	r28
     678:	cd b7       	in	r28, 0x3d	; 61
     67a:	de b7       	in	r29, 0x3e	; 62
     67c:	28 97       	sbiw	r28, 0x08	; 8
     67e:	0f b6       	in	r0, 0x3f	; 63
     680:	f8 94       	cli
     682:	de bf       	out	0x3e, r29	; 62
     684:	0f be       	out	0x3f, r0	; 63
     686:	cd bf       	out	0x3d, r28	; 61
     688:	9e 83       	std	Y+6, r25	; 0x06
     68a:	8d 83       	std	Y+5, r24	; 0x05
     68c:	78 87       	std	Y+8, r23	; 0x08
     68e:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
     690:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
     692:	0e 94 85 05 	call	0xb0a	; 0xb0a <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     696:	ed 81       	ldd	r30, Y+5	; 0x05
     698:	fe 81       	ldd	r31, Y+6	; 0x06
     69a:	20 81       	ld	r18, Z
     69c:	31 81       	ldd	r19, Z+1	; 0x01
     69e:	8f 81       	ldd	r24, Y+7	; 0x07
     6a0:	98 85       	ldd	r25, Y+8	; 0x08
     6a2:	82 0f       	add	r24, r18
     6a4:	93 1f       	adc	r25, r19
     6a6:	9c 83       	std	Y+4, r25	; 0x04
     6a8:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
     6aa:	ed 81       	ldd	r30, Y+5	; 0x05
     6ac:	fe 81       	ldd	r31, Y+6	; 0x06
     6ae:	20 81       	ld	r18, Z
     6b0:	31 81       	ldd	r19, Z+1	; 0x01
     6b2:	80 91 1f 02 	lds	r24, 0x021F
     6b6:	90 91 20 02 	lds	r25, 0x0220
     6ba:	82 17       	cp	r24, r18
     6bc:	93 07       	cpc	r25, r19
     6be:	a8 f4       	brcc	.+42     	; 0x6ea <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
     6c0:	ed 81       	ldd	r30, Y+5	; 0x05
     6c2:	fe 81       	ldd	r31, Y+6	; 0x06
     6c4:	20 81       	ld	r18, Z
     6c6:	31 81       	ldd	r19, Z+1	; 0x01
     6c8:	8b 81       	ldd	r24, Y+3	; 0x03
     6ca:	9c 81       	ldd	r25, Y+4	; 0x04
     6cc:	82 17       	cp	r24, r18
     6ce:	93 07       	cpc	r25, r19
     6d0:	00 f5       	brcc	.+64     	; 0x712 <vTaskDelayUntil+0x9e>
     6d2:	20 91 1f 02 	lds	r18, 0x021F
     6d6:	30 91 20 02 	lds	r19, 0x0220
     6da:	8b 81       	ldd	r24, Y+3	; 0x03
     6dc:	9c 81       	ldd	r25, Y+4	; 0x04
     6de:	28 17       	cp	r18, r24
     6e0:	39 07       	cpc	r19, r25
     6e2:	b8 f4       	brcc	.+46     	; 0x712 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
     6e4:	81 e0       	ldi	r24, 0x01	; 1
     6e6:	89 83       	std	Y+1, r24	; 0x01
     6e8:	14 c0       	rjmp	.+40     	; 0x712 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
     6ea:	ed 81       	ldd	r30, Y+5	; 0x05
     6ec:	fe 81       	ldd	r31, Y+6	; 0x06
     6ee:	20 81       	ld	r18, Z
     6f0:	31 81       	ldd	r19, Z+1	; 0x01
     6f2:	8b 81       	ldd	r24, Y+3	; 0x03
     6f4:	9c 81       	ldd	r25, Y+4	; 0x04
     6f6:	82 17       	cp	r24, r18
     6f8:	93 07       	cpc	r25, r19
     6fa:	48 f0       	brcs	.+18     	; 0x70e <vTaskDelayUntil+0x9a>
     6fc:	20 91 1f 02 	lds	r18, 0x021F
     700:	30 91 20 02 	lds	r19, 0x0220
     704:	8b 81       	ldd	r24, Y+3	; 0x03
     706:	9c 81       	ldd	r25, Y+4	; 0x04
     708:	28 17       	cp	r18, r24
     70a:	39 07       	cpc	r19, r25
     70c:	10 f4       	brcc	.+4      	; 0x712 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
     70e:	81 e0       	ldi	r24, 0x01	; 1
     710:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     712:	ed 81       	ldd	r30, Y+5	; 0x05
     714:	fe 81       	ldd	r31, Y+6	; 0x06
     716:	8b 81       	ldd	r24, Y+3	; 0x03
     718:	9c 81       	ldd	r25, Y+4	; 0x04
     71a:	91 83       	std	Z+1, r25	; 0x01
     71c:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
     71e:	89 81       	ldd	r24, Y+1	; 0x01
     720:	88 23       	and	r24, r24
     722:	59 f0       	breq	.+22     	; 0x73a <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
     724:	80 91 1c 02 	lds	r24, 0x021C
     728:	90 91 1d 02 	lds	r25, 0x021D
     72c:	02 96       	adiw	r24, 0x02	; 2
     72e:	0e 94 9f 11 	call	0x233e	; 0x233e <uxListRemove>
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
     732:	8b 81       	ldd	r24, Y+3	; 0x03
     734:	9c 81       	ldd	r25, Y+4	; 0x04
     736:	0e 94 92 09 	call	0x1324	; 0x1324 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     73a:	0e 94 91 05 	call	0xb22	; 0xb22 <xTaskResumeAll>
     73e:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     740:	8a 81       	ldd	r24, Y+2	; 0x02
     742:	88 23       	and	r24, r24
     744:	11 f4       	brne	.+4      	; 0x74a <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
     746:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <vPortYield>
		}
	}
     74a:	28 96       	adiw	r28, 0x08	; 8
     74c:	0f b6       	in	r0, 0x3f	; 63
     74e:	f8 94       	cli
     750:	de bf       	out	0x3e, r29	; 62
     752:	0f be       	out	0x3f, r0	; 63
     754:	cd bf       	out	0x3d, r28	; 61
     756:	cf 91       	pop	r28
     758:	df 91       	pop	r29
     75a:	08 95       	ret

0000075c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
     75c:	df 93       	push	r29
     75e:	cf 93       	push	r28
     760:	00 d0       	rcall	.+0      	; 0x762 <vTaskDelay+0x6>
     762:	0f 92       	push	r0
     764:	0f 92       	push	r0
     766:	cd b7       	in	r28, 0x3d	; 61
     768:	de b7       	in	r29, 0x3e	; 62
     76a:	9d 83       	std	Y+5, r25	; 0x05
     76c:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
     76e:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
     770:	8c 81       	ldd	r24, Y+4	; 0x04
     772:	9d 81       	ldd	r25, Y+5	; 0x05
     774:	00 97       	sbiw	r24, 0x00	; 0
     776:	d1 f0       	breq	.+52     	; 0x7ac <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
     778:	0e 94 85 05 	call	0xb0a	; 0xb0a <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
     77c:	20 91 1f 02 	lds	r18, 0x021F
     780:	30 91 20 02 	lds	r19, 0x0220
     784:	8c 81       	ldd	r24, Y+4	; 0x04
     786:	9d 81       	ldd	r25, Y+5	; 0x05
     788:	82 0f       	add	r24, r18
     78a:	93 1f       	adc	r25, r19
     78c:	9b 83       	std	Y+3, r25	; 0x03
     78e:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
     790:	80 91 1c 02 	lds	r24, 0x021C
     794:	90 91 1d 02 	lds	r25, 0x021D
     798:	02 96       	adiw	r24, 0x02	; 2
     79a:	0e 94 9f 11 	call	0x233e	; 0x233e <uxListRemove>
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
     79e:	8a 81       	ldd	r24, Y+2	; 0x02
     7a0:	9b 81       	ldd	r25, Y+3	; 0x03
     7a2:	0e 94 92 09 	call	0x1324	; 0x1324 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     7a6:	0e 94 91 05 	call	0xb22	; 0xb22 <xTaskResumeAll>
     7aa:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     7ac:	89 81       	ldd	r24, Y+1	; 0x01
     7ae:	88 23       	and	r24, r24
     7b0:	11 f4       	brne	.+4      	; 0x7b6 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
     7b2:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <vPortYield>
		}
	}
     7b6:	0f 90       	pop	r0
     7b8:	0f 90       	pop	r0
     7ba:	0f 90       	pop	r0
     7bc:	0f 90       	pop	r0
     7be:	0f 90       	pop	r0
     7c0:	cf 91       	pop	r28
     7c2:	df 91       	pop	r29
     7c4:	08 95       	ret

000007c6 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
     7c6:	df 93       	push	r29
     7c8:	cf 93       	push	r28
     7ca:	00 d0       	rcall	.+0      	; 0x7cc <vTaskSuspend+0x6>
     7cc:	00 d0       	rcall	.+0      	; 0x7ce <vTaskSuspend+0x8>
     7ce:	cd b7       	in	r28, 0x3d	; 61
     7d0:	de b7       	in	r29, 0x3e	; 62
     7d2:	9c 83       	std	Y+4, r25	; 0x04
     7d4:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
     7d6:	0f b6       	in	r0, 0x3f	; 63
     7d8:	f8 94       	cli
     7da:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
     7dc:	20 91 1c 02 	lds	r18, 0x021C
     7e0:	30 91 1d 02 	lds	r19, 0x021D
     7e4:	8b 81       	ldd	r24, Y+3	; 0x03
     7e6:	9c 81       	ldd	r25, Y+4	; 0x04
     7e8:	82 17       	cp	r24, r18
     7ea:	93 07       	cpc	r25, r19
     7ec:	11 f4       	brne	.+4      	; 0x7f2 <vTaskSuspend+0x2c>
			{
				pxTaskToSuspend = NULL;
     7ee:	1c 82       	std	Y+4, r1	; 0x04
     7f0:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
     7f2:	8b 81       	ldd	r24, Y+3	; 0x03
     7f4:	9c 81       	ldd	r25, Y+4	; 0x04
     7f6:	00 97       	sbiw	r24, 0x00	; 0
     7f8:	39 f4       	brne	.+14     	; 0x808 <vTaskSuspend+0x42>
     7fa:	80 91 1c 02 	lds	r24, 0x021C
     7fe:	90 91 1d 02 	lds	r25, 0x021D
     802:	9e 83       	std	Y+6, r25	; 0x06
     804:	8d 83       	std	Y+5, r24	; 0x05
     806:	04 c0       	rjmp	.+8      	; 0x810 <vTaskSuspend+0x4a>
     808:	8b 81       	ldd	r24, Y+3	; 0x03
     80a:	9c 81       	ldd	r25, Y+4	; 0x04
     80c:	9e 83       	std	Y+6, r25	; 0x06
     80e:	8d 83       	std	Y+5, r24	; 0x05
     810:	8d 81       	ldd	r24, Y+5	; 0x05
     812:	9e 81       	ldd	r25, Y+6	; 0x06
     814:	9a 83       	std	Y+2, r25	; 0x02
     816:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
     818:	89 81       	ldd	r24, Y+1	; 0x01
     81a:	9a 81       	ldd	r25, Y+2	; 0x02
     81c:	02 96       	adiw	r24, 0x02	; 2
     81e:	0e 94 9f 11 	call	0x233e	; 0x233e <uxListRemove>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
			}

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
     822:	e9 81       	ldd	r30, Y+1	; 0x01
     824:	fa 81       	ldd	r31, Y+2	; 0x02
     826:	84 89       	ldd	r24, Z+20	; 0x14
     828:	95 89       	ldd	r25, Z+21	; 0x15
     82a:	00 97       	sbiw	r24, 0x00	; 0
     82c:	29 f0       	breq	.+10     	; 0x838 <vTaskSuspend+0x72>
			{
				uxListRemove( &( pxTCB->xEventListItem ) );
     82e:	89 81       	ldd	r24, Y+1	; 0x01
     830:	9a 81       	ldd	r25, Y+2	; 0x02
     832:	0c 96       	adiw	r24, 0x0c	; 12
     834:	0e 94 9f 11 	call	0x233e	; 0x233e <uxListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
     838:	89 81       	ldd	r24, Y+1	; 0x01
     83a:	9a 81       	ldd	r25, Y+2	; 0x02
     83c:	9c 01       	movw	r18, r24
     83e:	2e 5f       	subi	r18, 0xFE	; 254
     840:	3f 4f       	sbci	r19, 0xFF	; 255
     842:	8c e6       	ldi	r24, 0x6C	; 108
     844:	92 e0       	ldi	r25, 0x02	; 2
     846:	b9 01       	movw	r22, r18
     848:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
     84c:	0f 90       	pop	r0
     84e:	0f be       	out	0x3f, r0	; 63

		if( ( void * ) pxTaskToSuspend == NULL )
     850:	8b 81       	ldd	r24, Y+3	; 0x03
     852:	9c 81       	ldd	r25, Y+4	; 0x04
     854:	00 97       	sbiw	r24, 0x00	; 0
     856:	a1 f4       	brne	.+40     	; 0x880 <vTaskSuspend+0xba>
		{
			if( xSchedulerRunning != pdFALSE )
     858:	80 91 23 02 	lds	r24, 0x0223
     85c:	88 23       	and	r24, r24
     85e:	19 f0       	breq	.+6      	; 0x866 <vTaskSuspend+0xa0>
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
     860:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <vPortYield>
     864:	0d c0       	rjmp	.+26     	; 0x880 <vTaskSuspend+0xba>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
     866:	90 91 6c 02 	lds	r25, 0x026C
     86a:	80 91 1e 02 	lds	r24, 0x021E
     86e:	98 17       	cp	r25, r24
     870:	29 f4       	brne	.+10     	; 0x87c <vTaskSuspend+0xb6>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
     872:	10 92 1d 02 	sts	0x021D, r1
     876:	10 92 1c 02 	sts	0x021C, r1
     87a:	02 c0       	rjmp	.+4      	; 0x880 <vTaskSuspend+0xba>
				}
				else
				{
					vTaskSwitchContext();
     87c:	0e 94 24 07 	call	0xe48	; 0xe48 <vTaskSwitchContext>
				}
			}
		}
	}
     880:	26 96       	adiw	r28, 0x06	; 6
     882:	0f b6       	in	r0, 0x3f	; 63
     884:	f8 94       	cli
     886:	de bf       	out	0x3e, r29	; 62
     888:	0f be       	out	0x3f, r0	; 63
     88a:	cd bf       	out	0x3d, r28	; 61
     88c:	cf 91       	pop	r28
     88e:	df 91       	pop	r29
     890:	08 95       	ret

00000892 <xTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
     892:	df 93       	push	r29
     894:	cf 93       	push	r28
     896:	00 d0       	rcall	.+0      	; 0x898 <xTaskIsTaskSuspended+0x6>
     898:	0f 92       	push	r0
     89a:	0f 92       	push	r0
     89c:	cd b7       	in	r28, 0x3d	; 61
     89e:	de b7       	in	r29, 0x3e	; 62
     8a0:	9d 83       	std	Y+5, r25	; 0x05
     8a2:	8c 83       	std	Y+4, r24	; 0x04
	portBASE_TYPE xReturn = pdFALSE;
     8a4:	1b 82       	std	Y+3, r1	; 0x03
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
     8a6:	8c 81       	ldd	r24, Y+4	; 0x04
     8a8:	9d 81       	ldd	r25, Y+5	; 0x05
     8aa:	9a 83       	std	Y+2, r25	; 0x02
     8ac:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
     8ae:	e9 81       	ldd	r30, Y+1	; 0x01
     8b0:	fa 81       	ldd	r31, Y+2	; 0x02
     8b2:	82 85       	ldd	r24, Z+10	; 0x0a
     8b4:	93 85       	ldd	r25, Z+11	; 0x0b
     8b6:	22 e0       	ldi	r18, 0x02	; 2
     8b8:	8c 36       	cpi	r24, 0x6C	; 108
     8ba:	92 07       	cpc	r25, r18
     8bc:	81 f4       	brne	.+32     	; 0x8de <xTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
     8be:	e9 81       	ldd	r30, Y+1	; 0x01
     8c0:	fa 81       	ldd	r31, Y+2	; 0x02
     8c2:	84 89       	ldd	r24, Z+20	; 0x14
     8c4:	95 89       	ldd	r25, Z+21	; 0x15
     8c6:	22 e0       	ldi	r18, 0x02	; 2
     8c8:	83 36       	cpi	r24, 0x63	; 99
     8ca:	92 07       	cpc	r25, r18
     8cc:	41 f0       	breq	.+16     	; 0x8de <xTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
     8ce:	e9 81       	ldd	r30, Y+1	; 0x01
     8d0:	fa 81       	ldd	r31, Y+2	; 0x02
     8d2:	84 89       	ldd	r24, Z+20	; 0x14
     8d4:	95 89       	ldd	r25, Z+21	; 0x15
     8d6:	00 97       	sbiw	r24, 0x00	; 0
     8d8:	11 f4       	brne	.+4      	; 0x8de <xTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
     8da:	81 e0       	ldi	r24, 0x01	; 1
     8dc:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}

		return xReturn;
     8de:	8b 81       	ldd	r24, Y+3	; 0x03
	}
     8e0:	0f 90       	pop	r0
     8e2:	0f 90       	pop	r0
     8e4:	0f 90       	pop	r0
     8e6:	0f 90       	pop	r0
     8e8:	0f 90       	pop	r0
     8ea:	cf 91       	pop	r28
     8ec:	df 91       	pop	r29
     8ee:	08 95       	ret

000008f0 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
     8f0:	df 93       	push	r29
     8f2:	cf 93       	push	r28
     8f4:	00 d0       	rcall	.+0      	; 0x8f6 <vTaskResume+0x6>
     8f6:	0f 92       	push	r0
     8f8:	cd b7       	in	r28, 0x3d	; 61
     8fa:	de b7       	in	r29, 0x3e	; 62
     8fc:	9c 83       	std	Y+4, r25	; 0x04
     8fe:	8b 83       	std	Y+3, r24	; 0x03
		/* It does not make sense to resume the calling task. */
		configASSERT( pxTaskToResume );

		/* Remove the task from whichever list it is currently in, and place
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;
     900:	8b 81       	ldd	r24, Y+3	; 0x03
     902:	9c 81       	ldd	r25, Y+4	; 0x04
     904:	9a 83       	std	Y+2, r25	; 0x02
     906:	89 83       	std	Y+1, r24	; 0x01

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
     908:	89 81       	ldd	r24, Y+1	; 0x01
     90a:	9a 81       	ldd	r25, Y+2	; 0x02
     90c:	00 97       	sbiw	r24, 0x00	; 0
     90e:	09 f4       	brne	.+2      	; 0x912 <vTaskResume+0x22>
     910:	4c c0       	rjmp	.+152    	; 0x9aa <vTaskResume+0xba>
     912:	20 91 1c 02 	lds	r18, 0x021C
     916:	30 91 1d 02 	lds	r19, 0x021D
     91a:	89 81       	ldd	r24, Y+1	; 0x01
     91c:	9a 81       	ldd	r25, Y+2	; 0x02
     91e:	82 17       	cp	r24, r18
     920:	93 07       	cpc	r25, r19
     922:	09 f4       	brne	.+2      	; 0x926 <vTaskResume+0x36>
     924:	42 c0       	rjmp	.+132    	; 0x9aa <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
     926:	0f b6       	in	r0, 0x3f	; 63
     928:	f8 94       	cli
     92a:	0f 92       	push	r0
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
     92c:	89 81       	ldd	r24, Y+1	; 0x01
     92e:	9a 81       	ldd	r25, Y+2	; 0x02
     930:	0e 94 49 04 	call	0x892	; 0x892 <xTaskIsTaskSuspended>
     934:	81 30       	cpi	r24, 0x01	; 1
     936:	b9 f5       	brne	.+110    	; 0x9a6 <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					uxListRemove(  &( pxTCB->xGenericListItem ) );
     938:	89 81       	ldd	r24, Y+1	; 0x01
     93a:	9a 81       	ldd	r25, Y+2	; 0x02
     93c:	02 96       	adiw	r24, 0x02	; 2
     93e:	0e 94 9f 11 	call	0x233e	; 0x233e <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
     942:	e9 81       	ldd	r30, Y+1	; 0x01
     944:	fa 81       	ldd	r31, Y+2	; 0x02
     946:	96 89       	ldd	r25, Z+22	; 0x16
     948:	80 91 22 02 	lds	r24, 0x0222
     94c:	89 17       	cp	r24, r25
     94e:	28 f4       	brcc	.+10     	; 0x95a <vTaskResume+0x6a>
     950:	e9 81       	ldd	r30, Y+1	; 0x01
     952:	fa 81       	ldd	r31, Y+2	; 0x02
     954:	86 89       	ldd	r24, Z+22	; 0x16
     956:	80 93 22 02 	sts	0x0222, r24
     95a:	e9 81       	ldd	r30, Y+1	; 0x01
     95c:	fa 81       	ldd	r31, Y+2	; 0x02
     95e:	86 89       	ldd	r24, Z+22	; 0x16
     960:	28 2f       	mov	r18, r24
     962:	30 e0       	ldi	r19, 0x00	; 0
     964:	c9 01       	movw	r24, r18
     966:	88 0f       	add	r24, r24
     968:	99 1f       	adc	r25, r25
     96a:	88 0f       	add	r24, r24
     96c:	99 1f       	adc	r25, r25
     96e:	88 0f       	add	r24, r24
     970:	99 1f       	adc	r25, r25
     972:	82 0f       	add	r24, r18
     974:	93 1f       	adc	r25, r19
     976:	ac 01       	movw	r20, r24
     978:	47 5d       	subi	r20, 0xD7	; 215
     97a:	5d 4f       	sbci	r21, 0xFD	; 253
     97c:	89 81       	ldd	r24, Y+1	; 0x01
     97e:	9a 81       	ldd	r25, Y+2	; 0x02
     980:	9c 01       	movw	r18, r24
     982:	2e 5f       	subi	r18, 0xFE	; 254
     984:	3f 4f       	sbci	r19, 0xFF	; 255
     986:	ca 01       	movw	r24, r20
     988:	b9 01       	movw	r22, r18
     98a:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     98e:	e9 81       	ldd	r30, Y+1	; 0x01
     990:	fa 81       	ldd	r31, Y+2	; 0x02
     992:	96 89       	ldd	r25, Z+22	; 0x16
     994:	e0 91 1c 02 	lds	r30, 0x021C
     998:	f0 91 1d 02 	lds	r31, 0x021D
     99c:	86 89       	ldd	r24, Z+22	; 0x16
     99e:	98 17       	cp	r25, r24
     9a0:	10 f0       	brcs	.+4      	; 0x9a6 <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
     9a2:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <vPortYield>
					}
				}
			}
			taskEXIT_CRITICAL();
     9a6:	0f 90       	pop	r0
     9a8:	0f be       	out	0x3f, r0	; 63
		}
	}
     9aa:	0f 90       	pop	r0
     9ac:	0f 90       	pop	r0
     9ae:	0f 90       	pop	r0
     9b0:	0f 90       	pop	r0
     9b2:	cf 91       	pop	r28
     9b4:	df 91       	pop	r29
     9b6:	08 95       	ret

000009b8 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
     9b8:	df 93       	push	r29
     9ba:	cf 93       	push	r28
     9bc:	00 d0       	rcall	.+0      	; 0x9be <xTaskResumeFromISR+0x6>
     9be:	00 d0       	rcall	.+0      	; 0x9c0 <xTaskResumeFromISR+0x8>
     9c0:	cd b7       	in	r28, 0x3d	; 61
     9c2:	de b7       	in	r29, 0x3e	; 62
     9c4:	9e 83       	std	Y+6, r25	; 0x06
     9c6:	8d 83       	std	Y+5, r24	; 0x05
	portBASE_TYPE xYieldRequired = pdFALSE;
     9c8:	1c 82       	std	Y+4, r1	; 0x04
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxSavedInterruptStatus;

		configASSERT( pxTaskToResume );

		pxTCB = ( tskTCB * ) pxTaskToResume;
     9ca:	8d 81       	ldd	r24, Y+5	; 0x05
     9cc:	9e 81       	ldd	r25, Y+6	; 0x06
     9ce:	9b 83       	std	Y+3, r25	; 0x03
     9d0:	8a 83       	std	Y+2, r24	; 0x02

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     9d2:	19 82       	std	Y+1, r1	; 0x01
		{
			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
     9d4:	8a 81       	ldd	r24, Y+2	; 0x02
     9d6:	9b 81       	ldd	r25, Y+3	; 0x03
     9d8:	0e 94 49 04 	call	0x892	; 0x892 <xTaskIsTaskSuspended>
     9dc:	81 30       	cpi	r24, 0x01	; 1
     9de:	09 f0       	breq	.+2      	; 0x9e2 <xTaskResumeFromISR+0x2a>
     9e0:	47 c0       	rjmp	.+142    	; 0xa70 <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     9e2:	80 91 24 02 	lds	r24, 0x0224
     9e6:	88 23       	and	r24, r24
     9e8:	c9 f5       	brne	.+114    	; 0xa5c <xTaskResumeFromISR+0xa4>
				{
					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
     9ea:	ea 81       	ldd	r30, Y+2	; 0x02
     9ec:	fb 81       	ldd	r31, Y+3	; 0x03
     9ee:	96 89       	ldd	r25, Z+22	; 0x16
     9f0:	e0 91 1c 02 	lds	r30, 0x021C
     9f4:	f0 91 1d 02 	lds	r31, 0x021D
     9f8:	86 89       	ldd	r24, Z+22	; 0x16
     9fa:	1c 82       	std	Y+4, r1	; 0x04
     9fc:	98 17       	cp	r25, r24
     9fe:	10 f0       	brcs	.+4      	; 0xa04 <xTaskResumeFromISR+0x4c>
     a00:	81 e0       	ldi	r24, 0x01	; 1
     a02:	8c 83       	std	Y+4, r24	; 0x04
					uxListRemove(  &( pxTCB->xGenericListItem ) );
     a04:	8a 81       	ldd	r24, Y+2	; 0x02
     a06:	9b 81       	ldd	r25, Y+3	; 0x03
     a08:	02 96       	adiw	r24, 0x02	; 2
     a0a:	0e 94 9f 11 	call	0x233e	; 0x233e <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
     a0e:	ea 81       	ldd	r30, Y+2	; 0x02
     a10:	fb 81       	ldd	r31, Y+3	; 0x03
     a12:	96 89       	ldd	r25, Z+22	; 0x16
     a14:	80 91 22 02 	lds	r24, 0x0222
     a18:	89 17       	cp	r24, r25
     a1a:	28 f4       	brcc	.+10     	; 0xa26 <xTaskResumeFromISR+0x6e>
     a1c:	ea 81       	ldd	r30, Y+2	; 0x02
     a1e:	fb 81       	ldd	r31, Y+3	; 0x03
     a20:	86 89       	ldd	r24, Z+22	; 0x16
     a22:	80 93 22 02 	sts	0x0222, r24
     a26:	ea 81       	ldd	r30, Y+2	; 0x02
     a28:	fb 81       	ldd	r31, Y+3	; 0x03
     a2a:	86 89       	ldd	r24, Z+22	; 0x16
     a2c:	28 2f       	mov	r18, r24
     a2e:	30 e0       	ldi	r19, 0x00	; 0
     a30:	c9 01       	movw	r24, r18
     a32:	88 0f       	add	r24, r24
     a34:	99 1f       	adc	r25, r25
     a36:	88 0f       	add	r24, r24
     a38:	99 1f       	adc	r25, r25
     a3a:	88 0f       	add	r24, r24
     a3c:	99 1f       	adc	r25, r25
     a3e:	82 0f       	add	r24, r18
     a40:	93 1f       	adc	r25, r19
     a42:	ac 01       	movw	r20, r24
     a44:	47 5d       	subi	r20, 0xD7	; 215
     a46:	5d 4f       	sbci	r21, 0xFD	; 253
     a48:	8a 81       	ldd	r24, Y+2	; 0x02
     a4a:	9b 81       	ldd	r25, Y+3	; 0x03
     a4c:	9c 01       	movw	r18, r24
     a4e:	2e 5f       	subi	r18, 0xFE	; 254
     a50:	3f 4f       	sbci	r19, 0xFF	; 255
     a52:	ca 01       	movw	r24, r20
     a54:	b9 01       	movw	r22, r18
     a56:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <vListInsertEnd>
     a5a:	0a c0       	rjmp	.+20     	; 0xa70 <xTaskResumeFromISR+0xb8>
				else
				{
					/* We cannot access the delayed or ready lists, so will hold this
					task pending until the scheduler is resumed, at which point a
					yield will be performed if necessary. */
					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
     a5c:	8a 81       	ldd	r24, Y+2	; 0x02
     a5e:	9b 81       	ldd	r25, Y+3	; 0x03
     a60:	9c 01       	movw	r18, r24
     a62:	24 5f       	subi	r18, 0xF4	; 244
     a64:	3f 4f       	sbci	r19, 0xFF	; 255
     a66:	83 e6       	ldi	r24, 0x63	; 99
     a68:	92 e0       	ldi	r25, 0x02	; 2
     a6a:	b9 01       	movw	r22, r18
     a6c:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <vListInsertEnd>
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
     a70:	8c 81       	ldd	r24, Y+4	; 0x04
	}
     a72:	26 96       	adiw	r28, 0x06	; 6
     a74:	0f b6       	in	r0, 0x3f	; 63
     a76:	f8 94       	cli
     a78:	de bf       	out	0x3e, r29	; 62
     a7a:	0f be       	out	0x3f, r0	; 63
     a7c:	cd bf       	out	0x3d, r28	; 61
     a7e:	cf 91       	pop	r28
     a80:	df 91       	pop	r29
     a82:	08 95       	ret

00000a84 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
     a84:	af 92       	push	r10
     a86:	bf 92       	push	r11
     a88:	cf 92       	push	r12
     a8a:	df 92       	push	r13
     a8c:	ef 92       	push	r14
     a8e:	ff 92       	push	r15
     a90:	0f 93       	push	r16
     a92:	df 93       	push	r29
     a94:	cf 93       	push	r28
     a96:	0f 92       	push	r0
     a98:	cd b7       	in	r28, 0x3d	; 61
     a9a:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
     a9c:	82 ee       	ldi	r24, 0xE2	; 226
     a9e:	98 e0       	ldi	r25, 0x08	; 8
     aa0:	25 e1       	ldi	r18, 0x15	; 21
     aa2:	32 e0       	ldi	r19, 0x02	; 2
     aa4:	b9 01       	movw	r22, r18
     aa6:	45 e5       	ldi	r20, 0x55	; 85
     aa8:	50 e0       	ldi	r21, 0x00	; 0
     aaa:	20 e0       	ldi	r18, 0x00	; 0
     aac:	30 e0       	ldi	r19, 0x00	; 0
     aae:	00 e0       	ldi	r16, 0x00	; 0
     ab0:	ee 24       	eor	r14, r14
     ab2:	ff 24       	eor	r15, r15
     ab4:	cc 24       	eor	r12, r12
     ab6:	dd 24       	eor	r13, r13
     ab8:	aa 24       	eor	r10, r10
     aba:	bb 24       	eor	r11, r11
     abc:	0e 94 4d 02 	call	0x49a	; 0x49a <xTaskGenericCreate>
     ac0:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
     ac2:	89 81       	ldd	r24, Y+1	; 0x01
     ac4:	81 30       	cpi	r24, 0x01	; 1
     ac6:	51 f4       	brne	.+20     	; 0xadc <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
     ac8:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
     aca:	81 e0       	ldi	r24, 0x01	; 1
     acc:	80 93 23 02 	sts	0x0223, r24
		xTickCount = ( portTickType ) 0U;
     ad0:	10 92 20 02 	sts	0x0220, r1
     ad4:	10 92 1f 02 	sts	0x021F, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     ad8:	0e 94 cc 16 	call	0x2d98	; 0x2d98 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
     adc:	0f 90       	pop	r0
     ade:	cf 91       	pop	r28
     ae0:	df 91       	pop	r29
     ae2:	0f 91       	pop	r16
     ae4:	ff 90       	pop	r15
     ae6:	ef 90       	pop	r14
     ae8:	df 90       	pop	r13
     aea:	cf 90       	pop	r12
     aec:	bf 90       	pop	r11
     aee:	af 90       	pop	r10
     af0:	08 95       	ret

00000af2 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
     af2:	df 93       	push	r29
     af4:	cf 93       	push	r28
     af6:	cd b7       	in	r28, 0x3d	; 61
     af8:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
     afa:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
     afc:	10 92 23 02 	sts	0x0223, r1
	vPortEndScheduler();
     b00:	0e 94 05 17 	call	0x2e0a	; 0x2e0a <vPortEndScheduler>
}
     b04:	cf 91       	pop	r28
     b06:	df 91       	pop	r29
     b08:	08 95       	ret

00000b0a <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
     b0a:	df 93       	push	r29
     b0c:	cf 93       	push	r28
     b0e:	cd b7       	in	r28, 0x3d	; 61
     b10:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
     b12:	80 91 24 02 	lds	r24, 0x0224
     b16:	8f 5f       	subi	r24, 0xFF	; 255
     b18:	80 93 24 02 	sts	0x0224, r24
}
     b1c:	cf 91       	pop	r28
     b1e:	df 91       	pop	r29
     b20:	08 95       	ret

00000b22 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE != 0  */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
     b22:	df 93       	push	r29
     b24:	cf 93       	push	r28
     b26:	00 d0       	rcall	.+0      	; 0xb28 <xTaskResumeAll+0x6>
     b28:	0f 92       	push	r0
     b2a:	cd b7       	in	r28, 0x3d	; 61
     b2c:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
     b2e:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     b30:	0f b6       	in	r0, 0x3f	; 63
     b32:	f8 94       	cli
     b34:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     b36:	80 91 24 02 	lds	r24, 0x0224
     b3a:	81 50       	subi	r24, 0x01	; 1
     b3c:	80 93 24 02 	sts	0x0224, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     b40:	80 91 24 02 	lds	r24, 0x0224
     b44:	88 23       	and	r24, r24
     b46:	09 f0       	breq	.+2      	; 0xb4a <xTaskResumeAll+0x28>
     b48:	6c c0       	rjmp	.+216    	; 0xc22 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
     b4a:	80 91 1e 02 	lds	r24, 0x021E
     b4e:	88 23       	and	r24, r24
     b50:	09 f4       	brne	.+2      	; 0xb54 <xTaskResumeAll+0x32>
     b52:	67 c0       	rjmp	.+206    	; 0xc22 <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
     b54:	19 82       	std	Y+1, r1	; 0x01
     b56:	41 c0       	rjmp	.+130    	; 0xbda <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
     b58:	e0 91 68 02 	lds	r30, 0x0268
     b5c:	f0 91 69 02 	lds	r31, 0x0269
     b60:	86 81       	ldd	r24, Z+6	; 0x06
     b62:	97 81       	ldd	r25, Z+7	; 0x07
     b64:	9c 83       	std	Y+4, r25	; 0x04
     b66:	8b 83       	std	Y+3, r24	; 0x03
					uxListRemove( &( pxTCB->xEventListItem ) );
     b68:	8b 81       	ldd	r24, Y+3	; 0x03
     b6a:	9c 81       	ldd	r25, Y+4	; 0x04
     b6c:	0c 96       	adiw	r24, 0x0c	; 12
     b6e:	0e 94 9f 11 	call	0x233e	; 0x233e <uxListRemove>
					uxListRemove( &( pxTCB->xGenericListItem ) );
     b72:	8b 81       	ldd	r24, Y+3	; 0x03
     b74:	9c 81       	ldd	r25, Y+4	; 0x04
     b76:	02 96       	adiw	r24, 0x02	; 2
     b78:	0e 94 9f 11 	call	0x233e	; 0x233e <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
     b7c:	eb 81       	ldd	r30, Y+3	; 0x03
     b7e:	fc 81       	ldd	r31, Y+4	; 0x04
     b80:	96 89       	ldd	r25, Z+22	; 0x16
     b82:	80 91 22 02 	lds	r24, 0x0222
     b86:	89 17       	cp	r24, r25
     b88:	28 f4       	brcc	.+10     	; 0xb94 <xTaskResumeAll+0x72>
     b8a:	eb 81       	ldd	r30, Y+3	; 0x03
     b8c:	fc 81       	ldd	r31, Y+4	; 0x04
     b8e:	86 89       	ldd	r24, Z+22	; 0x16
     b90:	80 93 22 02 	sts	0x0222, r24
     b94:	eb 81       	ldd	r30, Y+3	; 0x03
     b96:	fc 81       	ldd	r31, Y+4	; 0x04
     b98:	86 89       	ldd	r24, Z+22	; 0x16
     b9a:	28 2f       	mov	r18, r24
     b9c:	30 e0       	ldi	r19, 0x00	; 0
     b9e:	c9 01       	movw	r24, r18
     ba0:	88 0f       	add	r24, r24
     ba2:	99 1f       	adc	r25, r25
     ba4:	88 0f       	add	r24, r24
     ba6:	99 1f       	adc	r25, r25
     ba8:	88 0f       	add	r24, r24
     baa:	99 1f       	adc	r25, r25
     bac:	82 0f       	add	r24, r18
     bae:	93 1f       	adc	r25, r19
     bb0:	87 5d       	subi	r24, 0xD7	; 215
     bb2:	9d 4f       	sbci	r25, 0xFD	; 253
     bb4:	2b 81       	ldd	r18, Y+3	; 0x03
     bb6:	3c 81       	ldd	r19, Y+4	; 0x04
     bb8:	2e 5f       	subi	r18, 0xFE	; 254
     bba:	3f 4f       	sbci	r19, 0xFF	; 255
     bbc:	b9 01       	movw	r22, r18
     bbe:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     bc2:	eb 81       	ldd	r30, Y+3	; 0x03
     bc4:	fc 81       	ldd	r31, Y+4	; 0x04
     bc6:	96 89       	ldd	r25, Z+22	; 0x16
     bc8:	e0 91 1c 02 	lds	r30, 0x021C
     bcc:	f0 91 1d 02 	lds	r31, 0x021D
     bd0:	86 89       	ldd	r24, Z+22	; 0x16
     bd2:	98 17       	cp	r25, r24
     bd4:	10 f0       	brcs	.+4      	; 0xbda <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
     bd6:	81 e0       	ldi	r24, 0x01	; 1
     bd8:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
     bda:	80 91 63 02 	lds	r24, 0x0263
     bde:	88 23       	and	r24, r24
     be0:	09 f0       	breq	.+2      	; 0xbe4 <xTaskResumeAll+0xc2>
     be2:	ba cf       	rjmp	.-140    	; 0xb58 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
     be4:	80 91 25 02 	lds	r24, 0x0225
     be8:	88 23       	and	r24, r24
     bea:	71 f0       	breq	.+28     	; 0xc08 <xTaskResumeAll+0xe6>
     bec:	07 c0       	rjmp	.+14     	; 0xbfc <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
     bee:	0e 94 50 06 	call	0xca0	; 0xca0 <vTaskIncrementTick>
						--uxMissedTicks;
     bf2:	80 91 25 02 	lds	r24, 0x0225
     bf6:	81 50       	subi	r24, 0x01	; 1
     bf8:	80 93 25 02 	sts	0x0225, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
     bfc:	80 91 25 02 	lds	r24, 0x0225
     c00:	88 23       	and	r24, r24
     c02:	a9 f7       	brne	.-22     	; 0xbee <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
     c04:	81 e0       	ldi	r24, 0x01	; 1
     c06:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
     c08:	89 81       	ldd	r24, Y+1	; 0x01
     c0a:	81 30       	cpi	r24, 0x01	; 1
     c0c:	21 f0       	breq	.+8      	; 0xc16 <xTaskResumeAll+0xf4>
     c0e:	80 91 26 02 	lds	r24, 0x0226
     c12:	81 30       	cpi	r24, 0x01	; 1
     c14:	31 f4       	brne	.+12     	; 0xc22 <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
     c16:	81 e0       	ldi	r24, 0x01	; 1
     c18:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
     c1a:	10 92 26 02 	sts	0x0226, r1
					portYIELD_WITHIN_API();
     c1e:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
     c22:	0f 90       	pop	r0
     c24:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
     c26:	8a 81       	ldd	r24, Y+2	; 0x02
}
     c28:	0f 90       	pop	r0
     c2a:	0f 90       	pop	r0
     c2c:	0f 90       	pop	r0
     c2e:	0f 90       	pop	r0
     c30:	cf 91       	pop	r28
     c32:	df 91       	pop	r29
     c34:	08 95       	ret

00000c36 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
     c36:	df 93       	push	r29
     c38:	cf 93       	push	r28
     c3a:	0f 92       	push	r0
     c3c:	0f 92       	push	r0
     c3e:	cd b7       	in	r28, 0x3d	; 61
     c40:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
     c42:	0f b6       	in	r0, 0x3f	; 63
     c44:	f8 94       	cli
     c46:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     c48:	80 91 1f 02 	lds	r24, 0x021F
     c4c:	90 91 20 02 	lds	r25, 0x0220
     c50:	9a 83       	std	Y+2, r25	; 0x02
     c52:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
     c54:	0f 90       	pop	r0
     c56:	0f be       	out	0x3f, r0	; 63

	return xTicks;
     c58:	89 81       	ldd	r24, Y+1	; 0x01
     c5a:	9a 81       	ldd	r25, Y+2	; 0x02
}
     c5c:	0f 90       	pop	r0
     c5e:	0f 90       	pop	r0
     c60:	cf 91       	pop	r28
     c62:	df 91       	pop	r29
     c64:	08 95       	ret

00000c66 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
     c66:	df 93       	push	r29
     c68:	cf 93       	push	r28
     c6a:	00 d0       	rcall	.+0      	; 0xc6c <xTaskGetTickCountFromISR+0x6>
     c6c:	cd b7       	in	r28, 0x3d	; 61
     c6e:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     c70:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
     c72:	80 91 1f 02 	lds	r24, 0x021F
     c76:	90 91 20 02 	lds	r25, 0x0220
     c7a:	9b 83       	std	Y+3, r25	; 0x03
     c7c:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
     c7e:	8a 81       	ldd	r24, Y+2	; 0x02
     c80:	9b 81       	ldd	r25, Y+3	; 0x03
}
     c82:	0f 90       	pop	r0
     c84:	0f 90       	pop	r0
     c86:	0f 90       	pop	r0
     c88:	cf 91       	pop	r28
     c8a:	df 91       	pop	r29
     c8c:	08 95       	ret

00000c8e <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
     c8e:	df 93       	push	r29
     c90:	cf 93       	push	r28
     c92:	cd b7       	in	r28, 0x3d	; 61
     c94:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
     c96:	80 91 1e 02 	lds	r24, 0x021E
}
     c9a:	cf 91       	pop	r28
     c9c:	df 91       	pop	r29
     c9e:	08 95       	ret

00000ca0 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
     ca0:	df 93       	push	r29
     ca2:	cf 93       	push	r28
     ca4:	00 d0       	rcall	.+0      	; 0xca6 <vTaskIncrementTick+0x6>
     ca6:	00 d0       	rcall	.+0      	; 0xca8 <vTaskIncrementTick+0x8>
     ca8:	cd b7       	in	r28, 0x3d	; 61
     caa:	de b7       	in	r29, 0x3e	; 62

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     cac:	80 91 24 02 	lds	r24, 0x0224
     cb0:	88 23       	and	r24, r24
     cb2:	09 f0       	breq	.+2      	; 0xcb6 <vTaskIncrementTick+0x16>
     cb4:	bb c0       	rjmp	.+374    	; 0xe2c <vTaskIncrementTick+0x18c>
	{
		++xTickCount;
     cb6:	80 91 1f 02 	lds	r24, 0x021F
     cba:	90 91 20 02 	lds	r25, 0x0220
     cbe:	01 96       	adiw	r24, 0x01	; 1
     cc0:	90 93 20 02 	sts	0x0220, r25
     cc4:	80 93 1f 02 	sts	0x021F, r24
		if( xTickCount == ( portTickType ) 0U )
     cc8:	80 91 1f 02 	lds	r24, 0x021F
     ccc:	90 91 20 02 	lds	r25, 0x0220
     cd0:	00 97       	sbiw	r24, 0x00	; 0
     cd2:	d1 f5       	brne	.+116    	; 0xd48 <vTaskIncrementTick+0xa8>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
     cd4:	80 91 5f 02 	lds	r24, 0x025F
     cd8:	90 91 60 02 	lds	r25, 0x0260
     cdc:	9c 83       	std	Y+4, r25	; 0x04
     cde:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
     ce0:	80 91 61 02 	lds	r24, 0x0261
     ce4:	90 91 62 02 	lds	r25, 0x0262
     ce8:	90 93 60 02 	sts	0x0260, r25
     cec:	80 93 5f 02 	sts	0x025F, r24
			pxOverflowDelayedTaskList = pxTemp;
     cf0:	8b 81       	ldd	r24, Y+3	; 0x03
     cf2:	9c 81       	ldd	r25, Y+4	; 0x04
     cf4:	90 93 62 02 	sts	0x0262, r25
     cf8:	80 93 61 02 	sts	0x0261, r24
			xNumOfOverflows++;
     cfc:	80 91 27 02 	lds	r24, 0x0227
     d00:	8f 5f       	subi	r24, 0xFF	; 255
     d02:	80 93 27 02 	sts	0x0227, r24

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     d06:	e0 91 5f 02 	lds	r30, 0x025F
     d0a:	f0 91 60 02 	lds	r31, 0x0260
     d0e:	80 81       	ld	r24, Z
     d10:	88 23       	and	r24, r24
     d12:	39 f4       	brne	.+14     	; 0xd22 <vTaskIncrementTick+0x82>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
     d14:	8f ef       	ldi	r24, 0xFF	; 255
     d16:	9f ef       	ldi	r25, 0xFF	; 255
     d18:	90 93 14 02 	sts	0x0214, r25
     d1c:	80 93 13 02 	sts	0x0213, r24
     d20:	13 c0       	rjmp	.+38     	; 0xd48 <vTaskIncrementTick+0xa8>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     d22:	e0 91 5f 02 	lds	r30, 0x025F
     d26:	f0 91 60 02 	lds	r31, 0x0260
     d2a:	05 80       	ldd	r0, Z+5	; 0x05
     d2c:	f6 81       	ldd	r31, Z+6	; 0x06
     d2e:	e0 2d       	mov	r30, r0
     d30:	86 81       	ldd	r24, Z+6	; 0x06
     d32:	97 81       	ldd	r25, Z+7	; 0x07
     d34:	9e 83       	std	Y+6, r25	; 0x06
     d36:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
     d38:	ed 81       	ldd	r30, Y+5	; 0x05
     d3a:	fe 81       	ldd	r31, Y+6	; 0x06
     d3c:	82 81       	ldd	r24, Z+2	; 0x02
     d3e:	93 81       	ldd	r25, Z+3	; 0x03
     d40:	90 93 14 02 	sts	0x0214, r25
     d44:	80 93 13 02 	sts	0x0213, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
     d48:	20 91 1f 02 	lds	r18, 0x021F
     d4c:	30 91 20 02 	lds	r19, 0x0220
     d50:	80 91 13 02 	lds	r24, 0x0213
     d54:	90 91 14 02 	lds	r25, 0x0214
     d58:	28 17       	cp	r18, r24
     d5a:	39 07       	cpc	r19, r25
     d5c:	08 f4       	brcc	.+2      	; 0xd60 <vTaskIncrementTick+0xc0>
     d5e:	6b c0       	rjmp	.+214    	; 0xe36 <vTaskIncrementTick+0x196>
     d60:	e0 91 5f 02 	lds	r30, 0x025F
     d64:	f0 91 60 02 	lds	r31, 0x0260
     d68:	80 81       	ld	r24, Z
     d6a:	88 23       	and	r24, r24
     d6c:	39 f4       	brne	.+14     	; 0xd7c <vTaskIncrementTick+0xdc>
     d6e:	8f ef       	ldi	r24, 0xFF	; 255
     d70:	9f ef       	ldi	r25, 0xFF	; 255
     d72:	90 93 14 02 	sts	0x0214, r25
     d76:	80 93 13 02 	sts	0x0213, r24
     d7a:	5d c0       	rjmp	.+186    	; 0xe36 <vTaskIncrementTick+0x196>
     d7c:	e0 91 5f 02 	lds	r30, 0x025F
     d80:	f0 91 60 02 	lds	r31, 0x0260
     d84:	05 80       	ldd	r0, Z+5	; 0x05
     d86:	f6 81       	ldd	r31, Z+6	; 0x06
     d88:	e0 2d       	mov	r30, r0
     d8a:	86 81       	ldd	r24, Z+6	; 0x06
     d8c:	97 81       	ldd	r25, Z+7	; 0x07
     d8e:	9e 83       	std	Y+6, r25	; 0x06
     d90:	8d 83       	std	Y+5, r24	; 0x05
     d92:	ed 81       	ldd	r30, Y+5	; 0x05
     d94:	fe 81       	ldd	r31, Y+6	; 0x06
     d96:	82 81       	ldd	r24, Z+2	; 0x02
     d98:	93 81       	ldd	r25, Z+3	; 0x03
     d9a:	9a 83       	std	Y+2, r25	; 0x02
     d9c:	89 83       	std	Y+1, r24	; 0x01
     d9e:	20 91 1f 02 	lds	r18, 0x021F
     da2:	30 91 20 02 	lds	r19, 0x0220
     da6:	89 81       	ldd	r24, Y+1	; 0x01
     da8:	9a 81       	ldd	r25, Y+2	; 0x02
     daa:	28 17       	cp	r18, r24
     dac:	39 07       	cpc	r19, r25
     dae:	38 f4       	brcc	.+14     	; 0xdbe <vTaskIncrementTick+0x11e>
     db0:	89 81       	ldd	r24, Y+1	; 0x01
     db2:	9a 81       	ldd	r25, Y+2	; 0x02
     db4:	90 93 14 02 	sts	0x0214, r25
     db8:	80 93 13 02 	sts	0x0213, r24
     dbc:	3c c0       	rjmp	.+120    	; 0xe36 <vTaskIncrementTick+0x196>
     dbe:	8d 81       	ldd	r24, Y+5	; 0x05
     dc0:	9e 81       	ldd	r25, Y+6	; 0x06
     dc2:	02 96       	adiw	r24, 0x02	; 2
     dc4:	0e 94 9f 11 	call	0x233e	; 0x233e <uxListRemove>
     dc8:	ed 81       	ldd	r30, Y+5	; 0x05
     dca:	fe 81       	ldd	r31, Y+6	; 0x06
     dcc:	84 89       	ldd	r24, Z+20	; 0x14
     dce:	95 89       	ldd	r25, Z+21	; 0x15
     dd0:	00 97       	sbiw	r24, 0x00	; 0
     dd2:	29 f0       	breq	.+10     	; 0xdde <vTaskIncrementTick+0x13e>
     dd4:	8d 81       	ldd	r24, Y+5	; 0x05
     dd6:	9e 81       	ldd	r25, Y+6	; 0x06
     dd8:	0c 96       	adiw	r24, 0x0c	; 12
     dda:	0e 94 9f 11 	call	0x233e	; 0x233e <uxListRemove>
     dde:	ed 81       	ldd	r30, Y+5	; 0x05
     de0:	fe 81       	ldd	r31, Y+6	; 0x06
     de2:	96 89       	ldd	r25, Z+22	; 0x16
     de4:	80 91 22 02 	lds	r24, 0x0222
     de8:	89 17       	cp	r24, r25
     dea:	28 f4       	brcc	.+10     	; 0xdf6 <vTaskIncrementTick+0x156>
     dec:	ed 81       	ldd	r30, Y+5	; 0x05
     dee:	fe 81       	ldd	r31, Y+6	; 0x06
     df0:	86 89       	ldd	r24, Z+22	; 0x16
     df2:	80 93 22 02 	sts	0x0222, r24
     df6:	ed 81       	ldd	r30, Y+5	; 0x05
     df8:	fe 81       	ldd	r31, Y+6	; 0x06
     dfa:	86 89       	ldd	r24, Z+22	; 0x16
     dfc:	28 2f       	mov	r18, r24
     dfe:	30 e0       	ldi	r19, 0x00	; 0
     e00:	c9 01       	movw	r24, r18
     e02:	88 0f       	add	r24, r24
     e04:	99 1f       	adc	r25, r25
     e06:	88 0f       	add	r24, r24
     e08:	99 1f       	adc	r25, r25
     e0a:	88 0f       	add	r24, r24
     e0c:	99 1f       	adc	r25, r25
     e0e:	82 0f       	add	r24, r18
     e10:	93 1f       	adc	r25, r19
     e12:	ac 01       	movw	r20, r24
     e14:	47 5d       	subi	r20, 0xD7	; 215
     e16:	5d 4f       	sbci	r21, 0xFD	; 253
     e18:	8d 81       	ldd	r24, Y+5	; 0x05
     e1a:	9e 81       	ldd	r25, Y+6	; 0x06
     e1c:	9c 01       	movw	r18, r24
     e1e:	2e 5f       	subi	r18, 0xFE	; 254
     e20:	3f 4f       	sbci	r19, 0xFF	; 255
     e22:	ca 01       	movw	r24, r20
     e24:	b9 01       	movw	r22, r18
     e26:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <vListInsertEnd>
     e2a:	9a cf       	rjmp	.-204    	; 0xd60 <vTaskIncrementTick+0xc0>
	}
	else
	{
		++uxMissedTicks;
     e2c:	80 91 25 02 	lds	r24, 0x0225
     e30:	8f 5f       	subi	r24, 0xFF	; 255
     e32:	80 93 25 02 	sts	0x0225, r24
		{
			vApplicationTickHook();
		}
	}
	#endif
}
     e36:	26 96       	adiw	r28, 0x06	; 6
     e38:	0f b6       	in	r0, 0x3f	; 63
     e3a:	f8 94       	cli
     e3c:	de bf       	out	0x3e, r29	; 62
     e3e:	0f be       	out	0x3f, r0	; 63
     e40:	cd bf       	out	0x3d, r28	; 61
     e42:	cf 91       	pop	r28
     e44:	df 91       	pop	r29
     e46:	08 95       	ret

00000e48 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
     e48:	df 93       	push	r29
     e4a:	cf 93       	push	r28
     e4c:	0f 92       	push	r0
     e4e:	0f 92       	push	r0
     e50:	cd b7       	in	r28, 0x3d	; 61
     e52:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
     e54:	80 91 24 02 	lds	r24, 0x0224
     e58:	88 23       	and	r24, r24
     e5a:	21 f0       	breq	.+8      	; 0xe64 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
     e5c:	81 e0       	ldi	r24, 0x01	; 1
     e5e:	80 93 26 02 	sts	0x0226, r24
     e62:	70 c0       	rjmp	.+224    	; 0xf44 <vTaskSwitchContext+0xfc>
				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
				ulTaskSwitchedInTime = ulTempCounter;
		}
		#endif

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
     e64:	e0 91 1c 02 	lds	r30, 0x021C
     e68:	f0 91 1d 02 	lds	r31, 0x021D
     e6c:	20 81       	ld	r18, Z
     e6e:	31 81       	ldd	r19, Z+1	; 0x01
     e70:	e0 91 1c 02 	lds	r30, 0x021C
     e74:	f0 91 1d 02 	lds	r31, 0x021D
     e78:	87 89       	ldd	r24, Z+23	; 0x17
     e7a:	90 8d       	ldd	r25, Z+24	; 0x18
     e7c:	82 17       	cp	r24, r18
     e7e:	93 07       	cpc	r25, r19
     e80:	90 f0       	brcs	.+36     	; 0xea6 <vTaskSwitchContext+0x5e>
     e82:	80 91 1c 02 	lds	r24, 0x021C
     e86:	90 91 1d 02 	lds	r25, 0x021D
     e8a:	20 91 1c 02 	lds	r18, 0x021C
     e8e:	30 91 1d 02 	lds	r19, 0x021D
     e92:	27 5e       	subi	r18, 0xE7	; 231
     e94:	3f 4f       	sbci	r19, 0xFF	; 255
     e96:	b9 01       	movw	r22, r18
     e98:	0e 94 a5 00 	call	0x14a	; 0x14a <vApplicationStackOverflowHook>
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
     e9c:	80 91 22 02 	lds	r24, 0x0222
     ea0:	81 50       	subi	r24, 0x01	; 1
     ea2:	80 93 22 02 	sts	0x0222, r24
     ea6:	80 91 22 02 	lds	r24, 0x0222
     eaa:	28 2f       	mov	r18, r24
     eac:	30 e0       	ldi	r19, 0x00	; 0
     eae:	c9 01       	movw	r24, r18
     eb0:	88 0f       	add	r24, r24
     eb2:	99 1f       	adc	r25, r25
     eb4:	88 0f       	add	r24, r24
     eb6:	99 1f       	adc	r25, r25
     eb8:	88 0f       	add	r24, r24
     eba:	99 1f       	adc	r25, r25
     ebc:	82 0f       	add	r24, r18
     ebe:	93 1f       	adc	r25, r19
     ec0:	fc 01       	movw	r30, r24
     ec2:	e7 5d       	subi	r30, 0xD7	; 215
     ec4:	fd 4f       	sbci	r31, 0xFD	; 253
     ec6:	80 81       	ld	r24, Z
     ec8:	88 23       	and	r24, r24
     eca:	41 f3       	breq	.-48     	; 0xe9c <vTaskSwitchContext+0x54>
     ecc:	80 91 22 02 	lds	r24, 0x0222
     ed0:	28 2f       	mov	r18, r24
     ed2:	30 e0       	ldi	r19, 0x00	; 0
     ed4:	c9 01       	movw	r24, r18
     ed6:	88 0f       	add	r24, r24
     ed8:	99 1f       	adc	r25, r25
     eda:	88 0f       	add	r24, r24
     edc:	99 1f       	adc	r25, r25
     ede:	88 0f       	add	r24, r24
     ee0:	99 1f       	adc	r25, r25
     ee2:	82 0f       	add	r24, r18
     ee4:	93 1f       	adc	r25, r19
     ee6:	87 5d       	subi	r24, 0xD7	; 215
     ee8:	9d 4f       	sbci	r25, 0xFD	; 253
     eea:	9a 83       	std	Y+2, r25	; 0x02
     eec:	89 83       	std	Y+1, r24	; 0x01
     eee:	e9 81       	ldd	r30, Y+1	; 0x01
     ef0:	fa 81       	ldd	r31, Y+2	; 0x02
     ef2:	01 80       	ldd	r0, Z+1	; 0x01
     ef4:	f2 81       	ldd	r31, Z+2	; 0x02
     ef6:	e0 2d       	mov	r30, r0
     ef8:	82 81       	ldd	r24, Z+2	; 0x02
     efa:	93 81       	ldd	r25, Z+3	; 0x03
     efc:	e9 81       	ldd	r30, Y+1	; 0x01
     efe:	fa 81       	ldd	r31, Y+2	; 0x02
     f00:	92 83       	std	Z+2, r25	; 0x02
     f02:	81 83       	std	Z+1, r24	; 0x01
     f04:	e9 81       	ldd	r30, Y+1	; 0x01
     f06:	fa 81       	ldd	r31, Y+2	; 0x02
     f08:	21 81       	ldd	r18, Z+1	; 0x01
     f0a:	32 81       	ldd	r19, Z+2	; 0x02
     f0c:	89 81       	ldd	r24, Y+1	; 0x01
     f0e:	9a 81       	ldd	r25, Y+2	; 0x02
     f10:	03 96       	adiw	r24, 0x03	; 3
     f12:	28 17       	cp	r18, r24
     f14:	39 07       	cpc	r19, r25
     f16:	59 f4       	brne	.+22     	; 0xf2e <vTaskSwitchContext+0xe6>
     f18:	e9 81       	ldd	r30, Y+1	; 0x01
     f1a:	fa 81       	ldd	r31, Y+2	; 0x02
     f1c:	01 80       	ldd	r0, Z+1	; 0x01
     f1e:	f2 81       	ldd	r31, Z+2	; 0x02
     f20:	e0 2d       	mov	r30, r0
     f22:	82 81       	ldd	r24, Z+2	; 0x02
     f24:	93 81       	ldd	r25, Z+3	; 0x03
     f26:	e9 81       	ldd	r30, Y+1	; 0x01
     f28:	fa 81       	ldd	r31, Y+2	; 0x02
     f2a:	92 83       	std	Z+2, r25	; 0x02
     f2c:	81 83       	std	Z+1, r24	; 0x01
     f2e:	e9 81       	ldd	r30, Y+1	; 0x01
     f30:	fa 81       	ldd	r31, Y+2	; 0x02
     f32:	01 80       	ldd	r0, Z+1	; 0x01
     f34:	f2 81       	ldd	r31, Z+2	; 0x02
     f36:	e0 2d       	mov	r30, r0
     f38:	86 81       	ldd	r24, Z+6	; 0x06
     f3a:	97 81       	ldd	r25, Z+7	; 0x07
     f3c:	90 93 1d 02 	sts	0x021D, r25
     f40:	80 93 1c 02 	sts	0x021C, r24

		traceTASK_SWITCHED_IN();
	}
}
     f44:	0f 90       	pop	r0
     f46:	0f 90       	pop	r0
     f48:	cf 91       	pop	r28
     f4a:	df 91       	pop	r29
     f4c:	08 95       	ret

00000f4e <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
     f4e:	df 93       	push	r29
     f50:	cf 93       	push	r28
     f52:	00 d0       	rcall	.+0      	; 0xf54 <vTaskPlaceOnEventList+0x6>
     f54:	00 d0       	rcall	.+0      	; 0xf56 <vTaskPlaceOnEventList+0x8>
     f56:	cd b7       	in	r28, 0x3d	; 61
     f58:	de b7       	in	r29, 0x3e	; 62
     f5a:	9c 83       	std	Y+4, r25	; 0x04
     f5c:	8b 83       	std	Y+3, r24	; 0x03
     f5e:	7e 83       	std	Y+6, r23	; 0x06
     f60:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
     f62:	4b 81       	ldd	r20, Y+3	; 0x03
     f64:	5c 81       	ldd	r21, Y+4	; 0x04
     f66:	80 91 1c 02 	lds	r24, 0x021C
     f6a:	90 91 1d 02 	lds	r25, 0x021D
     f6e:	9c 01       	movw	r18, r24
     f70:	24 5f       	subi	r18, 0xF4	; 244
     f72:	3f 4f       	sbci	r19, 0xFF	; 255
     f74:	ca 01       	movw	r24, r20
     f76:	b9 01       	movw	r22, r18
     f78:	0e 94 33 11 	call	0x2266	; 0x2266 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
     f7c:	80 91 1c 02 	lds	r24, 0x021C
     f80:	90 91 1d 02 	lds	r25, 0x021D
     f84:	02 96       	adiw	r24, 0x02	; 2
     f86:	0e 94 9f 11 	call	0x233e	; 0x233e <uxListRemove>
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
     f8a:	8d 81       	ldd	r24, Y+5	; 0x05
     f8c:	9e 81       	ldd	r25, Y+6	; 0x06
     f8e:	2f ef       	ldi	r18, 0xFF	; 255
     f90:	8f 3f       	cpi	r24, 0xFF	; 255
     f92:	92 07       	cpc	r25, r18
     f94:	69 f4       	brne	.+26     	; 0xfb0 <vTaskPlaceOnEventList+0x62>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
     f96:	80 91 1c 02 	lds	r24, 0x021C
     f9a:	90 91 1d 02 	lds	r25, 0x021D
     f9e:	9c 01       	movw	r18, r24
     fa0:	2e 5f       	subi	r18, 0xFE	; 254
     fa2:	3f 4f       	sbci	r19, 0xFF	; 255
     fa4:	8c e6       	ldi	r24, 0x6C	; 108
     fa6:	92 e0       	ldi	r25, 0x02	; 2
     fa8:	b9 01       	movw	r22, r18
     faa:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <vListInsertEnd>
     fae:	0e c0       	rjmp	.+28     	; 0xfcc <vTaskPlaceOnEventList+0x7e>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
     fb0:	20 91 1f 02 	lds	r18, 0x021F
     fb4:	30 91 20 02 	lds	r19, 0x0220
     fb8:	8d 81       	ldd	r24, Y+5	; 0x05
     fba:	9e 81       	ldd	r25, Y+6	; 0x06
     fbc:	82 0f       	add	r24, r18
     fbe:	93 1f       	adc	r25, r19
     fc0:	9a 83       	std	Y+2, r25	; 0x02
     fc2:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
     fc4:	89 81       	ldd	r24, Y+1	; 0x01
     fc6:	9a 81       	ldd	r25, Y+2	; 0x02
     fc8:	0e 94 92 09 	call	0x1324	; 0x1324 <prvAddCurrentTaskToDelayedList>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
     fcc:	26 96       	adiw	r28, 0x06	; 6
     fce:	0f b6       	in	r0, 0x3f	; 63
     fd0:	f8 94       	cli
     fd2:	de bf       	out	0x3e, r29	; 62
     fd4:	0f be       	out	0x3f, r0	; 63
     fd6:	cd bf       	out	0x3d, r28	; 61
     fd8:	cf 91       	pop	r28
     fda:	df 91       	pop	r29
     fdc:	08 95       	ret

00000fde <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
     fde:	df 93       	push	r29
     fe0:	cf 93       	push	r28
     fe2:	00 d0       	rcall	.+0      	; 0xfe4 <xTaskRemoveFromEventList+0x6>
     fe4:	0f 92       	push	r0
     fe6:	0f 92       	push	r0
     fe8:	cd b7       	in	r28, 0x3d	; 61
     fea:	de b7       	in	r29, 0x3e	; 62
     fec:	9d 83       	std	Y+5, r25	; 0x05
     fee:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     ff0:	ec 81       	ldd	r30, Y+4	; 0x04
     ff2:	fd 81       	ldd	r31, Y+5	; 0x05
     ff4:	05 80       	ldd	r0, Z+5	; 0x05
     ff6:	f6 81       	ldd	r31, Z+6	; 0x06
     ff8:	e0 2d       	mov	r30, r0
     ffa:	86 81       	ldd	r24, Z+6	; 0x06
     ffc:	97 81       	ldd	r25, Z+7	; 0x07
     ffe:	9b 83       	std	Y+3, r25	; 0x03
    1000:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1002:	8a 81       	ldd	r24, Y+2	; 0x02
    1004:	9b 81       	ldd	r25, Y+3	; 0x03
    1006:	0c 96       	adiw	r24, 0x0c	; 12
    1008:	0e 94 9f 11 	call	0x233e	; 0x233e <uxListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    100c:	80 91 24 02 	lds	r24, 0x0224
    1010:	88 23       	and	r24, r24
    1012:	61 f5       	brne	.+88     	; 0x106c <xTaskRemoveFromEventList+0x8e>
	{
		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    1014:	8a 81       	ldd	r24, Y+2	; 0x02
    1016:	9b 81       	ldd	r25, Y+3	; 0x03
    1018:	02 96       	adiw	r24, 0x02	; 2
    101a:	0e 94 9f 11 	call	0x233e	; 0x233e <uxListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    101e:	ea 81       	ldd	r30, Y+2	; 0x02
    1020:	fb 81       	ldd	r31, Y+3	; 0x03
    1022:	96 89       	ldd	r25, Z+22	; 0x16
    1024:	80 91 22 02 	lds	r24, 0x0222
    1028:	89 17       	cp	r24, r25
    102a:	28 f4       	brcc	.+10     	; 0x1036 <xTaskRemoveFromEventList+0x58>
    102c:	ea 81       	ldd	r30, Y+2	; 0x02
    102e:	fb 81       	ldd	r31, Y+3	; 0x03
    1030:	86 89       	ldd	r24, Z+22	; 0x16
    1032:	80 93 22 02 	sts	0x0222, r24
    1036:	ea 81       	ldd	r30, Y+2	; 0x02
    1038:	fb 81       	ldd	r31, Y+3	; 0x03
    103a:	86 89       	ldd	r24, Z+22	; 0x16
    103c:	28 2f       	mov	r18, r24
    103e:	30 e0       	ldi	r19, 0x00	; 0
    1040:	c9 01       	movw	r24, r18
    1042:	88 0f       	add	r24, r24
    1044:	99 1f       	adc	r25, r25
    1046:	88 0f       	add	r24, r24
    1048:	99 1f       	adc	r25, r25
    104a:	88 0f       	add	r24, r24
    104c:	99 1f       	adc	r25, r25
    104e:	82 0f       	add	r24, r18
    1050:	93 1f       	adc	r25, r19
    1052:	ac 01       	movw	r20, r24
    1054:	47 5d       	subi	r20, 0xD7	; 215
    1056:	5d 4f       	sbci	r21, 0xFD	; 253
    1058:	8a 81       	ldd	r24, Y+2	; 0x02
    105a:	9b 81       	ldd	r25, Y+3	; 0x03
    105c:	9c 01       	movw	r18, r24
    105e:	2e 5f       	subi	r18, 0xFE	; 254
    1060:	3f 4f       	sbci	r19, 0xFF	; 255
    1062:	ca 01       	movw	r24, r20
    1064:	b9 01       	movw	r22, r18
    1066:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <vListInsertEnd>
    106a:	0a c0       	rjmp	.+20     	; 0x1080 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    106c:	8a 81       	ldd	r24, Y+2	; 0x02
    106e:	9b 81       	ldd	r25, Y+3	; 0x03
    1070:	9c 01       	movw	r18, r24
    1072:	24 5f       	subi	r18, 0xF4	; 244
    1074:	3f 4f       	sbci	r19, 0xFF	; 255
    1076:	83 e6       	ldi	r24, 0x63	; 99
    1078:	92 e0       	ldi	r25, 0x02	; 2
    107a:	b9 01       	movw	r22, r18
    107c:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1080:	ea 81       	ldd	r30, Y+2	; 0x02
    1082:	fb 81       	ldd	r31, Y+3	; 0x03
    1084:	96 89       	ldd	r25, Z+22	; 0x16
    1086:	e0 91 1c 02 	lds	r30, 0x021C
    108a:	f0 91 1d 02 	lds	r31, 0x021D
    108e:	86 89       	ldd	r24, Z+22	; 0x16
    1090:	98 17       	cp	r25, r24
    1092:	18 f0       	brcs	.+6      	; 0x109a <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    1094:	81 e0       	ldi	r24, 0x01	; 1
    1096:	89 83       	std	Y+1, r24	; 0x01
    1098:	01 c0       	rjmp	.+2      	; 0x109c <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    109a:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    109c:	89 81       	ldd	r24, Y+1	; 0x01
}
    109e:	0f 90       	pop	r0
    10a0:	0f 90       	pop	r0
    10a2:	0f 90       	pop	r0
    10a4:	0f 90       	pop	r0
    10a6:	0f 90       	pop	r0
    10a8:	cf 91       	pop	r28
    10aa:	df 91       	pop	r29
    10ac:	08 95       	ret

000010ae <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    10ae:	df 93       	push	r29
    10b0:	cf 93       	push	r28
    10b2:	0f 92       	push	r0
    10b4:	0f 92       	push	r0
    10b6:	cd b7       	in	r28, 0x3d	; 61
    10b8:	de b7       	in	r29, 0x3e	; 62
    10ba:	9a 83       	std	Y+2, r25	; 0x02
    10bc:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    10be:	80 91 27 02 	lds	r24, 0x0227
    10c2:	e9 81       	ldd	r30, Y+1	; 0x01
    10c4:	fa 81       	ldd	r31, Y+2	; 0x02
    10c6:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    10c8:	80 91 1f 02 	lds	r24, 0x021F
    10cc:	90 91 20 02 	lds	r25, 0x0220
    10d0:	e9 81       	ldd	r30, Y+1	; 0x01
    10d2:	fa 81       	ldd	r31, Y+2	; 0x02
    10d4:	92 83       	std	Z+2, r25	; 0x02
    10d6:	81 83       	std	Z+1, r24	; 0x01
}
    10d8:	0f 90       	pop	r0
    10da:	0f 90       	pop	r0
    10dc:	cf 91       	pop	r28
    10de:	df 91       	pop	r29
    10e0:	08 95       	ret

000010e2 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    10e2:	df 93       	push	r29
    10e4:	cf 93       	push	r28
    10e6:	00 d0       	rcall	.+0      	; 0x10e8 <xTaskCheckForTimeOut+0x6>
    10e8:	0f 92       	push	r0
    10ea:	0f 92       	push	r0
    10ec:	cd b7       	in	r28, 0x3d	; 61
    10ee:	de b7       	in	r29, 0x3e	; 62
    10f0:	9b 83       	std	Y+3, r25	; 0x03
    10f2:	8a 83       	std	Y+2, r24	; 0x02
    10f4:	7d 83       	std	Y+5, r23	; 0x05
    10f6:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    10f8:	0f b6       	in	r0, 0x3f	; 63
    10fa:	f8 94       	cli
    10fc:	0f 92       	push	r0
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    10fe:	ec 81       	ldd	r30, Y+4	; 0x04
    1100:	fd 81       	ldd	r31, Y+5	; 0x05
    1102:	80 81       	ld	r24, Z
    1104:	91 81       	ldd	r25, Z+1	; 0x01
    1106:	2f ef       	ldi	r18, 0xFF	; 255
    1108:	8f 3f       	cpi	r24, 0xFF	; 255
    110a:	92 07       	cpc	r25, r18
    110c:	11 f4       	brne	.+4      	; 0x1112 <xTaskCheckForTimeOut+0x30>
			{
				xReturn = pdFALSE;
    110e:	19 82       	std	Y+1, r1	; 0x01
    1110:	44 c0       	rjmp	.+136    	; 0x119a <xTaskCheckForTimeOut+0xb8>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    1112:	ea 81       	ldd	r30, Y+2	; 0x02
    1114:	fb 81       	ldd	r31, Y+3	; 0x03
    1116:	90 81       	ld	r25, Z
    1118:	80 91 27 02 	lds	r24, 0x0227
    111c:	98 17       	cp	r25, r24
    111e:	71 f0       	breq	.+28     	; 0x113c <xTaskCheckForTimeOut+0x5a>
    1120:	ea 81       	ldd	r30, Y+2	; 0x02
    1122:	fb 81       	ldd	r31, Y+3	; 0x03
    1124:	21 81       	ldd	r18, Z+1	; 0x01
    1126:	32 81       	ldd	r19, Z+2	; 0x02
    1128:	80 91 1f 02 	lds	r24, 0x021F
    112c:	90 91 20 02 	lds	r25, 0x0220
    1130:	82 17       	cp	r24, r18
    1132:	93 07       	cpc	r25, r19
    1134:	18 f0       	brcs	.+6      	; 0x113c <xTaskCheckForTimeOut+0x5a>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    1136:	81 e0       	ldi	r24, 0x01	; 1
    1138:	89 83       	std	Y+1, r24	; 0x01
    113a:	2f c0       	rjmp	.+94     	; 0x119a <xTaskCheckForTimeOut+0xb8>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    113c:	20 91 1f 02 	lds	r18, 0x021F
    1140:	30 91 20 02 	lds	r19, 0x0220
    1144:	ea 81       	ldd	r30, Y+2	; 0x02
    1146:	fb 81       	ldd	r31, Y+3	; 0x03
    1148:	81 81       	ldd	r24, Z+1	; 0x01
    114a:	92 81       	ldd	r25, Z+2	; 0x02
    114c:	28 1b       	sub	r18, r24
    114e:	39 0b       	sbc	r19, r25
    1150:	ec 81       	ldd	r30, Y+4	; 0x04
    1152:	fd 81       	ldd	r31, Y+5	; 0x05
    1154:	80 81       	ld	r24, Z
    1156:	91 81       	ldd	r25, Z+1	; 0x01
    1158:	28 17       	cp	r18, r24
    115a:	39 07       	cpc	r19, r25
    115c:	e0 f4       	brcc	.+56     	; 0x1196 <xTaskCheckForTimeOut+0xb4>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    115e:	ec 81       	ldd	r30, Y+4	; 0x04
    1160:	fd 81       	ldd	r31, Y+5	; 0x05
    1162:	40 81       	ld	r20, Z
    1164:	51 81       	ldd	r21, Z+1	; 0x01
    1166:	ea 81       	ldd	r30, Y+2	; 0x02
    1168:	fb 81       	ldd	r31, Y+3	; 0x03
    116a:	21 81       	ldd	r18, Z+1	; 0x01
    116c:	32 81       	ldd	r19, Z+2	; 0x02
    116e:	80 91 1f 02 	lds	r24, 0x021F
    1172:	90 91 20 02 	lds	r25, 0x0220
    1176:	b9 01       	movw	r22, r18
    1178:	68 1b       	sub	r22, r24
    117a:	79 0b       	sbc	r23, r25
    117c:	cb 01       	movw	r24, r22
    117e:	84 0f       	add	r24, r20
    1180:	95 1f       	adc	r25, r21
    1182:	ec 81       	ldd	r30, Y+4	; 0x04
    1184:	fd 81       	ldd	r31, Y+5	; 0x05
    1186:	91 83       	std	Z+1, r25	; 0x01
    1188:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    118a:	8a 81       	ldd	r24, Y+2	; 0x02
    118c:	9b 81       	ldd	r25, Y+3	; 0x03
    118e:	0e 94 57 08 	call	0x10ae	; 0x10ae <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    1192:	19 82       	std	Y+1, r1	; 0x01
    1194:	02 c0       	rjmp	.+4      	; 0x119a <xTaskCheckForTimeOut+0xb8>
		}
		else
		{
			xReturn = pdTRUE;
    1196:	81 e0       	ldi	r24, 0x01	; 1
    1198:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    119a:	0f 90       	pop	r0
    119c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    119e:	89 81       	ldd	r24, Y+1	; 0x01
}
    11a0:	0f 90       	pop	r0
    11a2:	0f 90       	pop	r0
    11a4:	0f 90       	pop	r0
    11a6:	0f 90       	pop	r0
    11a8:	0f 90       	pop	r0
    11aa:	cf 91       	pop	r28
    11ac:	df 91       	pop	r29
    11ae:	08 95       	ret

000011b0 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    11b0:	df 93       	push	r29
    11b2:	cf 93       	push	r28
    11b4:	cd b7       	in	r28, 0x3d	; 61
    11b6:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    11b8:	81 e0       	ldi	r24, 0x01	; 1
    11ba:	80 93 26 02 	sts	0x0226, r24
}
    11be:	cf 91       	pop	r28
    11c0:	df 91       	pop	r29
    11c2:	08 95       	ret

000011c4 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    11c4:	df 93       	push	r29
    11c6:	cf 93       	push	r28
    11c8:	0f 92       	push	r0
    11ca:	0f 92       	push	r0
    11cc:	cd b7       	in	r28, 0x3d	; 61
    11ce:	de b7       	in	r29, 0x3e	; 62
    11d0:	9a 83       	std	Y+2, r25	; 0x02
    11d2:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    11d4:	0e 94 8b 09 	call	0x1316	; 0x1316 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    11d8:	80 91 29 02 	lds	r24, 0x0229
    11dc:	82 30       	cpi	r24, 0x02	; 2
    11de:	d0 f3       	brcs	.-12     	; 0x11d4 <prvIdleTask+0x10>
			{
				taskYIELD();
    11e0:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <vPortYield>
    11e4:	f7 cf       	rjmp	.-18     	; 0x11d4 <prvIdleTask+0x10>

000011e6 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    11e6:	0f 93       	push	r16
    11e8:	1f 93       	push	r17
    11ea:	df 93       	push	r29
    11ec:	cf 93       	push	r28
    11ee:	cd b7       	in	r28, 0x3d	; 61
    11f0:	de b7       	in	r29, 0x3e	; 62
    11f2:	29 97       	sbiw	r28, 0x09	; 9
    11f4:	0f b6       	in	r0, 0x3f	; 63
    11f6:	f8 94       	cli
    11f8:	de bf       	out	0x3e, r29	; 62
    11fa:	0f be       	out	0x3f, r0	; 63
    11fc:	cd bf       	out	0x3d, r28	; 61
    11fe:	9a 83       	std	Y+2, r25	; 0x02
    1200:	89 83       	std	Y+1, r24	; 0x01
    1202:	7c 83       	std	Y+4, r23	; 0x04
    1204:	6b 83       	std	Y+3, r22	; 0x03
    1206:	4d 83       	std	Y+5, r20	; 0x05
    1208:	3f 83       	std	Y+7, r19	; 0x07
    120a:	2e 83       	std	Y+6, r18	; 0x06
    120c:	19 87       	std	Y+9, r17	; 0x09
    120e:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    1210:	89 81       	ldd	r24, Y+1	; 0x01
    1212:	9a 81       	ldd	r25, Y+2	; 0x02
    1214:	49 96       	adiw	r24, 0x19	; 25
    1216:	2b 81       	ldd	r18, Y+3	; 0x03
    1218:	3c 81       	ldd	r19, Y+4	; 0x04
    121a:	b9 01       	movw	r22, r18
    121c:	40 e1       	ldi	r20, 0x10	; 16
    121e:	50 e0       	ldi	r21, 0x00	; 0
    1220:	0e 94 f5 1e 	call	0x3dea	; 0x3dea <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    1224:	e9 81       	ldd	r30, Y+1	; 0x01
    1226:	fa 81       	ldd	r31, Y+2	; 0x02
    1228:	10 a6       	std	Z+40, r1	; 0x28

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    122a:	8d 81       	ldd	r24, Y+5	; 0x05
    122c:	84 30       	cpi	r24, 0x04	; 4
    122e:	10 f0       	brcs	.+4      	; 0x1234 <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    1230:	83 e0       	ldi	r24, 0x03	; 3
    1232:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    1234:	e9 81       	ldd	r30, Y+1	; 0x01
    1236:	fa 81       	ldd	r31, Y+2	; 0x02
    1238:	8d 81       	ldd	r24, Y+5	; 0x05
    123a:	86 8b       	std	Z+22, r24	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    123c:	e9 81       	ldd	r30, Y+1	; 0x01
    123e:	fa 81       	ldd	r31, Y+2	; 0x02
    1240:	8d 81       	ldd	r24, Y+5	; 0x05
    1242:	81 a7       	std	Z+41, r24	; 0x29
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    1244:	89 81       	ldd	r24, Y+1	; 0x01
    1246:	9a 81       	ldd	r25, Y+2	; 0x02
    1248:	02 96       	adiw	r24, 0x02	; 2
    124a:	0e 94 d7 10 	call	0x21ae	; 0x21ae <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    124e:	89 81       	ldd	r24, Y+1	; 0x01
    1250:	9a 81       	ldd	r25, Y+2	; 0x02
    1252:	0c 96       	adiw	r24, 0x0c	; 12
    1254:	0e 94 d7 10 	call	0x21ae	; 0x21ae <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    1258:	e9 81       	ldd	r30, Y+1	; 0x01
    125a:	fa 81       	ldd	r31, Y+2	; 0x02
    125c:	89 81       	ldd	r24, Y+1	; 0x01
    125e:	9a 81       	ldd	r25, Y+2	; 0x02
    1260:	91 87       	std	Z+9, r25	; 0x09
    1262:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    1264:	8d 81       	ldd	r24, Y+5	; 0x05
    1266:	28 2f       	mov	r18, r24
    1268:	30 e0       	ldi	r19, 0x00	; 0
    126a:	84 e0       	ldi	r24, 0x04	; 4
    126c:	90 e0       	ldi	r25, 0x00	; 0
    126e:	82 1b       	sub	r24, r18
    1270:	93 0b       	sbc	r25, r19
    1272:	e9 81       	ldd	r30, Y+1	; 0x01
    1274:	fa 81       	ldd	r31, Y+2	; 0x02
    1276:	95 87       	std	Z+13, r25	; 0x0d
    1278:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    127a:	e9 81       	ldd	r30, Y+1	; 0x01
    127c:	fa 81       	ldd	r31, Y+2	; 0x02
    127e:	89 81       	ldd	r24, Y+1	; 0x01
    1280:	9a 81       	ldd	r25, Y+2	; 0x02
    1282:	93 8b       	std	Z+19, r25	; 0x13
    1284:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    1286:	29 96       	adiw	r28, 0x09	; 9
    1288:	0f b6       	in	r0, 0x3f	; 63
    128a:	f8 94       	cli
    128c:	de bf       	out	0x3e, r29	; 62
    128e:	0f be       	out	0x3f, r0	; 63
    1290:	cd bf       	out	0x3d, r28	; 61
    1292:	cf 91       	pop	r28
    1294:	df 91       	pop	r29
    1296:	1f 91       	pop	r17
    1298:	0f 91       	pop	r16
    129a:	08 95       	ret

0000129c <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    129c:	df 93       	push	r29
    129e:	cf 93       	push	r28
    12a0:	0f 92       	push	r0
    12a2:	cd b7       	in	r28, 0x3d	; 61
    12a4:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    12a6:	19 82       	std	Y+1, r1	; 0x01
    12a8:	13 c0       	rjmp	.+38     	; 0x12d0 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    12aa:	89 81       	ldd	r24, Y+1	; 0x01
    12ac:	28 2f       	mov	r18, r24
    12ae:	30 e0       	ldi	r19, 0x00	; 0
    12b0:	c9 01       	movw	r24, r18
    12b2:	88 0f       	add	r24, r24
    12b4:	99 1f       	adc	r25, r25
    12b6:	88 0f       	add	r24, r24
    12b8:	99 1f       	adc	r25, r25
    12ba:	88 0f       	add	r24, r24
    12bc:	99 1f       	adc	r25, r25
    12be:	82 0f       	add	r24, r18
    12c0:	93 1f       	adc	r25, r19
    12c2:	87 5d       	subi	r24, 0xD7	; 215
    12c4:	9d 4f       	sbci	r25, 0xFD	; 253
    12c6:	0e 94 ac 10 	call	0x2158	; 0x2158 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    12ca:	89 81       	ldd	r24, Y+1	; 0x01
    12cc:	8f 5f       	subi	r24, 0xFF	; 255
    12ce:	89 83       	std	Y+1, r24	; 0x01
    12d0:	89 81       	ldd	r24, Y+1	; 0x01
    12d2:	84 30       	cpi	r24, 0x04	; 4
    12d4:	50 f3       	brcs	.-44     	; 0x12aa <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    12d6:	8d e4       	ldi	r24, 0x4D	; 77
    12d8:	92 e0       	ldi	r25, 0x02	; 2
    12da:	0e 94 ac 10 	call	0x2158	; 0x2158 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    12de:	86 e5       	ldi	r24, 0x56	; 86
    12e0:	92 e0       	ldi	r25, 0x02	; 2
    12e2:	0e 94 ac 10 	call	0x2158	; 0x2158 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    12e6:	83 e6       	ldi	r24, 0x63	; 99
    12e8:	92 e0       	ldi	r25, 0x02	; 2
    12ea:	0e 94 ac 10 	call	0x2158	; 0x2158 <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
    12ee:	8c e6       	ldi	r24, 0x6C	; 108
    12f0:	92 e0       	ldi	r25, 0x02	; 2
    12f2:	0e 94 ac 10 	call	0x2158	; 0x2158 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    12f6:	8d e4       	ldi	r24, 0x4D	; 77
    12f8:	92 e0       	ldi	r25, 0x02	; 2
    12fa:	90 93 60 02 	sts	0x0260, r25
    12fe:	80 93 5f 02 	sts	0x025F, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1302:	86 e5       	ldi	r24, 0x56	; 86
    1304:	92 e0       	ldi	r25, 0x02	; 2
    1306:	90 93 62 02 	sts	0x0262, r25
    130a:	80 93 61 02 	sts	0x0261, r24
}
    130e:	0f 90       	pop	r0
    1310:	cf 91       	pop	r28
    1312:	df 91       	pop	r29
    1314:	08 95       	ret

00001316 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    1316:	df 93       	push	r29
    1318:	cf 93       	push	r28
    131a:	cd b7       	in	r28, 0x3d	; 61
    131c:	de b7       	in	r29, 0x3e	; 62
				prvDeleteTCB( pxTCB );
			}
		}
	}
	#endif
}
    131e:	cf 91       	pop	r28
    1320:	df 91       	pop	r29
    1322:	08 95       	ret

00001324 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    1324:	df 93       	push	r29
    1326:	cf 93       	push	r28
    1328:	0f 92       	push	r0
    132a:	0f 92       	push	r0
    132c:	cd b7       	in	r28, 0x3d	; 61
    132e:	de b7       	in	r29, 0x3e	; 62
    1330:	9a 83       	std	Y+2, r25	; 0x02
    1332:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1334:	e0 91 1c 02 	lds	r30, 0x021C
    1338:	f0 91 1d 02 	lds	r31, 0x021D
    133c:	89 81       	ldd	r24, Y+1	; 0x01
    133e:	9a 81       	ldd	r25, Y+2	; 0x02
    1340:	93 83       	std	Z+3, r25	; 0x03
    1342:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    1344:	20 91 1f 02 	lds	r18, 0x021F
    1348:	30 91 20 02 	lds	r19, 0x0220
    134c:	89 81       	ldd	r24, Y+1	; 0x01
    134e:	9a 81       	ldd	r25, Y+2	; 0x02
    1350:	82 17       	cp	r24, r18
    1352:	93 07       	cpc	r25, r19
    1354:	70 f4       	brcc	.+28     	; 0x1372 <prvAddCurrentTaskToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1356:	80 91 61 02 	lds	r24, 0x0261
    135a:	90 91 62 02 	lds	r25, 0x0262
    135e:	20 91 1c 02 	lds	r18, 0x021C
    1362:	30 91 1d 02 	lds	r19, 0x021D
    1366:	2e 5f       	subi	r18, 0xFE	; 254
    1368:	3f 4f       	sbci	r19, 0xFF	; 255
    136a:	b9 01       	movw	r22, r18
    136c:	0e 94 33 11 	call	0x2266	; 0x2266 <vListInsert>
    1370:	1e c0       	rjmp	.+60     	; 0x13ae <prvAddCurrentTaskToDelayedList+0x8a>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1372:	40 91 5f 02 	lds	r20, 0x025F
    1376:	50 91 60 02 	lds	r21, 0x0260
    137a:	80 91 1c 02 	lds	r24, 0x021C
    137e:	90 91 1d 02 	lds	r25, 0x021D
    1382:	9c 01       	movw	r18, r24
    1384:	2e 5f       	subi	r18, 0xFE	; 254
    1386:	3f 4f       	sbci	r19, 0xFF	; 255
    1388:	ca 01       	movw	r24, r20
    138a:	b9 01       	movw	r22, r18
    138c:	0e 94 33 11 	call	0x2266	; 0x2266 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    1390:	20 91 13 02 	lds	r18, 0x0213
    1394:	30 91 14 02 	lds	r19, 0x0214
    1398:	89 81       	ldd	r24, Y+1	; 0x01
    139a:	9a 81       	ldd	r25, Y+2	; 0x02
    139c:	82 17       	cp	r24, r18
    139e:	93 07       	cpc	r25, r19
    13a0:	30 f4       	brcc	.+12     	; 0x13ae <prvAddCurrentTaskToDelayedList+0x8a>
		{
			xNextTaskUnblockTime = xTimeToWake;
    13a2:	89 81       	ldd	r24, Y+1	; 0x01
    13a4:	9a 81       	ldd	r25, Y+2	; 0x02
    13a6:	90 93 14 02 	sts	0x0214, r25
    13aa:	80 93 13 02 	sts	0x0213, r24
		}
	}
}
    13ae:	0f 90       	pop	r0
    13b0:	0f 90       	pop	r0
    13b2:	cf 91       	pop	r28
    13b4:	df 91       	pop	r29
    13b6:	08 95       	ret

000013b8 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    13b8:	df 93       	push	r29
    13ba:	cf 93       	push	r28
    13bc:	cd b7       	in	r28, 0x3d	; 61
    13be:	de b7       	in	r29, 0x3e	; 62
    13c0:	28 97       	sbiw	r28, 0x08	; 8
    13c2:	0f b6       	in	r0, 0x3f	; 63
    13c4:	f8 94       	cli
    13c6:	de bf       	out	0x3e, r29	; 62
    13c8:	0f be       	out	0x3f, r0	; 63
    13ca:	cd bf       	out	0x3d, r28	; 61
    13cc:	9c 83       	std	Y+4, r25	; 0x04
    13ce:	8b 83       	std	Y+3, r24	; 0x03
    13d0:	7e 83       	std	Y+6, r23	; 0x06
    13d2:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    13d4:	8a e2       	ldi	r24, 0x2A	; 42
    13d6:	90 e0       	ldi	r25, 0x00	; 0
    13d8:	0e 94 c4 14 	call	0x2988	; 0x2988 <pvPortMalloc>
    13dc:	9a 83       	std	Y+2, r25	; 0x02
    13de:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    13e0:	89 81       	ldd	r24, Y+1	; 0x01
    13e2:	9a 81       	ldd	r25, Y+2	; 0x02
    13e4:	00 97       	sbiw	r24, 0x00	; 0
    13e6:	69 f1       	breq	.+90     	; 0x1442 <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    13e8:	8d 81       	ldd	r24, Y+5	; 0x05
    13ea:	9e 81       	ldd	r25, Y+6	; 0x06
    13ec:	00 97       	sbiw	r24, 0x00	; 0
    13ee:	39 f4       	brne	.+14     	; 0x13fe <prvAllocateTCBAndStack+0x46>
    13f0:	8b 81       	ldd	r24, Y+3	; 0x03
    13f2:	9c 81       	ldd	r25, Y+4	; 0x04
    13f4:	0e 94 c4 14 	call	0x2988	; 0x2988 <pvPortMalloc>
    13f8:	98 87       	std	Y+8, r25	; 0x08
    13fa:	8f 83       	std	Y+7, r24	; 0x07
    13fc:	04 c0       	rjmp	.+8      	; 0x1406 <prvAllocateTCBAndStack+0x4e>
    13fe:	8d 81       	ldd	r24, Y+5	; 0x05
    1400:	9e 81       	ldd	r25, Y+6	; 0x06
    1402:	98 87       	std	Y+8, r25	; 0x08
    1404:	8f 83       	std	Y+7, r24	; 0x07
    1406:	e9 81       	ldd	r30, Y+1	; 0x01
    1408:	fa 81       	ldd	r31, Y+2	; 0x02
    140a:	8f 81       	ldd	r24, Y+7	; 0x07
    140c:	98 85       	ldd	r25, Y+8	; 0x08
    140e:	90 8f       	std	Z+24, r25	; 0x18
    1410:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    1412:	e9 81       	ldd	r30, Y+1	; 0x01
    1414:	fa 81       	ldd	r31, Y+2	; 0x02
    1416:	87 89       	ldd	r24, Z+23	; 0x17
    1418:	90 8d       	ldd	r25, Z+24	; 0x18
    141a:	00 97       	sbiw	r24, 0x00	; 0
    141c:	39 f4       	brne	.+14     	; 0x142c <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    141e:	89 81       	ldd	r24, Y+1	; 0x01
    1420:	9a 81       	ldd	r25, Y+2	; 0x02
    1422:	0e 94 0a 15 	call	0x2a14	; 0x2a14 <vPortFree>
			pxNewTCB = NULL;
    1426:	1a 82       	std	Y+2, r1	; 0x02
    1428:	19 82       	std	Y+1, r1	; 0x01
    142a:	0b c0       	rjmp	.+22     	; 0x1442 <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    142c:	e9 81       	ldd	r30, Y+1	; 0x01
    142e:	fa 81       	ldd	r31, Y+2	; 0x02
    1430:	87 89       	ldd	r24, Z+23	; 0x17
    1432:	90 8d       	ldd	r25, Z+24	; 0x18
    1434:	2b 81       	ldd	r18, Y+3	; 0x03
    1436:	3c 81       	ldd	r19, Y+4	; 0x04
    1438:	65 ea       	ldi	r22, 0xA5	; 165
    143a:	70 e0       	ldi	r23, 0x00	; 0
    143c:	a9 01       	movw	r20, r18
    143e:	0e 94 ee 1e 	call	0x3ddc	; 0x3ddc <memset>
		}
	}

	return pxNewTCB;
    1442:	89 81       	ldd	r24, Y+1	; 0x01
    1444:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1446:	28 96       	adiw	r28, 0x08	; 8
    1448:	0f b6       	in	r0, 0x3f	; 63
    144a:	f8 94       	cli
    144c:	de bf       	out	0x3e, r29	; 62
    144e:	0f be       	out	0x3f, r0	; 63
    1450:	cd bf       	out	0x3d, r28	; 61
    1452:	cf 91       	pop	r28
    1454:	df 91       	pop	r29
    1456:	08 95       	ret

00001458 <usTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
    1458:	df 93       	push	r29
    145a:	cf 93       	push	r28
    145c:	00 d0       	rcall	.+0      	; 0x145e <usTaskCheckFreeStackSpace+0x6>
    145e:	0f 92       	push	r0
    1460:	cd b7       	in	r28, 0x3d	; 61
    1462:	de b7       	in	r29, 0x3e	; 62
    1464:	9a 83       	std	Y+2, r25	; 0x02
    1466:	89 83       	std	Y+1, r24	; 0x01
	register unsigned short usCount = 0U;
    1468:	1c 82       	std	Y+4, r1	; 0x04
    146a:	1b 82       	std	Y+3, r1	; 0x03
    146c:	0a c0       	rjmp	.+20     	; 0x1482 <usTaskCheckFreeStackSpace+0x2a>

		while( *pucStackByte == tskSTACK_FILL_BYTE )
		{
			pucStackByte -= portSTACK_GROWTH;
    146e:	89 81       	ldd	r24, Y+1	; 0x01
    1470:	9a 81       	ldd	r25, Y+2	; 0x02
    1472:	01 96       	adiw	r24, 0x01	; 1
    1474:	9a 83       	std	Y+2, r25	; 0x02
    1476:	89 83       	std	Y+1, r24	; 0x01
			usCount++;
    1478:	8b 81       	ldd	r24, Y+3	; 0x03
    147a:	9c 81       	ldd	r25, Y+4	; 0x04
    147c:	01 96       	adiw	r24, 0x01	; 1
    147e:	9c 83       	std	Y+4, r25	; 0x04
    1480:	8b 83       	std	Y+3, r24	; 0x03

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    1482:	e9 81       	ldd	r30, Y+1	; 0x01
    1484:	fa 81       	ldd	r31, Y+2	; 0x02
    1486:	80 81       	ld	r24, Z
    1488:	85 3a       	cpi	r24, 0xA5	; 165
    148a:	89 f3       	breq	.-30     	; 0x146e <usTaskCheckFreeStackSpace+0x16>
			usCount++;
		}

		usCount /= sizeof( portSTACK_TYPE );

		return usCount;
    148c:	8b 81       	ldd	r24, Y+3	; 0x03
    148e:	9c 81       	ldd	r25, Y+4	; 0x04
	}
    1490:	0f 90       	pop	r0
    1492:	0f 90       	pop	r0
    1494:	0f 90       	pop	r0
    1496:	0f 90       	pop	r0
    1498:	cf 91       	pop	r28
    149a:	df 91       	pop	r29
    149c:	08 95       	ret

0000149e <uxTaskGetStackHighWaterMark>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
	{
    149e:	df 93       	push	r29
    14a0:	cf 93       	push	r28
    14a2:	cd b7       	in	r28, 0x3d	; 61
    14a4:	de b7       	in	r29, 0x3e	; 62
    14a6:	29 97       	sbiw	r28, 0x09	; 9
    14a8:	0f b6       	in	r0, 0x3f	; 63
    14aa:	f8 94       	cli
    14ac:	de bf       	out	0x3e, r29	; 62
    14ae:	0f be       	out	0x3f, r0	; 63
    14b0:	cd bf       	out	0x3d, r28	; 61
    14b2:	9f 83       	std	Y+7, r25	; 0x07
    14b4:	8e 83       	std	Y+6, r24	; 0x06
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    14b6:	8e 81       	ldd	r24, Y+6	; 0x06
    14b8:	9f 81       	ldd	r25, Y+7	; 0x07
    14ba:	00 97       	sbiw	r24, 0x00	; 0
    14bc:	39 f4       	brne	.+14     	; 0x14cc <uxTaskGetStackHighWaterMark+0x2e>
    14be:	80 91 1c 02 	lds	r24, 0x021C
    14c2:	90 91 1d 02 	lds	r25, 0x021D
    14c6:	99 87       	std	Y+9, r25	; 0x09
    14c8:	88 87       	std	Y+8, r24	; 0x08
    14ca:	04 c0       	rjmp	.+8      	; 0x14d4 <uxTaskGetStackHighWaterMark+0x36>
    14cc:	8e 81       	ldd	r24, Y+6	; 0x06
    14ce:	9f 81       	ldd	r25, Y+7	; 0x07
    14d0:	99 87       	std	Y+9, r25	; 0x09
    14d2:	88 87       	std	Y+8, r24	; 0x08
    14d4:	88 85       	ldd	r24, Y+8	; 0x08
    14d6:	99 85       	ldd	r25, Y+9	; 0x09
    14d8:	9d 83       	std	Y+5, r25	; 0x05
    14da:	8c 83       	std	Y+4, r24	; 0x04

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    14dc:	ec 81       	ldd	r30, Y+4	; 0x04
    14de:	fd 81       	ldd	r31, Y+5	; 0x05
    14e0:	87 89       	ldd	r24, Z+23	; 0x17
    14e2:	90 8d       	ldd	r25, Z+24	; 0x18
    14e4:	9b 83       	std	Y+3, r25	; 0x03
    14e6:	8a 83       	std	Y+2, r24	; 0x02
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
		}
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
    14e8:	8a 81       	ldd	r24, Y+2	; 0x02
    14ea:	9b 81       	ldd	r25, Y+3	; 0x03
    14ec:	0e 94 2c 0a 	call	0x1458	; 0x1458 <usTaskCheckFreeStackSpace>
    14f0:	89 83       	std	Y+1, r24	; 0x01

		return uxReturn;
    14f2:	89 81       	ldd	r24, Y+1	; 0x01
	}
    14f4:	29 96       	adiw	r28, 0x09	; 9
    14f6:	0f b6       	in	r0, 0x3f	; 63
    14f8:	f8 94       	cli
    14fa:	de bf       	out	0x3e, r29	; 62
    14fc:	0f be       	out	0x3f, r0	; 63
    14fe:	cd bf       	out	0x3d, r28	; 61
    1500:	cf 91       	pop	r28
    1502:	df 91       	pop	r29
    1504:	08 95       	ret

00001506 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	xTaskHandle xTaskGetCurrentTaskHandle( void )
	{
    1506:	df 93       	push	r29
    1508:	cf 93       	push	r28
    150a:	0f 92       	push	r0
    150c:	0f 92       	push	r0
    150e:	cd b7       	in	r28, 0x3d	; 61
    1510:	de b7       	in	r29, 0x3e	; 62
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    1512:	80 91 1c 02 	lds	r24, 0x021C
    1516:	90 91 1d 02 	lds	r25, 0x021D
    151a:	9a 83       	std	Y+2, r25	; 0x02
    151c:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    151e:	89 81       	ldd	r24, Y+1	; 0x01
    1520:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    1522:	0f 90       	pop	r0
    1524:	0f 90       	pop	r0
    1526:	cf 91       	pop	r28
    1528:	df 91       	pop	r29
    152a:	08 95       	ret

0000152c <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    152c:	df 93       	push	r29
    152e:	cf 93       	push	r28
    1530:	00 d0       	rcall	.+0      	; 0x1532 <vTaskPriorityInherit+0x6>
    1532:	0f 92       	push	r0
    1534:	cd b7       	in	r28, 0x3d	; 61
    1536:	de b7       	in	r29, 0x3e	; 62
    1538:	9c 83       	std	Y+4, r25	; 0x04
    153a:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
    153c:	8b 81       	ldd	r24, Y+3	; 0x03
    153e:	9c 81       	ldd	r25, Y+4	; 0x04
    1540:	9a 83       	std	Y+2, r25	; 0x02
    1542:	89 83       	std	Y+1, r24	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    1544:	8b 81       	ldd	r24, Y+3	; 0x03
    1546:	9c 81       	ldd	r25, Y+4	; 0x04
    1548:	00 97       	sbiw	r24, 0x00	; 0
    154a:	09 f4       	brne	.+2      	; 0x154e <vTaskPriorityInherit+0x22>
    154c:	6d c0       	rjmp	.+218    	; 0x1628 <vTaskPriorityInherit+0xfc>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    154e:	e9 81       	ldd	r30, Y+1	; 0x01
    1550:	fa 81       	ldd	r31, Y+2	; 0x02
    1552:	96 89       	ldd	r25, Z+22	; 0x16
    1554:	e0 91 1c 02 	lds	r30, 0x021C
    1558:	f0 91 1d 02 	lds	r31, 0x021D
    155c:	86 89       	ldd	r24, Z+22	; 0x16
    155e:	98 17       	cp	r25, r24
    1560:	08 f0       	brcs	.+2      	; 0x1564 <vTaskPriorityInherit+0x38>
    1562:	62 c0       	rjmp	.+196    	; 0x1628 <vTaskPriorityInherit+0xfc>
			{
				/* Adjust the mutex holder state to account for its new priority. */
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    1564:	e0 91 1c 02 	lds	r30, 0x021C
    1568:	f0 91 1d 02 	lds	r31, 0x021D
    156c:	86 89       	ldd	r24, Z+22	; 0x16
    156e:	28 2f       	mov	r18, r24
    1570:	30 e0       	ldi	r19, 0x00	; 0
    1572:	84 e0       	ldi	r24, 0x04	; 4
    1574:	90 e0       	ldi	r25, 0x00	; 0
    1576:	82 1b       	sub	r24, r18
    1578:	93 0b       	sbc	r25, r19
    157a:	e9 81       	ldd	r30, Y+1	; 0x01
    157c:	fa 81       	ldd	r31, Y+2	; 0x02
    157e:	95 87       	std	Z+13, r25	; 0x0d
    1580:	84 87       	std	Z+12, r24	; 0x0c

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    1582:	e9 81       	ldd	r30, Y+1	; 0x01
    1584:	fa 81       	ldd	r31, Y+2	; 0x02
    1586:	42 85       	ldd	r20, Z+10	; 0x0a
    1588:	53 85       	ldd	r21, Z+11	; 0x0b
    158a:	e9 81       	ldd	r30, Y+1	; 0x01
    158c:	fa 81       	ldd	r31, Y+2	; 0x02
    158e:	86 89       	ldd	r24, Z+22	; 0x16
    1590:	28 2f       	mov	r18, r24
    1592:	30 e0       	ldi	r19, 0x00	; 0
    1594:	c9 01       	movw	r24, r18
    1596:	88 0f       	add	r24, r24
    1598:	99 1f       	adc	r25, r25
    159a:	88 0f       	add	r24, r24
    159c:	99 1f       	adc	r25, r25
    159e:	88 0f       	add	r24, r24
    15a0:	99 1f       	adc	r25, r25
    15a2:	82 0f       	add	r24, r18
    15a4:	93 1f       	adc	r25, r19
    15a6:	87 5d       	subi	r24, 0xD7	; 215
    15a8:	9d 4f       	sbci	r25, 0xFD	; 253
    15aa:	48 17       	cp	r20, r24
    15ac:	59 07       	cpc	r21, r25
    15ae:	a1 f5       	brne	.+104    	; 0x1618 <vTaskPriorityInherit+0xec>
				{
					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    15b0:	89 81       	ldd	r24, Y+1	; 0x01
    15b2:	9a 81       	ldd	r25, Y+2	; 0x02
    15b4:	02 96       	adiw	r24, 0x02	; 2
    15b6:	0e 94 9f 11 	call	0x233e	; 0x233e <uxListRemove>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    15ba:	e0 91 1c 02 	lds	r30, 0x021C
    15be:	f0 91 1d 02 	lds	r31, 0x021D
    15c2:	86 89       	ldd	r24, Z+22	; 0x16
    15c4:	e9 81       	ldd	r30, Y+1	; 0x01
    15c6:	fa 81       	ldd	r31, Y+2	; 0x02
    15c8:	86 8b       	std	Z+22, r24	; 0x16
					prvAddTaskToReadyQueue( pxTCB );
    15ca:	e9 81       	ldd	r30, Y+1	; 0x01
    15cc:	fa 81       	ldd	r31, Y+2	; 0x02
    15ce:	96 89       	ldd	r25, Z+22	; 0x16
    15d0:	80 91 22 02 	lds	r24, 0x0222
    15d4:	89 17       	cp	r24, r25
    15d6:	28 f4       	brcc	.+10     	; 0x15e2 <vTaskPriorityInherit+0xb6>
    15d8:	e9 81       	ldd	r30, Y+1	; 0x01
    15da:	fa 81       	ldd	r31, Y+2	; 0x02
    15dc:	86 89       	ldd	r24, Z+22	; 0x16
    15de:	80 93 22 02 	sts	0x0222, r24
    15e2:	e9 81       	ldd	r30, Y+1	; 0x01
    15e4:	fa 81       	ldd	r31, Y+2	; 0x02
    15e6:	86 89       	ldd	r24, Z+22	; 0x16
    15e8:	28 2f       	mov	r18, r24
    15ea:	30 e0       	ldi	r19, 0x00	; 0
    15ec:	c9 01       	movw	r24, r18
    15ee:	88 0f       	add	r24, r24
    15f0:	99 1f       	adc	r25, r25
    15f2:	88 0f       	add	r24, r24
    15f4:	99 1f       	adc	r25, r25
    15f6:	88 0f       	add	r24, r24
    15f8:	99 1f       	adc	r25, r25
    15fa:	82 0f       	add	r24, r18
    15fc:	93 1f       	adc	r25, r19
    15fe:	ac 01       	movw	r20, r24
    1600:	47 5d       	subi	r20, 0xD7	; 215
    1602:	5d 4f       	sbci	r21, 0xFD	; 253
    1604:	89 81       	ldd	r24, Y+1	; 0x01
    1606:	9a 81       	ldd	r25, Y+2	; 0x02
    1608:	9c 01       	movw	r18, r24
    160a:	2e 5f       	subi	r18, 0xFE	; 254
    160c:	3f 4f       	sbci	r19, 0xFF	; 255
    160e:	ca 01       	movw	r24, r20
    1610:	b9 01       	movw	r22, r18
    1612:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <vListInsertEnd>
    1616:	08 c0       	rjmp	.+16     	; 0x1628 <vTaskPriorityInherit+0xfc>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    1618:	e0 91 1c 02 	lds	r30, 0x021C
    161c:	f0 91 1d 02 	lds	r31, 0x021D
    1620:	86 89       	ldd	r24, Z+22	; 0x16
    1622:	e9 81       	ldd	r30, Y+1	; 0x01
    1624:	fa 81       	ldd	r31, Y+2	; 0x02
    1626:	86 8b       	std	Z+22, r24	; 0x16
				}

				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
			}
		}
	}
    1628:	0f 90       	pop	r0
    162a:	0f 90       	pop	r0
    162c:	0f 90       	pop	r0
    162e:	0f 90       	pop	r0
    1630:	cf 91       	pop	r28
    1632:	df 91       	pop	r29
    1634:	08 95       	ret

00001636 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    1636:	df 93       	push	r29
    1638:	cf 93       	push	r28
    163a:	00 d0       	rcall	.+0      	; 0x163c <vTaskPriorityDisinherit+0x6>
    163c:	0f 92       	push	r0
    163e:	cd b7       	in	r28, 0x3d	; 61
    1640:	de b7       	in	r29, 0x3e	; 62
    1642:	9c 83       	std	Y+4, r25	; 0x04
    1644:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
    1646:	8b 81       	ldd	r24, Y+3	; 0x03
    1648:	9c 81       	ldd	r25, Y+4	; 0x04
    164a:	9a 83       	std	Y+2, r25	; 0x02
    164c:	89 83       	std	Y+1, r24	; 0x01

		if( pxMutexHolder != NULL )
    164e:	8b 81       	ldd	r24, Y+3	; 0x03
    1650:	9c 81       	ldd	r25, Y+4	; 0x04
    1652:	00 97       	sbiw	r24, 0x00	; 0
    1654:	09 f4       	brne	.+2      	; 0x1658 <vTaskPriorityDisinherit+0x22>
    1656:	47 c0       	rjmp	.+142    	; 0x16e6 <vTaskPriorityDisinherit+0xb0>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    1658:	e9 81       	ldd	r30, Y+1	; 0x01
    165a:	fa 81       	ldd	r31, Y+2	; 0x02
    165c:	96 89       	ldd	r25, Z+22	; 0x16
    165e:	e9 81       	ldd	r30, Y+1	; 0x01
    1660:	fa 81       	ldd	r31, Y+2	; 0x02
    1662:	81 a5       	ldd	r24, Z+41	; 0x29
    1664:	98 17       	cp	r25, r24
    1666:	09 f4       	brne	.+2      	; 0x166a <vTaskPriorityDisinherit+0x34>
    1668:	3e c0       	rjmp	.+124    	; 0x16e6 <vTaskPriorityDisinherit+0xb0>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    166a:	89 81       	ldd	r24, Y+1	; 0x01
    166c:	9a 81       	ldd	r25, Y+2	; 0x02
    166e:	02 96       	adiw	r24, 0x02	; 2
    1670:	0e 94 9f 11 	call	0x233e	; 0x233e <uxListRemove>
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    1674:	e9 81       	ldd	r30, Y+1	; 0x01
    1676:	fa 81       	ldd	r31, Y+2	; 0x02
    1678:	81 a5       	ldd	r24, Z+41	; 0x29
    167a:	e9 81       	ldd	r30, Y+1	; 0x01
    167c:	fa 81       	ldd	r31, Y+2	; 0x02
    167e:	86 8b       	std	Z+22, r24	; 0x16
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    1680:	e9 81       	ldd	r30, Y+1	; 0x01
    1682:	fa 81       	ldd	r31, Y+2	; 0x02
    1684:	86 89       	ldd	r24, Z+22	; 0x16
    1686:	28 2f       	mov	r18, r24
    1688:	30 e0       	ldi	r19, 0x00	; 0
    168a:	84 e0       	ldi	r24, 0x04	; 4
    168c:	90 e0       	ldi	r25, 0x00	; 0
    168e:	82 1b       	sub	r24, r18
    1690:	93 0b       	sbc	r25, r19
    1692:	e9 81       	ldd	r30, Y+1	; 0x01
    1694:	fa 81       	ldd	r31, Y+2	; 0x02
    1696:	95 87       	std	Z+13, r25	; 0x0d
    1698:	84 87       	std	Z+12, r24	; 0x0c
				prvAddTaskToReadyQueue( pxTCB );
    169a:	e9 81       	ldd	r30, Y+1	; 0x01
    169c:	fa 81       	ldd	r31, Y+2	; 0x02
    169e:	96 89       	ldd	r25, Z+22	; 0x16
    16a0:	80 91 22 02 	lds	r24, 0x0222
    16a4:	89 17       	cp	r24, r25
    16a6:	28 f4       	brcc	.+10     	; 0x16b2 <vTaskPriorityDisinherit+0x7c>
    16a8:	e9 81       	ldd	r30, Y+1	; 0x01
    16aa:	fa 81       	ldd	r31, Y+2	; 0x02
    16ac:	86 89       	ldd	r24, Z+22	; 0x16
    16ae:	80 93 22 02 	sts	0x0222, r24
    16b2:	e9 81       	ldd	r30, Y+1	; 0x01
    16b4:	fa 81       	ldd	r31, Y+2	; 0x02
    16b6:	86 89       	ldd	r24, Z+22	; 0x16
    16b8:	28 2f       	mov	r18, r24
    16ba:	30 e0       	ldi	r19, 0x00	; 0
    16bc:	c9 01       	movw	r24, r18
    16be:	88 0f       	add	r24, r24
    16c0:	99 1f       	adc	r25, r25
    16c2:	88 0f       	add	r24, r24
    16c4:	99 1f       	adc	r25, r25
    16c6:	88 0f       	add	r24, r24
    16c8:	99 1f       	adc	r25, r25
    16ca:	82 0f       	add	r24, r18
    16cc:	93 1f       	adc	r25, r19
    16ce:	ac 01       	movw	r20, r24
    16d0:	47 5d       	subi	r20, 0xD7	; 215
    16d2:	5d 4f       	sbci	r21, 0xFD	; 253
    16d4:	89 81       	ldd	r24, Y+1	; 0x01
    16d6:	9a 81       	ldd	r25, Y+2	; 0x02
    16d8:	9c 01       	movw	r18, r24
    16da:	2e 5f       	subi	r18, 0xFE	; 254
    16dc:	3f 4f       	sbci	r19, 0xFF	; 255
    16de:	ca 01       	movw	r24, r20
    16e0:	b9 01       	movw	r22, r18
    16e2:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <vListInsertEnd>
			}
		}
	}
    16e6:	0f 90       	pop	r0
    16e8:	0f 90       	pop	r0
    16ea:	0f 90       	pop	r0
    16ec:	0f 90       	pop	r0
    16ee:	cf 91       	pop	r28
    16f0:	df 91       	pop	r29
    16f2:	08 95       	ret

000016f4 <xQueueGenericReset>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle pxQueue, portBASE_TYPE xNewQueue )
{
    16f4:	df 93       	push	r29
    16f6:	cf 93       	push	r28
    16f8:	00 d0       	rcall	.+0      	; 0x16fa <xQueueGenericReset+0x6>
    16fa:	cd b7       	in	r28, 0x3d	; 61
    16fc:	de b7       	in	r29, 0x3e	; 62
    16fe:	9a 83       	std	Y+2, r25	; 0x02
    1700:	89 83       	std	Y+1, r24	; 0x01
    1702:	6b 83       	std	Y+3, r22	; 0x03
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1704:	0f b6       	in	r0, 0x3f	; 63
    1706:	f8 94       	cli
    1708:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    170a:	e9 81       	ldd	r30, Y+1	; 0x01
    170c:	fa 81       	ldd	r31, Y+2	; 0x02
    170e:	40 81       	ld	r20, Z
    1710:	51 81       	ldd	r21, Z+1	; 0x01
    1712:	e9 81       	ldd	r30, Y+1	; 0x01
    1714:	fa 81       	ldd	r31, Y+2	; 0x02
    1716:	83 8d       	ldd	r24, Z+27	; 0x1b
    1718:	28 2f       	mov	r18, r24
    171a:	30 e0       	ldi	r19, 0x00	; 0
    171c:	e9 81       	ldd	r30, Y+1	; 0x01
    171e:	fa 81       	ldd	r31, Y+2	; 0x02
    1720:	84 8d       	ldd	r24, Z+28	; 0x1c
    1722:	88 2f       	mov	r24, r24
    1724:	90 e0       	ldi	r25, 0x00	; 0
    1726:	bc 01       	movw	r22, r24
    1728:	26 9f       	mul	r18, r22
    172a:	c0 01       	movw	r24, r0
    172c:	27 9f       	mul	r18, r23
    172e:	90 0d       	add	r25, r0
    1730:	36 9f       	mul	r19, r22
    1732:	90 0d       	add	r25, r0
    1734:	11 24       	eor	r1, r1
    1736:	84 0f       	add	r24, r20
    1738:	95 1f       	adc	r25, r21
    173a:	e9 81       	ldd	r30, Y+1	; 0x01
    173c:	fa 81       	ldd	r31, Y+2	; 0x02
    173e:	93 83       	std	Z+3, r25	; 0x03
    1740:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1742:	e9 81       	ldd	r30, Y+1	; 0x01
    1744:	fa 81       	ldd	r31, Y+2	; 0x02
    1746:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1748:	e9 81       	ldd	r30, Y+1	; 0x01
    174a:	fa 81       	ldd	r31, Y+2	; 0x02
    174c:	80 81       	ld	r24, Z
    174e:	91 81       	ldd	r25, Z+1	; 0x01
    1750:	e9 81       	ldd	r30, Y+1	; 0x01
    1752:	fa 81       	ldd	r31, Y+2	; 0x02
    1754:	95 83       	std	Z+5, r25	; 0x05
    1756:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
    1758:	e9 81       	ldd	r30, Y+1	; 0x01
    175a:	fa 81       	ldd	r31, Y+2	; 0x02
    175c:	40 81       	ld	r20, Z
    175e:	51 81       	ldd	r21, Z+1	; 0x01
    1760:	e9 81       	ldd	r30, Y+1	; 0x01
    1762:	fa 81       	ldd	r31, Y+2	; 0x02
    1764:	83 8d       	ldd	r24, Z+27	; 0x1b
    1766:	88 2f       	mov	r24, r24
    1768:	90 e0       	ldi	r25, 0x00	; 0
    176a:	9c 01       	movw	r18, r24
    176c:	21 50       	subi	r18, 0x01	; 1
    176e:	30 40       	sbci	r19, 0x00	; 0
    1770:	e9 81       	ldd	r30, Y+1	; 0x01
    1772:	fa 81       	ldd	r31, Y+2	; 0x02
    1774:	84 8d       	ldd	r24, Z+28	; 0x1c
    1776:	88 2f       	mov	r24, r24
    1778:	90 e0       	ldi	r25, 0x00	; 0
    177a:	bc 01       	movw	r22, r24
    177c:	26 9f       	mul	r18, r22
    177e:	c0 01       	movw	r24, r0
    1780:	27 9f       	mul	r18, r23
    1782:	90 0d       	add	r25, r0
    1784:	36 9f       	mul	r19, r22
    1786:	90 0d       	add	r25, r0
    1788:	11 24       	eor	r1, r1
    178a:	84 0f       	add	r24, r20
    178c:	95 1f       	adc	r25, r21
    178e:	e9 81       	ldd	r30, Y+1	; 0x01
    1790:	fa 81       	ldd	r31, Y+2	; 0x02
    1792:	97 83       	std	Z+7, r25	; 0x07
    1794:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    1796:	e9 81       	ldd	r30, Y+1	; 0x01
    1798:	fa 81       	ldd	r31, Y+2	; 0x02
    179a:	8f ef       	ldi	r24, 0xFF	; 255
    179c:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    179e:	e9 81       	ldd	r30, Y+1	; 0x01
    17a0:	fa 81       	ldd	r31, Y+2	; 0x02
    17a2:	8f ef       	ldi	r24, 0xFF	; 255
    17a4:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    17a6:	8b 81       	ldd	r24, Y+3	; 0x03
    17a8:	88 23       	and	r24, r24
    17aa:	79 f4       	brne	.+30     	; 0x17ca <xQueueGenericReset+0xd6>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to	write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    17ac:	e9 81       	ldd	r30, Y+1	; 0x01
    17ae:	fa 81       	ldd	r31, Y+2	; 0x02
    17b0:	80 85       	ldd	r24, Z+8	; 0x08
    17b2:	88 23       	and	r24, r24
    17b4:	a1 f0       	breq	.+40     	; 0x17de <xQueueGenericReset+0xea>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    17b6:	89 81       	ldd	r24, Y+1	; 0x01
    17b8:	9a 81       	ldd	r25, Y+2	; 0x02
    17ba:	08 96       	adiw	r24, 0x08	; 8
    17bc:	0e 94 ef 07 	call	0xfde	; 0xfde <xTaskRemoveFromEventList>
    17c0:	81 30       	cpi	r24, 0x01	; 1
    17c2:	69 f4       	brne	.+26     	; 0x17de <xQueueGenericReset+0xea>
				{
					portYIELD_WITHIN_API();
    17c4:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <vPortYield>
    17c8:	0a c0       	rjmp	.+20     	; 0x17de <xQueueGenericReset+0xea>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    17ca:	89 81       	ldd	r24, Y+1	; 0x01
    17cc:	9a 81       	ldd	r25, Y+2	; 0x02
    17ce:	08 96       	adiw	r24, 0x08	; 8
    17d0:	0e 94 ac 10 	call	0x2158	; 0x2158 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    17d4:	89 81       	ldd	r24, Y+1	; 0x01
    17d6:	9a 81       	ldd	r25, Y+2	; 0x02
    17d8:	41 96       	adiw	r24, 0x11	; 17
    17da:	0e 94 ac 10 	call	0x2158	; 0x2158 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    17de:	0f 90       	pop	r0
    17e0:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    17e2:	81 e0       	ldi	r24, 0x01	; 1
}
    17e4:	0f 90       	pop	r0
    17e6:	0f 90       	pop	r0
    17e8:	0f 90       	pop	r0
    17ea:	cf 91       	pop	r28
    17ec:	df 91       	pop	r29
    17ee:	08 95       	ret

000017f0 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
    17f0:	df 93       	push	r29
    17f2:	cf 93       	push	r28
    17f4:	cd b7       	in	r28, 0x3d	; 61
    17f6:	de b7       	in	r29, 0x3e	; 62
    17f8:	29 97       	sbiw	r28, 0x09	; 9
    17fa:	0f b6       	in	r0, 0x3f	; 63
    17fc:	f8 94       	cli
    17fe:	de bf       	out	0x3e, r29	; 62
    1800:	0f be       	out	0x3f, r0	; 63
    1802:	cd bf       	out	0x3d, r28	; 61
    1804:	8f 83       	std	Y+7, r24	; 0x07
    1806:	68 87       	std	Y+8, r22	; 0x08
    1808:	49 87       	std	Y+9, r20	; 0x09
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    180a:	1a 82       	std	Y+2, r1	; 0x02
    180c:	19 82       	std	Y+1, r1	; 0x01
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    180e:	8f 81       	ldd	r24, Y+7	; 0x07
    1810:	88 23       	and	r24, r24
    1812:	09 f4       	brne	.+2      	; 0x1816 <xQueueGenericCreate+0x26>
    1814:	3f c0       	rjmp	.+126    	; 0x1894 <xQueueGenericCreate+0xa4>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    1816:	8f e1       	ldi	r24, 0x1F	; 31
    1818:	90 e0       	ldi	r25, 0x00	; 0
    181a:	0e 94 c4 14 	call	0x2988	; 0x2988 <pvPortMalloc>
    181e:	9e 83       	std	Y+6, r25	; 0x06
    1820:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    1822:	8d 81       	ldd	r24, Y+5	; 0x05
    1824:	9e 81       	ldd	r25, Y+6	; 0x06
    1826:	00 97       	sbiw	r24, 0x00	; 0
    1828:	a9 f1       	breq	.+106    	; 0x1894 <xQueueGenericCreate+0xa4>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    182a:	8f 81       	ldd	r24, Y+7	; 0x07
    182c:	28 2f       	mov	r18, r24
    182e:	30 e0       	ldi	r19, 0x00	; 0
    1830:	88 85       	ldd	r24, Y+8	; 0x08
    1832:	88 2f       	mov	r24, r24
    1834:	90 e0       	ldi	r25, 0x00	; 0
    1836:	ac 01       	movw	r20, r24
    1838:	24 9f       	mul	r18, r20
    183a:	c0 01       	movw	r24, r0
    183c:	25 9f       	mul	r18, r21
    183e:	90 0d       	add	r25, r0
    1840:	34 9f       	mul	r19, r20
    1842:	90 0d       	add	r25, r0
    1844:	11 24       	eor	r1, r1
    1846:	01 96       	adiw	r24, 0x01	; 1
    1848:	9c 83       	std	Y+4, r25	; 0x04
    184a:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    184c:	8b 81       	ldd	r24, Y+3	; 0x03
    184e:	9c 81       	ldd	r25, Y+4	; 0x04
    1850:	0e 94 c4 14 	call	0x2988	; 0x2988 <pvPortMalloc>
    1854:	ed 81       	ldd	r30, Y+5	; 0x05
    1856:	fe 81       	ldd	r31, Y+6	; 0x06
    1858:	91 83       	std	Z+1, r25	; 0x01
    185a:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    185c:	ed 81       	ldd	r30, Y+5	; 0x05
    185e:	fe 81       	ldd	r31, Y+6	; 0x06
    1860:	80 81       	ld	r24, Z
    1862:	91 81       	ldd	r25, Z+1	; 0x01
    1864:	00 97       	sbiw	r24, 0x00	; 0
    1866:	91 f0       	breq	.+36     	; 0x188c <xQueueGenericCreate+0x9c>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    1868:	ed 81       	ldd	r30, Y+5	; 0x05
    186a:	fe 81       	ldd	r31, Y+6	; 0x06
    186c:	8f 81       	ldd	r24, Y+7	; 0x07
    186e:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1870:	ed 81       	ldd	r30, Y+5	; 0x05
    1872:	fe 81       	ldd	r31, Y+6	; 0x06
    1874:	88 85       	ldd	r24, Y+8	; 0x08
    1876:	84 8f       	std	Z+28, r24	; 0x1c
				xQueueGenericReset( pxNewQueue, pdTRUE );
    1878:	8d 81       	ldd	r24, Y+5	; 0x05
    187a:	9e 81       	ldd	r25, Y+6	; 0x06
    187c:	61 e0       	ldi	r22, 0x01	; 1
    187e:	0e 94 7a 0b 	call	0x16f4	; 0x16f4 <xQueueGenericReset>
					pxNewQueue->ucQueueType = ucQueueType;
				}
				#endif /* configUSE_TRACE_FACILITY */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    1882:	8d 81       	ldd	r24, Y+5	; 0x05
    1884:	9e 81       	ldd	r25, Y+6	; 0x06
    1886:	9a 83       	std	Y+2, r25	; 0x02
    1888:	89 83       	std	Y+1, r24	; 0x01
    188a:	04 c0       	rjmp	.+8      	; 0x1894 <xQueueGenericCreate+0xa4>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    188c:	8d 81       	ldd	r24, Y+5	; 0x05
    188e:	9e 81       	ldd	r25, Y+6	; 0x06
    1890:	0e 94 0a 15 	call	0x2a14	; 0x2a14 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    1894:	89 81       	ldd	r24, Y+1	; 0x01
    1896:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1898:	29 96       	adiw	r28, 0x09	; 9
    189a:	0f b6       	in	r0, 0x3f	; 63
    189c:	f8 94       	cli
    189e:	de bf       	out	0x3e, r29	; 62
    18a0:	0f be       	out	0x3f, r0	; 63
    18a2:	cd bf       	out	0x3d, r28	; 61
    18a4:	cf 91       	pop	r28
    18a6:	df 91       	pop	r29
    18a8:	08 95       	ret

000018aa <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
	{
    18aa:	df 93       	push	r29
    18ac:	cf 93       	push	r28
    18ae:	00 d0       	rcall	.+0      	; 0x18b0 <xQueueCreateMutex+0x6>
    18b0:	cd b7       	in	r28, 0x3d	; 61
    18b2:	de b7       	in	r29, 0x3e	; 62
    18b4:	8b 83       	std	Y+3, r24	; 0x03
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    18b6:	8f e1       	ldi	r24, 0x1F	; 31
    18b8:	90 e0       	ldi	r25, 0x00	; 0
    18ba:	0e 94 c4 14 	call	0x2988	; 0x2988 <pvPortMalloc>
    18be:	9a 83       	std	Y+2, r25	; 0x02
    18c0:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    18c2:	89 81       	ldd	r24, Y+1	; 0x01
    18c4:	9a 81       	ldd	r25, Y+2	; 0x02
    18c6:	00 97       	sbiw	r24, 0x00	; 0
    18c8:	a9 f1       	breq	.+106    	; 0x1934 <xQueueCreateMutex+0x8a>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    18ca:	e9 81       	ldd	r30, Y+1	; 0x01
    18cc:	fa 81       	ldd	r31, Y+2	; 0x02
    18ce:	13 82       	std	Z+3, r1	; 0x03
    18d0:	12 82       	std	Z+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    18d2:	e9 81       	ldd	r30, Y+1	; 0x01
    18d4:	fa 81       	ldd	r31, Y+2	; 0x02
    18d6:	11 82       	std	Z+1, r1	; 0x01
    18d8:	10 82       	st	Z, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    18da:	e9 81       	ldd	r30, Y+1	; 0x01
    18dc:	fa 81       	ldd	r31, Y+2	; 0x02
    18de:	15 82       	std	Z+5, r1	; 0x05
    18e0:	14 82       	std	Z+4, r1	; 0x04
			pxNewQueue->pcReadFrom = NULL;
    18e2:	e9 81       	ldd	r30, Y+1	; 0x01
    18e4:	fa 81       	ldd	r31, Y+2	; 0x02
    18e6:	17 82       	std	Z+7, r1	; 0x07
    18e8:	16 82       	std	Z+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    18ea:	e9 81       	ldd	r30, Y+1	; 0x01
    18ec:	fa 81       	ldd	r31, Y+2	; 0x02
    18ee:	12 8e       	std	Z+26, r1	; 0x1a
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
    18f0:	e9 81       	ldd	r30, Y+1	; 0x01
    18f2:	fa 81       	ldd	r31, Y+2	; 0x02
    18f4:	81 e0       	ldi	r24, 0x01	; 1
    18f6:	83 8f       	std	Z+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
    18f8:	e9 81       	ldd	r30, Y+1	; 0x01
    18fa:	fa 81       	ldd	r31, Y+2	; 0x02
    18fc:	14 8e       	std	Z+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    18fe:	e9 81       	ldd	r30, Y+1	; 0x01
    1900:	fa 81       	ldd	r31, Y+2	; 0x02
    1902:	8f ef       	ldi	r24, 0xFF	; 255
    1904:	85 8f       	std	Z+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    1906:	e9 81       	ldd	r30, Y+1	; 0x01
    1908:	fa 81       	ldd	r31, Y+2	; 0x02
    190a:	8f ef       	ldi	r24, 0xFF	; 255
    190c:	86 8f       	std	Z+30, r24	; 0x1e
				pxNewQueue->ucQueueType = ucQueueType;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    190e:	89 81       	ldd	r24, Y+1	; 0x01
    1910:	9a 81       	ldd	r25, Y+2	; 0x02
    1912:	08 96       	adiw	r24, 0x08	; 8
    1914:	0e 94 ac 10 	call	0x2158	; 0x2158 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1918:	89 81       	ldd	r24, Y+1	; 0x01
    191a:	9a 81       	ldd	r25, Y+2	; 0x02
    191c:	41 96       	adiw	r24, 0x11	; 17
    191e:	0e 94 ac 10 	call	0x2158	; 0x2158 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
    1922:	89 81       	ldd	r24, Y+1	; 0x01
    1924:	9a 81       	ldd	r25, Y+2	; 0x02
    1926:	60 e0       	ldi	r22, 0x00	; 0
    1928:	70 e0       	ldi	r23, 0x00	; 0
    192a:	40 e0       	ldi	r20, 0x00	; 0
    192c:	50 e0       	ldi	r21, 0x00	; 0
    192e:	20 e0       	ldi	r18, 0x00	; 0
    1930:	0e 94 a2 0c 	call	0x1944	; 0x1944 <xQueueGenericSend>
		{
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
    1934:	89 81       	ldd	r24, Y+1	; 0x01
    1936:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    1938:	0f 90       	pop	r0
    193a:	0f 90       	pop	r0
    193c:	0f 90       	pop	r0
    193e:	cf 91       	pop	r28
    1940:	df 91       	pop	r29
    1942:	08 95       	ret

00001944 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    1944:	df 93       	push	r29
    1946:	cf 93       	push	r28
    1948:	cd b7       	in	r28, 0x3d	; 61
    194a:	de b7       	in	r29, 0x3e	; 62
    194c:	2c 97       	sbiw	r28, 0x0c	; 12
    194e:	0f b6       	in	r0, 0x3f	; 63
    1950:	f8 94       	cli
    1952:	de bf       	out	0x3e, r29	; 62
    1954:	0f be       	out	0x3f, r0	; 63
    1956:	cd bf       	out	0x3d, r28	; 61
    1958:	9e 83       	std	Y+6, r25	; 0x06
    195a:	8d 83       	std	Y+5, r24	; 0x05
    195c:	78 87       	std	Y+8, r23	; 0x08
    195e:	6f 83       	std	Y+7, r22	; 0x07
    1960:	5a 87       	std	Y+10, r21	; 0x0a
    1962:	49 87       	std	Y+9, r20	; 0x09
    1964:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1966:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1968:	0f b6       	in	r0, 0x3f	; 63
    196a:	f8 94       	cli
    196c:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    196e:	ed 81       	ldd	r30, Y+5	; 0x05
    1970:	fe 81       	ldd	r31, Y+6	; 0x06
    1972:	92 8d       	ldd	r25, Z+26	; 0x1a
    1974:	ed 81       	ldd	r30, Y+5	; 0x05
    1976:	fe 81       	ldd	r31, Y+6	; 0x06
    1978:	83 8d       	ldd	r24, Z+27	; 0x1b
    197a:	98 17       	cp	r25, r24
    197c:	d8 f4       	brcc	.+54     	; 0x19b4 <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    197e:	8d 81       	ldd	r24, Y+5	; 0x05
    1980:	9e 81       	ldd	r25, Y+6	; 0x06
    1982:	2f 81       	ldd	r18, Y+7	; 0x07
    1984:	38 85       	ldd	r19, Y+8	; 0x08
    1986:	b9 01       	movw	r22, r18
    1988:	4b 85       	ldd	r20, Y+11	; 0x0b
    198a:	0e 94 01 0f 	call	0x1e02	; 0x1e02 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    198e:	ed 81       	ldd	r30, Y+5	; 0x05
    1990:	fe 81       	ldd	r31, Y+6	; 0x06
    1992:	81 89       	ldd	r24, Z+17	; 0x11
    1994:	88 23       	and	r24, r24
    1996:	49 f0       	breq	.+18     	; 0x19aa <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1998:	8d 81       	ldd	r24, Y+5	; 0x05
    199a:	9e 81       	ldd	r25, Y+6	; 0x06
    199c:	41 96       	adiw	r24, 0x11	; 17
    199e:	0e 94 ef 07 	call	0xfde	; 0xfde <xTaskRemoveFromEventList>
    19a2:	81 30       	cpi	r24, 0x01	; 1
    19a4:	11 f4       	brne	.+4      	; 0x19aa <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    19a6:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    19aa:	0f 90       	pop	r0
    19ac:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    19ae:	81 e0       	ldi	r24, 0x01	; 1
    19b0:	8c 87       	std	Y+12, r24	; 0x0c
    19b2:	5c c0       	rjmp	.+184    	; 0x1a6c <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    19b4:	89 85       	ldd	r24, Y+9	; 0x09
    19b6:	9a 85       	ldd	r25, Y+10	; 0x0a
    19b8:	00 97       	sbiw	r24, 0x00	; 0
    19ba:	21 f4       	brne	.+8      	; 0x19c4 <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    19bc:	0f 90       	pop	r0
    19be:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    19c0:	1c 86       	std	Y+12, r1	; 0x0c
    19c2:	54 c0       	rjmp	.+168    	; 0x1a6c <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    19c4:	89 81       	ldd	r24, Y+1	; 0x01
    19c6:	88 23       	and	r24, r24
    19c8:	31 f4       	brne	.+12     	; 0x19d6 <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    19ca:	ce 01       	movw	r24, r28
    19cc:	02 96       	adiw	r24, 0x02	; 2
    19ce:	0e 94 57 08 	call	0x10ae	; 0x10ae <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    19d2:	81 e0       	ldi	r24, 0x01	; 1
    19d4:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    19d6:	0f 90       	pop	r0
    19d8:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    19da:	0e 94 85 05 	call	0xb0a	; 0xb0a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    19de:	0f b6       	in	r0, 0x3f	; 63
    19e0:	f8 94       	cli
    19e2:	0f 92       	push	r0
    19e4:	ed 81       	ldd	r30, Y+5	; 0x05
    19e6:	fe 81       	ldd	r31, Y+6	; 0x06
    19e8:	85 8d       	ldd	r24, Z+29	; 0x1d
    19ea:	8f 3f       	cpi	r24, 0xFF	; 255
    19ec:	19 f4       	brne	.+6      	; 0x19f4 <xQueueGenericSend+0xb0>
    19ee:	ed 81       	ldd	r30, Y+5	; 0x05
    19f0:	fe 81       	ldd	r31, Y+6	; 0x06
    19f2:	15 8e       	std	Z+29, r1	; 0x1d
    19f4:	ed 81       	ldd	r30, Y+5	; 0x05
    19f6:	fe 81       	ldd	r31, Y+6	; 0x06
    19f8:	86 8d       	ldd	r24, Z+30	; 0x1e
    19fa:	8f 3f       	cpi	r24, 0xFF	; 255
    19fc:	19 f4       	brne	.+6      	; 0x1a04 <xQueueGenericSend+0xc0>
    19fe:	ed 81       	ldd	r30, Y+5	; 0x05
    1a00:	fe 81       	ldd	r31, Y+6	; 0x06
    1a02:	16 8e       	std	Z+30, r1	; 0x1e
    1a04:	0f 90       	pop	r0
    1a06:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1a08:	ce 01       	movw	r24, r28
    1a0a:	02 96       	adiw	r24, 0x02	; 2
    1a0c:	9e 01       	movw	r18, r28
    1a0e:	27 5f       	subi	r18, 0xF7	; 247
    1a10:	3f 4f       	sbci	r19, 0xFF	; 255
    1a12:	b9 01       	movw	r22, r18
    1a14:	0e 94 71 08 	call	0x10e2	; 0x10e2 <xTaskCheckForTimeOut>
    1a18:	88 23       	and	r24, r24
    1a1a:	09 f5       	brne	.+66     	; 0x1a5e <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1a1c:	8d 81       	ldd	r24, Y+5	; 0x05
    1a1e:	9e 81       	ldd	r25, Y+6	; 0x06
    1a20:	0e 94 75 10 	call	0x20ea	; 0x20ea <prvIsQueueFull>
    1a24:	88 23       	and	r24, r24
    1a26:	a1 f0       	breq	.+40     	; 0x1a50 <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1a28:	8d 81       	ldd	r24, Y+5	; 0x05
    1a2a:	9e 81       	ldd	r25, Y+6	; 0x06
    1a2c:	08 96       	adiw	r24, 0x08	; 8
    1a2e:	29 85       	ldd	r18, Y+9	; 0x09
    1a30:	3a 85       	ldd	r19, Y+10	; 0x0a
    1a32:	b9 01       	movw	r22, r18
    1a34:	0e 94 a7 07 	call	0xf4e	; 0xf4e <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1a38:	8d 81       	ldd	r24, Y+5	; 0x05
    1a3a:	9e 81       	ldd	r25, Y+6	; 0x06
    1a3c:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1a40:	0e 94 91 05 	call	0xb22	; 0xb22 <xTaskResumeAll>
    1a44:	88 23       	and	r24, r24
    1a46:	09 f0       	breq	.+2      	; 0x1a4a <xQueueGenericSend+0x106>
    1a48:	8f cf       	rjmp	.-226    	; 0x1968 <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    1a4a:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <vPortYield>
    1a4e:	8c cf       	rjmp	.-232    	; 0x1968 <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1a50:	8d 81       	ldd	r24, Y+5	; 0x05
    1a52:	9e 81       	ldd	r25, Y+6	; 0x06
    1a54:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1a58:	0e 94 91 05 	call	0xb22	; 0xb22 <xTaskResumeAll>
    1a5c:	85 cf       	rjmp	.-246    	; 0x1968 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1a5e:	8d 81       	ldd	r24, Y+5	; 0x05
    1a60:	9e 81       	ldd	r25, Y+6	; 0x06
    1a62:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1a66:	0e 94 91 05 	call	0xb22	; 0xb22 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1a6a:	1c 86       	std	Y+12, r1	; 0x0c
    1a6c:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    1a6e:	2c 96       	adiw	r28, 0x0c	; 12
    1a70:	0f b6       	in	r0, 0x3f	; 63
    1a72:	f8 94       	cli
    1a74:	de bf       	out	0x3e, r29	; 62
    1a76:	0f be       	out	0x3f, r0	; 63
    1a78:	cd bf       	out	0x3d, r28	; 61
    1a7a:	cf 91       	pop	r28
    1a7c:	df 91       	pop	r29
    1a7e:	08 95       	ret

00001a80 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1a80:	df 93       	push	r29
    1a82:	cf 93       	push	r28
    1a84:	cd b7       	in	r28, 0x3d	; 61
    1a86:	de b7       	in	r29, 0x3e	; 62
    1a88:	29 97       	sbiw	r28, 0x09	; 9
    1a8a:	0f b6       	in	r0, 0x3f	; 63
    1a8c:	f8 94       	cli
    1a8e:	de bf       	out	0x3e, r29	; 62
    1a90:	0f be       	out	0x3f, r0	; 63
    1a92:	cd bf       	out	0x3d, r28	; 61
    1a94:	9c 83       	std	Y+4, r25	; 0x04
    1a96:	8b 83       	std	Y+3, r24	; 0x03
    1a98:	7e 83       	std	Y+6, r23	; 0x06
    1a9a:	6d 83       	std	Y+5, r22	; 0x05
    1a9c:	58 87       	std	Y+8, r21	; 0x08
    1a9e:	4f 83       	std	Y+7, r20	; 0x07
    1aa0:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1aa2:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1aa4:	eb 81       	ldd	r30, Y+3	; 0x03
    1aa6:	fc 81       	ldd	r31, Y+4	; 0x04
    1aa8:	92 8d       	ldd	r25, Z+26	; 0x1a
    1aaa:	eb 81       	ldd	r30, Y+3	; 0x03
    1aac:	fc 81       	ldd	r31, Y+4	; 0x04
    1aae:	83 8d       	ldd	r24, Z+27	; 0x1b
    1ab0:	98 17       	cp	r25, r24
    1ab2:	60 f5       	brcc	.+88     	; 0x1b0c <xQueueGenericSendFromISR+0x8c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1ab4:	8b 81       	ldd	r24, Y+3	; 0x03
    1ab6:	9c 81       	ldd	r25, Y+4	; 0x04
    1ab8:	2d 81       	ldd	r18, Y+5	; 0x05
    1aba:	3e 81       	ldd	r19, Y+6	; 0x06
    1abc:	b9 01       	movw	r22, r18
    1abe:	49 85       	ldd	r20, Y+9	; 0x09
    1ac0:	0e 94 01 0f 	call	0x1e02	; 0x1e02 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1ac4:	eb 81       	ldd	r30, Y+3	; 0x03
    1ac6:	fc 81       	ldd	r31, Y+4	; 0x04
    1ac8:	86 8d       	ldd	r24, Z+30	; 0x1e
    1aca:	8f 3f       	cpi	r24, 0xFF	; 255
    1acc:	a9 f4       	brne	.+42     	; 0x1af8 <xQueueGenericSendFromISR+0x78>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1ace:	eb 81       	ldd	r30, Y+3	; 0x03
    1ad0:	fc 81       	ldd	r31, Y+4	; 0x04
    1ad2:	81 89       	ldd	r24, Z+17	; 0x11
    1ad4:	88 23       	and	r24, r24
    1ad6:	b9 f0       	breq	.+46     	; 0x1b06 <xQueueGenericSendFromISR+0x86>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1ad8:	8b 81       	ldd	r24, Y+3	; 0x03
    1ada:	9c 81       	ldd	r25, Y+4	; 0x04
    1adc:	41 96       	adiw	r24, 0x11	; 17
    1ade:	0e 94 ef 07 	call	0xfde	; 0xfde <xTaskRemoveFromEventList>
    1ae2:	88 23       	and	r24, r24
    1ae4:	81 f0       	breq	.+32     	; 0x1b06 <xQueueGenericSendFromISR+0x86>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						if( pxHigherPriorityTaskWoken != NULL )
    1ae6:	8f 81       	ldd	r24, Y+7	; 0x07
    1ae8:	98 85       	ldd	r25, Y+8	; 0x08
    1aea:	00 97       	sbiw	r24, 0x00	; 0
    1aec:	61 f0       	breq	.+24     	; 0x1b06 <xQueueGenericSendFromISR+0x86>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1aee:	ef 81       	ldd	r30, Y+7	; 0x07
    1af0:	f8 85       	ldd	r31, Y+8	; 0x08
    1af2:	81 e0       	ldi	r24, 0x01	; 1
    1af4:	80 83       	st	Z, r24
    1af6:	07 c0       	rjmp	.+14     	; 0x1b06 <xQueueGenericSendFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1af8:	eb 81       	ldd	r30, Y+3	; 0x03
    1afa:	fc 81       	ldd	r31, Y+4	; 0x04
    1afc:	86 8d       	ldd	r24, Z+30	; 0x1e
    1afe:	8f 5f       	subi	r24, 0xFF	; 255
    1b00:	eb 81       	ldd	r30, Y+3	; 0x03
    1b02:	fc 81       	ldd	r31, Y+4	; 0x04
    1b04:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1b06:	81 e0       	ldi	r24, 0x01	; 1
    1b08:	8a 83       	std	Y+2, r24	; 0x02
    1b0a:	01 c0       	rjmp	.+2      	; 0x1b0e <xQueueGenericSendFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1b0c:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1b0e:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1b10:	29 96       	adiw	r28, 0x09	; 9
    1b12:	0f b6       	in	r0, 0x3f	; 63
    1b14:	f8 94       	cli
    1b16:	de bf       	out	0x3e, r29	; 62
    1b18:	0f be       	out	0x3f, r0	; 63
    1b1a:	cd bf       	out	0x3d, r28	; 61
    1b1c:	cf 91       	pop	r28
    1b1e:	df 91       	pop	r29
    1b20:	08 95       	ret

00001b22 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1b22:	df 93       	push	r29
    1b24:	cf 93       	push	r28
    1b26:	cd b7       	in	r28, 0x3d	; 61
    1b28:	de b7       	in	r29, 0x3e	; 62
    1b2a:	2e 97       	sbiw	r28, 0x0e	; 14
    1b2c:	0f b6       	in	r0, 0x3f	; 63
    1b2e:	f8 94       	cli
    1b30:	de bf       	out	0x3e, r29	; 62
    1b32:	0f be       	out	0x3f, r0	; 63
    1b34:	cd bf       	out	0x3d, r28	; 61
    1b36:	98 87       	std	Y+8, r25	; 0x08
    1b38:	8f 83       	std	Y+7, r24	; 0x07
    1b3a:	7a 87       	std	Y+10, r23	; 0x0a
    1b3c:	69 87       	std	Y+9, r22	; 0x09
    1b3e:	5c 87       	std	Y+12, r21	; 0x0c
    1b40:	4b 87       	std	Y+11, r20	; 0x0b
    1b42:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1b44:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1b46:	0f b6       	in	r0, 0x3f	; 63
    1b48:	f8 94       	cli
    1b4a:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1b4c:	ef 81       	ldd	r30, Y+7	; 0x07
    1b4e:	f8 85       	ldd	r31, Y+8	; 0x08
    1b50:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b52:	88 23       	and	r24, r24
    1b54:	09 f4       	brne	.+2      	; 0x1b58 <xQueueGenericReceive+0x36>
    1b56:	4b c0       	rjmp	.+150    	; 0x1bee <xQueueGenericReceive+0xcc>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1b58:	ef 81       	ldd	r30, Y+7	; 0x07
    1b5a:	f8 85       	ldd	r31, Y+8	; 0x08
    1b5c:	86 81       	ldd	r24, Z+6	; 0x06
    1b5e:	97 81       	ldd	r25, Z+7	; 0x07
    1b60:	9a 83       	std	Y+2, r25	; 0x02
    1b62:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1b64:	8f 81       	ldd	r24, Y+7	; 0x07
    1b66:	98 85       	ldd	r25, Y+8	; 0x08
    1b68:	29 85       	ldd	r18, Y+9	; 0x09
    1b6a:	3a 85       	ldd	r19, Y+10	; 0x0a
    1b6c:	b9 01       	movw	r22, r18
    1b6e:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1b72:	8d 85       	ldd	r24, Y+13	; 0x0d
    1b74:	88 23       	and	r24, r24
    1b76:	11 f5       	brne	.+68     	; 0x1bbc <xQueueGenericReceive+0x9a>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1b78:	ef 81       	ldd	r30, Y+7	; 0x07
    1b7a:	f8 85       	ldd	r31, Y+8	; 0x08
    1b7c:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b7e:	81 50       	subi	r24, 0x01	; 1
    1b80:	ef 81       	ldd	r30, Y+7	; 0x07
    1b82:	f8 85       	ldd	r31, Y+8	; 0x08
    1b84:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1b86:	ef 81       	ldd	r30, Y+7	; 0x07
    1b88:	f8 85       	ldd	r31, Y+8	; 0x08
    1b8a:	80 81       	ld	r24, Z
    1b8c:	91 81       	ldd	r25, Z+1	; 0x01
    1b8e:	00 97       	sbiw	r24, 0x00	; 0
    1b90:	31 f4       	brne	.+12     	; 0x1b9e <xQueueGenericReceive+0x7c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    1b92:	0e 94 83 0a 	call	0x1506	; 0x1506 <xTaskGetCurrentTaskHandle>
    1b96:	ef 81       	ldd	r30, Y+7	; 0x07
    1b98:	f8 85       	ldd	r31, Y+8	; 0x08
    1b9a:	93 83       	std	Z+3, r25	; 0x03
    1b9c:	82 83       	std	Z+2, r24	; 0x02
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1b9e:	ef 81       	ldd	r30, Y+7	; 0x07
    1ba0:	f8 85       	ldd	r31, Y+8	; 0x08
    1ba2:	80 85       	ldd	r24, Z+8	; 0x08
    1ba4:	88 23       	and	r24, r24
    1ba6:	f1 f0       	breq	.+60     	; 0x1be4 <xQueueGenericReceive+0xc2>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1ba8:	8f 81       	ldd	r24, Y+7	; 0x07
    1baa:	98 85       	ldd	r25, Y+8	; 0x08
    1bac:	08 96       	adiw	r24, 0x08	; 8
    1bae:	0e 94 ef 07 	call	0xfde	; 0xfde <xTaskRemoveFromEventList>
    1bb2:	81 30       	cpi	r24, 0x01	; 1
    1bb4:	b9 f4       	brne	.+46     	; 0x1be4 <xQueueGenericReceive+0xc2>
						{
							portYIELD_WITHIN_API();
    1bb6:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <vPortYield>
    1bba:	14 c0       	rjmp	.+40     	; 0x1be4 <xQueueGenericReceive+0xc2>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1bbc:	ef 81       	ldd	r30, Y+7	; 0x07
    1bbe:	f8 85       	ldd	r31, Y+8	; 0x08
    1bc0:	89 81       	ldd	r24, Y+1	; 0x01
    1bc2:	9a 81       	ldd	r25, Y+2	; 0x02
    1bc4:	97 83       	std	Z+7, r25	; 0x07
    1bc6:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1bc8:	ef 81       	ldd	r30, Y+7	; 0x07
    1bca:	f8 85       	ldd	r31, Y+8	; 0x08
    1bcc:	81 89       	ldd	r24, Z+17	; 0x11
    1bce:	88 23       	and	r24, r24
    1bd0:	49 f0       	breq	.+18     	; 0x1be4 <xQueueGenericReceive+0xc2>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1bd2:	8f 81       	ldd	r24, Y+7	; 0x07
    1bd4:	98 85       	ldd	r25, Y+8	; 0x08
    1bd6:	41 96       	adiw	r24, 0x11	; 17
    1bd8:	0e 94 ef 07 	call	0xfde	; 0xfde <xTaskRemoveFromEventList>
    1bdc:	88 23       	and	r24, r24
    1bde:	11 f0       	breq	.+4      	; 0x1be4 <xQueueGenericReceive+0xc2>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1be0:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <vPortYield>
						}
					}
				}

				taskEXIT_CRITICAL();
    1be4:	0f 90       	pop	r0
    1be6:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1be8:	81 e0       	ldi	r24, 0x01	; 1
    1bea:	8e 87       	std	Y+14, r24	; 0x0e
    1bec:	6d c0       	rjmp	.+218    	; 0x1cc8 <xQueueGenericReceive+0x1a6>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1bee:	8b 85       	ldd	r24, Y+11	; 0x0b
    1bf0:	9c 85       	ldd	r25, Y+12	; 0x0c
    1bf2:	00 97       	sbiw	r24, 0x00	; 0
    1bf4:	21 f4       	brne	.+8      	; 0x1bfe <xQueueGenericReceive+0xdc>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1bf6:	0f 90       	pop	r0
    1bf8:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1bfa:	1e 86       	std	Y+14, r1	; 0x0e
    1bfc:	65 c0       	rjmp	.+202    	; 0x1cc8 <xQueueGenericReceive+0x1a6>
				}
				else if( xEntryTimeSet == pdFALSE )
    1bfe:	8b 81       	ldd	r24, Y+3	; 0x03
    1c00:	88 23       	and	r24, r24
    1c02:	31 f4       	brne	.+12     	; 0x1c10 <xQueueGenericReceive+0xee>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1c04:	ce 01       	movw	r24, r28
    1c06:	04 96       	adiw	r24, 0x04	; 4
    1c08:	0e 94 57 08 	call	0x10ae	; 0x10ae <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1c0c:	81 e0       	ldi	r24, 0x01	; 1
    1c0e:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    1c10:	0f 90       	pop	r0
    1c12:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1c14:	0e 94 85 05 	call	0xb0a	; 0xb0a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1c18:	0f b6       	in	r0, 0x3f	; 63
    1c1a:	f8 94       	cli
    1c1c:	0f 92       	push	r0
    1c1e:	ef 81       	ldd	r30, Y+7	; 0x07
    1c20:	f8 85       	ldd	r31, Y+8	; 0x08
    1c22:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c24:	8f 3f       	cpi	r24, 0xFF	; 255
    1c26:	19 f4       	brne	.+6      	; 0x1c2e <xQueueGenericReceive+0x10c>
    1c28:	ef 81       	ldd	r30, Y+7	; 0x07
    1c2a:	f8 85       	ldd	r31, Y+8	; 0x08
    1c2c:	15 8e       	std	Z+29, r1	; 0x1d
    1c2e:	ef 81       	ldd	r30, Y+7	; 0x07
    1c30:	f8 85       	ldd	r31, Y+8	; 0x08
    1c32:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c34:	8f 3f       	cpi	r24, 0xFF	; 255
    1c36:	19 f4       	brne	.+6      	; 0x1c3e <xQueueGenericReceive+0x11c>
    1c38:	ef 81       	ldd	r30, Y+7	; 0x07
    1c3a:	f8 85       	ldd	r31, Y+8	; 0x08
    1c3c:	16 8e       	std	Z+30, r1	; 0x1e
    1c3e:	0f 90       	pop	r0
    1c40:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1c42:	ce 01       	movw	r24, r28
    1c44:	04 96       	adiw	r24, 0x04	; 4
    1c46:	9e 01       	movw	r18, r28
    1c48:	25 5f       	subi	r18, 0xF5	; 245
    1c4a:	3f 4f       	sbci	r19, 0xFF	; 255
    1c4c:	b9 01       	movw	r22, r18
    1c4e:	0e 94 71 08 	call	0x10e2	; 0x10e2 <xTaskCheckForTimeOut>
    1c52:	88 23       	and	r24, r24
    1c54:	91 f5       	brne	.+100    	; 0x1cba <xQueueGenericReceive+0x198>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1c56:	8f 81       	ldd	r24, Y+7	; 0x07
    1c58:	98 85       	ldd	r25, Y+8	; 0x08
    1c5a:	0e 94 44 10 	call	0x2088	; 0x2088 <prvIsQueueEmpty>
    1c5e:	88 23       	and	r24, r24
    1c60:	29 f1       	breq	.+74     	; 0x1cac <xQueueGenericReceive+0x18a>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1c62:	ef 81       	ldd	r30, Y+7	; 0x07
    1c64:	f8 85       	ldd	r31, Y+8	; 0x08
    1c66:	80 81       	ld	r24, Z
    1c68:	91 81       	ldd	r25, Z+1	; 0x01
    1c6a:	00 97       	sbiw	r24, 0x00	; 0
    1c6c:	59 f4       	brne	.+22     	; 0x1c84 <xQueueGenericReceive+0x162>
					{
						portENTER_CRITICAL();
    1c6e:	0f b6       	in	r0, 0x3f	; 63
    1c70:	f8 94       	cli
    1c72:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1c74:	ef 81       	ldd	r30, Y+7	; 0x07
    1c76:	f8 85       	ldd	r31, Y+8	; 0x08
    1c78:	82 81       	ldd	r24, Z+2	; 0x02
    1c7a:	93 81       	ldd	r25, Z+3	; 0x03
    1c7c:	0e 94 96 0a 	call	0x152c	; 0x152c <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    1c80:	0f 90       	pop	r0
    1c82:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1c84:	8f 81       	ldd	r24, Y+7	; 0x07
    1c86:	98 85       	ldd	r25, Y+8	; 0x08
    1c88:	41 96       	adiw	r24, 0x11	; 17
    1c8a:	2b 85       	ldd	r18, Y+11	; 0x0b
    1c8c:	3c 85       	ldd	r19, Y+12	; 0x0c
    1c8e:	b9 01       	movw	r22, r18
    1c90:	0e 94 a7 07 	call	0xf4e	; 0xf4e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1c94:	8f 81       	ldd	r24, Y+7	; 0x07
    1c96:	98 85       	ldd	r25, Y+8	; 0x08
    1c98:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1c9c:	0e 94 91 05 	call	0xb22	; 0xb22 <xTaskResumeAll>
    1ca0:	88 23       	and	r24, r24
    1ca2:	09 f0       	breq	.+2      	; 0x1ca6 <xQueueGenericReceive+0x184>
    1ca4:	50 cf       	rjmp	.-352    	; 0x1b46 <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    1ca6:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <vPortYield>
    1caa:	4d cf       	rjmp	.-358    	; 0x1b46 <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1cac:	8f 81       	ldd	r24, Y+7	; 0x07
    1cae:	98 85       	ldd	r25, Y+8	; 0x08
    1cb0:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1cb4:	0e 94 91 05 	call	0xb22	; 0xb22 <xTaskResumeAll>
    1cb8:	46 cf       	rjmp	.-372    	; 0x1b46 <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1cba:	8f 81       	ldd	r24, Y+7	; 0x07
    1cbc:	98 85       	ldd	r25, Y+8	; 0x08
    1cbe:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1cc2:	0e 94 91 05 	call	0xb22	; 0xb22 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1cc6:	1e 86       	std	Y+14, r1	; 0x0e
    1cc8:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    1cca:	2e 96       	adiw	r28, 0x0e	; 14
    1ccc:	0f b6       	in	r0, 0x3f	; 63
    1cce:	f8 94       	cli
    1cd0:	de bf       	out	0x3e, r29	; 62
    1cd2:	0f be       	out	0x3f, r0	; 63
    1cd4:	cd bf       	out	0x3d, r28	; 61
    1cd6:	cf 91       	pop	r28
    1cd8:	df 91       	pop	r29
    1cda:	08 95       	ret

00001cdc <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
{
    1cdc:	df 93       	push	r29
    1cde:	cf 93       	push	r28
    1ce0:	cd b7       	in	r28, 0x3d	; 61
    1ce2:	de b7       	in	r29, 0x3e	; 62
    1ce4:	28 97       	sbiw	r28, 0x08	; 8
    1ce6:	0f b6       	in	r0, 0x3f	; 63
    1ce8:	f8 94       	cli
    1cea:	de bf       	out	0x3e, r29	; 62
    1cec:	0f be       	out	0x3f, r0	; 63
    1cee:	cd bf       	out	0x3d, r28	; 61
    1cf0:	9c 83       	std	Y+4, r25	; 0x04
    1cf2:	8b 83       	std	Y+3, r24	; 0x03
    1cf4:	7e 83       	std	Y+6, r23	; 0x06
    1cf6:	6d 83       	std	Y+5, r22	; 0x05
    1cf8:	58 87       	std	Y+8, r21	; 0x08
    1cfa:	4f 83       	std	Y+7, r20	; 0x07
unsigned portBASE_TYPE uxSavedInterruptStatus;

	configASSERT( pxQueue );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1cfc:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1cfe:	eb 81       	ldd	r30, Y+3	; 0x03
    1d00:	fc 81       	ldd	r31, Y+4	; 0x04
    1d02:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d04:	88 23       	and	r24, r24
    1d06:	91 f1       	breq	.+100    	; 0x1d6c <xQueueReceiveFromISR+0x90>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1d08:	8b 81       	ldd	r24, Y+3	; 0x03
    1d0a:	9c 81       	ldd	r25, Y+4	; 0x04
    1d0c:	2d 81       	ldd	r18, Y+5	; 0x05
    1d0e:	3e 81       	ldd	r19, Y+6	; 0x06
    1d10:	b9 01       	movw	r22, r18
    1d12:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1d16:	eb 81       	ldd	r30, Y+3	; 0x03
    1d18:	fc 81       	ldd	r31, Y+4	; 0x04
    1d1a:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d1c:	81 50       	subi	r24, 0x01	; 1
    1d1e:	eb 81       	ldd	r30, Y+3	; 0x03
    1d20:	fc 81       	ldd	r31, Y+4	; 0x04
    1d22:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1d24:	eb 81       	ldd	r30, Y+3	; 0x03
    1d26:	fc 81       	ldd	r31, Y+4	; 0x04
    1d28:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d2a:	8f 3f       	cpi	r24, 0xFF	; 255
    1d2c:	a9 f4       	brne	.+42     	; 0x1d58 <xQueueReceiveFromISR+0x7c>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1d2e:	eb 81       	ldd	r30, Y+3	; 0x03
    1d30:	fc 81       	ldd	r31, Y+4	; 0x04
    1d32:	80 85       	ldd	r24, Z+8	; 0x08
    1d34:	88 23       	and	r24, r24
    1d36:	b9 f0       	breq	.+46     	; 0x1d66 <xQueueReceiveFromISR+0x8a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1d38:	8b 81       	ldd	r24, Y+3	; 0x03
    1d3a:	9c 81       	ldd	r25, Y+4	; 0x04
    1d3c:	08 96       	adiw	r24, 0x08	; 8
    1d3e:	0e 94 ef 07 	call	0xfde	; 0xfde <xTaskRemoveFromEventList>
    1d42:	88 23       	and	r24, r24
    1d44:	81 f0       	breq	.+32     	; 0x1d66 <xQueueReceiveFromISR+0x8a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1d46:	8f 81       	ldd	r24, Y+7	; 0x07
    1d48:	98 85       	ldd	r25, Y+8	; 0x08
    1d4a:	00 97       	sbiw	r24, 0x00	; 0
    1d4c:	61 f0       	breq	.+24     	; 0x1d66 <xQueueReceiveFromISR+0x8a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1d4e:	ef 81       	ldd	r30, Y+7	; 0x07
    1d50:	f8 85       	ldd	r31, Y+8	; 0x08
    1d52:	81 e0       	ldi	r24, 0x01	; 1
    1d54:	80 83       	st	Z, r24
    1d56:	07 c0       	rjmp	.+14     	; 0x1d66 <xQueueReceiveFromISR+0x8a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1d58:	eb 81       	ldd	r30, Y+3	; 0x03
    1d5a:	fc 81       	ldd	r31, Y+4	; 0x04
    1d5c:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d5e:	8f 5f       	subi	r24, 0xFF	; 255
    1d60:	eb 81       	ldd	r30, Y+3	; 0x03
    1d62:	fc 81       	ldd	r31, Y+4	; 0x04
    1d64:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    1d66:	81 e0       	ldi	r24, 0x01	; 1
    1d68:	8a 83       	std	Y+2, r24	; 0x02
    1d6a:	01 c0       	rjmp	.+2      	; 0x1d6e <xQueueReceiveFromISR+0x92>
		}
		else
		{
			xReturn = pdFAIL;
    1d6c:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1d6e:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1d70:	28 96       	adiw	r28, 0x08	; 8
    1d72:	0f b6       	in	r0, 0x3f	; 63
    1d74:	f8 94       	cli
    1d76:	de bf       	out	0x3e, r29	; 62
    1d78:	0f be       	out	0x3f, r0	; 63
    1d7a:	cd bf       	out	0x3d, r28	; 61
    1d7c:	cf 91       	pop	r28
    1d7e:	df 91       	pop	r29
    1d80:	08 95       	ret

00001d82 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    1d82:	df 93       	push	r29
    1d84:	cf 93       	push	r28
    1d86:	00 d0       	rcall	.+0      	; 0x1d88 <uxQueueMessagesWaiting+0x6>
    1d88:	cd b7       	in	r28, 0x3d	; 61
    1d8a:	de b7       	in	r29, 0x3e	; 62
    1d8c:	9b 83       	std	Y+3, r25	; 0x03
    1d8e:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1d90:	0f b6       	in	r0, 0x3f	; 63
    1d92:	f8 94       	cli
    1d94:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1d96:	ea 81       	ldd	r30, Y+2	; 0x02
    1d98:	fb 81       	ldd	r31, Y+3	; 0x03
    1d9a:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d9c:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1d9e:	0f 90       	pop	r0
    1da0:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1da2:	89 81       	ldd	r24, Y+1	; 0x01
}
    1da4:	0f 90       	pop	r0
    1da6:	0f 90       	pop	r0
    1da8:	0f 90       	pop	r0
    1daa:	cf 91       	pop	r28
    1dac:	df 91       	pop	r29
    1dae:	08 95       	ret

00001db0 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    1db0:	df 93       	push	r29
    1db2:	cf 93       	push	r28
    1db4:	00 d0       	rcall	.+0      	; 0x1db6 <uxQueueMessagesWaitingFromISR+0x6>
    1db6:	cd b7       	in	r28, 0x3d	; 61
    1db8:	de b7       	in	r29, 0x3e	; 62
    1dba:	9b 83       	std	Y+3, r25	; 0x03
    1dbc:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    1dbe:	ea 81       	ldd	r30, Y+2	; 0x02
    1dc0:	fb 81       	ldd	r31, Y+3	; 0x03
    1dc2:	82 8d       	ldd	r24, Z+26	; 0x1a
    1dc4:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    1dc6:	89 81       	ldd	r24, Y+1	; 0x01
}
    1dc8:	0f 90       	pop	r0
    1dca:	0f 90       	pop	r0
    1dcc:	0f 90       	pop	r0
    1dce:	cf 91       	pop	r28
    1dd0:	df 91       	pop	r29
    1dd2:	08 95       	ret

00001dd4 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    1dd4:	df 93       	push	r29
    1dd6:	cf 93       	push	r28
    1dd8:	0f 92       	push	r0
    1dda:	0f 92       	push	r0
    1ddc:	cd b7       	in	r28, 0x3d	; 61
    1dde:	de b7       	in	r29, 0x3e	; 62
    1de0:	9a 83       	std	Y+2, r25	; 0x02
    1de2:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    1de4:	e9 81       	ldd	r30, Y+1	; 0x01
    1de6:	fa 81       	ldd	r31, Y+2	; 0x02
    1de8:	80 81       	ld	r24, Z
    1dea:	91 81       	ldd	r25, Z+1	; 0x01
    1dec:	0e 94 0a 15 	call	0x2a14	; 0x2a14 <vPortFree>
	vPortFree( pxQueue );
    1df0:	89 81       	ldd	r24, Y+1	; 0x01
    1df2:	9a 81       	ldd	r25, Y+2	; 0x02
    1df4:	0e 94 0a 15 	call	0x2a14	; 0x2a14 <vPortFree>
}
    1df8:	0f 90       	pop	r0
    1dfa:	0f 90       	pop	r0
    1dfc:	cf 91       	pop	r28
    1dfe:	df 91       	pop	r29
    1e00:	08 95       	ret

00001e02 <prvCopyDataToQueue>:

#endif
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    1e02:	df 93       	push	r29
    1e04:	cf 93       	push	r28
    1e06:	00 d0       	rcall	.+0      	; 0x1e08 <prvCopyDataToQueue+0x6>
    1e08:	0f 92       	push	r0
    1e0a:	0f 92       	push	r0
    1e0c:	cd b7       	in	r28, 0x3d	; 61
    1e0e:	de b7       	in	r29, 0x3e	; 62
    1e10:	9a 83       	std	Y+2, r25	; 0x02
    1e12:	89 83       	std	Y+1, r24	; 0x01
    1e14:	7c 83       	std	Y+4, r23	; 0x04
    1e16:	6b 83       	std	Y+3, r22	; 0x03
    1e18:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    1e1a:	e9 81       	ldd	r30, Y+1	; 0x01
    1e1c:	fa 81       	ldd	r31, Y+2	; 0x02
    1e1e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1e20:	88 23       	and	r24, r24
    1e22:	91 f4       	brne	.+36     	; 0x1e48 <prvCopyDataToQueue+0x46>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1e24:	e9 81       	ldd	r30, Y+1	; 0x01
    1e26:	fa 81       	ldd	r31, Y+2	; 0x02
    1e28:	80 81       	ld	r24, Z
    1e2a:	91 81       	ldd	r25, Z+1	; 0x01
    1e2c:	00 97       	sbiw	r24, 0x00	; 0
    1e2e:	09 f0       	breq	.+2      	; 0x1e32 <prvCopyDataToQueue+0x30>
    1e30:	7f c0       	rjmp	.+254    	; 0x1f30 <prvCopyDataToQueue+0x12e>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    1e32:	e9 81       	ldd	r30, Y+1	; 0x01
    1e34:	fa 81       	ldd	r31, Y+2	; 0x02
    1e36:	82 81       	ldd	r24, Z+2	; 0x02
    1e38:	93 81       	ldd	r25, Z+3	; 0x03
    1e3a:	0e 94 1b 0b 	call	0x1636	; 0x1636 <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    1e3e:	e9 81       	ldd	r30, Y+1	; 0x01
    1e40:	fa 81       	ldd	r31, Y+2	; 0x02
    1e42:	13 82       	std	Z+3, r1	; 0x03
    1e44:	12 82       	std	Z+2, r1	; 0x02
    1e46:	74 c0       	rjmp	.+232    	; 0x1f30 <prvCopyDataToQueue+0x12e>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    1e48:	8d 81       	ldd	r24, Y+5	; 0x05
    1e4a:	88 23       	and	r24, r24
    1e4c:	99 f5       	brne	.+102    	; 0x1eb4 <prvCopyDataToQueue+0xb2>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1e4e:	e9 81       	ldd	r30, Y+1	; 0x01
    1e50:	fa 81       	ldd	r31, Y+2	; 0x02
    1e52:	64 81       	ldd	r22, Z+4	; 0x04
    1e54:	75 81       	ldd	r23, Z+5	; 0x05
    1e56:	e9 81       	ldd	r30, Y+1	; 0x01
    1e58:	fa 81       	ldd	r31, Y+2	; 0x02
    1e5a:	84 8d       	ldd	r24, Z+28	; 0x1c
    1e5c:	48 2f       	mov	r20, r24
    1e5e:	50 e0       	ldi	r21, 0x00	; 0
    1e60:	2b 81       	ldd	r18, Y+3	; 0x03
    1e62:	3c 81       	ldd	r19, Y+4	; 0x04
    1e64:	cb 01       	movw	r24, r22
    1e66:	b9 01       	movw	r22, r18
    1e68:	0e 94 e5 1e 	call	0x3dca	; 0x3dca <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1e6c:	e9 81       	ldd	r30, Y+1	; 0x01
    1e6e:	fa 81       	ldd	r31, Y+2	; 0x02
    1e70:	24 81       	ldd	r18, Z+4	; 0x04
    1e72:	35 81       	ldd	r19, Z+5	; 0x05
    1e74:	e9 81       	ldd	r30, Y+1	; 0x01
    1e76:	fa 81       	ldd	r31, Y+2	; 0x02
    1e78:	84 8d       	ldd	r24, Z+28	; 0x1c
    1e7a:	88 2f       	mov	r24, r24
    1e7c:	90 e0       	ldi	r25, 0x00	; 0
    1e7e:	82 0f       	add	r24, r18
    1e80:	93 1f       	adc	r25, r19
    1e82:	e9 81       	ldd	r30, Y+1	; 0x01
    1e84:	fa 81       	ldd	r31, Y+2	; 0x02
    1e86:	95 83       	std	Z+5, r25	; 0x05
    1e88:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    1e8a:	e9 81       	ldd	r30, Y+1	; 0x01
    1e8c:	fa 81       	ldd	r31, Y+2	; 0x02
    1e8e:	24 81       	ldd	r18, Z+4	; 0x04
    1e90:	35 81       	ldd	r19, Z+5	; 0x05
    1e92:	e9 81       	ldd	r30, Y+1	; 0x01
    1e94:	fa 81       	ldd	r31, Y+2	; 0x02
    1e96:	82 81       	ldd	r24, Z+2	; 0x02
    1e98:	93 81       	ldd	r25, Z+3	; 0x03
    1e9a:	28 17       	cp	r18, r24
    1e9c:	39 07       	cpc	r19, r25
    1e9e:	08 f4       	brcc	.+2      	; 0x1ea2 <prvCopyDataToQueue+0xa0>
    1ea0:	47 c0       	rjmp	.+142    	; 0x1f30 <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1ea2:	e9 81       	ldd	r30, Y+1	; 0x01
    1ea4:	fa 81       	ldd	r31, Y+2	; 0x02
    1ea6:	80 81       	ld	r24, Z
    1ea8:	91 81       	ldd	r25, Z+1	; 0x01
    1eaa:	e9 81       	ldd	r30, Y+1	; 0x01
    1eac:	fa 81       	ldd	r31, Y+2	; 0x02
    1eae:	95 83       	std	Z+5, r25	; 0x05
    1eb0:	84 83       	std	Z+4, r24	; 0x04
    1eb2:	3e c0       	rjmp	.+124    	; 0x1f30 <prvCopyDataToQueue+0x12e>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1eb4:	e9 81       	ldd	r30, Y+1	; 0x01
    1eb6:	fa 81       	ldd	r31, Y+2	; 0x02
    1eb8:	66 81       	ldd	r22, Z+6	; 0x06
    1eba:	77 81       	ldd	r23, Z+7	; 0x07
    1ebc:	e9 81       	ldd	r30, Y+1	; 0x01
    1ebe:	fa 81       	ldd	r31, Y+2	; 0x02
    1ec0:	84 8d       	ldd	r24, Z+28	; 0x1c
    1ec2:	48 2f       	mov	r20, r24
    1ec4:	50 e0       	ldi	r21, 0x00	; 0
    1ec6:	2b 81       	ldd	r18, Y+3	; 0x03
    1ec8:	3c 81       	ldd	r19, Y+4	; 0x04
    1eca:	cb 01       	movw	r24, r22
    1ecc:	b9 01       	movw	r22, r18
    1ece:	0e 94 e5 1e 	call	0x3dca	; 0x3dca <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    1ed2:	e9 81       	ldd	r30, Y+1	; 0x01
    1ed4:	fa 81       	ldd	r31, Y+2	; 0x02
    1ed6:	26 81       	ldd	r18, Z+6	; 0x06
    1ed8:	37 81       	ldd	r19, Z+7	; 0x07
    1eda:	e9 81       	ldd	r30, Y+1	; 0x01
    1edc:	fa 81       	ldd	r31, Y+2	; 0x02
    1ede:	84 8d       	ldd	r24, Z+28	; 0x1c
    1ee0:	88 2f       	mov	r24, r24
    1ee2:	90 e0       	ldi	r25, 0x00	; 0
    1ee4:	90 95       	com	r25
    1ee6:	81 95       	neg	r24
    1ee8:	9f 4f       	sbci	r25, 0xFF	; 255
    1eea:	82 0f       	add	r24, r18
    1eec:	93 1f       	adc	r25, r19
    1eee:	e9 81       	ldd	r30, Y+1	; 0x01
    1ef0:	fa 81       	ldd	r31, Y+2	; 0x02
    1ef2:	97 83       	std	Z+7, r25	; 0x07
    1ef4:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    1ef6:	e9 81       	ldd	r30, Y+1	; 0x01
    1ef8:	fa 81       	ldd	r31, Y+2	; 0x02
    1efa:	26 81       	ldd	r18, Z+6	; 0x06
    1efc:	37 81       	ldd	r19, Z+7	; 0x07
    1efe:	e9 81       	ldd	r30, Y+1	; 0x01
    1f00:	fa 81       	ldd	r31, Y+2	; 0x02
    1f02:	80 81       	ld	r24, Z
    1f04:	91 81       	ldd	r25, Z+1	; 0x01
    1f06:	28 17       	cp	r18, r24
    1f08:	39 07       	cpc	r19, r25
    1f0a:	90 f4       	brcc	.+36     	; 0x1f30 <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1f0c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f0e:	fa 81       	ldd	r31, Y+2	; 0x02
    1f10:	22 81       	ldd	r18, Z+2	; 0x02
    1f12:	33 81       	ldd	r19, Z+3	; 0x03
    1f14:	e9 81       	ldd	r30, Y+1	; 0x01
    1f16:	fa 81       	ldd	r31, Y+2	; 0x02
    1f18:	84 8d       	ldd	r24, Z+28	; 0x1c
    1f1a:	88 2f       	mov	r24, r24
    1f1c:	90 e0       	ldi	r25, 0x00	; 0
    1f1e:	90 95       	com	r25
    1f20:	81 95       	neg	r24
    1f22:	9f 4f       	sbci	r25, 0xFF	; 255
    1f24:	82 0f       	add	r24, r18
    1f26:	93 1f       	adc	r25, r19
    1f28:	e9 81       	ldd	r30, Y+1	; 0x01
    1f2a:	fa 81       	ldd	r31, Y+2	; 0x02
    1f2c:	97 83       	std	Z+7, r25	; 0x07
    1f2e:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1f30:	e9 81       	ldd	r30, Y+1	; 0x01
    1f32:	fa 81       	ldd	r31, Y+2	; 0x02
    1f34:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f36:	8f 5f       	subi	r24, 0xFF	; 255
    1f38:	e9 81       	ldd	r30, Y+1	; 0x01
    1f3a:	fa 81       	ldd	r31, Y+2	; 0x02
    1f3c:	82 8f       	std	Z+26, r24	; 0x1a
}
    1f3e:	0f 90       	pop	r0
    1f40:	0f 90       	pop	r0
    1f42:	0f 90       	pop	r0
    1f44:	0f 90       	pop	r0
    1f46:	0f 90       	pop	r0
    1f48:	cf 91       	pop	r28
    1f4a:	df 91       	pop	r29
    1f4c:	08 95       	ret

00001f4e <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    1f4e:	df 93       	push	r29
    1f50:	cf 93       	push	r28
    1f52:	00 d0       	rcall	.+0      	; 0x1f54 <prvCopyDataFromQueue+0x6>
    1f54:	0f 92       	push	r0
    1f56:	cd b7       	in	r28, 0x3d	; 61
    1f58:	de b7       	in	r29, 0x3e	; 62
    1f5a:	9a 83       	std	Y+2, r25	; 0x02
    1f5c:	89 83       	std	Y+1, r24	; 0x01
    1f5e:	7c 83       	std	Y+4, r23	; 0x04
    1f60:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    1f62:	e9 81       	ldd	r30, Y+1	; 0x01
    1f64:	fa 81       	ldd	r31, Y+2	; 0x02
    1f66:	80 81       	ld	r24, Z
    1f68:	91 81       	ldd	r25, Z+1	; 0x01
    1f6a:	00 97       	sbiw	r24, 0x00	; 0
    1f6c:	89 f1       	breq	.+98     	; 0x1fd0 <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    1f6e:	e9 81       	ldd	r30, Y+1	; 0x01
    1f70:	fa 81       	ldd	r31, Y+2	; 0x02
    1f72:	26 81       	ldd	r18, Z+6	; 0x06
    1f74:	37 81       	ldd	r19, Z+7	; 0x07
    1f76:	e9 81       	ldd	r30, Y+1	; 0x01
    1f78:	fa 81       	ldd	r31, Y+2	; 0x02
    1f7a:	84 8d       	ldd	r24, Z+28	; 0x1c
    1f7c:	88 2f       	mov	r24, r24
    1f7e:	90 e0       	ldi	r25, 0x00	; 0
    1f80:	82 0f       	add	r24, r18
    1f82:	93 1f       	adc	r25, r19
    1f84:	e9 81       	ldd	r30, Y+1	; 0x01
    1f86:	fa 81       	ldd	r31, Y+2	; 0x02
    1f88:	97 83       	std	Z+7, r25	; 0x07
    1f8a:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1f8c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f8e:	fa 81       	ldd	r31, Y+2	; 0x02
    1f90:	26 81       	ldd	r18, Z+6	; 0x06
    1f92:	37 81       	ldd	r19, Z+7	; 0x07
    1f94:	e9 81       	ldd	r30, Y+1	; 0x01
    1f96:	fa 81       	ldd	r31, Y+2	; 0x02
    1f98:	82 81       	ldd	r24, Z+2	; 0x02
    1f9a:	93 81       	ldd	r25, Z+3	; 0x03
    1f9c:	28 17       	cp	r18, r24
    1f9e:	39 07       	cpc	r19, r25
    1fa0:	40 f0       	brcs	.+16     	; 0x1fb2 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    1fa2:	e9 81       	ldd	r30, Y+1	; 0x01
    1fa4:	fa 81       	ldd	r31, Y+2	; 0x02
    1fa6:	80 81       	ld	r24, Z
    1fa8:	91 81       	ldd	r25, Z+1	; 0x01
    1faa:	e9 81       	ldd	r30, Y+1	; 0x01
    1fac:	fa 81       	ldd	r31, Y+2	; 0x02
    1fae:	97 83       	std	Z+7, r25	; 0x07
    1fb0:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1fb2:	e9 81       	ldd	r30, Y+1	; 0x01
    1fb4:	fa 81       	ldd	r31, Y+2	; 0x02
    1fb6:	46 81       	ldd	r20, Z+6	; 0x06
    1fb8:	57 81       	ldd	r21, Z+7	; 0x07
    1fba:	e9 81       	ldd	r30, Y+1	; 0x01
    1fbc:	fa 81       	ldd	r31, Y+2	; 0x02
    1fbe:	84 8d       	ldd	r24, Z+28	; 0x1c
    1fc0:	28 2f       	mov	r18, r24
    1fc2:	30 e0       	ldi	r19, 0x00	; 0
    1fc4:	8b 81       	ldd	r24, Y+3	; 0x03
    1fc6:	9c 81       	ldd	r25, Y+4	; 0x04
    1fc8:	ba 01       	movw	r22, r20
    1fca:	a9 01       	movw	r20, r18
    1fcc:	0e 94 e5 1e 	call	0x3dca	; 0x3dca <memcpy>
	}
}
    1fd0:	0f 90       	pop	r0
    1fd2:	0f 90       	pop	r0
    1fd4:	0f 90       	pop	r0
    1fd6:	0f 90       	pop	r0
    1fd8:	cf 91       	pop	r28
    1fda:	df 91       	pop	r29
    1fdc:	08 95       	ret

00001fde <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    1fde:	df 93       	push	r29
    1fe0:	cf 93       	push	r28
    1fe2:	0f 92       	push	r0
    1fe4:	0f 92       	push	r0
    1fe6:	cd b7       	in	r28, 0x3d	; 61
    1fe8:	de b7       	in	r29, 0x3e	; 62
    1fea:	9a 83       	std	Y+2, r25	; 0x02
    1fec:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1fee:	0f b6       	in	r0, 0x3f	; 63
    1ff0:	f8 94       	cli
    1ff2:	0f 92       	push	r0
    1ff4:	15 c0       	rjmp	.+42     	; 0x2020 <prvUnlockQueue+0x42>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1ff6:	e9 81       	ldd	r30, Y+1	; 0x01
    1ff8:	fa 81       	ldd	r31, Y+2	; 0x02
    1ffa:	81 89       	ldd	r24, Z+17	; 0x11
    1ffc:	88 23       	and	r24, r24
    1ffe:	a9 f0       	breq	.+42     	; 0x202a <prvUnlockQueue+0x4c>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2000:	89 81       	ldd	r24, Y+1	; 0x01
    2002:	9a 81       	ldd	r25, Y+2	; 0x02
    2004:	41 96       	adiw	r24, 0x11	; 17
    2006:	0e 94 ef 07 	call	0xfde	; 0xfde <xTaskRemoveFromEventList>
    200a:	88 23       	and	r24, r24
    200c:	11 f0       	breq	.+4      	; 0x2012 <prvUnlockQueue+0x34>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    200e:	0e 94 d8 08 	call	0x11b0	; 0x11b0 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    2012:	e9 81       	ldd	r30, Y+1	; 0x01
    2014:	fa 81       	ldd	r31, Y+2	; 0x02
    2016:	86 8d       	ldd	r24, Z+30	; 0x1e
    2018:	81 50       	subi	r24, 0x01	; 1
    201a:	e9 81       	ldd	r30, Y+1	; 0x01
    201c:	fa 81       	ldd	r31, Y+2	; 0x02
    201e:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2020:	e9 81       	ldd	r30, Y+1	; 0x01
    2022:	fa 81       	ldd	r31, Y+2	; 0x02
    2024:	86 8d       	ldd	r24, Z+30	; 0x1e
    2026:	18 16       	cp	r1, r24
    2028:	34 f3       	brlt	.-52     	; 0x1ff6 <prvUnlockQueue+0x18>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    202a:	e9 81       	ldd	r30, Y+1	; 0x01
    202c:	fa 81       	ldd	r31, Y+2	; 0x02
    202e:	8f ef       	ldi	r24, 0xFF	; 255
    2030:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    2032:	0f 90       	pop	r0
    2034:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2036:	0f b6       	in	r0, 0x3f	; 63
    2038:	f8 94       	cli
    203a:	0f 92       	push	r0
    203c:	15 c0       	rjmp	.+42     	; 0x2068 <prvUnlockQueue+0x8a>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    203e:	e9 81       	ldd	r30, Y+1	; 0x01
    2040:	fa 81       	ldd	r31, Y+2	; 0x02
    2042:	80 85       	ldd	r24, Z+8	; 0x08
    2044:	88 23       	and	r24, r24
    2046:	a9 f0       	breq	.+42     	; 0x2072 <prvUnlockQueue+0x94>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2048:	89 81       	ldd	r24, Y+1	; 0x01
    204a:	9a 81       	ldd	r25, Y+2	; 0x02
    204c:	08 96       	adiw	r24, 0x08	; 8
    204e:	0e 94 ef 07 	call	0xfde	; 0xfde <xTaskRemoveFromEventList>
    2052:	88 23       	and	r24, r24
    2054:	11 f0       	breq	.+4      	; 0x205a <prvUnlockQueue+0x7c>
				{
					vTaskMissedYield();
    2056:	0e 94 d8 08 	call	0x11b0	; 0x11b0 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    205a:	e9 81       	ldd	r30, Y+1	; 0x01
    205c:	fa 81       	ldd	r31, Y+2	; 0x02
    205e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2060:	81 50       	subi	r24, 0x01	; 1
    2062:	e9 81       	ldd	r30, Y+1	; 0x01
    2064:	fa 81       	ldd	r31, Y+2	; 0x02
    2066:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2068:	e9 81       	ldd	r30, Y+1	; 0x01
    206a:	fa 81       	ldd	r31, Y+2	; 0x02
    206c:	85 8d       	ldd	r24, Z+29	; 0x1d
    206e:	18 16       	cp	r1, r24
    2070:	34 f3       	brlt	.-52     	; 0x203e <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    2072:	e9 81       	ldd	r30, Y+1	; 0x01
    2074:	fa 81       	ldd	r31, Y+2	; 0x02
    2076:	8f ef       	ldi	r24, 0xFF	; 255
    2078:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    207a:	0f 90       	pop	r0
    207c:	0f be       	out	0x3f, r0	; 63
}
    207e:	0f 90       	pop	r0
    2080:	0f 90       	pop	r0
    2082:	cf 91       	pop	r28
    2084:	df 91       	pop	r29
    2086:	08 95       	ret

00002088 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    2088:	df 93       	push	r29
    208a:	cf 93       	push	r28
    208c:	00 d0       	rcall	.+0      	; 0x208e <prvIsQueueEmpty+0x6>
    208e:	cd b7       	in	r28, 0x3d	; 61
    2090:	de b7       	in	r29, 0x3e	; 62
    2092:	9b 83       	std	Y+3, r25	; 0x03
    2094:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    2096:	0f b6       	in	r0, 0x3f	; 63
    2098:	f8 94       	cli
    209a:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    209c:	ea 81       	ldd	r30, Y+2	; 0x02
    209e:	fb 81       	ldd	r31, Y+3	; 0x03
    20a0:	82 8d       	ldd	r24, Z+26	; 0x1a
    20a2:	19 82       	std	Y+1, r1	; 0x01
    20a4:	88 23       	and	r24, r24
    20a6:	11 f4       	brne	.+4      	; 0x20ac <prvIsQueueEmpty+0x24>
    20a8:	81 e0       	ldi	r24, 0x01	; 1
    20aa:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    20ac:	0f 90       	pop	r0
    20ae:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    20b0:	89 81       	ldd	r24, Y+1	; 0x01
}
    20b2:	0f 90       	pop	r0
    20b4:	0f 90       	pop	r0
    20b6:	0f 90       	pop	r0
    20b8:	cf 91       	pop	r28
    20ba:	df 91       	pop	r29
    20bc:	08 95       	ret

000020be <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    20be:	df 93       	push	r29
    20c0:	cf 93       	push	r28
    20c2:	00 d0       	rcall	.+0      	; 0x20c4 <xQueueIsQueueEmptyFromISR+0x6>
    20c4:	cd b7       	in	r28, 0x3d	; 61
    20c6:	de b7       	in	r29, 0x3e	; 62
    20c8:	9b 83       	std	Y+3, r25	; 0x03
    20ca:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    20cc:	ea 81       	ldd	r30, Y+2	; 0x02
    20ce:	fb 81       	ldd	r31, Y+3	; 0x03
    20d0:	82 8d       	ldd	r24, Z+26	; 0x1a
    20d2:	19 82       	std	Y+1, r1	; 0x01
    20d4:	88 23       	and	r24, r24
    20d6:	11 f4       	brne	.+4      	; 0x20dc <xQueueIsQueueEmptyFromISR+0x1e>
    20d8:	81 e0       	ldi	r24, 0x01	; 1
    20da:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    20dc:	89 81       	ldd	r24, Y+1	; 0x01
}
    20de:	0f 90       	pop	r0
    20e0:	0f 90       	pop	r0
    20e2:	0f 90       	pop	r0
    20e4:	cf 91       	pop	r28
    20e6:	df 91       	pop	r29
    20e8:	08 95       	ret

000020ea <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    20ea:	df 93       	push	r29
    20ec:	cf 93       	push	r28
    20ee:	00 d0       	rcall	.+0      	; 0x20f0 <prvIsQueueFull+0x6>
    20f0:	cd b7       	in	r28, 0x3d	; 61
    20f2:	de b7       	in	r29, 0x3e	; 62
    20f4:	9b 83       	std	Y+3, r25	; 0x03
    20f6:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    20f8:	0f b6       	in	r0, 0x3f	; 63
    20fa:	f8 94       	cli
    20fc:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    20fe:	ea 81       	ldd	r30, Y+2	; 0x02
    2100:	fb 81       	ldd	r31, Y+3	; 0x03
    2102:	92 8d       	ldd	r25, Z+26	; 0x1a
    2104:	ea 81       	ldd	r30, Y+2	; 0x02
    2106:	fb 81       	ldd	r31, Y+3	; 0x03
    2108:	83 8d       	ldd	r24, Z+27	; 0x1b
    210a:	19 82       	std	Y+1, r1	; 0x01
    210c:	98 17       	cp	r25, r24
    210e:	11 f4       	brne	.+4      	; 0x2114 <prvIsQueueFull+0x2a>
    2110:	81 e0       	ldi	r24, 0x01	; 1
    2112:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    2114:	0f 90       	pop	r0
    2116:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2118:	89 81       	ldd	r24, Y+1	; 0x01
}
    211a:	0f 90       	pop	r0
    211c:	0f 90       	pop	r0
    211e:	0f 90       	pop	r0
    2120:	cf 91       	pop	r28
    2122:	df 91       	pop	r29
    2124:	08 95       	ret

00002126 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    2126:	df 93       	push	r29
    2128:	cf 93       	push	r28
    212a:	00 d0       	rcall	.+0      	; 0x212c <xQueueIsQueueFullFromISR+0x6>
    212c:	cd b7       	in	r28, 0x3d	; 61
    212e:	de b7       	in	r29, 0x3e	; 62
    2130:	9b 83       	std	Y+3, r25	; 0x03
    2132:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    2134:	ea 81       	ldd	r30, Y+2	; 0x02
    2136:	fb 81       	ldd	r31, Y+3	; 0x03
    2138:	92 8d       	ldd	r25, Z+26	; 0x1a
    213a:	ea 81       	ldd	r30, Y+2	; 0x02
    213c:	fb 81       	ldd	r31, Y+3	; 0x03
    213e:	83 8d       	ldd	r24, Z+27	; 0x1b
    2140:	19 82       	std	Y+1, r1	; 0x01
    2142:	98 17       	cp	r25, r24
    2144:	11 f4       	brne	.+4      	; 0x214a <xQueueIsQueueFullFromISR+0x24>
    2146:	81 e0       	ldi	r24, 0x01	; 1
    2148:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    214a:	89 81       	ldd	r24, Y+1	; 0x01
}
    214c:	0f 90       	pop	r0
    214e:	0f 90       	pop	r0
    2150:	0f 90       	pop	r0
    2152:	cf 91       	pop	r28
    2154:	df 91       	pop	r29
    2156:	08 95       	ret

00002158 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    2158:	df 93       	push	r29
    215a:	cf 93       	push	r28
    215c:	0f 92       	push	r0
    215e:	0f 92       	push	r0
    2160:	cd b7       	in	r28, 0x3d	; 61
    2162:	de b7       	in	r29, 0x3e	; 62
    2164:	9a 83       	std	Y+2, r25	; 0x02
    2166:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    2168:	89 81       	ldd	r24, Y+1	; 0x01
    216a:	9a 81       	ldd	r25, Y+2	; 0x02
    216c:	03 96       	adiw	r24, 0x03	; 3
    216e:	e9 81       	ldd	r30, Y+1	; 0x01
    2170:	fa 81       	ldd	r31, Y+2	; 0x02
    2172:	92 83       	std	Z+2, r25	; 0x02
    2174:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2176:	e9 81       	ldd	r30, Y+1	; 0x01
    2178:	fa 81       	ldd	r31, Y+2	; 0x02
    217a:	8f ef       	ldi	r24, 0xFF	; 255
    217c:	9f ef       	ldi	r25, 0xFF	; 255
    217e:	94 83       	std	Z+4, r25	; 0x04
    2180:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    2182:	89 81       	ldd	r24, Y+1	; 0x01
    2184:	9a 81       	ldd	r25, Y+2	; 0x02
    2186:	03 96       	adiw	r24, 0x03	; 3
    2188:	e9 81       	ldd	r30, Y+1	; 0x01
    218a:	fa 81       	ldd	r31, Y+2	; 0x02
    218c:	96 83       	std	Z+6, r25	; 0x06
    218e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    2190:	89 81       	ldd	r24, Y+1	; 0x01
    2192:	9a 81       	ldd	r25, Y+2	; 0x02
    2194:	03 96       	adiw	r24, 0x03	; 3
    2196:	e9 81       	ldd	r30, Y+1	; 0x01
    2198:	fa 81       	ldd	r31, Y+2	; 0x02
    219a:	90 87       	std	Z+8, r25	; 0x08
    219c:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    219e:	e9 81       	ldd	r30, Y+1	; 0x01
    21a0:	fa 81       	ldd	r31, Y+2	; 0x02
    21a2:	10 82       	st	Z, r1
}
    21a4:	0f 90       	pop	r0
    21a6:	0f 90       	pop	r0
    21a8:	cf 91       	pop	r28
    21aa:	df 91       	pop	r29
    21ac:	08 95       	ret

000021ae <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    21ae:	df 93       	push	r29
    21b0:	cf 93       	push	r28
    21b2:	0f 92       	push	r0
    21b4:	0f 92       	push	r0
    21b6:	cd b7       	in	r28, 0x3d	; 61
    21b8:	de b7       	in	r29, 0x3e	; 62
    21ba:	9a 83       	std	Y+2, r25	; 0x02
    21bc:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    21be:	e9 81       	ldd	r30, Y+1	; 0x01
    21c0:	fa 81       	ldd	r31, Y+2	; 0x02
    21c2:	11 86       	std	Z+9, r1	; 0x09
    21c4:	10 86       	std	Z+8, r1	; 0x08
}
    21c6:	0f 90       	pop	r0
    21c8:	0f 90       	pop	r0
    21ca:	cf 91       	pop	r28
    21cc:	df 91       	pop	r29
    21ce:	08 95       	ret

000021d0 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    21d0:	df 93       	push	r29
    21d2:	cf 93       	push	r28
    21d4:	00 d0       	rcall	.+0      	; 0x21d6 <vListInsertEnd+0x6>
    21d6:	00 d0       	rcall	.+0      	; 0x21d8 <vListInsertEnd+0x8>
    21d8:	cd b7       	in	r28, 0x3d	; 61
    21da:	de b7       	in	r29, 0x3e	; 62
    21dc:	9c 83       	std	Y+4, r25	; 0x04
    21de:	8b 83       	std	Y+3, r24	; 0x03
    21e0:	7e 83       	std	Y+6, r23	; 0x06
    21e2:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    21e4:	eb 81       	ldd	r30, Y+3	; 0x03
    21e6:	fc 81       	ldd	r31, Y+4	; 0x04
    21e8:	81 81       	ldd	r24, Z+1	; 0x01
    21ea:	92 81       	ldd	r25, Z+2	; 0x02
    21ec:	9a 83       	std	Y+2, r25	; 0x02
    21ee:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    21f0:	e9 81       	ldd	r30, Y+1	; 0x01
    21f2:	fa 81       	ldd	r31, Y+2	; 0x02
    21f4:	82 81       	ldd	r24, Z+2	; 0x02
    21f6:	93 81       	ldd	r25, Z+3	; 0x03
    21f8:	ed 81       	ldd	r30, Y+5	; 0x05
    21fa:	fe 81       	ldd	r31, Y+6	; 0x06
    21fc:	93 83       	std	Z+3, r25	; 0x03
    21fe:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    2200:	eb 81       	ldd	r30, Y+3	; 0x03
    2202:	fc 81       	ldd	r31, Y+4	; 0x04
    2204:	81 81       	ldd	r24, Z+1	; 0x01
    2206:	92 81       	ldd	r25, Z+2	; 0x02
    2208:	ed 81       	ldd	r30, Y+5	; 0x05
    220a:	fe 81       	ldd	r31, Y+6	; 0x06
    220c:	95 83       	std	Z+5, r25	; 0x05
    220e:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2210:	e9 81       	ldd	r30, Y+1	; 0x01
    2212:	fa 81       	ldd	r31, Y+2	; 0x02
    2214:	02 80       	ldd	r0, Z+2	; 0x02
    2216:	f3 81       	ldd	r31, Z+3	; 0x03
    2218:	e0 2d       	mov	r30, r0
    221a:	8d 81       	ldd	r24, Y+5	; 0x05
    221c:	9e 81       	ldd	r25, Y+6	; 0x06
    221e:	95 83       	std	Z+5, r25	; 0x05
    2220:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    2222:	8d 81       	ldd	r24, Y+5	; 0x05
    2224:	9e 81       	ldd	r25, Y+6	; 0x06
    2226:	e9 81       	ldd	r30, Y+1	; 0x01
    2228:	fa 81       	ldd	r31, Y+2	; 0x02
    222a:	93 83       	std	Z+3, r25	; 0x03
    222c:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    222e:	8d 81       	ldd	r24, Y+5	; 0x05
    2230:	9e 81       	ldd	r25, Y+6	; 0x06
    2232:	eb 81       	ldd	r30, Y+3	; 0x03
    2234:	fc 81       	ldd	r31, Y+4	; 0x04
    2236:	92 83       	std	Z+2, r25	; 0x02
    2238:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    223a:	ed 81       	ldd	r30, Y+5	; 0x05
    223c:	fe 81       	ldd	r31, Y+6	; 0x06
    223e:	8b 81       	ldd	r24, Y+3	; 0x03
    2240:	9c 81       	ldd	r25, Y+4	; 0x04
    2242:	91 87       	std	Z+9, r25	; 0x09
    2244:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    2246:	eb 81       	ldd	r30, Y+3	; 0x03
    2248:	fc 81       	ldd	r31, Y+4	; 0x04
    224a:	80 81       	ld	r24, Z
    224c:	8f 5f       	subi	r24, 0xFF	; 255
    224e:	eb 81       	ldd	r30, Y+3	; 0x03
    2250:	fc 81       	ldd	r31, Y+4	; 0x04
    2252:	80 83       	st	Z, r24
}
    2254:	26 96       	adiw	r28, 0x06	; 6
    2256:	0f b6       	in	r0, 0x3f	; 63
    2258:	f8 94       	cli
    225a:	de bf       	out	0x3e, r29	; 62
    225c:	0f be       	out	0x3f, r0	; 63
    225e:	cd bf       	out	0x3d, r28	; 61
    2260:	cf 91       	pop	r28
    2262:	df 91       	pop	r29
    2264:	08 95       	ret

00002266 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    2266:	df 93       	push	r29
    2268:	cf 93       	push	r28
    226a:	cd b7       	in	r28, 0x3d	; 61
    226c:	de b7       	in	r29, 0x3e	; 62
    226e:	28 97       	sbiw	r28, 0x08	; 8
    2270:	0f b6       	in	r0, 0x3f	; 63
    2272:	f8 94       	cli
    2274:	de bf       	out	0x3e, r29	; 62
    2276:	0f be       	out	0x3f, r0	; 63
    2278:	cd bf       	out	0x3d, r28	; 61
    227a:	9e 83       	std	Y+6, r25	; 0x06
    227c:	8d 83       	std	Y+5, r24	; 0x05
    227e:	78 87       	std	Y+8, r23	; 0x08
    2280:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    2282:	ef 81       	ldd	r30, Y+7	; 0x07
    2284:	f8 85       	ldd	r31, Y+8	; 0x08
    2286:	80 81       	ld	r24, Z
    2288:	91 81       	ldd	r25, Z+1	; 0x01
    228a:	9a 83       	std	Y+2, r25	; 0x02
    228c:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    228e:	89 81       	ldd	r24, Y+1	; 0x01
    2290:	9a 81       	ldd	r25, Y+2	; 0x02
    2292:	2f ef       	ldi	r18, 0xFF	; 255
    2294:	8f 3f       	cpi	r24, 0xFF	; 255
    2296:	92 07       	cpc	r25, r18
    2298:	39 f4       	brne	.+14     	; 0x22a8 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    229a:	ed 81       	ldd	r30, Y+5	; 0x05
    229c:	fe 81       	ldd	r31, Y+6	; 0x06
    229e:	87 81       	ldd	r24, Z+7	; 0x07
    22a0:	90 85       	ldd	r25, Z+8	; 0x08
    22a2:	9c 83       	std	Y+4, r25	; 0x04
    22a4:	8b 83       	std	Y+3, r24	; 0x03
    22a6:	18 c0       	rjmp	.+48     	; 0x22d8 <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    22a8:	8d 81       	ldd	r24, Y+5	; 0x05
    22aa:	9e 81       	ldd	r25, Y+6	; 0x06
    22ac:	03 96       	adiw	r24, 0x03	; 3
    22ae:	9c 83       	std	Y+4, r25	; 0x04
    22b0:	8b 83       	std	Y+3, r24	; 0x03
    22b2:	06 c0       	rjmp	.+12     	; 0x22c0 <vListInsert+0x5a>
    22b4:	eb 81       	ldd	r30, Y+3	; 0x03
    22b6:	fc 81       	ldd	r31, Y+4	; 0x04
    22b8:	82 81       	ldd	r24, Z+2	; 0x02
    22ba:	93 81       	ldd	r25, Z+3	; 0x03
    22bc:	9c 83       	std	Y+4, r25	; 0x04
    22be:	8b 83       	std	Y+3, r24	; 0x03
    22c0:	eb 81       	ldd	r30, Y+3	; 0x03
    22c2:	fc 81       	ldd	r31, Y+4	; 0x04
    22c4:	02 80       	ldd	r0, Z+2	; 0x02
    22c6:	f3 81       	ldd	r31, Z+3	; 0x03
    22c8:	e0 2d       	mov	r30, r0
    22ca:	20 81       	ld	r18, Z
    22cc:	31 81       	ldd	r19, Z+1	; 0x01
    22ce:	89 81       	ldd	r24, Y+1	; 0x01
    22d0:	9a 81       	ldd	r25, Y+2	; 0x02
    22d2:	82 17       	cp	r24, r18
    22d4:	93 07       	cpc	r25, r19
    22d6:	70 f7       	brcc	.-36     	; 0x22b4 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    22d8:	eb 81       	ldd	r30, Y+3	; 0x03
    22da:	fc 81       	ldd	r31, Y+4	; 0x04
    22dc:	82 81       	ldd	r24, Z+2	; 0x02
    22de:	93 81       	ldd	r25, Z+3	; 0x03
    22e0:	ef 81       	ldd	r30, Y+7	; 0x07
    22e2:	f8 85       	ldd	r31, Y+8	; 0x08
    22e4:	93 83       	std	Z+3, r25	; 0x03
    22e6:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    22e8:	ef 81       	ldd	r30, Y+7	; 0x07
    22ea:	f8 85       	ldd	r31, Y+8	; 0x08
    22ec:	02 80       	ldd	r0, Z+2	; 0x02
    22ee:	f3 81       	ldd	r31, Z+3	; 0x03
    22f0:	e0 2d       	mov	r30, r0
    22f2:	8f 81       	ldd	r24, Y+7	; 0x07
    22f4:	98 85       	ldd	r25, Y+8	; 0x08
    22f6:	95 83       	std	Z+5, r25	; 0x05
    22f8:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    22fa:	ef 81       	ldd	r30, Y+7	; 0x07
    22fc:	f8 85       	ldd	r31, Y+8	; 0x08
    22fe:	8b 81       	ldd	r24, Y+3	; 0x03
    2300:	9c 81       	ldd	r25, Y+4	; 0x04
    2302:	95 83       	std	Z+5, r25	; 0x05
    2304:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    2306:	8f 81       	ldd	r24, Y+7	; 0x07
    2308:	98 85       	ldd	r25, Y+8	; 0x08
    230a:	eb 81       	ldd	r30, Y+3	; 0x03
    230c:	fc 81       	ldd	r31, Y+4	; 0x04
    230e:	93 83       	std	Z+3, r25	; 0x03
    2310:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2312:	ef 81       	ldd	r30, Y+7	; 0x07
    2314:	f8 85       	ldd	r31, Y+8	; 0x08
    2316:	8d 81       	ldd	r24, Y+5	; 0x05
    2318:	9e 81       	ldd	r25, Y+6	; 0x06
    231a:	91 87       	std	Z+9, r25	; 0x09
    231c:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    231e:	ed 81       	ldd	r30, Y+5	; 0x05
    2320:	fe 81       	ldd	r31, Y+6	; 0x06
    2322:	80 81       	ld	r24, Z
    2324:	8f 5f       	subi	r24, 0xFF	; 255
    2326:	ed 81       	ldd	r30, Y+5	; 0x05
    2328:	fe 81       	ldd	r31, Y+6	; 0x06
    232a:	80 83       	st	Z, r24
}
    232c:	28 96       	adiw	r28, 0x08	; 8
    232e:	0f b6       	in	r0, 0x3f	; 63
    2330:	f8 94       	cli
    2332:	de bf       	out	0x3e, r29	; 62
    2334:	0f be       	out	0x3f, r0	; 63
    2336:	cd bf       	out	0x3d, r28	; 61
    2338:	cf 91       	pop	r28
    233a:	df 91       	pop	r29
    233c:	08 95       	ret

0000233e <uxListRemove>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
{
    233e:	df 93       	push	r29
    2340:	cf 93       	push	r28
    2342:	00 d0       	rcall	.+0      	; 0x2344 <uxListRemove+0x6>
    2344:	0f 92       	push	r0
    2346:	cd b7       	in	r28, 0x3d	; 61
    2348:	de b7       	in	r29, 0x3e	; 62
    234a:	9c 83       	std	Y+4, r25	; 0x04
    234c:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    234e:	eb 81       	ldd	r30, Y+3	; 0x03
    2350:	fc 81       	ldd	r31, Y+4	; 0x04
    2352:	a2 81       	ldd	r26, Z+2	; 0x02
    2354:	b3 81       	ldd	r27, Z+3	; 0x03
    2356:	eb 81       	ldd	r30, Y+3	; 0x03
    2358:	fc 81       	ldd	r31, Y+4	; 0x04
    235a:	84 81       	ldd	r24, Z+4	; 0x04
    235c:	95 81       	ldd	r25, Z+5	; 0x05
    235e:	15 96       	adiw	r26, 0x05	; 5
    2360:	9c 93       	st	X, r25
    2362:	8e 93       	st	-X, r24
    2364:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2366:	eb 81       	ldd	r30, Y+3	; 0x03
    2368:	fc 81       	ldd	r31, Y+4	; 0x04
    236a:	a4 81       	ldd	r26, Z+4	; 0x04
    236c:	b5 81       	ldd	r27, Z+5	; 0x05
    236e:	eb 81       	ldd	r30, Y+3	; 0x03
    2370:	fc 81       	ldd	r31, Y+4	; 0x04
    2372:	82 81       	ldd	r24, Z+2	; 0x02
    2374:	93 81       	ldd	r25, Z+3	; 0x03
    2376:	13 96       	adiw	r26, 0x03	; 3
    2378:	9c 93       	st	X, r25
    237a:	8e 93       	st	-X, r24
    237c:	12 97       	sbiw	r26, 0x02	; 2

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    237e:	eb 81       	ldd	r30, Y+3	; 0x03
    2380:	fc 81       	ldd	r31, Y+4	; 0x04
    2382:	80 85       	ldd	r24, Z+8	; 0x08
    2384:	91 85       	ldd	r25, Z+9	; 0x09
    2386:	9a 83       	std	Y+2, r25	; 0x02
    2388:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    238a:	e9 81       	ldd	r30, Y+1	; 0x01
    238c:	fa 81       	ldd	r31, Y+2	; 0x02
    238e:	21 81       	ldd	r18, Z+1	; 0x01
    2390:	32 81       	ldd	r19, Z+2	; 0x02
    2392:	8b 81       	ldd	r24, Y+3	; 0x03
    2394:	9c 81       	ldd	r25, Y+4	; 0x04
    2396:	28 17       	cp	r18, r24
    2398:	39 07       	cpc	r19, r25
    239a:	41 f4       	brne	.+16     	; 0x23ac <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    239c:	eb 81       	ldd	r30, Y+3	; 0x03
    239e:	fc 81       	ldd	r31, Y+4	; 0x04
    23a0:	84 81       	ldd	r24, Z+4	; 0x04
    23a2:	95 81       	ldd	r25, Z+5	; 0x05
    23a4:	e9 81       	ldd	r30, Y+1	; 0x01
    23a6:	fa 81       	ldd	r31, Y+2	; 0x02
    23a8:	92 83       	std	Z+2, r25	; 0x02
    23aa:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    23ac:	eb 81       	ldd	r30, Y+3	; 0x03
    23ae:	fc 81       	ldd	r31, Y+4	; 0x04
    23b0:	11 86       	std	Z+9, r1	; 0x09
    23b2:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    23b4:	e9 81       	ldd	r30, Y+1	; 0x01
    23b6:	fa 81       	ldd	r31, Y+2	; 0x02
    23b8:	80 81       	ld	r24, Z
    23ba:	81 50       	subi	r24, 0x01	; 1
    23bc:	e9 81       	ldd	r30, Y+1	; 0x01
    23be:	fa 81       	ldd	r31, Y+2	; 0x02
    23c0:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    23c2:	e9 81       	ldd	r30, Y+1	; 0x01
    23c4:	fa 81       	ldd	r31, Y+2	; 0x02
    23c6:	80 81       	ld	r24, Z
}
    23c8:	0f 90       	pop	r0
    23ca:	0f 90       	pop	r0
    23cc:	0f 90       	pop	r0
    23ce:	0f 90       	pop	r0
    23d0:	cf 91       	pop	r28
    23d2:	df 91       	pop	r29
    23d4:	08 95       	ret

000023d6 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    23d6:	df 93       	push	r29
    23d8:	cf 93       	push	r28
    23da:	cd b7       	in	r28, 0x3d	; 61
    23dc:	de b7       	in	r29, 0x3e	; 62
    23de:	27 97       	sbiw	r28, 0x07	; 7
    23e0:	0f b6       	in	r0, 0x3f	; 63
    23e2:	f8 94       	cli
    23e4:	de bf       	out	0x3e, r29	; 62
    23e6:	0f be       	out	0x3f, r0	; 63
    23e8:	cd bf       	out	0x3d, r28	; 61
    23ea:	9d 83       	std	Y+5, r25	; 0x05
    23ec:	8c 83       	std	Y+4, r24	; 0x04
    23ee:	6e 83       	std	Y+6, r22	; 0x06
    23f0:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    23f2:	8a e1       	ldi	r24, 0x1A	; 26
    23f4:	90 e0       	ldi	r25, 0x00	; 0
    23f6:	0e 94 c4 14 	call	0x2988	; 0x2988 <pvPortMalloc>
    23fa:	9a 83       	std	Y+2, r25	; 0x02
    23fc:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
    23fe:	89 81       	ldd	r24, Y+1	; 0x01
    2400:	9a 81       	ldd	r25, Y+2	; 0x02
    2402:	00 97       	sbiw	r24, 0x00	; 0
    2404:	09 f4       	brne	.+2      	; 0x2408 <xCoRoutineCreate+0x32>
    2406:	6f c0       	rjmp	.+222    	; 0x24e6 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    2408:	80 91 75 02 	lds	r24, 0x0275
    240c:	90 91 76 02 	lds	r25, 0x0276
    2410:	00 97       	sbiw	r24, 0x00	; 0
    2412:	41 f4       	brne	.+16     	; 0x2424 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    2414:	89 81       	ldd	r24, Y+1	; 0x01
    2416:	9a 81       	ldd	r25, Y+2	; 0x02
    2418:	90 93 76 02 	sts	0x0276, r25
    241c:	80 93 75 02 	sts	0x0275, r24
			prvInitialiseCoRoutineLists();
    2420:	0e 94 53 14 	call	0x28a6	; 0x28a6 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    2424:	8e 81       	ldd	r24, Y+6	; 0x06
    2426:	82 30       	cpi	r24, 0x02	; 2
    2428:	10 f0       	brcs	.+4      	; 0x242e <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    242a:	81 e0       	ldi	r24, 0x01	; 1
    242c:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    242e:	e9 81       	ldd	r30, Y+1	; 0x01
    2430:	fa 81       	ldd	r31, Y+2	; 0x02
    2432:	11 8e       	std	Z+25, r1	; 0x19
    2434:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    2436:	e9 81       	ldd	r30, Y+1	; 0x01
    2438:	fa 81       	ldd	r31, Y+2	; 0x02
    243a:	8e 81       	ldd	r24, Y+6	; 0x06
    243c:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    243e:	e9 81       	ldd	r30, Y+1	; 0x01
    2440:	fa 81       	ldd	r31, Y+2	; 0x02
    2442:	8f 81       	ldd	r24, Y+7	; 0x07
    2444:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    2446:	e9 81       	ldd	r30, Y+1	; 0x01
    2448:	fa 81       	ldd	r31, Y+2	; 0x02
    244a:	8c 81       	ldd	r24, Y+4	; 0x04
    244c:	9d 81       	ldd	r25, Y+5	; 0x05
    244e:	91 83       	std	Z+1, r25	; 0x01
    2450:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    2452:	89 81       	ldd	r24, Y+1	; 0x01
    2454:	9a 81       	ldd	r25, Y+2	; 0x02
    2456:	02 96       	adiw	r24, 0x02	; 2
    2458:	0e 94 d7 10 	call	0x21ae	; 0x21ae <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    245c:	89 81       	ldd	r24, Y+1	; 0x01
    245e:	9a 81       	ldd	r25, Y+2	; 0x02
    2460:	0c 96       	adiw	r24, 0x0c	; 12
    2462:	0e 94 d7 10 	call	0x21ae	; 0x21ae <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    2466:	e9 81       	ldd	r30, Y+1	; 0x01
    2468:	fa 81       	ldd	r31, Y+2	; 0x02
    246a:	89 81       	ldd	r24, Y+1	; 0x01
    246c:	9a 81       	ldd	r25, Y+2	; 0x02
    246e:	91 87       	std	Z+9, r25	; 0x09
    2470:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    2472:	e9 81       	ldd	r30, Y+1	; 0x01
    2474:	fa 81       	ldd	r31, Y+2	; 0x02
    2476:	89 81       	ldd	r24, Y+1	; 0x01
    2478:	9a 81       	ldd	r25, Y+2	; 0x02
    247a:	93 8b       	std	Z+19, r25	; 0x13
    247c:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    247e:	8e 81       	ldd	r24, Y+6	; 0x06
    2480:	28 2f       	mov	r18, r24
    2482:	30 e0       	ldi	r19, 0x00	; 0
    2484:	84 e0       	ldi	r24, 0x04	; 4
    2486:	90 e0       	ldi	r25, 0x00	; 0
    2488:	82 1b       	sub	r24, r18
    248a:	93 0b       	sbc	r25, r19
    248c:	e9 81       	ldd	r30, Y+1	; 0x01
    248e:	fa 81       	ldd	r31, Y+2	; 0x02
    2490:	95 87       	std	Z+13, r25	; 0x0d
    2492:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    2494:	e9 81       	ldd	r30, Y+1	; 0x01
    2496:	fa 81       	ldd	r31, Y+2	; 0x02
    2498:	96 89       	ldd	r25, Z+22	; 0x16
    249a:	80 91 77 02 	lds	r24, 0x0277
    249e:	89 17       	cp	r24, r25
    24a0:	28 f4       	brcc	.+10     	; 0x24ac <xCoRoutineCreate+0xd6>
    24a2:	e9 81       	ldd	r30, Y+1	; 0x01
    24a4:	fa 81       	ldd	r31, Y+2	; 0x02
    24a6:	86 89       	ldd	r24, Z+22	; 0x16
    24a8:	80 93 77 02 	sts	0x0277, r24
    24ac:	e9 81       	ldd	r30, Y+1	; 0x01
    24ae:	fa 81       	ldd	r31, Y+2	; 0x02
    24b0:	86 89       	ldd	r24, Z+22	; 0x16
    24b2:	28 2f       	mov	r18, r24
    24b4:	30 e0       	ldi	r19, 0x00	; 0
    24b6:	c9 01       	movw	r24, r18
    24b8:	88 0f       	add	r24, r24
    24ba:	99 1f       	adc	r25, r25
    24bc:	88 0f       	add	r24, r24
    24be:	99 1f       	adc	r25, r25
    24c0:	88 0f       	add	r24, r24
    24c2:	99 1f       	adc	r25, r25
    24c4:	82 0f       	add	r24, r18
    24c6:	93 1f       	adc	r25, r19
    24c8:	ac 01       	movw	r20, r24
    24ca:	42 58       	subi	r20, 0x82	; 130
    24cc:	5d 4f       	sbci	r21, 0xFD	; 253
    24ce:	89 81       	ldd	r24, Y+1	; 0x01
    24d0:	9a 81       	ldd	r25, Y+2	; 0x02
    24d2:	9c 01       	movw	r18, r24
    24d4:	2e 5f       	subi	r18, 0xFE	; 254
    24d6:	3f 4f       	sbci	r19, 0xFF	; 255
    24d8:	ca 01       	movw	r24, r20
    24da:	b9 01       	movw	r22, r18
    24dc:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <vListInsertEnd>

		xReturn = pdPASS;
    24e0:	81 e0       	ldi	r24, 0x01	; 1
    24e2:	8b 83       	std	Y+3, r24	; 0x03
    24e4:	02 c0       	rjmp	.+4      	; 0x24ea <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    24e6:	8f ef       	ldi	r24, 0xFF	; 255
    24e8:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
    24ea:	8b 81       	ldd	r24, Y+3	; 0x03
}
    24ec:	27 96       	adiw	r28, 0x07	; 7
    24ee:	0f b6       	in	r0, 0x3f	; 63
    24f0:	f8 94       	cli
    24f2:	de bf       	out	0x3e, r29	; 62
    24f4:	0f be       	out	0x3f, r0	; 63
    24f6:	cd bf       	out	0x3d, r28	; 61
    24f8:	cf 91       	pop	r28
    24fa:	df 91       	pop	r29
    24fc:	08 95       	ret

000024fe <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    24fe:	df 93       	push	r29
    2500:	cf 93       	push	r28
    2502:	00 d0       	rcall	.+0      	; 0x2504 <vCoRoutineAddToDelayedList+0x6>
    2504:	00 d0       	rcall	.+0      	; 0x2506 <vCoRoutineAddToDelayedList+0x8>
    2506:	cd b7       	in	r28, 0x3d	; 61
    2508:	de b7       	in	r29, 0x3e	; 62
    250a:	9c 83       	std	Y+4, r25	; 0x04
    250c:	8b 83       	std	Y+3, r24	; 0x03
    250e:	7e 83       	std	Y+6, r23	; 0x06
    2510:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    2512:	20 91 78 02 	lds	r18, 0x0278
    2516:	30 91 79 02 	lds	r19, 0x0279
    251a:	8b 81       	ldd	r24, Y+3	; 0x03
    251c:	9c 81       	ldd	r25, Y+4	; 0x04
    251e:	82 0f       	add	r24, r18
    2520:	93 1f       	adc	r25, r19
    2522:	9a 83       	std	Y+2, r25	; 0x02
    2524:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2526:	80 91 75 02 	lds	r24, 0x0275
    252a:	90 91 76 02 	lds	r25, 0x0276
    252e:	02 96       	adiw	r24, 0x02	; 2
    2530:	0e 94 9f 11 	call	0x233e	; 0x233e <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    2534:	e0 91 75 02 	lds	r30, 0x0275
    2538:	f0 91 76 02 	lds	r31, 0x0276
    253c:	89 81       	ldd	r24, Y+1	; 0x01
    253e:	9a 81       	ldd	r25, Y+2	; 0x02
    2540:	93 83       	std	Z+3, r25	; 0x03
    2542:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    2544:	20 91 78 02 	lds	r18, 0x0278
    2548:	30 91 79 02 	lds	r19, 0x0279
    254c:	89 81       	ldd	r24, Y+1	; 0x01
    254e:	9a 81       	ldd	r25, Y+2	; 0x02
    2550:	82 17       	cp	r24, r18
    2552:	93 07       	cpc	r25, r19
    2554:	70 f4       	brcc	.+28     	; 0x2572 <vCoRoutineAddToDelayedList+0x74>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2556:	80 91 a4 02 	lds	r24, 0x02A4
    255a:	90 91 a5 02 	lds	r25, 0x02A5
    255e:	20 91 75 02 	lds	r18, 0x0275
    2562:	30 91 76 02 	lds	r19, 0x0276
    2566:	2e 5f       	subi	r18, 0xFE	; 254
    2568:	3f 4f       	sbci	r19, 0xFF	; 255
    256a:	b9 01       	movw	r22, r18
    256c:	0e 94 33 11 	call	0x2266	; 0x2266 <vListInsert>
    2570:	0d c0       	rjmp	.+26     	; 0x258c <vCoRoutineAddToDelayedList+0x8e>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2572:	80 91 a2 02 	lds	r24, 0x02A2
    2576:	90 91 a3 02 	lds	r25, 0x02A3
    257a:	20 91 75 02 	lds	r18, 0x0275
    257e:	30 91 76 02 	lds	r19, 0x0276
    2582:	2e 5f       	subi	r18, 0xFE	; 254
    2584:	3f 4f       	sbci	r19, 0xFF	; 255
    2586:	b9 01       	movw	r22, r18
    2588:	0e 94 33 11 	call	0x2266	; 0x2266 <vListInsert>
	}

	if( pxEventList )
    258c:	8d 81       	ldd	r24, Y+5	; 0x05
    258e:	9e 81       	ldd	r25, Y+6	; 0x06
    2590:	00 97       	sbiw	r24, 0x00	; 0
    2592:	61 f0       	breq	.+24     	; 0x25ac <vCoRoutineAddToDelayedList+0xae>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    2594:	80 91 75 02 	lds	r24, 0x0275
    2598:	90 91 76 02 	lds	r25, 0x0276
    259c:	9c 01       	movw	r18, r24
    259e:	24 5f       	subi	r18, 0xF4	; 244
    25a0:	3f 4f       	sbci	r19, 0xFF	; 255
    25a2:	8d 81       	ldd	r24, Y+5	; 0x05
    25a4:	9e 81       	ldd	r25, Y+6	; 0x06
    25a6:	b9 01       	movw	r22, r18
    25a8:	0e 94 33 11 	call	0x2266	; 0x2266 <vListInsert>
	}
}
    25ac:	26 96       	adiw	r28, 0x06	; 6
    25ae:	0f b6       	in	r0, 0x3f	; 63
    25b0:	f8 94       	cli
    25b2:	de bf       	out	0x3e, r29	; 62
    25b4:	0f be       	out	0x3f, r0	; 63
    25b6:	cd bf       	out	0x3d, r28	; 61
    25b8:	cf 91       	pop	r28
    25ba:	df 91       	pop	r29
    25bc:	08 95       	ret

000025be <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    25be:	df 93       	push	r29
    25c0:	cf 93       	push	r28
    25c2:	0f 92       	push	r0
    25c4:	0f 92       	push	r0
    25c6:	cd b7       	in	r28, 0x3d	; 61
    25c8:	de b7       	in	r29, 0x3e	; 62
    25ca:	3a c0       	rjmp	.+116    	; 0x2640 <prvCheckPendingReadyList+0x82>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    25cc:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    25ce:	e0 91 ab 02 	lds	r30, 0x02AB
    25d2:	f0 91 ac 02 	lds	r31, 0x02AC
    25d6:	86 81       	ldd	r24, Z+6	; 0x06
    25d8:	97 81       	ldd	r25, Z+7	; 0x07
    25da:	9a 83       	std	Y+2, r25	; 0x02
    25dc:	89 83       	std	Y+1, r24	; 0x01
			uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    25de:	89 81       	ldd	r24, Y+1	; 0x01
    25e0:	9a 81       	ldd	r25, Y+2	; 0x02
    25e2:	0c 96       	adiw	r24, 0x0c	; 12
    25e4:	0e 94 9f 11 	call	0x233e	; 0x233e <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    25e8:	78 94       	sei

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    25ea:	89 81       	ldd	r24, Y+1	; 0x01
    25ec:	9a 81       	ldd	r25, Y+2	; 0x02
    25ee:	02 96       	adiw	r24, 0x02	; 2
    25f0:	0e 94 9f 11 	call	0x233e	; 0x233e <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    25f4:	e9 81       	ldd	r30, Y+1	; 0x01
    25f6:	fa 81       	ldd	r31, Y+2	; 0x02
    25f8:	96 89       	ldd	r25, Z+22	; 0x16
    25fa:	80 91 77 02 	lds	r24, 0x0277
    25fe:	89 17       	cp	r24, r25
    2600:	28 f4       	brcc	.+10     	; 0x260c <prvCheckPendingReadyList+0x4e>
    2602:	e9 81       	ldd	r30, Y+1	; 0x01
    2604:	fa 81       	ldd	r31, Y+2	; 0x02
    2606:	86 89       	ldd	r24, Z+22	; 0x16
    2608:	80 93 77 02 	sts	0x0277, r24
    260c:	e9 81       	ldd	r30, Y+1	; 0x01
    260e:	fa 81       	ldd	r31, Y+2	; 0x02
    2610:	86 89       	ldd	r24, Z+22	; 0x16
    2612:	28 2f       	mov	r18, r24
    2614:	30 e0       	ldi	r19, 0x00	; 0
    2616:	c9 01       	movw	r24, r18
    2618:	88 0f       	add	r24, r24
    261a:	99 1f       	adc	r25, r25
    261c:	88 0f       	add	r24, r24
    261e:	99 1f       	adc	r25, r25
    2620:	88 0f       	add	r24, r24
    2622:	99 1f       	adc	r25, r25
    2624:	82 0f       	add	r24, r18
    2626:	93 1f       	adc	r25, r19
    2628:	ac 01       	movw	r20, r24
    262a:	42 58       	subi	r20, 0x82	; 130
    262c:	5d 4f       	sbci	r21, 0xFD	; 253
    262e:	89 81       	ldd	r24, Y+1	; 0x01
    2630:	9a 81       	ldd	r25, Y+2	; 0x02
    2632:	9c 01       	movw	r18, r24
    2634:	2e 5f       	subi	r18, 0xFE	; 254
    2636:	3f 4f       	sbci	r19, 0xFF	; 255
    2638:	ca 01       	movw	r24, r20
    263a:	b9 01       	movw	r22, r18
    263c:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    2640:	80 91 a6 02 	lds	r24, 0x02A6
    2644:	88 23       	and	r24, r24
    2646:	09 f0       	breq	.+2      	; 0x264a <prvCheckPendingReadyList+0x8c>
    2648:	c1 cf       	rjmp	.-126    	; 0x25cc <prvCheckPendingReadyList+0xe>
		portENABLE_INTERRUPTS();

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    264a:	0f 90       	pop	r0
    264c:	0f 90       	pop	r0
    264e:	cf 91       	pop	r28
    2650:	df 91       	pop	r29
    2652:	08 95       	ret

00002654 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    2654:	df 93       	push	r29
    2656:	cf 93       	push	r28
    2658:	00 d0       	rcall	.+0      	; 0x265a <prvCheckDelayedList+0x6>
    265a:	0f 92       	push	r0
    265c:	cd b7       	in	r28, 0x3d	; 61
    265e:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    2660:	0e 94 1b 06 	call	0xc36	; 0xc36 <xTaskGetTickCount>
    2664:	20 91 7a 02 	lds	r18, 0x027A
    2668:	30 91 7b 02 	lds	r19, 0x027B
    266c:	82 1b       	sub	r24, r18
    266e:	93 0b       	sbc	r25, r19
    2670:	90 93 7d 02 	sts	0x027D, r25
    2674:	80 93 7c 02 	sts	0x027C, r24
    2678:	85 c0       	rjmp	.+266    	; 0x2784 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    267a:	80 91 78 02 	lds	r24, 0x0278
    267e:	90 91 79 02 	lds	r25, 0x0279
    2682:	01 96       	adiw	r24, 0x01	; 1
    2684:	90 93 79 02 	sts	0x0279, r25
    2688:	80 93 78 02 	sts	0x0278, r24
		xPassedTicks--;
    268c:	80 91 7c 02 	lds	r24, 0x027C
    2690:	90 91 7d 02 	lds	r25, 0x027D
    2694:	01 97       	sbiw	r24, 0x01	; 1
    2696:	90 93 7d 02 	sts	0x027D, r25
    269a:	80 93 7c 02 	sts	0x027C, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    269e:	80 91 78 02 	lds	r24, 0x0278
    26a2:	90 91 79 02 	lds	r25, 0x0279
    26a6:	00 97       	sbiw	r24, 0x00	; 0
    26a8:	09 f0       	breq	.+2      	; 0x26ac <prvCheckDelayedList+0x58>
    26aa:	64 c0       	rjmp	.+200    	; 0x2774 <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    26ac:	80 91 a2 02 	lds	r24, 0x02A2
    26b0:	90 91 a3 02 	lds	r25, 0x02A3
    26b4:	9a 83       	std	Y+2, r25	; 0x02
    26b6:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    26b8:	80 91 a4 02 	lds	r24, 0x02A4
    26bc:	90 91 a5 02 	lds	r25, 0x02A5
    26c0:	90 93 a3 02 	sts	0x02A3, r25
    26c4:	80 93 a2 02 	sts	0x02A2, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    26c8:	89 81       	ldd	r24, Y+1	; 0x01
    26ca:	9a 81       	ldd	r25, Y+2	; 0x02
    26cc:	90 93 a5 02 	sts	0x02A5, r25
    26d0:	80 93 a4 02 	sts	0x02A4, r24
    26d4:	4f c0       	rjmp	.+158    	; 0x2774 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    26d6:	e0 91 a2 02 	lds	r30, 0x02A2
    26da:	f0 91 a3 02 	lds	r31, 0x02A3
    26de:	05 80       	ldd	r0, Z+5	; 0x05
    26e0:	f6 81       	ldd	r31, Z+6	; 0x06
    26e2:	e0 2d       	mov	r30, r0
    26e4:	86 81       	ldd	r24, Z+6	; 0x06
    26e6:	97 81       	ldd	r25, Z+7	; 0x07
    26e8:	9c 83       	std	Y+4, r25	; 0x04
    26ea:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    26ec:	eb 81       	ldd	r30, Y+3	; 0x03
    26ee:	fc 81       	ldd	r31, Y+4	; 0x04
    26f0:	22 81       	ldd	r18, Z+2	; 0x02
    26f2:	33 81       	ldd	r19, Z+3	; 0x03
    26f4:	80 91 78 02 	lds	r24, 0x0278
    26f8:	90 91 79 02 	lds	r25, 0x0279
    26fc:	82 17       	cp	r24, r18
    26fe:	93 07       	cpc	r25, r19
    2700:	08 f4       	brcc	.+2      	; 0x2704 <prvCheckDelayedList+0xb0>
    2702:	40 c0       	rjmp	.+128    	; 0x2784 <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    2704:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				uxListRemove( &( pxCRCB->xGenericListItem ) );											
    2706:	8b 81       	ldd	r24, Y+3	; 0x03
    2708:	9c 81       	ldd	r25, Y+4	; 0x04
    270a:	02 96       	adiw	r24, 0x02	; 2
    270c:	0e 94 9f 11 	call	0x233e	; 0x233e <uxListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    2710:	eb 81       	ldd	r30, Y+3	; 0x03
    2712:	fc 81       	ldd	r31, Y+4	; 0x04
    2714:	84 89       	ldd	r24, Z+20	; 0x14
    2716:	95 89       	ldd	r25, Z+21	; 0x15
    2718:	00 97       	sbiw	r24, 0x00	; 0
    271a:	29 f0       	breq	.+10     	; 0x2726 <prvCheckDelayedList+0xd2>
				{															
					uxListRemove( &( pxCRCB->xEventListItem ) );											
    271c:	8b 81       	ldd	r24, Y+3	; 0x03
    271e:	9c 81       	ldd	r25, Y+4	; 0x04
    2720:	0c 96       	adiw	r24, 0x0c	; 12
    2722:	0e 94 9f 11 	call	0x233e	; 0x233e <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    2726:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    2728:	eb 81       	ldd	r30, Y+3	; 0x03
    272a:	fc 81       	ldd	r31, Y+4	; 0x04
    272c:	96 89       	ldd	r25, Z+22	; 0x16
    272e:	80 91 77 02 	lds	r24, 0x0277
    2732:	89 17       	cp	r24, r25
    2734:	28 f4       	brcc	.+10     	; 0x2740 <prvCheckDelayedList+0xec>
    2736:	eb 81       	ldd	r30, Y+3	; 0x03
    2738:	fc 81       	ldd	r31, Y+4	; 0x04
    273a:	86 89       	ldd	r24, Z+22	; 0x16
    273c:	80 93 77 02 	sts	0x0277, r24
    2740:	eb 81       	ldd	r30, Y+3	; 0x03
    2742:	fc 81       	ldd	r31, Y+4	; 0x04
    2744:	86 89       	ldd	r24, Z+22	; 0x16
    2746:	28 2f       	mov	r18, r24
    2748:	30 e0       	ldi	r19, 0x00	; 0
    274a:	c9 01       	movw	r24, r18
    274c:	88 0f       	add	r24, r24
    274e:	99 1f       	adc	r25, r25
    2750:	88 0f       	add	r24, r24
    2752:	99 1f       	adc	r25, r25
    2754:	88 0f       	add	r24, r24
    2756:	99 1f       	adc	r25, r25
    2758:	82 0f       	add	r24, r18
    275a:	93 1f       	adc	r25, r19
    275c:	ac 01       	movw	r20, r24
    275e:	42 58       	subi	r20, 0x82	; 130
    2760:	5d 4f       	sbci	r21, 0xFD	; 253
    2762:	8b 81       	ldd	r24, Y+3	; 0x03
    2764:	9c 81       	ldd	r25, Y+4	; 0x04
    2766:	9c 01       	movw	r18, r24
    2768:	2e 5f       	subi	r18, 0xFE	; 254
    276a:	3f 4f       	sbci	r19, 0xFF	; 255
    276c:	ca 01       	movw	r24, r20
    276e:	b9 01       	movw	r22, r18
    2770:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    2774:	e0 91 a2 02 	lds	r30, 0x02A2
    2778:	f0 91 a3 02 	lds	r31, 0x02A3
    277c:	80 81       	ld	r24, Z
    277e:	88 23       	and	r24, r24
    2780:	09 f0       	breq	.+2      	; 0x2784 <prvCheckDelayedList+0x130>
    2782:	a9 cf       	rjmp	.-174    	; 0x26d6 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    2784:	80 91 7c 02 	lds	r24, 0x027C
    2788:	90 91 7d 02 	lds	r25, 0x027D
    278c:	00 97       	sbiw	r24, 0x00	; 0
    278e:	09 f0       	breq	.+2      	; 0x2792 <prvCheckDelayedList+0x13e>
    2790:	74 cf       	rjmp	.-280    	; 0x267a <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    2792:	80 91 78 02 	lds	r24, 0x0278
    2796:	90 91 79 02 	lds	r25, 0x0279
    279a:	90 93 7b 02 	sts	0x027B, r25
    279e:	80 93 7a 02 	sts	0x027A, r24
}
    27a2:	0f 90       	pop	r0
    27a4:	0f 90       	pop	r0
    27a6:	0f 90       	pop	r0
    27a8:	0f 90       	pop	r0
    27aa:	cf 91       	pop	r28
    27ac:	df 91       	pop	r29
    27ae:	08 95       	ret

000027b0 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    27b0:	df 93       	push	r29
    27b2:	cf 93       	push	r28
    27b4:	0f 92       	push	r0
    27b6:	0f 92       	push	r0
    27b8:	cd b7       	in	r28, 0x3d	; 61
    27ba:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    27bc:	0e 94 df 12 	call	0x25be	; 0x25be <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    27c0:	0e 94 2a 13 	call	0x2654	; 0x2654 <prvCheckDelayedList>
    27c4:	0a c0       	rjmp	.+20     	; 0x27da <vCoRoutineSchedule+0x2a>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    27c6:	80 91 77 02 	lds	r24, 0x0277
    27ca:	88 23       	and	r24, r24
    27cc:	09 f4       	brne	.+2      	; 0x27d0 <vCoRoutineSchedule+0x20>
    27ce:	66 c0       	rjmp	.+204    	; 0x289c <vCoRoutineSchedule+0xec>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    27d0:	80 91 77 02 	lds	r24, 0x0277
    27d4:	81 50       	subi	r24, 0x01	; 1
    27d6:	80 93 77 02 	sts	0x0277, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    27da:	80 91 77 02 	lds	r24, 0x0277
    27de:	28 2f       	mov	r18, r24
    27e0:	30 e0       	ldi	r19, 0x00	; 0
    27e2:	c9 01       	movw	r24, r18
    27e4:	88 0f       	add	r24, r24
    27e6:	99 1f       	adc	r25, r25
    27e8:	88 0f       	add	r24, r24
    27ea:	99 1f       	adc	r25, r25
    27ec:	88 0f       	add	r24, r24
    27ee:	99 1f       	adc	r25, r25
    27f0:	82 0f       	add	r24, r18
    27f2:	93 1f       	adc	r25, r19
    27f4:	fc 01       	movw	r30, r24
    27f6:	e2 58       	subi	r30, 0x82	; 130
    27f8:	fd 4f       	sbci	r31, 0xFD	; 253
    27fa:	80 81       	ld	r24, Z
    27fc:	88 23       	and	r24, r24
    27fe:	19 f3       	breq	.-58     	; 0x27c6 <vCoRoutineSchedule+0x16>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    2800:	80 91 77 02 	lds	r24, 0x0277
    2804:	28 2f       	mov	r18, r24
    2806:	30 e0       	ldi	r19, 0x00	; 0
    2808:	c9 01       	movw	r24, r18
    280a:	88 0f       	add	r24, r24
    280c:	99 1f       	adc	r25, r25
    280e:	88 0f       	add	r24, r24
    2810:	99 1f       	adc	r25, r25
    2812:	88 0f       	add	r24, r24
    2814:	99 1f       	adc	r25, r25
    2816:	82 0f       	add	r24, r18
    2818:	93 1f       	adc	r25, r19
    281a:	82 58       	subi	r24, 0x82	; 130
    281c:	9d 4f       	sbci	r25, 0xFD	; 253
    281e:	9a 83       	std	Y+2, r25	; 0x02
    2820:	89 83       	std	Y+1, r24	; 0x01
    2822:	e9 81       	ldd	r30, Y+1	; 0x01
    2824:	fa 81       	ldd	r31, Y+2	; 0x02
    2826:	01 80       	ldd	r0, Z+1	; 0x01
    2828:	f2 81       	ldd	r31, Z+2	; 0x02
    282a:	e0 2d       	mov	r30, r0
    282c:	82 81       	ldd	r24, Z+2	; 0x02
    282e:	93 81       	ldd	r25, Z+3	; 0x03
    2830:	e9 81       	ldd	r30, Y+1	; 0x01
    2832:	fa 81       	ldd	r31, Y+2	; 0x02
    2834:	92 83       	std	Z+2, r25	; 0x02
    2836:	81 83       	std	Z+1, r24	; 0x01
    2838:	e9 81       	ldd	r30, Y+1	; 0x01
    283a:	fa 81       	ldd	r31, Y+2	; 0x02
    283c:	21 81       	ldd	r18, Z+1	; 0x01
    283e:	32 81       	ldd	r19, Z+2	; 0x02
    2840:	89 81       	ldd	r24, Y+1	; 0x01
    2842:	9a 81       	ldd	r25, Y+2	; 0x02
    2844:	03 96       	adiw	r24, 0x03	; 3
    2846:	28 17       	cp	r18, r24
    2848:	39 07       	cpc	r19, r25
    284a:	59 f4       	brne	.+22     	; 0x2862 <vCoRoutineSchedule+0xb2>
    284c:	e9 81       	ldd	r30, Y+1	; 0x01
    284e:	fa 81       	ldd	r31, Y+2	; 0x02
    2850:	01 80       	ldd	r0, Z+1	; 0x01
    2852:	f2 81       	ldd	r31, Z+2	; 0x02
    2854:	e0 2d       	mov	r30, r0
    2856:	82 81       	ldd	r24, Z+2	; 0x02
    2858:	93 81       	ldd	r25, Z+3	; 0x03
    285a:	e9 81       	ldd	r30, Y+1	; 0x01
    285c:	fa 81       	ldd	r31, Y+2	; 0x02
    285e:	92 83       	std	Z+2, r25	; 0x02
    2860:	81 83       	std	Z+1, r24	; 0x01
    2862:	e9 81       	ldd	r30, Y+1	; 0x01
    2864:	fa 81       	ldd	r31, Y+2	; 0x02
    2866:	01 80       	ldd	r0, Z+1	; 0x01
    2868:	f2 81       	ldd	r31, Z+2	; 0x02
    286a:	e0 2d       	mov	r30, r0
    286c:	86 81       	ldd	r24, Z+6	; 0x06
    286e:	97 81       	ldd	r25, Z+7	; 0x07
    2870:	90 93 76 02 	sts	0x0276, r25
    2874:	80 93 75 02 	sts	0x0275, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2878:	e0 91 75 02 	lds	r30, 0x0275
    287c:	f0 91 76 02 	lds	r31, 0x0276
    2880:	40 81       	ld	r20, Z
    2882:	51 81       	ldd	r21, Z+1	; 0x01
    2884:	80 91 75 02 	lds	r24, 0x0275
    2888:	90 91 76 02 	lds	r25, 0x0276
    288c:	e0 91 75 02 	lds	r30, 0x0275
    2890:	f0 91 76 02 	lds	r31, 0x0276
    2894:	27 89       	ldd	r18, Z+23	; 0x17
    2896:	62 2f       	mov	r22, r18
    2898:	fa 01       	movw	r30, r20
    289a:	19 95       	eicall

	return;
}
    289c:	0f 90       	pop	r0
    289e:	0f 90       	pop	r0
    28a0:	cf 91       	pop	r28
    28a2:	df 91       	pop	r29
    28a4:	08 95       	ret

000028a6 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    28a6:	df 93       	push	r29
    28a8:	cf 93       	push	r28
    28aa:	0f 92       	push	r0
    28ac:	cd b7       	in	r28, 0x3d	; 61
    28ae:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    28b0:	19 82       	std	Y+1, r1	; 0x01
    28b2:	13 c0       	rjmp	.+38     	; 0x28da <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    28b4:	89 81       	ldd	r24, Y+1	; 0x01
    28b6:	28 2f       	mov	r18, r24
    28b8:	30 e0       	ldi	r19, 0x00	; 0
    28ba:	c9 01       	movw	r24, r18
    28bc:	88 0f       	add	r24, r24
    28be:	99 1f       	adc	r25, r25
    28c0:	88 0f       	add	r24, r24
    28c2:	99 1f       	adc	r25, r25
    28c4:	88 0f       	add	r24, r24
    28c6:	99 1f       	adc	r25, r25
    28c8:	82 0f       	add	r24, r18
    28ca:	93 1f       	adc	r25, r19
    28cc:	82 58       	subi	r24, 0x82	; 130
    28ce:	9d 4f       	sbci	r25, 0xFD	; 253
    28d0:	0e 94 ac 10 	call	0x2158	; 0x2158 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    28d4:	89 81       	ldd	r24, Y+1	; 0x01
    28d6:	8f 5f       	subi	r24, 0xFF	; 255
    28d8:	89 83       	std	Y+1, r24	; 0x01
    28da:	89 81       	ldd	r24, Y+1	; 0x01
    28dc:	82 30       	cpi	r24, 0x02	; 2
    28de:	50 f3       	brcs	.-44     	; 0x28b4 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    28e0:	80 e9       	ldi	r24, 0x90	; 144
    28e2:	92 e0       	ldi	r25, 0x02	; 2
    28e4:	0e 94 ac 10 	call	0x2158	; 0x2158 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    28e8:	89 e9       	ldi	r24, 0x99	; 153
    28ea:	92 e0       	ldi	r25, 0x02	; 2
    28ec:	0e 94 ac 10 	call	0x2158	; 0x2158 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    28f0:	86 ea       	ldi	r24, 0xA6	; 166
    28f2:	92 e0       	ldi	r25, 0x02	; 2
    28f4:	0e 94 ac 10 	call	0x2158	; 0x2158 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    28f8:	80 e9       	ldi	r24, 0x90	; 144
    28fa:	92 e0       	ldi	r25, 0x02	; 2
    28fc:	90 93 a3 02 	sts	0x02A3, r25
    2900:	80 93 a2 02 	sts	0x02A2, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    2904:	89 e9       	ldi	r24, 0x99	; 153
    2906:	92 e0       	ldi	r25, 0x02	; 2
    2908:	90 93 a5 02 	sts	0x02A5, r25
    290c:	80 93 a4 02 	sts	0x02A4, r24
}
    2910:	0f 90       	pop	r0
    2912:	cf 91       	pop	r28
    2914:	df 91       	pop	r29
    2916:	08 95       	ret

00002918 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    2918:	df 93       	push	r29
    291a:	cf 93       	push	r28
    291c:	00 d0       	rcall	.+0      	; 0x291e <xCoRoutineRemoveFromEventList+0x6>
    291e:	0f 92       	push	r0
    2920:	0f 92       	push	r0
    2922:	cd b7       	in	r28, 0x3d	; 61
    2924:	de b7       	in	r29, 0x3e	; 62
    2926:	9d 83       	std	Y+5, r25	; 0x05
    2928:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    292a:	ec 81       	ldd	r30, Y+4	; 0x04
    292c:	fd 81       	ldd	r31, Y+5	; 0x05
    292e:	05 80       	ldd	r0, Z+5	; 0x05
    2930:	f6 81       	ldd	r31, Z+6	; 0x06
    2932:	e0 2d       	mov	r30, r0
    2934:	86 81       	ldd	r24, Z+6	; 0x06
    2936:	97 81       	ldd	r25, Z+7	; 0x07
    2938:	9b 83       	std	Y+3, r25	; 0x03
    293a:	8a 83       	std	Y+2, r24	; 0x02
	uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    293c:	8a 81       	ldd	r24, Y+2	; 0x02
    293e:	9b 81       	ldd	r25, Y+3	; 0x03
    2940:	0c 96       	adiw	r24, 0x0c	; 12
    2942:	0e 94 9f 11 	call	0x233e	; 0x233e <uxListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    2946:	8a 81       	ldd	r24, Y+2	; 0x02
    2948:	9b 81       	ldd	r25, Y+3	; 0x03
    294a:	9c 01       	movw	r18, r24
    294c:	24 5f       	subi	r18, 0xF4	; 244
    294e:	3f 4f       	sbci	r19, 0xFF	; 255
    2950:	86 ea       	ldi	r24, 0xA6	; 166
    2952:	92 e0       	ldi	r25, 0x02	; 2
    2954:	b9 01       	movw	r22, r18
    2956:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    295a:	ea 81       	ldd	r30, Y+2	; 0x02
    295c:	fb 81       	ldd	r31, Y+3	; 0x03
    295e:	96 89       	ldd	r25, Z+22	; 0x16
    2960:	e0 91 75 02 	lds	r30, 0x0275
    2964:	f0 91 76 02 	lds	r31, 0x0276
    2968:	86 89       	ldd	r24, Z+22	; 0x16
    296a:	98 17       	cp	r25, r24
    296c:	18 f0       	brcs	.+6      	; 0x2974 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    296e:	81 e0       	ldi	r24, 0x01	; 1
    2970:	89 83       	std	Y+1, r24	; 0x01
    2972:	01 c0       	rjmp	.+2      	; 0x2976 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    2974:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2976:	89 81       	ldd	r24, Y+1	; 0x01
}
    2978:	0f 90       	pop	r0
    297a:	0f 90       	pop	r0
    297c:	0f 90       	pop	r0
    297e:	0f 90       	pop	r0
    2980:	0f 90       	pop	r0
    2982:	cf 91       	pop	r28
    2984:	df 91       	pop	r29
    2986:	08 95       	ret

00002988 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2988:	df 93       	push	r29
    298a:	cf 93       	push	r28
    298c:	00 d0       	rcall	.+0      	; 0x298e <pvPortMalloc+0x6>
    298e:	0f 92       	push	r0
    2990:	cd b7       	in	r28, 0x3d	; 61
    2992:	de b7       	in	r29, 0x3e	; 62
    2994:	9c 83       	std	Y+4, r25	; 0x04
    2996:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    2998:	1a 82       	std	Y+2, r1	; 0x02
    299a:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    299c:	0e 94 85 05 	call	0xb0a	; 0xb0a <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    29a0:	80 91 af 02 	lds	r24, 0x02AF
    29a4:	90 91 b0 02 	lds	r25, 0x02B0
    29a8:	2b 81       	ldd	r18, Y+3	; 0x03
    29aa:	3c 81       	ldd	r19, Y+4	; 0x04
    29ac:	82 0f       	add	r24, r18
    29ae:	93 1f       	adc	r25, r19
    29b0:	28 e1       	ldi	r18, 0x18	; 24
    29b2:	80 30       	cpi	r24, 0x00	; 0
    29b4:	92 07       	cpc	r25, r18
    29b6:	18 f5       	brcc	.+70     	; 0x29fe <pvPortMalloc+0x76>
    29b8:	20 91 af 02 	lds	r18, 0x02AF
    29bc:	30 91 b0 02 	lds	r19, 0x02B0
    29c0:	8b 81       	ldd	r24, Y+3	; 0x03
    29c2:	9c 81       	ldd	r25, Y+4	; 0x04
    29c4:	28 0f       	add	r18, r24
    29c6:	39 1f       	adc	r19, r25
    29c8:	80 91 af 02 	lds	r24, 0x02AF
    29cc:	90 91 b0 02 	lds	r25, 0x02B0
    29d0:	82 17       	cp	r24, r18
    29d2:	93 07       	cpc	r25, r19
    29d4:	a0 f4       	brcc	.+40     	; 0x29fe <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    29d6:	80 91 af 02 	lds	r24, 0x02AF
    29da:	90 91 b0 02 	lds	r25, 0x02B0
    29de:	8f 54       	subi	r24, 0x4F	; 79
    29e0:	9d 4f       	sbci	r25, 0xFD	; 253
    29e2:	9a 83       	std	Y+2, r25	; 0x02
    29e4:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    29e6:	20 91 af 02 	lds	r18, 0x02AF
    29ea:	30 91 b0 02 	lds	r19, 0x02B0
    29ee:	8b 81       	ldd	r24, Y+3	; 0x03
    29f0:	9c 81       	ldd	r25, Y+4	; 0x04
    29f2:	82 0f       	add	r24, r18
    29f4:	93 1f       	adc	r25, r19
    29f6:	90 93 b0 02 	sts	0x02B0, r25
    29fa:	80 93 af 02 	sts	0x02AF, r24
		}
	}
	xTaskResumeAll();
    29fe:	0e 94 91 05 	call	0xb22	; 0xb22 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    2a02:	89 81       	ldd	r24, Y+1	; 0x01
    2a04:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2a06:	0f 90       	pop	r0
    2a08:	0f 90       	pop	r0
    2a0a:	0f 90       	pop	r0
    2a0c:	0f 90       	pop	r0
    2a0e:	cf 91       	pop	r28
    2a10:	df 91       	pop	r29
    2a12:	08 95       	ret

00002a14 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2a14:	df 93       	push	r29
    2a16:	cf 93       	push	r28
    2a18:	0f 92       	push	r0
    2a1a:	0f 92       	push	r0
    2a1c:	cd b7       	in	r28, 0x3d	; 61
    2a1e:	de b7       	in	r29, 0x3e	; 62
    2a20:	9a 83       	std	Y+2, r25	; 0x02
    2a22:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    2a24:	0f 90       	pop	r0
    2a26:	0f 90       	pop	r0
    2a28:	cf 91       	pop	r28
    2a2a:	df 91       	pop	r29
    2a2c:	08 95       	ret

00002a2e <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    2a2e:	df 93       	push	r29
    2a30:	cf 93       	push	r28
    2a32:	cd b7       	in	r28, 0x3d	; 61
    2a34:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    2a36:	10 92 b0 02 	sts	0x02B0, r1
    2a3a:	10 92 af 02 	sts	0x02AF, r1
}
    2a3e:	cf 91       	pop	r28
    2a40:	df 91       	pop	r29
    2a42:	08 95       	ret

00002a44 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    2a44:	df 93       	push	r29
    2a46:	cf 93       	push	r28
    2a48:	cd b7       	in	r28, 0x3d	; 61
    2a4a:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    2a4c:	20 91 af 02 	lds	r18, 0x02AF
    2a50:	30 91 b0 02 	lds	r19, 0x02B0
    2a54:	80 e0       	ldi	r24, 0x00	; 0
    2a56:	98 e1       	ldi	r25, 0x18	; 24
    2a58:	82 1b       	sub	r24, r18
    2a5a:	93 0b       	sbc	r25, r19
}
    2a5c:	cf 91       	pop	r28
    2a5e:	df 91       	pop	r29
    2a60:	08 95       	ret

00002a62 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    2a62:	df 93       	push	r29
    2a64:	cf 93       	push	r28
    2a66:	cd b7       	in	r28, 0x3d	; 61
    2a68:	de b7       	in	r29, 0x3e	; 62
    2a6a:	28 97       	sbiw	r28, 0x08	; 8
    2a6c:	0f b6       	in	r0, 0x3f	; 63
    2a6e:	f8 94       	cli
    2a70:	de bf       	out	0x3e, r29	; 62
    2a72:	0f be       	out	0x3f, r0	; 63
    2a74:	cd bf       	out	0x3d, r28	; 61
    2a76:	9c 83       	std	Y+4, r25	; 0x04
    2a78:	8b 83       	std	Y+3, r24	; 0x03
    2a7a:	7e 83       	std	Y+6, r23	; 0x06
    2a7c:	6d 83       	std	Y+5, r22	; 0x05
    2a7e:	58 87       	std	Y+8, r21	; 0x08
    2a80:	4f 83       	std	Y+7, r20	; 0x07
#endif

	/* Place a few bytes of known values on the bottom of the stack.
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2a82:	eb 81       	ldd	r30, Y+3	; 0x03
    2a84:	fc 81       	ldd	r31, Y+4	; 0x04
    2a86:	81 e1       	ldi	r24, 0x11	; 17
    2a88:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a8a:	8b 81       	ldd	r24, Y+3	; 0x03
    2a8c:	9c 81       	ldd	r25, Y+4	; 0x04
    2a8e:	01 97       	sbiw	r24, 0x01	; 1
    2a90:	9c 83       	std	Y+4, r25	; 0x04
    2a92:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    2a94:	eb 81       	ldd	r30, Y+3	; 0x03
    2a96:	fc 81       	ldd	r31, Y+4	; 0x04
    2a98:	82 e2       	ldi	r24, 0x22	; 34
    2a9a:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a9c:	8b 81       	ldd	r24, Y+3	; 0x03
    2a9e:	9c 81       	ldd	r25, Y+4	; 0x04
    2aa0:	01 97       	sbiw	r24, 0x01	; 1
    2aa2:	9c 83       	std	Y+4, r25	; 0x04
    2aa4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    2aa6:	eb 81       	ldd	r30, Y+3	; 0x03
    2aa8:	fc 81       	ldd	r31, Y+4	; 0x04
    2aaa:	83 e3       	ldi	r24, 0x33	; 51
    2aac:	80 83       	st	Z, r24
	pxTopOfStack--;
    2aae:	8b 81       	ldd	r24, Y+3	; 0x03
    2ab0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ab2:	01 97       	sbiw	r24, 0x01	; 1
    2ab4:	9c 83       	std	Y+4, r25	; 0x04
    2ab6:	8b 83       	std	Y+3, r24	; 0x03
	 * of flash. We do this by adding the .task label in the linker script.
	 *
	 * In order to do this properly, we would need to get a full 3-byte pointer to
	 * pxCode.  That requires a change to GCC.  Not likely to happen any time soon.
	 */
	usAddress = ( unsigned portSHORT ) pxCode;
    2ab8:	8d 81       	ldd	r24, Y+5	; 0x05
    2aba:	9e 81       	ldd	r25, Y+6	; 0x06
    2abc:	9a 83       	std	Y+2, r25	; 0x02
    2abe:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    2ac0:	89 81       	ldd	r24, Y+1	; 0x01
    2ac2:	eb 81       	ldd	r30, Y+3	; 0x03
    2ac4:	fc 81       	ldd	r31, Y+4	; 0x04
    2ac6:	80 83       	st	Z, r24
	pxTopOfStack--;
    2ac8:	8b 81       	ldd	r24, Y+3	; 0x03
    2aca:	9c 81       	ldd	r25, Y+4	; 0x04
    2acc:	01 97       	sbiw	r24, 0x01	; 1
    2ace:	9c 83       	std	Y+4, r25	; 0x04
    2ad0:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2ad2:	89 81       	ldd	r24, Y+1	; 0x01
    2ad4:	9a 81       	ldd	r25, Y+2	; 0x02
    2ad6:	89 2f       	mov	r24, r25
    2ad8:	99 27       	eor	r25, r25
    2ada:	9a 83       	std	Y+2, r25	; 0x02
    2adc:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    2ade:	89 81       	ldd	r24, Y+1	; 0x01
    2ae0:	eb 81       	ldd	r30, Y+3	; 0x03
    2ae2:	fc 81       	ldd	r31, Y+4	; 0x04
    2ae4:	80 83       	st	Z, r24
	pxTopOfStack--;
    2ae6:	8b 81       	ldd	r24, Y+3	; 0x03
    2ae8:	9c 81       	ldd	r25, Y+4	; 0x04
    2aea:	01 97       	sbiw	r24, 0x01	; 1
    2aec:	9c 83       	std	Y+4, r25	; 0x04
    2aee:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = 0;
    2af0:	eb 81       	ldd	r30, Y+3	; 0x03
    2af2:	fc 81       	ldd	r31, Y+4	; 0x04
    2af4:	10 82       	st	Z, r1
	pxTopOfStack--;
    2af6:	8b 81       	ldd	r24, Y+3	; 0x03
    2af8:	9c 81       	ldd	r25, Y+4	; 0x04
    2afa:	01 97       	sbiw	r24, 0x01	; 1
    2afc:	9c 83       	std	Y+4, r25	; 0x04
    2afe:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    2b00:	eb 81       	ldd	r30, Y+3	; 0x03
    2b02:	fc 81       	ldd	r31, Y+4	; 0x04
    2b04:	10 82       	st	Z, r1
	pxTopOfStack--;
    2b06:	8b 81       	ldd	r24, Y+3	; 0x03
    2b08:	9c 81       	ldd	r25, Y+4	; 0x04
    2b0a:	01 97       	sbiw	r24, 0x01	; 1
    2b0c:	9c 83       	std	Y+4, r25	; 0x04
    2b0e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2b10:	eb 81       	ldd	r30, Y+3	; 0x03
    2b12:	fc 81       	ldd	r31, Y+4	; 0x04
    2b14:	80 e8       	ldi	r24, 0x80	; 128
    2b16:	80 83       	st	Z, r24
	pxTopOfStack--;
    2b18:	8b 81       	ldd	r24, Y+3	; 0x03
    2b1a:	9c 81       	ldd	r25, Y+4	; 0x04
    2b1c:	01 97       	sbiw	r24, 0x01	; 1
    2b1e:	9c 83       	std	Y+4, r25	; 0x04
    2b20:	8b 83       	std	Y+3, r24	; 0x03
#if defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

	/* If we have an ATmega256x, we are also saving the RAMPZ and EIND registers.
	 * We should default those to 0.
	 */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* EIND */
    2b22:	eb 81       	ldd	r30, Y+3	; 0x03
    2b24:	fc 81       	ldd	r31, Y+4	; 0x04
    2b26:	10 82       	st	Z, r1
	pxTopOfStack--;
    2b28:	8b 81       	ldd	r24, Y+3	; 0x03
    2b2a:	9c 81       	ldd	r25, Y+4	; 0x04
    2b2c:	01 97       	sbiw	r24, 0x01	; 1
    2b2e:	9c 83       	std	Y+4, r25	; 0x04
    2b30:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* RAMPZ */
    2b32:	eb 81       	ldd	r30, Y+3	; 0x03
    2b34:	fc 81       	ldd	r31, Y+4	; 0x04
    2b36:	10 82       	st	Z, r1
	pxTopOfStack--;
    2b38:	8b 81       	ldd	r24, Y+3	; 0x03
    2b3a:	9c 81       	ldd	r25, Y+4	; 0x04
    2b3c:	01 97       	sbiw	r24, 0x01	; 1
    2b3e:	9c 83       	std	Y+4, r25	; 0x04
    2b40:	8b 83       	std	Y+3, r24	; 0x03

#endif

	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    2b42:	eb 81       	ldd	r30, Y+3	; 0x03
    2b44:	fc 81       	ldd	r31, Y+4	; 0x04
    2b46:	10 82       	st	Z, r1
	pxTopOfStack--;
    2b48:	8b 81       	ldd	r24, Y+3	; 0x03
    2b4a:	9c 81       	ldd	r25, Y+4	; 0x04
    2b4c:	01 97       	sbiw	r24, 0x01	; 1
    2b4e:	9c 83       	std	Y+4, r25	; 0x04
    2b50:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    2b52:	eb 81       	ldd	r30, Y+3	; 0x03
    2b54:	fc 81       	ldd	r31, Y+4	; 0x04
    2b56:	82 e0       	ldi	r24, 0x02	; 2
    2b58:	80 83       	st	Z, r24
	pxTopOfStack--;
    2b5a:	8b 81       	ldd	r24, Y+3	; 0x03
    2b5c:	9c 81       	ldd	r25, Y+4	; 0x04
    2b5e:	01 97       	sbiw	r24, 0x01	; 1
    2b60:	9c 83       	std	Y+4, r25	; 0x04
    2b62:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    2b64:	eb 81       	ldd	r30, Y+3	; 0x03
    2b66:	fc 81       	ldd	r31, Y+4	; 0x04
    2b68:	83 e0       	ldi	r24, 0x03	; 3
    2b6a:	80 83       	st	Z, r24
	pxTopOfStack--;
    2b6c:	8b 81       	ldd	r24, Y+3	; 0x03
    2b6e:	9c 81       	ldd	r25, Y+4	; 0x04
    2b70:	01 97       	sbiw	r24, 0x01	; 1
    2b72:	9c 83       	std	Y+4, r25	; 0x04
    2b74:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    2b76:	eb 81       	ldd	r30, Y+3	; 0x03
    2b78:	fc 81       	ldd	r31, Y+4	; 0x04
    2b7a:	84 e0       	ldi	r24, 0x04	; 4
    2b7c:	80 83       	st	Z, r24
	pxTopOfStack--;
    2b7e:	8b 81       	ldd	r24, Y+3	; 0x03
    2b80:	9c 81       	ldd	r25, Y+4	; 0x04
    2b82:	01 97       	sbiw	r24, 0x01	; 1
    2b84:	9c 83       	std	Y+4, r25	; 0x04
    2b86:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    2b88:	eb 81       	ldd	r30, Y+3	; 0x03
    2b8a:	fc 81       	ldd	r31, Y+4	; 0x04
    2b8c:	85 e0       	ldi	r24, 0x05	; 5
    2b8e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2b90:	8b 81       	ldd	r24, Y+3	; 0x03
    2b92:	9c 81       	ldd	r25, Y+4	; 0x04
    2b94:	01 97       	sbiw	r24, 0x01	; 1
    2b96:	9c 83       	std	Y+4, r25	; 0x04
    2b98:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    2b9a:	eb 81       	ldd	r30, Y+3	; 0x03
    2b9c:	fc 81       	ldd	r31, Y+4	; 0x04
    2b9e:	86 e0       	ldi	r24, 0x06	; 6
    2ba0:	80 83       	st	Z, r24
	pxTopOfStack--;
    2ba2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ba4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ba6:	01 97       	sbiw	r24, 0x01	; 1
    2ba8:	9c 83       	std	Y+4, r25	; 0x04
    2baa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    2bac:	eb 81       	ldd	r30, Y+3	; 0x03
    2bae:	fc 81       	ldd	r31, Y+4	; 0x04
    2bb0:	87 e0       	ldi	r24, 0x07	; 7
    2bb2:	80 83       	st	Z, r24
	pxTopOfStack--;
    2bb4:	8b 81       	ldd	r24, Y+3	; 0x03
    2bb6:	9c 81       	ldd	r25, Y+4	; 0x04
    2bb8:	01 97       	sbiw	r24, 0x01	; 1
    2bba:	9c 83       	std	Y+4, r25	; 0x04
    2bbc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    2bbe:	eb 81       	ldd	r30, Y+3	; 0x03
    2bc0:	fc 81       	ldd	r31, Y+4	; 0x04
    2bc2:	88 e0       	ldi	r24, 0x08	; 8
    2bc4:	80 83       	st	Z, r24
	pxTopOfStack--;
    2bc6:	8b 81       	ldd	r24, Y+3	; 0x03
    2bc8:	9c 81       	ldd	r25, Y+4	; 0x04
    2bca:	01 97       	sbiw	r24, 0x01	; 1
    2bcc:	9c 83       	std	Y+4, r25	; 0x04
    2bce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    2bd0:	eb 81       	ldd	r30, Y+3	; 0x03
    2bd2:	fc 81       	ldd	r31, Y+4	; 0x04
    2bd4:	89 e0       	ldi	r24, 0x09	; 9
    2bd6:	80 83       	st	Z, r24
	pxTopOfStack--;
    2bd8:	8b 81       	ldd	r24, Y+3	; 0x03
    2bda:	9c 81       	ldd	r25, Y+4	; 0x04
    2bdc:	01 97       	sbiw	r24, 0x01	; 1
    2bde:	9c 83       	std	Y+4, r25	; 0x04
    2be0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    2be2:	eb 81       	ldd	r30, Y+3	; 0x03
    2be4:	fc 81       	ldd	r31, Y+4	; 0x04
    2be6:	80 e1       	ldi	r24, 0x10	; 16
    2be8:	80 83       	st	Z, r24
	pxTopOfStack--;
    2bea:	8b 81       	ldd	r24, Y+3	; 0x03
    2bec:	9c 81       	ldd	r25, Y+4	; 0x04
    2bee:	01 97       	sbiw	r24, 0x01	; 1
    2bf0:	9c 83       	std	Y+4, r25	; 0x04
    2bf2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    2bf4:	eb 81       	ldd	r30, Y+3	; 0x03
    2bf6:	fc 81       	ldd	r31, Y+4	; 0x04
    2bf8:	81 e1       	ldi	r24, 0x11	; 17
    2bfa:	80 83       	st	Z, r24
	pxTopOfStack--;
    2bfc:	8b 81       	ldd	r24, Y+3	; 0x03
    2bfe:	9c 81       	ldd	r25, Y+4	; 0x04
    2c00:	01 97       	sbiw	r24, 0x01	; 1
    2c02:	9c 83       	std	Y+4, r25	; 0x04
    2c04:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    2c06:	eb 81       	ldd	r30, Y+3	; 0x03
    2c08:	fc 81       	ldd	r31, Y+4	; 0x04
    2c0a:	82 e1       	ldi	r24, 0x12	; 18
    2c0c:	80 83       	st	Z, r24
	pxTopOfStack--;
    2c0e:	8b 81       	ldd	r24, Y+3	; 0x03
    2c10:	9c 81       	ldd	r25, Y+4	; 0x04
    2c12:	01 97       	sbiw	r24, 0x01	; 1
    2c14:	9c 83       	std	Y+4, r25	; 0x04
    2c16:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    2c18:	eb 81       	ldd	r30, Y+3	; 0x03
    2c1a:	fc 81       	ldd	r31, Y+4	; 0x04
    2c1c:	83 e1       	ldi	r24, 0x13	; 19
    2c1e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2c20:	8b 81       	ldd	r24, Y+3	; 0x03
    2c22:	9c 81       	ldd	r25, Y+4	; 0x04
    2c24:	01 97       	sbiw	r24, 0x01	; 1
    2c26:	9c 83       	std	Y+4, r25	; 0x04
    2c28:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    2c2a:	eb 81       	ldd	r30, Y+3	; 0x03
    2c2c:	fc 81       	ldd	r31, Y+4	; 0x04
    2c2e:	84 e1       	ldi	r24, 0x14	; 20
    2c30:	80 83       	st	Z, r24
	pxTopOfStack--;
    2c32:	8b 81       	ldd	r24, Y+3	; 0x03
    2c34:	9c 81       	ldd	r25, Y+4	; 0x04
    2c36:	01 97       	sbiw	r24, 0x01	; 1
    2c38:	9c 83       	std	Y+4, r25	; 0x04
    2c3a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    2c3c:	eb 81       	ldd	r30, Y+3	; 0x03
    2c3e:	fc 81       	ldd	r31, Y+4	; 0x04
    2c40:	85 e1       	ldi	r24, 0x15	; 21
    2c42:	80 83       	st	Z, r24
	pxTopOfStack--;
    2c44:	8b 81       	ldd	r24, Y+3	; 0x03
    2c46:	9c 81       	ldd	r25, Y+4	; 0x04
    2c48:	01 97       	sbiw	r24, 0x01	; 1
    2c4a:	9c 83       	std	Y+4, r25	; 0x04
    2c4c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    2c4e:	eb 81       	ldd	r30, Y+3	; 0x03
    2c50:	fc 81       	ldd	r31, Y+4	; 0x04
    2c52:	86 e1       	ldi	r24, 0x16	; 22
    2c54:	80 83       	st	Z, r24
	pxTopOfStack--;
    2c56:	8b 81       	ldd	r24, Y+3	; 0x03
    2c58:	9c 81       	ldd	r25, Y+4	; 0x04
    2c5a:	01 97       	sbiw	r24, 0x01	; 1
    2c5c:	9c 83       	std	Y+4, r25	; 0x04
    2c5e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    2c60:	eb 81       	ldd	r30, Y+3	; 0x03
    2c62:	fc 81       	ldd	r31, Y+4	; 0x04
    2c64:	87 e1       	ldi	r24, 0x17	; 23
    2c66:	80 83       	st	Z, r24
	pxTopOfStack--;
    2c68:	8b 81       	ldd	r24, Y+3	; 0x03
    2c6a:	9c 81       	ldd	r25, Y+4	; 0x04
    2c6c:	01 97       	sbiw	r24, 0x01	; 1
    2c6e:	9c 83       	std	Y+4, r25	; 0x04
    2c70:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    2c72:	eb 81       	ldd	r30, Y+3	; 0x03
    2c74:	fc 81       	ldd	r31, Y+4	; 0x04
    2c76:	88 e1       	ldi	r24, 0x18	; 24
    2c78:	80 83       	st	Z, r24
	pxTopOfStack--;
    2c7a:	8b 81       	ldd	r24, Y+3	; 0x03
    2c7c:	9c 81       	ldd	r25, Y+4	; 0x04
    2c7e:	01 97       	sbiw	r24, 0x01	; 1
    2c80:	9c 83       	std	Y+4, r25	; 0x04
    2c82:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    2c84:	eb 81       	ldd	r30, Y+3	; 0x03
    2c86:	fc 81       	ldd	r31, Y+4	; 0x04
    2c88:	89 e1       	ldi	r24, 0x19	; 25
    2c8a:	80 83       	st	Z, r24
	pxTopOfStack--;
    2c8c:	8b 81       	ldd	r24, Y+3	; 0x03
    2c8e:	9c 81       	ldd	r25, Y+4	; 0x04
    2c90:	01 97       	sbiw	r24, 0x01	; 1
    2c92:	9c 83       	std	Y+4, r25	; 0x04
    2c94:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    2c96:	eb 81       	ldd	r30, Y+3	; 0x03
    2c98:	fc 81       	ldd	r31, Y+4	; 0x04
    2c9a:	80 e2       	ldi	r24, 0x20	; 32
    2c9c:	80 83       	st	Z, r24
	pxTopOfStack--;
    2c9e:	8b 81       	ldd	r24, Y+3	; 0x03
    2ca0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ca2:	01 97       	sbiw	r24, 0x01	; 1
    2ca4:	9c 83       	std	Y+4, r25	; 0x04
    2ca6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    2ca8:	eb 81       	ldd	r30, Y+3	; 0x03
    2caa:	fc 81       	ldd	r31, Y+4	; 0x04
    2cac:	81 e2       	ldi	r24, 0x21	; 33
    2cae:	80 83       	st	Z, r24
	pxTopOfStack--;
    2cb0:	8b 81       	ldd	r24, Y+3	; 0x03
    2cb2:	9c 81       	ldd	r25, Y+4	; 0x04
    2cb4:	01 97       	sbiw	r24, 0x01	; 1
    2cb6:	9c 83       	std	Y+4, r25	; 0x04
    2cb8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    2cba:	eb 81       	ldd	r30, Y+3	; 0x03
    2cbc:	fc 81       	ldd	r31, Y+4	; 0x04
    2cbe:	82 e2       	ldi	r24, 0x22	; 34
    2cc0:	80 83       	st	Z, r24
	pxTopOfStack--;
    2cc2:	8b 81       	ldd	r24, Y+3	; 0x03
    2cc4:	9c 81       	ldd	r25, Y+4	; 0x04
    2cc6:	01 97       	sbiw	r24, 0x01	; 1
    2cc8:	9c 83       	std	Y+4, r25	; 0x04
    2cca:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    2ccc:	eb 81       	ldd	r30, Y+3	; 0x03
    2cce:	fc 81       	ldd	r31, Y+4	; 0x04
    2cd0:	83 e2       	ldi	r24, 0x23	; 35
    2cd2:	80 83       	st	Z, r24
	pxTopOfStack--;
    2cd4:	8b 81       	ldd	r24, Y+3	; 0x03
    2cd6:	9c 81       	ldd	r25, Y+4	; 0x04
    2cd8:	01 97       	sbiw	r24, 0x01	; 1
    2cda:	9c 83       	std	Y+4, r25	; 0x04
    2cdc:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    2cde:	8f 81       	ldd	r24, Y+7	; 0x07
    2ce0:	98 85       	ldd	r25, Y+8	; 0x08
    2ce2:	9a 83       	std	Y+2, r25	; 0x02
    2ce4:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2ce6:	89 81       	ldd	r24, Y+1	; 0x01
    2ce8:	eb 81       	ldd	r30, Y+3	; 0x03
    2cea:	fc 81       	ldd	r31, Y+4	; 0x04
    2cec:	80 83       	st	Z, r24
	pxTopOfStack--;
    2cee:	8b 81       	ldd	r24, Y+3	; 0x03
    2cf0:	9c 81       	ldd	r25, Y+4	; 0x04
    2cf2:	01 97       	sbiw	r24, 0x01	; 1
    2cf4:	9c 83       	std	Y+4, r25	; 0x04
    2cf6:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2cf8:	89 81       	ldd	r24, Y+1	; 0x01
    2cfa:	9a 81       	ldd	r25, Y+2	; 0x02
    2cfc:	89 2f       	mov	r24, r25
    2cfe:	99 27       	eor	r25, r25
    2d00:	9a 83       	std	Y+2, r25	; 0x02
    2d02:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2d04:	89 81       	ldd	r24, Y+1	; 0x01
    2d06:	eb 81       	ldd	r30, Y+3	; 0x03
    2d08:	fc 81       	ldd	r31, Y+4	; 0x04
    2d0a:	80 83       	st	Z, r24
	pxTopOfStack--;
    2d0c:	8b 81       	ldd	r24, Y+3	; 0x03
    2d0e:	9c 81       	ldd	r25, Y+4	; 0x04
    2d10:	01 97       	sbiw	r24, 0x01	; 1
    2d12:	9c 83       	std	Y+4, r25	; 0x04
    2d14:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    2d16:	eb 81       	ldd	r30, Y+3	; 0x03
    2d18:	fc 81       	ldd	r31, Y+4	; 0x04
    2d1a:	86 e2       	ldi	r24, 0x26	; 38
    2d1c:	80 83       	st	Z, r24
	pxTopOfStack--;
    2d1e:	8b 81       	ldd	r24, Y+3	; 0x03
    2d20:	9c 81       	ldd	r25, Y+4	; 0x04
    2d22:	01 97       	sbiw	r24, 0x01	; 1
    2d24:	9c 83       	std	Y+4, r25	; 0x04
    2d26:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    2d28:	eb 81       	ldd	r30, Y+3	; 0x03
    2d2a:	fc 81       	ldd	r31, Y+4	; 0x04
    2d2c:	87 e2       	ldi	r24, 0x27	; 39
    2d2e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2d30:	8b 81       	ldd	r24, Y+3	; 0x03
    2d32:	9c 81       	ldd	r25, Y+4	; 0x04
    2d34:	01 97       	sbiw	r24, 0x01	; 1
    2d36:	9c 83       	std	Y+4, r25	; 0x04
    2d38:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    2d3a:	eb 81       	ldd	r30, Y+3	; 0x03
    2d3c:	fc 81       	ldd	r31, Y+4	; 0x04
    2d3e:	88 e2       	ldi	r24, 0x28	; 40
    2d40:	80 83       	st	Z, r24
	pxTopOfStack--;
    2d42:	8b 81       	ldd	r24, Y+3	; 0x03
    2d44:	9c 81       	ldd	r25, Y+4	; 0x04
    2d46:	01 97       	sbiw	r24, 0x01	; 1
    2d48:	9c 83       	std	Y+4, r25	; 0x04
    2d4a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    2d4c:	eb 81       	ldd	r30, Y+3	; 0x03
    2d4e:	fc 81       	ldd	r31, Y+4	; 0x04
    2d50:	89 e2       	ldi	r24, 0x29	; 41
    2d52:	80 83       	st	Z, r24
	pxTopOfStack--;
    2d54:	8b 81       	ldd	r24, Y+3	; 0x03
    2d56:	9c 81       	ldd	r25, Y+4	; 0x04
    2d58:	01 97       	sbiw	r24, 0x01	; 1
    2d5a:	9c 83       	std	Y+4, r25	; 0x04
    2d5c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    2d5e:	eb 81       	ldd	r30, Y+3	; 0x03
    2d60:	fc 81       	ldd	r31, Y+4	; 0x04
    2d62:	80 e3       	ldi	r24, 0x30	; 48
    2d64:	80 83       	st	Z, r24
	pxTopOfStack--;
    2d66:	8b 81       	ldd	r24, Y+3	; 0x03
    2d68:	9c 81       	ldd	r25, Y+4	; 0x04
    2d6a:	01 97       	sbiw	r24, 0x01	; 1
    2d6c:	9c 83       	std	Y+4, r25	; 0x04
    2d6e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    2d70:	eb 81       	ldd	r30, Y+3	; 0x03
    2d72:	fc 81       	ldd	r31, Y+4	; 0x04
    2d74:	81 e3       	ldi	r24, 0x31	; 49
    2d76:	80 83       	st	Z, r24
	pxTopOfStack--;
    2d78:	8b 81       	ldd	r24, Y+3	; 0x03
    2d7a:	9c 81       	ldd	r25, Y+4	; 0x04
    2d7c:	01 97       	sbiw	r24, 0x01	; 1
    2d7e:	9c 83       	std	Y+4, r25	; 0x04
    2d80:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    2d82:	8b 81       	ldd	r24, Y+3	; 0x03
    2d84:	9c 81       	ldd	r25, Y+4	; 0x04
}
    2d86:	28 96       	adiw	r28, 0x08	; 8
    2d88:	0f b6       	in	r0, 0x3f	; 63
    2d8a:	f8 94       	cli
    2d8c:	de bf       	out	0x3e, r29	; 62
    2d8e:	0f be       	out	0x3f, r0	; 63
    2d90:	cd bf       	out	0x3d, r28	; 61
    2d92:	cf 91       	pop	r28
    2d94:	df 91       	pop	r29
    2d96:	08 95       	ret

00002d98 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    2d98:	df 93       	push	r29
    2d9a:	cf 93       	push	r28
    2d9c:	cd b7       	in	r28, 0x3d	; 61
    2d9e:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    2da0:	0e 94 d0 17 	call	0x2fa0	; 0x2fa0 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2da4:	a0 91 1c 02 	lds	r26, 0x021C
    2da8:	b0 91 1d 02 	lds	r27, 0x021D
    2dac:	cd 91       	ld	r28, X+
    2dae:	cd bf       	out	0x3d, r28	; 61
    2db0:	dd 91       	ld	r29, X+
    2db2:	de bf       	out	0x3e, r29	; 62
    2db4:	ff 91       	pop	r31
    2db6:	ef 91       	pop	r30
    2db8:	df 91       	pop	r29
    2dba:	cf 91       	pop	r28
    2dbc:	bf 91       	pop	r27
    2dbe:	af 91       	pop	r26
    2dc0:	9f 91       	pop	r25
    2dc2:	8f 91       	pop	r24
    2dc4:	7f 91       	pop	r23
    2dc6:	6f 91       	pop	r22
    2dc8:	5f 91       	pop	r21
    2dca:	4f 91       	pop	r20
    2dcc:	3f 91       	pop	r19
    2dce:	2f 91       	pop	r18
    2dd0:	1f 91       	pop	r17
    2dd2:	0f 91       	pop	r16
    2dd4:	ff 90       	pop	r15
    2dd6:	ef 90       	pop	r14
    2dd8:	df 90       	pop	r13
    2dda:	cf 90       	pop	r12
    2ddc:	bf 90       	pop	r11
    2dde:	af 90       	pop	r10
    2de0:	9f 90       	pop	r9
    2de2:	8f 90       	pop	r8
    2de4:	7f 90       	pop	r7
    2de6:	6f 90       	pop	r6
    2de8:	5f 90       	pop	r5
    2dea:	4f 90       	pop	r4
    2dec:	3f 90       	pop	r3
    2dee:	2f 90       	pop	r2
    2df0:	1f 90       	pop	r1
    2df2:	0f 90       	pop	r0
    2df4:	0c be       	out	0x3c, r0	; 60
    2df6:	0f 90       	pop	r0
    2df8:	0b be       	out	0x3b, r0	; 59
    2dfa:	0f 90       	pop	r0
    2dfc:	0f be       	out	0x3f, r0	; 63
    2dfe:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2e00:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    2e02:	81 e0       	ldi	r24, 0x01	; 1
}
    2e04:	cf 91       	pop	r28
    2e06:	df 91       	pop	r29
    2e08:	08 95       	ret

00002e0a <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    2e0a:	df 93       	push	r29
    2e0c:	cf 93       	push	r28
    2e0e:	cd b7       	in	r28, 0x3d	; 61
    2e10:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    2e12:	cf 91       	pop	r28
    2e14:	df 91       	pop	r29
    2e16:	08 95       	ret

00002e18 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2e18:	0f 92       	push	r0
    2e1a:	0f b6       	in	r0, 0x3f	; 63
    2e1c:	f8 94       	cli
    2e1e:	0f 92       	push	r0
    2e20:	0b b6       	in	r0, 0x3b	; 59
    2e22:	0f 92       	push	r0
    2e24:	0c b6       	in	r0, 0x3c	; 60
    2e26:	0f 92       	push	r0
    2e28:	1f 92       	push	r1
    2e2a:	11 24       	eor	r1, r1
    2e2c:	2f 92       	push	r2
    2e2e:	3f 92       	push	r3
    2e30:	4f 92       	push	r4
    2e32:	5f 92       	push	r5
    2e34:	6f 92       	push	r6
    2e36:	7f 92       	push	r7
    2e38:	8f 92       	push	r8
    2e3a:	9f 92       	push	r9
    2e3c:	af 92       	push	r10
    2e3e:	bf 92       	push	r11
    2e40:	cf 92       	push	r12
    2e42:	df 92       	push	r13
    2e44:	ef 92       	push	r14
    2e46:	ff 92       	push	r15
    2e48:	0f 93       	push	r16
    2e4a:	1f 93       	push	r17
    2e4c:	2f 93       	push	r18
    2e4e:	3f 93       	push	r19
    2e50:	4f 93       	push	r20
    2e52:	5f 93       	push	r21
    2e54:	6f 93       	push	r22
    2e56:	7f 93       	push	r23
    2e58:	8f 93       	push	r24
    2e5a:	9f 93       	push	r25
    2e5c:	af 93       	push	r26
    2e5e:	bf 93       	push	r27
    2e60:	cf 93       	push	r28
    2e62:	df 93       	push	r29
    2e64:	ef 93       	push	r30
    2e66:	ff 93       	push	r31
    2e68:	a0 91 1c 02 	lds	r26, 0x021C
    2e6c:	b0 91 1d 02 	lds	r27, 0x021D
    2e70:	0d b6       	in	r0, 0x3d	; 61
    2e72:	0d 92       	st	X+, r0
    2e74:	0e b6       	in	r0, 0x3e	; 62
    2e76:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2e78:	0e 94 24 07 	call	0xe48	; 0xe48 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2e7c:	a0 91 1c 02 	lds	r26, 0x021C
    2e80:	b0 91 1d 02 	lds	r27, 0x021D
    2e84:	cd 91       	ld	r28, X+
    2e86:	cd bf       	out	0x3d, r28	; 61
    2e88:	dd 91       	ld	r29, X+
    2e8a:	de bf       	out	0x3e, r29	; 62
    2e8c:	ff 91       	pop	r31
    2e8e:	ef 91       	pop	r30
    2e90:	df 91       	pop	r29
    2e92:	cf 91       	pop	r28
    2e94:	bf 91       	pop	r27
    2e96:	af 91       	pop	r26
    2e98:	9f 91       	pop	r25
    2e9a:	8f 91       	pop	r24
    2e9c:	7f 91       	pop	r23
    2e9e:	6f 91       	pop	r22
    2ea0:	5f 91       	pop	r21
    2ea2:	4f 91       	pop	r20
    2ea4:	3f 91       	pop	r19
    2ea6:	2f 91       	pop	r18
    2ea8:	1f 91       	pop	r17
    2eaa:	0f 91       	pop	r16
    2eac:	ff 90       	pop	r15
    2eae:	ef 90       	pop	r14
    2eb0:	df 90       	pop	r13
    2eb2:	cf 90       	pop	r12
    2eb4:	bf 90       	pop	r11
    2eb6:	af 90       	pop	r10
    2eb8:	9f 90       	pop	r9
    2eba:	8f 90       	pop	r8
    2ebc:	7f 90       	pop	r7
    2ebe:	6f 90       	pop	r6
    2ec0:	5f 90       	pop	r5
    2ec2:	4f 90       	pop	r4
    2ec4:	3f 90       	pop	r3
    2ec6:	2f 90       	pop	r2
    2ec8:	1f 90       	pop	r1
    2eca:	0f 90       	pop	r0
    2ecc:	0c be       	out	0x3c, r0	; 60
    2ece:	0f 90       	pop	r0
    2ed0:	0b be       	out	0x3b, r0	; 59
    2ed2:	0f 90       	pop	r0
    2ed4:	0f be       	out	0x3f, r0	; 63
    2ed6:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2ed8:	08 95       	ret

00002eda <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2eda:	0f 92       	push	r0
    2edc:	0f b6       	in	r0, 0x3f	; 63
    2ede:	f8 94       	cli
    2ee0:	0f 92       	push	r0
    2ee2:	0b b6       	in	r0, 0x3b	; 59
    2ee4:	0f 92       	push	r0
    2ee6:	0c b6       	in	r0, 0x3c	; 60
    2ee8:	0f 92       	push	r0
    2eea:	1f 92       	push	r1
    2eec:	11 24       	eor	r1, r1
    2eee:	2f 92       	push	r2
    2ef0:	3f 92       	push	r3
    2ef2:	4f 92       	push	r4
    2ef4:	5f 92       	push	r5
    2ef6:	6f 92       	push	r6
    2ef8:	7f 92       	push	r7
    2efa:	8f 92       	push	r8
    2efc:	9f 92       	push	r9
    2efe:	af 92       	push	r10
    2f00:	bf 92       	push	r11
    2f02:	cf 92       	push	r12
    2f04:	df 92       	push	r13
    2f06:	ef 92       	push	r14
    2f08:	ff 92       	push	r15
    2f0a:	0f 93       	push	r16
    2f0c:	1f 93       	push	r17
    2f0e:	2f 93       	push	r18
    2f10:	3f 93       	push	r19
    2f12:	4f 93       	push	r20
    2f14:	5f 93       	push	r21
    2f16:	6f 93       	push	r22
    2f18:	7f 93       	push	r23
    2f1a:	8f 93       	push	r24
    2f1c:	9f 93       	push	r25
    2f1e:	af 93       	push	r26
    2f20:	bf 93       	push	r27
    2f22:	cf 93       	push	r28
    2f24:	df 93       	push	r29
    2f26:	ef 93       	push	r30
    2f28:	ff 93       	push	r31
    2f2a:	a0 91 1c 02 	lds	r26, 0x021C
    2f2e:	b0 91 1d 02 	lds	r27, 0x021D
    2f32:	0d b6       	in	r0, 0x3d	; 61
    2f34:	0d 92       	st	X+, r0
    2f36:	0e b6       	in	r0, 0x3e	; 62
    2f38:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    2f3a:	0e 94 50 06 	call	0xca0	; 0xca0 <vTaskIncrementTick>
	vTaskSwitchContext();
    2f3e:	0e 94 24 07 	call	0xe48	; 0xe48 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2f42:	a0 91 1c 02 	lds	r26, 0x021C
    2f46:	b0 91 1d 02 	lds	r27, 0x021D
    2f4a:	cd 91       	ld	r28, X+
    2f4c:	cd bf       	out	0x3d, r28	; 61
    2f4e:	dd 91       	ld	r29, X+
    2f50:	de bf       	out	0x3e, r29	; 62
    2f52:	ff 91       	pop	r31
    2f54:	ef 91       	pop	r30
    2f56:	df 91       	pop	r29
    2f58:	cf 91       	pop	r28
    2f5a:	bf 91       	pop	r27
    2f5c:	af 91       	pop	r26
    2f5e:	9f 91       	pop	r25
    2f60:	8f 91       	pop	r24
    2f62:	7f 91       	pop	r23
    2f64:	6f 91       	pop	r22
    2f66:	5f 91       	pop	r21
    2f68:	4f 91       	pop	r20
    2f6a:	3f 91       	pop	r19
    2f6c:	2f 91       	pop	r18
    2f6e:	1f 91       	pop	r17
    2f70:	0f 91       	pop	r16
    2f72:	ff 90       	pop	r15
    2f74:	ef 90       	pop	r14
    2f76:	df 90       	pop	r13
    2f78:	cf 90       	pop	r12
    2f7a:	bf 90       	pop	r11
    2f7c:	af 90       	pop	r10
    2f7e:	9f 90       	pop	r9
    2f80:	8f 90       	pop	r8
    2f82:	7f 90       	pop	r7
    2f84:	6f 90       	pop	r6
    2f86:	5f 90       	pop	r5
    2f88:	4f 90       	pop	r4
    2f8a:	3f 90       	pop	r3
    2f8c:	2f 90       	pop	r2
    2f8e:	1f 90       	pop	r1
    2f90:	0f 90       	pop	r0
    2f92:	0c be       	out	0x3c, r0	; 60
    2f94:	0f 90       	pop	r0
    2f96:	0b be       	out	0x3b, r0	; 59
    2f98:	0f 90       	pop	r0
    2f9a:	0f be       	out	0x3f, r0	; 63
    2f9c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2f9e:	08 95       	ret

00002fa0 <prvSetupTimerInterrupt>:

/*
 * Setup timer 0 or 3 or 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    2fa0:	df 93       	push	r29
    2fa2:	cf 93       	push	r28
    2fa4:	00 d0       	rcall	.+0      	; 0x2fa6 <prvSetupTimerInterrupt+0x6>
    2fa6:	00 d0       	rcall	.+0      	; 0x2fa8 <prvSetupTimerInterrupt+0x8>
    2fa8:	cd b7       	in	r28, 0x3d	; 61
    2faa:	de b7       	in	r29, 0x3e	; 62

    /* Using 8bit Timer0 or 16bit Timer1 or Timer3 to generate the tick. */

    // ulCompareMatch 40,000 = 20,000,000 / 500; 20MHz
    // ulCompareMatch 110,592 = 22,118,400 / 200; 22.1184 MHz
    ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    2fac:	80 e0       	ldi	r24, 0x00	; 0
    2fae:	9d e7       	ldi	r25, 0x7D	; 125
    2fb0:	a0 e0       	ldi	r26, 0x00	; 0
    2fb2:	b0 e0       	ldi	r27, 0x00	; 0
    2fb4:	8b 83       	std	Y+3, r24	; 0x03
    2fb6:	9c 83       	std	Y+4, r25	; 0x04
    2fb8:	ad 83       	std	Y+5, r26	; 0x05
    2fba:	be 83       	std	Y+6, r27	; 0x06

    /* We only have 8 or 16 bits so have to scale 64 or 256 to get our required tick rate. */
    //ulCompareMatch = 625 /= portCLOCK_PRESCALER; 20MHz with 64 prescale
    //ulCompareMatch = 108 /= portCLOCK_PRESCALER; 22.1184 MHz with 1024 prescale
    ulCompareMatch /= portCLOCK_PRESCALER;
    2fbc:	8b 81       	ldd	r24, Y+3	; 0x03
    2fbe:	9c 81       	ldd	r25, Y+4	; 0x04
    2fc0:	ad 81       	ldd	r26, Y+5	; 0x05
    2fc2:	be 81       	ldd	r27, Y+6	; 0x06
    2fc4:	68 94       	set
    2fc6:	15 f8       	bld	r1, 5
    2fc8:	b6 95       	lsr	r27
    2fca:	a7 95       	ror	r26
    2fcc:	97 95       	ror	r25
    2fce:	87 95       	ror	r24
    2fd0:	16 94       	lsr	r1
    2fd2:	d1 f7       	brne	.-12     	; 0x2fc8 <prvSetupTimerInterrupt+0x28>
    2fd4:	8b 83       	std	Y+3, r24	; 0x03
    2fd6:	9c 83       	std	Y+4, r25	; 0x04
    2fd8:	ad 83       	std	Y+5, r26	; 0x05
    2fda:	be 83       	std	Y+6, r27	; 0x06

    /* Adjust for correct value. */
    ulCompareMatch -= ( unsigned portLONG ) 1;
    2fdc:	8b 81       	ldd	r24, Y+3	; 0x03
    2fde:	9c 81       	ldd	r25, Y+4	; 0x04
    2fe0:	ad 81       	ldd	r26, Y+5	; 0x05
    2fe2:	be 81       	ldd	r27, Y+6	; 0x06
    2fe4:	01 97       	sbiw	r24, 0x01	; 1
    2fe6:	a1 09       	sbc	r26, r1
    2fe8:	b1 09       	sbc	r27, r1
    2fea:	8b 83       	std	Y+3, r24	; 0x03
    2fec:	9c 83       	std	Y+4, r25	; 0x04
    2fee:	ad 83       	std	Y+5, r26	; 0x05
    2ff0:	be 83       	std	Y+6, r27	; 0x06

    /* Setup compare match value for compare match A.  Interrupts are disabled
    before this is called so we need not worry here. */
    ucLowByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
    2ff2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ff4:	89 83       	std	Y+1, r24	; 0x01
    //  OCR3AL = ucLowByte;

    // the HiByte is only needed, if a 16 Bit counter is being utilized
#ifdef portOCRH

    ulCompareMatch >>= 8;
    2ff6:	8b 81       	ldd	r24, Y+3	; 0x03
    2ff8:	9c 81       	ldd	r25, Y+4	; 0x04
    2ffa:	ad 81       	ldd	r26, Y+5	; 0x05
    2ffc:	be 81       	ldd	r27, Y+6	; 0x06
    2ffe:	89 2f       	mov	r24, r25
    3000:	9a 2f       	mov	r25, r26
    3002:	ab 2f       	mov	r26, r27
    3004:	bb 27       	eor	r27, r27
    3006:	8b 83       	std	Y+3, r24	; 0x03
    3008:	9c 83       	std	Y+4, r25	; 0x04
    300a:	ad 83       	std	Y+5, r26	; 0x05
    300c:	be 83       	std	Y+6, r27	; 0x06
    ucHighByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
    300e:	8b 81       	ldd	r24, Y+3	; 0x03
    3010:	8a 83       	std	Y+2, r24	; 0x02
    portOCRH = ucHighByte;
    3012:	e9 e9       	ldi	r30, 0x99	; 153
    3014:	f0 e0       	ldi	r31, 0x00	; 0
    3016:	8a 81       	ldd	r24, Y+2	; 0x02
    3018:	80 83       	st	Z, r24

#endif

    portOCRL = ucLowByte;
    301a:	e8 e9       	ldi	r30, 0x98	; 152
    301c:	f0 e0       	ldi	r31, 0x00	; 0
    301e:	89 81       	ldd	r24, Y+1	; 0x01
    3020:	80 83       	st	Z, r24
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	portTCCRb = ucLowByte;

#elif defined( portUSE_TIMER3 )
	/* Setup clock source and compare match behaviour. Assuming  640 / 1280 /1281 / 1284p / 2560 / 2561 (with Timer3) */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    3022:	8b e0       	ldi	r24, 0x0B	; 11
    3024:	89 83       	std	Y+1, r24	; 0x01
	portTCCRb = ucLowByte;
    3026:	e1 e9       	ldi	r30, 0x91	; 145
    3028:	f0 e0       	ldi	r31, 0x00	; 0
    302a:	89 81       	ldd	r24, Y+1	; 0x01
    302c:	80 83       	st	Z, r24
#endif

    /* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
    ucLowByte = portTIMSK;
    302e:	e1 e7       	ldi	r30, 0x71	; 113
    3030:	f0 e0       	ldi	r31, 0x00	; 0
    3032:	80 81       	ld	r24, Z
    3034:	89 83       	std	Y+1, r24	; 0x01
    ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    3036:	89 81       	ldd	r24, Y+1	; 0x01
    3038:	82 60       	ori	r24, 0x02	; 2
    303a:	89 83       	std	Y+1, r24	; 0x01
    portTIMSK = ucLowByte;
    303c:	e1 e7       	ldi	r30, 0x71	; 113
    303e:	f0 e0       	ldi	r31, 0x00	; 0
    3040:	89 81       	ldd	r24, Y+1	; 0x01
    3042:	80 83       	st	Z, r24

}
    3044:	26 96       	adiw	r28, 0x06	; 6
    3046:	0f b6       	in	r0, 0x3f	; 63
    3048:	f8 94       	cli
    304a:	de bf       	out	0x3e, r29	; 62
    304c:	0f be       	out	0x3f, r0	; 63
    304e:	cd bf       	out	0x3d, r28	; 61
    3050:	cf 91       	pop	r28
    3052:	df 91       	pop	r29
    3054:	08 95       	ret

00003056 <__vector_32>:

	#elif defined( portUSE_TIMER3 )
		#warning "Timer3 used for PRE-EMPTIVE scheduler."
		ISR(TIMER3_COMPA_vect, ISR_NAKED)
		{
			vPortYieldFromTick();
    3056:	0e 94 6d 17 	call	0x2eda	; 0x2eda <vPortYieldFromTick>
			asm volatile ( "reti" );
    305a:	18 95       	reti

0000305c <USART_Init>:
*  the specified baud rate and clk speed.
*
* Param buadin: The desired Baud rate.
* Param clk_seedin: The clk speed of the ATmega328p
************************************/
void USART_Init(uint16_t baudin, uint32_t clk_speedin) {
    305c:	ef 92       	push	r14
    305e:	ff 92       	push	r15
    3060:	0f 93       	push	r16
    3062:	1f 93       	push	r17
    3064:	df 93       	push	r29
    3066:	cf 93       	push	r28
    3068:	cd b7       	in	r28, 0x3d	; 61
    306a:	de b7       	in	r29, 0x3e	; 62
    306c:	2a 97       	sbiw	r28, 0x0a	; 10
    306e:	0f b6       	in	r0, 0x3f	; 63
    3070:	f8 94       	cli
    3072:	de bf       	out	0x3e, r29	; 62
    3074:	0f be       	out	0x3f, r0	; 63
    3076:	cd bf       	out	0x3d, r28	; 61
    3078:	9e 83       	std	Y+6, r25	; 0x06
    307a:	8d 83       	std	Y+5, r24	; 0x05
    307c:	4f 83       	std	Y+7, r20	; 0x07
    307e:	58 87       	std	Y+8, r21	; 0x08
    3080:	69 87       	std	Y+9, r22	; 0x09
    3082:	7a 87       	std	Y+10, r23	; 0x0a
    USART_WriteQueue = xQueueCreate(32,sizeof(uint8_t));
    3084:	80 e2       	ldi	r24, 0x20	; 32
    3086:	61 e0       	ldi	r22, 0x01	; 1
    3088:	40 e0       	ldi	r20, 0x00	; 0
    308a:	0e 94 f8 0b 	call	0x17f0	; 0x17f0 <xQueueGenericCreate>
    308e:	90 93 b7 1a 	sts	0x1AB7, r25
    3092:	80 93 b6 1a 	sts	0x1AB6, r24
    USART_ReadQueue = xQueueCreate(8,sizeof(uint8_t));
    3096:	88 e0       	ldi	r24, 0x08	; 8
    3098:	61 e0       	ldi	r22, 0x01	; 1
    309a:	40 e0       	ldi	r20, 0x00	; 0
    309c:	0e 94 f8 0b 	call	0x17f0	; 0x17f0 <xQueueGenericCreate>
    30a0:	90 93 b5 1a 	sts	0x1AB5, r25
    30a4:	80 93 b4 1a 	sts	0x1AB4, r24

    uint32_t ubrr = clk_speedin/(16UL)/baudin-1;
    30a8:	8f 81       	ldd	r24, Y+7	; 0x07
    30aa:	98 85       	ldd	r25, Y+8	; 0x08
    30ac:	a9 85       	ldd	r26, Y+9	; 0x09
    30ae:	ba 85       	ldd	r27, Y+10	; 0x0a
    30b0:	7c 01       	movw	r14, r24
    30b2:	8d 01       	movw	r16, r26
    30b4:	68 94       	set
    30b6:	13 f8       	bld	r1, 3
    30b8:	16 95       	lsr	r17
    30ba:	07 95       	ror	r16
    30bc:	f7 94       	ror	r15
    30be:	e7 94       	ror	r14
    30c0:	16 94       	lsr	r1
    30c2:	d1 f7       	brne	.-12     	; 0x30b8 <USART_Init+0x5c>
    30c4:	8d 81       	ldd	r24, Y+5	; 0x05
    30c6:	9e 81       	ldd	r25, Y+6	; 0x06
    30c8:	9c 01       	movw	r18, r24
    30ca:	40 e0       	ldi	r20, 0x00	; 0
    30cc:	50 e0       	ldi	r21, 0x00	; 0
    30ce:	c8 01       	movw	r24, r16
    30d0:	b7 01       	movw	r22, r14
    30d2:	0e 94 c3 1e 	call	0x3d86	; 0x3d86 <__udivmodsi4>
    30d6:	da 01       	movw	r26, r20
    30d8:	c9 01       	movw	r24, r18
    30da:	01 97       	sbiw	r24, 0x01	; 1
    30dc:	a1 09       	sbc	r26, r1
    30de:	b1 09       	sbc	r27, r1
    30e0:	89 83       	std	Y+1, r24	; 0x01
    30e2:	9a 83       	std	Y+2, r25	; 0x02
    30e4:	ab 83       	std	Y+3, r26	; 0x03
    30e6:	bc 83       	std	Y+4, r27	; 0x04
    UBRR0H = (unsigned char)(ubrr>>8) ;// & 0x7F;
    30e8:	e5 ec       	ldi	r30, 0xC5	; 197
    30ea:	f0 e0       	ldi	r31, 0x00	; 0
    30ec:	89 81       	ldd	r24, Y+1	; 0x01
    30ee:	9a 81       	ldd	r25, Y+2	; 0x02
    30f0:	ab 81       	ldd	r26, Y+3	; 0x03
    30f2:	bc 81       	ldd	r27, Y+4	; 0x04
    30f4:	89 2f       	mov	r24, r25
    30f6:	9a 2f       	mov	r25, r26
    30f8:	ab 2f       	mov	r26, r27
    30fa:	bb 27       	eor	r27, r27
    30fc:	80 83       	st	Z, r24
    UBRR0L = (unsigned char)ubrr;
    30fe:	e4 ec       	ldi	r30, 0xC4	; 196
    3100:	f0 e0       	ldi	r31, 0x00	; 0
    3102:	89 81       	ldd	r24, Y+1	; 0x01
    3104:	80 83       	st	Z, r24
    
    //UBRR0H = 0; //115200
    //UBRR0L = 8;

    /* Enable receiver and transmitter */
    UCSR0B = (1<<RXEN0)|(1<<TXEN0);
    3106:	e1 ec       	ldi	r30, 0xC1	; 193
    3108:	f0 e0       	ldi	r31, 0x00	; 0
    310a:	88 e1       	ldi	r24, 0x18	; 24
    310c:	80 83       	st	Z, r24
    /* Set frame format: 8data, 1stop bit */
    UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);
    310e:	e2 ec       	ldi	r30, 0xC2	; 194
    3110:	f0 e0       	ldi	r31, 0x00	; 0
    3112:	86 e0       	ldi	r24, 0x06	; 6
    3114:	80 83       	st	Z, r24
	// clear U2X0 for Synchronous operation
    UCSR0A &= ~(1<<U2X0);
    3116:	a0 ec       	ldi	r26, 0xC0	; 192
    3118:	b0 e0       	ldi	r27, 0x00	; 0
    311a:	e0 ec       	ldi	r30, 0xC0	; 192
    311c:	f0 e0       	ldi	r31, 0x00	; 0
    311e:	80 81       	ld	r24, Z
    3120:	8d 7f       	andi	r24, 0xFD	; 253
    3122:	8c 93       	st	X, r24

    //UCSR0B |= (1<<UDRIE0);

}
    3124:	2a 96       	adiw	r28, 0x0a	; 10
    3126:	0f b6       	in	r0, 0x3f	; 63
    3128:	f8 94       	cli
    312a:	de bf       	out	0x3e, r29	; 62
    312c:	0f be       	out	0x3f, r0	; 63
    312e:	cd bf       	out	0x3d, r28	; 61
    3130:	cf 91       	pop	r28
    3132:	df 91       	pop	r29
    3134:	1f 91       	pop	r17
    3136:	0f 91       	pop	r16
    3138:	ff 90       	pop	r15
    313a:	ef 90       	pop	r14
    313c:	08 95       	ret

0000313e <USART_Write>:

/*the send function will put 8bits on the trans line. */
void USART_Write(uint8_t data) {
    313e:	df 93       	push	r29
    3140:	cf 93       	push	r28
    3142:	0f 92       	push	r0
    3144:	cd b7       	in	r28, 0x3d	; 61
    3146:	de b7       	in	r29, 0x3e	; 62
    3148:	89 83       	std	Y+1, r24	; 0x01
		/* Wait for empty transmit buffer */
		while ( !( UCSR0A & (1<<UDRE0)) )
    314a:	e0 ec       	ldi	r30, 0xC0	; 192
    314c:	f0 e0       	ldi	r31, 0x00	; 0
    314e:	80 81       	ld	r24, Z
    3150:	88 2f       	mov	r24, r24
    3152:	90 e0       	ldi	r25, 0x00	; 0
    3154:	80 72       	andi	r24, 0x20	; 32
    3156:	90 70       	andi	r25, 0x00	; 0
    3158:	00 97       	sbiw	r24, 0x00	; 0
    315a:	b9 f3       	breq	.-18     	; 0x314a <USART_Write+0xc>
		;
		/* Put data into buffer, sends the data */
		UDR0 = data;
    315c:	e6 ec       	ldi	r30, 0xC6	; 198
    315e:	f0 e0       	ldi	r31, 0x00	; 0
    3160:	89 81       	ldd	r24, Y+1	; 0x01
    3162:	80 83       	st	Z, r24
}
    3164:	0f 90       	pop	r0
    3166:	cf 91       	pop	r28
    3168:	df 91       	pop	r29
    316a:	08 95       	ret

0000316c <USART_Write_Unprotected>:

/*the send function will put 8bits on the trans line. */
void USART_Write_Unprotected(uint8_t data) {
    316c:	df 93       	push	r29
    316e:	cf 93       	push	r28
    3170:	0f 92       	push	r0
    3172:	cd b7       	in	r28, 0x3d	; 61
    3174:	de b7       	in	r29, 0x3e	; 62
    3176:	89 83       	std	Y+1, r24	; 0x01
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)) )
    3178:	e0 ec       	ldi	r30, 0xC0	; 192
    317a:	f0 e0       	ldi	r31, 0x00	; 0
    317c:	80 81       	ld	r24, Z
    317e:	88 2f       	mov	r24, r24
    3180:	90 e0       	ldi	r25, 0x00	; 0
    3182:	80 72       	andi	r24, 0x20	; 32
    3184:	90 70       	andi	r25, 0x00	; 0
    3186:	00 97       	sbiw	r24, 0x00	; 0
    3188:	b9 f3       	breq	.-18     	; 0x3178 <USART_Write_Unprotected+0xc>
	;
	/* Put data into buffer, sends the data */
	UDR0 = data;
    318a:	e6 ec       	ldi	r30, 0xC6	; 198
    318c:	f0 e0       	ldi	r31, 0x00	; 0
    318e:	89 81       	ldd	r24, Y+1	; 0x01
    3190:	80 83       	st	Z, r24
}
    3192:	0f 90       	pop	r0
    3194:	cf 91       	pop	r28
    3196:	df 91       	pop	r29
    3198:	08 95       	ret

0000319a <USART_Read>:
Therefore you may not get control back after this is called 
until a much later time. It may be helpful to use the 
istheredata() function to check before calling this function
        @return 8bit data packet from sender
*/
uint8_t USART_Read(void) {
    319a:	df 93       	push	r29
    319c:	cf 93       	push	r28
    319e:	cd b7       	in	r28, 0x3d	; 61
    31a0:	de b7       	in	r29, 0x3e	; 62
    /* Wait for data to be received */
    while ( !(UCSR0A & (1<<RXC0)) )
    31a2:	e0 ec       	ldi	r30, 0xC0	; 192
    31a4:	f0 e0       	ldi	r31, 0x00	; 0
    31a6:	80 81       	ld	r24, Z
    31a8:	88 23       	and	r24, r24
    31aa:	dc f7       	brge	.-10     	; 0x31a2 <USART_Read+0x8>
        ;
    /* Get and return received data from buffer */
    return UDR0;
    31ac:	e6 ec       	ldi	r30, 0xC6	; 198
    31ae:	f0 e0       	ldi	r31, 0x00	; 0
    31b0:	80 81       	ld	r24, Z
}
    31b2:	cf 91       	pop	r28
    31b4:	df 91       	pop	r29
    31b6:	08 95       	ret

000031b8 <ISR>:


ISR(USART0_RX_vect){
    31b8:	df 93       	push	r29
    31ba:	cf 93       	push	r28
    31bc:	00 d0       	rcall	.+0      	; 0x31be <ISR+0x6>
    31be:	0f 92       	push	r0
    31c0:	0f 92       	push	r0
    31c2:	cd b7       	in	r28, 0x3d	; 61
    31c4:	de b7       	in	r29, 0x3e	; 62
    31c6:	9b 83       	std	Y+3, r25	; 0x03
    31c8:	8a 83       	std	Y+2, r24	; 0x02
    uint8_t data;
    data = UDR0;
    31ca:	e6 ec       	ldi	r30, 0xC6	; 198
    31cc:	f0 e0       	ldi	r31, 0x00	; 0
    31ce:	80 81       	ld	r24, Z
    31d0:	89 83       	std	Y+1, r24	; 0x01
    xQueueSendToBackFromISR(USART_ReadQueue,&data,NULL);
    31d2:	80 91 b4 1a 	lds	r24, 0x1AB4
    31d6:	90 91 b5 1a 	lds	r25, 0x1AB5
    31da:	9e 01       	movw	r18, r28
    31dc:	2f 5f       	subi	r18, 0xFF	; 255
    31de:	3f 4f       	sbci	r19, 0xFF	; 255
    31e0:	b9 01       	movw	r22, r18
    31e2:	40 e0       	ldi	r20, 0x00	; 0
    31e4:	50 e0       	ldi	r21, 0x00	; 0
    31e6:	20 e0       	ldi	r18, 0x00	; 0
    31e8:	0e 94 40 0d 	call	0x1a80	; 0x1a80 <xQueueGenericSendFromISR>
}
    31ec:	0f 90       	pop	r0
    31ee:	0f 90       	pop	r0
    31f0:	0f 90       	pop	r0
    31f2:	0f 90       	pop	r0
    31f4:	0f 90       	pop	r0
    31f6:	cf 91       	pop	r28
    31f8:	df 91       	pop	r29
    31fa:	08 95       	ret

000031fc <USART_AddToQueue>:

void USART_AddToQueue(uint8_t data){
    31fc:	df 93       	push	r29
    31fe:	cf 93       	push	r28
    3200:	0f 92       	push	r0
    3202:	cd b7       	in	r28, 0x3d	; 61
    3204:	de b7       	in	r29, 0x3e	; 62
    3206:	89 83       	std	Y+1, r24	; 0x01
    
    xQueueSendToBack(USART_WriteQueue,&data,portMAX_DELAY);
    3208:	80 91 b6 1a 	lds	r24, 0x1AB6
    320c:	90 91 b7 1a 	lds	r25, 0x1AB7
    3210:	9e 01       	movw	r18, r28
    3212:	2f 5f       	subi	r18, 0xFF	; 255
    3214:	3f 4f       	sbci	r19, 0xFF	; 255
    3216:	b9 01       	movw	r22, r18
    3218:	4f ef       	ldi	r20, 0xFF	; 255
    321a:	5f ef       	ldi	r21, 0xFF	; 255
    321c:	20 e0       	ldi	r18, 0x00	; 0
    321e:	0e 94 a2 0c 	call	0x1944	; 0x1944 <xQueueGenericSend>

}
    3222:	0f 90       	pop	r0
    3224:	cf 91       	pop	r28
    3226:	df 91       	pop	r29
    3228:	08 95       	ret

0000322a <USART_TransmitString>:

void USART_TransmitString(char* str){
    322a:	df 93       	push	r29
    322c:	cf 93       	push	r28
    322e:	0f 92       	push	r0
    3230:	0f 92       	push	r0
    3232:	cd b7       	in	r28, 0x3d	; 61
    3234:	de b7       	in	r29, 0x3e	; 62
    3236:	9a 83       	std	Y+2, r25	; 0x02
    3238:	89 83       	std	Y+1, r24	; 0x01
    323a:	0a c0       	rjmp	.+20     	; 0x3250 <USART_TransmitString+0x26>
    while(*str) {
        USART_AddToQueue(*str);
    323c:	e9 81       	ldd	r30, Y+1	; 0x01
    323e:	fa 81       	ldd	r31, Y+2	; 0x02
    3240:	80 81       	ld	r24, Z
    3242:	0e 94 fe 18 	call	0x31fc	; 0x31fc <USART_AddToQueue>
        str++;
    3246:	89 81       	ldd	r24, Y+1	; 0x01
    3248:	9a 81       	ldd	r25, Y+2	; 0x02
    324a:	01 96       	adiw	r24, 0x01	; 1
    324c:	9a 83       	std	Y+2, r25	; 0x02
    324e:	89 83       	std	Y+1, r24	; 0x01
    xQueueSendToBack(USART_WriteQueue,&data,portMAX_DELAY);

}

void USART_TransmitString(char* str){
    while(*str) {
    3250:	e9 81       	ldd	r30, Y+1	; 0x01
    3252:	fa 81       	ldd	r31, Y+2	; 0x02
    3254:	80 81       	ld	r24, Z
    3256:	88 23       	and	r24, r24
    3258:	89 f7       	brne	.-30     	; 0x323c <USART_TransmitString+0x12>
        USART_AddToQueue(*str);
        str++;
    }
}
    325a:	0f 90       	pop	r0
    325c:	0f 90       	pop	r0
    325e:	cf 91       	pop	r28
    3260:	df 91       	pop	r29
    3262:	08 95       	ret

00003264 <vTaskUARTWrite>:

void vTaskUARTWrite(void *pvParameters)
{
    3264:	df 93       	push	r29
    3266:	cf 93       	push	r28
    3268:	00 d0       	rcall	.+0      	; 0x326a <vTaskUARTWrite+0x6>
    326a:	cd b7       	in	r28, 0x3d	; 61
    326c:	de b7       	in	r29, 0x3e	; 62
    326e:	9b 83       	std	Y+3, r25	; 0x03
    3270:	8a 83       	std	Y+2, r24	; 0x02
    uint8_t data;
    while(1){
        while(xQueueReceive(USART_WriteQueue,&data,portMAX_DELAY)==pdFALSE);
    3272:	80 91 b6 1a 	lds	r24, 0x1AB6
    3276:	90 91 b7 1a 	lds	r25, 0x1AB7
    327a:	9e 01       	movw	r18, r28
    327c:	2f 5f       	subi	r18, 0xFF	; 255
    327e:	3f 4f       	sbci	r19, 0xFF	; 255
    3280:	b9 01       	movw	r22, r18
    3282:	4f ef       	ldi	r20, 0xFF	; 255
    3284:	5f ef       	ldi	r21, 0xFF	; 255
    3286:	20 e0       	ldi	r18, 0x00	; 0
    3288:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <xQueueGenericReceive>
    328c:	88 23       	and	r24, r24
    328e:	89 f3       	breq	.-30     	; 0x3272 <vTaskUARTWrite+0xe>
    3290:	04 c0       	rjmp	.+8      	; 0x329a <vTaskUARTWrite+0x36>

        while(!(UCSR0A & (1<<UDRE0))) vTaskDelay(1);
    3292:	81 e0       	ldi	r24, 0x01	; 1
    3294:	90 e0       	ldi	r25, 0x00	; 0
    3296:	0e 94 ae 03 	call	0x75c	; 0x75c <vTaskDelay>
    329a:	e0 ec       	ldi	r30, 0xC0	; 192
    329c:	f0 e0       	ldi	r31, 0x00	; 0
    329e:	80 81       	ld	r24, Z
    32a0:	88 2f       	mov	r24, r24
    32a2:	90 e0       	ldi	r25, 0x00	; 0
    32a4:	80 72       	andi	r24, 0x20	; 32
    32a6:	90 70       	andi	r25, 0x00	; 0
    32a8:	00 97       	sbiw	r24, 0x00	; 0
    32aa:	99 f3       	breq	.-26     	; 0x3292 <vTaskUARTWrite+0x2e>
        UDR0 = data;
    32ac:	e6 ec       	ldi	r30, 0xC6	; 198
    32ae:	f0 e0       	ldi	r31, 0x00	; 0
    32b0:	89 81       	ldd	r24, Y+1	; 0x01
    32b2:	80 83       	st	Z, r24
    32b4:	de cf       	rjmp	.-68     	; 0x3272 <vTaskUARTWrite+0xe>

000032b6 <vTaskUARTRead>:

    }
}

void vTaskUARTRead(void *pvParameters){
    32b6:	df 93       	push	r29
    32b8:	cf 93       	push	r28
    32ba:	cd b7       	in	r28, 0x3d	; 61
    32bc:	de b7       	in	r29, 0x3e	; 62
    32be:	c5 55       	subi	r28, 0x55	; 85
    32c0:	d0 40       	sbci	r29, 0x00	; 0
    32c2:	0f b6       	in	r0, 0x3f	; 63
    32c4:	f8 94       	cli
    32c6:	de bf       	out	0x3e, r29	; 62
    32c8:	0f be       	out	0x3f, r0	; 63
    32ca:	cd bf       	out	0x3d, r28	; 61
    32cc:	fe 01       	movw	r30, r28
    32ce:	ec 5a       	subi	r30, 0xAC	; 172
    32d0:	ff 4f       	sbci	r31, 0xFF	; 255
    32d2:	91 83       	std	Z+1, r25	; 0x01
    32d4:	80 83       	st	Z, r24
    Command command;
    Response response;

    while(1){
        //Get Header
        bytesRecieved = 0;
    32d6:	1e 82       	std	Y+6, r1	; 0x06
    32d8:	1c c0       	rjmp	.+56     	; 0x3312 <vTaskUARTRead+0x5c>
        while(bytesRecieved < 4){
            if((UCSR1A & (1<<RXC1))){
    32da:	e8 ec       	ldi	r30, 0xC8	; 200
    32dc:	f0 e0       	ldi	r31, 0x00	; 0
    32de:	80 81       	ld	r24, Z
    32e0:	88 23       	and	r24, r24
    32e2:	bc f4       	brge	.+46     	; 0x3312 <vTaskUARTRead+0x5c>
                rxData = UDR1;
    32e4:	ee ec       	ldi	r30, 0xCE	; 206
    32e6:	f0 e0       	ldi	r31, 0x00	; 0
    32e8:	80 81       	ld	r24, Z
    32ea:	8d 83       	std	Y+5, r24	; 0x05
                PORTB = 0xFF;
    32ec:	e5 e2       	ldi	r30, 0x25	; 37
    32ee:	f0 e0       	ldi	r31, 0x00	; 0
    32f0:	8f ef       	ldi	r24, 0xFF	; 255
    32f2:	80 83       	st	Z, r24
            //if(xQueueReceive(USART_ReadQueue,&rxData,portMAX_DELAY) == pdTRUE){
                buffer[bytesRecieved] = rxData;
    32f4:	8e 81       	ldd	r24, Y+6	; 0x06
    32f6:	28 2f       	mov	r18, r24
    32f8:	33 27       	eor	r19, r19
    32fa:	27 fd       	sbrc	r18, 7
    32fc:	30 95       	com	r19
    32fe:	ce 01       	movw	r24, r28
    3300:	07 96       	adiw	r24, 0x07	; 7
    3302:	fc 01       	movw	r30, r24
    3304:	e2 0f       	add	r30, r18
    3306:	f3 1f       	adc	r31, r19
    3308:	8d 81       	ldd	r24, Y+5	; 0x05
    330a:	80 83       	st	Z, r24
                //USART_AddToQueue(rxData);
                bytesRecieved++;
    330c:	8e 81       	ldd	r24, Y+6	; 0x06
    330e:	8f 5f       	subi	r24, 0xFF	; 255
    3310:	8e 83       	std	Y+6, r24	; 0x06
    Response response;

    while(1){
        //Get Header
        bytesRecieved = 0;
        while(bytesRecieved < 4){
    3312:	8e 81       	ldd	r24, Y+6	; 0x06
    3314:	84 30       	cpi	r24, 0x04	; 4
    3316:	0c f3       	brlt	.-62     	; 0x32da <vTaskUARTRead+0x24>
                buffer[bytesRecieved] = rxData;
                //USART_AddToQueue(rxData);
                bytesRecieved++;
            }
        }
        if(calcChecksum(buffer,3) != buffer[3]){
    3318:	ce 01       	movw	r24, r28
    331a:	07 96       	adiw	r24, 0x07	; 7
    331c:	63 e0       	ldi	r22, 0x03	; 3
    331e:	0e 94 d9 19 	call	0x33b2	; 0x33b2 <calcChecksum>
    3322:	98 2f       	mov	r25, r24
    3324:	8a 85       	ldd	r24, Y+10	; 0x0a
    3326:	98 17       	cp	r25, r24
    3328:	19 f0       	breq	.+6      	; 0x3330 <vTaskUARTRead+0x7a>
            while(1) sendNACK();
    332a:	0e 94 cf 19 	call	0x339e	; 0x339e <sendNACK>
    332e:	fd cf       	rjmp	.-6      	; 0x332a <vTaskUARTRead+0x74>
        } else {
            while(1) sendACK();
    3330:	0e 94 c5 19 	call	0x338a	; 0x338a <sendACK>
    3334:	fd cf       	rjmp	.-6      	; 0x3330 <vTaskUARTRead+0x7a>

00003336 <sendResponse>:

    }

}

void sendResponse(Response* response){
    3336:	df 93       	push	r29
    3338:	cf 93       	push	r28
    333a:	00 d0       	rcall	.+0      	; 0x333c <sendResponse+0x6>
    333c:	0f 92       	push	r0
    333e:	cd b7       	in	r28, 0x3d	; 61
    3340:	de b7       	in	r29, 0x3e	; 62
    3342:	9c 83       	std	Y+4, r25	; 0x04
    3344:	8b 83       	std	Y+3, r24	; 0x03

    char checksumBuffer[2];

    USART_AddToQueue(response->commandBack);
    3346:	eb 81       	ldd	r30, Y+3	; 0x03
    3348:	fc 81       	ldd	r31, Y+4	; 0x04
    334a:	80 81       	ld	r24, Z
    334c:	0e 94 fe 18 	call	0x31fc	; 0x31fc <USART_AddToQueue>
    USART_AddToQueue(response->size);
    3350:	eb 81       	ldd	r30, Y+3	; 0x03
    3352:	fc 81       	ldd	r31, Y+4	; 0x04
    3354:	81 81       	ldd	r24, Z+1	; 0x01
    3356:	0e 94 fe 18 	call	0x31fc	; 0x31fc <USART_AddToQueue>
    USART_AddToQueue(calcChecksum(checksumBuffer,2));
    335a:	ce 01       	movw	r24, r28
    335c:	01 96       	adiw	r24, 0x01	; 1
    335e:	62 e0       	ldi	r22, 0x02	; 2
    3360:	0e 94 d9 19 	call	0x33b2	; 0x33b2 <calcChecksum>
    3364:	0e 94 fe 18 	call	0x31fc	; 0x31fc <USART_AddToQueue>
    if(response->size > 0){
    3368:	eb 81       	ldd	r30, Y+3	; 0x03
    336a:	fc 81       	ldd	r31, Y+4	; 0x04
    336c:	81 81       	ldd	r24, Z+1	; 0x01
    336e:	18 16       	cp	r1, r24
    3370:	2c f4       	brge	.+10     	; 0x337c <sendResponse+0x46>
        USART_TransmitString(response->payload);
    3372:	8b 81       	ldd	r24, Y+3	; 0x03
    3374:	9c 81       	ldd	r25, Y+4	; 0x04
    3376:	02 96       	adiw	r24, 0x02	; 2
    3378:	0e 94 15 19 	call	0x322a	; 0x322a <USART_TransmitString>
    }

}
    337c:	0f 90       	pop	r0
    337e:	0f 90       	pop	r0
    3380:	0f 90       	pop	r0
    3382:	0f 90       	pop	r0
    3384:	cf 91       	pop	r28
    3386:	df 91       	pop	r29
    3388:	08 95       	ret

0000338a <sendACK>:

void sendACK(){
    338a:	df 93       	push	r29
    338c:	cf 93       	push	r28
    338e:	cd b7       	in	r28, 0x3d	; 61
    3390:	de b7       	in	r29, 0x3e	; 62
    USART_AddToQueue(0xFF);
    3392:	8f ef       	ldi	r24, 0xFF	; 255
    3394:	0e 94 fe 18 	call	0x31fc	; 0x31fc <USART_AddToQueue>
}
    3398:	cf 91       	pop	r28
    339a:	df 91       	pop	r29
    339c:	08 95       	ret

0000339e <sendNACK>:

void sendNACK(){
    339e:	df 93       	push	r29
    33a0:	cf 93       	push	r28
    33a2:	cd b7       	in	r28, 0x3d	; 61
    33a4:	de b7       	in	r29, 0x3e	; 62
    USART_AddToQueue(0);
    33a6:	80 e0       	ldi	r24, 0x00	; 0
    33a8:	0e 94 fe 18 	call	0x31fc	; 0x31fc <USART_AddToQueue>
}
    33ac:	cf 91       	pop	r28
    33ae:	df 91       	pop	r29
    33b0:	08 95       	ret

000033b2 <calcChecksum>:

uint8_t calcChecksum(uint8_t* buffer,uint8_t size){
    33b2:	df 93       	push	r29
    33b4:	cf 93       	push	r28
    33b6:	00 d0       	rcall	.+0      	; 0x33b8 <calcChecksum+0x6>
    33b8:	0f 92       	push	r0
    33ba:	0f 92       	push	r0
    33bc:	cd b7       	in	r28, 0x3d	; 61
    33be:	de b7       	in	r29, 0x3e	; 62
    33c0:	9b 83       	std	Y+3, r25	; 0x03
    33c2:	8a 83       	std	Y+2, r24	; 0x02
    33c4:	6c 83       	std	Y+4, r22	; 0x04
    uint8_t checksum = 0;
    33c6:	19 82       	std	Y+1, r1	; 0x01
    33c8:	0b c0       	rjmp	.+22     	; 0x33e0 <calcChecksum+0x2e>
    while(size-- > 0){
        checksum += *(buffer++);
    33ca:	ea 81       	ldd	r30, Y+2	; 0x02
    33cc:	fb 81       	ldd	r31, Y+3	; 0x03
    33ce:	90 81       	ld	r25, Z
    33d0:	89 81       	ldd	r24, Y+1	; 0x01
    33d2:	89 0f       	add	r24, r25
    33d4:	89 83       	std	Y+1, r24	; 0x01
    33d6:	8a 81       	ldd	r24, Y+2	; 0x02
    33d8:	9b 81       	ldd	r25, Y+3	; 0x03
    33da:	01 96       	adiw	r24, 0x01	; 1
    33dc:	9b 83       	std	Y+3, r25	; 0x03
    33de:	8a 83       	std	Y+2, r24	; 0x02
    USART_AddToQueue(0);
}

uint8_t calcChecksum(uint8_t* buffer,uint8_t size){
    uint8_t checksum = 0;
    while(size-- > 0){
    33e0:	8c 81       	ldd	r24, Y+4	; 0x04
    33e2:	8d 83       	std	Y+5, r24	; 0x05
    33e4:	8d 81       	ldd	r24, Y+5	; 0x05
    33e6:	88 23       	and	r24, r24
    33e8:	11 f0       	breq	.+4      	; 0x33ee <calcChecksum+0x3c>
    33ea:	81 e0       	ldi	r24, 0x01	; 1
    33ec:	8d 83       	std	Y+5, r24	; 0x05
    33ee:	8d 81       	ldd	r24, Y+5	; 0x05
    33f0:	9c 81       	ldd	r25, Y+4	; 0x04
    33f2:	91 50       	subi	r25, 0x01	; 1
    33f4:	9c 83       	std	Y+4, r25	; 0x04
    33f6:	88 23       	and	r24, r24
    33f8:	41 f7       	brne	.-48     	; 0x33ca <calcChecksum+0x18>
        checksum += *(buffer++);
    }
    return checksum;
    33fa:	89 81       	ldd	r24, Y+1	; 0x01
    33fc:	0f 90       	pop	r0
    33fe:	0f 90       	pop	r0
    3400:	0f 90       	pop	r0
    3402:	0f 90       	pop	r0
    3404:	0f 90       	pop	r0
    3406:	cf 91       	pop	r28
    3408:	df 91       	pop	r29
    340a:	08 95       	ret

0000340c <commandIntegCheck>:
#include "protocol.h"
#include "Components/Sonar/Sonar.h"


//function to CRC the command structure
char commandIntegCheck(Command *command) {
    340c:	df 93       	push	r29
    340e:	cf 93       	push	r28
    3410:	0f 92       	push	r0
    3412:	0f 92       	push	r0
    3414:	cd b7       	in	r28, 0x3d	; 61
    3416:	de b7       	in	r29, 0x3e	; 62
    3418:	9a 83       	std	Y+2, r25	; 0x02
    341a:	89 83       	std	Y+1, r24	; 0x01
   //CRC the command with 0x00 in place of the CRC
   //return success for now
   return 1;
    341c:	81 e0       	ldi	r24, 0x01	; 1
}
    341e:	0f 90       	pop	r0
    3420:	0f 90       	pop	r0
    3422:	cf 91       	pop	r28
    3424:	df 91       	pop	r29
    3426:	08 95       	ret

00003428 <processUltrasonicCommand>:

char processUltrasonicCommand(char commandCode, void* commandData, void* responseData) {
    3428:	df 93       	push	r29
    342a:	cf 93       	push	r28
    342c:	cd b7       	in	r28, 0x3d	; 61
    342e:	de b7       	in	r29, 0x3e	; 62
    3430:	27 97       	sbiw	r28, 0x07	; 7
    3432:	0f b6       	in	r0, 0x3f	; 63
    3434:	f8 94       	cli
    3436:	de bf       	out	0x3e, r29	; 62
    3438:	0f be       	out	0x3f, r0	; 63
    343a:	cd bf       	out	0x3d, r28	; 61
    343c:	89 83       	std	Y+1, r24	; 0x01
    343e:	7b 83       	std	Y+3, r23	; 0x03
    3440:	6a 83       	std	Y+2, r22	; 0x02
    3442:	5d 83       	std	Y+5, r21	; 0x05
    3444:	4c 83       	std	Y+4, r20	; 0x04
   switch(commandCode) {
    3446:	89 81       	ldd	r24, Y+1	; 0x01
    3448:	28 2f       	mov	r18, r24
    344a:	33 27       	eor	r19, r19
    344c:	27 fd       	sbrc	r18, 7
    344e:	30 95       	com	r19
    3450:	3f 83       	std	Y+7, r19	; 0x07
    3452:	2e 83       	std	Y+6, r18	; 0x06
    3454:	8e 81       	ldd	r24, Y+6	; 0x06
    3456:	9f 81       	ldd	r25, Y+7	; 0x07
    3458:	81 30       	cpi	r24, 0x01	; 1
    345a:	91 05       	cpc	r25, r1
    345c:	71 f0       	breq	.+28     	; 0x347a <processUltrasonicCommand+0x52>
    345e:	2e 81       	ldd	r18, Y+6	; 0x06
    3460:	3f 81       	ldd	r19, Y+7	; 0x07
    3462:	22 30       	cpi	r18, 0x02	; 2
    3464:	31 05       	cpc	r19, r1
    3466:	91 f0       	breq	.+36     	; 0x348c <processUltrasonicCommand+0x64>
    3468:	8e 81       	ldd	r24, Y+6	; 0x06
    346a:	9f 81       	ldd	r25, Y+7	; 0x07
    346c:	00 97       	sbiw	r24, 0x00	; 0
    346e:	b1 f4       	brne	.+44     	; 0x349c <processUltrasonicCommand+0x74>
      case GET_ALL_SENSORS:
         getAllSensors((int*) responseData);
    3470:	8c 81       	ldd	r24, Y+4	; 0x04
    3472:	9d 81       	ldd	r25, Y+5	; 0x05
    3474:	0e 94 83 1d 	call	0x3b06	; 0x3b06 <getAllSensors>
    3478:	11 c0       	rjmp	.+34     	; 0x349c <processUltrasonicCommand+0x74>
         break;
      case GET_CERTAIN_SENSORS:
         getCertainSensor(((char*)commandData)[0], (int*) responseData);
    347a:	ea 81       	ldd	r30, Y+2	; 0x02
    347c:	fb 81       	ldd	r31, Y+3	; 0x03
    347e:	80 81       	ld	r24, Z
    3480:	2c 81       	ldd	r18, Y+4	; 0x04
    3482:	3d 81       	ldd	r19, Y+5	; 0x05
    3484:	b9 01       	movw	r22, r18
    3486:	0e 94 b8 1d 	call	0x3b70	; 0x3b70 <getCertainSensor>
    348a:	08 c0       	rjmp	.+16     	; 0x349c <processUltrasonicCommand+0x74>
         break;
      case GET_SENSOR_GROUP:
         getSensorGroup(((char*)commandData)[0], (int*) responseData);
    348c:	ea 81       	ldd	r30, Y+2	; 0x02
    348e:	fb 81       	ldd	r31, Y+3	; 0x03
    3490:	80 81       	ld	r24, Z
    3492:	2c 81       	ldd	r18, Y+4	; 0x04
    3494:	3d 81       	ldd	r19, Y+5	; 0x05
    3496:	b9 01       	movw	r22, r18
    3498:	0e 94 e6 1d 	call	0x3bcc	; 0x3bcc <getSensorGroup>
         break;
   }
   //return success for now...
   return 1;
    349c:	81 e0       	ldi	r24, 0x01	; 1
}
    349e:	27 96       	adiw	r28, 0x07	; 7
    34a0:	0f b6       	in	r0, 0x3f	; 63
    34a2:	f8 94       	cli
    34a4:	de bf       	out	0x3e, r29	; 62
    34a6:	0f be       	out	0x3f, r0	; 63
    34a8:	cd bf       	out	0x3d, r28	; 61
    34aa:	cf 91       	pop	r28
    34ac:	df 91       	pop	r29
    34ae:	08 95       	ret

000034b0 <processSpeedCommand>:

char processSpeedCommand(char commandCode, void* commandData, void* responseData) {
    34b0:	df 93       	push	r29
    34b2:	cf 93       	push	r28
    34b4:	cd b7       	in	r28, 0x3d	; 61
    34b6:	de b7       	in	r29, 0x3e	; 62
    34b8:	27 97       	sbiw	r28, 0x07	; 7
    34ba:	0f b6       	in	r0, 0x3f	; 63
    34bc:	f8 94       	cli
    34be:	de bf       	out	0x3e, r29	; 62
    34c0:	0f be       	out	0x3f, r0	; 63
    34c2:	cd bf       	out	0x3d, r28	; 61
    34c4:	89 83       	std	Y+1, r24	; 0x01
    34c6:	7b 83       	std	Y+3, r23	; 0x03
    34c8:	6a 83       	std	Y+2, r22	; 0x02
    34ca:	5d 83       	std	Y+5, r21	; 0x05
    34cc:	4c 83       	std	Y+4, r20	; 0x04
   switch(commandCode) {
    34ce:	89 81       	ldd	r24, Y+1	; 0x01
    34d0:	28 2f       	mov	r18, r24
    34d2:	33 27       	eor	r19, r19
    34d4:	27 fd       	sbrc	r18, 7
    34d6:	30 95       	com	r19
    34d8:	3f 83       	std	Y+7, r19	; 0x07
    34da:	2e 83       	std	Y+6, r18	; 0x06
    34dc:	8e 81       	ldd	r24, Y+6	; 0x06
    34de:	9f 81       	ldd	r25, Y+7	; 0x07
    34e0:	00 97       	sbiw	r24, 0x00	; 0
    34e2:	31 f0       	breq	.+12     	; 0x34f0 <processSpeedCommand+0x40>
    34e4:	2e 81       	ldd	r18, Y+6	; 0x06
    34e6:	3f 81       	ldd	r19, Y+7	; 0x07
    34e8:	21 30       	cpi	r18, 0x01	; 1
    34ea:	31 05       	cpc	r19, r1
    34ec:	31 f0       	breq	.+12     	; 0x34fa <processSpeedCommand+0x4a>
    34ee:	0d c0       	rjmp	.+26     	; 0x350a <processSpeedCommand+0x5a>
      case GET_SPEED:
         getSpeed((char*) responseData);
    34f0:	8c 81       	ldd	r24, Y+4	; 0x04
    34f2:	9d 81       	ldd	r25, Y+5	; 0x05
    34f4:	0e 94 5d 1e 	call	0x3cba	; 0x3cba <getSpeed>
    34f8:	08 c0       	rjmp	.+16     	; 0x350a <processSpeedCommand+0x5a>
         break;
      case SET_SPEED:
         setSpeed(((char*)commandData)[0]);
    34fa:	ea 81       	ldd	r30, Y+2	; 0x02
    34fc:	fb 81       	ldd	r31, Y+3	; 0x03
    34fe:	80 81       	ld	r24, Z
    3500:	99 27       	eor	r25, r25
    3502:	87 fd       	sbrc	r24, 7
    3504:	90 95       	com	r25
    3506:	0e 94 6e 1e 	call	0x3cdc	; 0x3cdc <setSpeed>
         break;
   }
   //return success for now
   return 1;
    350a:	81 e0       	ldi	r24, 0x01	; 1
}
    350c:	27 96       	adiw	r28, 0x07	; 7
    350e:	0f b6       	in	r0, 0x3f	; 63
    3510:	f8 94       	cli
    3512:	de bf       	out	0x3e, r29	; 62
    3514:	0f be       	out	0x3f, r0	; 63
    3516:	cd bf       	out	0x3d, r28	; 61
    3518:	cf 91       	pop	r28
    351a:	df 91       	pop	r29
    351c:	08 95       	ret

0000351e <processSteeringCommand>:

char processSteeringCommand(char commandCode, void* commandData, void* responseData) {
    351e:	df 93       	push	r29
    3520:	cf 93       	push	r28
    3522:	cd b7       	in	r28, 0x3d	; 61
    3524:	de b7       	in	r29, 0x3e	; 62
    3526:	27 97       	sbiw	r28, 0x07	; 7
    3528:	0f b6       	in	r0, 0x3f	; 63
    352a:	f8 94       	cli
    352c:	de bf       	out	0x3e, r29	; 62
    352e:	0f be       	out	0x3f, r0	; 63
    3530:	cd bf       	out	0x3d, r28	; 61
    3532:	89 83       	std	Y+1, r24	; 0x01
    3534:	7b 83       	std	Y+3, r23	; 0x03
    3536:	6a 83       	std	Y+2, r22	; 0x02
    3538:	5d 83       	std	Y+5, r21	; 0x05
    353a:	4c 83       	std	Y+4, r20	; 0x04
   switch(commandCode) {
    353c:	89 81       	ldd	r24, Y+1	; 0x01
    353e:	28 2f       	mov	r18, r24
    3540:	33 27       	eor	r19, r19
    3542:	27 fd       	sbrc	r18, 7
    3544:	30 95       	com	r19
    3546:	3f 83       	std	Y+7, r19	; 0x07
    3548:	2e 83       	std	Y+6, r18	; 0x06
    354a:	8e 81       	ldd	r24, Y+6	; 0x06
    354c:	9f 81       	ldd	r25, Y+7	; 0x07
    354e:	82 30       	cpi	r24, 0x02	; 2
    3550:	91 05       	cpc	r25, r1
    3552:	41 f1       	breq	.+80     	; 0x35a4 <processSteeringCommand+0x86>
    3554:	2e 81       	ldd	r18, Y+6	; 0x06
    3556:	3f 81       	ldd	r19, Y+7	; 0x07
    3558:	23 30       	cpi	r18, 0x03	; 3
    355a:	31 05       	cpc	r19, r1
    355c:	54 f4       	brge	.+20     	; 0x3572 <processSteeringCommand+0x54>
    355e:	8e 81       	ldd	r24, Y+6	; 0x06
    3560:	9f 81       	ldd	r25, Y+7	; 0x07
    3562:	00 97       	sbiw	r24, 0x00	; 0
    3564:	89 f0       	breq	.+34     	; 0x3588 <processSteeringCommand+0x6a>
    3566:	2e 81       	ldd	r18, Y+6	; 0x06
    3568:	3f 81       	ldd	r19, Y+7	; 0x07
    356a:	21 30       	cpi	r18, 0x01	; 1
    356c:	31 05       	cpc	r19, r1
    356e:	a9 f0       	breq	.+42     	; 0x359a <processSteeringCommand+0x7c>
    3570:	51 c0       	rjmp	.+162    	; 0x3614 <processSteeringCommand+0xf6>
    3572:	8e 81       	ldd	r24, Y+6	; 0x06
    3574:	9f 81       	ldd	r25, Y+7	; 0x07
    3576:	83 30       	cpi	r24, 0x03	; 3
    3578:	91 05       	cpc	r25, r1
    357a:	c9 f0       	breq	.+50     	; 0x35ae <processSteeringCommand+0x90>
    357c:	2e 81       	ldd	r18, Y+6	; 0x06
    357e:	3f 81       	ldd	r19, Y+7	; 0x07
    3580:	24 30       	cpi	r18, 0x04	; 4
    3582:	31 05       	cpc	r19, r1
    3584:	99 f1       	breq	.+102    	; 0x35ec <processSteeringCommand+0xce>
    3586:	46 c0       	rjmp	.+140    	; 0x3614 <processSteeringCommand+0xf6>
      case SET_ANGLE:
         setAngle(*((char*)commandData));
    3588:	ea 81       	ldd	r30, Y+2	; 0x02
    358a:	fb 81       	ldd	r31, Y+3	; 0x03
    358c:	80 81       	ld	r24, Z
    358e:	99 27       	eor	r25, r25
    3590:	87 fd       	sbrc	r24, 7
    3592:	90 95       	com	r25
    3594:	0e 94 79 1e 	call	0x3cf2	; 0x3cf2 <setAngle>
    3598:	3d c0       	rjmp	.+122    	; 0x3614 <processSteeringCommand+0xf6>
         break;
      case GET_ANGLE:
         getAngle((char*) responseData);
    359a:	8c 81       	ldd	r24, Y+4	; 0x04
    359c:	9d 81       	ldd	r25, Y+5	; 0x05
    359e:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <getAngle>
    35a2:	38 c0       	rjmp	.+112    	; 0x3614 <processSteeringCommand+0xf6>
         break;
      case GET_DESIRED_ANGLE:
         getDesiredAngle((char*) responseData);
    35a4:	8c 81       	ldd	r24, Y+4	; 0x04
    35a6:	9d 81       	ldd	r25, Y+5	; 0x05
    35a8:	0e 94 95 1e 	call	0x3d2a	; 0x3d2a <getDesiredAngle>
    35ac:	33 c0       	rjmp	.+102    	; 0x3614 <processSteeringCommand+0xf6>
         break;
      case CHANGE_PID:
         changePID(((char*)commandData)[0], ((char*)commandData)[1], ((char*)commandData)[2]);
    35ae:	ea 81       	ldd	r30, Y+2	; 0x02
    35b0:	fb 81       	ldd	r31, Y+3	; 0x03
    35b2:	80 81       	ld	r24, Z
    35b4:	68 2f       	mov	r22, r24
    35b6:	77 27       	eor	r23, r23
    35b8:	67 fd       	sbrc	r22, 7
    35ba:	70 95       	com	r23
    35bc:	8a 81       	ldd	r24, Y+2	; 0x02
    35be:	9b 81       	ldd	r25, Y+3	; 0x03
    35c0:	fc 01       	movw	r30, r24
    35c2:	31 96       	adiw	r30, 0x01	; 1
    35c4:	80 81       	ld	r24, Z
    35c6:	48 2f       	mov	r20, r24
    35c8:	55 27       	eor	r21, r21
    35ca:	47 fd       	sbrc	r20, 7
    35cc:	50 95       	com	r21
    35ce:	8a 81       	ldd	r24, Y+2	; 0x02
    35d0:	9b 81       	ldd	r25, Y+3	; 0x03
    35d2:	fc 01       	movw	r30, r24
    35d4:	32 96       	adiw	r30, 0x02	; 2
    35d6:	80 81       	ld	r24, Z
    35d8:	28 2f       	mov	r18, r24
    35da:	33 27       	eor	r19, r19
    35dc:	27 fd       	sbrc	r18, 7
    35de:	30 95       	com	r19
    35e0:	cb 01       	movw	r24, r22
    35e2:	ba 01       	movw	r22, r20
    35e4:	a9 01       	movw	r20, r18
    35e6:	0e 94 a6 1e 	call	0x3d4c	; 0x3d4c <changePID>
    35ea:	14 c0       	rjmp	.+40     	; 0x3614 <processSteeringCommand+0xf6>
         break;
      case SET_LIMITS:
         setLimits(((char*)commandData)[0], ((char*)commandData)[1]);
    35ec:	ea 81       	ldd	r30, Y+2	; 0x02
    35ee:	fb 81       	ldd	r31, Y+3	; 0x03
    35f0:	80 81       	ld	r24, Z
    35f2:	48 2f       	mov	r20, r24
    35f4:	55 27       	eor	r21, r21
    35f6:	47 fd       	sbrc	r20, 7
    35f8:	50 95       	com	r21
    35fa:	8a 81       	ldd	r24, Y+2	; 0x02
    35fc:	9b 81       	ldd	r25, Y+3	; 0x03
    35fe:	fc 01       	movw	r30, r24
    3600:	31 96       	adiw	r30, 0x01	; 1
    3602:	80 81       	ld	r24, Z
    3604:	28 2f       	mov	r18, r24
    3606:	33 27       	eor	r19, r19
    3608:	27 fd       	sbrc	r18, 7
    360a:	30 95       	com	r19
    360c:	ca 01       	movw	r24, r20
    360e:	b9 01       	movw	r22, r18
    3610:	0e 94 b5 1e 	call	0x3d6a	; 0x3d6a <setLimits>
         break;
   }
   //return success for now
   return 1;
    3614:	81 e0       	ldi	r24, 0x01	; 1
}
    3616:	27 96       	adiw	r28, 0x07	; 7
    3618:	0f b6       	in	r0, 0x3f	; 63
    361a:	f8 94       	cli
    361c:	de bf       	out	0x3e, r29	; 62
    361e:	0f be       	out	0x3f, r0	; 63
    3620:	cd bf       	out	0x3d, r28	; 61
    3622:	cf 91       	pop	r28
    3624:	df 91       	pop	r29
    3626:	08 95       	ret

00003628 <processFNRCommand>:

char processFNRCommand(char commandCode, void* commandData, void* responseData) {
    3628:	df 93       	push	r29
    362a:	cf 93       	push	r28
    362c:	cd b7       	in	r28, 0x3d	; 61
    362e:	de b7       	in	r29, 0x3e	; 62
    3630:	28 97       	sbiw	r28, 0x08	; 8
    3632:	0f b6       	in	r0, 0x3f	; 63
    3634:	f8 94       	cli
    3636:	de bf       	out	0x3e, r29	; 62
    3638:	0f be       	out	0x3f, r0	; 63
    363a:	cd bf       	out	0x3d, r28	; 61
    363c:	89 83       	std	Y+1, r24	; 0x01
    363e:	7b 83       	std	Y+3, r23	; 0x03
    3640:	6a 83       	std	Y+2, r22	; 0x02
    3642:	5d 83       	std	Y+5, r21	; 0x05
    3644:	4c 83       	std	Y+4, r20	; 0x04
   switch(commandCode) {
    3646:	89 81       	ldd	r24, Y+1	; 0x01
    3648:	28 2f       	mov	r18, r24
    364a:	33 27       	eor	r19, r19
    364c:	27 fd       	sbrc	r18, 7
    364e:	30 95       	com	r19
    3650:	3f 83       	std	Y+7, r19	; 0x07
    3652:	2e 83       	std	Y+6, r18	; 0x06
    3654:	8e 81       	ldd	r24, Y+6	; 0x06
    3656:	9f 81       	ldd	r25, Y+7	; 0x07
    3658:	00 97       	sbiw	r24, 0x00	; 0
    365a:	31 f0       	breq	.+12     	; 0x3668 <processFNRCommand+0x40>
    365c:	2e 81       	ldd	r18, Y+6	; 0x06
    365e:	3f 81       	ldd	r19, Y+7	; 0x07
    3660:	21 30       	cpi	r18, 0x01	; 1
    3662:	31 05       	cpc	r19, r1
    3664:	51 f0       	breq	.+20     	; 0x367a <processFNRCommand+0x52>
    3666:	0d c0       	rjmp	.+26     	; 0x3682 <processFNRCommand+0x5a>
      case SET_FNR:
         setFNR(*((char*)commandData));
    3668:	ea 81       	ldd	r30, Y+2	; 0x02
    366a:	fb 81       	ldd	r31, Y+3	; 0x03
    366c:	80 81       	ld	r24, Z
    366e:	99 27       	eor	r25, r25
    3670:	87 fd       	sbrc	r24, 7
    3672:	90 95       	com	r25
    3674:	0e 94 4b 1c 	call	0x3896	; 0x3896 <setFNR>
    3678:	04 c0       	rjmp	.+8      	; 0x3682 <processFNRCommand+0x5a>
         break;
      case GET_FNR:
         getFNR((char*) responseData);
    367a:	8c 81       	ldd	r24, Y+4	; 0x04
    367c:	9d 81       	ldd	r25, Y+5	; 0x05
    367e:	0e 94 56 1c 	call	0x38ac	; 0x38ac <getFNR>
         break;
   }
}
    3682:	28 96       	adiw	r28, 0x08	; 8
    3684:	0f b6       	in	r0, 0x3f	; 63
    3686:	f8 94       	cli
    3688:	de bf       	out	0x3e, r29	; 62
    368a:	0f be       	out	0x3f, r0	; 63
    368c:	cd bf       	out	0x3d, r28	; 61
    368e:	cf 91       	pop	r28
    3690:	df 91       	pop	r29
    3692:	08 95       	ret

00003694 <processBrakeCommand>:

char processBrakeCommand(char commandCode, void* commandData, void* responseData) {
    3694:	df 93       	push	r29
    3696:	cf 93       	push	r28
    3698:	cd b7       	in	r28, 0x3d	; 61
    369a:	de b7       	in	r29, 0x3e	; 62
    369c:	28 97       	sbiw	r28, 0x08	; 8
    369e:	0f b6       	in	r0, 0x3f	; 63
    36a0:	f8 94       	cli
    36a2:	de bf       	out	0x3e, r29	; 62
    36a4:	0f be       	out	0x3f, r0	; 63
    36a6:	cd bf       	out	0x3d, r28	; 61
    36a8:	89 83       	std	Y+1, r24	; 0x01
    36aa:	7b 83       	std	Y+3, r23	; 0x03
    36ac:	6a 83       	std	Y+2, r22	; 0x02
    36ae:	5d 83       	std	Y+5, r21	; 0x05
    36b0:	4c 83       	std	Y+4, r20	; 0x04
   switch(commandCode) {
    36b2:	89 81       	ldd	r24, Y+1	; 0x01
    36b4:	28 2f       	mov	r18, r24
    36b6:	33 27       	eor	r19, r19
    36b8:	27 fd       	sbrc	r18, 7
    36ba:	30 95       	com	r19
    36bc:	3f 83       	std	Y+7, r19	; 0x07
    36be:	2e 83       	std	Y+6, r18	; 0x06
    36c0:	8e 81       	ldd	r24, Y+6	; 0x06
    36c2:	9f 81       	ldd	r25, Y+7	; 0x07
    36c4:	00 97       	sbiw	r24, 0x00	; 0
    36c6:	31 f0       	breq	.+12     	; 0x36d4 <processBrakeCommand+0x40>
    36c8:	2e 81       	ldd	r18, Y+6	; 0x06
    36ca:	3f 81       	ldd	r19, Y+7	; 0x07
    36cc:	21 30       	cpi	r18, 0x01	; 1
    36ce:	31 05       	cpc	r19, r1
    36d0:	51 f0       	breq	.+20     	; 0x36e6 <processBrakeCommand+0x52>
    36d2:	0d c0       	rjmp	.+26     	; 0x36ee <processBrakeCommand+0x5a>
      case SET_BRAKE:
	 setBrake(*((char*)commandData));
    36d4:	ea 81       	ldd	r30, Y+2	; 0x02
    36d6:	fb 81       	ldd	r31, Y+3	; 0x03
    36d8:	80 81       	ld	r24, Z
    36da:	99 27       	eor	r25, r25
    36dc:	87 fd       	sbrc	r24, 7
    36de:	90 95       	com	r25
    36e0:	0e 94 2f 1c 	call	0x385e	; 0x385e <setBrake>
    36e4:	04 c0       	rjmp	.+8      	; 0x36ee <processBrakeCommand+0x5a>
	 break;
      case GET_BRAKE:
	 getBrake((char*) responseData);
    36e6:	8c 81       	ldd	r24, Y+4	; 0x04
    36e8:	9d 81       	ldd	r25, Y+5	; 0x05
    36ea:	0e 94 3a 1c 	call	0x3874	; 0x3874 <getBrake>
	 break; 
   }
}
    36ee:	28 96       	adiw	r28, 0x08	; 8
    36f0:	0f b6       	in	r0, 0x3f	; 63
    36f2:	f8 94       	cli
    36f4:	de bf       	out	0x3e, r29	; 62
    36f6:	0f be       	out	0x3f, r0	; 63
    36f8:	cd bf       	out	0x3d, r28	; 61
    36fa:	cf 91       	pop	r28
    36fc:	df 91       	pop	r29
    36fe:	08 95       	ret

00003700 <processBatteryCommand>:

char processBatteryCommand(char commandCode, void* commandData, void* responseData) {
    3700:	df 93       	push	r29
    3702:	cf 93       	push	r28
    3704:	cd b7       	in	r28, 0x3d	; 61
    3706:	de b7       	in	r29, 0x3e	; 62
    3708:	28 97       	sbiw	r28, 0x08	; 8
    370a:	0f b6       	in	r0, 0x3f	; 63
    370c:	f8 94       	cli
    370e:	de bf       	out	0x3e, r29	; 62
    3710:	0f be       	out	0x3f, r0	; 63
    3712:	cd bf       	out	0x3d, r28	; 61
    3714:	89 83       	std	Y+1, r24	; 0x01
    3716:	7b 83       	std	Y+3, r23	; 0x03
    3718:	6a 83       	std	Y+2, r22	; 0x02
    371a:	5d 83       	std	Y+5, r21	; 0x05
    371c:	4c 83       	std	Y+4, r20	; 0x04
   switch(commandCode) {
    371e:	89 81       	ldd	r24, Y+1	; 0x01
    3720:	28 2f       	mov	r18, r24
    3722:	33 27       	eor	r19, r19
    3724:	27 fd       	sbrc	r18, 7
    3726:	30 95       	com	r19
    3728:	3f 83       	std	Y+7, r19	; 0x07
    372a:	2e 83       	std	Y+6, r18	; 0x06
    372c:	8e 81       	ldd	r24, Y+6	; 0x06
    372e:	9f 81       	ldd	r25, Y+7	; 0x07
    3730:	00 97       	sbiw	r24, 0x00	; 0
    3732:	31 f0       	breq	.+12     	; 0x3740 <processBatteryCommand+0x40>
    3734:	2e 81       	ldd	r18, Y+6	; 0x06
    3736:	3f 81       	ldd	r19, Y+7	; 0x07
    3738:	21 30       	cpi	r18, 0x01	; 1
    373a:	31 05       	cpc	r19, r1
    373c:	31 f0       	breq	.+12     	; 0x374a <processBatteryCommand+0x4a>
    373e:	09 c0       	rjmp	.+18     	; 0x3752 <processBatteryCommand+0x52>
      case GET_BATTERY_VOLTAGE:
         getBatteryVoltage((char*) responseData);
    3740:	8c 81       	ldd	r24, Y+4	; 0x04
    3742:	9d 81       	ldd	r25, Y+5	; 0x05
    3744:	0e 94 0d 1c 	call	0x381a	; 0x381a <getBatteryVoltage>
    3748:	04 c0       	rjmp	.+8      	; 0x3752 <processBatteryCommand+0x52>
         break;
      case GET_STEERING_VOLTAGE:
         getSteeringVoltage((char*) responseData);
    374a:	8c 81       	ldd	r24, Y+4	; 0x04
    374c:	9d 81       	ldd	r25, Y+5	; 0x05
    374e:	0e 94 1e 1c 	call	0x383c	; 0x383c <getSteeringVoltage>
         break;
   }
}
    3752:	28 96       	adiw	r28, 0x08	; 8
    3754:	0f b6       	in	r0, 0x3f	; 63
    3756:	f8 94       	cli
    3758:	de bf       	out	0x3e, r29	; 62
    375a:	0f be       	out	0x3f, r0	; 63
    375c:	cd bf       	out	0x3d, r28	; 61
    375e:	cf 91       	pop	r28
    3760:	df 91       	pop	r29
    3762:	08 95       	ret

00003764 <processLightCommand>:

char processLightCommand(char commandCode, void* commandData, void* responseDate) {
    3764:	df 93       	push	r29
    3766:	cf 93       	push	r28
    3768:	00 d0       	rcall	.+0      	; 0x376a <processLightCommand+0x6>
    376a:	00 d0       	rcall	.+0      	; 0x376c <processLightCommand+0x8>
    376c:	cd b7       	in	r28, 0x3d	; 61
    376e:	de b7       	in	r29, 0x3e	; 62
    3770:	89 83       	std	Y+1, r24	; 0x01
    3772:	7b 83       	std	Y+3, r23	; 0x03
    3774:	6a 83       	std	Y+2, r22	; 0x02
    3776:	5d 83       	std	Y+5, r21	; 0x05
    3778:	4c 83       	std	Y+4, r20	; 0x04
   switch(commandCode) {
    377a:	89 81       	ldd	r24, Y+1	; 0x01
    377c:	99 27       	eor	r25, r25
    377e:	87 fd       	sbrc	r24, 7
    3780:	90 95       	com	r25
    3782:	00 97       	sbiw	r24, 0x00	; 0
    3784:	41 f4       	brne	.+16     	; 0x3796 <processLightCommand+0x32>
      case SET_LIGHT:
	 setLight(*((char*)commandData));
    3786:	ea 81       	ldd	r30, Y+2	; 0x02
    3788:	fb 81       	ldd	r31, Y+3	; 0x03
    378a:	80 81       	ld	r24, Z
    378c:	99 27       	eor	r25, r25
    378e:	87 fd       	sbrc	r24, 7
    3790:	90 95       	com	r25
    3792:	0e 94 67 1c 	call	0x38ce	; 0x38ce <setLight>
         break;
   }
}
    3796:	26 96       	adiw	r28, 0x06	; 6
    3798:	0f b6       	in	r0, 0x3f	; 63
    379a:	f8 94       	cli
    379c:	de bf       	out	0x3e, r29	; 62
    379e:	0f be       	out	0x3f, r0	; 63
    37a0:	cd bf       	out	0x3d, r28	; 61
    37a2:	cf 91       	pop	r28
    37a4:	df 91       	pop	r29
    37a6:	08 95       	ret

000037a8 <processCommand>:



//Function that will take in a command (as char array) and process it into a
//correct response to be stored into response
char processCommand(Command *command, Response *response) {
    37a8:	df 93       	push	r29
    37aa:	cf 93       	push	r28
    37ac:	00 d0       	rcall	.+0      	; 0x37ae <processCommand+0x6>
    37ae:	0f 92       	push	r0
    37b0:	0f 92       	push	r0
    37b2:	cd b7       	in	r28, 0x3d	; 61
    37b4:	de b7       	in	r29, 0x3e	; 62
    37b6:	9a 83       	std	Y+2, r25	; 0x02
    37b8:	89 83       	std	Y+1, r24	; 0x01
    37ba:	7c 83       	std	Y+4, r23	; 0x04
    37bc:	6b 83       	std	Y+3, r22	; 0x03
   if(commandIntegCheck(command)) {
    37be:	89 81       	ldd	r24, Y+1	; 0x01
    37c0:	9a 81       	ldd	r25, Y+2	; 0x02
    37c2:	0e 94 06 1a 	call	0x340c	; 0x340c <commandIntegCheck>
    37c6:	88 23       	and	r24, r24
    37c8:	f1 f0       	breq	.+60     	; 0x3806 <processCommand+0x5e>
      switch(command->groupID) {
    37ca:	e9 81       	ldd	r30, Y+1	; 0x01
    37cc:	fa 81       	ldd	r31, Y+2	; 0x02
    37ce:	80 81       	ld	r24, Z
    37d0:	99 27       	eor	r25, r25
    37d2:	87 fd       	sbrc	r24, 7
    37d4:	90 95       	com	r25
    37d6:	81 30       	cpi	r24, 0x01	; 1
    37d8:	91 05       	cpc	r25, r1
    37da:	91 f4       	brne	.+36     	; 0x3800 <processCommand+0x58>
         case ULTRASONIC_GROUP:
            processUltrasonicCommand(command->cmd, command->payload, response->payload);
    37dc:	e9 81       	ldd	r30, Y+1	; 0x01
    37de:	fa 81       	ldd	r31, Y+2	; 0x02
    37e0:	61 81       	ldd	r22, Z+1	; 0x01
    37e2:	89 81       	ldd	r24, Y+1	; 0x01
    37e4:	9a 81       	ldd	r25, Y+2	; 0x02
    37e6:	ac 01       	movw	r20, r24
    37e8:	4d 5f       	subi	r20, 0xFD	; 253
    37ea:	5f 4f       	sbci	r21, 0xFF	; 255
    37ec:	8b 81       	ldd	r24, Y+3	; 0x03
    37ee:	9c 81       	ldd	r25, Y+4	; 0x04
    37f0:	9c 01       	movw	r18, r24
    37f2:	2e 5f       	subi	r18, 0xFE	; 254
    37f4:	3f 4f       	sbci	r19, 0xFF	; 255
    37f6:	86 2f       	mov	r24, r22
    37f8:	ba 01       	movw	r22, r20
    37fa:	a9 01       	movw	r20, r18
    37fc:	0e 94 14 1a 	call	0x3428	; 0x3428 <processUltrasonicCommand>
         case ERROR_GROUP:
            /*do error things*/
            break;
      }
      //return a dummy success for now
      return 1;
    3800:	81 e0       	ldi	r24, 0x01	; 1
    3802:	8d 83       	std	Y+5, r24	; 0x05
    3804:	01 c0       	rjmp	.+2      	; 0x3808 <processCommand+0x60>
   } else {
      return 0;
    3806:	1d 82       	std	Y+5, r1	; 0x05
    3808:	8d 81       	ldd	r24, Y+5	; 0x05
   }
}
    380a:	0f 90       	pop	r0
    380c:	0f 90       	pop	r0
    380e:	0f 90       	pop	r0
    3810:	0f 90       	pop	r0
    3812:	0f 90       	pop	r0
    3814:	cf 91       	pop	r28
    3816:	df 91       	pop	r29
    3818:	08 95       	ret

0000381a <getBatteryVoltage>:

//battery controller functions

//read battery strength in a char. Might need to be unsigned, specs don't say
//anything regarding that.
char getBatteryVoltage(char *sensorResponse) {
    381a:	df 93       	push	r29
    381c:	cf 93       	push	r28
    381e:	0f 92       	push	r0
    3820:	0f 92       	push	r0
    3822:	cd b7       	in	r28, 0x3d	; 61
    3824:	de b7       	in	r29, 0x3e	; 62
    3826:	9a 83       	std	Y+2, r25	; 0x02
    3828:	89 83       	std	Y+1, r24	; 0x01
   //fake battery reading
   *sensorResponse = 0;
    382a:	e9 81       	ldd	r30, Y+1	; 0x01
    382c:	fa 81       	ldd	r31, Y+2	; 0x02
    382e:	10 82       	st	Z, r1
   //return success
   return 1;
    3830:	81 e0       	ldi	r24, 0x01	; 1
}
    3832:	0f 90       	pop	r0
    3834:	0f 90       	pop	r0
    3836:	cf 91       	pop	r28
    3838:	df 91       	pop	r29
    383a:	08 95       	ret

0000383c <getSteeringVoltage>:

//gets voltage from steering?
char getSteeringVoltage(char *sensorResponse) {
    383c:	df 93       	push	r29
    383e:	cf 93       	push	r28
    3840:	0f 92       	push	r0
    3842:	0f 92       	push	r0
    3844:	cd b7       	in	r28, 0x3d	; 61
    3846:	de b7       	in	r29, 0x3e	; 62
    3848:	9a 83       	std	Y+2, r25	; 0x02
    384a:	89 83       	std	Y+1, r24	; 0x01
   //fake steering voltage reading
   *sensorResponse = 0;
    384c:	e9 81       	ldd	r30, Y+1	; 0x01
    384e:	fa 81       	ldd	r31, Y+2	; 0x02
    3850:	10 82       	st	Z, r1
   //return success
   return 1;
    3852:	81 e0       	ldi	r24, 0x01	; 1
}
    3854:	0f 90       	pop	r0
    3856:	0f 90       	pop	r0
    3858:	cf 91       	pop	r28
    385a:	df 91       	pop	r29
    385c:	08 95       	ret

0000385e <setBrake>:
//Brake controller functions. THERE IS CURRENTLY NO WAY TO GET THE DESIRED
//BRAKE TARGET IN THE SPECS

//set brake target
char setBrake(char gainTarget) {
    385e:	df 93       	push	r29
    3860:	cf 93       	push	r28
    3862:	0f 92       	push	r0
    3864:	cd b7       	in	r28, 0x3d	; 61
    3866:	de b7       	in	r29, 0x3e	; 62
    3868:	89 83       	std	Y+1, r24	; 0x01
   //dummy function, nothing happens
   //return success
   return 1;
    386a:	81 e0       	ldi	r24, 0x01	; 1
}
    386c:	0f 90       	pop	r0
    386e:	cf 91       	pop	r28
    3870:	df 91       	pop	r29
    3872:	08 95       	ret

00003874 <getBrake>:

//get what is assumed to be the current brake value?
char getBrake(char* sensorResponse) {
    3874:	df 93       	push	r29
    3876:	cf 93       	push	r28
    3878:	0f 92       	push	r0
    387a:	0f 92       	push	r0
    387c:	cd b7       	in	r28, 0x3d	; 61
    387e:	de b7       	in	r29, 0x3e	; 62
    3880:	9a 83       	std	Y+2, r25	; 0x02
    3882:	89 83       	std	Y+1, r24	; 0x01
   //fake brake reading
   *sensorResponse = 0;
    3884:	e9 81       	ldd	r30, Y+1	; 0x01
    3886:	fa 81       	ldd	r31, Y+2	; 0x02
    3888:	10 82       	st	Z, r1
   //return success
   return 1;
    388a:	81 e0       	ldi	r24, 0x01	; 1
}
    388c:	0f 90       	pop	r0
    388e:	0f 90       	pop	r0
    3890:	cf 91       	pop	r28
    3892:	df 91       	pop	r29
    3894:	08 95       	ret

00003896 <setFNR>:
//FNR controller functions

//set the FNR controller, inputs are either -1, 0, or 1.
char setFNR(char FNR) {
    3896:	df 93       	push	r29
    3898:	cf 93       	push	r28
    389a:	0f 92       	push	r0
    389c:	cd b7       	in	r28, 0x3d	; 61
    389e:	de b7       	in	r29, 0x3e	; 62
    38a0:	89 83       	std	Y+1, r24	; 0x01
   //dummy function, nothing happens
   //return success
   return 1;
    38a2:	81 e0       	ldi	r24, 0x01	; 1
}
    38a4:	0f 90       	pop	r0
    38a6:	cf 91       	pop	r28
    38a8:	df 91       	pop	r29
    38aa:	08 95       	ret

000038ac <getFNR>:

//get the current FNR state. Function follows same format for consistancy
char getFNR(char *sensorResponse) {
    38ac:	df 93       	push	r29
    38ae:	cf 93       	push	r28
    38b0:	0f 92       	push	r0
    38b2:	0f 92       	push	r0
    38b4:	cd b7       	in	r28, 0x3d	; 61
    38b6:	de b7       	in	r29, 0x3e	; 62
    38b8:	9a 83       	std	Y+2, r25	; 0x02
    38ba:	89 83       	std	Y+1, r24	; 0x01
   //fake reading
   *sensorResponse = 0;
    38bc:	e9 81       	ldd	r30, Y+1	; 0x01
    38be:	fa 81       	ldd	r31, Y+2	; 0x02
    38c0:	10 82       	st	Z, r1
   //return success
   return 1;
    38c2:	81 e0       	ldi	r24, 0x01	; 1
}
    38c4:	0f 90       	pop	r0
    38c6:	0f 90       	pop	r0
    38c8:	cf 91       	pop	r28
    38ca:	df 91       	pop	r29
    38cc:	08 95       	ret

000038ce <setLight>:
//light controller functions

//turn lights on and off
char setLight(char lightTarget) {
    38ce:	df 93       	push	r29
    38d0:	cf 93       	push	r28
    38d2:	0f 92       	push	r0
    38d4:	cd b7       	in	r28, 0x3d	; 61
    38d6:	de b7       	in	r29, 0x3e	; 62
    38d8:	89 83       	std	Y+1, r24	; 0x01
   //dummy function, nothing happens
   //return success
   return 1;
    38da:	81 e0       	ldi	r24, 0x01	; 1
}
    38dc:	0f 90       	pop	r0
    38de:	cf 91       	pop	r28
    38e0:	df 91       	pop	r29
    38e2:	08 95       	ret

000038e4 <setSonarData>:
extern int count;

unsigned char currSonar;
unsigned char lastSonarData = 0;
   
void setSonarData(int i,unsigned char data){
    38e4:	df 93       	push	r29
    38e6:	cf 93       	push	r28
    38e8:	00 d0       	rcall	.+0      	; 0x38ea <setSonarData+0x6>
    38ea:	cd b7       	in	r28, 0x3d	; 61
    38ec:	de b7       	in	r29, 0x3e	; 62
    38ee:	9a 83       	std	Y+2, r25	; 0x02
    38f0:	89 83       	std	Y+1, r24	; 0x01
    38f2:	6b 83       	std	Y+3, r22	; 0x03
// xSemaphoreTake(sonarDataMutex[i],portMAX_DELAY);
   sonarData[i] = data;
    38f4:	89 81       	ldd	r24, Y+1	; 0x01
    38f6:	9a 81       	ldd	r25, Y+2	; 0x02
    38f8:	fc 01       	movw	r30, r24
    38fa:	e8 54       	subi	r30, 0x48	; 72
    38fc:	f5 4e       	sbci	r31, 0xE5	; 229
    38fe:	8b 81       	ldd	r24, Y+3	; 0x03
    3900:	80 83       	st	Z, r24
   //xSemaphoreGive(sonarDataMutex[i]);
}
    3902:	0f 90       	pop	r0
    3904:	0f 90       	pop	r0
    3906:	0f 90       	pop	r0
    3908:	cf 91       	pop	r28
    390a:	df 91       	pop	r29
    390c:	08 95       	ret

0000390e <getSonarData>:

unsigned char getSonarData(int i){
    390e:	df 93       	push	r29
    3910:	cf 93       	push	r28
    3912:	0f 92       	push	r0
    3914:	0f 92       	push	r0
    3916:	cd b7       	in	r28, 0x3d	; 61
    3918:	de b7       	in	r29, 0x3e	; 62
    391a:	9a 83       	std	Y+2, r25	; 0x02
    391c:	89 83       	std	Y+1, r24	; 0x01
   //xSemaphoreTake(sonarDataMutex[i],portMAX_DELAY);
   return sonarData[i];
    391e:	89 81       	ldd	r24, Y+1	; 0x01
    3920:	9a 81       	ldd	r25, Y+2	; 0x02
    3922:	fc 01       	movw	r30, r24
    3924:	e8 54       	subi	r30, 0x48	; 72
    3926:	f5 4e       	sbci	r31, 0xE5	; 229
    3928:	80 81       	ld	r24, Z
   //xSemaphoreGive(sonarDataMutex[i]);
}
    392a:	0f 90       	pop	r0
    392c:	0f 90       	pop	r0
    392e:	cf 91       	pop	r28
    3930:	df 91       	pop	r29
    3932:	08 95       	ret

00003934 <getTimerCount>:

unsigned char getTimerCount(){
    3934:	df 93       	push	r29
    3936:	cf 93       	push	r28
    3938:	cd b7       	in	r28, 0x3d	; 61
    393a:	de b7       	in	r29, 0x3e	; 62
   return TCNT0;
    393c:	e6 e4       	ldi	r30, 0x46	; 70
    393e:	f0 e0       	ldi	r31, 0x00	; 0
    3940:	80 81       	ld	r24, Z
}
    3942:	cf 91       	pop	r28
    3944:	df 91       	pop	r29
    3946:	08 95       	ret

00003948 <__vector_11>:

inline void setTimerCount(unsigned char i){
   TCNT0 = i;
}

ISR(PCINT2_vect) {
    3948:	1f 92       	push	r1
    394a:	0f 92       	push	r0
    394c:	0f b6       	in	r0, 0x3f	; 63
    394e:	0f 92       	push	r0
    3950:	00 90 5b 00 	lds	r0, 0x005B
    3954:	0f 92       	push	r0
    3956:	11 24       	eor	r1, r1
    3958:	2f 93       	push	r18
    395a:	3f 93       	push	r19
    395c:	4f 93       	push	r20
    395e:	5f 93       	push	r21
    3960:	6f 93       	push	r22
    3962:	7f 93       	push	r23
    3964:	8f 93       	push	r24
    3966:	9f 93       	push	r25
    3968:	af 93       	push	r26
    396a:	bf 93       	push	r27
    396c:	ef 93       	push	r30
    396e:	ff 93       	push	r31
    3970:	df 93       	push	r29
    3972:	cf 93       	push	r28
    3974:	00 d0       	rcall	.+0      	; 0x3976 <__vector_11+0x2e>
    3976:	cd b7       	in	r28, 0x3d	; 61
    3978:	de b7       	in	r29, 0x3e	; 62

   unsigned char beginCount;
   unsigned char currCount;
   char i=0;   
    397a:	19 82       	std	Y+1, r1	; 0x01

   if(PINK&(1<<currSonar)){
    397c:	e6 e0       	ldi	r30, 0x06	; 6
    397e:	f1 e0       	ldi	r31, 0x01	; 1
    3980:	80 81       	ld	r24, Z
    3982:	28 2f       	mov	r18, r24
    3984:	30 e0       	ldi	r19, 0x00	; 0
    3986:	80 91 cc 1a 	lds	r24, 0x1ACC
    398a:	88 2f       	mov	r24, r24
    398c:	90 e0       	ldi	r25, 0x00	; 0
    398e:	a9 01       	movw	r20, r18
    3990:	02 c0       	rjmp	.+4      	; 0x3996 <__vector_11+0x4e>
    3992:	55 95       	asr	r21
    3994:	47 95       	ror	r20
    3996:	8a 95       	dec	r24
    3998:	e2 f7       	brpl	.-8      	; 0x3992 <__vector_11+0x4a>
    399a:	ca 01       	movw	r24, r20
    399c:	81 70       	andi	r24, 0x01	; 1
    399e:	90 70       	andi	r25, 0x00	; 0
    39a0:	88 23       	and	r24, r24
    39a2:	41 f0       	breq	.+16     	; 0x39b4 <__vector_11+0x6c>
      beginCount = getTimerCount();
    39a4:	0e 94 9a 1c 	call	0x3934	; 0x3934 <getTimerCount>
    39a8:	8b 83       	std	Y+3, r24	; 0x03
      PORTE = 0xFF;
    39aa:	ee e2       	ldi	r30, 0x2E	; 46
    39ac:	f0 e0       	ldi	r31, 0x00	; 0
    39ae:	8f ef       	ldi	r24, 0xFF	; 255
    39b0:	80 83       	st	Z, r24
    39b2:	1a c0       	rjmp	.+52     	; 0x39e8 <__vector_11+0xa0>
   } else {
      currCount = getTimerCount();
    39b4:	0e 94 9a 1c 	call	0x3934	; 0x3934 <getTimerCount>
    39b8:	8a 83       	std	Y+2, r24	; 0x02
      if(currCount > beginCount){
    39ba:	9a 81       	ldd	r25, Y+2	; 0x02
    39bc:	8b 81       	ldd	r24, Y+3	; 0x03
    39be:	89 17       	cp	r24, r25
    39c0:	28 f4       	brcc	.+10     	; 0x39cc <__vector_11+0x84>
         lastSonarData = currCount - beginCount;
    39c2:	8a 81       	ldd	r24, Y+2	; 0x02
    39c4:	9b 81       	ldd	r25, Y+3	; 0x03
    39c6:	89 1b       	sub	r24, r25
    39c8:	80 93 b1 1a 	sts	0x1AB1, r24
      }
      PORTE = 0;
    39cc:	ee e2       	ldi	r30, 0x2E	; 46
    39ce:	f0 e0       	ldi	r31, 0x00	; 0
    39d0:	10 82       	st	Z, r1
      xSemaphoreGiveFromISR(sonarSemaphore,0);
    39d2:	80 91 be 1a 	lds	r24, 0x1ABE
    39d6:	90 91 bf 1a 	lds	r25, 0x1ABF
    39da:	60 e0       	ldi	r22, 0x00	; 0
    39dc:	70 e0       	ldi	r23, 0x00	; 0
    39de:	40 e0       	ldi	r20, 0x00	; 0
    39e0:	50 e0       	ldi	r21, 0x00	; 0
    39e2:	20 e0       	ldi	r18, 0x00	; 0
    39e4:	0e 94 40 0d 	call	0x1a80	; 0x1a80 <xQueueGenericSendFromISR>
   }

}
    39e8:	0f 90       	pop	r0
    39ea:	0f 90       	pop	r0
    39ec:	0f 90       	pop	r0
    39ee:	cf 91       	pop	r28
    39f0:	df 91       	pop	r29
    39f2:	ff 91       	pop	r31
    39f4:	ef 91       	pop	r30
    39f6:	bf 91       	pop	r27
    39f8:	af 91       	pop	r26
    39fa:	9f 91       	pop	r25
    39fc:	8f 91       	pop	r24
    39fe:	7f 91       	pop	r23
    3a00:	6f 91       	pop	r22
    3a02:	5f 91       	pop	r21
    3a04:	4f 91       	pop	r20
    3a06:	3f 91       	pop	r19
    3a08:	2f 91       	pop	r18
    3a0a:	0f 90       	pop	r0
    3a0c:	00 92 5b 00 	sts	0x005B, r0
    3a10:	0f 90       	pop	r0
    3a12:	0f be       	out	0x3f, r0	; 63
    3a14:	0f 90       	pop	r0
    3a16:	1f 90       	pop	r1
    3a18:	18 95       	reti

00003a1a <initializeSonarSensors>:

void initializeSonarSensors(){
    3a1a:	df 93       	push	r29
    3a1c:	cf 93       	push	r28
    3a1e:	cd b7       	in	r28, 0x3d	; 61
    3a20:	de b7       	in	r29, 0x3e	; 62
   //DDRD &= 0xFE;   
   DIDR2 = 0;
    3a22:	ed e7       	ldi	r30, 0x7D	; 125
    3a24:	f0 e0       	ldi	r31, 0x00	; 0
    3a26:	10 82       	st	Z, r1
   DDRK = 0;
    3a28:	e7 e0       	ldi	r30, 0x07	; 7
    3a2a:	f1 e0       	ldi	r31, 0x01	; 1
    3a2c:	10 82       	st	Z, r1
   DDRC = 0;
    3a2e:	e7 e2       	ldi	r30, 0x27	; 39
    3a30:	f0 e0       	ldi	r31, 0x00	; 0
    3a32:	10 82       	st	Z, r1

   PORTC = 0;
    3a34:	e8 e2       	ldi	r30, 0x28	; 40
    3a36:	f0 e0       	ldi	r31, 0x00	; 0
    3a38:	10 82       	st	Z, r1

   //EICRA = 1;
   //EIMSK = 1;

   PCMSK2 = 0xFF;
    3a3a:	ed e6       	ldi	r30, 0x6D	; 109
    3a3c:	f0 e0       	ldi	r31, 0x00	; 0
    3a3e:	8f ef       	ldi	r24, 0xFF	; 255
    3a40:	80 83       	st	Z, r24
   PCICR = 0x7;
    3a42:	e8 e6       	ldi	r30, 0x68	; 104
    3a44:	f0 e0       	ldi	r31, 0x00	; 0
    3a46:	87 e0       	ldi	r24, 0x07	; 7
    3a48:	80 83       	st	Z, r24

   TCCR0A = 0;
    3a4a:	e4 e4       	ldi	r30, 0x44	; 68
    3a4c:	f0 e0       	ldi	r31, 0x00	; 0
    3a4e:	10 82       	st	Z, r1
   TCCR0B = 5;
    3a50:	e5 e4       	ldi	r30, 0x45	; 69
    3a52:	f0 e0       	ldi	r31, 0x00	; 0
    3a54:	85 e0       	ldi	r24, 0x05	; 5
    3a56:	80 83       	st	Z, r24

}
    3a58:	cf 91       	pop	r28
    3a5a:	df 91       	pop	r29
    3a5c:	08 95       	ret

00003a5e <vTaskSonar>:

void vTaskSonar(void* parameter){
    3a5e:	df 93       	push	r29
    3a60:	cf 93       	push	r28
    3a62:	00 d0       	rcall	.+0      	; 0x3a64 <vTaskSonar+0x6>
    3a64:	0f 92       	push	r0
    3a66:	cd b7       	in	r28, 0x3d	; 61
    3a68:	de b7       	in	r29, 0x3e	; 62
    3a6a:	9c 83       	std	Y+4, r25	; 0x04
    3a6c:	8b 83       	std	Y+3, r24	; 0x03

   int i;
   initializeSonarSensors();
    3a6e:	0e 94 0d 1d 	call	0x3a1a	; 0x3a1a <initializeSonarSensors>
   
   vSemaphoreCreateBinary(sonarSemaphore);
    3a72:	81 e0       	ldi	r24, 0x01	; 1
    3a74:	60 e0       	ldi	r22, 0x00	; 0
    3a76:	43 e0       	ldi	r20, 0x03	; 3
    3a78:	0e 94 f8 0b 	call	0x17f0	; 0x17f0 <xQueueGenericCreate>
    3a7c:	90 93 bf 1a 	sts	0x1ABF, r25
    3a80:	80 93 be 1a 	sts	0x1ABE, r24
    3a84:	80 91 be 1a 	lds	r24, 0x1ABE
    3a88:	90 91 bf 1a 	lds	r25, 0x1ABF
    3a8c:	00 97       	sbiw	r24, 0x00	; 0
    3a8e:	59 f0       	breq	.+22     	; 0x3aa6 <vTaskSonar+0x48>
    3a90:	80 91 be 1a 	lds	r24, 0x1ABE
    3a94:	90 91 bf 1a 	lds	r25, 0x1ABF
    3a98:	60 e0       	ldi	r22, 0x00	; 0
    3a9a:	70 e0       	ldi	r23, 0x00	; 0
    3a9c:	40 e0       	ldi	r20, 0x00	; 0
    3a9e:	50 e0       	ldi	r21, 0x00	; 0
    3aa0:	20 e0       	ldi	r18, 0x00	; 0
    3aa2:	0e 94 a2 0c 	call	0x1944	; 0x1944 <xQueueGenericSend>
      
   currSonar = 0;
    3aa6:	10 92 cc 1a 	sts	0x1ACC, r1

   while(1){
      for(i=0;i<2;i++){
    3aaa:	1a 82       	std	Y+2, r1	; 0x02
    3aac:	19 82       	std	Y+1, r1	; 0x01
    3aae:	25 c0       	rjmp	.+74     	; 0x3afa <vTaskSonar+0x9c>
         currSonar = i;
    3ab0:	89 81       	ldd	r24, Y+1	; 0x01
    3ab2:	80 93 cc 1a 	sts	0x1ACC, r24
         PORTC = (1<<i);
    3ab6:	e8 e2       	ldi	r30, 0x28	; 40
    3ab8:	f0 e0       	ldi	r31, 0x00	; 0
    3aba:	81 e0       	ldi	r24, 0x01	; 1
    3abc:	90 e0       	ldi	r25, 0x00	; 0
    3abe:	09 80       	ldd	r0, Y+1	; 0x01
    3ac0:	02 c0       	rjmp	.+4      	; 0x3ac6 <vTaskSonar+0x68>
    3ac2:	88 0f       	add	r24, r24
    3ac4:	99 1f       	adc	r25, r25
    3ac6:	0a 94       	dec	r0
    3ac8:	e2 f7       	brpl	.-8      	; 0x3ac2 <vTaskSonar+0x64>
    3aca:	80 83       	st	Z, r24
         xSemaphoreTake(sonarSemaphore,portMAX_DELAY);
    3acc:	80 91 be 1a 	lds	r24, 0x1ABE
    3ad0:	90 91 bf 1a 	lds	r25, 0x1ABF
    3ad4:	60 e0       	ldi	r22, 0x00	; 0
    3ad6:	70 e0       	ldi	r23, 0x00	; 0
    3ad8:	4f ef       	ldi	r20, 0xFF	; 255
    3ada:	5f ef       	ldi	r21, 0xFF	; 255
    3adc:	20 e0       	ldi	r18, 0x00	; 0
    3ade:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <xQueueGenericReceive>
         setSonarData(i,lastSonarData);
    3ae2:	20 91 b1 1a 	lds	r18, 0x1AB1
    3ae6:	89 81       	ldd	r24, Y+1	; 0x01
    3ae8:	9a 81       	ldd	r25, Y+2	; 0x02
    3aea:	62 2f       	mov	r22, r18
    3aec:	0e 94 72 1c 	call	0x38e4	; 0x38e4 <setSonarData>
   vSemaphoreCreateBinary(sonarSemaphore);
      
   currSonar = 0;

   while(1){
      for(i=0;i<2;i++){
    3af0:	89 81       	ldd	r24, Y+1	; 0x01
    3af2:	9a 81       	ldd	r25, Y+2	; 0x02
    3af4:	01 96       	adiw	r24, 0x01	; 1
    3af6:	9a 83       	std	Y+2, r25	; 0x02
    3af8:	89 83       	std	Y+1, r24	; 0x01
    3afa:	89 81       	ldd	r24, Y+1	; 0x01
    3afc:	9a 81       	ldd	r25, Y+2	; 0x02
    3afe:	82 30       	cpi	r24, 0x02	; 2
    3b00:	91 05       	cpc	r25, r1
    3b02:	b4 f2       	brlt	.-84     	; 0x3ab0 <vTaskSonar+0x52>
    3b04:	d2 cf       	rjmp	.-92     	; 0x3aaa <vTaskSonar+0x4c>

00003b06 <getAllSensors>:
      }
   }
            
} 

char getAllSensors(int* responseData){
    3b06:	0f 93       	push	r16
    3b08:	1f 93       	push	r17
    3b0a:	df 93       	push	r29
    3b0c:	cf 93       	push	r28
    3b0e:	00 d0       	rcall	.+0      	; 0x3b10 <getAllSensors+0xa>
    3b10:	0f 92       	push	r0
    3b12:	0f 92       	push	r0
    3b14:	cd b7       	in	r28, 0x3d	; 61
    3b16:	de b7       	in	r29, 0x3e	; 62
    3b18:	9c 83       	std	Y+4, r25	; 0x04
    3b1a:	8b 83       	std	Y+3, r24	; 0x03
   int i;
   for(i=0;i<6;i++){
    3b1c:	1a 82       	std	Y+2, r1	; 0x02
    3b1e:	19 82       	std	Y+1, r1	; 0x01
    3b20:	18 c0       	rjmp	.+48     	; 0x3b52 <getAllSensors+0x4c>
      responseData[i] = getSonarData(i);
    3b22:	89 81       	ldd	r24, Y+1	; 0x01
    3b24:	9a 81       	ldd	r25, Y+2	; 0x02
    3b26:	9c 01       	movw	r18, r24
    3b28:	22 0f       	add	r18, r18
    3b2a:	33 1f       	adc	r19, r19
    3b2c:	8b 81       	ldd	r24, Y+3	; 0x03
    3b2e:	9c 81       	ldd	r25, Y+4	; 0x04
    3b30:	8c 01       	movw	r16, r24
    3b32:	02 0f       	add	r16, r18
    3b34:	13 1f       	adc	r17, r19
    3b36:	89 81       	ldd	r24, Y+1	; 0x01
    3b38:	9a 81       	ldd	r25, Y+2	; 0x02
    3b3a:	0e 94 87 1c 	call	0x390e	; 0x390e <getSonarData>
    3b3e:	88 2f       	mov	r24, r24
    3b40:	90 e0       	ldi	r25, 0x00	; 0
    3b42:	f8 01       	movw	r30, r16
    3b44:	91 83       	std	Z+1, r25	; 0x01
    3b46:	80 83       	st	Z, r24
            
} 

char getAllSensors(int* responseData){
   int i;
   for(i=0;i<6;i++){
    3b48:	89 81       	ldd	r24, Y+1	; 0x01
    3b4a:	9a 81       	ldd	r25, Y+2	; 0x02
    3b4c:	01 96       	adiw	r24, 0x01	; 1
    3b4e:	9a 83       	std	Y+2, r25	; 0x02
    3b50:	89 83       	std	Y+1, r24	; 0x01
    3b52:	89 81       	ldd	r24, Y+1	; 0x01
    3b54:	9a 81       	ldd	r25, Y+2	; 0x02
    3b56:	86 30       	cpi	r24, 0x06	; 6
    3b58:	91 05       	cpc	r25, r1
    3b5a:	1c f3       	brlt	.-58     	; 0x3b22 <getAllSensors+0x1c>
      responseData[i] = getSonarData(i);
   }
}
    3b5c:	0f 90       	pop	r0
    3b5e:	0f 90       	pop	r0
    3b60:	0f 90       	pop	r0
    3b62:	0f 90       	pop	r0
    3b64:	0f 90       	pop	r0
    3b66:	cf 91       	pop	r28
    3b68:	df 91       	pop	r29
    3b6a:	1f 91       	pop	r17
    3b6c:	0f 91       	pop	r16
    3b6e:	08 95       	ret

00003b70 <getCertainSensor>:

char getCertainSensor(char commandData,int* responseData){
    3b70:	0f 93       	push	r16
    3b72:	1f 93       	push	r17
    3b74:	df 93       	push	r29
    3b76:	cf 93       	push	r28
    3b78:	00 d0       	rcall	.+0      	; 0x3b7a <getCertainSensor+0xa>
    3b7a:	0f 92       	push	r0
    3b7c:	cd b7       	in	r28, 0x3d	; 61
    3b7e:	de b7       	in	r29, 0x3e	; 62
    3b80:	89 83       	std	Y+1, r24	; 0x01
    3b82:	7b 83       	std	Y+3, r23	; 0x03
    3b84:	6a 83       	std	Y+2, r22	; 0x02
   if(commandData < 6){
    3b86:	89 81       	ldd	r24, Y+1	; 0x01
    3b88:	86 30       	cpi	r24, 0x06	; 6
    3b8a:	bc f4       	brge	.+46     	; 0x3bba <getCertainSensor+0x4a>
      responseData[commandData] = getSonarData(commandData);
    3b8c:	89 81       	ldd	r24, Y+1	; 0x01
    3b8e:	99 27       	eor	r25, r25
    3b90:	87 fd       	sbrc	r24, 7
    3b92:	90 95       	com	r25
    3b94:	9c 01       	movw	r18, r24
    3b96:	22 0f       	add	r18, r18
    3b98:	33 1f       	adc	r19, r19
    3b9a:	8a 81       	ldd	r24, Y+2	; 0x02
    3b9c:	9b 81       	ldd	r25, Y+3	; 0x03
    3b9e:	8c 01       	movw	r16, r24
    3ba0:	02 0f       	add	r16, r18
    3ba2:	13 1f       	adc	r17, r19
    3ba4:	89 81       	ldd	r24, Y+1	; 0x01
    3ba6:	99 27       	eor	r25, r25
    3ba8:	87 fd       	sbrc	r24, 7
    3baa:	90 95       	com	r25
    3bac:	0e 94 87 1c 	call	0x390e	; 0x390e <getSonarData>
    3bb0:	88 2f       	mov	r24, r24
    3bb2:	90 e0       	ldi	r25, 0x00	; 0
    3bb4:	f8 01       	movw	r30, r16
    3bb6:	91 83       	std	Z+1, r25	; 0x01
    3bb8:	80 83       	st	Z, r24
   }
}
    3bba:	0f 90       	pop	r0
    3bbc:	0f 90       	pop	r0
    3bbe:	0f 90       	pop	r0
    3bc0:	0f 90       	pop	r0
    3bc2:	cf 91       	pop	r28
    3bc4:	df 91       	pop	r29
    3bc6:	1f 91       	pop	r17
    3bc8:	0f 91       	pop	r16
    3bca:	08 95       	ret

00003bcc <getSensorGroup>:

char getSensorGroup(char commandData,int* responseData){
    3bcc:	0f 93       	push	r16
    3bce:	1f 93       	push	r17
    3bd0:	df 93       	push	r29
    3bd2:	cf 93       	push	r28
    3bd4:	00 d0       	rcall	.+0      	; 0x3bd6 <getSensorGroup+0xa>
    3bd6:	00 d0       	rcall	.+0      	; 0x3bd8 <getSensorGroup+0xc>
    3bd8:	cd b7       	in	r28, 0x3d	; 61
    3bda:	de b7       	in	r29, 0x3e	; 62
    3bdc:	89 83       	std	Y+1, r24	; 0x01
    3bde:	7b 83       	std	Y+3, r23	; 0x03
    3be0:	6a 83       	std	Y+2, r22	; 0x02

   switch(commandData){
    3be2:	89 81       	ldd	r24, Y+1	; 0x01
    3be4:	28 2f       	mov	r18, r24
    3be6:	33 27       	eor	r19, r19
    3be8:	27 fd       	sbrc	r18, 7
    3bea:	30 95       	com	r19
    3bec:	3d 83       	std	Y+5, r19	; 0x05
    3bee:	2c 83       	std	Y+4, r18	; 0x04
    3bf0:	8c 81       	ldd	r24, Y+4	; 0x04
    3bf2:	9d 81       	ldd	r25, Y+5	; 0x05
    3bf4:	81 30       	cpi	r24, 0x01	; 1
    3bf6:	91 05       	cpc	r25, r1
    3bf8:	21 f1       	breq	.+72     	; 0x3c42 <getSensorGroup+0x76>
    3bfa:	ec 81       	ldd	r30, Y+4	; 0x04
    3bfc:	fd 81       	ldd	r31, Y+5	; 0x05
    3bfe:	e2 30       	cpi	r30, 0x02	; 2
    3c00:	f1 05       	cpc	r31, r1
    3c02:	c1 f1       	breq	.+112    	; 0x3c74 <getSensorGroup+0xa8>
    3c04:	2c 81       	ldd	r18, Y+4	; 0x04
    3c06:	3d 81       	ldd	r19, Y+5	; 0x05
    3c08:	21 15       	cp	r18, r1
    3c0a:	31 05       	cpc	r19, r1
    3c0c:	09 f0       	breq	.+2      	; 0x3c10 <getSensorGroup+0x44>
    3c0e:	4a c0       	rjmp	.+148    	; 0x3ca4 <getSensorGroup+0xd8>
      case SONAR_GROUP_LEFT:
         responseData[0] = getSonarData(0);
    3c10:	80 e0       	ldi	r24, 0x00	; 0
    3c12:	90 e0       	ldi	r25, 0x00	; 0
    3c14:	0e 94 87 1c 	call	0x390e	; 0x390e <getSonarData>
    3c18:	88 2f       	mov	r24, r24
    3c1a:	90 e0       	ldi	r25, 0x00	; 0
    3c1c:	ea 81       	ldd	r30, Y+2	; 0x02
    3c1e:	fb 81       	ldd	r31, Y+3	; 0x03
    3c20:	91 83       	std	Z+1, r25	; 0x01
    3c22:	80 83       	st	Z, r24
         responseData[1] = getSonarData(1);
    3c24:	8a 81       	ldd	r24, Y+2	; 0x02
    3c26:	9b 81       	ldd	r25, Y+3	; 0x03
    3c28:	8c 01       	movw	r16, r24
    3c2a:	0e 5f       	subi	r16, 0xFE	; 254
    3c2c:	1f 4f       	sbci	r17, 0xFF	; 255
    3c2e:	81 e0       	ldi	r24, 0x01	; 1
    3c30:	90 e0       	ldi	r25, 0x00	; 0
    3c32:	0e 94 87 1c 	call	0x390e	; 0x390e <getSonarData>
    3c36:	88 2f       	mov	r24, r24
    3c38:	90 e0       	ldi	r25, 0x00	; 0
    3c3a:	f8 01       	movw	r30, r16
    3c3c:	91 83       	std	Z+1, r25	; 0x01
    3c3e:	80 83       	st	Z, r24
    3c40:	31 c0       	rjmp	.+98     	; 0x3ca4 <getSensorGroup+0xd8>
         break;
      case SONAR_GROUP_FRONT:
         responseData[0] = getSonarData(2);
    3c42:	82 e0       	ldi	r24, 0x02	; 2
    3c44:	90 e0       	ldi	r25, 0x00	; 0
    3c46:	0e 94 87 1c 	call	0x390e	; 0x390e <getSonarData>
    3c4a:	88 2f       	mov	r24, r24
    3c4c:	90 e0       	ldi	r25, 0x00	; 0
    3c4e:	ea 81       	ldd	r30, Y+2	; 0x02
    3c50:	fb 81       	ldd	r31, Y+3	; 0x03
    3c52:	91 83       	std	Z+1, r25	; 0x01
    3c54:	80 83       	st	Z, r24
         responseData[1] = getSonarData(3);
    3c56:	8a 81       	ldd	r24, Y+2	; 0x02
    3c58:	9b 81       	ldd	r25, Y+3	; 0x03
    3c5a:	8c 01       	movw	r16, r24
    3c5c:	0e 5f       	subi	r16, 0xFE	; 254
    3c5e:	1f 4f       	sbci	r17, 0xFF	; 255
    3c60:	83 e0       	ldi	r24, 0x03	; 3
    3c62:	90 e0       	ldi	r25, 0x00	; 0
    3c64:	0e 94 87 1c 	call	0x390e	; 0x390e <getSonarData>
    3c68:	88 2f       	mov	r24, r24
    3c6a:	90 e0       	ldi	r25, 0x00	; 0
    3c6c:	f8 01       	movw	r30, r16
    3c6e:	91 83       	std	Z+1, r25	; 0x01
    3c70:	80 83       	st	Z, r24
    3c72:	18 c0       	rjmp	.+48     	; 0x3ca4 <getSensorGroup+0xd8>
         break;
      case SONAR_GROUP_RIGHT:
         responseData[0] = getSonarData(4);
    3c74:	84 e0       	ldi	r24, 0x04	; 4
    3c76:	90 e0       	ldi	r25, 0x00	; 0
    3c78:	0e 94 87 1c 	call	0x390e	; 0x390e <getSonarData>
    3c7c:	88 2f       	mov	r24, r24
    3c7e:	90 e0       	ldi	r25, 0x00	; 0
    3c80:	ea 81       	ldd	r30, Y+2	; 0x02
    3c82:	fb 81       	ldd	r31, Y+3	; 0x03
    3c84:	91 83       	std	Z+1, r25	; 0x01
    3c86:	80 83       	st	Z, r24
         responseData[1] = getSonarData(5);
    3c88:	8a 81       	ldd	r24, Y+2	; 0x02
    3c8a:	9b 81       	ldd	r25, Y+3	; 0x03
    3c8c:	8c 01       	movw	r16, r24
    3c8e:	0e 5f       	subi	r16, 0xFE	; 254
    3c90:	1f 4f       	sbci	r17, 0xFF	; 255
    3c92:	85 e0       	ldi	r24, 0x05	; 5
    3c94:	90 e0       	ldi	r25, 0x00	; 0
    3c96:	0e 94 87 1c 	call	0x390e	; 0x390e <getSonarData>
    3c9a:	88 2f       	mov	r24, r24
    3c9c:	90 e0       	ldi	r25, 0x00	; 0
    3c9e:	f8 01       	movw	r30, r16
    3ca0:	91 83       	std	Z+1, r25	; 0x01
    3ca2:	80 83       	st	Z, r24
         break;
   }

    3ca4:	26 96       	adiw	r28, 0x06	; 6
    3ca6:	0f b6       	in	r0, 0x3f	; 63
    3ca8:	f8 94       	cli
    3caa:	de bf       	out	0x3e, r29	; 62
    3cac:	0f be       	out	0x3f, r0	; 63
    3cae:	cd bf       	out	0x3d, r28	; 61
    3cb0:	cf 91       	pop	r28
    3cb2:	df 91       	pop	r29
    3cb4:	1f 91       	pop	r17
    3cb6:	0f 91       	pop	r16
    3cb8:	08 95       	ret

00003cba <getSpeed>:
//Speed Sensor group

//get the speed of the vehicle
char getSpeed(char* sensorResponse) {
    3cba:	df 93       	push	r29
    3cbc:	cf 93       	push	r28
    3cbe:	0f 92       	push	r0
    3cc0:	0f 92       	push	r0
    3cc2:	cd b7       	in	r28, 0x3d	; 61
    3cc4:	de b7       	in	r29, 0x3e	; 62
    3cc6:	9a 83       	std	Y+2, r25	; 0x02
    3cc8:	89 83       	std	Y+1, r24	; 0x01
   //store dummy speed value
   *sensorResponse = 0;
    3cca:	e9 81       	ldd	r30, Y+1	; 0x01
    3ccc:	fa 81       	ldd	r31, Y+2	; 0x02
    3cce:	10 82       	st	Z, r1
   //return success
   return 1;
    3cd0:	81 e0       	ldi	r24, 0x01	; 1
}
    3cd2:	0f 90       	pop	r0
    3cd4:	0f 90       	pop	r0
    3cd6:	cf 91       	pop	r28
    3cd8:	df 91       	pop	r29
    3cda:	08 95       	ret

00003cdc <setSpeed>:

//will set just the speed of the wheels of the car
char setSpeed(char speedTarget) {
    3cdc:	df 93       	push	r29
    3cde:	cf 93       	push	r28
    3ce0:	0f 92       	push	r0
    3ce2:	cd b7       	in	r28, 0x3d	; 61
    3ce4:	de b7       	in	r29, 0x3e	; 62
    3ce6:	89 83       	std	Y+1, r24	; 0x01
   //nothing done down here
   //return success
   return 1;
    3ce8:	81 e0       	ldi	r24, 0x01	; 1
}
    3cea:	0f 90       	pop	r0
    3cec:	cf 91       	pop	r28
    3cee:	df 91       	pop	r29
    3cf0:	08 95       	ret

00003cf2 <setAngle>:

//Steering group

//JUST SETS ANGLE TARGET. Actual angle changing is lower level
char setAngle(char angleTarget) {
    3cf2:	df 93       	push	r29
    3cf4:	cf 93       	push	r28
    3cf6:	0f 92       	push	r0
    3cf8:	cd b7       	in	r28, 0x3d	; 61
    3cfa:	de b7       	in	r29, 0x3e	; 62
    3cfc:	89 83       	std	Y+1, r24	; 0x01
   //dummy function, nothing will happen for now...
   //return success
   return 1;
    3cfe:	81 e0       	ldi	r24, 0x01	; 1
}
    3d00:	0f 90       	pop	r0
    3d02:	cf 91       	pop	r28
    3d04:	df 91       	pop	r29
    3d06:	08 95       	ret

00003d08 <getAngle>:

//get the current angle of the steering system
char getAngle(char* sensorResponse) {
    3d08:	df 93       	push	r29
    3d0a:	cf 93       	push	r28
    3d0c:	0f 92       	push	r0
    3d0e:	0f 92       	push	r0
    3d10:	cd b7       	in	r28, 0x3d	; 61
    3d12:	de b7       	in	r29, 0x3e	; 62
    3d14:	9a 83       	std	Y+2, r25	; 0x02
    3d16:	89 83       	std	Y+1, r24	; 0x01
   //store fake angle reading
   *sensorResponse = 0;
    3d18:	e9 81       	ldd	r30, Y+1	; 0x01
    3d1a:	fa 81       	ldd	r31, Y+2	; 0x02
    3d1c:	10 82       	st	Z, r1
   //return success
   return 1;
    3d1e:	81 e0       	ldi	r24, 0x01	; 1
}
    3d20:	0f 90       	pop	r0
    3d22:	0f 90       	pop	r0
    3d24:	cf 91       	pop	r28
    3d26:	df 91       	pop	r29
    3d28:	08 95       	ret

00003d2a <getDesiredAngle>:

//get the angle target. argument name is sensorResponse for the sake of consistancy
char getDesiredAngle(char* sensorResponse) {
    3d2a:	df 93       	push	r29
    3d2c:	cf 93       	push	r28
    3d2e:	0f 92       	push	r0
    3d30:	0f 92       	push	r0
    3d32:	cd b7       	in	r28, 0x3d	; 61
    3d34:	de b7       	in	r29, 0x3e	; 62
    3d36:	9a 83       	std	Y+2, r25	; 0x02
    3d38:	89 83       	std	Y+1, r24	; 0x01
   //fake response
   *sensorResponse = 0;
    3d3a:	e9 81       	ldd	r30, Y+1	; 0x01
    3d3c:	fa 81       	ldd	r31, Y+2	; 0x02
    3d3e:	10 82       	st	Z, r1
   //return success
   return 1;
    3d40:	81 e0       	ldi	r24, 0x01	; 1
}
    3d42:	0f 90       	pop	r0
    3d44:	0f 90       	pop	r0
    3d46:	cf 91       	pop	r28
    3d48:	df 91       	pop	r29
    3d4a:	08 95       	ret

00003d4c <changePID>:

//change the PID controller
char changePID(char P, char I, char D) {
    3d4c:	df 93       	push	r29
    3d4e:	cf 93       	push	r28
    3d50:	00 d0       	rcall	.+0      	; 0x3d52 <changePID+0x6>
    3d52:	cd b7       	in	r28, 0x3d	; 61
    3d54:	de b7       	in	r29, 0x3e	; 62
    3d56:	89 83       	std	Y+1, r24	; 0x01
    3d58:	6a 83       	std	Y+2, r22	; 0x02
    3d5a:	4b 83       	std	Y+3, r20	; 0x03
   //dummy function, nothing happens
   //return success
   return 1;
    3d5c:	81 e0       	ldi	r24, 0x01	; 1
}
    3d5e:	0f 90       	pop	r0
    3d60:	0f 90       	pop	r0
    3d62:	0f 90       	pop	r0
    3d64:	cf 91       	pop	r28
    3d66:	df 91       	pop	r29
    3d68:	08 95       	ret

00003d6a <setLimits>:

//not sure what this does. Also not sure why upper and lower are separated
//but its in the specs so...
char setLimits(char upper, char lower) {
    3d6a:	df 93       	push	r29
    3d6c:	cf 93       	push	r28
    3d6e:	0f 92       	push	r0
    3d70:	0f 92       	push	r0
    3d72:	cd b7       	in	r28, 0x3d	; 61
    3d74:	de b7       	in	r29, 0x3e	; 62
    3d76:	89 83       	std	Y+1, r24	; 0x01
    3d78:	6a 83       	std	Y+2, r22	; 0x02
   //dummy function, nothing happens
   //return success
   return 1;
    3d7a:	81 e0       	ldi	r24, 0x01	; 1
}
    3d7c:	0f 90       	pop	r0
    3d7e:	0f 90       	pop	r0
    3d80:	cf 91       	pop	r28
    3d82:	df 91       	pop	r29
    3d84:	08 95       	ret

00003d86 <__udivmodsi4>:
    3d86:	a1 e2       	ldi	r26, 0x21	; 33
    3d88:	1a 2e       	mov	r1, r26
    3d8a:	aa 1b       	sub	r26, r26
    3d8c:	bb 1b       	sub	r27, r27
    3d8e:	fd 01       	movw	r30, r26
    3d90:	0d c0       	rjmp	.+26     	; 0x3dac <__udivmodsi4_ep>

00003d92 <__udivmodsi4_loop>:
    3d92:	aa 1f       	adc	r26, r26
    3d94:	bb 1f       	adc	r27, r27
    3d96:	ee 1f       	adc	r30, r30
    3d98:	ff 1f       	adc	r31, r31
    3d9a:	a2 17       	cp	r26, r18
    3d9c:	b3 07       	cpc	r27, r19
    3d9e:	e4 07       	cpc	r30, r20
    3da0:	f5 07       	cpc	r31, r21
    3da2:	20 f0       	brcs	.+8      	; 0x3dac <__udivmodsi4_ep>
    3da4:	a2 1b       	sub	r26, r18
    3da6:	b3 0b       	sbc	r27, r19
    3da8:	e4 0b       	sbc	r30, r20
    3daa:	f5 0b       	sbc	r31, r21

00003dac <__udivmodsi4_ep>:
    3dac:	66 1f       	adc	r22, r22
    3dae:	77 1f       	adc	r23, r23
    3db0:	88 1f       	adc	r24, r24
    3db2:	99 1f       	adc	r25, r25
    3db4:	1a 94       	dec	r1
    3db6:	69 f7       	brne	.-38     	; 0x3d92 <__udivmodsi4_loop>
    3db8:	60 95       	com	r22
    3dba:	70 95       	com	r23
    3dbc:	80 95       	com	r24
    3dbe:	90 95       	com	r25
    3dc0:	9b 01       	movw	r18, r22
    3dc2:	ac 01       	movw	r20, r24
    3dc4:	bd 01       	movw	r22, r26
    3dc6:	cf 01       	movw	r24, r30
    3dc8:	08 95       	ret

00003dca <memcpy>:
    3dca:	fb 01       	movw	r30, r22
    3dcc:	dc 01       	movw	r26, r24
    3dce:	02 c0       	rjmp	.+4      	; 0x3dd4 <memcpy+0xa>
    3dd0:	01 90       	ld	r0, Z+
    3dd2:	0d 92       	st	X+, r0
    3dd4:	41 50       	subi	r20, 0x01	; 1
    3dd6:	50 40       	sbci	r21, 0x00	; 0
    3dd8:	d8 f7       	brcc	.-10     	; 0x3dd0 <memcpy+0x6>
    3dda:	08 95       	ret

00003ddc <memset>:
    3ddc:	dc 01       	movw	r26, r24
    3dde:	01 c0       	rjmp	.+2      	; 0x3de2 <memset+0x6>
    3de0:	6d 93       	st	X+, r22
    3de2:	41 50       	subi	r20, 0x01	; 1
    3de4:	50 40       	sbci	r21, 0x00	; 0
    3de6:	e0 f7       	brcc	.-8      	; 0x3de0 <memset+0x4>
    3de8:	08 95       	ret

00003dea <strncpy>:
    3dea:	fb 01       	movw	r30, r22
    3dec:	dc 01       	movw	r26, r24
    3dee:	41 50       	subi	r20, 0x01	; 1
    3df0:	50 40       	sbci	r21, 0x00	; 0
    3df2:	48 f0       	brcs	.+18     	; 0x3e06 <strncpy+0x1c>
    3df4:	01 90       	ld	r0, Z+
    3df6:	0d 92       	st	X+, r0
    3df8:	00 20       	and	r0, r0
    3dfa:	c9 f7       	brne	.-14     	; 0x3dee <strncpy+0x4>
    3dfc:	01 c0       	rjmp	.+2      	; 0x3e00 <strncpy+0x16>
    3dfe:	1d 92       	st	X+, r1
    3e00:	41 50       	subi	r20, 0x01	; 1
    3e02:	50 40       	sbci	r21, 0x00	; 0
    3e04:	e0 f7       	brcc	.-8      	; 0x3dfe <strncpy+0x14>
    3e06:	08 95       	ret

00003e08 <itoa>:
    3e08:	fb 01       	movw	r30, r22
    3e0a:	9f 01       	movw	r18, r30
    3e0c:	e8 94       	clt
    3e0e:	42 30       	cpi	r20, 0x02	; 2
    3e10:	c4 f0       	brlt	.+48     	; 0x3e42 <itoa+0x3a>
    3e12:	45 32       	cpi	r20, 0x25	; 37
    3e14:	b4 f4       	brge	.+44     	; 0x3e42 <itoa+0x3a>
    3e16:	4a 30       	cpi	r20, 0x0A	; 10
    3e18:	29 f4       	brne	.+10     	; 0x3e24 <itoa+0x1c>
    3e1a:	97 fb       	bst	r25, 7
    3e1c:	1e f4       	brtc	.+6      	; 0x3e24 <itoa+0x1c>
    3e1e:	90 95       	com	r25
    3e20:	81 95       	neg	r24
    3e22:	9f 4f       	sbci	r25, 0xFF	; 255
    3e24:	64 2f       	mov	r22, r20
    3e26:	77 27       	eor	r23, r23
    3e28:	0e 94 35 1f 	call	0x3e6a	; 0x3e6a <__udivmodhi4>
    3e2c:	80 5d       	subi	r24, 0xD0	; 208
    3e2e:	8a 33       	cpi	r24, 0x3A	; 58
    3e30:	0c f0       	brlt	.+2      	; 0x3e34 <itoa+0x2c>
    3e32:	89 5d       	subi	r24, 0xD9	; 217
    3e34:	81 93       	st	Z+, r24
    3e36:	cb 01       	movw	r24, r22
    3e38:	00 97       	sbiw	r24, 0x00	; 0
    3e3a:	a1 f7       	brne	.-24     	; 0x3e24 <itoa+0x1c>
    3e3c:	16 f4       	brtc	.+4      	; 0x3e42 <itoa+0x3a>
    3e3e:	5d e2       	ldi	r21, 0x2D	; 45
    3e40:	51 93       	st	Z+, r21
    3e42:	10 82       	st	Z, r1
    3e44:	c9 01       	movw	r24, r18
    3e46:	0c 94 25 1f 	jmp	0x3e4a	; 0x3e4a <strrev>

00003e4a <strrev>:
    3e4a:	dc 01       	movw	r26, r24
    3e4c:	fc 01       	movw	r30, r24
    3e4e:	67 2f       	mov	r22, r23
    3e50:	71 91       	ld	r23, Z+
    3e52:	77 23       	and	r23, r23
    3e54:	e1 f7       	brne	.-8      	; 0x3e4e <strrev+0x4>
    3e56:	32 97       	sbiw	r30, 0x02	; 2
    3e58:	04 c0       	rjmp	.+8      	; 0x3e62 <strrev+0x18>
    3e5a:	7c 91       	ld	r23, X
    3e5c:	6d 93       	st	X+, r22
    3e5e:	70 83       	st	Z, r23
    3e60:	62 91       	ld	r22, -Z
    3e62:	ae 17       	cp	r26, r30
    3e64:	bf 07       	cpc	r27, r31
    3e66:	c8 f3       	brcs	.-14     	; 0x3e5a <strrev+0x10>
    3e68:	08 95       	ret

00003e6a <__udivmodhi4>:
    3e6a:	aa 1b       	sub	r26, r26
    3e6c:	bb 1b       	sub	r27, r27
    3e6e:	51 e1       	ldi	r21, 0x11	; 17
    3e70:	07 c0       	rjmp	.+14     	; 0x3e80 <__udivmodhi4_ep>

00003e72 <__udivmodhi4_loop>:
    3e72:	aa 1f       	adc	r26, r26
    3e74:	bb 1f       	adc	r27, r27
    3e76:	a6 17       	cp	r26, r22
    3e78:	b7 07       	cpc	r27, r23
    3e7a:	10 f0       	brcs	.+4      	; 0x3e80 <__udivmodhi4_ep>
    3e7c:	a6 1b       	sub	r26, r22
    3e7e:	b7 0b       	sbc	r27, r23

00003e80 <__udivmodhi4_ep>:
    3e80:	88 1f       	adc	r24, r24
    3e82:	99 1f       	adc	r25, r25
    3e84:	5a 95       	dec	r21
    3e86:	a9 f7       	brne	.-22     	; 0x3e72 <__udivmodhi4_loop>
    3e88:	80 95       	com	r24
    3e8a:	90 95       	com	r25
    3e8c:	bc 01       	movw	r22, r24
    3e8e:	cd 01       	movw	r24, r26
    3e90:	08 95       	ret

00003e92 <_exit>:
    3e92:	f8 94       	cli

00003e94 <__stop_program>:
    3e94:	ff cf       	rjmp	.-2      	; 0x3e94 <__stop_program>
