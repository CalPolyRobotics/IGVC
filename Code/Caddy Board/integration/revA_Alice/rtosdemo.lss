
rtosdemo.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001a  00800200  00003c16  00003caa  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003c16  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000018b3  0080021a  0080021a  00003cc4  2**0
                  ALLOC
  3 .stab         00009ea0  00000000  00000000  00003cc4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00003d7c  00000000  00000000  0000db64  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  000118e0  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__ctors_end>
       4:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
       8:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
       c:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      10:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      14:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      18:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      1c:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      20:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      24:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      28:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      2c:	0c 94 66 1b 	jmp	0x36cc	; 0x36cc <__vector_11>
      30:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      34:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      38:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      3c:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      40:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      44:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      48:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      4c:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      50:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      54:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      58:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      5c:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      60:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      64:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      68:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      6c:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      70:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      74:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      78:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      7c:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      80:	0c 94 35 19 	jmp	0x326a	; 0x326a <__vector_32>
      84:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      88:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      8c:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      90:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      94:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      98:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      9c:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      a0:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      a4:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      a8:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      ac:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      b0:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      b4:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      b8:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      bc:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      c0:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      c4:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      c8:	0c 94 df 01 	jmp	0x3be	; 0x3be <__vector_50>
      cc:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      d0:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      d4:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      d8:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      dc:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      e0:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>

000000e4 <__trampolines_start>:
      e4:	0c 94 6a 1a 	jmp	0x34d4	; 0x34d4 <vTaskUARTRead>
      e8:	0c 94 21 02 	jmp	0x442	; 0x442 <vTaskFunction_1>
      ec:	0c 94 3e 1a 	jmp	0x347c	; 0x347c <vTaskUARTWrite>
      f0:	0c 94 e3 08 	jmp	0x11c6	; 0x11c6 <prvIdleTask>
      f4:	0c 94 ff 1b 	jmp	0x37fe	; 0x37fe <vTaskSonar>

000000f8 <__ctors_end>:
      f8:	11 24       	eor	r1, r1
      fa:	1f be       	out	0x3f, r1	; 63
      fc:	cf ef       	ldi	r28, 0xFF	; 255
      fe:	d1 e2       	ldi	r29, 0x21	; 33
     100:	de bf       	out	0x3e, r29	; 62
     102:	cd bf       	out	0x3d, r28	; 61
     104:	00 e0       	ldi	r16, 0x00	; 0
     106:	0c bf       	out	0x3c, r16	; 60

00000108 <__do_copy_data>:
     108:	12 e0       	ldi	r17, 0x02	; 2
     10a:	a0 e0       	ldi	r26, 0x00	; 0
     10c:	b2 e0       	ldi	r27, 0x02	; 2
     10e:	e6 e1       	ldi	r30, 0x16	; 22
     110:	fc e3       	ldi	r31, 0x3C	; 60
     112:	00 e0       	ldi	r16, 0x00	; 0
     114:	0b bf       	out	0x3b, r16	; 59
     116:	02 c0       	rjmp	.+4      	; 0x11c <__do_copy_data+0x14>
     118:	07 90       	elpm	r0, Z+
     11a:	0d 92       	st	X+, r0
     11c:	aa 31       	cpi	r26, 0x1A	; 26
     11e:	b1 07       	cpc	r27, r17
     120:	d9 f7       	brne	.-10     	; 0x118 <__do_copy_data+0x10>

00000122 <__do_clear_bss>:
     122:	1a e1       	ldi	r17, 0x1A	; 26
     124:	aa e1       	ldi	r26, 0x1A	; 26
     126:	b2 e0       	ldi	r27, 0x02	; 2
     128:	01 c0       	rjmp	.+2      	; 0x12c <.do_clear_bss_start>

0000012a <.do_clear_bss_loop>:
     12a:	1d 92       	st	X+, r1

0000012c <.do_clear_bss_start>:
     12c:	ad 3c       	cpi	r26, 0xCD	; 205
     12e:	b1 07       	cpc	r27, r17
     130:	e1 f7       	brne	.-8      	; 0x12a <.do_clear_bss_loop>
     132:	0e 94 af 00 	call	0x15e	; 0x15e <main>
     136:	0c 94 09 1e 	jmp	0x3c12	; 0x3c12 <_exit>

0000013a <__bad_interrupt>:
     13a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000013e <vApplicationTickHook>:
int count = 0;

int sonarTime;

void vApplicationTickHook()
{
     13e:	cf 93       	push	r28
     140:	df 93       	push	r29
     142:	cd b7       	in	r28, 0x3d	; 61
     144:	de b7       	in	r29, 0x3e	; 62
    count++;
     146:	80 91 1a 02 	lds	r24, 0x021A
     14a:	90 91 1b 02 	lds	r25, 0x021B
     14e:	01 96       	adiw	r24, 0x01	; 1
     150:	90 93 1b 02 	sts	0x021B, r25
     154:	80 93 1a 02 	sts	0x021A, r24
}
     158:	df 91       	pop	r29
     15a:	cf 91       	pop	r28
     15c:	08 95       	ret

0000015e <main>:
/*-----------------------------------------------------------*/

int main( void )
{
     15e:	af 92       	push	r10
     160:	bf 92       	push	r11
     162:	cf 92       	push	r12
     164:	df 92       	push	r13
     166:	ef 92       	push	r14
     168:	ff 92       	push	r15
     16a:	0f 93       	push	r16
     16c:	cf 93       	push	r28
     16e:	df 93       	push	r29
     170:	00 d0       	rcall	.+0      	; 0x172 <main+0x14>
     172:	00 d0       	rcall	.+0      	; 0x174 <main+0x16>
     174:	cd b7       	in	r28, 0x3d	; 61
     176:	de b7       	in	r29, 0x3e	; 62
    
    //- wimpy variable defs
	uint8_t val[2] = {0x3F, 0xFE};
     178:	8f e3       	ldi	r24, 0x3F	; 63
     17a:	8d 83       	std	Y+5, r24	; 0x05
     17c:	8e ef       	ldi	r24, 0xFE	; 254
     17e:	8e 83       	std	Y+6, r24	; 0x06
    uint8_t *val0, *val1;
    
	//- avoid pesky warnings...
	val0 = val + 0;
     180:	ce 01       	movw	r24, r28
     182:	05 96       	adiw	r24, 0x05	; 5
     184:	9a 83       	std	Y+2, r25	; 0x02
     186:	89 83       	std	Y+1, r24	; 0x01
	val1 = val + 1;
     188:	ce 01       	movw	r24, r28
     18a:	05 96       	adiw	r24, 0x05	; 5
     18c:	01 96       	adiw	r24, 0x01	; 1
     18e:	9c 83       	std	Y+4, r25	; 0x04
     190:	8b 83       	std	Y+3, r24	; 0x03
    
	DDRD = 0xFF;
     192:	8a e2       	ldi	r24, 0x2A	; 42
     194:	90 e0       	ldi	r25, 0x00	; 0
     196:	2f ef       	ldi	r18, 0xFF	; 255
     198:	fc 01       	movw	r30, r24
     19a:	20 83       	st	Z, r18
	DDRE = 0xFF;
     19c:	8d e2       	ldi	r24, 0x2D	; 45
     19e:	90 e0       	ldi	r25, 0x00	; 0
     1a0:	2f ef       	ldi	r18, 0xFF	; 255
     1a2:	fc 01       	movw	r30, r24
     1a4:	20 83       	st	Z, r18
	DDRK = 0;
     1a6:	87 e0       	ldi	r24, 0x07	; 7
     1a8:	91 e0       	ldi	r25, 0x01	; 1
     1aa:	fc 01       	movw	r30, r24
     1ac:	10 82       	st	Z, r1

	PORTD = 0;
     1ae:	8b e2       	ldi	r24, 0x2B	; 43
     1b0:	90 e0       	ldi	r25, 0x00	; 0
     1b2:	fc 01       	movw	r30, r24
     1b4:	10 82       	st	Z, r1
	PORTE = 0;
     1b6:	8e e2       	ldi	r24, 0x2E	; 46
     1b8:	90 e0       	ldi	r25, 0x00	; 0
     1ba:	fc 01       	movw	r30, r24
     1bc:	10 82       	st	Z, r1
	PORTK = 2;
     1be:	88 e0       	ldi	r24, 0x08	; 8
     1c0:	91 e0       	ldi	r25, 0x01	; 1
     1c2:	22 e0       	ldi	r18, 0x02	; 2
     1c4:	fc 01       	movw	r30, r24
     1c6:	20 83       	st	Z, r18

    //- init IO with goodness
	vIO_init();
     1c8:	0e 94 36 02 	call	0x46c	; 0x46c <vIO_init>

	//- Create a 
	xTaskCreate( (pdTASK_CODE) vTaskFunction_1, (signed char *) "T0", configMINIMAL_STACK_SIZE+1000,
     1cc:	8b 81       	ldd	r24, Y+3	; 0x03
     1ce:	9c 81       	ldd	r25, Y+4	; 0x04
     1d0:	a1 2c       	mov	r10, r1
     1d2:	b1 2c       	mov	r11, r1
     1d4:	c1 2c       	mov	r12, r1
     1d6:	d1 2c       	mov	r13, r1
     1d8:	e1 2c       	mov	r14, r1
     1da:	f1 2c       	mov	r15, r1
     1dc:	01 e0       	ldi	r16, 0x01	; 1
     1de:	9c 01       	movw	r18, r24
     1e0:	4d e3       	ldi	r20, 0x3D	; 61
     1e2:	54 e0       	ldi	r21, 0x04	; 4
     1e4:	62 e0       	ldi	r22, 0x02	; 2
     1e6:	72 e0       	ldi	r23, 0x02	; 2
     1e8:	81 e2       	ldi	r24, 0x21	; 33
     1ea:	92 e0       	ldi	r25, 0x02	; 2
     1ec:	0e 94 46 02 	call	0x48c	; 0x48c <xTaskGenericCreate>
                (void *) val1, 1, NULL );
    
   xTaskCreate( (pdTASK_CODE) vTaskSonar, (signed char *) "T0", configMINIMAL_STACK_SIZE,
     1f0:	8b 81       	ldd	r24, Y+3	; 0x03
     1f2:	9c 81       	ldd	r25, Y+4	; 0x04
     1f4:	a1 2c       	mov	r10, r1
     1f6:	b1 2c       	mov	r11, r1
     1f8:	c1 2c       	mov	r12, r1
     1fa:	d1 2c       	mov	r13, r1
     1fc:	e1 2c       	mov	r14, r1
     1fe:	f1 2c       	mov	r15, r1
     200:	01 e0       	ldi	r16, 0x01	; 1
     202:	9c 01       	movw	r18, r24
     204:	45 e5       	ldi	r20, 0x55	; 85
     206:	50 e0       	ldi	r21, 0x00	; 0
     208:	62 e0       	ldi	r22, 0x02	; 2
     20a:	72 e0       	ldi	r23, 0x02	; 2
     20c:	8f ef       	ldi	r24, 0xFF	; 255
     20e:	9b e1       	ldi	r25, 0x1B	; 27
     210:	0e 94 46 02 	call	0x48c	; 0x48c <xTaskGenericCreate>
                (void *) val1, 1, NULL );

   xTaskCreate( (pdTASK_CODE) vTaskUARTWrite, (signed char *) "T0", configMINIMAL_STACK_SIZE,
     214:	8b 81       	ldd	r24, Y+3	; 0x03
     216:	9c 81       	ldd	r25, Y+4	; 0x04
     218:	a1 2c       	mov	r10, r1
     21a:	b1 2c       	mov	r11, r1
     21c:	c1 2c       	mov	r12, r1
     21e:	d1 2c       	mov	r13, r1
     220:	e1 2c       	mov	r14, r1
     222:	f1 2c       	mov	r15, r1
     224:	01 e0       	ldi	r16, 0x01	; 1
     226:	9c 01       	movw	r18, r24
     228:	45 e5       	ldi	r20, 0x55	; 85
     22a:	50 e0       	ldi	r21, 0x00	; 0
     22c:	62 e0       	ldi	r22, 0x02	; 2
     22e:	72 e0       	ldi	r23, 0x02	; 2
     230:	8e e3       	ldi	r24, 0x3E	; 62
     232:	9a e1       	ldi	r25, 0x1A	; 26
     234:	0e 94 46 02 	call	0x48c	; 0x48c <xTaskGenericCreate>
   				(void *) val1, 1, NULL);

   xTaskCreate( (pdTASK_CODE) vTaskUARTRead, (signed char *) "T0", configMINIMAL_STACK_SIZE,
     238:	8b 81       	ldd	r24, Y+3	; 0x03
     23a:	9c 81       	ldd	r25, Y+4	; 0x04
     23c:	a1 2c       	mov	r10, r1
     23e:	b1 2c       	mov	r11, r1
     240:	c1 2c       	mov	r12, r1
     242:	d1 2c       	mov	r13, r1
     244:	e1 2c       	mov	r14, r1
     246:	f1 2c       	mov	r15, r1
     248:	01 e0       	ldi	r16, 0x01	; 1
     24a:	9c 01       	movw	r18, r24
     24c:	45 e5       	ldi	r20, 0x55	; 85
     24e:	50 e0       	ldi	r21, 0x00	; 0
     250:	62 e0       	ldi	r22, 0x02	; 2
     252:	72 e0       	ldi	r23, 0x02	; 2
     254:	8a e6       	ldi	r24, 0x6A	; 106
     256:	9a e1       	ldi	r25, 0x1A	; 26
     258:	0e 94 46 02 	call	0x48c	; 0x48c <xTaskGenericCreate>
   				(void *) val1, 1, NULL);

    
    //- kick off the scheduler
	vTaskStartScheduler();
     25c:	0e 94 45 05 	call	0xa8a	; 0xa8a <vTaskStartScheduler>
    
	return 0;
     260:	80 e0       	ldi	r24, 0x00	; 0
     262:	90 e0       	ldi	r25, 0x00	; 0
}
     264:	26 96       	adiw	r28, 0x06	; 6
     266:	0f b6       	in	r0, 0x3f	; 63
     268:	f8 94       	cli
     26a:	de bf       	out	0x3e, r29	; 62
     26c:	0f be       	out	0x3f, r0	; 63
     26e:	cd bf       	out	0x3d, r28	; 61
     270:	df 91       	pop	r29
     272:	cf 91       	pop	r28
     274:	0f 91       	pop	r16
     276:	ff 90       	pop	r15
     278:	ef 90       	pop	r14
     27a:	df 90       	pop	r13
     27c:	cf 90       	pop	r12
     27e:	bf 90       	pop	r11
     280:	af 90       	pop	r10
     282:	08 95       	ret

00000284 <printHex>:
/*-----------------------------------------------------------*/

void printHex(int i){
     284:	cf 93       	push	r28
     286:	df 93       	push	r29
     288:	cd b7       	in	r28, 0x3d	; 61
     28a:	de b7       	in	r29, 0x3e	; 62
     28c:	62 97       	sbiw	r28, 0x12	; 18
     28e:	0f b6       	in	r0, 0x3f	; 63
     290:	f8 94       	cli
     292:	de bf       	out	0x3e, r29	; 62
     294:	0f be       	out	0x3f, r0	; 63
     296:	cd bf       	out	0x3d, r28	; 61
     298:	9a 8b       	std	Y+18, r25	; 0x12
     29a:	89 8b       	std	Y+17, r24	; 0x11
	char hex[] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
     29c:	20 e1       	ldi	r18, 0x10	; 16
     29e:	e5 e0       	ldi	r30, 0x05	; 5
     2a0:	f2 e0       	ldi	r31, 0x02	; 2
     2a2:	ce 01       	movw	r24, r28
     2a4:	01 96       	adiw	r24, 0x01	; 1
     2a6:	dc 01       	movw	r26, r24
     2a8:	01 90       	ld	r0, Z+
     2aa:	0d 92       	st	X+, r0
     2ac:	2a 95       	dec	r18
     2ae:	e1 f7       	brne	.-8      	; 0x2a8 <printHex+0x24>

	USART_Write(hex[(i&0xF000) >> 12]);
     2b0:	89 89       	ldd	r24, Y+17	; 0x11
     2b2:	9a 89       	ldd	r25, Y+18	; 0x12
     2b4:	89 2f       	mov	r24, r25
     2b6:	99 27       	eor	r25, r25
     2b8:	82 95       	swap	r24
     2ba:	8f 70       	andi	r24, 0x0F	; 15
     2bc:	9e 01       	movw	r18, r28
     2be:	2f 5f       	subi	r18, 0xFF	; 255
     2c0:	3f 4f       	sbci	r19, 0xFF	; 255
     2c2:	82 0f       	add	r24, r18
     2c4:	93 1f       	adc	r25, r19
     2c6:	fc 01       	movw	r30, r24
     2c8:	80 81       	ld	r24, Z
     2ca:	0e 94 a5 19 	call	0x334a	; 0x334a <USART_Write>
	USART_Write(hex[(i&0xF00) >> 8]);
     2ce:	89 89       	ldd	r24, Y+17	; 0x11
     2d0:	9a 89       	ldd	r25, Y+18	; 0x12
     2d2:	88 27       	eor	r24, r24
     2d4:	9f 70       	andi	r25, 0x0F	; 15
     2d6:	89 2f       	mov	r24, r25
     2d8:	99 0f       	add	r25, r25
     2da:	99 0b       	sbc	r25, r25
     2dc:	9e 01       	movw	r18, r28
     2de:	2f 5f       	subi	r18, 0xFF	; 255
     2e0:	3f 4f       	sbci	r19, 0xFF	; 255
     2e2:	82 0f       	add	r24, r18
     2e4:	93 1f       	adc	r25, r19
     2e6:	fc 01       	movw	r30, r24
     2e8:	80 81       	ld	r24, Z
     2ea:	0e 94 a5 19 	call	0x334a	; 0x334a <USART_Write>
	USART_Write(hex[(i&0xF0) >> 4]);
     2ee:	89 89       	ldd	r24, Y+17	; 0x11
     2f0:	9a 89       	ldd	r25, Y+18	; 0x12
     2f2:	80 7f       	andi	r24, 0xF0	; 240
     2f4:	99 27       	eor	r25, r25
     2f6:	95 95       	asr	r25
     2f8:	87 95       	ror	r24
     2fa:	95 95       	asr	r25
     2fc:	87 95       	ror	r24
     2fe:	95 95       	asr	r25
     300:	87 95       	ror	r24
     302:	95 95       	asr	r25
     304:	87 95       	ror	r24
     306:	9e 01       	movw	r18, r28
     308:	2f 5f       	subi	r18, 0xFF	; 255
     30a:	3f 4f       	sbci	r19, 0xFF	; 255
     30c:	82 0f       	add	r24, r18
     30e:	93 1f       	adc	r25, r19
     310:	fc 01       	movw	r30, r24
     312:	80 81       	ld	r24, Z
     314:	0e 94 a5 19 	call	0x334a	; 0x334a <USART_Write>
	USART_Write(hex[i&0xF]);
     318:	89 89       	ldd	r24, Y+17	; 0x11
     31a:	9a 89       	ldd	r25, Y+18	; 0x12
     31c:	8f 70       	andi	r24, 0x0F	; 15
     31e:	99 27       	eor	r25, r25
     320:	9e 01       	movw	r18, r28
     322:	2f 5f       	subi	r18, 0xFF	; 255
     324:	3f 4f       	sbci	r19, 0xFF	; 255
     326:	82 0f       	add	r24, r18
     328:	93 1f       	adc	r25, r19
     32a:	fc 01       	movw	r30, r24
     32c:	80 81       	ld	r24, Z
     32e:	0e 94 a5 19 	call	0x334a	; 0x334a <USART_Write>

}
     332:	62 96       	adiw	r28, 0x12	; 18
     334:	0f b6       	in	r0, 0x3f	; 63
     336:	f8 94       	cli
     338:	de bf       	out	0x3e, r29	; 62
     33a:	0f be       	out	0x3f, r0	; 63
     33c:	cd bf       	out	0x3d, r28	; 61
     33e:	df 91       	pop	r29
     340:	cf 91       	pop	r28
     342:	08 95       	ret

00000344 <printNum>:

void printNum(unsigned char i){
     344:	cf 93       	push	r28
     346:	df 93       	push	r29
     348:	cd b7       	in	r28, 0x3d	; 61
     34a:	de b7       	in	r29, 0x3e	; 62
     34c:	2d 97       	sbiw	r28, 0x0d	; 13
     34e:	0f b6       	in	r0, 0x3f	; 63
     350:	f8 94       	cli
     352:	de bf       	out	0x3e, r29	; 62
     354:	0f be       	out	0x3f, r0	; 63
     356:	cd bf       	out	0x3d, r28	; 61
     358:	8d 87       	std	Y+13, r24	; 0x0d
    
    char str[10];
    memset(str,0,10);
     35a:	ce 01       	movw	r24, r28
     35c:	03 96       	adiw	r24, 0x03	; 3
     35e:	4a e0       	ldi	r20, 0x0A	; 10
     360:	50 e0       	ldi	r21, 0x00	; 0
     362:	60 e0       	ldi	r22, 0x00	; 0
     364:	70 e0       	ldi	r23, 0x00	; 0
     366:	0e 94 ae 1d 	call	0x3b5c	; 0x3b5c <memset>
    itoa(i,str,9);
     36a:	8d 85       	ldd	r24, Y+13	; 0x0d
     36c:	88 2f       	mov	r24, r24
     36e:	90 e0       	ldi	r25, 0x00	; 0
     370:	9e 01       	movw	r18, r28
     372:	2d 5f       	subi	r18, 0xFD	; 253
     374:	3f 4f       	sbci	r19, 0xFF	; 255
     376:	49 e0       	ldi	r20, 0x09	; 9
     378:	50 e0       	ldi	r21, 0x00	; 0
     37a:	b9 01       	movw	r22, r18
     37c:	0e 94 c4 1d 	call	0x3b88	; 0x3b88 <itoa>
    char * irr = str;
     380:	ce 01       	movw	r24, r28
     382:	03 96       	adiw	r24, 0x03	; 3
     384:	9a 83       	std	Y+2, r25	; 0x02
     386:	89 83       	std	Y+1, r24	; 0x01
    while(*irr){
     388:	0b c0       	rjmp	.+22     	; 0x3a0 <printNum+0x5c>
        USART_Write((unsigned char )*irr);
     38a:	89 81       	ldd	r24, Y+1	; 0x01
     38c:	9a 81       	ldd	r25, Y+2	; 0x02
     38e:	fc 01       	movw	r30, r24
     390:	80 81       	ld	r24, Z
     392:	0e 94 a5 19 	call	0x334a	; 0x334a <USART_Write>
        irr++;
     396:	89 81       	ldd	r24, Y+1	; 0x01
     398:	9a 81       	ldd	r25, Y+2	; 0x02
     39a:	01 96       	adiw	r24, 0x01	; 1
     39c:	9a 83       	std	Y+2, r25	; 0x02
     39e:	89 83       	std	Y+1, r24	; 0x01
    
    char str[10];
    memset(str,0,10);
    itoa(i,str,9);
    char * irr = str;
    while(*irr){
     3a0:	89 81       	ldd	r24, Y+1	; 0x01
     3a2:	9a 81       	ldd	r25, Y+2	; 0x02
     3a4:	fc 01       	movw	r30, r24
     3a6:	80 81       	ld	r24, Z
     3a8:	88 23       	and	r24, r24
     3aa:	79 f7       	brne	.-34     	; 0x38a <printNum+0x46>
        USART_Write((unsigned char )*irr);
        irr++;
    }
    
}
     3ac:	2d 96       	adiw	r28, 0x0d	; 13
     3ae:	0f b6       	in	r0, 0x3f	; 63
     3b0:	f8 94       	cli
     3b2:	de bf       	out	0x3e, r29	; 62
     3b4:	0f be       	out	0x3f, r0	; 63
     3b6:	cd bf       	out	0x3d, r28	; 61
     3b8:	df 91       	pop	r29
     3ba:	cf 91       	pop	r28
     3bc:	08 95       	ret

000003be <__vector_50>:

ISR(TIMER5_OVF_vect){
     3be:	1f 92       	push	r1
     3c0:	0f 92       	push	r0
     3c2:	00 90 5f 00 	lds	r0, 0x005F
     3c6:	0f 92       	push	r0
     3c8:	11 24       	eor	r1, r1
     3ca:	00 90 5b 00 	lds	r0, 0x005B
     3ce:	0f 92       	push	r0
     3d0:	2f 93       	push	r18
     3d2:	3f 93       	push	r19
     3d4:	8f 93       	push	r24
     3d6:	9f 93       	push	r25
     3d8:	ef 93       	push	r30
     3da:	ff 93       	push	r31
     3dc:	cf 93       	push	r28
     3de:	df 93       	push	r29
     3e0:	cd b7       	in	r28, 0x3d	; 61
     3e2:	de b7       	in	r29, 0x3e	; 62

	PORTB ^= 0xFF;
     3e4:	85 e2       	ldi	r24, 0x25	; 37
     3e6:	90 e0       	ldi	r25, 0x00	; 0
     3e8:	25 e2       	ldi	r18, 0x25	; 37
     3ea:	30 e0       	ldi	r19, 0x00	; 0
     3ec:	f9 01       	movw	r30, r18
     3ee:	20 81       	ld	r18, Z
     3f0:	20 95       	com	r18
     3f2:	fc 01       	movw	r30, r24
     3f4:	20 83       	st	Z, r18
	TCNT3L = 0;
     3f6:	84 e9       	ldi	r24, 0x94	; 148
     3f8:	90 e0       	ldi	r25, 0x00	; 0
     3fa:	fc 01       	movw	r30, r24
     3fc:	10 82       	st	Z, r1
	TCNT3H = 0;
     3fe:	85 e9       	ldi	r24, 0x95	; 149
     400:	90 e0       	ldi	r25, 0x00	; 0
     402:	fc 01       	movw	r30, r24
     404:	10 82       	st	Z, r1

}
     406:	df 91       	pop	r29
     408:	cf 91       	pop	r28
     40a:	ff 91       	pop	r31
     40c:	ef 91       	pop	r30
     40e:	9f 91       	pop	r25
     410:	8f 91       	pop	r24
     412:	3f 91       	pop	r19
     414:	2f 91       	pop	r18
     416:	0f 90       	pop	r0
     418:	00 92 5b 00 	sts	0x005B, r0
     41c:	0f 90       	pop	r0
     41e:	00 92 5f 00 	sts	0x005F, r0
     422:	0f 90       	pop	r0
     424:	1f 90       	pop	r1
     426:	18 95       	reti

00000428 <getTimerCount2>:

unsigned int getTimerCount2(){
     428:	cf 93       	push	r28
     42a:	df 93       	push	r29
     42c:	cd b7       	in	r28, 0x3d	; 61
     42e:	de b7       	in	r29, 0x3e	; 62

	//volatile char timerLow = TCNT3L;

	return TCNT0;
     430:	86 e4       	ldi	r24, 0x46	; 70
     432:	90 e0       	ldi	r25, 0x00	; 0
     434:	fc 01       	movw	r30, r24
     436:	80 81       	ld	r24, Z
     438:	88 2f       	mov	r24, r24
     43a:	90 e0       	ldi	r25, 0x00	; 0

}
     43c:	df 91       	pop	r29
     43e:	cf 91       	pop	r28
     440:	08 95       	ret

00000442 <vTaskFunction_1>:

void vTaskFunction_1(void *pvParameters)
{	
     442:	cf 93       	push	r28
     444:	df 93       	push	r29
     446:	1f 92       	push	r1
     448:	1f 92       	push	r1
     44a:	cd b7       	in	r28, 0x3d	; 61
     44c:	de b7       	in	r29, 0x3e	; 62
     44e:	9a 83       	std	Y+2, r25	; 0x02
     450:	89 83       	std	Y+1, r24	; 0x01
    USART_Init(9600, 16000000);
     452:	40 e0       	ldi	r20, 0x00	; 0
     454:	54 e2       	ldi	r21, 0x24	; 36
     456:	64 ef       	ldi	r22, 0xF4	; 244
     458:	70 e0       	ldi	r23, 0x00	; 0
     45a:	80 e8       	ldi	r24, 0x80	; 128
     45c:	95 e2       	ldi	r25, 0x25	; 37
     45e:	0e 94 38 19 	call	0x3270	; 0x3270 <USART_Init>
		//PORTB = 0;
		//USART_AddToQueue('%');
		//USART_TransmitString("Hello World!\n");

		//USART_TransmitString("H\n");
		vTaskDelay(25);
     462:	89 e1       	ldi	r24, 0x19	; 25
     464:	90 e0       	ldi	r25, 0x00	; 0
     466:	0e 94 b3 03 	call	0x766	; 0x766 <vTaskDelay>
	}
     46a:	fb cf       	rjmp	.-10     	; 0x462 <vTaskFunction_1+0x20>

0000046c <vIO_init>:
        // UDR0;
    }
}

void vIO_init(void)
{
     46c:	cf 93       	push	r28
     46e:	df 93       	push	r29
     470:	cd b7       	in	r28, 0x3d	; 61
     472:	de b7       	in	r29, 0x3e	; 62
    //- set PortB as output
	DDRB = 0xFF; 
     474:	84 e2       	ldi	r24, 0x24	; 36
     476:	90 e0       	ldi	r25, 0x00	; 0
     478:	2f ef       	ldi	r18, 0xFF	; 255
     47a:	fc 01       	movw	r30, r24
     47c:	20 83       	st	Z, r18
    PORTB = 0; 
     47e:	85 e2       	ldi	r24, 0x25	; 37
     480:	90 e0       	ldi	r25, 0x00	; 0
     482:	fc 01       	movw	r30, r24
     484:	10 82       	st	Z, r1
}
     486:	df 91       	pop	r29
     488:	cf 91       	pop	r28
     48a:	08 95       	ret

0000048c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
     48c:	af 92       	push	r10
     48e:	bf 92       	push	r11
     490:	cf 92       	push	r12
     492:	df 92       	push	r13
     494:	ef 92       	push	r14
     496:	ff 92       	push	r15
     498:	0f 93       	push	r16
     49a:	1f 93       	push	r17
     49c:	cf 93       	push	r28
     49e:	df 93       	push	r29
     4a0:	cd b7       	in	r28, 0x3d	; 61
     4a2:	de b7       	in	r29, 0x3e	; 62
     4a4:	64 97       	sbiw	r28, 0x14	; 20
     4a6:	0f b6       	in	r0, 0x3f	; 63
     4a8:	f8 94       	cli
     4aa:	de bf       	out	0x3e, r29	; 62
     4ac:	0f be       	out	0x3f, r0	; 63
     4ae:	cd bf       	out	0x3d, r28	; 61
     4b0:	9f 83       	std	Y+7, r25	; 0x07
     4b2:	8e 83       	std	Y+6, r24	; 0x06
     4b4:	79 87       	std	Y+9, r23	; 0x09
     4b6:	68 87       	std	Y+8, r22	; 0x08
     4b8:	5b 87       	std	Y+11, r21	; 0x0b
     4ba:	4a 87       	std	Y+10, r20	; 0x0a
     4bc:	3d 87       	std	Y+13, r19	; 0x0d
     4be:	2c 87       	std	Y+12, r18	; 0x0c
     4c0:	0e 87       	std	Y+14, r16	; 0x0e
     4c2:	f8 8a       	std	Y+16, r15	; 0x10
     4c4:	ef 86       	std	Y+15, r14	; 0x0f
     4c6:	da 8a       	std	Y+18, r13	; 0x12
     4c8:	c9 8a       	std	Y+17, r12	; 0x11
     4ca:	bc 8a       	std	Y+20, r11	; 0x14
     4cc:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
     4ce:	29 89       	ldd	r18, Y+17	; 0x11
     4d0:	3a 89       	ldd	r19, Y+18	; 0x12
     4d2:	8a 85       	ldd	r24, Y+10	; 0x0a
     4d4:	9b 85       	ldd	r25, Y+11	; 0x0b
     4d6:	b9 01       	movw	r22, r18
     4d8:	0e 94 e5 09 	call	0x13ca	; 0x13ca <prvAllocateTCBAndStack>
     4dc:	9b 83       	std	Y+3, r25	; 0x03
     4de:	8a 83       	std	Y+2, r24	; 0x02

	if( pxNewTCB != NULL )
     4e0:	8a 81       	ldd	r24, Y+2	; 0x02
     4e2:	9b 81       	ldd	r25, Y+3	; 0x03
     4e4:	00 97       	sbiw	r24, 0x00	; 0
     4e6:	09 f4       	brne	.+2      	; 0x4ea <xTaskGenericCreate+0x5e>
     4e8:	9f c0       	rjmp	.+318    	; 0x628 <xTaskGenericCreate+0x19c>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
     4ea:	8a 81       	ldd	r24, Y+2	; 0x02
     4ec:	9b 81       	ldd	r25, Y+3	; 0x03
     4ee:	fc 01       	movw	r30, r24
     4f0:	27 89       	ldd	r18, Z+23	; 0x17
     4f2:	30 8d       	ldd	r19, Z+24	; 0x18
     4f4:	8a 85       	ldd	r24, Y+10	; 0x0a
     4f6:	9b 85       	ldd	r25, Y+11	; 0x0b
     4f8:	01 97       	sbiw	r24, 0x01	; 1
     4fa:	82 0f       	add	r24, r18
     4fc:	93 1f       	adc	r25, r19
     4fe:	9d 83       	std	Y+5, r25	; 0x05
     500:	8c 83       	std	Y+4, r24	; 0x04
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
     502:	4a 85       	ldd	r20, Y+10	; 0x0a
     504:	5b 85       	ldd	r21, Y+11	; 0x0b
     506:	2b 89       	ldd	r18, Y+19	; 0x13
     508:	3c 89       	ldd	r19, Y+20	; 0x14
     50a:	68 85       	ldd	r22, Y+8	; 0x08
     50c:	79 85       	ldd	r23, Y+9	; 0x09
     50e:	8a 81       	ldd	r24, Y+2	; 0x02
     510:	9b 81       	ldd	r25, Y+3	; 0x03
     512:	8a 01       	movw	r16, r20
     514:	4e 85       	ldd	r20, Y+14	; 0x0e
     516:	0e 94 f5 08 	call	0x11ea	; 0x11ea <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     51a:	4c 85       	ldd	r20, Y+12	; 0x0c
     51c:	5d 85       	ldd	r21, Y+13	; 0x0d
     51e:	2e 81       	ldd	r18, Y+6	; 0x06
     520:	3f 81       	ldd	r19, Y+7	; 0x07
     522:	8c 81       	ldd	r24, Y+4	; 0x04
     524:	9d 81       	ldd	r25, Y+5	; 0x05
     526:	b9 01       	movw	r22, r18
     528:	0e 94 0d 16 	call	0x2c1a	; 0x2c1a <pxPortInitialiseStack>
     52c:	9c 01       	movw	r18, r24
     52e:	8a 81       	ldd	r24, Y+2	; 0x02
     530:	9b 81       	ldd	r25, Y+3	; 0x03
     532:	fc 01       	movw	r30, r24
     534:	31 83       	std	Z+1, r19	; 0x01
     536:	20 83       	st	Z, r18
		#endif

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
     538:	8f 85       	ldd	r24, Y+15	; 0x0f
     53a:	98 89       	ldd	r25, Y+16	; 0x10
     53c:	00 97       	sbiw	r24, 0x00	; 0
     53e:	39 f0       	breq	.+14     	; 0x54e <xTaskGenericCreate+0xc2>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
     540:	8f 85       	ldd	r24, Y+15	; 0x0f
     542:	98 89       	ldd	r25, Y+16	; 0x10
     544:	2a 81       	ldd	r18, Y+2	; 0x02
     546:	3b 81       	ldd	r19, Y+3	; 0x03
     548:	fc 01       	movw	r30, r24
     54a:	31 83       	std	Z+1, r19	; 0x01
     54c:	20 83       	st	Z, r18
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
     54e:	0f b6       	in	r0, 0x3f	; 63
     550:	f8 94       	cli
     552:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
     554:	80 91 6a 02 	lds	r24, 0x026A
     558:	8f 5f       	subi	r24, 0xFF	; 255
     55a:	80 93 6a 02 	sts	0x026A, r24
			if( pxCurrentTCB == NULL )
     55e:	80 91 1c 02 	lds	r24, 0x021C
     562:	90 91 1d 02 	lds	r25, 0x021D
     566:	00 97       	sbiw	r24, 0x00	; 0
     568:	69 f4       	brne	.+26     	; 0x584 <xTaskGenericCreate+0xf8>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
     56a:	8a 81       	ldd	r24, Y+2	; 0x02
     56c:	9b 81       	ldd	r25, Y+3	; 0x03
     56e:	90 93 1d 02 	sts	0x021D, r25
     572:	80 93 1c 02 	sts	0x021C, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
     576:	80 91 6a 02 	lds	r24, 0x026A
     57a:	81 30       	cpi	r24, 0x01	; 1
     57c:	b1 f4       	brne	.+44     	; 0x5aa <xTaskGenericCreate+0x11e>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
     57e:	0e 94 56 09 	call	0x12ac	; 0x12ac <prvInitialiseTaskLists>
     582:	13 c0       	rjmp	.+38     	; 0x5aa <xTaskGenericCreate+0x11e>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
     584:	80 91 6f 02 	lds	r24, 0x026F
     588:	88 23       	and	r24, r24
     58a:	79 f4       	brne	.+30     	; 0x5aa <xTaskGenericCreate+0x11e>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
     58c:	80 91 1c 02 	lds	r24, 0x021C
     590:	90 91 1d 02 	lds	r25, 0x021D
     594:	fc 01       	movw	r30, r24
     596:	96 89       	ldd	r25, Z+22	; 0x16
     598:	8e 85       	ldd	r24, Y+14	; 0x0e
     59a:	89 17       	cp	r24, r25
     59c:	30 f0       	brcs	.+12     	; 0x5aa <xTaskGenericCreate+0x11e>
					{
						pxCurrentTCB = pxNewTCB;
     59e:	8a 81       	ldd	r24, Y+2	; 0x02
     5a0:	9b 81       	ldd	r25, Y+3	; 0x03
     5a2:	90 93 1d 02 	sts	0x021D, r25
     5a6:	80 93 1c 02 	sts	0x021C, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
     5aa:	8a 81       	ldd	r24, Y+2	; 0x02
     5ac:	9b 81       	ldd	r25, Y+3	; 0x03
     5ae:	fc 01       	movw	r30, r24
     5b0:	96 89       	ldd	r25, Z+22	; 0x16
     5b2:	80 91 6d 02 	lds	r24, 0x026D
     5b6:	89 17       	cp	r24, r25
     5b8:	30 f4       	brcc	.+12     	; 0x5c6 <xTaskGenericCreate+0x13a>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
     5ba:	8a 81       	ldd	r24, Y+2	; 0x02
     5bc:	9b 81       	ldd	r25, Y+3	; 0x03
     5be:	fc 01       	movw	r30, r24
     5c0:	86 89       	ldd	r24, Z+22	; 0x16
     5c2:	80 93 6d 02 	sts	0x026D, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
     5c6:	80 91 74 02 	lds	r24, 0x0274
     5ca:	8f 5f       	subi	r24, 0xFF	; 255
     5cc:	80 93 74 02 	sts	0x0274, r24

			prvAddTaskToReadyQueue( pxNewTCB );
     5d0:	8a 81       	ldd	r24, Y+2	; 0x02
     5d2:	9b 81       	ldd	r25, Y+3	; 0x03
     5d4:	fc 01       	movw	r30, r24
     5d6:	96 89       	ldd	r25, Z+22	; 0x16
     5d8:	80 91 6e 02 	lds	r24, 0x026E
     5dc:	89 17       	cp	r24, r25
     5de:	30 f4       	brcc	.+12     	; 0x5ec <xTaskGenericCreate+0x160>
     5e0:	8a 81       	ldd	r24, Y+2	; 0x02
     5e2:	9b 81       	ldd	r25, Y+3	; 0x03
     5e4:	fc 01       	movw	r30, r24
     5e6:	86 89       	ldd	r24, Z+22	; 0x16
     5e8:	80 93 6e 02 	sts	0x026E, r24
     5ec:	8a 81       	ldd	r24, Y+2	; 0x02
     5ee:	9b 81       	ldd	r25, Y+3	; 0x03
     5f0:	ac 01       	movw	r20, r24
     5f2:	4e 5f       	subi	r20, 0xFE	; 254
     5f4:	5f 4f       	sbci	r21, 0xFF	; 255
     5f6:	8a 81       	ldd	r24, Y+2	; 0x02
     5f8:	9b 81       	ldd	r25, Y+3	; 0x03
     5fa:	fc 01       	movw	r30, r24
     5fc:	86 89       	ldd	r24, Z+22	; 0x16
     5fe:	28 2f       	mov	r18, r24
     600:	30 e0       	ldi	r19, 0x00	; 0
     602:	c9 01       	movw	r24, r18
     604:	88 0f       	add	r24, r24
     606:	99 1f       	adc	r25, r25
     608:	88 0f       	add	r24, r24
     60a:	99 1f       	adc	r25, r25
     60c:	88 0f       	add	r24, r24
     60e:	99 1f       	adc	r25, r25
     610:	82 0f       	add	r24, r18
     612:	93 1f       	adc	r25, r19
     614:	82 5e       	subi	r24, 0xE2	; 226
     616:	9d 4f       	sbci	r25, 0xFD	; 253
     618:	ba 01       	movw	r22, r20
     61a:	0e 94 7f 11 	call	0x22fe	; 0x22fe <vListInsertEnd>

			xReturn = pdPASS;
     61e:	81 e0       	ldi	r24, 0x01	; 1
     620:	89 83       	std	Y+1, r24	; 0x01
			portSETUP_TCB( pxNewTCB );
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
     622:	0f 90       	pop	r0
     624:	0f be       	out	0x3f, r0	; 63
     626:	02 c0       	rjmp	.+4      	; 0x62c <xTaskGenericCreate+0x1a0>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     628:	8f ef       	ldi	r24, 0xFF	; 255
     62a:	89 83       	std	Y+1, r24	; 0x01
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
     62c:	89 81       	ldd	r24, Y+1	; 0x01
     62e:	81 30       	cpi	r24, 0x01	; 1
     630:	79 f4       	brne	.+30     	; 0x650 <xTaskGenericCreate+0x1c4>
	{
		if( xSchedulerRunning != pdFALSE )
     632:	80 91 6f 02 	lds	r24, 0x026F
     636:	88 23       	and	r24, r24
     638:	59 f0       	breq	.+22     	; 0x650 <xTaskGenericCreate+0x1c4>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
     63a:	80 91 1c 02 	lds	r24, 0x021C
     63e:	90 91 1d 02 	lds	r25, 0x021D
     642:	fc 01       	movw	r30, r24
     644:	96 89       	ldd	r25, Z+22	; 0x16
     646:	8e 85       	ldd	r24, Y+14	; 0x0e
     648:	98 17       	cp	r25, r24
     64a:	10 f4       	brcc	.+4      	; 0x650 <xTaskGenericCreate+0x1c4>
			{
				portYIELD_WITHIN_API();
     64c:	0e 94 11 18 	call	0x3022	; 0x3022 <vPortYield>
			}
		}
	}

	return xReturn;
     650:	89 81       	ldd	r24, Y+1	; 0x01
}
     652:	64 96       	adiw	r28, 0x14	; 20
     654:	0f b6       	in	r0, 0x3f	; 63
     656:	f8 94       	cli
     658:	de bf       	out	0x3e, r29	; 62
     65a:	0f be       	out	0x3f, r0	; 63
     65c:	cd bf       	out	0x3d, r28	; 61
     65e:	df 91       	pop	r29
     660:	cf 91       	pop	r28
     662:	1f 91       	pop	r17
     664:	0f 91       	pop	r16
     666:	ff 90       	pop	r15
     668:	ef 90       	pop	r14
     66a:	df 90       	pop	r13
     66c:	cf 90       	pop	r12
     66e:	bf 90       	pop	r11
     670:	af 90       	pop	r10
     672:	08 95       	ret

00000674 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
     674:	cf 93       	push	r28
     676:	df 93       	push	r29
     678:	cd b7       	in	r28, 0x3d	; 61
     67a:	de b7       	in	r29, 0x3e	; 62
     67c:	28 97       	sbiw	r28, 0x08	; 8
     67e:	0f b6       	in	r0, 0x3f	; 63
     680:	f8 94       	cli
     682:	de bf       	out	0x3e, r29	; 62
     684:	0f be       	out	0x3f, r0	; 63
     686:	cd bf       	out	0x3d, r28	; 61
     688:	9e 83       	std	Y+6, r25	; 0x06
     68a:	8d 83       	std	Y+5, r24	; 0x05
     68c:	78 87       	std	Y+8, r23	; 0x08
     68e:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
     690:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
     692:	0e 94 87 05 	call	0xb0e	; 0xb0e <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     696:	8d 81       	ldd	r24, Y+5	; 0x05
     698:	9e 81       	ldd	r25, Y+6	; 0x06
     69a:	fc 01       	movw	r30, r24
     69c:	20 81       	ld	r18, Z
     69e:	31 81       	ldd	r19, Z+1	; 0x01
     6a0:	8f 81       	ldd	r24, Y+7	; 0x07
     6a2:	98 85       	ldd	r25, Y+8	; 0x08
     6a4:	82 0f       	add	r24, r18
     6a6:	93 1f       	adc	r25, r19
     6a8:	9b 83       	std	Y+3, r25	; 0x03
     6aa:	8a 83       	std	Y+2, r24	; 0x02

			if( xTickCount < *pxPreviousWakeTime )
     6ac:	8d 81       	ldd	r24, Y+5	; 0x05
     6ae:	9e 81       	ldd	r25, Y+6	; 0x06
     6b0:	fc 01       	movw	r30, r24
     6b2:	20 81       	ld	r18, Z
     6b4:	31 81       	ldd	r19, Z+1	; 0x01
     6b6:	80 91 6b 02 	lds	r24, 0x026B
     6ba:	90 91 6c 02 	lds	r25, 0x026C
     6be:	82 17       	cp	r24, r18
     6c0:	93 07       	cpc	r25, r19
     6c2:	b0 f4       	brcc	.+44     	; 0x6f0 <vTaskDelayUntil+0x7c>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
     6c4:	8d 81       	ldd	r24, Y+5	; 0x05
     6c6:	9e 81       	ldd	r25, Y+6	; 0x06
     6c8:	fc 01       	movw	r30, r24
     6ca:	20 81       	ld	r18, Z
     6cc:	31 81       	ldd	r19, Z+1	; 0x01
     6ce:	8a 81       	ldd	r24, Y+2	; 0x02
     6d0:	9b 81       	ldd	r25, Y+3	; 0x03
     6d2:	82 17       	cp	r24, r18
     6d4:	93 07       	cpc	r25, r19
     6d6:	08 f5       	brcc	.+66     	; 0x71a <vTaskDelayUntil+0xa6>
     6d8:	80 91 6b 02 	lds	r24, 0x026B
     6dc:	90 91 6c 02 	lds	r25, 0x026C
     6e0:	2a 81       	ldd	r18, Y+2	; 0x02
     6e2:	3b 81       	ldd	r19, Y+3	; 0x03
     6e4:	82 17       	cp	r24, r18
     6e6:	93 07       	cpc	r25, r19
     6e8:	c0 f4       	brcc	.+48     	; 0x71a <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
     6ea:	81 e0       	ldi	r24, 0x01	; 1
     6ec:	89 83       	std	Y+1, r24	; 0x01
     6ee:	15 c0       	rjmp	.+42     	; 0x71a <vTaskDelayUntil+0xa6>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
     6f0:	8d 81       	ldd	r24, Y+5	; 0x05
     6f2:	9e 81       	ldd	r25, Y+6	; 0x06
     6f4:	fc 01       	movw	r30, r24
     6f6:	20 81       	ld	r18, Z
     6f8:	31 81       	ldd	r19, Z+1	; 0x01
     6fa:	8a 81       	ldd	r24, Y+2	; 0x02
     6fc:	9b 81       	ldd	r25, Y+3	; 0x03
     6fe:	82 17       	cp	r24, r18
     700:	93 07       	cpc	r25, r19
     702:	48 f0       	brcs	.+18     	; 0x716 <vTaskDelayUntil+0xa2>
     704:	80 91 6b 02 	lds	r24, 0x026B
     708:	90 91 6c 02 	lds	r25, 0x026C
     70c:	2a 81       	ldd	r18, Y+2	; 0x02
     70e:	3b 81       	ldd	r19, Y+3	; 0x03
     710:	82 17       	cp	r24, r18
     712:	93 07       	cpc	r25, r19
     714:	10 f4       	brcc	.+4      	; 0x71a <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
     716:	81 e0       	ldi	r24, 0x01	; 1
     718:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     71a:	8d 81       	ldd	r24, Y+5	; 0x05
     71c:	9e 81       	ldd	r25, Y+6	; 0x06
     71e:	2a 81       	ldd	r18, Y+2	; 0x02
     720:	3b 81       	ldd	r19, Y+3	; 0x03
     722:	fc 01       	movw	r30, r24
     724:	31 83       	std	Z+1, r19	; 0x01
     726:	20 83       	st	Z, r18

			if( xShouldDelay != pdFALSE )
     728:	89 81       	ldd	r24, Y+1	; 0x01
     72a:	88 23       	and	r24, r24
     72c:	59 f0       	breq	.+22     	; 0x744 <vTaskDelayUntil+0xd0>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
     72e:	80 91 1c 02 	lds	r24, 0x021C
     732:	90 91 1d 02 	lds	r25, 0x021D
     736:	02 96       	adiw	r24, 0x02	; 2
     738:	0e 94 4f 12 	call	0x249e	; 0x249e <uxListRemove>
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
     73c:	8a 81       	ldd	r24, Y+2	; 0x02
     73e:	9b 81       	ldd	r25, Y+3	; 0x03
     740:	0e 94 9a 09 	call	0x1334	; 0x1334 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     744:	0e 94 93 05 	call	0xb26	; 0xb26 <xTaskResumeAll>
     748:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     74a:	8c 81       	ldd	r24, Y+4	; 0x04
     74c:	88 23       	and	r24, r24
     74e:	11 f4       	brne	.+4      	; 0x754 <vTaskDelayUntil+0xe0>
		{
			portYIELD_WITHIN_API();
     750:	0e 94 11 18 	call	0x3022	; 0x3022 <vPortYield>
		}
	}
     754:	28 96       	adiw	r28, 0x08	; 8
     756:	0f b6       	in	r0, 0x3f	; 63
     758:	f8 94       	cli
     75a:	de bf       	out	0x3e, r29	; 62
     75c:	0f be       	out	0x3f, r0	; 63
     75e:	cd bf       	out	0x3d, r28	; 61
     760:	df 91       	pop	r29
     762:	cf 91       	pop	r28
     764:	08 95       	ret

00000766 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
     766:	cf 93       	push	r28
     768:	df 93       	push	r29
     76a:	00 d0       	rcall	.+0      	; 0x76c <vTaskDelay+0x6>
     76c:	1f 92       	push	r1
     76e:	1f 92       	push	r1
     770:	cd b7       	in	r28, 0x3d	; 61
     772:	de b7       	in	r29, 0x3e	; 62
     774:	9d 83       	std	Y+5, r25	; 0x05
     776:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
     778:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
     77a:	8c 81       	ldd	r24, Y+4	; 0x04
     77c:	9d 81       	ldd	r25, Y+5	; 0x05
     77e:	00 97       	sbiw	r24, 0x00	; 0
     780:	d1 f0       	breq	.+52     	; 0x7b6 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
     782:	0e 94 87 05 	call	0xb0e	; 0xb0e <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
     786:	20 91 6b 02 	lds	r18, 0x026B
     78a:	30 91 6c 02 	lds	r19, 0x026C
     78e:	8c 81       	ldd	r24, Y+4	; 0x04
     790:	9d 81       	ldd	r25, Y+5	; 0x05
     792:	82 0f       	add	r24, r18
     794:	93 1f       	adc	r25, r19
     796:	9b 83       	std	Y+3, r25	; 0x03
     798:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
     79a:	80 91 1c 02 	lds	r24, 0x021C
     79e:	90 91 1d 02 	lds	r25, 0x021D
     7a2:	02 96       	adiw	r24, 0x02	; 2
     7a4:	0e 94 4f 12 	call	0x249e	; 0x249e <uxListRemove>
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
     7a8:	8a 81       	ldd	r24, Y+2	; 0x02
     7aa:	9b 81       	ldd	r25, Y+3	; 0x03
     7ac:	0e 94 9a 09 	call	0x1334	; 0x1334 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     7b0:	0e 94 93 05 	call	0xb26	; 0xb26 <xTaskResumeAll>
     7b4:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     7b6:	89 81       	ldd	r24, Y+1	; 0x01
     7b8:	88 23       	and	r24, r24
     7ba:	11 f4       	brne	.+4      	; 0x7c0 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
     7bc:	0e 94 11 18 	call	0x3022	; 0x3022 <vPortYield>
		}
	}
     7c0:	0f 90       	pop	r0
     7c2:	0f 90       	pop	r0
     7c4:	0f 90       	pop	r0
     7c6:	0f 90       	pop	r0
     7c8:	0f 90       	pop	r0
     7ca:	df 91       	pop	r29
     7cc:	cf 91       	pop	r28
     7ce:	08 95       	ret

000007d0 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
     7d0:	cf 93       	push	r28
     7d2:	df 93       	push	r29
     7d4:	00 d0       	rcall	.+0      	; 0x7d6 <vTaskSuspend+0x6>
     7d6:	1f 92       	push	r1
     7d8:	cd b7       	in	r28, 0x3d	; 61
     7da:	de b7       	in	r29, 0x3e	; 62
     7dc:	9c 83       	std	Y+4, r25	; 0x04
     7de:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
     7e0:	0f b6       	in	r0, 0x3f	; 63
     7e2:	f8 94       	cli
     7e4:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
     7e6:	80 91 1c 02 	lds	r24, 0x021C
     7ea:	90 91 1d 02 	lds	r25, 0x021D
     7ee:	2b 81       	ldd	r18, Y+3	; 0x03
     7f0:	3c 81       	ldd	r19, Y+4	; 0x04
     7f2:	28 17       	cp	r18, r24
     7f4:	39 07       	cpc	r19, r25
     7f6:	11 f4       	brne	.+4      	; 0x7fc <vTaskSuspend+0x2c>
			{
				pxTaskToSuspend = NULL;
     7f8:	1c 82       	std	Y+4, r1	; 0x04
     7fa:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
     7fc:	8b 81       	ldd	r24, Y+3	; 0x03
     7fe:	9c 81       	ldd	r25, Y+4	; 0x04
     800:	00 97       	sbiw	r24, 0x00	; 0
     802:	29 f4       	brne	.+10     	; 0x80e <vTaskSuspend+0x3e>
     804:	80 91 1c 02 	lds	r24, 0x021C
     808:	90 91 1d 02 	lds	r25, 0x021D
     80c:	02 c0       	rjmp	.+4      	; 0x812 <vTaskSuspend+0x42>
     80e:	8b 81       	ldd	r24, Y+3	; 0x03
     810:	9c 81       	ldd	r25, Y+4	; 0x04
     812:	9a 83       	std	Y+2, r25	; 0x02
     814:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
     816:	89 81       	ldd	r24, Y+1	; 0x01
     818:	9a 81       	ldd	r25, Y+2	; 0x02
     81a:	02 96       	adiw	r24, 0x02	; 2
     81c:	0e 94 4f 12 	call	0x249e	; 0x249e <uxListRemove>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
			}

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
     820:	89 81       	ldd	r24, Y+1	; 0x01
     822:	9a 81       	ldd	r25, Y+2	; 0x02
     824:	fc 01       	movw	r30, r24
     826:	84 89       	ldd	r24, Z+20	; 0x14
     828:	95 89       	ldd	r25, Z+21	; 0x15
     82a:	00 97       	sbiw	r24, 0x00	; 0
     82c:	29 f0       	breq	.+10     	; 0x838 <vTaskSuspend+0x68>
			{
				uxListRemove( &( pxTCB->xEventListItem ) );
     82e:	89 81       	ldd	r24, Y+1	; 0x01
     830:	9a 81       	ldd	r25, Y+2	; 0x02
     832:	0c 96       	adiw	r24, 0x0c	; 12
     834:	0e 94 4f 12 	call	0x249e	; 0x249e <uxListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
     838:	89 81       	ldd	r24, Y+1	; 0x01
     83a:	9a 81       	ldd	r25, Y+2	; 0x02
     83c:	02 96       	adiw	r24, 0x02	; 2
     83e:	bc 01       	movw	r22, r24
     840:	81 e6       	ldi	r24, 0x61	; 97
     842:	92 e0       	ldi	r25, 0x02	; 2
     844:	0e 94 7f 11 	call	0x22fe	; 0x22fe <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
     848:	0f 90       	pop	r0
     84a:	0f be       	out	0x3f, r0	; 63

		if( ( void * ) pxTaskToSuspend == NULL )
     84c:	8b 81       	ldd	r24, Y+3	; 0x03
     84e:	9c 81       	ldd	r25, Y+4	; 0x04
     850:	00 97       	sbiw	r24, 0x00	; 0
     852:	a1 f4       	brne	.+40     	; 0x87c <vTaskSuspend+0xac>
		{
			if( xSchedulerRunning != pdFALSE )
     854:	80 91 6f 02 	lds	r24, 0x026F
     858:	88 23       	and	r24, r24
     85a:	19 f0       	breq	.+6      	; 0x862 <vTaskSuspend+0x92>
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
     85c:	0e 94 11 18 	call	0x3022	; 0x3022 <vPortYield>
     860:	0d c0       	rjmp	.+26     	; 0x87c <vTaskSuspend+0xac>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
     862:	90 91 61 02 	lds	r25, 0x0261
     866:	80 91 6a 02 	lds	r24, 0x026A
     86a:	98 17       	cp	r25, r24
     86c:	29 f4       	brne	.+10     	; 0x878 <vTaskSuspend+0xa8>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
     86e:	10 92 1d 02 	sts	0x021D, r1
     872:	10 92 1c 02 	sts	0x021C, r1
     876:	02 c0       	rjmp	.+4      	; 0x87c <vTaskSuspend+0xac>
				}
				else
				{
					vTaskSwitchContext();
     878:	0e 94 31 07 	call	0xe62	; 0xe62 <vTaskSwitchContext>
				}
			}
		}
	}
     87c:	0f 90       	pop	r0
     87e:	0f 90       	pop	r0
     880:	0f 90       	pop	r0
     882:	0f 90       	pop	r0
     884:	df 91       	pop	r29
     886:	cf 91       	pop	r28
     888:	08 95       	ret

0000088a <xTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
     88a:	cf 93       	push	r28
     88c:	df 93       	push	r29
     88e:	00 d0       	rcall	.+0      	; 0x890 <xTaskIsTaskSuspended+0x6>
     890:	1f 92       	push	r1
     892:	1f 92       	push	r1
     894:	cd b7       	in	r28, 0x3d	; 61
     896:	de b7       	in	r29, 0x3e	; 62
     898:	9d 83       	std	Y+5, r25	; 0x05
     89a:	8c 83       	std	Y+4, r24	; 0x04
	portBASE_TYPE xReturn = pdFALSE;
     89c:	19 82       	std	Y+1, r1	; 0x01
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
     89e:	8c 81       	ldd	r24, Y+4	; 0x04
     8a0:	9d 81       	ldd	r25, Y+5	; 0x05
     8a2:	9b 83       	std	Y+3, r25	; 0x03
     8a4:	8a 83       	std	Y+2, r24	; 0x02
		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
     8a6:	8a 81       	ldd	r24, Y+2	; 0x02
     8a8:	9b 81       	ldd	r25, Y+3	; 0x03
     8aa:	fc 01       	movw	r30, r24
     8ac:	82 85       	ldd	r24, Z+10	; 0x0a
     8ae:	93 85       	ldd	r25, Z+11	; 0x0b
     8b0:	f2 e0       	ldi	r31, 0x02	; 2
     8b2:	81 36       	cpi	r24, 0x61	; 97
     8b4:	9f 07       	cpc	r25, r31
     8b6:	91 f4       	brne	.+36     	; 0x8dc <xTaskIsTaskSuspended+0x52>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
     8b8:	8a 81       	ldd	r24, Y+2	; 0x02
     8ba:	9b 81       	ldd	r25, Y+3	; 0x03
     8bc:	fc 01       	movw	r30, r24
     8be:	84 89       	ldd	r24, Z+20	; 0x14
     8c0:	95 89       	ldd	r25, Z+21	; 0x15
     8c2:	f2 e0       	ldi	r31, 0x02	; 2
     8c4:	88 35       	cpi	r24, 0x58	; 88
     8c6:	9f 07       	cpc	r25, r31
     8c8:	49 f0       	breq	.+18     	; 0x8dc <xTaskIsTaskSuspended+0x52>
			{
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
     8ca:	8a 81       	ldd	r24, Y+2	; 0x02
     8cc:	9b 81       	ldd	r25, Y+3	; 0x03
     8ce:	fc 01       	movw	r30, r24
     8d0:	84 89       	ldd	r24, Z+20	; 0x14
     8d2:	95 89       	ldd	r25, Z+21	; 0x15
     8d4:	00 97       	sbiw	r24, 0x00	; 0
     8d6:	11 f4       	brne	.+4      	; 0x8dc <xTaskIsTaskSuspended+0x52>
				{
					xReturn = pdTRUE;
     8d8:	81 e0       	ldi	r24, 0x01	; 1
     8da:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}

		return xReturn;
     8dc:	89 81       	ldd	r24, Y+1	; 0x01
	}
     8de:	0f 90       	pop	r0
     8e0:	0f 90       	pop	r0
     8e2:	0f 90       	pop	r0
     8e4:	0f 90       	pop	r0
     8e6:	0f 90       	pop	r0
     8e8:	df 91       	pop	r29
     8ea:	cf 91       	pop	r28
     8ec:	08 95       	ret

000008ee <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
     8ee:	cf 93       	push	r28
     8f0:	df 93       	push	r29
     8f2:	00 d0       	rcall	.+0      	; 0x8f4 <vTaskResume+0x6>
     8f4:	1f 92       	push	r1
     8f6:	cd b7       	in	r28, 0x3d	; 61
     8f8:	de b7       	in	r29, 0x3e	; 62
     8fa:	9c 83       	std	Y+4, r25	; 0x04
     8fc:	8b 83       	std	Y+3, r24	; 0x03
		/* It does not make sense to resume the calling task. */
		configASSERT( pxTaskToResume );

		/* Remove the task from whichever list it is currently in, and place
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;
     8fe:	8b 81       	ldd	r24, Y+3	; 0x03
     900:	9c 81       	ldd	r25, Y+4	; 0x04
     902:	9a 83       	std	Y+2, r25	; 0x02
     904:	89 83       	std	Y+1, r24	; 0x01

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
     906:	89 81       	ldd	r24, Y+1	; 0x01
     908:	9a 81       	ldd	r25, Y+2	; 0x02
     90a:	00 97       	sbiw	r24, 0x00	; 0
     90c:	09 f4       	brne	.+2      	; 0x910 <vTaskResume+0x22>
     90e:	4f c0       	rjmp	.+158    	; 0x9ae <vTaskResume+0xc0>
     910:	80 91 1c 02 	lds	r24, 0x021C
     914:	90 91 1d 02 	lds	r25, 0x021D
     918:	29 81       	ldd	r18, Y+1	; 0x01
     91a:	3a 81       	ldd	r19, Y+2	; 0x02
     91c:	28 17       	cp	r18, r24
     91e:	39 07       	cpc	r19, r25
     920:	09 f4       	brne	.+2      	; 0x924 <vTaskResume+0x36>
     922:	45 c0       	rjmp	.+138    	; 0x9ae <vTaskResume+0xc0>
		{
			taskENTER_CRITICAL();
     924:	0f b6       	in	r0, 0x3f	; 63
     926:	f8 94       	cli
     928:	0f 92       	push	r0
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
     92a:	89 81       	ldd	r24, Y+1	; 0x01
     92c:	9a 81       	ldd	r25, Y+2	; 0x02
     92e:	0e 94 45 04 	call	0x88a	; 0x88a <xTaskIsTaskSuspended>
     932:	81 30       	cpi	r24, 0x01	; 1
     934:	d1 f5       	brne	.+116    	; 0x9aa <vTaskResume+0xbc>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					uxListRemove(  &( pxTCB->xGenericListItem ) );
     936:	89 81       	ldd	r24, Y+1	; 0x01
     938:	9a 81       	ldd	r25, Y+2	; 0x02
     93a:	02 96       	adiw	r24, 0x02	; 2
     93c:	0e 94 4f 12 	call	0x249e	; 0x249e <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
     940:	89 81       	ldd	r24, Y+1	; 0x01
     942:	9a 81       	ldd	r25, Y+2	; 0x02
     944:	fc 01       	movw	r30, r24
     946:	96 89       	ldd	r25, Z+22	; 0x16
     948:	80 91 6e 02 	lds	r24, 0x026E
     94c:	89 17       	cp	r24, r25
     94e:	30 f4       	brcc	.+12     	; 0x95c <vTaskResume+0x6e>
     950:	89 81       	ldd	r24, Y+1	; 0x01
     952:	9a 81       	ldd	r25, Y+2	; 0x02
     954:	fc 01       	movw	r30, r24
     956:	86 89       	ldd	r24, Z+22	; 0x16
     958:	80 93 6e 02 	sts	0x026E, r24
     95c:	89 81       	ldd	r24, Y+1	; 0x01
     95e:	9a 81       	ldd	r25, Y+2	; 0x02
     960:	ac 01       	movw	r20, r24
     962:	4e 5f       	subi	r20, 0xFE	; 254
     964:	5f 4f       	sbci	r21, 0xFF	; 255
     966:	89 81       	ldd	r24, Y+1	; 0x01
     968:	9a 81       	ldd	r25, Y+2	; 0x02
     96a:	fc 01       	movw	r30, r24
     96c:	86 89       	ldd	r24, Z+22	; 0x16
     96e:	28 2f       	mov	r18, r24
     970:	30 e0       	ldi	r19, 0x00	; 0
     972:	c9 01       	movw	r24, r18
     974:	88 0f       	add	r24, r24
     976:	99 1f       	adc	r25, r25
     978:	88 0f       	add	r24, r24
     97a:	99 1f       	adc	r25, r25
     97c:	88 0f       	add	r24, r24
     97e:	99 1f       	adc	r25, r25
     980:	82 0f       	add	r24, r18
     982:	93 1f       	adc	r25, r19
     984:	82 5e       	subi	r24, 0xE2	; 226
     986:	9d 4f       	sbci	r25, 0xFD	; 253
     988:	ba 01       	movw	r22, r20
     98a:	0e 94 7f 11 	call	0x22fe	; 0x22fe <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     98e:	89 81       	ldd	r24, Y+1	; 0x01
     990:	9a 81       	ldd	r25, Y+2	; 0x02
     992:	fc 01       	movw	r30, r24
     994:	26 89       	ldd	r18, Z+22	; 0x16
     996:	80 91 1c 02 	lds	r24, 0x021C
     99a:	90 91 1d 02 	lds	r25, 0x021D
     99e:	fc 01       	movw	r30, r24
     9a0:	86 89       	ldd	r24, Z+22	; 0x16
     9a2:	28 17       	cp	r18, r24
     9a4:	10 f0       	brcs	.+4      	; 0x9aa <vTaskResume+0xbc>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
     9a6:	0e 94 11 18 	call	0x3022	; 0x3022 <vPortYield>
					}
				}
			}
			taskEXIT_CRITICAL();
     9aa:	0f 90       	pop	r0
     9ac:	0f be       	out	0x3f, r0	; 63
		}
	}
     9ae:	0f 90       	pop	r0
     9b0:	0f 90       	pop	r0
     9b2:	0f 90       	pop	r0
     9b4:	0f 90       	pop	r0
     9b6:	df 91       	pop	r29
     9b8:	cf 91       	pop	r28
     9ba:	08 95       	ret

000009bc <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
     9bc:	cf 93       	push	r28
     9be:	df 93       	push	r29
     9c0:	00 d0       	rcall	.+0      	; 0x9c2 <xTaskResumeFromISR+0x6>
     9c2:	00 d0       	rcall	.+0      	; 0x9c4 <xTaskResumeFromISR+0x8>
     9c4:	cd b7       	in	r28, 0x3d	; 61
     9c6:	de b7       	in	r29, 0x3e	; 62
     9c8:	9e 83       	std	Y+6, r25	; 0x06
     9ca:	8d 83       	std	Y+5, r24	; 0x05
	portBASE_TYPE xYieldRequired = pdFALSE;
     9cc:	19 82       	std	Y+1, r1	; 0x01
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxSavedInterruptStatus;

		configASSERT( pxTaskToResume );

		pxTCB = ( tskTCB * ) pxTaskToResume;
     9ce:	8d 81       	ldd	r24, Y+5	; 0x05
     9d0:	9e 81       	ldd	r25, Y+6	; 0x06
     9d2:	9b 83       	std	Y+3, r25	; 0x03
     9d4:	8a 83       	std	Y+2, r24	; 0x02

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     9d6:	1c 82       	std	Y+4, r1	; 0x04
		{
			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
     9d8:	8a 81       	ldd	r24, Y+2	; 0x02
     9da:	9b 81       	ldd	r25, Y+3	; 0x03
     9dc:	0e 94 45 04 	call	0x88a	; 0x88a <xTaskIsTaskSuspended>
     9e0:	81 30       	cpi	r24, 0x01	; 1
     9e2:	09 f0       	breq	.+2      	; 0x9e6 <xTaskResumeFromISR+0x2a>
     9e4:	48 c0       	rjmp	.+144    	; 0xa76 <xTaskResumeFromISR+0xba>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     9e6:	80 91 70 02 	lds	r24, 0x0270
     9ea:	88 23       	and	r24, r24
     9ec:	e1 f5       	brne	.+120    	; 0xa66 <xTaskResumeFromISR+0xaa>
				{
					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
     9ee:	8a 81       	ldd	r24, Y+2	; 0x02
     9f0:	9b 81       	ldd	r25, Y+3	; 0x03
     9f2:	fc 01       	movw	r30, r24
     9f4:	26 89       	ldd	r18, Z+22	; 0x16
     9f6:	80 91 1c 02 	lds	r24, 0x021C
     9fa:	90 91 1d 02 	lds	r25, 0x021D
     9fe:	fc 01       	movw	r30, r24
     a00:	96 89       	ldd	r25, Z+22	; 0x16
     a02:	81 e0       	ldi	r24, 0x01	; 1
     a04:	29 17       	cp	r18, r25
     a06:	08 f4       	brcc	.+2      	; 0xa0a <xTaskResumeFromISR+0x4e>
     a08:	80 e0       	ldi	r24, 0x00	; 0
     a0a:	89 83       	std	Y+1, r24	; 0x01
					uxListRemove(  &( pxTCB->xGenericListItem ) );
     a0c:	8a 81       	ldd	r24, Y+2	; 0x02
     a0e:	9b 81       	ldd	r25, Y+3	; 0x03
     a10:	02 96       	adiw	r24, 0x02	; 2
     a12:	0e 94 4f 12 	call	0x249e	; 0x249e <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
     a16:	8a 81       	ldd	r24, Y+2	; 0x02
     a18:	9b 81       	ldd	r25, Y+3	; 0x03
     a1a:	fc 01       	movw	r30, r24
     a1c:	96 89       	ldd	r25, Z+22	; 0x16
     a1e:	80 91 6e 02 	lds	r24, 0x026E
     a22:	89 17       	cp	r24, r25
     a24:	30 f4       	brcc	.+12     	; 0xa32 <xTaskResumeFromISR+0x76>
     a26:	8a 81       	ldd	r24, Y+2	; 0x02
     a28:	9b 81       	ldd	r25, Y+3	; 0x03
     a2a:	fc 01       	movw	r30, r24
     a2c:	86 89       	ldd	r24, Z+22	; 0x16
     a2e:	80 93 6e 02 	sts	0x026E, r24
     a32:	8a 81       	ldd	r24, Y+2	; 0x02
     a34:	9b 81       	ldd	r25, Y+3	; 0x03
     a36:	ac 01       	movw	r20, r24
     a38:	4e 5f       	subi	r20, 0xFE	; 254
     a3a:	5f 4f       	sbci	r21, 0xFF	; 255
     a3c:	8a 81       	ldd	r24, Y+2	; 0x02
     a3e:	9b 81       	ldd	r25, Y+3	; 0x03
     a40:	fc 01       	movw	r30, r24
     a42:	86 89       	ldd	r24, Z+22	; 0x16
     a44:	28 2f       	mov	r18, r24
     a46:	30 e0       	ldi	r19, 0x00	; 0
     a48:	c9 01       	movw	r24, r18
     a4a:	88 0f       	add	r24, r24
     a4c:	99 1f       	adc	r25, r25
     a4e:	88 0f       	add	r24, r24
     a50:	99 1f       	adc	r25, r25
     a52:	88 0f       	add	r24, r24
     a54:	99 1f       	adc	r25, r25
     a56:	82 0f       	add	r24, r18
     a58:	93 1f       	adc	r25, r19
     a5a:	82 5e       	subi	r24, 0xE2	; 226
     a5c:	9d 4f       	sbci	r25, 0xFD	; 253
     a5e:	ba 01       	movw	r22, r20
     a60:	0e 94 7f 11 	call	0x22fe	; 0x22fe <vListInsertEnd>
     a64:	08 c0       	rjmp	.+16     	; 0xa76 <xTaskResumeFromISR+0xba>
				else
				{
					/* We cannot access the delayed or ready lists, so will hold this
					task pending until the scheduler is resumed, at which point a
					yield will be performed if necessary. */
					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
     a66:	8a 81       	ldd	r24, Y+2	; 0x02
     a68:	9b 81       	ldd	r25, Y+3	; 0x03
     a6a:	0c 96       	adiw	r24, 0x0c	; 12
     a6c:	bc 01       	movw	r22, r24
     a6e:	88 e5       	ldi	r24, 0x58	; 88
     a70:	92 e0       	ldi	r25, 0x02	; 2
     a72:	0e 94 7f 11 	call	0x22fe	; 0x22fe <vListInsertEnd>
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
     a76:	89 81       	ldd	r24, Y+1	; 0x01
	}
     a78:	26 96       	adiw	r28, 0x06	; 6
     a7a:	0f b6       	in	r0, 0x3f	; 63
     a7c:	f8 94       	cli
     a7e:	de bf       	out	0x3e, r29	; 62
     a80:	0f be       	out	0x3f, r0	; 63
     a82:	cd bf       	out	0x3d, r28	; 61
     a84:	df 91       	pop	r29
     a86:	cf 91       	pop	r28
     a88:	08 95       	ret

00000a8a <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
     a8a:	af 92       	push	r10
     a8c:	bf 92       	push	r11
     a8e:	cf 92       	push	r12
     a90:	df 92       	push	r13
     a92:	ef 92       	push	r14
     a94:	ff 92       	push	r15
     a96:	0f 93       	push	r16
     a98:	cf 93       	push	r28
     a9a:	df 93       	push	r29
     a9c:	1f 92       	push	r1
     a9e:	cd b7       	in	r28, 0x3d	; 61
     aa0:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
     aa2:	a1 2c       	mov	r10, r1
     aa4:	b1 2c       	mov	r11, r1
     aa6:	c1 2c       	mov	r12, r1
     aa8:	d1 2c       	mov	r13, r1
     aaa:	e1 2c       	mov	r14, r1
     aac:	f1 2c       	mov	r15, r1
     aae:	00 e0       	ldi	r16, 0x00	; 0
     ab0:	20 e0       	ldi	r18, 0x00	; 0
     ab2:	30 e0       	ldi	r19, 0x00	; 0
     ab4:	45 e5       	ldi	r20, 0x55	; 85
     ab6:	50 e0       	ldi	r21, 0x00	; 0
     ab8:	65 e1       	ldi	r22, 0x15	; 21
     aba:	72 e0       	ldi	r23, 0x02	; 2
     abc:	83 ee       	ldi	r24, 0xE3	; 227
     abe:	98 e0       	ldi	r25, 0x08	; 8
     ac0:	0e 94 46 02 	call	0x48c	; 0x48c <xTaskGenericCreate>
     ac4:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
     ac6:	89 81       	ldd	r24, Y+1	; 0x01
     ac8:	81 30       	cpi	r24, 0x01	; 1
     aca:	51 f4       	brne	.+20     	; 0xae0 <vTaskStartScheduler+0x56>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
     acc:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
     ace:	81 e0       	ldi	r24, 0x01	; 1
     ad0:	80 93 6f 02 	sts	0x026F, r24
		xTickCount = ( portTickType ) 0U;
     ad4:	10 92 6c 02 	sts	0x026C, r1
     ad8:	10 92 6b 02 	sts	0x026B, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     adc:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
     ae0:	0f 90       	pop	r0
     ae2:	df 91       	pop	r29
     ae4:	cf 91       	pop	r28
     ae6:	0f 91       	pop	r16
     ae8:	ff 90       	pop	r15
     aea:	ef 90       	pop	r14
     aec:	df 90       	pop	r13
     aee:	cf 90       	pop	r12
     af0:	bf 90       	pop	r11
     af2:	af 90       	pop	r10
     af4:	08 95       	ret

00000af6 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
     af6:	cf 93       	push	r28
     af8:	df 93       	push	r29
     afa:	cd b7       	in	r28, 0x3d	; 61
     afc:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
     afe:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
     b00:	10 92 6f 02 	sts	0x026F, r1
	vPortEndScheduler();
     b04:	0e 94 0a 18 	call	0x3014	; 0x3014 <vPortEndScheduler>
}
     b08:	df 91       	pop	r29
     b0a:	cf 91       	pop	r28
     b0c:	08 95       	ret

00000b0e <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
     b0e:	cf 93       	push	r28
     b10:	df 93       	push	r29
     b12:	cd b7       	in	r28, 0x3d	; 61
     b14:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
     b16:	80 91 70 02 	lds	r24, 0x0270
     b1a:	8f 5f       	subi	r24, 0xFF	; 255
     b1c:	80 93 70 02 	sts	0x0270, r24
}
     b20:	df 91       	pop	r29
     b22:	cf 91       	pop	r28
     b24:	08 95       	ret

00000b26 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE != 0  */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
     b26:	0f 93       	push	r16
     b28:	1f 93       	push	r17
     b2a:	cf 93       	push	r28
     b2c:	df 93       	push	r29
     b2e:	1f 92       	push	r1
     b30:	1f 92       	push	r1
     b32:	cd b7       	in	r28, 0x3d	; 61
     b34:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
     b36:	19 82       	std	Y+1, r1	; 0x01
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     b38:	0f b6       	in	r0, 0x3f	; 63
     b3a:	f8 94       	cli
     b3c:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     b3e:	80 91 70 02 	lds	r24, 0x0270
     b42:	81 50       	subi	r24, 0x01	; 1
     b44:	80 93 70 02 	sts	0x0270, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     b48:	80 91 70 02 	lds	r24, 0x0270
     b4c:	88 23       	and	r24, r24
     b4e:	09 f0       	breq	.+2      	; 0xb52 <xTaskResumeAll+0x2c>
     b50:	64 c0       	rjmp	.+200    	; 0xc1a <xTaskResumeAll+0xf4>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
     b52:	80 91 6a 02 	lds	r24, 0x026A
     b56:	88 23       	and	r24, r24
     b58:	09 f4       	brne	.+2      	; 0xb5c <xTaskResumeAll+0x36>
     b5a:	5f c0       	rjmp	.+190    	; 0xc1a <xTaskResumeAll+0xf4>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
     b5c:	1a 82       	std	Y+2, r1	; 0x02

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
     b5e:	3a c0       	rjmp	.+116    	; 0xbd4 <xTaskResumeAll+0xae>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
     b60:	80 91 5d 02 	lds	r24, 0x025D
     b64:	90 91 5e 02 	lds	r25, 0x025E
     b68:	fc 01       	movw	r30, r24
     b6a:	06 81       	ldd	r16, Z+6	; 0x06
     b6c:	17 81       	ldd	r17, Z+7	; 0x07
					uxListRemove( &( pxTCB->xEventListItem ) );
     b6e:	c8 01       	movw	r24, r16
     b70:	0c 96       	adiw	r24, 0x0c	; 12
     b72:	0e 94 4f 12 	call	0x249e	; 0x249e <uxListRemove>
					uxListRemove( &( pxTCB->xGenericListItem ) );
     b76:	c8 01       	movw	r24, r16
     b78:	02 96       	adiw	r24, 0x02	; 2
     b7a:	0e 94 4f 12 	call	0x249e	; 0x249e <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
     b7e:	f8 01       	movw	r30, r16
     b80:	96 89       	ldd	r25, Z+22	; 0x16
     b82:	80 91 6e 02 	lds	r24, 0x026E
     b86:	89 17       	cp	r24, r25
     b88:	20 f4       	brcc	.+8      	; 0xb92 <xTaskResumeAll+0x6c>
     b8a:	f8 01       	movw	r30, r16
     b8c:	86 89       	ldd	r24, Z+22	; 0x16
     b8e:	80 93 6e 02 	sts	0x026E, r24
     b92:	a8 01       	movw	r20, r16
     b94:	4e 5f       	subi	r20, 0xFE	; 254
     b96:	5f 4f       	sbci	r21, 0xFF	; 255
     b98:	f8 01       	movw	r30, r16
     b9a:	86 89       	ldd	r24, Z+22	; 0x16
     b9c:	28 2f       	mov	r18, r24
     b9e:	30 e0       	ldi	r19, 0x00	; 0
     ba0:	c9 01       	movw	r24, r18
     ba2:	88 0f       	add	r24, r24
     ba4:	99 1f       	adc	r25, r25
     ba6:	88 0f       	add	r24, r24
     ba8:	99 1f       	adc	r25, r25
     baa:	88 0f       	add	r24, r24
     bac:	99 1f       	adc	r25, r25
     bae:	82 0f       	add	r24, r18
     bb0:	93 1f       	adc	r25, r19
     bb2:	82 5e       	subi	r24, 0xE2	; 226
     bb4:	9d 4f       	sbci	r25, 0xFD	; 253
     bb6:	ba 01       	movw	r22, r20
     bb8:	0e 94 7f 11 	call	0x22fe	; 0x22fe <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     bbc:	f8 01       	movw	r30, r16
     bbe:	26 89       	ldd	r18, Z+22	; 0x16
     bc0:	80 91 1c 02 	lds	r24, 0x021C
     bc4:	90 91 1d 02 	lds	r25, 0x021D
     bc8:	fc 01       	movw	r30, r24
     bca:	86 89       	ldd	r24, Z+22	; 0x16
     bcc:	28 17       	cp	r18, r24
     bce:	10 f0       	brcs	.+4      	; 0xbd4 <xTaskResumeAll+0xae>
					{
						xYieldRequired = pdTRUE;
     bd0:	81 e0       	ldi	r24, 0x01	; 1
     bd2:	8a 83       	std	Y+2, r24	; 0x02
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
     bd4:	80 91 58 02 	lds	r24, 0x0258
     bd8:	88 23       	and	r24, r24
     bda:	11 f6       	brne	.-124    	; 0xb60 <xTaskResumeAll+0x3a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
     bdc:	80 91 71 02 	lds	r24, 0x0271
     be0:	88 23       	and	r24, r24
     be2:	71 f0       	breq	.+28     	; 0xc00 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
     be4:	07 c0       	rjmp	.+14     	; 0xbf4 <xTaskResumeAll+0xce>
					{
						vTaskIncrementTick();
     be6:	0e 94 4c 06 	call	0xc98	; 0xc98 <vTaskIncrementTick>
						--uxMissedTicks;
     bea:	80 91 71 02 	lds	r24, 0x0271
     bee:	81 50       	subi	r24, 0x01	; 1
     bf0:	80 93 71 02 	sts	0x0271, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
     bf4:	80 91 71 02 	lds	r24, 0x0271
     bf8:	88 23       	and	r24, r24
     bfa:	a9 f7       	brne	.-22     	; 0xbe6 <xTaskResumeAll+0xc0>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
     bfc:	81 e0       	ldi	r24, 0x01	; 1
     bfe:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
     c00:	8a 81       	ldd	r24, Y+2	; 0x02
     c02:	81 30       	cpi	r24, 0x01	; 1
     c04:	21 f0       	breq	.+8      	; 0xc0e <xTaskResumeAll+0xe8>
     c06:	80 91 72 02 	lds	r24, 0x0272
     c0a:	81 30       	cpi	r24, 0x01	; 1
     c0c:	31 f4       	brne	.+12     	; 0xc1a <xTaskResumeAll+0xf4>
				{
					xAlreadyYielded = pdTRUE;
     c0e:	81 e0       	ldi	r24, 0x01	; 1
     c10:	89 83       	std	Y+1, r24	; 0x01
					xMissedYield = pdFALSE;
     c12:	10 92 72 02 	sts	0x0272, r1
					portYIELD_WITHIN_API();
     c16:	0e 94 11 18 	call	0x3022	; 0x3022 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
     c1a:	0f 90       	pop	r0
     c1c:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
     c1e:	89 81       	ldd	r24, Y+1	; 0x01
}
     c20:	0f 90       	pop	r0
     c22:	0f 90       	pop	r0
     c24:	df 91       	pop	r29
     c26:	cf 91       	pop	r28
     c28:	1f 91       	pop	r17
     c2a:	0f 91       	pop	r16
     c2c:	08 95       	ret

00000c2e <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
     c2e:	cf 93       	push	r28
     c30:	df 93       	push	r29
     c32:	1f 92       	push	r1
     c34:	1f 92       	push	r1
     c36:	cd b7       	in	r28, 0x3d	; 61
     c38:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
     c3a:	0f b6       	in	r0, 0x3f	; 63
     c3c:	f8 94       	cli
     c3e:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     c40:	80 91 6b 02 	lds	r24, 0x026B
     c44:	90 91 6c 02 	lds	r25, 0x026C
     c48:	9a 83       	std	Y+2, r25	; 0x02
     c4a:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
     c4c:	0f 90       	pop	r0
     c4e:	0f be       	out	0x3f, r0	; 63

	return xTicks;
     c50:	89 81       	ldd	r24, Y+1	; 0x01
     c52:	9a 81       	ldd	r25, Y+2	; 0x02
}
     c54:	0f 90       	pop	r0
     c56:	0f 90       	pop	r0
     c58:	df 91       	pop	r29
     c5a:	cf 91       	pop	r28
     c5c:	08 95       	ret

00000c5e <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
     c5e:	cf 93       	push	r28
     c60:	df 93       	push	r29
     c62:	00 d0       	rcall	.+0      	; 0xc64 <xTaskGetTickCountFromISR+0x6>
     c64:	cd b7       	in	r28, 0x3d	; 61
     c66:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     c68:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
     c6a:	80 91 6b 02 	lds	r24, 0x026B
     c6e:	90 91 6c 02 	lds	r25, 0x026C
     c72:	9b 83       	std	Y+3, r25	; 0x03
     c74:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
     c76:	8a 81       	ldd	r24, Y+2	; 0x02
     c78:	9b 81       	ldd	r25, Y+3	; 0x03
}
     c7a:	0f 90       	pop	r0
     c7c:	0f 90       	pop	r0
     c7e:	0f 90       	pop	r0
     c80:	df 91       	pop	r29
     c82:	cf 91       	pop	r28
     c84:	08 95       	ret

00000c86 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
     c86:	cf 93       	push	r28
     c88:	df 93       	push	r29
     c8a:	cd b7       	in	r28, 0x3d	; 61
     c8c:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
     c8e:	80 91 6a 02 	lds	r24, 0x026A
}
     c92:	df 91       	pop	r29
     c94:	cf 91       	pop	r28
     c96:	08 95       	ret

00000c98 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
     c98:	cf 93       	push	r28
     c9a:	df 93       	push	r29
     c9c:	00 d0       	rcall	.+0      	; 0xc9e <vTaskIncrementTick+0x6>
     c9e:	00 d0       	rcall	.+0      	; 0xca0 <vTaskIncrementTick+0x8>
     ca0:	cd b7       	in	r28, 0x3d	; 61
     ca2:	de b7       	in	r29, 0x3e	; 62

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     ca4:	80 91 70 02 	lds	r24, 0x0270
     ca8:	88 23       	and	r24, r24
     caa:	09 f0       	breq	.+2      	; 0xcae <vTaskIncrementTick+0x16>
     cac:	c4 c0       	rjmp	.+392    	; 0xe36 <vTaskIncrementTick+0x19e>
	{
		++xTickCount;
     cae:	80 91 6b 02 	lds	r24, 0x026B
     cb2:	90 91 6c 02 	lds	r25, 0x026C
     cb6:	01 96       	adiw	r24, 0x01	; 1
     cb8:	90 93 6c 02 	sts	0x026C, r25
     cbc:	80 93 6b 02 	sts	0x026B, r24
		if( xTickCount == ( portTickType ) 0U )
     cc0:	80 91 6b 02 	lds	r24, 0x026B
     cc4:	90 91 6c 02 	lds	r25, 0x026C
     cc8:	00 97       	sbiw	r24, 0x00	; 0
     cca:	e9 f5       	brne	.+122    	; 0xd46 <vTaskIncrementTick+0xae>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
     ccc:	80 91 54 02 	lds	r24, 0x0254
     cd0:	90 91 55 02 	lds	r25, 0x0255
     cd4:	9a 83       	std	Y+2, r25	; 0x02
     cd6:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedTaskList = pxOverflowDelayedTaskList;
     cd8:	80 91 56 02 	lds	r24, 0x0256
     cdc:	90 91 57 02 	lds	r25, 0x0257
     ce0:	90 93 55 02 	sts	0x0255, r25
     ce4:	80 93 54 02 	sts	0x0254, r24
			pxOverflowDelayedTaskList = pxTemp;
     ce8:	89 81       	ldd	r24, Y+1	; 0x01
     cea:	9a 81       	ldd	r25, Y+2	; 0x02
     cec:	90 93 57 02 	sts	0x0257, r25
     cf0:	80 93 56 02 	sts	0x0256, r24
			xNumOfOverflows++;
     cf4:	80 91 73 02 	lds	r24, 0x0273
     cf8:	8f 5f       	subi	r24, 0xFF	; 255
     cfa:	80 93 73 02 	sts	0x0273, r24

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     cfe:	80 91 54 02 	lds	r24, 0x0254
     d02:	90 91 55 02 	lds	r25, 0x0255
     d06:	fc 01       	movw	r30, r24
     d08:	80 81       	ld	r24, Z
     d0a:	88 23       	and	r24, r24
     d0c:	39 f4       	brne	.+14     	; 0xd1c <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
     d0e:	8f ef       	ldi	r24, 0xFF	; 255
     d10:	9f ef       	ldi	r25, 0xFF	; 255
     d12:	90 93 01 02 	sts	0x0201, r25
     d16:	80 93 00 02 	sts	0x0200, r24
     d1a:	15 c0       	rjmp	.+42     	; 0xd46 <vTaskIncrementTick+0xae>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     d1c:	80 91 54 02 	lds	r24, 0x0254
     d20:	90 91 55 02 	lds	r25, 0x0255
     d24:	fc 01       	movw	r30, r24
     d26:	85 81       	ldd	r24, Z+5	; 0x05
     d28:	96 81       	ldd	r25, Z+6	; 0x06
     d2a:	fc 01       	movw	r30, r24
     d2c:	86 81       	ldd	r24, Z+6	; 0x06
     d2e:	97 81       	ldd	r25, Z+7	; 0x07
     d30:	9c 83       	std	Y+4, r25	; 0x04
     d32:	8b 83       	std	Y+3, r24	; 0x03
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
     d34:	8b 81       	ldd	r24, Y+3	; 0x03
     d36:	9c 81       	ldd	r25, Y+4	; 0x04
     d38:	fc 01       	movw	r30, r24
     d3a:	82 81       	ldd	r24, Z+2	; 0x02
     d3c:	93 81       	ldd	r25, Z+3	; 0x03
     d3e:	90 93 01 02 	sts	0x0201, r25
     d42:	80 93 00 02 	sts	0x0200, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
     d46:	20 91 6b 02 	lds	r18, 0x026B
     d4a:	30 91 6c 02 	lds	r19, 0x026C
     d4e:	80 91 00 02 	lds	r24, 0x0200
     d52:	90 91 01 02 	lds	r25, 0x0201
     d56:	28 17       	cp	r18, r24
     d58:	39 07       	cpc	r19, r25
     d5a:	08 f4       	brcc	.+2      	; 0xd5e <vTaskIncrementTick+0xc6>
     d5c:	6b c0       	rjmp	.+214    	; 0xe34 <vTaskIncrementTick+0x19c>
     d5e:	80 91 54 02 	lds	r24, 0x0254
     d62:	90 91 55 02 	lds	r25, 0x0255
     d66:	fc 01       	movw	r30, r24
     d68:	80 81       	ld	r24, Z
     d6a:	88 23       	and	r24, r24
     d6c:	39 f4       	brne	.+14     	; 0xd7c <vTaskIncrementTick+0xe4>
     d6e:	8f ef       	ldi	r24, 0xFF	; 255
     d70:	9f ef       	ldi	r25, 0xFF	; 255
     d72:	90 93 01 02 	sts	0x0201, r25
     d76:	80 93 00 02 	sts	0x0200, r24
     d7a:	5c c0       	rjmp	.+184    	; 0xe34 <vTaskIncrementTick+0x19c>
     d7c:	80 91 54 02 	lds	r24, 0x0254
     d80:	90 91 55 02 	lds	r25, 0x0255
     d84:	fc 01       	movw	r30, r24
     d86:	85 81       	ldd	r24, Z+5	; 0x05
     d88:	96 81       	ldd	r25, Z+6	; 0x06
     d8a:	fc 01       	movw	r30, r24
     d8c:	86 81       	ldd	r24, Z+6	; 0x06
     d8e:	97 81       	ldd	r25, Z+7	; 0x07
     d90:	9c 83       	std	Y+4, r25	; 0x04
     d92:	8b 83       	std	Y+3, r24	; 0x03
     d94:	8b 81       	ldd	r24, Y+3	; 0x03
     d96:	9c 81       	ldd	r25, Y+4	; 0x04
     d98:	fc 01       	movw	r30, r24
     d9a:	82 81       	ldd	r24, Z+2	; 0x02
     d9c:	93 81       	ldd	r25, Z+3	; 0x03
     d9e:	9e 83       	std	Y+6, r25	; 0x06
     da0:	8d 83       	std	Y+5, r24	; 0x05
     da2:	20 91 6b 02 	lds	r18, 0x026B
     da6:	30 91 6c 02 	lds	r19, 0x026C
     daa:	8d 81       	ldd	r24, Y+5	; 0x05
     dac:	9e 81       	ldd	r25, Y+6	; 0x06
     dae:	28 17       	cp	r18, r24
     db0:	39 07       	cpc	r19, r25
     db2:	38 f4       	brcc	.+14     	; 0xdc2 <vTaskIncrementTick+0x12a>
     db4:	8d 81       	ldd	r24, Y+5	; 0x05
     db6:	9e 81       	ldd	r25, Y+6	; 0x06
     db8:	90 93 01 02 	sts	0x0201, r25
     dbc:	80 93 00 02 	sts	0x0200, r24
     dc0:	39 c0       	rjmp	.+114    	; 0xe34 <vTaskIncrementTick+0x19c>
     dc2:	8b 81       	ldd	r24, Y+3	; 0x03
     dc4:	9c 81       	ldd	r25, Y+4	; 0x04
     dc6:	02 96       	adiw	r24, 0x02	; 2
     dc8:	0e 94 4f 12 	call	0x249e	; 0x249e <uxListRemove>
     dcc:	8b 81       	ldd	r24, Y+3	; 0x03
     dce:	9c 81       	ldd	r25, Y+4	; 0x04
     dd0:	fc 01       	movw	r30, r24
     dd2:	84 89       	ldd	r24, Z+20	; 0x14
     dd4:	95 89       	ldd	r25, Z+21	; 0x15
     dd6:	00 97       	sbiw	r24, 0x00	; 0
     dd8:	29 f0       	breq	.+10     	; 0xde4 <vTaskIncrementTick+0x14c>
     dda:	8b 81       	ldd	r24, Y+3	; 0x03
     ddc:	9c 81       	ldd	r25, Y+4	; 0x04
     dde:	0c 96       	adiw	r24, 0x0c	; 12
     de0:	0e 94 4f 12 	call	0x249e	; 0x249e <uxListRemove>
     de4:	8b 81       	ldd	r24, Y+3	; 0x03
     de6:	9c 81       	ldd	r25, Y+4	; 0x04
     de8:	fc 01       	movw	r30, r24
     dea:	96 89       	ldd	r25, Z+22	; 0x16
     dec:	80 91 6e 02 	lds	r24, 0x026E
     df0:	89 17       	cp	r24, r25
     df2:	30 f4       	brcc	.+12     	; 0xe00 <vTaskIncrementTick+0x168>
     df4:	8b 81       	ldd	r24, Y+3	; 0x03
     df6:	9c 81       	ldd	r25, Y+4	; 0x04
     df8:	fc 01       	movw	r30, r24
     dfa:	86 89       	ldd	r24, Z+22	; 0x16
     dfc:	80 93 6e 02 	sts	0x026E, r24
     e00:	8b 81       	ldd	r24, Y+3	; 0x03
     e02:	9c 81       	ldd	r25, Y+4	; 0x04
     e04:	ac 01       	movw	r20, r24
     e06:	4e 5f       	subi	r20, 0xFE	; 254
     e08:	5f 4f       	sbci	r21, 0xFF	; 255
     e0a:	8b 81       	ldd	r24, Y+3	; 0x03
     e0c:	9c 81       	ldd	r25, Y+4	; 0x04
     e0e:	fc 01       	movw	r30, r24
     e10:	86 89       	ldd	r24, Z+22	; 0x16
     e12:	28 2f       	mov	r18, r24
     e14:	30 e0       	ldi	r19, 0x00	; 0
     e16:	c9 01       	movw	r24, r18
     e18:	88 0f       	add	r24, r24
     e1a:	99 1f       	adc	r25, r25
     e1c:	88 0f       	add	r24, r24
     e1e:	99 1f       	adc	r25, r25
     e20:	88 0f       	add	r24, r24
     e22:	99 1f       	adc	r25, r25
     e24:	82 0f       	add	r24, r18
     e26:	93 1f       	adc	r25, r19
     e28:	82 5e       	subi	r24, 0xE2	; 226
     e2a:	9d 4f       	sbci	r25, 0xFD	; 253
     e2c:	ba 01       	movw	r22, r20
     e2e:	0e 94 7f 11 	call	0x22fe	; 0x22fe <vListInsertEnd>
     e32:	95 cf       	rjmp	.-214    	; 0xd5e <vTaskIncrementTick+0xc6>
     e34:	07 c0       	rjmp	.+14     	; 0xe44 <vTaskIncrementTick+0x1ac>
	}
	else
	{
		++uxMissedTicks;
     e36:	80 91 71 02 	lds	r24, 0x0271
     e3a:	8f 5f       	subi	r24, 0xFF	; 255
     e3c:	80 93 71 02 	sts	0x0271, r24

		/* The tick hook gets called at regular intervals, even if the
		scheduler is locked. */
		#if ( configUSE_TICK_HOOK == 1 )
		{
			vApplicationTickHook();
     e40:	0e 94 9f 00 	call	0x13e	; 0x13e <vApplicationTickHook>

	#if ( configUSE_TICK_HOOK == 1 )
	{
		/* Guard against the tick hook being called when the missed tick
		count is being unwound (when the scheduler is being unlocked. */
		if( uxMissedTicks == ( unsigned portBASE_TYPE ) 0U )
     e44:	80 91 71 02 	lds	r24, 0x0271
     e48:	88 23       	and	r24, r24
     e4a:	11 f4       	brne	.+4      	; 0xe50 <vTaskIncrementTick+0x1b8>
		{
			vApplicationTickHook();
     e4c:	0e 94 9f 00 	call	0x13e	; 0x13e <vApplicationTickHook>
		}
	}
	#endif
}
     e50:	26 96       	adiw	r28, 0x06	; 6
     e52:	0f b6       	in	r0, 0x3f	; 63
     e54:	f8 94       	cli
     e56:	de bf       	out	0x3e, r29	; 62
     e58:	0f be       	out	0x3f, r0	; 63
     e5a:	cd bf       	out	0x3d, r28	; 61
     e5c:	df 91       	pop	r29
     e5e:	cf 91       	pop	r28
     e60:	08 95       	ret

00000e62 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
     e62:	cf 93       	push	r28
     e64:	df 93       	push	r29
     e66:	1f 92       	push	r1
     e68:	1f 92       	push	r1
     e6a:	cd b7       	in	r28, 0x3d	; 61
     e6c:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
     e6e:	80 91 70 02 	lds	r24, 0x0270
     e72:	88 23       	and	r24, r24
     e74:	21 f0       	breq	.+8      	; 0xe7e <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
     e76:	81 e0       	ldi	r24, 0x01	; 1
     e78:	80 93 72 02 	sts	0x0272, r24
     e7c:	5b c0       	rjmp	.+182    	; 0xf34 <vTaskSwitchContext+0xd2>

//BB Commented out...
//		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
     e7e:	05 c0       	rjmp	.+10     	; 0xe8a <vTaskSwitchContext+0x28>
     e80:	80 91 6e 02 	lds	r24, 0x026E
     e84:	81 50       	subi	r24, 0x01	; 1
     e86:	80 93 6e 02 	sts	0x026E, r24
     e8a:	80 91 6e 02 	lds	r24, 0x026E
     e8e:	28 2f       	mov	r18, r24
     e90:	30 e0       	ldi	r19, 0x00	; 0
     e92:	c9 01       	movw	r24, r18
     e94:	88 0f       	add	r24, r24
     e96:	99 1f       	adc	r25, r25
     e98:	88 0f       	add	r24, r24
     e9a:	99 1f       	adc	r25, r25
     e9c:	88 0f       	add	r24, r24
     e9e:	99 1f       	adc	r25, r25
     ea0:	82 0f       	add	r24, r18
     ea2:	93 1f       	adc	r25, r19
     ea4:	82 5e       	subi	r24, 0xE2	; 226
     ea6:	9d 4f       	sbci	r25, 0xFD	; 253
     ea8:	fc 01       	movw	r30, r24
     eaa:	80 81       	ld	r24, Z
     eac:	88 23       	and	r24, r24
     eae:	41 f3       	breq	.-48     	; 0xe80 <vTaskSwitchContext+0x1e>
     eb0:	80 91 6e 02 	lds	r24, 0x026E
     eb4:	28 2f       	mov	r18, r24
     eb6:	30 e0       	ldi	r19, 0x00	; 0
     eb8:	c9 01       	movw	r24, r18
     eba:	88 0f       	add	r24, r24
     ebc:	99 1f       	adc	r25, r25
     ebe:	88 0f       	add	r24, r24
     ec0:	99 1f       	adc	r25, r25
     ec2:	88 0f       	add	r24, r24
     ec4:	99 1f       	adc	r25, r25
     ec6:	82 0f       	add	r24, r18
     ec8:	93 1f       	adc	r25, r19
     eca:	82 5e       	subi	r24, 0xE2	; 226
     ecc:	9d 4f       	sbci	r25, 0xFD	; 253
     ece:	9a 83       	std	Y+2, r25	; 0x02
     ed0:	89 83       	std	Y+1, r24	; 0x01
     ed2:	89 81       	ldd	r24, Y+1	; 0x01
     ed4:	9a 81       	ldd	r25, Y+2	; 0x02
     ed6:	fc 01       	movw	r30, r24
     ed8:	81 81       	ldd	r24, Z+1	; 0x01
     eda:	92 81       	ldd	r25, Z+2	; 0x02
     edc:	fc 01       	movw	r30, r24
     ede:	22 81       	ldd	r18, Z+2	; 0x02
     ee0:	33 81       	ldd	r19, Z+3	; 0x03
     ee2:	89 81       	ldd	r24, Y+1	; 0x01
     ee4:	9a 81       	ldd	r25, Y+2	; 0x02
     ee6:	fc 01       	movw	r30, r24
     ee8:	32 83       	std	Z+2, r19	; 0x02
     eea:	21 83       	std	Z+1, r18	; 0x01
     eec:	89 81       	ldd	r24, Y+1	; 0x01
     eee:	9a 81       	ldd	r25, Y+2	; 0x02
     ef0:	fc 01       	movw	r30, r24
     ef2:	21 81       	ldd	r18, Z+1	; 0x01
     ef4:	32 81       	ldd	r19, Z+2	; 0x02
     ef6:	89 81       	ldd	r24, Y+1	; 0x01
     ef8:	9a 81       	ldd	r25, Y+2	; 0x02
     efa:	03 96       	adiw	r24, 0x03	; 3
     efc:	28 17       	cp	r18, r24
     efe:	39 07       	cpc	r19, r25
     f00:	69 f4       	brne	.+26     	; 0xf1c <vTaskSwitchContext+0xba>
     f02:	89 81       	ldd	r24, Y+1	; 0x01
     f04:	9a 81       	ldd	r25, Y+2	; 0x02
     f06:	fc 01       	movw	r30, r24
     f08:	81 81       	ldd	r24, Z+1	; 0x01
     f0a:	92 81       	ldd	r25, Z+2	; 0x02
     f0c:	fc 01       	movw	r30, r24
     f0e:	22 81       	ldd	r18, Z+2	; 0x02
     f10:	33 81       	ldd	r19, Z+3	; 0x03
     f12:	89 81       	ldd	r24, Y+1	; 0x01
     f14:	9a 81       	ldd	r25, Y+2	; 0x02
     f16:	fc 01       	movw	r30, r24
     f18:	32 83       	std	Z+2, r19	; 0x02
     f1a:	21 83       	std	Z+1, r18	; 0x01
     f1c:	89 81       	ldd	r24, Y+1	; 0x01
     f1e:	9a 81       	ldd	r25, Y+2	; 0x02
     f20:	fc 01       	movw	r30, r24
     f22:	81 81       	ldd	r24, Z+1	; 0x01
     f24:	92 81       	ldd	r25, Z+2	; 0x02
     f26:	fc 01       	movw	r30, r24
     f28:	86 81       	ldd	r24, Z+6	; 0x06
     f2a:	97 81       	ldd	r25, Z+7	; 0x07
     f2c:	90 93 1d 02 	sts	0x021D, r25
     f30:	80 93 1c 02 	sts	0x021C, r24

		traceTASK_SWITCHED_IN();
	}
}
     f34:	0f 90       	pop	r0
     f36:	0f 90       	pop	r0
     f38:	df 91       	pop	r29
     f3a:	cf 91       	pop	r28
     f3c:	08 95       	ret

00000f3e <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
     f3e:	cf 93       	push	r28
     f40:	df 93       	push	r29
     f42:	00 d0       	rcall	.+0      	; 0xf44 <vTaskPlaceOnEventList+0x6>
     f44:	00 d0       	rcall	.+0      	; 0xf46 <vTaskPlaceOnEventList+0x8>
     f46:	cd b7       	in	r28, 0x3d	; 61
     f48:	de b7       	in	r29, 0x3e	; 62
     f4a:	9c 83       	std	Y+4, r25	; 0x04
     f4c:	8b 83       	std	Y+3, r24	; 0x03
     f4e:	7e 83       	std	Y+6, r23	; 0x06
     f50:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
     f52:	80 91 1c 02 	lds	r24, 0x021C
     f56:	90 91 1d 02 	lds	r25, 0x021D
     f5a:	9c 01       	movw	r18, r24
     f5c:	24 5f       	subi	r18, 0xF4	; 244
     f5e:	3f 4f       	sbci	r19, 0xFF	; 255
     f60:	8b 81       	ldd	r24, Y+3	; 0x03
     f62:	9c 81       	ldd	r25, Y+4	; 0x04
     f64:	b9 01       	movw	r22, r18
     f66:	0e 94 d6 11 	call	0x23ac	; 0x23ac <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
     f6a:	80 91 1c 02 	lds	r24, 0x021C
     f6e:	90 91 1d 02 	lds	r25, 0x021D
     f72:	02 96       	adiw	r24, 0x02	; 2
     f74:	0e 94 4f 12 	call	0x249e	; 0x249e <uxListRemove>
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
     f78:	8d 81       	ldd	r24, Y+5	; 0x05
     f7a:	9e 81       	ldd	r25, Y+6	; 0x06
     f7c:	8f 3f       	cpi	r24, 0xFF	; 255
     f7e:	2f ef       	ldi	r18, 0xFF	; 255
     f80:	92 07       	cpc	r25, r18
     f82:	59 f4       	brne	.+22     	; 0xf9a <vTaskPlaceOnEventList+0x5c>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
     f84:	80 91 1c 02 	lds	r24, 0x021C
     f88:	90 91 1d 02 	lds	r25, 0x021D
     f8c:	02 96       	adiw	r24, 0x02	; 2
     f8e:	bc 01       	movw	r22, r24
     f90:	81 e6       	ldi	r24, 0x61	; 97
     f92:	92 e0       	ldi	r25, 0x02	; 2
     f94:	0e 94 7f 11 	call	0x22fe	; 0x22fe <vListInsertEnd>
     f98:	0e c0       	rjmp	.+28     	; 0xfb6 <vTaskPlaceOnEventList+0x78>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
     f9a:	20 91 6b 02 	lds	r18, 0x026B
     f9e:	30 91 6c 02 	lds	r19, 0x026C
     fa2:	8d 81       	ldd	r24, Y+5	; 0x05
     fa4:	9e 81       	ldd	r25, Y+6	; 0x06
     fa6:	82 0f       	add	r24, r18
     fa8:	93 1f       	adc	r25, r19
     faa:	9a 83       	std	Y+2, r25	; 0x02
     fac:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
     fae:	89 81       	ldd	r24, Y+1	; 0x01
     fb0:	9a 81       	ldd	r25, Y+2	; 0x02
     fb2:	0e 94 9a 09 	call	0x1334	; 0x1334 <prvAddCurrentTaskToDelayedList>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
     fb6:	26 96       	adiw	r28, 0x06	; 6
     fb8:	0f b6       	in	r0, 0x3f	; 63
     fba:	f8 94       	cli
     fbc:	de bf       	out	0x3e, r29	; 62
     fbe:	0f be       	out	0x3f, r0	; 63
     fc0:	cd bf       	out	0x3d, r28	; 61
     fc2:	df 91       	pop	r29
     fc4:	cf 91       	pop	r28
     fc6:	08 95       	ret

00000fc8 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
     fc8:	cf 93       	push	r28
     fca:	df 93       	push	r29
     fcc:	00 d0       	rcall	.+0      	; 0xfce <xTaskRemoveFromEventList+0x6>
     fce:	1f 92       	push	r1
     fd0:	1f 92       	push	r1
     fd2:	cd b7       	in	r28, 0x3d	; 61
     fd4:	de b7       	in	r29, 0x3e	; 62
     fd6:	9d 83       	std	Y+5, r25	; 0x05
     fd8:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     fda:	8c 81       	ldd	r24, Y+4	; 0x04
     fdc:	9d 81       	ldd	r25, Y+5	; 0x05
     fde:	fc 01       	movw	r30, r24
     fe0:	85 81       	ldd	r24, Z+5	; 0x05
     fe2:	96 81       	ldd	r25, Z+6	; 0x06
     fe4:	fc 01       	movw	r30, r24
     fe6:	86 81       	ldd	r24, Z+6	; 0x06
     fe8:	97 81       	ldd	r25, Z+7	; 0x07
     fea:	9b 83       	std	Y+3, r25	; 0x03
     fec:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
     fee:	8a 81       	ldd	r24, Y+2	; 0x02
     ff0:	9b 81       	ldd	r25, Y+3	; 0x03
     ff2:	0c 96       	adiw	r24, 0x0c	; 12
     ff4:	0e 94 4f 12 	call	0x249e	; 0x249e <uxListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     ff8:	80 91 70 02 	lds	r24, 0x0270
     ffc:	88 23       	and	r24, r24
     ffe:	69 f5       	brne	.+90     	; 0x105a <xTaskRemoveFromEventList+0x92>
	{
		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    1000:	8a 81       	ldd	r24, Y+2	; 0x02
    1002:	9b 81       	ldd	r25, Y+3	; 0x03
    1004:	02 96       	adiw	r24, 0x02	; 2
    1006:	0e 94 4f 12 	call	0x249e	; 0x249e <uxListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    100a:	8a 81       	ldd	r24, Y+2	; 0x02
    100c:	9b 81       	ldd	r25, Y+3	; 0x03
    100e:	fc 01       	movw	r30, r24
    1010:	96 89       	ldd	r25, Z+22	; 0x16
    1012:	80 91 6e 02 	lds	r24, 0x026E
    1016:	89 17       	cp	r24, r25
    1018:	30 f4       	brcc	.+12     	; 0x1026 <xTaskRemoveFromEventList+0x5e>
    101a:	8a 81       	ldd	r24, Y+2	; 0x02
    101c:	9b 81       	ldd	r25, Y+3	; 0x03
    101e:	fc 01       	movw	r30, r24
    1020:	86 89       	ldd	r24, Z+22	; 0x16
    1022:	80 93 6e 02 	sts	0x026E, r24
    1026:	8a 81       	ldd	r24, Y+2	; 0x02
    1028:	9b 81       	ldd	r25, Y+3	; 0x03
    102a:	ac 01       	movw	r20, r24
    102c:	4e 5f       	subi	r20, 0xFE	; 254
    102e:	5f 4f       	sbci	r21, 0xFF	; 255
    1030:	8a 81       	ldd	r24, Y+2	; 0x02
    1032:	9b 81       	ldd	r25, Y+3	; 0x03
    1034:	fc 01       	movw	r30, r24
    1036:	86 89       	ldd	r24, Z+22	; 0x16
    1038:	28 2f       	mov	r18, r24
    103a:	30 e0       	ldi	r19, 0x00	; 0
    103c:	c9 01       	movw	r24, r18
    103e:	88 0f       	add	r24, r24
    1040:	99 1f       	adc	r25, r25
    1042:	88 0f       	add	r24, r24
    1044:	99 1f       	adc	r25, r25
    1046:	88 0f       	add	r24, r24
    1048:	99 1f       	adc	r25, r25
    104a:	82 0f       	add	r24, r18
    104c:	93 1f       	adc	r25, r19
    104e:	82 5e       	subi	r24, 0xE2	; 226
    1050:	9d 4f       	sbci	r25, 0xFD	; 253
    1052:	ba 01       	movw	r22, r20
    1054:	0e 94 7f 11 	call	0x22fe	; 0x22fe <vListInsertEnd>
    1058:	08 c0       	rjmp	.+16     	; 0x106a <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    105a:	8a 81       	ldd	r24, Y+2	; 0x02
    105c:	9b 81       	ldd	r25, Y+3	; 0x03
    105e:	0c 96       	adiw	r24, 0x0c	; 12
    1060:	bc 01       	movw	r22, r24
    1062:	88 e5       	ldi	r24, 0x58	; 88
    1064:	92 e0       	ldi	r25, 0x02	; 2
    1066:	0e 94 7f 11 	call	0x22fe	; 0x22fe <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    106a:	8a 81       	ldd	r24, Y+2	; 0x02
    106c:	9b 81       	ldd	r25, Y+3	; 0x03
    106e:	fc 01       	movw	r30, r24
    1070:	26 89       	ldd	r18, Z+22	; 0x16
    1072:	80 91 1c 02 	lds	r24, 0x021C
    1076:	90 91 1d 02 	lds	r25, 0x021D
    107a:	fc 01       	movw	r30, r24
    107c:	86 89       	ldd	r24, Z+22	; 0x16
    107e:	28 17       	cp	r18, r24
    1080:	18 f0       	brcs	.+6      	; 0x1088 <xTaskRemoveFromEventList+0xc0>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    1082:	81 e0       	ldi	r24, 0x01	; 1
    1084:	89 83       	std	Y+1, r24	; 0x01
    1086:	01 c0       	rjmp	.+2      	; 0x108a <xTaskRemoveFromEventList+0xc2>
	}
	else
	{
		xReturn = pdFALSE;
    1088:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    108a:	89 81       	ldd	r24, Y+1	; 0x01
}
    108c:	0f 90       	pop	r0
    108e:	0f 90       	pop	r0
    1090:	0f 90       	pop	r0
    1092:	0f 90       	pop	r0
    1094:	0f 90       	pop	r0
    1096:	df 91       	pop	r29
    1098:	cf 91       	pop	r28
    109a:	08 95       	ret

0000109c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    109c:	cf 93       	push	r28
    109e:	df 93       	push	r29
    10a0:	1f 92       	push	r1
    10a2:	1f 92       	push	r1
    10a4:	cd b7       	in	r28, 0x3d	; 61
    10a6:	de b7       	in	r29, 0x3e	; 62
    10a8:	9a 83       	std	Y+2, r25	; 0x02
    10aa:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    10ac:	20 91 73 02 	lds	r18, 0x0273
    10b0:	89 81       	ldd	r24, Y+1	; 0x01
    10b2:	9a 81       	ldd	r25, Y+2	; 0x02
    10b4:	fc 01       	movw	r30, r24
    10b6:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    10b8:	20 91 6b 02 	lds	r18, 0x026B
    10bc:	30 91 6c 02 	lds	r19, 0x026C
    10c0:	89 81       	ldd	r24, Y+1	; 0x01
    10c2:	9a 81       	ldd	r25, Y+2	; 0x02
    10c4:	fc 01       	movw	r30, r24
    10c6:	32 83       	std	Z+2, r19	; 0x02
    10c8:	21 83       	std	Z+1, r18	; 0x01
}
    10ca:	0f 90       	pop	r0
    10cc:	0f 90       	pop	r0
    10ce:	df 91       	pop	r29
    10d0:	cf 91       	pop	r28
    10d2:	08 95       	ret

000010d4 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    10d4:	cf 93       	push	r28
    10d6:	df 93       	push	r29
    10d8:	00 d0       	rcall	.+0      	; 0x10da <xTaskCheckForTimeOut+0x6>
    10da:	1f 92       	push	r1
    10dc:	1f 92       	push	r1
    10de:	cd b7       	in	r28, 0x3d	; 61
    10e0:	de b7       	in	r29, 0x3e	; 62
    10e2:	9b 83       	std	Y+3, r25	; 0x03
    10e4:	8a 83       	std	Y+2, r24	; 0x02
    10e6:	7d 83       	std	Y+5, r23	; 0x05
    10e8:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    10ea:	0f b6       	in	r0, 0x3f	; 63
    10ec:	f8 94       	cli
    10ee:	0f 92       	push	r0
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    10f0:	8c 81       	ldd	r24, Y+4	; 0x04
    10f2:	9d 81       	ldd	r25, Y+5	; 0x05
    10f4:	fc 01       	movw	r30, r24
    10f6:	80 81       	ld	r24, Z
    10f8:	91 81       	ldd	r25, Z+1	; 0x01
    10fa:	8f 3f       	cpi	r24, 0xFF	; 255
    10fc:	ff ef       	ldi	r31, 0xFF	; 255
    10fe:	9f 07       	cpc	r25, r31
    1100:	11 f4       	brne	.+4      	; 0x1106 <xTaskCheckForTimeOut+0x32>
			{
				xReturn = pdFALSE;
    1102:	19 82       	std	Y+1, r1	; 0x01
    1104:	4b c0       	rjmp	.+150    	; 0x119c <xTaskCheckForTimeOut+0xc8>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    1106:	8a 81       	ldd	r24, Y+2	; 0x02
    1108:	9b 81       	ldd	r25, Y+3	; 0x03
    110a:	fc 01       	movw	r30, r24
    110c:	90 81       	ld	r25, Z
    110e:	80 91 73 02 	lds	r24, 0x0273
    1112:	98 17       	cp	r25, r24
    1114:	79 f0       	breq	.+30     	; 0x1134 <xTaskCheckForTimeOut+0x60>
    1116:	8a 81       	ldd	r24, Y+2	; 0x02
    1118:	9b 81       	ldd	r25, Y+3	; 0x03
    111a:	fc 01       	movw	r30, r24
    111c:	21 81       	ldd	r18, Z+1	; 0x01
    111e:	32 81       	ldd	r19, Z+2	; 0x02
    1120:	80 91 6b 02 	lds	r24, 0x026B
    1124:	90 91 6c 02 	lds	r25, 0x026C
    1128:	82 17       	cp	r24, r18
    112a:	93 07       	cpc	r25, r19
    112c:	18 f0       	brcs	.+6      	; 0x1134 <xTaskCheckForTimeOut+0x60>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    112e:	81 e0       	ldi	r24, 0x01	; 1
    1130:	89 83       	std	Y+1, r24	; 0x01
    1132:	34 c0       	rjmp	.+104    	; 0x119c <xTaskCheckForTimeOut+0xc8>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    1134:	20 91 6b 02 	lds	r18, 0x026B
    1138:	30 91 6c 02 	lds	r19, 0x026C
    113c:	8a 81       	ldd	r24, Y+2	; 0x02
    113e:	9b 81       	ldd	r25, Y+3	; 0x03
    1140:	fc 01       	movw	r30, r24
    1142:	81 81       	ldd	r24, Z+1	; 0x01
    1144:	92 81       	ldd	r25, Z+2	; 0x02
    1146:	28 1b       	sub	r18, r24
    1148:	39 0b       	sbc	r19, r25
    114a:	8c 81       	ldd	r24, Y+4	; 0x04
    114c:	9d 81       	ldd	r25, Y+5	; 0x05
    114e:	fc 01       	movw	r30, r24
    1150:	80 81       	ld	r24, Z
    1152:	91 81       	ldd	r25, Z+1	; 0x01
    1154:	28 17       	cp	r18, r24
    1156:	39 07       	cpc	r19, r25
    1158:	f8 f4       	brcc	.+62     	; 0x1198 <xTaskCheckForTimeOut+0xc4>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    115a:	8c 81       	ldd	r24, Y+4	; 0x04
    115c:	9d 81       	ldd	r25, Y+5	; 0x05
    115e:	fc 01       	movw	r30, r24
    1160:	20 81       	ld	r18, Z
    1162:	31 81       	ldd	r19, Z+1	; 0x01
    1164:	8a 81       	ldd	r24, Y+2	; 0x02
    1166:	9b 81       	ldd	r25, Y+3	; 0x03
    1168:	fc 01       	movw	r30, r24
    116a:	41 81       	ldd	r20, Z+1	; 0x01
    116c:	52 81       	ldd	r21, Z+2	; 0x02
    116e:	80 91 6b 02 	lds	r24, 0x026B
    1172:	90 91 6c 02 	lds	r25, 0x026C
    1176:	ba 01       	movw	r22, r20
    1178:	68 1b       	sub	r22, r24
    117a:	79 0b       	sbc	r23, r25
    117c:	cb 01       	movw	r24, r22
    117e:	28 0f       	add	r18, r24
    1180:	39 1f       	adc	r19, r25
    1182:	8c 81       	ldd	r24, Y+4	; 0x04
    1184:	9d 81       	ldd	r25, Y+5	; 0x05
    1186:	fc 01       	movw	r30, r24
    1188:	31 83       	std	Z+1, r19	; 0x01
    118a:	20 83       	st	Z, r18
			vTaskSetTimeOutState( pxTimeOut );
    118c:	8a 81       	ldd	r24, Y+2	; 0x02
    118e:	9b 81       	ldd	r25, Y+3	; 0x03
    1190:	0e 94 4e 08 	call	0x109c	; 0x109c <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    1194:	19 82       	std	Y+1, r1	; 0x01
    1196:	02 c0       	rjmp	.+4      	; 0x119c <xTaskCheckForTimeOut+0xc8>
		}
		else
		{
			xReturn = pdTRUE;
    1198:	81 e0       	ldi	r24, 0x01	; 1
    119a:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    119c:	0f 90       	pop	r0
    119e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    11a0:	89 81       	ldd	r24, Y+1	; 0x01
}
    11a2:	0f 90       	pop	r0
    11a4:	0f 90       	pop	r0
    11a6:	0f 90       	pop	r0
    11a8:	0f 90       	pop	r0
    11aa:	0f 90       	pop	r0
    11ac:	df 91       	pop	r29
    11ae:	cf 91       	pop	r28
    11b0:	08 95       	ret

000011b2 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    11b2:	cf 93       	push	r28
    11b4:	df 93       	push	r29
    11b6:	cd b7       	in	r28, 0x3d	; 61
    11b8:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    11ba:	81 e0       	ldi	r24, 0x01	; 1
    11bc:	80 93 72 02 	sts	0x0272, r24
}
    11c0:	df 91       	pop	r29
    11c2:	cf 91       	pop	r28
    11c4:	08 95       	ret

000011c6 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    11c6:	cf 93       	push	r28
    11c8:	df 93       	push	r29
    11ca:	1f 92       	push	r1
    11cc:	1f 92       	push	r1
    11ce:	cd b7       	in	r28, 0x3d	; 61
    11d0:	de b7       	in	r29, 0x3e	; 62
    11d2:	9a 83       	std	Y+2, r25	; 0x02
    11d4:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    11d6:	0e 94 93 09 	call	0x1326	; 0x1326 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    11da:	80 91 1e 02 	lds	r24, 0x021E
    11de:	82 30       	cpi	r24, 0x02	; 2
    11e0:	18 f0       	brcs	.+6      	; 0x11e8 <prvIdleTask+0x22>
			{
				taskYIELD();
    11e2:	0e 94 11 18 	call	0x3022	; 0x3022 <vPortYield>
				}
				xTaskResumeAll();
			}
		}
		#endif
	}
    11e6:	f7 cf       	rjmp	.-18     	; 0x11d6 <prvIdleTask+0x10>
    11e8:	f6 cf       	rjmp	.-20     	; 0x11d6 <prvIdleTask+0x10>

000011ea <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    11ea:	0f 93       	push	r16
    11ec:	1f 93       	push	r17
    11ee:	cf 93       	push	r28
    11f0:	df 93       	push	r29
    11f2:	cd b7       	in	r28, 0x3d	; 61
    11f4:	de b7       	in	r29, 0x3e	; 62
    11f6:	29 97       	sbiw	r28, 0x09	; 9
    11f8:	0f b6       	in	r0, 0x3f	; 63
    11fa:	f8 94       	cli
    11fc:	de bf       	out	0x3e, r29	; 62
    11fe:	0f be       	out	0x3f, r0	; 63
    1200:	cd bf       	out	0x3d, r28	; 61
    1202:	9a 83       	std	Y+2, r25	; 0x02
    1204:	89 83       	std	Y+1, r24	; 0x01
    1206:	7c 83       	std	Y+4, r23	; 0x04
    1208:	6b 83       	std	Y+3, r22	; 0x03
    120a:	4d 83       	std	Y+5, r20	; 0x05
    120c:	3f 83       	std	Y+7, r19	; 0x07
    120e:	2e 83       	std	Y+6, r18	; 0x06
    1210:	19 87       	std	Y+9, r17	; 0x09
    1212:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    1214:	89 81       	ldd	r24, Y+1	; 0x01
    1216:	9a 81       	ldd	r25, Y+2	; 0x02
    1218:	49 96       	adiw	r24, 0x19	; 25
    121a:	2b 81       	ldd	r18, Y+3	; 0x03
    121c:	3c 81       	ldd	r19, Y+4	; 0x04
    121e:	40 e1       	ldi	r20, 0x10	; 16
    1220:	50 e0       	ldi	r21, 0x00	; 0
    1222:	b9 01       	movw	r22, r18
    1224:	0e 94 b5 1d 	call	0x3b6a	; 0x3b6a <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    1228:	89 81       	ldd	r24, Y+1	; 0x01
    122a:	9a 81       	ldd	r25, Y+2	; 0x02
    122c:	fc 01       	movw	r30, r24
    122e:	10 a6       	std	Z+40, r1	; 0x28

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    1230:	8d 81       	ldd	r24, Y+5	; 0x05
    1232:	84 30       	cpi	r24, 0x04	; 4
    1234:	10 f0       	brcs	.+4      	; 0x123a <prvInitialiseTCBVariables+0x50>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    1236:	83 e0       	ldi	r24, 0x03	; 3
    1238:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    123a:	89 81       	ldd	r24, Y+1	; 0x01
    123c:	9a 81       	ldd	r25, Y+2	; 0x02
    123e:	2d 81       	ldd	r18, Y+5	; 0x05
    1240:	fc 01       	movw	r30, r24
    1242:	26 8b       	std	Z+22, r18	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    1244:	89 81       	ldd	r24, Y+1	; 0x01
    1246:	9a 81       	ldd	r25, Y+2	; 0x02
    1248:	2d 81       	ldd	r18, Y+5	; 0x05
    124a:	fc 01       	movw	r30, r24
    124c:	21 a7       	std	Z+41, r18	; 0x29
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    124e:	89 81       	ldd	r24, Y+1	; 0x01
    1250:	9a 81       	ldd	r25, Y+2	; 0x02
    1252:	02 96       	adiw	r24, 0x02	; 2
    1254:	0e 94 6d 11 	call	0x22da	; 0x22da <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    1258:	89 81       	ldd	r24, Y+1	; 0x01
    125a:	9a 81       	ldd	r25, Y+2	; 0x02
    125c:	0c 96       	adiw	r24, 0x0c	; 12
    125e:	0e 94 6d 11 	call	0x22da	; 0x22da <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    1262:	89 81       	ldd	r24, Y+1	; 0x01
    1264:	9a 81       	ldd	r25, Y+2	; 0x02
    1266:	29 81       	ldd	r18, Y+1	; 0x01
    1268:	3a 81       	ldd	r19, Y+2	; 0x02
    126a:	fc 01       	movw	r30, r24
    126c:	31 87       	std	Z+9, r19	; 0x09
    126e:	20 87       	std	Z+8, r18	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    1270:	8d 81       	ldd	r24, Y+5	; 0x05
    1272:	88 2f       	mov	r24, r24
    1274:	90 e0       	ldi	r25, 0x00	; 0
    1276:	24 e0       	ldi	r18, 0x04	; 4
    1278:	30 e0       	ldi	r19, 0x00	; 0
    127a:	28 1b       	sub	r18, r24
    127c:	39 0b       	sbc	r19, r25
    127e:	89 81       	ldd	r24, Y+1	; 0x01
    1280:	9a 81       	ldd	r25, Y+2	; 0x02
    1282:	fc 01       	movw	r30, r24
    1284:	35 87       	std	Z+13, r19	; 0x0d
    1286:	24 87       	std	Z+12, r18	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    1288:	89 81       	ldd	r24, Y+1	; 0x01
    128a:	9a 81       	ldd	r25, Y+2	; 0x02
    128c:	29 81       	ldd	r18, Y+1	; 0x01
    128e:	3a 81       	ldd	r19, Y+2	; 0x02
    1290:	fc 01       	movw	r30, r24
    1292:	33 8b       	std	Z+19, r19	; 0x13
    1294:	22 8b       	std	Z+18, r18	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    1296:	29 96       	adiw	r28, 0x09	; 9
    1298:	0f b6       	in	r0, 0x3f	; 63
    129a:	f8 94       	cli
    129c:	de bf       	out	0x3e, r29	; 62
    129e:	0f be       	out	0x3f, r0	; 63
    12a0:	cd bf       	out	0x3d, r28	; 61
    12a2:	df 91       	pop	r29
    12a4:	cf 91       	pop	r28
    12a6:	1f 91       	pop	r17
    12a8:	0f 91       	pop	r16
    12aa:	08 95       	ret

000012ac <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    12ac:	cf 93       	push	r28
    12ae:	df 93       	push	r29
    12b0:	1f 92       	push	r1
    12b2:	cd b7       	in	r28, 0x3d	; 61
    12b4:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    12b6:	19 82       	std	Y+1, r1	; 0x01
    12b8:	13 c0       	rjmp	.+38     	; 0x12e0 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    12ba:	89 81       	ldd	r24, Y+1	; 0x01
    12bc:	28 2f       	mov	r18, r24
    12be:	30 e0       	ldi	r19, 0x00	; 0
    12c0:	c9 01       	movw	r24, r18
    12c2:	88 0f       	add	r24, r24
    12c4:	99 1f       	adc	r25, r25
    12c6:	88 0f       	add	r24, r24
    12c8:	99 1f       	adc	r25, r25
    12ca:	88 0f       	add	r24, r24
    12cc:	99 1f       	adc	r25, r25
    12ce:	82 0f       	add	r24, r18
    12d0:	93 1f       	adc	r25, r19
    12d2:	82 5e       	subi	r24, 0xE2	; 226
    12d4:	9d 4f       	sbci	r25, 0xFD	; 253
    12d6:	0e 94 37 11 	call	0x226e	; 0x226e <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    12da:	89 81       	ldd	r24, Y+1	; 0x01
    12dc:	8f 5f       	subi	r24, 0xFF	; 255
    12de:	89 83       	std	Y+1, r24	; 0x01
    12e0:	89 81       	ldd	r24, Y+1	; 0x01
    12e2:	84 30       	cpi	r24, 0x04	; 4
    12e4:	50 f3       	brcs	.-44     	; 0x12ba <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    12e6:	82 e4       	ldi	r24, 0x42	; 66
    12e8:	92 e0       	ldi	r25, 0x02	; 2
    12ea:	0e 94 37 11 	call	0x226e	; 0x226e <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    12ee:	8b e4       	ldi	r24, 0x4B	; 75
    12f0:	92 e0       	ldi	r25, 0x02	; 2
    12f2:	0e 94 37 11 	call	0x226e	; 0x226e <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    12f6:	88 e5       	ldi	r24, 0x58	; 88
    12f8:	92 e0       	ldi	r25, 0x02	; 2
    12fa:	0e 94 37 11 	call	0x226e	; 0x226e <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
    12fe:	81 e6       	ldi	r24, 0x61	; 97
    1300:	92 e0       	ldi	r25, 0x02	; 2
    1302:	0e 94 37 11 	call	0x226e	; 0x226e <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1306:	82 e4       	ldi	r24, 0x42	; 66
    1308:	92 e0       	ldi	r25, 0x02	; 2
    130a:	90 93 55 02 	sts	0x0255, r25
    130e:	80 93 54 02 	sts	0x0254, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1312:	8b e4       	ldi	r24, 0x4B	; 75
    1314:	92 e0       	ldi	r25, 0x02	; 2
    1316:	90 93 57 02 	sts	0x0257, r25
    131a:	80 93 56 02 	sts	0x0256, r24
}
    131e:	0f 90       	pop	r0
    1320:	df 91       	pop	r29
    1322:	cf 91       	pop	r28
    1324:	08 95       	ret

00001326 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    1326:	cf 93       	push	r28
    1328:	df 93       	push	r29
    132a:	cd b7       	in	r28, 0x3d	; 61
    132c:	de b7       	in	r29, 0x3e	; 62
				prvDeleteTCB( pxTCB );
			}
		}
	}
	#endif
}
    132e:	df 91       	pop	r29
    1330:	cf 91       	pop	r28
    1332:	08 95       	ret

00001334 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    1334:	cf 93       	push	r28
    1336:	df 93       	push	r29
    1338:	1f 92       	push	r1
    133a:	1f 92       	push	r1
    133c:	cd b7       	in	r28, 0x3d	; 61
    133e:	de b7       	in	r29, 0x3e	; 62
    1340:	9a 83       	std	Y+2, r25	; 0x02
    1342:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1344:	80 91 1c 02 	lds	r24, 0x021C
    1348:	90 91 1d 02 	lds	r25, 0x021D
    134c:	29 81       	ldd	r18, Y+1	; 0x01
    134e:	3a 81       	ldd	r19, Y+2	; 0x02
    1350:	fc 01       	movw	r30, r24
    1352:	33 83       	std	Z+3, r19	; 0x03
    1354:	22 83       	std	Z+2, r18	; 0x02

	if( xTimeToWake < xTickCount )
    1356:	80 91 6b 02 	lds	r24, 0x026B
    135a:	90 91 6c 02 	lds	r25, 0x026C
    135e:	29 81       	ldd	r18, Y+1	; 0x01
    1360:	3a 81       	ldd	r19, Y+2	; 0x02
    1362:	28 17       	cp	r18, r24
    1364:	39 07       	cpc	r19, r25
    1366:	78 f4       	brcc	.+30     	; 0x1386 <prvAddCurrentTaskToDelayedList+0x52>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1368:	80 91 1c 02 	lds	r24, 0x021C
    136c:	90 91 1d 02 	lds	r25, 0x021D
    1370:	9c 01       	movw	r18, r24
    1372:	2e 5f       	subi	r18, 0xFE	; 254
    1374:	3f 4f       	sbci	r19, 0xFF	; 255
    1376:	80 91 56 02 	lds	r24, 0x0256
    137a:	90 91 57 02 	lds	r25, 0x0257
    137e:	b9 01       	movw	r22, r18
    1380:	0e 94 d6 11 	call	0x23ac	; 0x23ac <vListInsert>
    1384:	1d c0       	rjmp	.+58     	; 0x13c0 <prvAddCurrentTaskToDelayedList+0x8c>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1386:	80 91 1c 02 	lds	r24, 0x021C
    138a:	90 91 1d 02 	lds	r25, 0x021D
    138e:	9c 01       	movw	r18, r24
    1390:	2e 5f       	subi	r18, 0xFE	; 254
    1392:	3f 4f       	sbci	r19, 0xFF	; 255
    1394:	80 91 54 02 	lds	r24, 0x0254
    1398:	90 91 55 02 	lds	r25, 0x0255
    139c:	b9 01       	movw	r22, r18
    139e:	0e 94 d6 11 	call	0x23ac	; 0x23ac <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    13a2:	80 91 00 02 	lds	r24, 0x0200
    13a6:	90 91 01 02 	lds	r25, 0x0201
    13aa:	29 81       	ldd	r18, Y+1	; 0x01
    13ac:	3a 81       	ldd	r19, Y+2	; 0x02
    13ae:	28 17       	cp	r18, r24
    13b0:	39 07       	cpc	r19, r25
    13b2:	30 f4       	brcc	.+12     	; 0x13c0 <prvAddCurrentTaskToDelayedList+0x8c>
		{
			xNextTaskUnblockTime = xTimeToWake;
    13b4:	89 81       	ldd	r24, Y+1	; 0x01
    13b6:	9a 81       	ldd	r25, Y+2	; 0x02
    13b8:	90 93 01 02 	sts	0x0201, r25
    13bc:	80 93 00 02 	sts	0x0200, r24
		}
	}
}
    13c0:	0f 90       	pop	r0
    13c2:	0f 90       	pop	r0
    13c4:	df 91       	pop	r29
    13c6:	cf 91       	pop	r28
    13c8:	08 95       	ret

000013ca <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    13ca:	cf 93       	push	r28
    13cc:	df 93       	push	r29
    13ce:	00 d0       	rcall	.+0      	; 0x13d0 <prvAllocateTCBAndStack+0x6>
    13d0:	00 d0       	rcall	.+0      	; 0x13d2 <prvAllocateTCBAndStack+0x8>
    13d2:	cd b7       	in	r28, 0x3d	; 61
    13d4:	de b7       	in	r29, 0x3e	; 62
    13d6:	9c 83       	std	Y+4, r25	; 0x04
    13d8:	8b 83       	std	Y+3, r24	; 0x03
    13da:	7e 83       	std	Y+6, r23	; 0x06
    13dc:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    13de:	8a e2       	ldi	r24, 0x2A	; 42
    13e0:	90 e0       	ldi	r25, 0x00	; 0
    13e2:	0e 94 9e 15 	call	0x2b3c	; 0x2b3c <pvPortMalloc>
    13e6:	9a 83       	std	Y+2, r25	; 0x02
    13e8:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    13ea:	89 81       	ldd	r24, Y+1	; 0x01
    13ec:	9a 81       	ldd	r25, Y+2	; 0x02
    13ee:	00 97       	sbiw	r24, 0x00	; 0
    13f0:	51 f1       	breq	.+84     	; 0x1446 <prvAllocateTCBAndStack+0x7c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    13f2:	8d 81       	ldd	r24, Y+5	; 0x05
    13f4:	9e 81       	ldd	r25, Y+6	; 0x06
    13f6:	00 97       	sbiw	r24, 0x00	; 0
    13f8:	29 f4       	brne	.+10     	; 0x1404 <prvAllocateTCBAndStack+0x3a>
    13fa:	8b 81       	ldd	r24, Y+3	; 0x03
    13fc:	9c 81       	ldd	r25, Y+4	; 0x04
    13fe:	0e 94 9e 15 	call	0x2b3c	; 0x2b3c <pvPortMalloc>
    1402:	02 c0       	rjmp	.+4      	; 0x1408 <prvAllocateTCBAndStack+0x3e>
    1404:	8d 81       	ldd	r24, Y+5	; 0x05
    1406:	9e 81       	ldd	r25, Y+6	; 0x06
    1408:	29 81       	ldd	r18, Y+1	; 0x01
    140a:	3a 81       	ldd	r19, Y+2	; 0x02
    140c:	f9 01       	movw	r30, r18
    140e:	90 8f       	std	Z+24, r25	; 0x18
    1410:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    1412:	89 81       	ldd	r24, Y+1	; 0x01
    1414:	9a 81       	ldd	r25, Y+2	; 0x02
    1416:	fc 01       	movw	r30, r24
    1418:	87 89       	ldd	r24, Z+23	; 0x17
    141a:	90 8d       	ldd	r25, Z+24	; 0x18
    141c:	00 97       	sbiw	r24, 0x00	; 0
    141e:	39 f4       	brne	.+14     	; 0x142e <prvAllocateTCBAndStack+0x64>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    1420:	89 81       	ldd	r24, Y+1	; 0x01
    1422:	9a 81       	ldd	r25, Y+2	; 0x02
    1424:	0e 94 e4 15 	call	0x2bc8	; 0x2bc8 <vPortFree>
			pxNewTCB = NULL;
    1428:	1a 82       	std	Y+2, r1	; 0x02
    142a:	19 82       	std	Y+1, r1	; 0x01
    142c:	0c c0       	rjmp	.+24     	; 0x1446 <prvAllocateTCBAndStack+0x7c>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    142e:	89 81       	ldd	r24, Y+1	; 0x01
    1430:	9a 81       	ldd	r25, Y+2	; 0x02
    1432:	fc 01       	movw	r30, r24
    1434:	87 89       	ldd	r24, Z+23	; 0x17
    1436:	90 8d       	ldd	r25, Z+24	; 0x18
    1438:	2b 81       	ldd	r18, Y+3	; 0x03
    143a:	3c 81       	ldd	r19, Y+4	; 0x04
    143c:	a9 01       	movw	r20, r18
    143e:	65 ea       	ldi	r22, 0xA5	; 165
    1440:	70 e0       	ldi	r23, 0x00	; 0
    1442:	0e 94 ae 1d 	call	0x3b5c	; 0x3b5c <memset>
		}
	}

	return pxNewTCB;
    1446:	89 81       	ldd	r24, Y+1	; 0x01
    1448:	9a 81       	ldd	r25, Y+2	; 0x02
}
    144a:	26 96       	adiw	r28, 0x06	; 6
    144c:	0f b6       	in	r0, 0x3f	; 63
    144e:	f8 94       	cli
    1450:	de bf       	out	0x3e, r29	; 62
    1452:	0f be       	out	0x3f, r0	; 63
    1454:	cd bf       	out	0x3d, r28	; 61
    1456:	df 91       	pop	r29
    1458:	cf 91       	pop	r28
    145a:	08 95       	ret

0000145c <usTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
    145c:	0f 93       	push	r16
    145e:	1f 93       	push	r17
    1460:	cf 93       	push	r28
    1462:	df 93       	push	r29
    1464:	1f 92       	push	r1
    1466:	1f 92       	push	r1
    1468:	cd b7       	in	r28, 0x3d	; 61
    146a:	de b7       	in	r29, 0x3e	; 62
    146c:	9a 83       	std	Y+2, r25	; 0x02
    146e:	89 83       	std	Y+1, r24	; 0x01
	register unsigned short usCount = 0U;
    1470:	00 e0       	ldi	r16, 0x00	; 0
    1472:	10 e0       	ldi	r17, 0x00	; 0

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    1474:	09 c0       	rjmp	.+18     	; 0x1488 <usTaskCheckFreeStackSpace+0x2c>
		{
			pucStackByte -= portSTACK_GROWTH;
    1476:	89 81       	ldd	r24, Y+1	; 0x01
    1478:	9a 81       	ldd	r25, Y+2	; 0x02
    147a:	01 96       	adiw	r24, 0x01	; 1
    147c:	9a 83       	std	Y+2, r25	; 0x02
    147e:	89 83       	std	Y+1, r24	; 0x01
			usCount++;
    1480:	c8 01       	movw	r24, r16
    1482:	8c 01       	movw	r16, r24
    1484:	0f 5f       	subi	r16, 0xFF	; 255
    1486:	1f 4f       	sbci	r17, 0xFF	; 255

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    1488:	89 81       	ldd	r24, Y+1	; 0x01
    148a:	9a 81       	ldd	r25, Y+2	; 0x02
    148c:	fc 01       	movw	r30, r24
    148e:	80 81       	ld	r24, Z
    1490:	85 3a       	cpi	r24, 0xA5	; 165
    1492:	89 f3       	breq	.-30     	; 0x1476 <usTaskCheckFreeStackSpace+0x1a>
			usCount++;
		}

		usCount /= sizeof( portSTACK_TYPE );

		return usCount;
    1494:	c8 01       	movw	r24, r16
	}
    1496:	0f 90       	pop	r0
    1498:	0f 90       	pop	r0
    149a:	df 91       	pop	r29
    149c:	cf 91       	pop	r28
    149e:	1f 91       	pop	r17
    14a0:	0f 91       	pop	r16
    14a2:	08 95       	ret

000014a4 <uxTaskGetStackHighWaterMark>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
	{
    14a4:	cf 93       	push	r28
    14a6:	df 93       	push	r29
    14a8:	cd b7       	in	r28, 0x3d	; 61
    14aa:	de b7       	in	r29, 0x3e	; 62
    14ac:	27 97       	sbiw	r28, 0x07	; 7
    14ae:	0f b6       	in	r0, 0x3f	; 63
    14b0:	f8 94       	cli
    14b2:	de bf       	out	0x3e, r29	; 62
    14b4:	0f be       	out	0x3f, r0	; 63
    14b6:	cd bf       	out	0x3d, r28	; 61
    14b8:	9f 83       	std	Y+7, r25	; 0x07
    14ba:	8e 83       	std	Y+6, r24	; 0x06
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    14bc:	8e 81       	ldd	r24, Y+6	; 0x06
    14be:	9f 81       	ldd	r25, Y+7	; 0x07
    14c0:	00 97       	sbiw	r24, 0x00	; 0
    14c2:	29 f4       	brne	.+10     	; 0x14ce <uxTaskGetStackHighWaterMark+0x2a>
    14c4:	80 91 1c 02 	lds	r24, 0x021C
    14c8:	90 91 1d 02 	lds	r25, 0x021D
    14cc:	02 c0       	rjmp	.+4      	; 0x14d2 <uxTaskGetStackHighWaterMark+0x2e>
    14ce:	8e 81       	ldd	r24, Y+6	; 0x06
    14d0:	9f 81       	ldd	r25, Y+7	; 0x07
    14d2:	9a 83       	std	Y+2, r25	; 0x02
    14d4:	89 83       	std	Y+1, r24	; 0x01

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    14d6:	89 81       	ldd	r24, Y+1	; 0x01
    14d8:	9a 81       	ldd	r25, Y+2	; 0x02
    14da:	fc 01       	movw	r30, r24
    14dc:	87 89       	ldd	r24, Z+23	; 0x17
    14de:	90 8d       	ldd	r25, Z+24	; 0x18
    14e0:	9c 83       	std	Y+4, r25	; 0x04
    14e2:	8b 83       	std	Y+3, r24	; 0x03
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
		}
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
    14e4:	8b 81       	ldd	r24, Y+3	; 0x03
    14e6:	9c 81       	ldd	r25, Y+4	; 0x04
    14e8:	0e 94 2e 0a 	call	0x145c	; 0x145c <usTaskCheckFreeStackSpace>
    14ec:	8d 83       	std	Y+5, r24	; 0x05

		return uxReturn;
    14ee:	8d 81       	ldd	r24, Y+5	; 0x05
	}
    14f0:	27 96       	adiw	r28, 0x07	; 7
    14f2:	0f b6       	in	r0, 0x3f	; 63
    14f4:	f8 94       	cli
    14f6:	de bf       	out	0x3e, r29	; 62
    14f8:	0f be       	out	0x3f, r0	; 63
    14fa:	cd bf       	out	0x3d, r28	; 61
    14fc:	df 91       	pop	r29
    14fe:	cf 91       	pop	r28
    1500:	08 95       	ret

00001502 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	xTaskHandle xTaskGetCurrentTaskHandle( void )
	{
    1502:	cf 93       	push	r28
    1504:	df 93       	push	r29
    1506:	1f 92       	push	r1
    1508:	1f 92       	push	r1
    150a:	cd b7       	in	r28, 0x3d	; 61
    150c:	de b7       	in	r29, 0x3e	; 62
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    150e:	80 91 1c 02 	lds	r24, 0x021C
    1512:	90 91 1d 02 	lds	r25, 0x021D
    1516:	9a 83       	std	Y+2, r25	; 0x02
    1518:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    151a:	89 81       	ldd	r24, Y+1	; 0x01
    151c:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    151e:	0f 90       	pop	r0
    1520:	0f 90       	pop	r0
    1522:	df 91       	pop	r29
    1524:	cf 91       	pop	r28
    1526:	08 95       	ret

00001528 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    1528:	cf 93       	push	r28
    152a:	df 93       	push	r29
    152c:	00 d0       	rcall	.+0      	; 0x152e <vTaskPriorityInherit+0x6>
    152e:	1f 92       	push	r1
    1530:	cd b7       	in	r28, 0x3d	; 61
    1532:	de b7       	in	r29, 0x3e	; 62
    1534:	9c 83       	std	Y+4, r25	; 0x04
    1536:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
    1538:	8b 81       	ldd	r24, Y+3	; 0x03
    153a:	9c 81       	ldd	r25, Y+4	; 0x04
    153c:	9a 83       	std	Y+2, r25	; 0x02
    153e:	89 83       	std	Y+1, r24	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    1540:	8b 81       	ldd	r24, Y+3	; 0x03
    1542:	9c 81       	ldd	r25, Y+4	; 0x04
    1544:	00 97       	sbiw	r24, 0x00	; 0
    1546:	09 f4       	brne	.+2      	; 0x154a <vTaskPriorityInherit+0x22>
    1548:	78 c0       	rjmp	.+240    	; 0x163a <vTaskPriorityInherit+0x112>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    154a:	89 81       	ldd	r24, Y+1	; 0x01
    154c:	9a 81       	ldd	r25, Y+2	; 0x02
    154e:	fc 01       	movw	r30, r24
    1550:	26 89       	ldd	r18, Z+22	; 0x16
    1552:	80 91 1c 02 	lds	r24, 0x021C
    1556:	90 91 1d 02 	lds	r25, 0x021D
    155a:	fc 01       	movw	r30, r24
    155c:	86 89       	ldd	r24, Z+22	; 0x16
    155e:	28 17       	cp	r18, r24
    1560:	08 f0       	brcs	.+2      	; 0x1564 <vTaskPriorityInherit+0x3c>
    1562:	6b c0       	rjmp	.+214    	; 0x163a <vTaskPriorityInherit+0x112>
			{
				/* Adjust the mutex holder state to account for its new priority. */
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    1564:	80 91 1c 02 	lds	r24, 0x021C
    1568:	90 91 1d 02 	lds	r25, 0x021D
    156c:	fc 01       	movw	r30, r24
    156e:	86 89       	ldd	r24, Z+22	; 0x16
    1570:	88 2f       	mov	r24, r24
    1572:	90 e0       	ldi	r25, 0x00	; 0
    1574:	24 e0       	ldi	r18, 0x04	; 4
    1576:	30 e0       	ldi	r19, 0x00	; 0
    1578:	28 1b       	sub	r18, r24
    157a:	39 0b       	sbc	r19, r25
    157c:	89 81       	ldd	r24, Y+1	; 0x01
    157e:	9a 81       	ldd	r25, Y+2	; 0x02
    1580:	fc 01       	movw	r30, r24
    1582:	35 87       	std	Z+13, r19	; 0x0d
    1584:	24 87       	std	Z+12, r18	; 0x0c

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    1586:	89 81       	ldd	r24, Y+1	; 0x01
    1588:	9a 81       	ldd	r25, Y+2	; 0x02
    158a:	fc 01       	movw	r30, r24
    158c:	42 85       	ldd	r20, Z+10	; 0x0a
    158e:	53 85       	ldd	r21, Z+11	; 0x0b
    1590:	89 81       	ldd	r24, Y+1	; 0x01
    1592:	9a 81       	ldd	r25, Y+2	; 0x02
    1594:	fc 01       	movw	r30, r24
    1596:	86 89       	ldd	r24, Z+22	; 0x16
    1598:	28 2f       	mov	r18, r24
    159a:	30 e0       	ldi	r19, 0x00	; 0
    159c:	c9 01       	movw	r24, r18
    159e:	88 0f       	add	r24, r24
    15a0:	99 1f       	adc	r25, r25
    15a2:	88 0f       	add	r24, r24
    15a4:	99 1f       	adc	r25, r25
    15a6:	88 0f       	add	r24, r24
    15a8:	99 1f       	adc	r25, r25
    15aa:	82 0f       	add	r24, r18
    15ac:	93 1f       	adc	r25, r19
    15ae:	82 5e       	subi	r24, 0xE2	; 226
    15b0:	9d 4f       	sbci	r25, 0xFD	; 253
    15b2:	48 17       	cp	r20, r24
    15b4:	59 07       	cpc	r21, r25
    15b6:	b9 f5       	brne	.+110    	; 0x1626 <vTaskPriorityInherit+0xfe>
				{
					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    15b8:	89 81       	ldd	r24, Y+1	; 0x01
    15ba:	9a 81       	ldd	r25, Y+2	; 0x02
    15bc:	02 96       	adiw	r24, 0x02	; 2
    15be:	0e 94 4f 12 	call	0x249e	; 0x249e <uxListRemove>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    15c2:	80 91 1c 02 	lds	r24, 0x021C
    15c6:	90 91 1d 02 	lds	r25, 0x021D
    15ca:	fc 01       	movw	r30, r24
    15cc:	26 89       	ldd	r18, Z+22	; 0x16
    15ce:	89 81       	ldd	r24, Y+1	; 0x01
    15d0:	9a 81       	ldd	r25, Y+2	; 0x02
    15d2:	fc 01       	movw	r30, r24
    15d4:	26 8b       	std	Z+22, r18	; 0x16
					prvAddTaskToReadyQueue( pxTCB );
    15d6:	89 81       	ldd	r24, Y+1	; 0x01
    15d8:	9a 81       	ldd	r25, Y+2	; 0x02
    15da:	fc 01       	movw	r30, r24
    15dc:	96 89       	ldd	r25, Z+22	; 0x16
    15de:	80 91 6e 02 	lds	r24, 0x026E
    15e2:	89 17       	cp	r24, r25
    15e4:	30 f4       	brcc	.+12     	; 0x15f2 <vTaskPriorityInherit+0xca>
    15e6:	89 81       	ldd	r24, Y+1	; 0x01
    15e8:	9a 81       	ldd	r25, Y+2	; 0x02
    15ea:	fc 01       	movw	r30, r24
    15ec:	86 89       	ldd	r24, Z+22	; 0x16
    15ee:	80 93 6e 02 	sts	0x026E, r24
    15f2:	89 81       	ldd	r24, Y+1	; 0x01
    15f4:	9a 81       	ldd	r25, Y+2	; 0x02
    15f6:	ac 01       	movw	r20, r24
    15f8:	4e 5f       	subi	r20, 0xFE	; 254
    15fa:	5f 4f       	sbci	r21, 0xFF	; 255
    15fc:	89 81       	ldd	r24, Y+1	; 0x01
    15fe:	9a 81       	ldd	r25, Y+2	; 0x02
    1600:	fc 01       	movw	r30, r24
    1602:	86 89       	ldd	r24, Z+22	; 0x16
    1604:	28 2f       	mov	r18, r24
    1606:	30 e0       	ldi	r19, 0x00	; 0
    1608:	c9 01       	movw	r24, r18
    160a:	88 0f       	add	r24, r24
    160c:	99 1f       	adc	r25, r25
    160e:	88 0f       	add	r24, r24
    1610:	99 1f       	adc	r25, r25
    1612:	88 0f       	add	r24, r24
    1614:	99 1f       	adc	r25, r25
    1616:	82 0f       	add	r24, r18
    1618:	93 1f       	adc	r25, r19
    161a:	82 5e       	subi	r24, 0xE2	; 226
    161c:	9d 4f       	sbci	r25, 0xFD	; 253
    161e:	ba 01       	movw	r22, r20
    1620:	0e 94 7f 11 	call	0x22fe	; 0x22fe <vListInsertEnd>
    1624:	0a c0       	rjmp	.+20     	; 0x163a <vTaskPriorityInherit+0x112>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    1626:	80 91 1c 02 	lds	r24, 0x021C
    162a:	90 91 1d 02 	lds	r25, 0x021D
    162e:	fc 01       	movw	r30, r24
    1630:	26 89       	ldd	r18, Z+22	; 0x16
    1632:	89 81       	ldd	r24, Y+1	; 0x01
    1634:	9a 81       	ldd	r25, Y+2	; 0x02
    1636:	fc 01       	movw	r30, r24
    1638:	26 8b       	std	Z+22, r18	; 0x16
				}

				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
			}
		}
	}
    163a:	0f 90       	pop	r0
    163c:	0f 90       	pop	r0
    163e:	0f 90       	pop	r0
    1640:	0f 90       	pop	r0
    1642:	df 91       	pop	r29
    1644:	cf 91       	pop	r28
    1646:	08 95       	ret

00001648 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    1648:	cf 93       	push	r28
    164a:	df 93       	push	r29
    164c:	00 d0       	rcall	.+0      	; 0x164e <vTaskPriorityDisinherit+0x6>
    164e:	1f 92       	push	r1
    1650:	cd b7       	in	r28, 0x3d	; 61
    1652:	de b7       	in	r29, 0x3e	; 62
    1654:	9c 83       	std	Y+4, r25	; 0x04
    1656:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
    1658:	8b 81       	ldd	r24, Y+3	; 0x03
    165a:	9c 81       	ldd	r25, Y+4	; 0x04
    165c:	9a 83       	std	Y+2, r25	; 0x02
    165e:	89 83       	std	Y+1, r24	; 0x01

		if( pxMutexHolder != NULL )
    1660:	8b 81       	ldd	r24, Y+3	; 0x03
    1662:	9c 81       	ldd	r25, Y+4	; 0x04
    1664:	00 97       	sbiw	r24, 0x00	; 0
    1666:	09 f4       	brne	.+2      	; 0x166a <vTaskPriorityDisinherit+0x22>
    1668:	4e c0       	rjmp	.+156    	; 0x1706 <vTaskPriorityDisinherit+0xbe>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    166a:	89 81       	ldd	r24, Y+1	; 0x01
    166c:	9a 81       	ldd	r25, Y+2	; 0x02
    166e:	fc 01       	movw	r30, r24
    1670:	26 89       	ldd	r18, Z+22	; 0x16
    1672:	89 81       	ldd	r24, Y+1	; 0x01
    1674:	9a 81       	ldd	r25, Y+2	; 0x02
    1676:	fc 01       	movw	r30, r24
    1678:	81 a5       	ldd	r24, Z+41	; 0x29
    167a:	28 17       	cp	r18, r24
    167c:	09 f4       	brne	.+2      	; 0x1680 <vTaskPriorityDisinherit+0x38>
    167e:	43 c0       	rjmp	.+134    	; 0x1706 <vTaskPriorityDisinherit+0xbe>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    1680:	89 81       	ldd	r24, Y+1	; 0x01
    1682:	9a 81       	ldd	r25, Y+2	; 0x02
    1684:	02 96       	adiw	r24, 0x02	; 2
    1686:	0e 94 4f 12 	call	0x249e	; 0x249e <uxListRemove>
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    168a:	89 81       	ldd	r24, Y+1	; 0x01
    168c:	9a 81       	ldd	r25, Y+2	; 0x02
    168e:	fc 01       	movw	r30, r24
    1690:	21 a5       	ldd	r18, Z+41	; 0x29
    1692:	89 81       	ldd	r24, Y+1	; 0x01
    1694:	9a 81       	ldd	r25, Y+2	; 0x02
    1696:	fc 01       	movw	r30, r24
    1698:	26 8b       	std	Z+22, r18	; 0x16
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    169a:	89 81       	ldd	r24, Y+1	; 0x01
    169c:	9a 81       	ldd	r25, Y+2	; 0x02
    169e:	fc 01       	movw	r30, r24
    16a0:	86 89       	ldd	r24, Z+22	; 0x16
    16a2:	88 2f       	mov	r24, r24
    16a4:	90 e0       	ldi	r25, 0x00	; 0
    16a6:	24 e0       	ldi	r18, 0x04	; 4
    16a8:	30 e0       	ldi	r19, 0x00	; 0
    16aa:	28 1b       	sub	r18, r24
    16ac:	39 0b       	sbc	r19, r25
    16ae:	89 81       	ldd	r24, Y+1	; 0x01
    16b0:	9a 81       	ldd	r25, Y+2	; 0x02
    16b2:	fc 01       	movw	r30, r24
    16b4:	35 87       	std	Z+13, r19	; 0x0d
    16b6:	24 87       	std	Z+12, r18	; 0x0c
				prvAddTaskToReadyQueue( pxTCB );
    16b8:	89 81       	ldd	r24, Y+1	; 0x01
    16ba:	9a 81       	ldd	r25, Y+2	; 0x02
    16bc:	fc 01       	movw	r30, r24
    16be:	96 89       	ldd	r25, Z+22	; 0x16
    16c0:	80 91 6e 02 	lds	r24, 0x026E
    16c4:	89 17       	cp	r24, r25
    16c6:	30 f4       	brcc	.+12     	; 0x16d4 <vTaskPriorityDisinherit+0x8c>
    16c8:	89 81       	ldd	r24, Y+1	; 0x01
    16ca:	9a 81       	ldd	r25, Y+2	; 0x02
    16cc:	fc 01       	movw	r30, r24
    16ce:	86 89       	ldd	r24, Z+22	; 0x16
    16d0:	80 93 6e 02 	sts	0x026E, r24
    16d4:	89 81       	ldd	r24, Y+1	; 0x01
    16d6:	9a 81       	ldd	r25, Y+2	; 0x02
    16d8:	ac 01       	movw	r20, r24
    16da:	4e 5f       	subi	r20, 0xFE	; 254
    16dc:	5f 4f       	sbci	r21, 0xFF	; 255
    16de:	89 81       	ldd	r24, Y+1	; 0x01
    16e0:	9a 81       	ldd	r25, Y+2	; 0x02
    16e2:	fc 01       	movw	r30, r24
    16e4:	86 89       	ldd	r24, Z+22	; 0x16
    16e6:	28 2f       	mov	r18, r24
    16e8:	30 e0       	ldi	r19, 0x00	; 0
    16ea:	c9 01       	movw	r24, r18
    16ec:	88 0f       	add	r24, r24
    16ee:	99 1f       	adc	r25, r25
    16f0:	88 0f       	add	r24, r24
    16f2:	99 1f       	adc	r25, r25
    16f4:	88 0f       	add	r24, r24
    16f6:	99 1f       	adc	r25, r25
    16f8:	82 0f       	add	r24, r18
    16fa:	93 1f       	adc	r25, r19
    16fc:	82 5e       	subi	r24, 0xE2	; 226
    16fe:	9d 4f       	sbci	r25, 0xFD	; 253
    1700:	ba 01       	movw	r22, r20
    1702:	0e 94 7f 11 	call	0x22fe	; 0x22fe <vListInsertEnd>
			}
		}
	}
    1706:	0f 90       	pop	r0
    1708:	0f 90       	pop	r0
    170a:	0f 90       	pop	r0
    170c:	0f 90       	pop	r0
    170e:	df 91       	pop	r29
    1710:	cf 91       	pop	r28
    1712:	08 95       	ret

00001714 <xQueueGenericReset>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle pxQueue, portBASE_TYPE xNewQueue )
{
    1714:	cf 93       	push	r28
    1716:	df 93       	push	r29
    1718:	00 d0       	rcall	.+0      	; 0x171a <xQueueGenericReset+0x6>
    171a:	cd b7       	in	r28, 0x3d	; 61
    171c:	de b7       	in	r29, 0x3e	; 62
    171e:	9a 83       	std	Y+2, r25	; 0x02
    1720:	89 83       	std	Y+1, r24	; 0x01
    1722:	6b 83       	std	Y+3, r22	; 0x03
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1724:	0f b6       	in	r0, 0x3f	; 63
    1726:	f8 94       	cli
    1728:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    172a:	89 81       	ldd	r24, Y+1	; 0x01
    172c:	9a 81       	ldd	r25, Y+2	; 0x02
    172e:	fc 01       	movw	r30, r24
    1730:	20 81       	ld	r18, Z
    1732:	31 81       	ldd	r19, Z+1	; 0x01
    1734:	89 81       	ldd	r24, Y+1	; 0x01
    1736:	9a 81       	ldd	r25, Y+2	; 0x02
    1738:	fc 01       	movw	r30, r24
    173a:	83 8d       	ldd	r24, Z+27	; 0x1b
    173c:	68 2f       	mov	r22, r24
    173e:	70 e0       	ldi	r23, 0x00	; 0
    1740:	89 81       	ldd	r24, Y+1	; 0x01
    1742:	9a 81       	ldd	r25, Y+2	; 0x02
    1744:	fc 01       	movw	r30, r24
    1746:	84 8d       	ldd	r24, Z+28	; 0x1c
    1748:	48 2f       	mov	r20, r24
    174a:	50 e0       	ldi	r21, 0x00	; 0
    174c:	64 9f       	mul	r22, r20
    174e:	c0 01       	movw	r24, r0
    1750:	65 9f       	mul	r22, r21
    1752:	90 0d       	add	r25, r0
    1754:	74 9f       	mul	r23, r20
    1756:	90 0d       	add	r25, r0
    1758:	11 24       	eor	r1, r1
    175a:	28 0f       	add	r18, r24
    175c:	39 1f       	adc	r19, r25
    175e:	89 81       	ldd	r24, Y+1	; 0x01
    1760:	9a 81       	ldd	r25, Y+2	; 0x02
    1762:	fc 01       	movw	r30, r24
    1764:	33 83       	std	Z+3, r19	; 0x03
    1766:	22 83       	std	Z+2, r18	; 0x02
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1768:	89 81       	ldd	r24, Y+1	; 0x01
    176a:	9a 81       	ldd	r25, Y+2	; 0x02
    176c:	fc 01       	movw	r30, r24
    176e:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1770:	89 81       	ldd	r24, Y+1	; 0x01
    1772:	9a 81       	ldd	r25, Y+2	; 0x02
    1774:	fc 01       	movw	r30, r24
    1776:	20 81       	ld	r18, Z
    1778:	31 81       	ldd	r19, Z+1	; 0x01
    177a:	89 81       	ldd	r24, Y+1	; 0x01
    177c:	9a 81       	ldd	r25, Y+2	; 0x02
    177e:	fc 01       	movw	r30, r24
    1780:	35 83       	std	Z+5, r19	; 0x05
    1782:	24 83       	std	Z+4, r18	; 0x04
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
    1784:	89 81       	ldd	r24, Y+1	; 0x01
    1786:	9a 81       	ldd	r25, Y+2	; 0x02
    1788:	fc 01       	movw	r30, r24
    178a:	20 81       	ld	r18, Z
    178c:	31 81       	ldd	r19, Z+1	; 0x01
    178e:	89 81       	ldd	r24, Y+1	; 0x01
    1790:	9a 81       	ldd	r25, Y+2	; 0x02
    1792:	fc 01       	movw	r30, r24
    1794:	83 8d       	ldd	r24, Z+27	; 0x1b
    1796:	88 2f       	mov	r24, r24
    1798:	90 e0       	ldi	r25, 0x00	; 0
    179a:	bc 01       	movw	r22, r24
    179c:	61 50       	subi	r22, 0x01	; 1
    179e:	71 09       	sbc	r23, r1
    17a0:	89 81       	ldd	r24, Y+1	; 0x01
    17a2:	9a 81       	ldd	r25, Y+2	; 0x02
    17a4:	fc 01       	movw	r30, r24
    17a6:	84 8d       	ldd	r24, Z+28	; 0x1c
    17a8:	48 2f       	mov	r20, r24
    17aa:	50 e0       	ldi	r21, 0x00	; 0
    17ac:	64 9f       	mul	r22, r20
    17ae:	c0 01       	movw	r24, r0
    17b0:	65 9f       	mul	r22, r21
    17b2:	90 0d       	add	r25, r0
    17b4:	74 9f       	mul	r23, r20
    17b6:	90 0d       	add	r25, r0
    17b8:	11 24       	eor	r1, r1
    17ba:	28 0f       	add	r18, r24
    17bc:	39 1f       	adc	r19, r25
    17be:	89 81       	ldd	r24, Y+1	; 0x01
    17c0:	9a 81       	ldd	r25, Y+2	; 0x02
    17c2:	fc 01       	movw	r30, r24
    17c4:	37 83       	std	Z+7, r19	; 0x07
    17c6:	26 83       	std	Z+6, r18	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    17c8:	89 81       	ldd	r24, Y+1	; 0x01
    17ca:	9a 81       	ldd	r25, Y+2	; 0x02
    17cc:	2f ef       	ldi	r18, 0xFF	; 255
    17ce:	fc 01       	movw	r30, r24
    17d0:	25 8f       	std	Z+29, r18	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    17d2:	89 81       	ldd	r24, Y+1	; 0x01
    17d4:	9a 81       	ldd	r25, Y+2	; 0x02
    17d6:	2f ef       	ldi	r18, 0xFF	; 255
    17d8:	fc 01       	movw	r30, r24
    17da:	26 8f       	std	Z+30, r18	; 0x1e

		if( xNewQueue == pdFALSE )
    17dc:	8b 81       	ldd	r24, Y+3	; 0x03
    17de:	88 23       	and	r24, r24
    17e0:	81 f4       	brne	.+32     	; 0x1802 <xQueueGenericReset+0xee>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to	write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    17e2:	89 81       	ldd	r24, Y+1	; 0x01
    17e4:	9a 81       	ldd	r25, Y+2	; 0x02
    17e6:	fc 01       	movw	r30, r24
    17e8:	80 85       	ldd	r24, Z+8	; 0x08
    17ea:	88 23       	and	r24, r24
    17ec:	a1 f0       	breq	.+40     	; 0x1816 <xQueueGenericReset+0x102>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    17ee:	89 81       	ldd	r24, Y+1	; 0x01
    17f0:	9a 81       	ldd	r25, Y+2	; 0x02
    17f2:	08 96       	adiw	r24, 0x08	; 8
    17f4:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <xTaskRemoveFromEventList>
    17f8:	81 30       	cpi	r24, 0x01	; 1
    17fa:	69 f4       	brne	.+26     	; 0x1816 <xQueueGenericReset+0x102>
				{
					portYIELD_WITHIN_API();
    17fc:	0e 94 11 18 	call	0x3022	; 0x3022 <vPortYield>
    1800:	0a c0       	rjmp	.+20     	; 0x1816 <xQueueGenericReset+0x102>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1802:	89 81       	ldd	r24, Y+1	; 0x01
    1804:	9a 81       	ldd	r25, Y+2	; 0x02
    1806:	08 96       	adiw	r24, 0x08	; 8
    1808:	0e 94 37 11 	call	0x226e	; 0x226e <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    180c:	89 81       	ldd	r24, Y+1	; 0x01
    180e:	9a 81       	ldd	r25, Y+2	; 0x02
    1810:	41 96       	adiw	r24, 0x11	; 17
    1812:	0e 94 37 11 	call	0x226e	; 0x226e <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1816:	0f 90       	pop	r0
    1818:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    181a:	81 e0       	ldi	r24, 0x01	; 1
}
    181c:	0f 90       	pop	r0
    181e:	0f 90       	pop	r0
    1820:	0f 90       	pop	r0
    1822:	df 91       	pop	r29
    1824:	cf 91       	pop	r28
    1826:	08 95       	ret

00001828 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
    1828:	cf 93       	push	r28
    182a:	df 93       	push	r29
    182c:	cd b7       	in	r28, 0x3d	; 61
    182e:	de b7       	in	r29, 0x3e	; 62
    1830:	29 97       	sbiw	r28, 0x09	; 9
    1832:	0f b6       	in	r0, 0x3f	; 63
    1834:	f8 94       	cli
    1836:	de bf       	out	0x3e, r29	; 62
    1838:	0f be       	out	0x3f, r0	; 63
    183a:	cd bf       	out	0x3d, r28	; 61
    183c:	8f 83       	std	Y+7, r24	; 0x07
    183e:	68 87       	std	Y+8, r22	; 0x08
    1840:	49 87       	std	Y+9, r20	; 0x09
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    1842:	1a 82       	std	Y+2, r1	; 0x02
    1844:	19 82       	std	Y+1, r1	; 0x01
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    1846:	8f 81       	ldd	r24, Y+7	; 0x07
    1848:	88 23       	and	r24, r24
    184a:	09 f4       	brne	.+2      	; 0x184e <xQueueGenericCreate+0x26>
    184c:	43 c0       	rjmp	.+134    	; 0x18d4 <xQueueGenericCreate+0xac>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    184e:	8f e1       	ldi	r24, 0x1F	; 31
    1850:	90 e0       	ldi	r25, 0x00	; 0
    1852:	0e 94 9e 15 	call	0x2b3c	; 0x2b3c <pvPortMalloc>
    1856:	9c 83       	std	Y+4, r25	; 0x04
    1858:	8b 83       	std	Y+3, r24	; 0x03
		if( pxNewQueue != NULL )
    185a:	8b 81       	ldd	r24, Y+3	; 0x03
    185c:	9c 81       	ldd	r25, Y+4	; 0x04
    185e:	00 97       	sbiw	r24, 0x00	; 0
    1860:	c9 f1       	breq	.+114    	; 0x18d4 <xQueueGenericCreate+0xac>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    1862:	8f 81       	ldd	r24, Y+7	; 0x07
    1864:	48 2f       	mov	r20, r24
    1866:	50 e0       	ldi	r21, 0x00	; 0
    1868:	88 85       	ldd	r24, Y+8	; 0x08
    186a:	28 2f       	mov	r18, r24
    186c:	30 e0       	ldi	r19, 0x00	; 0
    186e:	42 9f       	mul	r20, r18
    1870:	c0 01       	movw	r24, r0
    1872:	43 9f       	mul	r20, r19
    1874:	90 0d       	add	r25, r0
    1876:	52 9f       	mul	r21, r18
    1878:	90 0d       	add	r25, r0
    187a:	11 24       	eor	r1, r1
    187c:	01 96       	adiw	r24, 0x01	; 1
    187e:	9e 83       	std	Y+6, r25	; 0x06
    1880:	8d 83       	std	Y+5, r24	; 0x05

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    1882:	8d 81       	ldd	r24, Y+5	; 0x05
    1884:	9e 81       	ldd	r25, Y+6	; 0x06
    1886:	0e 94 9e 15 	call	0x2b3c	; 0x2b3c <pvPortMalloc>
    188a:	9c 01       	movw	r18, r24
    188c:	8b 81       	ldd	r24, Y+3	; 0x03
    188e:	9c 81       	ldd	r25, Y+4	; 0x04
    1890:	fc 01       	movw	r30, r24
    1892:	31 83       	std	Z+1, r19	; 0x01
    1894:	20 83       	st	Z, r18
			if( pxNewQueue->pcHead != NULL )
    1896:	8b 81       	ldd	r24, Y+3	; 0x03
    1898:	9c 81       	ldd	r25, Y+4	; 0x04
    189a:	fc 01       	movw	r30, r24
    189c:	80 81       	ld	r24, Z
    189e:	91 81       	ldd	r25, Z+1	; 0x01
    18a0:	00 97       	sbiw	r24, 0x00	; 0
    18a2:	a1 f0       	breq	.+40     	; 0x18cc <xQueueGenericCreate+0xa4>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    18a4:	8b 81       	ldd	r24, Y+3	; 0x03
    18a6:	9c 81       	ldd	r25, Y+4	; 0x04
    18a8:	2f 81       	ldd	r18, Y+7	; 0x07
    18aa:	fc 01       	movw	r30, r24
    18ac:	23 8f       	std	Z+27, r18	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    18ae:	8b 81       	ldd	r24, Y+3	; 0x03
    18b0:	9c 81       	ldd	r25, Y+4	; 0x04
    18b2:	28 85       	ldd	r18, Y+8	; 0x08
    18b4:	fc 01       	movw	r30, r24
    18b6:	24 8f       	std	Z+28, r18	; 0x1c
				xQueueGenericReset( pxNewQueue, pdTRUE );
    18b8:	8b 81       	ldd	r24, Y+3	; 0x03
    18ba:	9c 81       	ldd	r25, Y+4	; 0x04
    18bc:	61 e0       	ldi	r22, 0x01	; 1
    18be:	0e 94 8a 0b 	call	0x1714	; 0x1714 <xQueueGenericReset>
					pxNewQueue->ucQueueType = ucQueueType;
				}
				#endif /* configUSE_TRACE_FACILITY */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    18c2:	8b 81       	ldd	r24, Y+3	; 0x03
    18c4:	9c 81       	ldd	r25, Y+4	; 0x04
    18c6:	9a 83       	std	Y+2, r25	; 0x02
    18c8:	89 83       	std	Y+1, r24	; 0x01
    18ca:	04 c0       	rjmp	.+8      	; 0x18d4 <xQueueGenericCreate+0xac>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    18cc:	8b 81       	ldd	r24, Y+3	; 0x03
    18ce:	9c 81       	ldd	r25, Y+4	; 0x04
    18d0:	0e 94 e4 15 	call	0x2bc8	; 0x2bc8 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    18d4:	89 81       	ldd	r24, Y+1	; 0x01
    18d6:	9a 81       	ldd	r25, Y+2	; 0x02
}
    18d8:	29 96       	adiw	r28, 0x09	; 9
    18da:	0f b6       	in	r0, 0x3f	; 63
    18dc:	f8 94       	cli
    18de:	de bf       	out	0x3e, r29	; 62
    18e0:	0f be       	out	0x3f, r0	; 63
    18e2:	cd bf       	out	0x3d, r28	; 61
    18e4:	df 91       	pop	r29
    18e6:	cf 91       	pop	r28
    18e8:	08 95       	ret

000018ea <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
	{
    18ea:	cf 93       	push	r28
    18ec:	df 93       	push	r29
    18ee:	00 d0       	rcall	.+0      	; 0x18f0 <xQueueCreateMutex+0x6>
    18f0:	cd b7       	in	r28, 0x3d	; 61
    18f2:	de b7       	in	r29, 0x3e	; 62
    18f4:	8b 83       	std	Y+3, r24	; 0x03
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    18f6:	8f e1       	ldi	r24, 0x1F	; 31
    18f8:	90 e0       	ldi	r25, 0x00	; 0
    18fa:	0e 94 9e 15 	call	0x2b3c	; 0x2b3c <pvPortMalloc>
    18fe:	9a 83       	std	Y+2, r25	; 0x02
    1900:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    1902:	89 81       	ldd	r24, Y+1	; 0x01
    1904:	9a 81       	ldd	r25, Y+2	; 0x02
    1906:	00 97       	sbiw	r24, 0x00	; 0
    1908:	f1 f1       	breq	.+124    	; 0x1986 <xQueueCreateMutex+0x9c>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    190a:	89 81       	ldd	r24, Y+1	; 0x01
    190c:	9a 81       	ldd	r25, Y+2	; 0x02
    190e:	fc 01       	movw	r30, r24
    1910:	13 82       	std	Z+3, r1	; 0x03
    1912:	12 82       	std	Z+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    1914:	89 81       	ldd	r24, Y+1	; 0x01
    1916:	9a 81       	ldd	r25, Y+2	; 0x02
    1918:	fc 01       	movw	r30, r24
    191a:	11 82       	std	Z+1, r1	; 0x01
    191c:	10 82       	st	Z, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    191e:	89 81       	ldd	r24, Y+1	; 0x01
    1920:	9a 81       	ldd	r25, Y+2	; 0x02
    1922:	fc 01       	movw	r30, r24
    1924:	15 82       	std	Z+5, r1	; 0x05
    1926:	14 82       	std	Z+4, r1	; 0x04
			pxNewQueue->pcReadFrom = NULL;
    1928:	89 81       	ldd	r24, Y+1	; 0x01
    192a:	9a 81       	ldd	r25, Y+2	; 0x02
    192c:	fc 01       	movw	r30, r24
    192e:	17 82       	std	Z+7, r1	; 0x07
    1930:	16 82       	std	Z+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1932:	89 81       	ldd	r24, Y+1	; 0x01
    1934:	9a 81       	ldd	r25, Y+2	; 0x02
    1936:	fc 01       	movw	r30, r24
    1938:	12 8e       	std	Z+26, r1	; 0x1a
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
    193a:	89 81       	ldd	r24, Y+1	; 0x01
    193c:	9a 81       	ldd	r25, Y+2	; 0x02
    193e:	21 e0       	ldi	r18, 0x01	; 1
    1940:	fc 01       	movw	r30, r24
    1942:	23 8f       	std	Z+27, r18	; 0x1b
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
    1944:	89 81       	ldd	r24, Y+1	; 0x01
    1946:	9a 81       	ldd	r25, Y+2	; 0x02
    1948:	fc 01       	movw	r30, r24
    194a:	14 8e       	std	Z+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    194c:	89 81       	ldd	r24, Y+1	; 0x01
    194e:	9a 81       	ldd	r25, Y+2	; 0x02
    1950:	2f ef       	ldi	r18, 0xFF	; 255
    1952:	fc 01       	movw	r30, r24
    1954:	25 8f       	std	Z+29, r18	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    1956:	89 81       	ldd	r24, Y+1	; 0x01
    1958:	9a 81       	ldd	r25, Y+2	; 0x02
    195a:	2f ef       	ldi	r18, 0xFF	; 255
    195c:	fc 01       	movw	r30, r24
    195e:	26 8f       	std	Z+30, r18	; 0x1e
				pxNewQueue->ucQueueType = ucQueueType;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1960:	89 81       	ldd	r24, Y+1	; 0x01
    1962:	9a 81       	ldd	r25, Y+2	; 0x02
    1964:	08 96       	adiw	r24, 0x08	; 8
    1966:	0e 94 37 11 	call	0x226e	; 0x226e <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    196a:	89 81       	ldd	r24, Y+1	; 0x01
    196c:	9a 81       	ldd	r25, Y+2	; 0x02
    196e:	41 96       	adiw	r24, 0x11	; 17
    1970:	0e 94 37 11 	call	0x226e	; 0x226e <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
    1974:	89 81       	ldd	r24, Y+1	; 0x01
    1976:	9a 81       	ldd	r25, Y+2	; 0x02
    1978:	20 e0       	ldi	r18, 0x00	; 0
    197a:	40 e0       	ldi	r20, 0x00	; 0
    197c:	50 e0       	ldi	r21, 0x00	; 0
    197e:	60 e0       	ldi	r22, 0x00	; 0
    1980:	70 e0       	ldi	r23, 0x00	; 0
    1982:	0e 94 cb 0c 	call	0x1996	; 0x1996 <xQueueGenericSend>
		{
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
    1986:	89 81       	ldd	r24, Y+1	; 0x01
    1988:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    198a:	0f 90       	pop	r0
    198c:	0f 90       	pop	r0
    198e:	0f 90       	pop	r0
    1990:	df 91       	pop	r29
    1992:	cf 91       	pop	r28
    1994:	08 95       	ret

00001996 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    1996:	cf 93       	push	r28
    1998:	df 93       	push	r29
    199a:	cd b7       	in	r28, 0x3d	; 61
    199c:	de b7       	in	r29, 0x3e	; 62
    199e:	2b 97       	sbiw	r28, 0x0b	; 11
    19a0:	0f b6       	in	r0, 0x3f	; 63
    19a2:	f8 94       	cli
    19a4:	de bf       	out	0x3e, r29	; 62
    19a6:	0f be       	out	0x3f, r0	; 63
    19a8:	cd bf       	out	0x3d, r28	; 61
    19aa:	9e 83       	std	Y+6, r25	; 0x06
    19ac:	8d 83       	std	Y+5, r24	; 0x05
    19ae:	78 87       	std	Y+8, r23	; 0x08
    19b0:	6f 83       	std	Y+7, r22	; 0x07
    19b2:	5a 87       	std	Y+10, r21	; 0x0a
    19b4:	49 87       	std	Y+9, r20	; 0x09
    19b6:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    19b8:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    19ba:	0f b6       	in	r0, 0x3f	; 63
    19bc:	f8 94       	cli
    19be:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    19c0:	8d 81       	ldd	r24, Y+5	; 0x05
    19c2:	9e 81       	ldd	r25, Y+6	; 0x06
    19c4:	fc 01       	movw	r30, r24
    19c6:	22 8d       	ldd	r18, Z+26	; 0x1a
    19c8:	8d 81       	ldd	r24, Y+5	; 0x05
    19ca:	9e 81       	ldd	r25, Y+6	; 0x06
    19cc:	fc 01       	movw	r30, r24
    19ce:	83 8d       	ldd	r24, Z+27	; 0x1b
    19d0:	28 17       	cp	r18, r24
    19d2:	d8 f4       	brcc	.+54     	; 0x1a0a <xQueueGenericSend+0x74>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    19d4:	2f 81       	ldd	r18, Y+7	; 0x07
    19d6:	38 85       	ldd	r19, Y+8	; 0x08
    19d8:	8d 81       	ldd	r24, Y+5	; 0x05
    19da:	9e 81       	ldd	r25, Y+6	; 0x06
    19dc:	4b 85       	ldd	r20, Y+11	; 0x0b
    19de:	b9 01       	movw	r22, r18
    19e0:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    19e4:	8d 81       	ldd	r24, Y+5	; 0x05
    19e6:	9e 81       	ldd	r25, Y+6	; 0x06
    19e8:	fc 01       	movw	r30, r24
    19ea:	81 89       	ldd	r24, Z+17	; 0x11
    19ec:	88 23       	and	r24, r24
    19ee:	49 f0       	breq	.+18     	; 0x1a02 <xQueueGenericSend+0x6c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    19f0:	8d 81       	ldd	r24, Y+5	; 0x05
    19f2:	9e 81       	ldd	r25, Y+6	; 0x06
    19f4:	41 96       	adiw	r24, 0x11	; 17
    19f6:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <xTaskRemoveFromEventList>
    19fa:	81 30       	cpi	r24, 0x01	; 1
    19fc:	11 f4       	brne	.+4      	; 0x1a02 <xQueueGenericSend+0x6c>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    19fe:	0e 94 11 18 	call	0x3022	; 0x3022 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    1a02:	0f 90       	pop	r0
    1a04:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    1a06:	81 e0       	ldi	r24, 0x01	; 1
    1a08:	61 c0       	rjmp	.+194    	; 0x1acc <xQueueGenericSend+0x136>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1a0a:	89 85       	ldd	r24, Y+9	; 0x09
    1a0c:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a0e:	00 97       	sbiw	r24, 0x00	; 0
    1a10:	21 f4       	brne	.+8      	; 0x1a1a <xQueueGenericSend+0x84>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1a12:	0f 90       	pop	r0
    1a14:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1a16:	80 e0       	ldi	r24, 0x00	; 0
    1a18:	59 c0       	rjmp	.+178    	; 0x1acc <xQueueGenericSend+0x136>
				}
				else if( xEntryTimeSet == pdFALSE )
    1a1a:	89 81       	ldd	r24, Y+1	; 0x01
    1a1c:	88 23       	and	r24, r24
    1a1e:	31 f4       	brne	.+12     	; 0x1a2c <xQueueGenericSend+0x96>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1a20:	ce 01       	movw	r24, r28
    1a22:	02 96       	adiw	r24, 0x02	; 2
    1a24:	0e 94 4e 08 	call	0x109c	; 0x109c <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1a28:	81 e0       	ldi	r24, 0x01	; 1
    1a2a:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    1a2c:	0f 90       	pop	r0
    1a2e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1a30:	0e 94 87 05 	call	0xb0e	; 0xb0e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1a34:	0f b6       	in	r0, 0x3f	; 63
    1a36:	f8 94       	cli
    1a38:	0f 92       	push	r0
    1a3a:	8d 81       	ldd	r24, Y+5	; 0x05
    1a3c:	9e 81       	ldd	r25, Y+6	; 0x06
    1a3e:	fc 01       	movw	r30, r24
    1a40:	85 8d       	ldd	r24, Z+29	; 0x1d
    1a42:	8f 3f       	cpi	r24, 0xFF	; 255
    1a44:	21 f4       	brne	.+8      	; 0x1a4e <xQueueGenericSend+0xb8>
    1a46:	8d 81       	ldd	r24, Y+5	; 0x05
    1a48:	9e 81       	ldd	r25, Y+6	; 0x06
    1a4a:	fc 01       	movw	r30, r24
    1a4c:	15 8e       	std	Z+29, r1	; 0x1d
    1a4e:	8d 81       	ldd	r24, Y+5	; 0x05
    1a50:	9e 81       	ldd	r25, Y+6	; 0x06
    1a52:	fc 01       	movw	r30, r24
    1a54:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a56:	8f 3f       	cpi	r24, 0xFF	; 255
    1a58:	21 f4       	brne	.+8      	; 0x1a62 <xQueueGenericSend+0xcc>
    1a5a:	8d 81       	ldd	r24, Y+5	; 0x05
    1a5c:	9e 81       	ldd	r25, Y+6	; 0x06
    1a5e:	fc 01       	movw	r30, r24
    1a60:	16 8e       	std	Z+30, r1	; 0x1e
    1a62:	0f 90       	pop	r0
    1a64:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1a66:	9e 01       	movw	r18, r28
    1a68:	27 5f       	subi	r18, 0xF7	; 247
    1a6a:	3f 4f       	sbci	r19, 0xFF	; 255
    1a6c:	ce 01       	movw	r24, r28
    1a6e:	02 96       	adiw	r24, 0x02	; 2
    1a70:	b9 01       	movw	r22, r18
    1a72:	0e 94 6a 08 	call	0x10d4	; 0x10d4 <xTaskCheckForTimeOut>
    1a76:	88 23       	and	r24, r24
    1a78:	01 f5       	brne	.+64     	; 0x1aba <xQueueGenericSend+0x124>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1a7a:	8d 81       	ldd	r24, Y+5	; 0x05
    1a7c:	9e 81       	ldd	r25, Y+6	; 0x06
    1a7e:	0e 94 fc 10 	call	0x21f8	; 0x21f8 <prvIsQueueFull>
    1a82:	88 23       	and	r24, r24
    1a84:	99 f0       	breq	.+38     	; 0x1aac <xQueueGenericSend+0x116>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1a86:	29 85       	ldd	r18, Y+9	; 0x09
    1a88:	3a 85       	ldd	r19, Y+10	; 0x0a
    1a8a:	8d 81       	ldd	r24, Y+5	; 0x05
    1a8c:	9e 81       	ldd	r25, Y+6	; 0x06
    1a8e:	08 96       	adiw	r24, 0x08	; 8
    1a90:	b9 01       	movw	r22, r18
    1a92:	0e 94 9f 07 	call	0xf3e	; 0xf3e <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1a96:	8d 81       	ldd	r24, Y+5	; 0x05
    1a98:	9e 81       	ldd	r25, Y+6	; 0x06
    1a9a:	0e 94 64 10 	call	0x20c8	; 0x20c8 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1a9e:	0e 94 93 05 	call	0xb26	; 0xb26 <xTaskResumeAll>
    1aa2:	88 23       	and	r24, r24
    1aa4:	91 f4       	brne	.+36     	; 0x1aca <xQueueGenericSend+0x134>
				{
					portYIELD_WITHIN_API();
    1aa6:	0e 94 11 18 	call	0x3022	; 0x3022 <vPortYield>
    1aaa:	0f c0       	rjmp	.+30     	; 0x1aca <xQueueGenericSend+0x134>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1aac:	8d 81       	ldd	r24, Y+5	; 0x05
    1aae:	9e 81       	ldd	r25, Y+6	; 0x06
    1ab0:	0e 94 64 10 	call	0x20c8	; 0x20c8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1ab4:	0e 94 93 05 	call	0xb26	; 0xb26 <xTaskResumeAll>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
    1ab8:	80 cf       	rjmp	.-256    	; 0x19ba <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1aba:	8d 81       	ldd	r24, Y+5	; 0x05
    1abc:	9e 81       	ldd	r25, Y+6	; 0x06
    1abe:	0e 94 64 10 	call	0x20c8	; 0x20c8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1ac2:	0e 94 93 05 	call	0xb26	; 0xb26 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1ac6:	80 e0       	ldi	r24, 0x00	; 0
    1ac8:	01 c0       	rjmp	.+2      	; 0x1acc <xQueueGenericSend+0x136>
		}
	}
    1aca:	77 cf       	rjmp	.-274    	; 0x19ba <xQueueGenericSend+0x24>
}
    1acc:	2b 96       	adiw	r28, 0x0b	; 11
    1ace:	0f b6       	in	r0, 0x3f	; 63
    1ad0:	f8 94       	cli
    1ad2:	de bf       	out	0x3e, r29	; 62
    1ad4:	0f be       	out	0x3f, r0	; 63
    1ad6:	cd bf       	out	0x3d, r28	; 61
    1ad8:	df 91       	pop	r29
    1ada:	cf 91       	pop	r28
    1adc:	08 95       	ret

00001ade <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1ade:	cf 93       	push	r28
    1ae0:	df 93       	push	r29
    1ae2:	cd b7       	in	r28, 0x3d	; 61
    1ae4:	de b7       	in	r29, 0x3e	; 62
    1ae6:	29 97       	sbiw	r28, 0x09	; 9
    1ae8:	0f b6       	in	r0, 0x3f	; 63
    1aea:	f8 94       	cli
    1aec:	de bf       	out	0x3e, r29	; 62
    1aee:	0f be       	out	0x3f, r0	; 63
    1af0:	cd bf       	out	0x3d, r28	; 61
    1af2:	9c 83       	std	Y+4, r25	; 0x04
    1af4:	8b 83       	std	Y+3, r24	; 0x03
    1af6:	7e 83       	std	Y+6, r23	; 0x06
    1af8:	6d 83       	std	Y+5, r22	; 0x05
    1afa:	58 87       	std	Y+8, r21	; 0x08
    1afc:	4f 83       	std	Y+7, r20	; 0x07
    1afe:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1b00:	1a 82       	std	Y+2, r1	; 0x02
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1b02:	8b 81       	ldd	r24, Y+3	; 0x03
    1b04:	9c 81       	ldd	r25, Y+4	; 0x04
    1b06:	fc 01       	movw	r30, r24
    1b08:	22 8d       	ldd	r18, Z+26	; 0x1a
    1b0a:	8b 81       	ldd	r24, Y+3	; 0x03
    1b0c:	9c 81       	ldd	r25, Y+4	; 0x04
    1b0e:	fc 01       	movw	r30, r24
    1b10:	83 8d       	ldd	r24, Z+27	; 0x1b
    1b12:	28 17       	cp	r18, r24
    1b14:	90 f5       	brcc	.+100    	; 0x1b7a <xQueueGenericSendFromISR+0x9c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1b16:	2d 81       	ldd	r18, Y+5	; 0x05
    1b18:	3e 81       	ldd	r19, Y+6	; 0x06
    1b1a:	8b 81       	ldd	r24, Y+3	; 0x03
    1b1c:	9c 81       	ldd	r25, Y+4	; 0x04
    1b1e:	49 85       	ldd	r20, Y+9	; 0x09
    1b20:	b9 01       	movw	r22, r18
    1b22:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1b26:	8b 81       	ldd	r24, Y+3	; 0x03
    1b28:	9c 81       	ldd	r25, Y+4	; 0x04
    1b2a:	fc 01       	movw	r30, r24
    1b2c:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b2e:	8f 3f       	cpi	r24, 0xFF	; 255
    1b30:	b9 f4       	brne	.+46     	; 0x1b60 <xQueueGenericSendFromISR+0x82>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b32:	8b 81       	ldd	r24, Y+3	; 0x03
    1b34:	9c 81       	ldd	r25, Y+4	; 0x04
    1b36:	fc 01       	movw	r30, r24
    1b38:	81 89       	ldd	r24, Z+17	; 0x11
    1b3a:	88 23       	and	r24, r24
    1b3c:	d9 f0       	breq	.+54     	; 0x1b74 <xQueueGenericSendFromISR+0x96>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b3e:	8b 81       	ldd	r24, Y+3	; 0x03
    1b40:	9c 81       	ldd	r25, Y+4	; 0x04
    1b42:	41 96       	adiw	r24, 0x11	; 17
    1b44:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <xTaskRemoveFromEventList>
    1b48:	88 23       	and	r24, r24
    1b4a:	a1 f0       	breq	.+40     	; 0x1b74 <xQueueGenericSendFromISR+0x96>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						if( pxHigherPriorityTaskWoken != NULL )
    1b4c:	8f 81       	ldd	r24, Y+7	; 0x07
    1b4e:	98 85       	ldd	r25, Y+8	; 0x08
    1b50:	00 97       	sbiw	r24, 0x00	; 0
    1b52:	81 f0       	breq	.+32     	; 0x1b74 <xQueueGenericSendFromISR+0x96>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1b54:	8f 81       	ldd	r24, Y+7	; 0x07
    1b56:	98 85       	ldd	r25, Y+8	; 0x08
    1b58:	21 e0       	ldi	r18, 0x01	; 1
    1b5a:	fc 01       	movw	r30, r24
    1b5c:	20 83       	st	Z, r18
    1b5e:	0a c0       	rjmp	.+20     	; 0x1b74 <xQueueGenericSendFromISR+0x96>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1b60:	8b 81       	ldd	r24, Y+3	; 0x03
    1b62:	9c 81       	ldd	r25, Y+4	; 0x04
    1b64:	fc 01       	movw	r30, r24
    1b66:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b68:	21 e0       	ldi	r18, 0x01	; 1
    1b6a:	28 0f       	add	r18, r24
    1b6c:	8b 81       	ldd	r24, Y+3	; 0x03
    1b6e:	9c 81       	ldd	r25, Y+4	; 0x04
    1b70:	fc 01       	movw	r30, r24
    1b72:	26 8f       	std	Z+30, r18	; 0x1e
			}

			xReturn = pdPASS;
    1b74:	81 e0       	ldi	r24, 0x01	; 1
    1b76:	89 83       	std	Y+1, r24	; 0x01
    1b78:	01 c0       	rjmp	.+2      	; 0x1b7c <xQueueGenericSendFromISR+0x9e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1b7a:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1b7c:	89 81       	ldd	r24, Y+1	; 0x01
}
    1b7e:	29 96       	adiw	r28, 0x09	; 9
    1b80:	0f b6       	in	r0, 0x3f	; 63
    1b82:	f8 94       	cli
    1b84:	de bf       	out	0x3e, r29	; 62
    1b86:	0f be       	out	0x3f, r0	; 63
    1b88:	cd bf       	out	0x3d, r28	; 61
    1b8a:	df 91       	pop	r29
    1b8c:	cf 91       	pop	r28
    1b8e:	08 95       	ret

00001b90 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1b90:	cf 93       	push	r28
    1b92:	df 93       	push	r29
    1b94:	cd b7       	in	r28, 0x3d	; 61
    1b96:	de b7       	in	r29, 0x3e	; 62
    1b98:	2d 97       	sbiw	r28, 0x0d	; 13
    1b9a:	0f b6       	in	r0, 0x3f	; 63
    1b9c:	f8 94       	cli
    1b9e:	de bf       	out	0x3e, r29	; 62
    1ba0:	0f be       	out	0x3f, r0	; 63
    1ba2:	cd bf       	out	0x3d, r28	; 61
    1ba4:	98 87       	std	Y+8, r25	; 0x08
    1ba6:	8f 83       	std	Y+7, r24	; 0x07
    1ba8:	7a 87       	std	Y+10, r23	; 0x0a
    1baa:	69 87       	std	Y+9, r22	; 0x09
    1bac:	5c 87       	std	Y+12, r21	; 0x0c
    1bae:	4b 87       	std	Y+11, r20	; 0x0b
    1bb0:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1bb2:	19 82       	std	Y+1, r1	; 0x01
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1bb4:	0f b6       	in	r0, 0x3f	; 63
    1bb6:	f8 94       	cli
    1bb8:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1bba:	8f 81       	ldd	r24, Y+7	; 0x07
    1bbc:	98 85       	ldd	r25, Y+8	; 0x08
    1bbe:	fc 01       	movw	r30, r24
    1bc0:	82 8d       	ldd	r24, Z+26	; 0x1a
    1bc2:	88 23       	and	r24, r24
    1bc4:	09 f4       	brne	.+2      	; 0x1bc8 <xQueueGenericReceive+0x38>
    1bc6:	54 c0       	rjmp	.+168    	; 0x1c70 <xQueueGenericReceive+0xe0>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1bc8:	8f 81       	ldd	r24, Y+7	; 0x07
    1bca:	98 85       	ldd	r25, Y+8	; 0x08
    1bcc:	fc 01       	movw	r30, r24
    1bce:	86 81       	ldd	r24, Z+6	; 0x06
    1bd0:	97 81       	ldd	r25, Z+7	; 0x07
    1bd2:	9b 83       	std	Y+3, r25	; 0x03
    1bd4:	8a 83       	std	Y+2, r24	; 0x02

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1bd6:	29 85       	ldd	r18, Y+9	; 0x09
    1bd8:	3a 85       	ldd	r19, Y+10	; 0x0a
    1bda:	8f 81       	ldd	r24, Y+7	; 0x07
    1bdc:	98 85       	ldd	r25, Y+8	; 0x08
    1bde:	b9 01       	movw	r22, r18
    1be0:	0e 94 13 10 	call	0x2026	; 0x2026 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1be4:	8d 85       	ldd	r24, Y+13	; 0x0d
    1be6:	88 23       	and	r24, r24
    1be8:	49 f5       	brne	.+82     	; 0x1c3c <xQueueGenericReceive+0xac>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1bea:	8f 81       	ldd	r24, Y+7	; 0x07
    1bec:	98 85       	ldd	r25, Y+8	; 0x08
    1bee:	fc 01       	movw	r30, r24
    1bf0:	82 8d       	ldd	r24, Z+26	; 0x1a
    1bf2:	2f ef       	ldi	r18, 0xFF	; 255
    1bf4:	28 0f       	add	r18, r24
    1bf6:	8f 81       	ldd	r24, Y+7	; 0x07
    1bf8:	98 85       	ldd	r25, Y+8	; 0x08
    1bfa:	fc 01       	movw	r30, r24
    1bfc:	22 8f       	std	Z+26, r18	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1bfe:	8f 81       	ldd	r24, Y+7	; 0x07
    1c00:	98 85       	ldd	r25, Y+8	; 0x08
    1c02:	fc 01       	movw	r30, r24
    1c04:	80 81       	ld	r24, Z
    1c06:	91 81       	ldd	r25, Z+1	; 0x01
    1c08:	00 97       	sbiw	r24, 0x00	; 0
    1c0a:	41 f4       	brne	.+16     	; 0x1c1c <xQueueGenericReceive+0x8c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    1c0c:	0e 94 81 0a 	call	0x1502	; 0x1502 <xTaskGetCurrentTaskHandle>
    1c10:	9c 01       	movw	r18, r24
    1c12:	8f 81       	ldd	r24, Y+7	; 0x07
    1c14:	98 85       	ldd	r25, Y+8	; 0x08
    1c16:	fc 01       	movw	r30, r24
    1c18:	33 83       	std	Z+3, r19	; 0x03
    1c1a:	22 83       	std	Z+2, r18	; 0x02
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1c1c:	8f 81       	ldd	r24, Y+7	; 0x07
    1c1e:	98 85       	ldd	r25, Y+8	; 0x08
    1c20:	fc 01       	movw	r30, r24
    1c22:	80 85       	ldd	r24, Z+8	; 0x08
    1c24:	88 23       	and	r24, r24
    1c26:	01 f1       	breq	.+64     	; 0x1c68 <xQueueGenericReceive+0xd8>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1c28:	8f 81       	ldd	r24, Y+7	; 0x07
    1c2a:	98 85       	ldd	r25, Y+8	; 0x08
    1c2c:	08 96       	adiw	r24, 0x08	; 8
    1c2e:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <xTaskRemoveFromEventList>
    1c32:	81 30       	cpi	r24, 0x01	; 1
    1c34:	c9 f4       	brne	.+50     	; 0x1c68 <xQueueGenericReceive+0xd8>
						{
							portYIELD_WITHIN_API();
    1c36:	0e 94 11 18 	call	0x3022	; 0x3022 <vPortYield>
    1c3a:	16 c0       	rjmp	.+44     	; 0x1c68 <xQueueGenericReceive+0xd8>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1c3c:	8f 81       	ldd	r24, Y+7	; 0x07
    1c3e:	98 85       	ldd	r25, Y+8	; 0x08
    1c40:	2a 81       	ldd	r18, Y+2	; 0x02
    1c42:	3b 81       	ldd	r19, Y+3	; 0x03
    1c44:	fc 01       	movw	r30, r24
    1c46:	37 83       	std	Z+7, r19	; 0x07
    1c48:	26 83       	std	Z+6, r18	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1c4a:	8f 81       	ldd	r24, Y+7	; 0x07
    1c4c:	98 85       	ldd	r25, Y+8	; 0x08
    1c4e:	fc 01       	movw	r30, r24
    1c50:	81 89       	ldd	r24, Z+17	; 0x11
    1c52:	88 23       	and	r24, r24
    1c54:	49 f0       	breq	.+18     	; 0x1c68 <xQueueGenericReceive+0xd8>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1c56:	8f 81       	ldd	r24, Y+7	; 0x07
    1c58:	98 85       	ldd	r25, Y+8	; 0x08
    1c5a:	41 96       	adiw	r24, 0x11	; 17
    1c5c:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <xTaskRemoveFromEventList>
    1c60:	88 23       	and	r24, r24
    1c62:	11 f0       	breq	.+4      	; 0x1c68 <xQueueGenericReceive+0xd8>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1c64:	0e 94 11 18 	call	0x3022	; 0x3022 <vPortYield>
						}
					}
				}

				taskEXIT_CRITICAL();
    1c68:	0f 90       	pop	r0
    1c6a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1c6c:	81 e0       	ldi	r24, 0x01	; 1
    1c6e:	74 c0       	rjmp	.+232    	; 0x1d58 <xQueueGenericReceive+0x1c8>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1c70:	8b 85       	ldd	r24, Y+11	; 0x0b
    1c72:	9c 85       	ldd	r25, Y+12	; 0x0c
    1c74:	00 97       	sbiw	r24, 0x00	; 0
    1c76:	21 f4       	brne	.+8      	; 0x1c80 <xQueueGenericReceive+0xf0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1c78:	0f 90       	pop	r0
    1c7a:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1c7c:	80 e0       	ldi	r24, 0x00	; 0
    1c7e:	6c c0       	rjmp	.+216    	; 0x1d58 <xQueueGenericReceive+0x1c8>
				}
				else if( xEntryTimeSet == pdFALSE )
    1c80:	89 81       	ldd	r24, Y+1	; 0x01
    1c82:	88 23       	and	r24, r24
    1c84:	31 f4       	brne	.+12     	; 0x1c92 <xQueueGenericReceive+0x102>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1c86:	ce 01       	movw	r24, r28
    1c88:	04 96       	adiw	r24, 0x04	; 4
    1c8a:	0e 94 4e 08 	call	0x109c	; 0x109c <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1c8e:	81 e0       	ldi	r24, 0x01	; 1
    1c90:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    1c92:	0f 90       	pop	r0
    1c94:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1c96:	0e 94 87 05 	call	0xb0e	; 0xb0e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1c9a:	0f b6       	in	r0, 0x3f	; 63
    1c9c:	f8 94       	cli
    1c9e:	0f 92       	push	r0
    1ca0:	8f 81       	ldd	r24, Y+7	; 0x07
    1ca2:	98 85       	ldd	r25, Y+8	; 0x08
    1ca4:	fc 01       	movw	r30, r24
    1ca6:	85 8d       	ldd	r24, Z+29	; 0x1d
    1ca8:	8f 3f       	cpi	r24, 0xFF	; 255
    1caa:	21 f4       	brne	.+8      	; 0x1cb4 <xQueueGenericReceive+0x124>
    1cac:	8f 81       	ldd	r24, Y+7	; 0x07
    1cae:	98 85       	ldd	r25, Y+8	; 0x08
    1cb0:	fc 01       	movw	r30, r24
    1cb2:	15 8e       	std	Z+29, r1	; 0x1d
    1cb4:	8f 81       	ldd	r24, Y+7	; 0x07
    1cb6:	98 85       	ldd	r25, Y+8	; 0x08
    1cb8:	fc 01       	movw	r30, r24
    1cba:	86 8d       	ldd	r24, Z+30	; 0x1e
    1cbc:	8f 3f       	cpi	r24, 0xFF	; 255
    1cbe:	21 f4       	brne	.+8      	; 0x1cc8 <xQueueGenericReceive+0x138>
    1cc0:	8f 81       	ldd	r24, Y+7	; 0x07
    1cc2:	98 85       	ldd	r25, Y+8	; 0x08
    1cc4:	fc 01       	movw	r30, r24
    1cc6:	16 8e       	std	Z+30, r1	; 0x1e
    1cc8:	0f 90       	pop	r0
    1cca:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1ccc:	9e 01       	movw	r18, r28
    1cce:	25 5f       	subi	r18, 0xF5	; 245
    1cd0:	3f 4f       	sbci	r19, 0xFF	; 255
    1cd2:	ce 01       	movw	r24, r28
    1cd4:	04 96       	adiw	r24, 0x04	; 4
    1cd6:	b9 01       	movw	r22, r18
    1cd8:	0e 94 6a 08 	call	0x10d4	; 0x10d4 <xTaskCheckForTimeOut>
    1cdc:	88 23       	and	r24, r24
    1cde:	99 f5       	brne	.+102    	; 0x1d46 <xQueueGenericReceive+0x1b6>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1ce0:	8f 81       	ldd	r24, Y+7	; 0x07
    1ce2:	98 85       	ldd	r25, Y+8	; 0x08
    1ce4:	0e 94 c9 10 	call	0x2192	; 0x2192 <prvIsQueueEmpty>
    1ce8:	88 23       	and	r24, r24
    1cea:	31 f1       	breq	.+76     	; 0x1d38 <xQueueGenericReceive+0x1a8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1cec:	8f 81       	ldd	r24, Y+7	; 0x07
    1cee:	98 85       	ldd	r25, Y+8	; 0x08
    1cf0:	fc 01       	movw	r30, r24
    1cf2:	80 81       	ld	r24, Z
    1cf4:	91 81       	ldd	r25, Z+1	; 0x01
    1cf6:	00 97       	sbiw	r24, 0x00	; 0
    1cf8:	61 f4       	brne	.+24     	; 0x1d12 <xQueueGenericReceive+0x182>
					{
						portENTER_CRITICAL();
    1cfa:	0f b6       	in	r0, 0x3f	; 63
    1cfc:	f8 94       	cli
    1cfe:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1d00:	8f 81       	ldd	r24, Y+7	; 0x07
    1d02:	98 85       	ldd	r25, Y+8	; 0x08
    1d04:	fc 01       	movw	r30, r24
    1d06:	82 81       	ldd	r24, Z+2	; 0x02
    1d08:	93 81       	ldd	r25, Z+3	; 0x03
    1d0a:	0e 94 94 0a 	call	0x1528	; 0x1528 <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    1d0e:	0f 90       	pop	r0
    1d10:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1d12:	2b 85       	ldd	r18, Y+11	; 0x0b
    1d14:	3c 85       	ldd	r19, Y+12	; 0x0c
    1d16:	8f 81       	ldd	r24, Y+7	; 0x07
    1d18:	98 85       	ldd	r25, Y+8	; 0x08
    1d1a:	41 96       	adiw	r24, 0x11	; 17
    1d1c:	b9 01       	movw	r22, r18
    1d1e:	0e 94 9f 07 	call	0xf3e	; 0xf3e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1d22:	8f 81       	ldd	r24, Y+7	; 0x07
    1d24:	98 85       	ldd	r25, Y+8	; 0x08
    1d26:	0e 94 64 10 	call	0x20c8	; 0x20c8 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1d2a:	0e 94 93 05 	call	0xb26	; 0xb26 <xTaskResumeAll>
    1d2e:	88 23       	and	r24, r24
    1d30:	91 f4       	brne	.+36     	; 0x1d56 <xQueueGenericReceive+0x1c6>
				{
					portYIELD_WITHIN_API();
    1d32:	0e 94 11 18 	call	0x3022	; 0x3022 <vPortYield>
    1d36:	0f c0       	rjmp	.+30     	; 0x1d56 <xQueueGenericReceive+0x1c6>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1d38:	8f 81       	ldd	r24, Y+7	; 0x07
    1d3a:	98 85       	ldd	r25, Y+8	; 0x08
    1d3c:	0e 94 64 10 	call	0x20c8	; 0x20c8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1d40:	0e 94 93 05 	call	0xb26	; 0xb26 <xTaskResumeAll>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
    1d44:	37 cf       	rjmp	.-402    	; 0x1bb4 <xQueueGenericReceive+0x24>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1d46:	8f 81       	ldd	r24, Y+7	; 0x07
    1d48:	98 85       	ldd	r25, Y+8	; 0x08
    1d4a:	0e 94 64 10 	call	0x20c8	; 0x20c8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1d4e:	0e 94 93 05 	call	0xb26	; 0xb26 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1d52:	80 e0       	ldi	r24, 0x00	; 0
    1d54:	01 c0       	rjmp	.+2      	; 0x1d58 <xQueueGenericReceive+0x1c8>
		}
	}
    1d56:	2e cf       	rjmp	.-420    	; 0x1bb4 <xQueueGenericReceive+0x24>
}
    1d58:	2d 96       	adiw	r28, 0x0d	; 13
    1d5a:	0f b6       	in	r0, 0x3f	; 63
    1d5c:	f8 94       	cli
    1d5e:	de bf       	out	0x3e, r29	; 62
    1d60:	0f be       	out	0x3f, r0	; 63
    1d62:	cd bf       	out	0x3d, r28	; 61
    1d64:	df 91       	pop	r29
    1d66:	cf 91       	pop	r28
    1d68:	08 95       	ret

00001d6a <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
{
    1d6a:	cf 93       	push	r28
    1d6c:	df 93       	push	r29
    1d6e:	cd b7       	in	r28, 0x3d	; 61
    1d70:	de b7       	in	r29, 0x3e	; 62
    1d72:	28 97       	sbiw	r28, 0x08	; 8
    1d74:	0f b6       	in	r0, 0x3f	; 63
    1d76:	f8 94       	cli
    1d78:	de bf       	out	0x3e, r29	; 62
    1d7a:	0f be       	out	0x3f, r0	; 63
    1d7c:	cd bf       	out	0x3d, r28	; 61
    1d7e:	9c 83       	std	Y+4, r25	; 0x04
    1d80:	8b 83       	std	Y+3, r24	; 0x03
    1d82:	7e 83       	std	Y+6, r23	; 0x06
    1d84:	6d 83       	std	Y+5, r22	; 0x05
    1d86:	58 87       	std	Y+8, r21	; 0x08
    1d88:	4f 83       	std	Y+7, r20	; 0x07
unsigned portBASE_TYPE uxSavedInterruptStatus;

	configASSERT( pxQueue );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1d8a:	1a 82       	std	Y+2, r1	; 0x02
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1d8c:	8b 81       	ldd	r24, Y+3	; 0x03
    1d8e:	9c 81       	ldd	r25, Y+4	; 0x04
    1d90:	fc 01       	movw	r30, r24
    1d92:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d94:	88 23       	and	r24, r24
    1d96:	d9 f1       	breq	.+118    	; 0x1e0e <xQueueReceiveFromISR+0xa4>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1d98:	2d 81       	ldd	r18, Y+5	; 0x05
    1d9a:	3e 81       	ldd	r19, Y+6	; 0x06
    1d9c:	8b 81       	ldd	r24, Y+3	; 0x03
    1d9e:	9c 81       	ldd	r25, Y+4	; 0x04
    1da0:	b9 01       	movw	r22, r18
    1da2:	0e 94 13 10 	call	0x2026	; 0x2026 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1da6:	8b 81       	ldd	r24, Y+3	; 0x03
    1da8:	9c 81       	ldd	r25, Y+4	; 0x04
    1daa:	fc 01       	movw	r30, r24
    1dac:	82 8d       	ldd	r24, Z+26	; 0x1a
    1dae:	2f ef       	ldi	r18, 0xFF	; 255
    1db0:	28 0f       	add	r18, r24
    1db2:	8b 81       	ldd	r24, Y+3	; 0x03
    1db4:	9c 81       	ldd	r25, Y+4	; 0x04
    1db6:	fc 01       	movw	r30, r24
    1db8:	22 8f       	std	Z+26, r18	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1dba:	8b 81       	ldd	r24, Y+3	; 0x03
    1dbc:	9c 81       	ldd	r25, Y+4	; 0x04
    1dbe:	fc 01       	movw	r30, r24
    1dc0:	85 8d       	ldd	r24, Z+29	; 0x1d
    1dc2:	8f 3f       	cpi	r24, 0xFF	; 255
    1dc4:	b9 f4       	brne	.+46     	; 0x1df4 <xQueueReceiveFromISR+0x8a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1dc6:	8b 81       	ldd	r24, Y+3	; 0x03
    1dc8:	9c 81       	ldd	r25, Y+4	; 0x04
    1dca:	fc 01       	movw	r30, r24
    1dcc:	80 85       	ldd	r24, Z+8	; 0x08
    1dce:	88 23       	and	r24, r24
    1dd0:	d9 f0       	breq	.+54     	; 0x1e08 <xQueueReceiveFromISR+0x9e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1dd2:	8b 81       	ldd	r24, Y+3	; 0x03
    1dd4:	9c 81       	ldd	r25, Y+4	; 0x04
    1dd6:	08 96       	adiw	r24, 0x08	; 8
    1dd8:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <xTaskRemoveFromEventList>
    1ddc:	88 23       	and	r24, r24
    1dde:	a1 f0       	breq	.+40     	; 0x1e08 <xQueueReceiveFromISR+0x9e>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1de0:	8f 81       	ldd	r24, Y+7	; 0x07
    1de2:	98 85       	ldd	r25, Y+8	; 0x08
    1de4:	00 97       	sbiw	r24, 0x00	; 0
    1de6:	81 f0       	breq	.+32     	; 0x1e08 <xQueueReceiveFromISR+0x9e>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1de8:	8f 81       	ldd	r24, Y+7	; 0x07
    1dea:	98 85       	ldd	r25, Y+8	; 0x08
    1dec:	21 e0       	ldi	r18, 0x01	; 1
    1dee:	fc 01       	movw	r30, r24
    1df0:	20 83       	st	Z, r18
    1df2:	0a c0       	rjmp	.+20     	; 0x1e08 <xQueueReceiveFromISR+0x9e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1df4:	8b 81       	ldd	r24, Y+3	; 0x03
    1df6:	9c 81       	ldd	r25, Y+4	; 0x04
    1df8:	fc 01       	movw	r30, r24
    1dfa:	85 8d       	ldd	r24, Z+29	; 0x1d
    1dfc:	21 e0       	ldi	r18, 0x01	; 1
    1dfe:	28 0f       	add	r18, r24
    1e00:	8b 81       	ldd	r24, Y+3	; 0x03
    1e02:	9c 81       	ldd	r25, Y+4	; 0x04
    1e04:	fc 01       	movw	r30, r24
    1e06:	25 8f       	std	Z+29, r18	; 0x1d
			}

			xReturn = pdPASS;
    1e08:	81 e0       	ldi	r24, 0x01	; 1
    1e0a:	89 83       	std	Y+1, r24	; 0x01
    1e0c:	01 c0       	rjmp	.+2      	; 0x1e10 <xQueueReceiveFromISR+0xa6>
		}
		else
		{
			xReturn = pdFAIL;
    1e0e:	19 82       	std	Y+1, r1	; 0x01
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1e10:	89 81       	ldd	r24, Y+1	; 0x01
}
    1e12:	28 96       	adiw	r28, 0x08	; 8
    1e14:	0f b6       	in	r0, 0x3f	; 63
    1e16:	f8 94       	cli
    1e18:	de bf       	out	0x3e, r29	; 62
    1e1a:	0f be       	out	0x3f, r0	; 63
    1e1c:	cd bf       	out	0x3d, r28	; 61
    1e1e:	df 91       	pop	r29
    1e20:	cf 91       	pop	r28
    1e22:	08 95       	ret

00001e24 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    1e24:	cf 93       	push	r28
    1e26:	df 93       	push	r29
    1e28:	00 d0       	rcall	.+0      	; 0x1e2a <uxQueueMessagesWaiting+0x6>
    1e2a:	cd b7       	in	r28, 0x3d	; 61
    1e2c:	de b7       	in	r29, 0x3e	; 62
    1e2e:	9b 83       	std	Y+3, r25	; 0x03
    1e30:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1e32:	0f b6       	in	r0, 0x3f	; 63
    1e34:	f8 94       	cli
    1e36:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1e38:	8a 81       	ldd	r24, Y+2	; 0x02
    1e3a:	9b 81       	ldd	r25, Y+3	; 0x03
    1e3c:	fc 01       	movw	r30, r24
    1e3e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e40:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1e42:	0f 90       	pop	r0
    1e44:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1e46:	89 81       	ldd	r24, Y+1	; 0x01
}
    1e48:	0f 90       	pop	r0
    1e4a:	0f 90       	pop	r0
    1e4c:	0f 90       	pop	r0
    1e4e:	df 91       	pop	r29
    1e50:	cf 91       	pop	r28
    1e52:	08 95       	ret

00001e54 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    1e54:	cf 93       	push	r28
    1e56:	df 93       	push	r29
    1e58:	00 d0       	rcall	.+0      	; 0x1e5a <uxQueueMessagesWaitingFromISR+0x6>
    1e5a:	cd b7       	in	r28, 0x3d	; 61
    1e5c:	de b7       	in	r29, 0x3e	; 62
    1e5e:	9b 83       	std	Y+3, r25	; 0x03
    1e60:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    1e62:	8a 81       	ldd	r24, Y+2	; 0x02
    1e64:	9b 81       	ldd	r25, Y+3	; 0x03
    1e66:	fc 01       	movw	r30, r24
    1e68:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e6a:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    1e6c:	89 81       	ldd	r24, Y+1	; 0x01
}
    1e6e:	0f 90       	pop	r0
    1e70:	0f 90       	pop	r0
    1e72:	0f 90       	pop	r0
    1e74:	df 91       	pop	r29
    1e76:	cf 91       	pop	r28
    1e78:	08 95       	ret

00001e7a <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    1e7a:	cf 93       	push	r28
    1e7c:	df 93       	push	r29
    1e7e:	1f 92       	push	r1
    1e80:	1f 92       	push	r1
    1e82:	cd b7       	in	r28, 0x3d	; 61
    1e84:	de b7       	in	r29, 0x3e	; 62
    1e86:	9a 83       	std	Y+2, r25	; 0x02
    1e88:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    1e8a:	89 81       	ldd	r24, Y+1	; 0x01
    1e8c:	9a 81       	ldd	r25, Y+2	; 0x02
    1e8e:	fc 01       	movw	r30, r24
    1e90:	80 81       	ld	r24, Z
    1e92:	91 81       	ldd	r25, Z+1	; 0x01
    1e94:	0e 94 e4 15 	call	0x2bc8	; 0x2bc8 <vPortFree>
	vPortFree( pxQueue );
    1e98:	89 81       	ldd	r24, Y+1	; 0x01
    1e9a:	9a 81       	ldd	r25, Y+2	; 0x02
    1e9c:	0e 94 e4 15 	call	0x2bc8	; 0x2bc8 <vPortFree>
}
    1ea0:	0f 90       	pop	r0
    1ea2:	0f 90       	pop	r0
    1ea4:	df 91       	pop	r29
    1ea6:	cf 91       	pop	r28
    1ea8:	08 95       	ret

00001eaa <prvCopyDataToQueue>:

#endif
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    1eaa:	cf 93       	push	r28
    1eac:	df 93       	push	r29
    1eae:	00 d0       	rcall	.+0      	; 0x1eb0 <prvCopyDataToQueue+0x6>
    1eb0:	1f 92       	push	r1
    1eb2:	1f 92       	push	r1
    1eb4:	cd b7       	in	r28, 0x3d	; 61
    1eb6:	de b7       	in	r29, 0x3e	; 62
    1eb8:	9a 83       	std	Y+2, r25	; 0x02
    1eba:	89 83       	std	Y+1, r24	; 0x01
    1ebc:	7c 83       	std	Y+4, r23	; 0x04
    1ebe:	6b 83       	std	Y+3, r22	; 0x03
    1ec0:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    1ec2:	89 81       	ldd	r24, Y+1	; 0x01
    1ec4:	9a 81       	ldd	r25, Y+2	; 0x02
    1ec6:	fc 01       	movw	r30, r24
    1ec8:	84 8d       	ldd	r24, Z+28	; 0x1c
    1eca:	88 23       	and	r24, r24
    1ecc:	a9 f4       	brne	.+42     	; 0x1ef8 <prvCopyDataToQueue+0x4e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1ece:	89 81       	ldd	r24, Y+1	; 0x01
    1ed0:	9a 81       	ldd	r25, Y+2	; 0x02
    1ed2:	fc 01       	movw	r30, r24
    1ed4:	80 81       	ld	r24, Z
    1ed6:	91 81       	ldd	r25, Z+1	; 0x01
    1ed8:	00 97       	sbiw	r24, 0x00	; 0
    1eda:	09 f0       	breq	.+2      	; 0x1ede <prvCopyDataToQueue+0x34>
    1edc:	92 c0       	rjmp	.+292    	; 0x2002 <prvCopyDataToQueue+0x158>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    1ede:	89 81       	ldd	r24, Y+1	; 0x01
    1ee0:	9a 81       	ldd	r25, Y+2	; 0x02
    1ee2:	fc 01       	movw	r30, r24
    1ee4:	82 81       	ldd	r24, Z+2	; 0x02
    1ee6:	93 81       	ldd	r25, Z+3	; 0x03
    1ee8:	0e 94 24 0b 	call	0x1648	; 0x1648 <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    1eec:	89 81       	ldd	r24, Y+1	; 0x01
    1eee:	9a 81       	ldd	r25, Y+2	; 0x02
    1ef0:	fc 01       	movw	r30, r24
    1ef2:	13 82       	std	Z+3, r1	; 0x03
    1ef4:	12 82       	std	Z+2, r1	; 0x02
    1ef6:	85 c0       	rjmp	.+266    	; 0x2002 <prvCopyDataToQueue+0x158>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    1ef8:	8d 81       	ldd	r24, Y+5	; 0x05
    1efa:	88 23       	and	r24, r24
    1efc:	d9 f5       	brne	.+118    	; 0x1f74 <prvCopyDataToQueue+0xca>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1efe:	89 81       	ldd	r24, Y+1	; 0x01
    1f00:	9a 81       	ldd	r25, Y+2	; 0x02
    1f02:	fc 01       	movw	r30, r24
    1f04:	84 8d       	ldd	r24, Z+28	; 0x1c
    1f06:	48 2f       	mov	r20, r24
    1f08:	50 e0       	ldi	r21, 0x00	; 0
    1f0a:	89 81       	ldd	r24, Y+1	; 0x01
    1f0c:	9a 81       	ldd	r25, Y+2	; 0x02
    1f0e:	fc 01       	movw	r30, r24
    1f10:	84 81       	ldd	r24, Z+4	; 0x04
    1f12:	95 81       	ldd	r25, Z+5	; 0x05
    1f14:	2b 81       	ldd	r18, Y+3	; 0x03
    1f16:	3c 81       	ldd	r19, Y+4	; 0x04
    1f18:	b9 01       	movw	r22, r18
    1f1a:	0e 94 a5 1d 	call	0x3b4a	; 0x3b4a <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1f1e:	89 81       	ldd	r24, Y+1	; 0x01
    1f20:	9a 81       	ldd	r25, Y+2	; 0x02
    1f22:	fc 01       	movw	r30, r24
    1f24:	24 81       	ldd	r18, Z+4	; 0x04
    1f26:	35 81       	ldd	r19, Z+5	; 0x05
    1f28:	89 81       	ldd	r24, Y+1	; 0x01
    1f2a:	9a 81       	ldd	r25, Y+2	; 0x02
    1f2c:	fc 01       	movw	r30, r24
    1f2e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1f30:	88 2f       	mov	r24, r24
    1f32:	90 e0       	ldi	r25, 0x00	; 0
    1f34:	28 0f       	add	r18, r24
    1f36:	39 1f       	adc	r19, r25
    1f38:	89 81       	ldd	r24, Y+1	; 0x01
    1f3a:	9a 81       	ldd	r25, Y+2	; 0x02
    1f3c:	fc 01       	movw	r30, r24
    1f3e:	35 83       	std	Z+5, r19	; 0x05
    1f40:	24 83       	std	Z+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    1f42:	89 81       	ldd	r24, Y+1	; 0x01
    1f44:	9a 81       	ldd	r25, Y+2	; 0x02
    1f46:	fc 01       	movw	r30, r24
    1f48:	24 81       	ldd	r18, Z+4	; 0x04
    1f4a:	35 81       	ldd	r19, Z+5	; 0x05
    1f4c:	89 81       	ldd	r24, Y+1	; 0x01
    1f4e:	9a 81       	ldd	r25, Y+2	; 0x02
    1f50:	fc 01       	movw	r30, r24
    1f52:	82 81       	ldd	r24, Z+2	; 0x02
    1f54:	93 81       	ldd	r25, Z+3	; 0x03
    1f56:	28 17       	cp	r18, r24
    1f58:	39 07       	cpc	r19, r25
    1f5a:	08 f4       	brcc	.+2      	; 0x1f5e <prvCopyDataToQueue+0xb4>
    1f5c:	52 c0       	rjmp	.+164    	; 0x2002 <prvCopyDataToQueue+0x158>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1f5e:	89 81       	ldd	r24, Y+1	; 0x01
    1f60:	9a 81       	ldd	r25, Y+2	; 0x02
    1f62:	fc 01       	movw	r30, r24
    1f64:	20 81       	ld	r18, Z
    1f66:	31 81       	ldd	r19, Z+1	; 0x01
    1f68:	89 81       	ldd	r24, Y+1	; 0x01
    1f6a:	9a 81       	ldd	r25, Y+2	; 0x02
    1f6c:	fc 01       	movw	r30, r24
    1f6e:	35 83       	std	Z+5, r19	; 0x05
    1f70:	24 83       	std	Z+4, r18	; 0x04
    1f72:	47 c0       	rjmp	.+142    	; 0x2002 <prvCopyDataToQueue+0x158>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1f74:	89 81       	ldd	r24, Y+1	; 0x01
    1f76:	9a 81       	ldd	r25, Y+2	; 0x02
    1f78:	fc 01       	movw	r30, r24
    1f7a:	84 8d       	ldd	r24, Z+28	; 0x1c
    1f7c:	48 2f       	mov	r20, r24
    1f7e:	50 e0       	ldi	r21, 0x00	; 0
    1f80:	89 81       	ldd	r24, Y+1	; 0x01
    1f82:	9a 81       	ldd	r25, Y+2	; 0x02
    1f84:	fc 01       	movw	r30, r24
    1f86:	86 81       	ldd	r24, Z+6	; 0x06
    1f88:	97 81       	ldd	r25, Z+7	; 0x07
    1f8a:	2b 81       	ldd	r18, Y+3	; 0x03
    1f8c:	3c 81       	ldd	r19, Y+4	; 0x04
    1f8e:	b9 01       	movw	r22, r18
    1f90:	0e 94 a5 1d 	call	0x3b4a	; 0x3b4a <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    1f94:	89 81       	ldd	r24, Y+1	; 0x01
    1f96:	9a 81       	ldd	r25, Y+2	; 0x02
    1f98:	fc 01       	movw	r30, r24
    1f9a:	26 81       	ldd	r18, Z+6	; 0x06
    1f9c:	37 81       	ldd	r19, Z+7	; 0x07
    1f9e:	89 81       	ldd	r24, Y+1	; 0x01
    1fa0:	9a 81       	ldd	r25, Y+2	; 0x02
    1fa2:	fc 01       	movw	r30, r24
    1fa4:	84 8d       	ldd	r24, Z+28	; 0x1c
    1fa6:	88 2f       	mov	r24, r24
    1fa8:	90 e0       	ldi	r25, 0x00	; 0
    1faa:	91 95       	neg	r25
    1fac:	81 95       	neg	r24
    1fae:	91 09       	sbc	r25, r1
    1fb0:	28 0f       	add	r18, r24
    1fb2:	39 1f       	adc	r19, r25
    1fb4:	89 81       	ldd	r24, Y+1	; 0x01
    1fb6:	9a 81       	ldd	r25, Y+2	; 0x02
    1fb8:	fc 01       	movw	r30, r24
    1fba:	37 83       	std	Z+7, r19	; 0x07
    1fbc:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    1fbe:	89 81       	ldd	r24, Y+1	; 0x01
    1fc0:	9a 81       	ldd	r25, Y+2	; 0x02
    1fc2:	fc 01       	movw	r30, r24
    1fc4:	26 81       	ldd	r18, Z+6	; 0x06
    1fc6:	37 81       	ldd	r19, Z+7	; 0x07
    1fc8:	89 81       	ldd	r24, Y+1	; 0x01
    1fca:	9a 81       	ldd	r25, Y+2	; 0x02
    1fcc:	fc 01       	movw	r30, r24
    1fce:	80 81       	ld	r24, Z
    1fd0:	91 81       	ldd	r25, Z+1	; 0x01
    1fd2:	28 17       	cp	r18, r24
    1fd4:	39 07       	cpc	r19, r25
    1fd6:	a8 f4       	brcc	.+42     	; 0x2002 <prvCopyDataToQueue+0x158>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1fd8:	89 81       	ldd	r24, Y+1	; 0x01
    1fda:	9a 81       	ldd	r25, Y+2	; 0x02
    1fdc:	fc 01       	movw	r30, r24
    1fde:	22 81       	ldd	r18, Z+2	; 0x02
    1fe0:	33 81       	ldd	r19, Z+3	; 0x03
    1fe2:	89 81       	ldd	r24, Y+1	; 0x01
    1fe4:	9a 81       	ldd	r25, Y+2	; 0x02
    1fe6:	fc 01       	movw	r30, r24
    1fe8:	84 8d       	ldd	r24, Z+28	; 0x1c
    1fea:	88 2f       	mov	r24, r24
    1fec:	90 e0       	ldi	r25, 0x00	; 0
    1fee:	91 95       	neg	r25
    1ff0:	81 95       	neg	r24
    1ff2:	91 09       	sbc	r25, r1
    1ff4:	28 0f       	add	r18, r24
    1ff6:	39 1f       	adc	r19, r25
    1ff8:	89 81       	ldd	r24, Y+1	; 0x01
    1ffa:	9a 81       	ldd	r25, Y+2	; 0x02
    1ffc:	fc 01       	movw	r30, r24
    1ffe:	37 83       	std	Z+7, r19	; 0x07
    2000:	26 83       	std	Z+6, r18	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    2002:	89 81       	ldd	r24, Y+1	; 0x01
    2004:	9a 81       	ldd	r25, Y+2	; 0x02
    2006:	fc 01       	movw	r30, r24
    2008:	82 8d       	ldd	r24, Z+26	; 0x1a
    200a:	21 e0       	ldi	r18, 0x01	; 1
    200c:	28 0f       	add	r18, r24
    200e:	89 81       	ldd	r24, Y+1	; 0x01
    2010:	9a 81       	ldd	r25, Y+2	; 0x02
    2012:	fc 01       	movw	r30, r24
    2014:	22 8f       	std	Z+26, r18	; 0x1a
}
    2016:	0f 90       	pop	r0
    2018:	0f 90       	pop	r0
    201a:	0f 90       	pop	r0
    201c:	0f 90       	pop	r0
    201e:	0f 90       	pop	r0
    2020:	df 91       	pop	r29
    2022:	cf 91       	pop	r28
    2024:	08 95       	ret

00002026 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    2026:	cf 93       	push	r28
    2028:	df 93       	push	r29
    202a:	00 d0       	rcall	.+0      	; 0x202c <prvCopyDataFromQueue+0x6>
    202c:	1f 92       	push	r1
    202e:	cd b7       	in	r28, 0x3d	; 61
    2030:	de b7       	in	r29, 0x3e	; 62
    2032:	9a 83       	std	Y+2, r25	; 0x02
    2034:	89 83       	std	Y+1, r24	; 0x01
    2036:	7c 83       	std	Y+4, r23	; 0x04
    2038:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    203a:	89 81       	ldd	r24, Y+1	; 0x01
    203c:	9a 81       	ldd	r25, Y+2	; 0x02
    203e:	fc 01       	movw	r30, r24
    2040:	80 81       	ld	r24, Z
    2042:	91 81       	ldd	r25, Z+1	; 0x01
    2044:	00 97       	sbiw	r24, 0x00	; 0
    2046:	c9 f1       	breq	.+114    	; 0x20ba <prvCopyDataFromQueue+0x94>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    2048:	89 81       	ldd	r24, Y+1	; 0x01
    204a:	9a 81       	ldd	r25, Y+2	; 0x02
    204c:	fc 01       	movw	r30, r24
    204e:	26 81       	ldd	r18, Z+6	; 0x06
    2050:	37 81       	ldd	r19, Z+7	; 0x07
    2052:	89 81       	ldd	r24, Y+1	; 0x01
    2054:	9a 81       	ldd	r25, Y+2	; 0x02
    2056:	fc 01       	movw	r30, r24
    2058:	84 8d       	ldd	r24, Z+28	; 0x1c
    205a:	88 2f       	mov	r24, r24
    205c:	90 e0       	ldi	r25, 0x00	; 0
    205e:	28 0f       	add	r18, r24
    2060:	39 1f       	adc	r19, r25
    2062:	89 81       	ldd	r24, Y+1	; 0x01
    2064:	9a 81       	ldd	r25, Y+2	; 0x02
    2066:	fc 01       	movw	r30, r24
    2068:	37 83       	std	Z+7, r19	; 0x07
    206a:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    206c:	89 81       	ldd	r24, Y+1	; 0x01
    206e:	9a 81       	ldd	r25, Y+2	; 0x02
    2070:	fc 01       	movw	r30, r24
    2072:	26 81       	ldd	r18, Z+6	; 0x06
    2074:	37 81       	ldd	r19, Z+7	; 0x07
    2076:	89 81       	ldd	r24, Y+1	; 0x01
    2078:	9a 81       	ldd	r25, Y+2	; 0x02
    207a:	fc 01       	movw	r30, r24
    207c:	82 81       	ldd	r24, Z+2	; 0x02
    207e:	93 81       	ldd	r25, Z+3	; 0x03
    2080:	28 17       	cp	r18, r24
    2082:	39 07       	cpc	r19, r25
    2084:	50 f0       	brcs	.+20     	; 0x209a <prvCopyDataFromQueue+0x74>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    2086:	89 81       	ldd	r24, Y+1	; 0x01
    2088:	9a 81       	ldd	r25, Y+2	; 0x02
    208a:	fc 01       	movw	r30, r24
    208c:	20 81       	ld	r18, Z
    208e:	31 81       	ldd	r19, Z+1	; 0x01
    2090:	89 81       	ldd	r24, Y+1	; 0x01
    2092:	9a 81       	ldd	r25, Y+2	; 0x02
    2094:	fc 01       	movw	r30, r24
    2096:	37 83       	std	Z+7, r19	; 0x07
    2098:	26 83       	std	Z+6, r18	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    209a:	89 81       	ldd	r24, Y+1	; 0x01
    209c:	9a 81       	ldd	r25, Y+2	; 0x02
    209e:	fc 01       	movw	r30, r24
    20a0:	84 8d       	ldd	r24, Z+28	; 0x1c
    20a2:	48 2f       	mov	r20, r24
    20a4:	50 e0       	ldi	r21, 0x00	; 0
    20a6:	89 81       	ldd	r24, Y+1	; 0x01
    20a8:	9a 81       	ldd	r25, Y+2	; 0x02
    20aa:	fc 01       	movw	r30, r24
    20ac:	26 81       	ldd	r18, Z+6	; 0x06
    20ae:	37 81       	ldd	r19, Z+7	; 0x07
    20b0:	8b 81       	ldd	r24, Y+3	; 0x03
    20b2:	9c 81       	ldd	r25, Y+4	; 0x04
    20b4:	b9 01       	movw	r22, r18
    20b6:	0e 94 a5 1d 	call	0x3b4a	; 0x3b4a <memcpy>
	}
}
    20ba:	0f 90       	pop	r0
    20bc:	0f 90       	pop	r0
    20be:	0f 90       	pop	r0
    20c0:	0f 90       	pop	r0
    20c2:	df 91       	pop	r29
    20c4:	cf 91       	pop	r28
    20c6:	08 95       	ret

000020c8 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    20c8:	cf 93       	push	r28
    20ca:	df 93       	push	r29
    20cc:	1f 92       	push	r1
    20ce:	1f 92       	push	r1
    20d0:	cd b7       	in	r28, 0x3d	; 61
    20d2:	de b7       	in	r29, 0x3e	; 62
    20d4:	9a 83       	std	Y+2, r25	; 0x02
    20d6:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    20d8:	0f b6       	in	r0, 0x3f	; 63
    20da:	f8 94       	cli
    20dc:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    20de:	1b c0       	rjmp	.+54     	; 0x2116 <prvUnlockQueue+0x4e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    20e0:	89 81       	ldd	r24, Y+1	; 0x01
    20e2:	9a 81       	ldd	r25, Y+2	; 0x02
    20e4:	fc 01       	movw	r30, r24
    20e6:	81 89       	ldd	r24, Z+17	; 0x11
    20e8:	88 23       	and	r24, r24
    20ea:	a1 f0       	breq	.+40     	; 0x2114 <prvUnlockQueue+0x4c>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    20ec:	89 81       	ldd	r24, Y+1	; 0x01
    20ee:	9a 81       	ldd	r25, Y+2	; 0x02
    20f0:	41 96       	adiw	r24, 0x11	; 17
    20f2:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <xTaskRemoveFromEventList>
    20f6:	88 23       	and	r24, r24
    20f8:	11 f0       	breq	.+4      	; 0x20fe <prvUnlockQueue+0x36>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    20fa:	0e 94 d9 08 	call	0x11b2	; 0x11b2 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    20fe:	89 81       	ldd	r24, Y+1	; 0x01
    2100:	9a 81       	ldd	r25, Y+2	; 0x02
    2102:	fc 01       	movw	r30, r24
    2104:	86 8d       	ldd	r24, Z+30	; 0x1e
    2106:	2f ef       	ldi	r18, 0xFF	; 255
    2108:	28 0f       	add	r18, r24
    210a:	89 81       	ldd	r24, Y+1	; 0x01
    210c:	9a 81       	ldd	r25, Y+2	; 0x02
    210e:	fc 01       	movw	r30, r24
    2110:	26 8f       	std	Z+30, r18	; 0x1e
    2112:	01 c0       	rjmp	.+2      	; 0x2116 <prvUnlockQueue+0x4e>
			}
			else
			{
				break;
    2114:	06 c0       	rjmp	.+12     	; 0x2122 <prvUnlockQueue+0x5a>
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2116:	89 81       	ldd	r24, Y+1	; 0x01
    2118:	9a 81       	ldd	r25, Y+2	; 0x02
    211a:	fc 01       	movw	r30, r24
    211c:	86 8d       	ldd	r24, Z+30	; 0x1e
    211e:	18 16       	cp	r1, r24
    2120:	fc f2       	brlt	.-66     	; 0x20e0 <prvUnlockQueue+0x18>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    2122:	89 81       	ldd	r24, Y+1	; 0x01
    2124:	9a 81       	ldd	r25, Y+2	; 0x02
    2126:	2f ef       	ldi	r18, 0xFF	; 255
    2128:	fc 01       	movw	r30, r24
    212a:	26 8f       	std	Z+30, r18	; 0x1e
	}
	taskEXIT_CRITICAL();
    212c:	0f 90       	pop	r0
    212e:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2130:	0f b6       	in	r0, 0x3f	; 63
    2132:	f8 94       	cli
    2134:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2136:	1b c0       	rjmp	.+54     	; 0x216e <prvUnlockQueue+0xa6>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2138:	89 81       	ldd	r24, Y+1	; 0x01
    213a:	9a 81       	ldd	r25, Y+2	; 0x02
    213c:	fc 01       	movw	r30, r24
    213e:	80 85       	ldd	r24, Z+8	; 0x08
    2140:	88 23       	and	r24, r24
    2142:	a1 f0       	breq	.+40     	; 0x216c <prvUnlockQueue+0xa4>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2144:	89 81       	ldd	r24, Y+1	; 0x01
    2146:	9a 81       	ldd	r25, Y+2	; 0x02
    2148:	08 96       	adiw	r24, 0x08	; 8
    214a:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <xTaskRemoveFromEventList>
    214e:	88 23       	and	r24, r24
    2150:	11 f0       	breq	.+4      	; 0x2156 <prvUnlockQueue+0x8e>
				{
					vTaskMissedYield();
    2152:	0e 94 d9 08 	call	0x11b2	; 0x11b2 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    2156:	89 81       	ldd	r24, Y+1	; 0x01
    2158:	9a 81       	ldd	r25, Y+2	; 0x02
    215a:	fc 01       	movw	r30, r24
    215c:	85 8d       	ldd	r24, Z+29	; 0x1d
    215e:	2f ef       	ldi	r18, 0xFF	; 255
    2160:	28 0f       	add	r18, r24
    2162:	89 81       	ldd	r24, Y+1	; 0x01
    2164:	9a 81       	ldd	r25, Y+2	; 0x02
    2166:	fc 01       	movw	r30, r24
    2168:	25 8f       	std	Z+29, r18	; 0x1d
    216a:	01 c0       	rjmp	.+2      	; 0x216e <prvUnlockQueue+0xa6>
			}
			else
			{
				break;
    216c:	06 c0       	rjmp	.+12     	; 0x217a <prvUnlockQueue+0xb2>
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    216e:	89 81       	ldd	r24, Y+1	; 0x01
    2170:	9a 81       	ldd	r25, Y+2	; 0x02
    2172:	fc 01       	movw	r30, r24
    2174:	85 8d       	ldd	r24, Z+29	; 0x1d
    2176:	18 16       	cp	r1, r24
    2178:	fc f2       	brlt	.-66     	; 0x2138 <prvUnlockQueue+0x70>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    217a:	89 81       	ldd	r24, Y+1	; 0x01
    217c:	9a 81       	ldd	r25, Y+2	; 0x02
    217e:	2f ef       	ldi	r18, 0xFF	; 255
    2180:	fc 01       	movw	r30, r24
    2182:	25 8f       	std	Z+29, r18	; 0x1d
	}
	taskEXIT_CRITICAL();
    2184:	0f 90       	pop	r0
    2186:	0f be       	out	0x3f, r0	; 63
}
    2188:	0f 90       	pop	r0
    218a:	0f 90       	pop	r0
    218c:	df 91       	pop	r29
    218e:	cf 91       	pop	r28
    2190:	08 95       	ret

00002192 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    2192:	cf 93       	push	r28
    2194:	df 93       	push	r29
    2196:	00 d0       	rcall	.+0      	; 0x2198 <prvIsQueueEmpty+0x6>
    2198:	cd b7       	in	r28, 0x3d	; 61
    219a:	de b7       	in	r29, 0x3e	; 62
    219c:	9b 83       	std	Y+3, r25	; 0x03
    219e:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    21a0:	0f b6       	in	r0, 0x3f	; 63
    21a2:	f8 94       	cli
    21a4:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    21a6:	8a 81       	ldd	r24, Y+2	; 0x02
    21a8:	9b 81       	ldd	r25, Y+3	; 0x03
    21aa:	fc 01       	movw	r30, r24
    21ac:	92 8d       	ldd	r25, Z+26	; 0x1a
    21ae:	81 e0       	ldi	r24, 0x01	; 1
    21b0:	99 23       	and	r25, r25
    21b2:	09 f0       	breq	.+2      	; 0x21b6 <prvIsQueueEmpty+0x24>
    21b4:	80 e0       	ldi	r24, 0x00	; 0
    21b6:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    21b8:	0f 90       	pop	r0
    21ba:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    21bc:	89 81       	ldd	r24, Y+1	; 0x01
}
    21be:	0f 90       	pop	r0
    21c0:	0f 90       	pop	r0
    21c2:	0f 90       	pop	r0
    21c4:	df 91       	pop	r29
    21c6:	cf 91       	pop	r28
    21c8:	08 95       	ret

000021ca <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    21ca:	cf 93       	push	r28
    21cc:	df 93       	push	r29
    21ce:	00 d0       	rcall	.+0      	; 0x21d0 <xQueueIsQueueEmptyFromISR+0x6>
    21d0:	cd b7       	in	r28, 0x3d	; 61
    21d2:	de b7       	in	r29, 0x3e	; 62
    21d4:	9b 83       	std	Y+3, r25	; 0x03
    21d6:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    21d8:	8a 81       	ldd	r24, Y+2	; 0x02
    21da:	9b 81       	ldd	r25, Y+3	; 0x03
    21dc:	fc 01       	movw	r30, r24
    21de:	92 8d       	ldd	r25, Z+26	; 0x1a
    21e0:	81 e0       	ldi	r24, 0x01	; 1
    21e2:	99 23       	and	r25, r25
    21e4:	09 f0       	breq	.+2      	; 0x21e8 <xQueueIsQueueEmptyFromISR+0x1e>
    21e6:	80 e0       	ldi	r24, 0x00	; 0
    21e8:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    21ea:	89 81       	ldd	r24, Y+1	; 0x01
}
    21ec:	0f 90       	pop	r0
    21ee:	0f 90       	pop	r0
    21f0:	0f 90       	pop	r0
    21f2:	df 91       	pop	r29
    21f4:	cf 91       	pop	r28
    21f6:	08 95       	ret

000021f8 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    21f8:	cf 93       	push	r28
    21fa:	df 93       	push	r29
    21fc:	00 d0       	rcall	.+0      	; 0x21fe <prvIsQueueFull+0x6>
    21fe:	cd b7       	in	r28, 0x3d	; 61
    2200:	de b7       	in	r29, 0x3e	; 62
    2202:	9b 83       	std	Y+3, r25	; 0x03
    2204:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    2206:	0f b6       	in	r0, 0x3f	; 63
    2208:	f8 94       	cli
    220a:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    220c:	8a 81       	ldd	r24, Y+2	; 0x02
    220e:	9b 81       	ldd	r25, Y+3	; 0x03
    2210:	fc 01       	movw	r30, r24
    2212:	22 8d       	ldd	r18, Z+26	; 0x1a
    2214:	8a 81       	ldd	r24, Y+2	; 0x02
    2216:	9b 81       	ldd	r25, Y+3	; 0x03
    2218:	fc 01       	movw	r30, r24
    221a:	93 8d       	ldd	r25, Z+27	; 0x1b
    221c:	81 e0       	ldi	r24, 0x01	; 1
    221e:	29 17       	cp	r18, r25
    2220:	09 f0       	breq	.+2      	; 0x2224 <__stack+0x25>
    2222:	80 e0       	ldi	r24, 0x00	; 0
    2224:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    2226:	0f 90       	pop	r0
    2228:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    222a:	89 81       	ldd	r24, Y+1	; 0x01
}
    222c:	0f 90       	pop	r0
    222e:	0f 90       	pop	r0
    2230:	0f 90       	pop	r0
    2232:	df 91       	pop	r29
    2234:	cf 91       	pop	r28
    2236:	08 95       	ret

00002238 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    2238:	cf 93       	push	r28
    223a:	df 93       	push	r29
    223c:	00 d0       	rcall	.+0      	; 0x223e <xQueueIsQueueFullFromISR+0x6>
    223e:	cd b7       	in	r28, 0x3d	; 61
    2240:	de b7       	in	r29, 0x3e	; 62
    2242:	9b 83       	std	Y+3, r25	; 0x03
    2244:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    2246:	8a 81       	ldd	r24, Y+2	; 0x02
    2248:	9b 81       	ldd	r25, Y+3	; 0x03
    224a:	fc 01       	movw	r30, r24
    224c:	22 8d       	ldd	r18, Z+26	; 0x1a
    224e:	8a 81       	ldd	r24, Y+2	; 0x02
    2250:	9b 81       	ldd	r25, Y+3	; 0x03
    2252:	fc 01       	movw	r30, r24
    2254:	93 8d       	ldd	r25, Z+27	; 0x1b
    2256:	81 e0       	ldi	r24, 0x01	; 1
    2258:	29 17       	cp	r18, r25
    225a:	09 f0       	breq	.+2      	; 0x225e <xQueueIsQueueFullFromISR+0x26>
    225c:	80 e0       	ldi	r24, 0x00	; 0
    225e:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    2260:	89 81       	ldd	r24, Y+1	; 0x01
}
    2262:	0f 90       	pop	r0
    2264:	0f 90       	pop	r0
    2266:	0f 90       	pop	r0
    2268:	df 91       	pop	r29
    226a:	cf 91       	pop	r28
    226c:	08 95       	ret

0000226e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    226e:	cf 93       	push	r28
    2270:	df 93       	push	r29
    2272:	1f 92       	push	r1
    2274:	1f 92       	push	r1
    2276:	cd b7       	in	r28, 0x3d	; 61
    2278:	de b7       	in	r29, 0x3e	; 62
    227a:	9a 83       	std	Y+2, r25	; 0x02
    227c:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    227e:	89 81       	ldd	r24, Y+1	; 0x01
    2280:	9a 81       	ldd	r25, Y+2	; 0x02
    2282:	9c 01       	movw	r18, r24
    2284:	2d 5f       	subi	r18, 0xFD	; 253
    2286:	3f 4f       	sbci	r19, 0xFF	; 255
    2288:	89 81       	ldd	r24, Y+1	; 0x01
    228a:	9a 81       	ldd	r25, Y+2	; 0x02
    228c:	fc 01       	movw	r30, r24
    228e:	32 83       	std	Z+2, r19	; 0x02
    2290:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2292:	89 81       	ldd	r24, Y+1	; 0x01
    2294:	9a 81       	ldd	r25, Y+2	; 0x02
    2296:	2f ef       	ldi	r18, 0xFF	; 255
    2298:	3f ef       	ldi	r19, 0xFF	; 255
    229a:	fc 01       	movw	r30, r24
    229c:	34 83       	std	Z+4, r19	; 0x04
    229e:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    22a0:	89 81       	ldd	r24, Y+1	; 0x01
    22a2:	9a 81       	ldd	r25, Y+2	; 0x02
    22a4:	9c 01       	movw	r18, r24
    22a6:	2d 5f       	subi	r18, 0xFD	; 253
    22a8:	3f 4f       	sbci	r19, 0xFF	; 255
    22aa:	89 81       	ldd	r24, Y+1	; 0x01
    22ac:	9a 81       	ldd	r25, Y+2	; 0x02
    22ae:	fc 01       	movw	r30, r24
    22b0:	36 83       	std	Z+6, r19	; 0x06
    22b2:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    22b4:	89 81       	ldd	r24, Y+1	; 0x01
    22b6:	9a 81       	ldd	r25, Y+2	; 0x02
    22b8:	9c 01       	movw	r18, r24
    22ba:	2d 5f       	subi	r18, 0xFD	; 253
    22bc:	3f 4f       	sbci	r19, 0xFF	; 255
    22be:	89 81       	ldd	r24, Y+1	; 0x01
    22c0:	9a 81       	ldd	r25, Y+2	; 0x02
    22c2:	fc 01       	movw	r30, r24
    22c4:	30 87       	std	Z+8, r19	; 0x08
    22c6:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    22c8:	89 81       	ldd	r24, Y+1	; 0x01
    22ca:	9a 81       	ldd	r25, Y+2	; 0x02
    22cc:	fc 01       	movw	r30, r24
    22ce:	10 82       	st	Z, r1
}
    22d0:	0f 90       	pop	r0
    22d2:	0f 90       	pop	r0
    22d4:	df 91       	pop	r29
    22d6:	cf 91       	pop	r28
    22d8:	08 95       	ret

000022da <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    22da:	cf 93       	push	r28
    22dc:	df 93       	push	r29
    22de:	1f 92       	push	r1
    22e0:	1f 92       	push	r1
    22e2:	cd b7       	in	r28, 0x3d	; 61
    22e4:	de b7       	in	r29, 0x3e	; 62
    22e6:	9a 83       	std	Y+2, r25	; 0x02
    22e8:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    22ea:	89 81       	ldd	r24, Y+1	; 0x01
    22ec:	9a 81       	ldd	r25, Y+2	; 0x02
    22ee:	fc 01       	movw	r30, r24
    22f0:	11 86       	std	Z+9, r1	; 0x09
    22f2:	10 86       	std	Z+8, r1	; 0x08
}
    22f4:	0f 90       	pop	r0
    22f6:	0f 90       	pop	r0
    22f8:	df 91       	pop	r29
    22fa:	cf 91       	pop	r28
    22fc:	08 95       	ret

000022fe <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    22fe:	cf 93       	push	r28
    2300:	df 93       	push	r29
    2302:	00 d0       	rcall	.+0      	; 0x2304 <vListInsertEnd+0x6>
    2304:	00 d0       	rcall	.+0      	; 0x2306 <vListInsertEnd+0x8>
    2306:	cd b7       	in	r28, 0x3d	; 61
    2308:	de b7       	in	r29, 0x3e	; 62
    230a:	9c 83       	std	Y+4, r25	; 0x04
    230c:	8b 83       	std	Y+3, r24	; 0x03
    230e:	7e 83       	std	Y+6, r23	; 0x06
    2310:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    2312:	8b 81       	ldd	r24, Y+3	; 0x03
    2314:	9c 81       	ldd	r25, Y+4	; 0x04
    2316:	fc 01       	movw	r30, r24
    2318:	81 81       	ldd	r24, Z+1	; 0x01
    231a:	92 81       	ldd	r25, Z+2	; 0x02
    231c:	9a 83       	std	Y+2, r25	; 0x02
    231e:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    2320:	89 81       	ldd	r24, Y+1	; 0x01
    2322:	9a 81       	ldd	r25, Y+2	; 0x02
    2324:	fc 01       	movw	r30, r24
    2326:	22 81       	ldd	r18, Z+2	; 0x02
    2328:	33 81       	ldd	r19, Z+3	; 0x03
    232a:	8d 81       	ldd	r24, Y+5	; 0x05
    232c:	9e 81       	ldd	r25, Y+6	; 0x06
    232e:	fc 01       	movw	r30, r24
    2330:	33 83       	std	Z+3, r19	; 0x03
    2332:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    2334:	8b 81       	ldd	r24, Y+3	; 0x03
    2336:	9c 81       	ldd	r25, Y+4	; 0x04
    2338:	fc 01       	movw	r30, r24
    233a:	21 81       	ldd	r18, Z+1	; 0x01
    233c:	32 81       	ldd	r19, Z+2	; 0x02
    233e:	8d 81       	ldd	r24, Y+5	; 0x05
    2340:	9e 81       	ldd	r25, Y+6	; 0x06
    2342:	fc 01       	movw	r30, r24
    2344:	35 83       	std	Z+5, r19	; 0x05
    2346:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2348:	89 81       	ldd	r24, Y+1	; 0x01
    234a:	9a 81       	ldd	r25, Y+2	; 0x02
    234c:	fc 01       	movw	r30, r24
    234e:	82 81       	ldd	r24, Z+2	; 0x02
    2350:	93 81       	ldd	r25, Z+3	; 0x03
    2352:	2d 81       	ldd	r18, Y+5	; 0x05
    2354:	3e 81       	ldd	r19, Y+6	; 0x06
    2356:	fc 01       	movw	r30, r24
    2358:	35 83       	std	Z+5, r19	; 0x05
    235a:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    235c:	89 81       	ldd	r24, Y+1	; 0x01
    235e:	9a 81       	ldd	r25, Y+2	; 0x02
    2360:	2d 81       	ldd	r18, Y+5	; 0x05
    2362:	3e 81       	ldd	r19, Y+6	; 0x06
    2364:	fc 01       	movw	r30, r24
    2366:	33 83       	std	Z+3, r19	; 0x03
    2368:	22 83       	std	Z+2, r18	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    236a:	8b 81       	ldd	r24, Y+3	; 0x03
    236c:	9c 81       	ldd	r25, Y+4	; 0x04
    236e:	2d 81       	ldd	r18, Y+5	; 0x05
    2370:	3e 81       	ldd	r19, Y+6	; 0x06
    2372:	fc 01       	movw	r30, r24
    2374:	32 83       	std	Z+2, r19	; 0x02
    2376:	21 83       	std	Z+1, r18	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2378:	8d 81       	ldd	r24, Y+5	; 0x05
    237a:	9e 81       	ldd	r25, Y+6	; 0x06
    237c:	2b 81       	ldd	r18, Y+3	; 0x03
    237e:	3c 81       	ldd	r19, Y+4	; 0x04
    2380:	fc 01       	movw	r30, r24
    2382:	31 87       	std	Z+9, r19	; 0x09
    2384:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    2386:	8b 81       	ldd	r24, Y+3	; 0x03
    2388:	9c 81       	ldd	r25, Y+4	; 0x04
    238a:	fc 01       	movw	r30, r24
    238c:	80 81       	ld	r24, Z
    238e:	21 e0       	ldi	r18, 0x01	; 1
    2390:	28 0f       	add	r18, r24
    2392:	8b 81       	ldd	r24, Y+3	; 0x03
    2394:	9c 81       	ldd	r25, Y+4	; 0x04
    2396:	fc 01       	movw	r30, r24
    2398:	20 83       	st	Z, r18
}
    239a:	26 96       	adiw	r28, 0x06	; 6
    239c:	0f b6       	in	r0, 0x3f	; 63
    239e:	f8 94       	cli
    23a0:	de bf       	out	0x3e, r29	; 62
    23a2:	0f be       	out	0x3f, r0	; 63
    23a4:	cd bf       	out	0x3d, r28	; 61
    23a6:	df 91       	pop	r29
    23a8:	cf 91       	pop	r28
    23aa:	08 95       	ret

000023ac <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    23ac:	cf 93       	push	r28
    23ae:	df 93       	push	r29
    23b0:	cd b7       	in	r28, 0x3d	; 61
    23b2:	de b7       	in	r29, 0x3e	; 62
    23b4:	28 97       	sbiw	r28, 0x08	; 8
    23b6:	0f b6       	in	r0, 0x3f	; 63
    23b8:	f8 94       	cli
    23ba:	de bf       	out	0x3e, r29	; 62
    23bc:	0f be       	out	0x3f, r0	; 63
    23be:	cd bf       	out	0x3d, r28	; 61
    23c0:	9e 83       	std	Y+6, r25	; 0x06
    23c2:	8d 83       	std	Y+5, r24	; 0x05
    23c4:	78 87       	std	Y+8, r23	; 0x08
    23c6:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    23c8:	8f 81       	ldd	r24, Y+7	; 0x07
    23ca:	98 85       	ldd	r25, Y+8	; 0x08
    23cc:	fc 01       	movw	r30, r24
    23ce:	80 81       	ld	r24, Z
    23d0:	91 81       	ldd	r25, Z+1	; 0x01
    23d2:	9c 83       	std	Y+4, r25	; 0x04
    23d4:	8b 83       	std	Y+3, r24	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    23d6:	8b 81       	ldd	r24, Y+3	; 0x03
    23d8:	9c 81       	ldd	r25, Y+4	; 0x04
    23da:	8f 3f       	cpi	r24, 0xFF	; 255
    23dc:	ff ef       	ldi	r31, 0xFF	; 255
    23de:	9f 07       	cpc	r25, r31
    23e0:	41 f4       	brne	.+16     	; 0x23f2 <vListInsert+0x46>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    23e2:	8d 81       	ldd	r24, Y+5	; 0x05
    23e4:	9e 81       	ldd	r25, Y+6	; 0x06
    23e6:	fc 01       	movw	r30, r24
    23e8:	87 81       	ldd	r24, Z+7	; 0x07
    23ea:	90 85       	ldd	r25, Z+8	; 0x08
    23ec:	9a 83       	std	Y+2, r25	; 0x02
    23ee:	89 83       	std	Y+1, r24	; 0x01
    23f0:	1a c0       	rjmp	.+52     	; 0x2426 <vListInsert+0x7a>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    23f2:	8d 81       	ldd	r24, Y+5	; 0x05
    23f4:	9e 81       	ldd	r25, Y+6	; 0x06
    23f6:	03 96       	adiw	r24, 0x03	; 3
    23f8:	9a 83       	std	Y+2, r25	; 0x02
    23fa:	89 83       	std	Y+1, r24	; 0x01
    23fc:	07 c0       	rjmp	.+14     	; 0x240c <vListInsert+0x60>
    23fe:	89 81       	ldd	r24, Y+1	; 0x01
    2400:	9a 81       	ldd	r25, Y+2	; 0x02
    2402:	fc 01       	movw	r30, r24
    2404:	82 81       	ldd	r24, Z+2	; 0x02
    2406:	93 81       	ldd	r25, Z+3	; 0x03
    2408:	9a 83       	std	Y+2, r25	; 0x02
    240a:	89 83       	std	Y+1, r24	; 0x01
    240c:	89 81       	ldd	r24, Y+1	; 0x01
    240e:	9a 81       	ldd	r25, Y+2	; 0x02
    2410:	fc 01       	movw	r30, r24
    2412:	82 81       	ldd	r24, Z+2	; 0x02
    2414:	93 81       	ldd	r25, Z+3	; 0x03
    2416:	fc 01       	movw	r30, r24
    2418:	20 81       	ld	r18, Z
    241a:	31 81       	ldd	r19, Z+1	; 0x01
    241c:	8b 81       	ldd	r24, Y+3	; 0x03
    241e:	9c 81       	ldd	r25, Y+4	; 0x04
    2420:	82 17       	cp	r24, r18
    2422:	93 07       	cpc	r25, r19
    2424:	60 f7       	brcc	.-40     	; 0x23fe <vListInsert+0x52>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2426:	89 81       	ldd	r24, Y+1	; 0x01
    2428:	9a 81       	ldd	r25, Y+2	; 0x02
    242a:	fc 01       	movw	r30, r24
    242c:	22 81       	ldd	r18, Z+2	; 0x02
    242e:	33 81       	ldd	r19, Z+3	; 0x03
    2430:	8f 81       	ldd	r24, Y+7	; 0x07
    2432:	98 85       	ldd	r25, Y+8	; 0x08
    2434:	fc 01       	movw	r30, r24
    2436:	33 83       	std	Z+3, r19	; 0x03
    2438:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    243a:	8f 81       	ldd	r24, Y+7	; 0x07
    243c:	98 85       	ldd	r25, Y+8	; 0x08
    243e:	fc 01       	movw	r30, r24
    2440:	82 81       	ldd	r24, Z+2	; 0x02
    2442:	93 81       	ldd	r25, Z+3	; 0x03
    2444:	2f 81       	ldd	r18, Y+7	; 0x07
    2446:	38 85       	ldd	r19, Y+8	; 0x08
    2448:	fc 01       	movw	r30, r24
    244a:	35 83       	std	Z+5, r19	; 0x05
    244c:	24 83       	std	Z+4, r18	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    244e:	8f 81       	ldd	r24, Y+7	; 0x07
    2450:	98 85       	ldd	r25, Y+8	; 0x08
    2452:	29 81       	ldd	r18, Y+1	; 0x01
    2454:	3a 81       	ldd	r19, Y+2	; 0x02
    2456:	fc 01       	movw	r30, r24
    2458:	35 83       	std	Z+5, r19	; 0x05
    245a:	24 83       	std	Z+4, r18	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    245c:	89 81       	ldd	r24, Y+1	; 0x01
    245e:	9a 81       	ldd	r25, Y+2	; 0x02
    2460:	2f 81       	ldd	r18, Y+7	; 0x07
    2462:	38 85       	ldd	r19, Y+8	; 0x08
    2464:	fc 01       	movw	r30, r24
    2466:	33 83       	std	Z+3, r19	; 0x03
    2468:	22 83       	std	Z+2, r18	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    246a:	8f 81       	ldd	r24, Y+7	; 0x07
    246c:	98 85       	ldd	r25, Y+8	; 0x08
    246e:	2d 81       	ldd	r18, Y+5	; 0x05
    2470:	3e 81       	ldd	r19, Y+6	; 0x06
    2472:	fc 01       	movw	r30, r24
    2474:	31 87       	std	Z+9, r19	; 0x09
    2476:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    2478:	8d 81       	ldd	r24, Y+5	; 0x05
    247a:	9e 81       	ldd	r25, Y+6	; 0x06
    247c:	fc 01       	movw	r30, r24
    247e:	80 81       	ld	r24, Z
    2480:	21 e0       	ldi	r18, 0x01	; 1
    2482:	28 0f       	add	r18, r24
    2484:	8d 81       	ldd	r24, Y+5	; 0x05
    2486:	9e 81       	ldd	r25, Y+6	; 0x06
    2488:	fc 01       	movw	r30, r24
    248a:	20 83       	st	Z, r18
}
    248c:	28 96       	adiw	r28, 0x08	; 8
    248e:	0f b6       	in	r0, 0x3f	; 63
    2490:	f8 94       	cli
    2492:	de bf       	out	0x3e, r29	; 62
    2494:	0f be       	out	0x3f, r0	; 63
    2496:	cd bf       	out	0x3d, r28	; 61
    2498:	df 91       	pop	r29
    249a:	cf 91       	pop	r28
    249c:	08 95       	ret

0000249e <uxListRemove>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
{
    249e:	cf 93       	push	r28
    24a0:	df 93       	push	r29
    24a2:	00 d0       	rcall	.+0      	; 0x24a4 <uxListRemove+0x6>
    24a4:	1f 92       	push	r1
    24a6:	cd b7       	in	r28, 0x3d	; 61
    24a8:	de b7       	in	r29, 0x3e	; 62
    24aa:	9c 83       	std	Y+4, r25	; 0x04
    24ac:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    24ae:	8b 81       	ldd	r24, Y+3	; 0x03
    24b0:	9c 81       	ldd	r25, Y+4	; 0x04
    24b2:	fc 01       	movw	r30, r24
    24b4:	82 81       	ldd	r24, Z+2	; 0x02
    24b6:	93 81       	ldd	r25, Z+3	; 0x03
    24b8:	2b 81       	ldd	r18, Y+3	; 0x03
    24ba:	3c 81       	ldd	r19, Y+4	; 0x04
    24bc:	f9 01       	movw	r30, r18
    24be:	24 81       	ldd	r18, Z+4	; 0x04
    24c0:	35 81       	ldd	r19, Z+5	; 0x05
    24c2:	fc 01       	movw	r30, r24
    24c4:	35 83       	std	Z+5, r19	; 0x05
    24c6:	24 83       	std	Z+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    24c8:	8b 81       	ldd	r24, Y+3	; 0x03
    24ca:	9c 81       	ldd	r25, Y+4	; 0x04
    24cc:	fc 01       	movw	r30, r24
    24ce:	84 81       	ldd	r24, Z+4	; 0x04
    24d0:	95 81       	ldd	r25, Z+5	; 0x05
    24d2:	2b 81       	ldd	r18, Y+3	; 0x03
    24d4:	3c 81       	ldd	r19, Y+4	; 0x04
    24d6:	f9 01       	movw	r30, r18
    24d8:	22 81       	ldd	r18, Z+2	; 0x02
    24da:	33 81       	ldd	r19, Z+3	; 0x03
    24dc:	fc 01       	movw	r30, r24
    24de:	33 83       	std	Z+3, r19	; 0x03
    24e0:	22 83       	std	Z+2, r18	; 0x02

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    24e2:	8b 81       	ldd	r24, Y+3	; 0x03
    24e4:	9c 81       	ldd	r25, Y+4	; 0x04
    24e6:	fc 01       	movw	r30, r24
    24e8:	80 85       	ldd	r24, Z+8	; 0x08
    24ea:	91 85       	ldd	r25, Z+9	; 0x09
    24ec:	9a 83       	std	Y+2, r25	; 0x02
    24ee:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    24f0:	89 81       	ldd	r24, Y+1	; 0x01
    24f2:	9a 81       	ldd	r25, Y+2	; 0x02
    24f4:	fc 01       	movw	r30, r24
    24f6:	21 81       	ldd	r18, Z+1	; 0x01
    24f8:	32 81       	ldd	r19, Z+2	; 0x02
    24fa:	8b 81       	ldd	r24, Y+3	; 0x03
    24fc:	9c 81       	ldd	r25, Y+4	; 0x04
    24fe:	28 17       	cp	r18, r24
    2500:	39 07       	cpc	r19, r25
    2502:	51 f4       	brne	.+20     	; 0x2518 <uxListRemove+0x7a>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2504:	8b 81       	ldd	r24, Y+3	; 0x03
    2506:	9c 81       	ldd	r25, Y+4	; 0x04
    2508:	fc 01       	movw	r30, r24
    250a:	24 81       	ldd	r18, Z+4	; 0x04
    250c:	35 81       	ldd	r19, Z+5	; 0x05
    250e:	89 81       	ldd	r24, Y+1	; 0x01
    2510:	9a 81       	ldd	r25, Y+2	; 0x02
    2512:	fc 01       	movw	r30, r24
    2514:	32 83       	std	Z+2, r19	; 0x02
    2516:	21 83       	std	Z+1, r18	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    2518:	8b 81       	ldd	r24, Y+3	; 0x03
    251a:	9c 81       	ldd	r25, Y+4	; 0x04
    251c:	fc 01       	movw	r30, r24
    251e:	11 86       	std	Z+9, r1	; 0x09
    2520:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    2522:	89 81       	ldd	r24, Y+1	; 0x01
    2524:	9a 81       	ldd	r25, Y+2	; 0x02
    2526:	fc 01       	movw	r30, r24
    2528:	80 81       	ld	r24, Z
    252a:	2f ef       	ldi	r18, 0xFF	; 255
    252c:	28 0f       	add	r18, r24
    252e:	89 81       	ldd	r24, Y+1	; 0x01
    2530:	9a 81       	ldd	r25, Y+2	; 0x02
    2532:	fc 01       	movw	r30, r24
    2534:	20 83       	st	Z, r18

	return pxList->uxNumberOfItems;
    2536:	89 81       	ldd	r24, Y+1	; 0x01
    2538:	9a 81       	ldd	r25, Y+2	; 0x02
    253a:	fc 01       	movw	r30, r24
    253c:	80 81       	ld	r24, Z
}
    253e:	0f 90       	pop	r0
    2540:	0f 90       	pop	r0
    2542:	0f 90       	pop	r0
    2544:	0f 90       	pop	r0
    2546:	df 91       	pop	r29
    2548:	cf 91       	pop	r28
    254a:	08 95       	ret

0000254c <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    254c:	cf 93       	push	r28
    254e:	df 93       	push	r29
    2550:	cd b7       	in	r28, 0x3d	; 61
    2552:	de b7       	in	r29, 0x3e	; 62
    2554:	27 97       	sbiw	r28, 0x07	; 7
    2556:	0f b6       	in	r0, 0x3f	; 63
    2558:	f8 94       	cli
    255a:	de bf       	out	0x3e, r29	; 62
    255c:	0f be       	out	0x3f, r0	; 63
    255e:	cd bf       	out	0x3d, r28	; 61
    2560:	9d 83       	std	Y+5, r25	; 0x05
    2562:	8c 83       	std	Y+4, r24	; 0x04
    2564:	6e 83       	std	Y+6, r22	; 0x06
    2566:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    2568:	8a e1       	ldi	r24, 0x1A	; 26
    256a:	90 e0       	ldi	r25, 0x00	; 0
    256c:	0e 94 9e 15 	call	0x2b3c	; 0x2b3c <pvPortMalloc>
    2570:	9b 83       	std	Y+3, r25	; 0x03
    2572:	8a 83       	std	Y+2, r24	; 0x02
	if( pxCoRoutine )
    2574:	8a 81       	ldd	r24, Y+2	; 0x02
    2576:	9b 81       	ldd	r25, Y+3	; 0x03
    2578:	00 97       	sbiw	r24, 0x00	; 0
    257a:	09 f4       	brne	.+2      	; 0x257e <xCoRoutineCreate+0x32>
    257c:	77 c0       	rjmp	.+238    	; 0x266c <xCoRoutineCreate+0x120>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    257e:	80 91 75 02 	lds	r24, 0x0275
    2582:	90 91 76 02 	lds	r25, 0x0276
    2586:	00 97       	sbiw	r24, 0x00	; 0
    2588:	41 f4       	brne	.+16     	; 0x259a <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    258a:	8a 81       	ldd	r24, Y+2	; 0x02
    258c:	9b 81       	ldd	r25, Y+3	; 0x03
    258e:	90 93 76 02 	sts	0x0276, r25
    2592:	80 93 75 02 	sts	0x0275, r24
			prvInitialiseCoRoutineLists();
    2596:	0e 94 2c 15 	call	0x2a58	; 0x2a58 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    259a:	8e 81       	ldd	r24, Y+6	; 0x06
    259c:	82 30       	cpi	r24, 0x02	; 2
    259e:	10 f0       	brcs	.+4      	; 0x25a4 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    25a0:	81 e0       	ldi	r24, 0x01	; 1
    25a2:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    25a4:	8a 81       	ldd	r24, Y+2	; 0x02
    25a6:	9b 81       	ldd	r25, Y+3	; 0x03
    25a8:	fc 01       	movw	r30, r24
    25aa:	11 8e       	std	Z+25, r1	; 0x19
    25ac:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    25ae:	8a 81       	ldd	r24, Y+2	; 0x02
    25b0:	9b 81       	ldd	r25, Y+3	; 0x03
    25b2:	2e 81       	ldd	r18, Y+6	; 0x06
    25b4:	fc 01       	movw	r30, r24
    25b6:	26 8b       	std	Z+22, r18	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    25b8:	8a 81       	ldd	r24, Y+2	; 0x02
    25ba:	9b 81       	ldd	r25, Y+3	; 0x03
    25bc:	2f 81       	ldd	r18, Y+7	; 0x07
    25be:	fc 01       	movw	r30, r24
    25c0:	27 8b       	std	Z+23, r18	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    25c2:	8a 81       	ldd	r24, Y+2	; 0x02
    25c4:	9b 81       	ldd	r25, Y+3	; 0x03
    25c6:	2c 81       	ldd	r18, Y+4	; 0x04
    25c8:	3d 81       	ldd	r19, Y+5	; 0x05
    25ca:	fc 01       	movw	r30, r24
    25cc:	31 83       	std	Z+1, r19	; 0x01
    25ce:	20 83       	st	Z, r18

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    25d0:	8a 81       	ldd	r24, Y+2	; 0x02
    25d2:	9b 81       	ldd	r25, Y+3	; 0x03
    25d4:	02 96       	adiw	r24, 0x02	; 2
    25d6:	0e 94 6d 11 	call	0x22da	; 0x22da <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    25da:	8a 81       	ldd	r24, Y+2	; 0x02
    25dc:	9b 81       	ldd	r25, Y+3	; 0x03
    25de:	0c 96       	adiw	r24, 0x0c	; 12
    25e0:	0e 94 6d 11 	call	0x22da	; 0x22da <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    25e4:	8a 81       	ldd	r24, Y+2	; 0x02
    25e6:	9b 81       	ldd	r25, Y+3	; 0x03
    25e8:	2a 81       	ldd	r18, Y+2	; 0x02
    25ea:	3b 81       	ldd	r19, Y+3	; 0x03
    25ec:	fc 01       	movw	r30, r24
    25ee:	31 87       	std	Z+9, r19	; 0x09
    25f0:	20 87       	std	Z+8, r18	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    25f2:	8a 81       	ldd	r24, Y+2	; 0x02
    25f4:	9b 81       	ldd	r25, Y+3	; 0x03
    25f6:	2a 81       	ldd	r18, Y+2	; 0x02
    25f8:	3b 81       	ldd	r19, Y+3	; 0x03
    25fa:	fc 01       	movw	r30, r24
    25fc:	33 8b       	std	Z+19, r19	; 0x13
    25fe:	22 8b       	std	Z+18, r18	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    2600:	8e 81       	ldd	r24, Y+6	; 0x06
    2602:	88 2f       	mov	r24, r24
    2604:	90 e0       	ldi	r25, 0x00	; 0
    2606:	24 e0       	ldi	r18, 0x04	; 4
    2608:	30 e0       	ldi	r19, 0x00	; 0
    260a:	28 1b       	sub	r18, r24
    260c:	39 0b       	sbc	r19, r25
    260e:	8a 81       	ldd	r24, Y+2	; 0x02
    2610:	9b 81       	ldd	r25, Y+3	; 0x03
    2612:	fc 01       	movw	r30, r24
    2614:	35 87       	std	Z+13, r19	; 0x0d
    2616:	24 87       	std	Z+12, r18	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    2618:	8a 81       	ldd	r24, Y+2	; 0x02
    261a:	9b 81       	ldd	r25, Y+3	; 0x03
    261c:	fc 01       	movw	r30, r24
    261e:	96 89       	ldd	r25, Z+22	; 0x16
    2620:	80 91 a8 02 	lds	r24, 0x02A8
    2624:	89 17       	cp	r24, r25
    2626:	30 f4       	brcc	.+12     	; 0x2634 <xCoRoutineCreate+0xe8>
    2628:	8a 81       	ldd	r24, Y+2	; 0x02
    262a:	9b 81       	ldd	r25, Y+3	; 0x03
    262c:	fc 01       	movw	r30, r24
    262e:	86 89       	ldd	r24, Z+22	; 0x16
    2630:	80 93 a8 02 	sts	0x02A8, r24
    2634:	8a 81       	ldd	r24, Y+2	; 0x02
    2636:	9b 81       	ldd	r25, Y+3	; 0x03
    2638:	ac 01       	movw	r20, r24
    263a:	4e 5f       	subi	r20, 0xFE	; 254
    263c:	5f 4f       	sbci	r21, 0xFF	; 255
    263e:	8a 81       	ldd	r24, Y+2	; 0x02
    2640:	9b 81       	ldd	r25, Y+3	; 0x03
    2642:	fc 01       	movw	r30, r24
    2644:	86 89       	ldd	r24, Z+22	; 0x16
    2646:	28 2f       	mov	r18, r24
    2648:	30 e0       	ldi	r19, 0x00	; 0
    264a:	c9 01       	movw	r24, r18
    264c:	88 0f       	add	r24, r24
    264e:	99 1f       	adc	r25, r25
    2650:	88 0f       	add	r24, r24
    2652:	99 1f       	adc	r25, r25
    2654:	88 0f       	add	r24, r24
    2656:	99 1f       	adc	r25, r25
    2658:	82 0f       	add	r24, r18
    265a:	93 1f       	adc	r25, r19
    265c:	89 58       	subi	r24, 0x89	; 137
    265e:	9d 4f       	sbci	r25, 0xFD	; 253
    2660:	ba 01       	movw	r22, r20
    2662:	0e 94 7f 11 	call	0x22fe	; 0x22fe <vListInsertEnd>

		xReturn = pdPASS;
    2666:	81 e0       	ldi	r24, 0x01	; 1
    2668:	89 83       	std	Y+1, r24	; 0x01
    266a:	02 c0       	rjmp	.+4      	; 0x2670 <xCoRoutineCreate+0x124>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    266c:	8f ef       	ldi	r24, 0xFF	; 255
    266e:	89 83       	std	Y+1, r24	; 0x01
	}
	
	return xReturn;	
    2670:	89 81       	ldd	r24, Y+1	; 0x01
}
    2672:	27 96       	adiw	r28, 0x07	; 7
    2674:	0f b6       	in	r0, 0x3f	; 63
    2676:	f8 94       	cli
    2678:	de bf       	out	0x3e, r29	; 62
    267a:	0f be       	out	0x3f, r0	; 63
    267c:	cd bf       	out	0x3d, r28	; 61
    267e:	df 91       	pop	r29
    2680:	cf 91       	pop	r28
    2682:	08 95       	ret

00002684 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    2684:	cf 93       	push	r28
    2686:	df 93       	push	r29
    2688:	00 d0       	rcall	.+0      	; 0x268a <vCoRoutineAddToDelayedList+0x6>
    268a:	00 d0       	rcall	.+0      	; 0x268c <vCoRoutineAddToDelayedList+0x8>
    268c:	cd b7       	in	r28, 0x3d	; 61
    268e:	de b7       	in	r29, 0x3e	; 62
    2690:	9c 83       	std	Y+4, r25	; 0x04
    2692:	8b 83       	std	Y+3, r24	; 0x03
    2694:	7e 83       	std	Y+6, r23	; 0x06
    2696:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    2698:	20 91 a9 02 	lds	r18, 0x02A9
    269c:	30 91 aa 02 	lds	r19, 0x02AA
    26a0:	8b 81       	ldd	r24, Y+3	; 0x03
    26a2:	9c 81       	ldd	r25, Y+4	; 0x04
    26a4:	82 0f       	add	r24, r18
    26a6:	93 1f       	adc	r25, r19
    26a8:	9a 83       	std	Y+2, r25	; 0x02
    26aa:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    26ac:	80 91 75 02 	lds	r24, 0x0275
    26b0:	90 91 76 02 	lds	r25, 0x0276
    26b4:	02 96       	adiw	r24, 0x02	; 2
    26b6:	0e 94 4f 12 	call	0x249e	; 0x249e <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    26ba:	80 91 75 02 	lds	r24, 0x0275
    26be:	90 91 76 02 	lds	r25, 0x0276
    26c2:	29 81       	ldd	r18, Y+1	; 0x01
    26c4:	3a 81       	ldd	r19, Y+2	; 0x02
    26c6:	fc 01       	movw	r30, r24
    26c8:	33 83       	std	Z+3, r19	; 0x03
    26ca:	22 83       	std	Z+2, r18	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    26cc:	80 91 a9 02 	lds	r24, 0x02A9
    26d0:	90 91 aa 02 	lds	r25, 0x02AA
    26d4:	29 81       	ldd	r18, Y+1	; 0x01
    26d6:	3a 81       	ldd	r19, Y+2	; 0x02
    26d8:	28 17       	cp	r18, r24
    26da:	39 07       	cpc	r19, r25
    26dc:	78 f4       	brcc	.+30     	; 0x26fc <vCoRoutineAddToDelayedList+0x78>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    26de:	80 91 75 02 	lds	r24, 0x0275
    26e2:	90 91 76 02 	lds	r25, 0x0276
    26e6:	9c 01       	movw	r18, r24
    26e8:	2e 5f       	subi	r18, 0xFE	; 254
    26ea:	3f 4f       	sbci	r19, 0xFF	; 255
    26ec:	80 91 9d 02 	lds	r24, 0x029D
    26f0:	90 91 9e 02 	lds	r25, 0x029E
    26f4:	b9 01       	movw	r22, r18
    26f6:	0e 94 d6 11 	call	0x23ac	; 0x23ac <vListInsert>
    26fa:	0e c0       	rjmp	.+28     	; 0x2718 <vCoRoutineAddToDelayedList+0x94>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    26fc:	80 91 75 02 	lds	r24, 0x0275
    2700:	90 91 76 02 	lds	r25, 0x0276
    2704:	9c 01       	movw	r18, r24
    2706:	2e 5f       	subi	r18, 0xFE	; 254
    2708:	3f 4f       	sbci	r19, 0xFF	; 255
    270a:	80 91 9b 02 	lds	r24, 0x029B
    270e:	90 91 9c 02 	lds	r25, 0x029C
    2712:	b9 01       	movw	r22, r18
    2714:	0e 94 d6 11 	call	0x23ac	; 0x23ac <vListInsert>
	}

	if( pxEventList )
    2718:	8d 81       	ldd	r24, Y+5	; 0x05
    271a:	9e 81       	ldd	r25, Y+6	; 0x06
    271c:	00 97       	sbiw	r24, 0x00	; 0
    271e:	61 f0       	breq	.+24     	; 0x2738 <vCoRoutineAddToDelayedList+0xb4>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    2720:	80 91 75 02 	lds	r24, 0x0275
    2724:	90 91 76 02 	lds	r25, 0x0276
    2728:	9c 01       	movw	r18, r24
    272a:	24 5f       	subi	r18, 0xF4	; 244
    272c:	3f 4f       	sbci	r19, 0xFF	; 255
    272e:	8d 81       	ldd	r24, Y+5	; 0x05
    2730:	9e 81       	ldd	r25, Y+6	; 0x06
    2732:	b9 01       	movw	r22, r18
    2734:	0e 94 d6 11 	call	0x23ac	; 0x23ac <vListInsert>
	}
}
    2738:	26 96       	adiw	r28, 0x06	; 6
    273a:	0f b6       	in	r0, 0x3f	; 63
    273c:	f8 94       	cli
    273e:	de bf       	out	0x3e, r29	; 62
    2740:	0f be       	out	0x3f, r0	; 63
    2742:	cd bf       	out	0x3d, r28	; 61
    2744:	df 91       	pop	r29
    2746:	cf 91       	pop	r28
    2748:	08 95       	ret

0000274a <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    274a:	cf 93       	push	r28
    274c:	df 93       	push	r29
    274e:	1f 92       	push	r1
    2750:	1f 92       	push	r1
    2752:	cd b7       	in	r28, 0x3d	; 61
    2754:	de b7       	in	r29, 0x3e	; 62
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    2756:	3c c0       	rjmp	.+120    	; 0x27d0 <prvCheckPendingReadyList+0x86>
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    2758:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    275a:	80 91 a4 02 	lds	r24, 0x02A4
    275e:	90 91 a5 02 	lds	r25, 0x02A5
    2762:	fc 01       	movw	r30, r24
    2764:	86 81       	ldd	r24, Z+6	; 0x06
    2766:	97 81       	ldd	r25, Z+7	; 0x07
    2768:	9a 83       	std	Y+2, r25	; 0x02
    276a:	89 83       	std	Y+1, r24	; 0x01
			uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    276c:	89 81       	ldd	r24, Y+1	; 0x01
    276e:	9a 81       	ldd	r25, Y+2	; 0x02
    2770:	0c 96       	adiw	r24, 0x0c	; 12
    2772:	0e 94 4f 12 	call	0x249e	; 0x249e <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    2776:	78 94       	sei

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    2778:	89 81       	ldd	r24, Y+1	; 0x01
    277a:	9a 81       	ldd	r25, Y+2	; 0x02
    277c:	02 96       	adiw	r24, 0x02	; 2
    277e:	0e 94 4f 12 	call	0x249e	; 0x249e <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    2782:	89 81       	ldd	r24, Y+1	; 0x01
    2784:	9a 81       	ldd	r25, Y+2	; 0x02
    2786:	fc 01       	movw	r30, r24
    2788:	96 89       	ldd	r25, Z+22	; 0x16
    278a:	80 91 a8 02 	lds	r24, 0x02A8
    278e:	89 17       	cp	r24, r25
    2790:	30 f4       	brcc	.+12     	; 0x279e <prvCheckPendingReadyList+0x54>
    2792:	89 81       	ldd	r24, Y+1	; 0x01
    2794:	9a 81       	ldd	r25, Y+2	; 0x02
    2796:	fc 01       	movw	r30, r24
    2798:	86 89       	ldd	r24, Z+22	; 0x16
    279a:	80 93 a8 02 	sts	0x02A8, r24
    279e:	89 81       	ldd	r24, Y+1	; 0x01
    27a0:	9a 81       	ldd	r25, Y+2	; 0x02
    27a2:	ac 01       	movw	r20, r24
    27a4:	4e 5f       	subi	r20, 0xFE	; 254
    27a6:	5f 4f       	sbci	r21, 0xFF	; 255
    27a8:	89 81       	ldd	r24, Y+1	; 0x01
    27aa:	9a 81       	ldd	r25, Y+2	; 0x02
    27ac:	fc 01       	movw	r30, r24
    27ae:	86 89       	ldd	r24, Z+22	; 0x16
    27b0:	28 2f       	mov	r18, r24
    27b2:	30 e0       	ldi	r19, 0x00	; 0
    27b4:	c9 01       	movw	r24, r18
    27b6:	88 0f       	add	r24, r24
    27b8:	99 1f       	adc	r25, r25
    27ba:	88 0f       	add	r24, r24
    27bc:	99 1f       	adc	r25, r25
    27be:	88 0f       	add	r24, r24
    27c0:	99 1f       	adc	r25, r25
    27c2:	82 0f       	add	r24, r18
    27c4:	93 1f       	adc	r25, r19
    27c6:	89 58       	subi	r24, 0x89	; 137
    27c8:	9d 4f       	sbci	r25, 0xFD	; 253
    27ca:	ba 01       	movw	r22, r20
    27cc:	0e 94 7f 11 	call	0x22fe	; 0x22fe <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    27d0:	80 91 9f 02 	lds	r24, 0x029F
    27d4:	88 23       	and	r24, r24
    27d6:	09 f0       	breq	.+2      	; 0x27da <prvCheckPendingReadyList+0x90>
    27d8:	bf cf       	rjmp	.-130    	; 0x2758 <prvCheckPendingReadyList+0xe>
		portENABLE_INTERRUPTS();

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    27da:	0f 90       	pop	r0
    27dc:	0f 90       	pop	r0
    27de:	df 91       	pop	r29
    27e0:	cf 91       	pop	r28
    27e2:	08 95       	ret

000027e4 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    27e4:	cf 93       	push	r28
    27e6:	df 93       	push	r29
    27e8:	00 d0       	rcall	.+0      	; 0x27ea <prvCheckDelayedList+0x6>
    27ea:	1f 92       	push	r1
    27ec:	cd b7       	in	r28, 0x3d	; 61
    27ee:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    27f0:	0e 94 17 06 	call	0xc2e	; 0xc2e <xTaskGetTickCount>
    27f4:	9c 01       	movw	r18, r24
    27f6:	80 91 ab 02 	lds	r24, 0x02AB
    27fa:	90 91 ac 02 	lds	r25, 0x02AC
    27fe:	a9 01       	movw	r20, r18
    2800:	48 1b       	sub	r20, r24
    2802:	59 0b       	sbc	r21, r25
    2804:	ca 01       	movw	r24, r20
    2806:	90 93 ae 02 	sts	0x02AE, r25
    280a:	80 93 ad 02 	sts	0x02AD, r24
	while( xPassedTicks )
    280e:	8a c0       	rjmp	.+276    	; 0x2924 <prvCheckDelayedList+0x140>
	{
		xCoRoutineTickCount++;
    2810:	80 91 a9 02 	lds	r24, 0x02A9
    2814:	90 91 aa 02 	lds	r25, 0x02AA
    2818:	01 96       	adiw	r24, 0x01	; 1
    281a:	90 93 aa 02 	sts	0x02AA, r25
    281e:	80 93 a9 02 	sts	0x02A9, r24
		xPassedTicks--;
    2822:	80 91 ad 02 	lds	r24, 0x02AD
    2826:	90 91 ae 02 	lds	r25, 0x02AE
    282a:	01 97       	sbiw	r24, 0x01	; 1
    282c:	90 93 ae 02 	sts	0x02AE, r25
    2830:	80 93 ad 02 	sts	0x02AD, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    2834:	80 91 a9 02 	lds	r24, 0x02A9
    2838:	90 91 aa 02 	lds	r25, 0x02AA
    283c:	00 97       	sbiw	r24, 0x00	; 0
    283e:	a9 f4       	brne	.+42     	; 0x286a <prvCheckDelayedList+0x86>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    2840:	80 91 9b 02 	lds	r24, 0x029B
    2844:	90 91 9c 02 	lds	r25, 0x029C
    2848:	9a 83       	std	Y+2, r25	; 0x02
    284a:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    284c:	80 91 9d 02 	lds	r24, 0x029D
    2850:	90 91 9e 02 	lds	r25, 0x029E
    2854:	90 93 9c 02 	sts	0x029C, r25
    2858:	80 93 9b 02 	sts	0x029B, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    285c:	89 81       	ldd	r24, Y+1	; 0x01
    285e:	9a 81       	ldd	r25, Y+2	; 0x02
    2860:	90 93 9e 02 	sts	0x029E, r25
    2864:	80 93 9d 02 	sts	0x029D, r24
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    2868:	54 c0       	rjmp	.+168    	; 0x2912 <prvCheckDelayedList+0x12e>
    286a:	53 c0       	rjmp	.+166    	; 0x2912 <prvCheckDelayedList+0x12e>
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    286c:	80 91 9b 02 	lds	r24, 0x029B
    2870:	90 91 9c 02 	lds	r25, 0x029C
    2874:	fc 01       	movw	r30, r24
    2876:	85 81       	ldd	r24, Z+5	; 0x05
    2878:	96 81       	ldd	r25, Z+6	; 0x06
    287a:	fc 01       	movw	r30, r24
    287c:	86 81       	ldd	r24, Z+6	; 0x06
    287e:	97 81       	ldd	r25, Z+7	; 0x07
    2880:	9c 83       	std	Y+4, r25	; 0x04
    2882:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    2884:	8b 81       	ldd	r24, Y+3	; 0x03
    2886:	9c 81       	ldd	r25, Y+4	; 0x04
    2888:	fc 01       	movw	r30, r24
    288a:	22 81       	ldd	r18, Z+2	; 0x02
    288c:	33 81       	ldd	r19, Z+3	; 0x03
    288e:	80 91 a9 02 	lds	r24, 0x02A9
    2892:	90 91 aa 02 	lds	r25, 0x02AA
    2896:	82 17       	cp	r24, r18
    2898:	93 07       	cpc	r25, r19
    289a:	08 f4       	brcc	.+2      	; 0x289e <prvCheckDelayedList+0xba>
			{			
				/* Timeout not yet expired. */																			
				break;																				
    289c:	43 c0       	rjmp	.+134    	; 0x2924 <prvCheckDelayedList+0x140>
			}																						

			portDISABLE_INTERRUPTS();
    289e:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				uxListRemove( &( pxCRCB->xGenericListItem ) );											
    28a0:	8b 81       	ldd	r24, Y+3	; 0x03
    28a2:	9c 81       	ldd	r25, Y+4	; 0x04
    28a4:	02 96       	adiw	r24, 0x02	; 2
    28a6:	0e 94 4f 12 	call	0x249e	; 0x249e <uxListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    28aa:	8b 81       	ldd	r24, Y+3	; 0x03
    28ac:	9c 81       	ldd	r25, Y+4	; 0x04
    28ae:	fc 01       	movw	r30, r24
    28b0:	84 89       	ldd	r24, Z+20	; 0x14
    28b2:	95 89       	ldd	r25, Z+21	; 0x15
    28b4:	00 97       	sbiw	r24, 0x00	; 0
    28b6:	29 f0       	breq	.+10     	; 0x28c2 <prvCheckDelayedList+0xde>
				{															
					uxListRemove( &( pxCRCB->xEventListItem ) );											
    28b8:	8b 81       	ldd	r24, Y+3	; 0x03
    28ba:	9c 81       	ldd	r25, Y+4	; 0x04
    28bc:	0c 96       	adiw	r24, 0x0c	; 12
    28be:	0e 94 4f 12 	call	0x249e	; 0x249e <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    28c2:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    28c4:	8b 81       	ldd	r24, Y+3	; 0x03
    28c6:	9c 81       	ldd	r25, Y+4	; 0x04
    28c8:	fc 01       	movw	r30, r24
    28ca:	96 89       	ldd	r25, Z+22	; 0x16
    28cc:	80 91 a8 02 	lds	r24, 0x02A8
    28d0:	89 17       	cp	r24, r25
    28d2:	30 f4       	brcc	.+12     	; 0x28e0 <prvCheckDelayedList+0xfc>
    28d4:	8b 81       	ldd	r24, Y+3	; 0x03
    28d6:	9c 81       	ldd	r25, Y+4	; 0x04
    28d8:	fc 01       	movw	r30, r24
    28da:	86 89       	ldd	r24, Z+22	; 0x16
    28dc:	80 93 a8 02 	sts	0x02A8, r24
    28e0:	8b 81       	ldd	r24, Y+3	; 0x03
    28e2:	9c 81       	ldd	r25, Y+4	; 0x04
    28e4:	ac 01       	movw	r20, r24
    28e6:	4e 5f       	subi	r20, 0xFE	; 254
    28e8:	5f 4f       	sbci	r21, 0xFF	; 255
    28ea:	8b 81       	ldd	r24, Y+3	; 0x03
    28ec:	9c 81       	ldd	r25, Y+4	; 0x04
    28ee:	fc 01       	movw	r30, r24
    28f0:	86 89       	ldd	r24, Z+22	; 0x16
    28f2:	28 2f       	mov	r18, r24
    28f4:	30 e0       	ldi	r19, 0x00	; 0
    28f6:	c9 01       	movw	r24, r18
    28f8:	88 0f       	add	r24, r24
    28fa:	99 1f       	adc	r25, r25
    28fc:	88 0f       	add	r24, r24
    28fe:	99 1f       	adc	r25, r25
    2900:	88 0f       	add	r24, r24
    2902:	99 1f       	adc	r25, r25
    2904:	82 0f       	add	r24, r18
    2906:	93 1f       	adc	r25, r19
    2908:	89 58       	subi	r24, 0x89	; 137
    290a:	9d 4f       	sbci	r25, 0xFD	; 253
    290c:	ba 01       	movw	r22, r20
    290e:	0e 94 7f 11 	call	0x22fe	; 0x22fe <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    2912:	80 91 9b 02 	lds	r24, 0x029B
    2916:	90 91 9c 02 	lds	r25, 0x029C
    291a:	fc 01       	movw	r30, r24
    291c:	80 81       	ld	r24, Z
    291e:	88 23       	and	r24, r24
    2920:	09 f0       	breq	.+2      	; 0x2924 <prvCheckDelayedList+0x140>
    2922:	a4 cf       	rjmp	.-184    	; 0x286c <prvCheckDelayedList+0x88>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    2924:	80 91 ad 02 	lds	r24, 0x02AD
    2928:	90 91 ae 02 	lds	r25, 0x02AE
    292c:	00 97       	sbiw	r24, 0x00	; 0
    292e:	09 f0       	breq	.+2      	; 0x2932 <prvCheckDelayedList+0x14e>
    2930:	6f cf       	rjmp	.-290    	; 0x2810 <prvCheckDelayedList+0x2c>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    2932:	80 91 a9 02 	lds	r24, 0x02A9
    2936:	90 91 aa 02 	lds	r25, 0x02AA
    293a:	90 93 ac 02 	sts	0x02AC, r25
    293e:	80 93 ab 02 	sts	0x02AB, r24
}
    2942:	0f 90       	pop	r0
    2944:	0f 90       	pop	r0
    2946:	0f 90       	pop	r0
    2948:	0f 90       	pop	r0
    294a:	df 91       	pop	r29
    294c:	cf 91       	pop	r28
    294e:	08 95       	ret

00002950 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    2950:	cf 93       	push	r28
    2952:	df 93       	push	r29
    2954:	1f 92       	push	r1
    2956:	1f 92       	push	r1
    2958:	cd b7       	in	r28, 0x3d	; 61
    295a:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    295c:	0e 94 a5 13 	call	0x274a	; 0x274a <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    2960:	0e 94 f2 13 	call	0x27e4	; 0x27e4 <prvCheckDelayedList>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2964:	0a c0       	rjmp	.+20     	; 0x297a <vCoRoutineSchedule+0x2a>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    2966:	80 91 a8 02 	lds	r24, 0x02A8
    296a:	88 23       	and	r24, r24
    296c:	09 f4       	brne	.+2      	; 0x2970 <vCoRoutineSchedule+0x20>
		{
			/* No more co-routines to check. */
			return;
    296e:	6f c0       	rjmp	.+222    	; 0x2a4e <vCoRoutineSchedule+0xfe>
		}
		--uxTopCoRoutineReadyPriority;
    2970:	80 91 a8 02 	lds	r24, 0x02A8
    2974:	81 50       	subi	r24, 0x01	; 1
    2976:	80 93 a8 02 	sts	0x02A8, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    297a:	80 91 a8 02 	lds	r24, 0x02A8
    297e:	28 2f       	mov	r18, r24
    2980:	30 e0       	ldi	r19, 0x00	; 0
    2982:	c9 01       	movw	r24, r18
    2984:	88 0f       	add	r24, r24
    2986:	99 1f       	adc	r25, r25
    2988:	88 0f       	add	r24, r24
    298a:	99 1f       	adc	r25, r25
    298c:	88 0f       	add	r24, r24
    298e:	99 1f       	adc	r25, r25
    2990:	82 0f       	add	r24, r18
    2992:	93 1f       	adc	r25, r19
    2994:	89 58       	subi	r24, 0x89	; 137
    2996:	9d 4f       	sbci	r25, 0xFD	; 253
    2998:	fc 01       	movw	r30, r24
    299a:	80 81       	ld	r24, Z
    299c:	88 23       	and	r24, r24
    299e:	19 f3       	breq	.-58     	; 0x2966 <vCoRoutineSchedule+0x16>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    29a0:	80 91 a8 02 	lds	r24, 0x02A8
    29a4:	28 2f       	mov	r18, r24
    29a6:	30 e0       	ldi	r19, 0x00	; 0
    29a8:	c9 01       	movw	r24, r18
    29aa:	88 0f       	add	r24, r24
    29ac:	99 1f       	adc	r25, r25
    29ae:	88 0f       	add	r24, r24
    29b0:	99 1f       	adc	r25, r25
    29b2:	88 0f       	add	r24, r24
    29b4:	99 1f       	adc	r25, r25
    29b6:	82 0f       	add	r24, r18
    29b8:	93 1f       	adc	r25, r19
    29ba:	89 58       	subi	r24, 0x89	; 137
    29bc:	9d 4f       	sbci	r25, 0xFD	; 253
    29be:	9a 83       	std	Y+2, r25	; 0x02
    29c0:	89 83       	std	Y+1, r24	; 0x01
    29c2:	89 81       	ldd	r24, Y+1	; 0x01
    29c4:	9a 81       	ldd	r25, Y+2	; 0x02
    29c6:	fc 01       	movw	r30, r24
    29c8:	81 81       	ldd	r24, Z+1	; 0x01
    29ca:	92 81       	ldd	r25, Z+2	; 0x02
    29cc:	fc 01       	movw	r30, r24
    29ce:	22 81       	ldd	r18, Z+2	; 0x02
    29d0:	33 81       	ldd	r19, Z+3	; 0x03
    29d2:	89 81       	ldd	r24, Y+1	; 0x01
    29d4:	9a 81       	ldd	r25, Y+2	; 0x02
    29d6:	fc 01       	movw	r30, r24
    29d8:	32 83       	std	Z+2, r19	; 0x02
    29da:	21 83       	std	Z+1, r18	; 0x01
    29dc:	89 81       	ldd	r24, Y+1	; 0x01
    29de:	9a 81       	ldd	r25, Y+2	; 0x02
    29e0:	fc 01       	movw	r30, r24
    29e2:	21 81       	ldd	r18, Z+1	; 0x01
    29e4:	32 81       	ldd	r19, Z+2	; 0x02
    29e6:	89 81       	ldd	r24, Y+1	; 0x01
    29e8:	9a 81       	ldd	r25, Y+2	; 0x02
    29ea:	03 96       	adiw	r24, 0x03	; 3
    29ec:	28 17       	cp	r18, r24
    29ee:	39 07       	cpc	r19, r25
    29f0:	69 f4       	brne	.+26     	; 0x2a0c <vCoRoutineSchedule+0xbc>
    29f2:	89 81       	ldd	r24, Y+1	; 0x01
    29f4:	9a 81       	ldd	r25, Y+2	; 0x02
    29f6:	fc 01       	movw	r30, r24
    29f8:	81 81       	ldd	r24, Z+1	; 0x01
    29fa:	92 81       	ldd	r25, Z+2	; 0x02
    29fc:	fc 01       	movw	r30, r24
    29fe:	22 81       	ldd	r18, Z+2	; 0x02
    2a00:	33 81       	ldd	r19, Z+3	; 0x03
    2a02:	89 81       	ldd	r24, Y+1	; 0x01
    2a04:	9a 81       	ldd	r25, Y+2	; 0x02
    2a06:	fc 01       	movw	r30, r24
    2a08:	32 83       	std	Z+2, r19	; 0x02
    2a0a:	21 83       	std	Z+1, r18	; 0x01
    2a0c:	89 81       	ldd	r24, Y+1	; 0x01
    2a0e:	9a 81       	ldd	r25, Y+2	; 0x02
    2a10:	fc 01       	movw	r30, r24
    2a12:	81 81       	ldd	r24, Z+1	; 0x01
    2a14:	92 81       	ldd	r25, Z+2	; 0x02
    2a16:	fc 01       	movw	r30, r24
    2a18:	86 81       	ldd	r24, Z+6	; 0x06
    2a1a:	97 81       	ldd	r25, Z+7	; 0x07
    2a1c:	90 93 76 02 	sts	0x0276, r25
    2a20:	80 93 75 02 	sts	0x0275, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2a24:	80 91 75 02 	lds	r24, 0x0275
    2a28:	90 91 76 02 	lds	r25, 0x0276
    2a2c:	fc 01       	movw	r30, r24
    2a2e:	20 81       	ld	r18, Z
    2a30:	31 81       	ldd	r19, Z+1	; 0x01
    2a32:	80 91 75 02 	lds	r24, 0x0275
    2a36:	90 91 76 02 	lds	r25, 0x0276
    2a3a:	fc 01       	movw	r30, r24
    2a3c:	47 89       	ldd	r20, Z+23	; 0x17
    2a3e:	80 91 75 02 	lds	r24, 0x0275
    2a42:	90 91 76 02 	lds	r25, 0x0276
    2a46:	64 2f       	mov	r22, r20
    2a48:	f9 01       	movw	r30, r18
    2a4a:	19 95       	eicall

	return;
    2a4c:	00 00       	nop
}
    2a4e:	0f 90       	pop	r0
    2a50:	0f 90       	pop	r0
    2a52:	df 91       	pop	r29
    2a54:	cf 91       	pop	r28
    2a56:	08 95       	ret

00002a58 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    2a58:	cf 93       	push	r28
    2a5a:	df 93       	push	r29
    2a5c:	1f 92       	push	r1
    2a5e:	cd b7       	in	r28, 0x3d	; 61
    2a60:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2a62:	19 82       	std	Y+1, r1	; 0x01
    2a64:	13 c0       	rjmp	.+38     	; 0x2a8c <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    2a66:	89 81       	ldd	r24, Y+1	; 0x01
    2a68:	28 2f       	mov	r18, r24
    2a6a:	30 e0       	ldi	r19, 0x00	; 0
    2a6c:	c9 01       	movw	r24, r18
    2a6e:	88 0f       	add	r24, r24
    2a70:	99 1f       	adc	r25, r25
    2a72:	88 0f       	add	r24, r24
    2a74:	99 1f       	adc	r25, r25
    2a76:	88 0f       	add	r24, r24
    2a78:	99 1f       	adc	r25, r25
    2a7a:	82 0f       	add	r24, r18
    2a7c:	93 1f       	adc	r25, r19
    2a7e:	89 58       	subi	r24, 0x89	; 137
    2a80:	9d 4f       	sbci	r25, 0xFD	; 253
    2a82:	0e 94 37 11 	call	0x226e	; 0x226e <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2a86:	89 81       	ldd	r24, Y+1	; 0x01
    2a88:	8f 5f       	subi	r24, 0xFF	; 255
    2a8a:	89 83       	std	Y+1, r24	; 0x01
    2a8c:	89 81       	ldd	r24, Y+1	; 0x01
    2a8e:	82 30       	cpi	r24, 0x02	; 2
    2a90:	50 f3       	brcs	.-44     	; 0x2a66 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    2a92:	89 e8       	ldi	r24, 0x89	; 137
    2a94:	92 e0       	ldi	r25, 0x02	; 2
    2a96:	0e 94 37 11 	call	0x226e	; 0x226e <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    2a9a:	82 e9       	ldi	r24, 0x92	; 146
    2a9c:	92 e0       	ldi	r25, 0x02	; 2
    2a9e:	0e 94 37 11 	call	0x226e	; 0x226e <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    2aa2:	8f e9       	ldi	r24, 0x9F	; 159
    2aa4:	92 e0       	ldi	r25, 0x02	; 2
    2aa6:	0e 94 37 11 	call	0x226e	; 0x226e <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    2aaa:	89 e8       	ldi	r24, 0x89	; 137
    2aac:	92 e0       	ldi	r25, 0x02	; 2
    2aae:	90 93 9c 02 	sts	0x029C, r25
    2ab2:	80 93 9b 02 	sts	0x029B, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    2ab6:	82 e9       	ldi	r24, 0x92	; 146
    2ab8:	92 e0       	ldi	r25, 0x02	; 2
    2aba:	90 93 9e 02 	sts	0x029E, r25
    2abe:	80 93 9d 02 	sts	0x029D, r24
}
    2ac2:	0f 90       	pop	r0
    2ac4:	df 91       	pop	r29
    2ac6:	cf 91       	pop	r28
    2ac8:	08 95       	ret

00002aca <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    2aca:	cf 93       	push	r28
    2acc:	df 93       	push	r29
    2ace:	00 d0       	rcall	.+0      	; 0x2ad0 <xCoRoutineRemoveFromEventList+0x6>
    2ad0:	1f 92       	push	r1
    2ad2:	1f 92       	push	r1
    2ad4:	cd b7       	in	r28, 0x3d	; 61
    2ad6:	de b7       	in	r29, 0x3e	; 62
    2ad8:	9d 83       	std	Y+5, r25	; 0x05
    2ada:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2adc:	8c 81       	ldd	r24, Y+4	; 0x04
    2ade:	9d 81       	ldd	r25, Y+5	; 0x05
    2ae0:	fc 01       	movw	r30, r24
    2ae2:	85 81       	ldd	r24, Z+5	; 0x05
    2ae4:	96 81       	ldd	r25, Z+6	; 0x06
    2ae6:	fc 01       	movw	r30, r24
    2ae8:	86 81       	ldd	r24, Z+6	; 0x06
    2aea:	97 81       	ldd	r25, Z+7	; 0x07
    2aec:	9b 83       	std	Y+3, r25	; 0x03
    2aee:	8a 83       	std	Y+2, r24	; 0x02
	uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2af0:	8a 81       	ldd	r24, Y+2	; 0x02
    2af2:	9b 81       	ldd	r25, Y+3	; 0x03
    2af4:	0c 96       	adiw	r24, 0x0c	; 12
    2af6:	0e 94 4f 12 	call	0x249e	; 0x249e <uxListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    2afa:	8a 81       	ldd	r24, Y+2	; 0x02
    2afc:	9b 81       	ldd	r25, Y+3	; 0x03
    2afe:	0c 96       	adiw	r24, 0x0c	; 12
    2b00:	bc 01       	movw	r22, r24
    2b02:	8f e9       	ldi	r24, 0x9F	; 159
    2b04:	92 e0       	ldi	r25, 0x02	; 2
    2b06:	0e 94 7f 11 	call	0x22fe	; 0x22fe <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    2b0a:	8a 81       	ldd	r24, Y+2	; 0x02
    2b0c:	9b 81       	ldd	r25, Y+3	; 0x03
    2b0e:	fc 01       	movw	r30, r24
    2b10:	26 89       	ldd	r18, Z+22	; 0x16
    2b12:	80 91 75 02 	lds	r24, 0x0275
    2b16:	90 91 76 02 	lds	r25, 0x0276
    2b1a:	fc 01       	movw	r30, r24
    2b1c:	86 89       	ldd	r24, Z+22	; 0x16
    2b1e:	28 17       	cp	r18, r24
    2b20:	18 f0       	brcs	.+6      	; 0x2b28 <xCoRoutineRemoveFromEventList+0x5e>
	{
		xReturn = pdTRUE;
    2b22:	81 e0       	ldi	r24, 0x01	; 1
    2b24:	89 83       	std	Y+1, r24	; 0x01
    2b26:	01 c0       	rjmp	.+2      	; 0x2b2a <xCoRoutineRemoveFromEventList+0x60>
	}
	else
	{
		xReturn = pdFALSE;
    2b28:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2b2a:	89 81       	ldd	r24, Y+1	; 0x01
}
    2b2c:	0f 90       	pop	r0
    2b2e:	0f 90       	pop	r0
    2b30:	0f 90       	pop	r0
    2b32:	0f 90       	pop	r0
    2b34:	0f 90       	pop	r0
    2b36:	df 91       	pop	r29
    2b38:	cf 91       	pop	r28
    2b3a:	08 95       	ret

00002b3c <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2b3c:	cf 93       	push	r28
    2b3e:	df 93       	push	r29
    2b40:	00 d0       	rcall	.+0      	; 0x2b42 <pvPortMalloc+0x6>
    2b42:	1f 92       	push	r1
    2b44:	cd b7       	in	r28, 0x3d	; 61
    2b46:	de b7       	in	r29, 0x3e	; 62
    2b48:	9c 83       	std	Y+4, r25	; 0x04
    2b4a:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    2b4c:	1a 82       	std	Y+2, r1	; 0x02
    2b4e:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    2b50:	0e 94 87 05 	call	0xb0e	; 0xb0e <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    2b54:	20 91 af 1a 	lds	r18, 0x1AAF
    2b58:	30 91 b0 1a 	lds	r19, 0x1AB0
    2b5c:	8b 81       	ldd	r24, Y+3	; 0x03
    2b5e:	9c 81       	ldd	r25, Y+4	; 0x04
    2b60:	82 0f       	add	r24, r18
    2b62:	93 1f       	adc	r25, r19
    2b64:	81 15       	cp	r24, r1
    2b66:	28 e1       	ldi	r18, 0x18	; 24
    2b68:	92 07       	cpc	r25, r18
    2b6a:	18 f5       	brcc	.+70     	; 0x2bb2 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
    2b6c:	20 91 af 1a 	lds	r18, 0x1AAF
    2b70:	30 91 b0 1a 	lds	r19, 0x1AB0
    2b74:	8b 81       	ldd	r24, Y+3	; 0x03
    2b76:	9c 81       	ldd	r25, Y+4	; 0x04
    2b78:	28 0f       	add	r18, r24
    2b7a:	39 1f       	adc	r19, r25
    2b7c:	80 91 af 1a 	lds	r24, 0x1AAF
    2b80:	90 91 b0 1a 	lds	r25, 0x1AB0
	#endif

	vTaskSuspendAll();
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    2b84:	82 17       	cp	r24, r18
    2b86:	93 07       	cpc	r25, r19
    2b88:	a0 f4       	brcc	.+40     	; 0x2bb2 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    2b8a:	80 91 af 1a 	lds	r24, 0x1AAF
    2b8e:	90 91 b0 1a 	lds	r25, 0x1AB0
    2b92:	81 55       	subi	r24, 0x51	; 81
    2b94:	9d 4f       	sbci	r25, 0xFD	; 253
    2b96:	9a 83       	std	Y+2, r25	; 0x02
    2b98:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    2b9a:	20 91 af 1a 	lds	r18, 0x1AAF
    2b9e:	30 91 b0 1a 	lds	r19, 0x1AB0
    2ba2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ba4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ba6:	82 0f       	add	r24, r18
    2ba8:	93 1f       	adc	r25, r19
    2baa:	90 93 b0 1a 	sts	0x1AB0, r25
    2bae:	80 93 af 1a 	sts	0x1AAF, r24
		}
	}
	xTaskResumeAll();
    2bb2:	0e 94 93 05 	call	0xb26	; 0xb26 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    2bb6:	89 81       	ldd	r24, Y+1	; 0x01
    2bb8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2bba:	0f 90       	pop	r0
    2bbc:	0f 90       	pop	r0
    2bbe:	0f 90       	pop	r0
    2bc0:	0f 90       	pop	r0
    2bc2:	df 91       	pop	r29
    2bc4:	cf 91       	pop	r28
    2bc6:	08 95       	ret

00002bc8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2bc8:	cf 93       	push	r28
    2bca:	df 93       	push	r29
    2bcc:	1f 92       	push	r1
    2bce:	1f 92       	push	r1
    2bd0:	cd b7       	in	r28, 0x3d	; 61
    2bd2:	de b7       	in	r29, 0x3e	; 62
    2bd4:	9a 83       	std	Y+2, r25	; 0x02
    2bd6:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    2bd8:	0f 90       	pop	r0
    2bda:	0f 90       	pop	r0
    2bdc:	df 91       	pop	r29
    2bde:	cf 91       	pop	r28
    2be0:	08 95       	ret

00002be2 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    2be2:	cf 93       	push	r28
    2be4:	df 93       	push	r29
    2be6:	cd b7       	in	r28, 0x3d	; 61
    2be8:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    2bea:	10 92 b0 1a 	sts	0x1AB0, r1
    2bee:	10 92 af 1a 	sts	0x1AAF, r1
}
    2bf2:	df 91       	pop	r29
    2bf4:	cf 91       	pop	r28
    2bf6:	08 95       	ret

00002bf8 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    2bf8:	cf 93       	push	r28
    2bfa:	df 93       	push	r29
    2bfc:	cd b7       	in	r28, 0x3d	; 61
    2bfe:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    2c00:	80 91 af 1a 	lds	r24, 0x1AAF
    2c04:	90 91 b0 1a 	lds	r25, 0x1AB0
    2c08:	20 e0       	ldi	r18, 0x00	; 0
    2c0a:	38 e1       	ldi	r19, 0x18	; 24
    2c0c:	a9 01       	movw	r20, r18
    2c0e:	48 1b       	sub	r20, r24
    2c10:	59 0b       	sbc	r21, r25
    2c12:	ca 01       	movw	r24, r20
}
    2c14:	df 91       	pop	r29
    2c16:	cf 91       	pop	r28
    2c18:	08 95       	ret

00002c1a <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    2c1a:	cf 93       	push	r28
    2c1c:	df 93       	push	r29
    2c1e:	cd b7       	in	r28, 0x3d	; 61
    2c20:	de b7       	in	r29, 0x3e	; 62
    2c22:	28 97       	sbiw	r28, 0x08	; 8
    2c24:	0f b6       	in	r0, 0x3f	; 63
    2c26:	f8 94       	cli
    2c28:	de bf       	out	0x3e, r29	; 62
    2c2a:	0f be       	out	0x3f, r0	; 63
    2c2c:	cd bf       	out	0x3d, r28	; 61
    2c2e:	9c 83       	std	Y+4, r25	; 0x04
    2c30:	8b 83       	std	Y+3, r24	; 0x03
    2c32:	7e 83       	std	Y+6, r23	; 0x06
    2c34:	6d 83       	std	Y+5, r22	; 0x05
    2c36:	58 87       	std	Y+8, r21	; 0x08
    2c38:	4f 83       	std	Y+7, r20	; 0x07
#endif

	/* Place a few bytes of known values on the bottom of the stack.
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2c3a:	8b 81       	ldd	r24, Y+3	; 0x03
    2c3c:	9c 81       	ldd	r25, Y+4	; 0x04
    2c3e:	21 e1       	ldi	r18, 0x11	; 17
    2c40:	fc 01       	movw	r30, r24
    2c42:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c44:	8b 81       	ldd	r24, Y+3	; 0x03
    2c46:	9c 81       	ldd	r25, Y+4	; 0x04
    2c48:	01 97       	sbiw	r24, 0x01	; 1
    2c4a:	9c 83       	std	Y+4, r25	; 0x04
    2c4c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    2c4e:	8b 81       	ldd	r24, Y+3	; 0x03
    2c50:	9c 81       	ldd	r25, Y+4	; 0x04
    2c52:	22 e2       	ldi	r18, 0x22	; 34
    2c54:	fc 01       	movw	r30, r24
    2c56:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c58:	8b 81       	ldd	r24, Y+3	; 0x03
    2c5a:	9c 81       	ldd	r25, Y+4	; 0x04
    2c5c:	01 97       	sbiw	r24, 0x01	; 1
    2c5e:	9c 83       	std	Y+4, r25	; 0x04
    2c60:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    2c62:	8b 81       	ldd	r24, Y+3	; 0x03
    2c64:	9c 81       	ldd	r25, Y+4	; 0x04
    2c66:	23 e3       	ldi	r18, 0x33	; 51
    2c68:	fc 01       	movw	r30, r24
    2c6a:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c6c:	8b 81       	ldd	r24, Y+3	; 0x03
    2c6e:	9c 81       	ldd	r25, Y+4	; 0x04
    2c70:	01 97       	sbiw	r24, 0x01	; 1
    2c72:	9c 83       	std	Y+4, r25	; 0x04
    2c74:	8b 83       	std	Y+3, r24	; 0x03
	 * of flash. We do this by adding the .task label in the linker script.
	 *
	 * In order to do this properly, we would need to get a full 3-byte pointer to
	 * pxCode.  That requires a change to GCC.  Not likely to happen any time soon.
	 */
	usAddress = ( unsigned portSHORT ) pxCode;
    2c76:	8d 81       	ldd	r24, Y+5	; 0x05
    2c78:	9e 81       	ldd	r25, Y+6	; 0x06
    2c7a:	9a 83       	std	Y+2, r25	; 0x02
    2c7c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    2c7e:	29 81       	ldd	r18, Y+1	; 0x01
    2c80:	8b 81       	ldd	r24, Y+3	; 0x03
    2c82:	9c 81       	ldd	r25, Y+4	; 0x04
    2c84:	fc 01       	movw	r30, r24
    2c86:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c88:	8b 81       	ldd	r24, Y+3	; 0x03
    2c8a:	9c 81       	ldd	r25, Y+4	; 0x04
    2c8c:	01 97       	sbiw	r24, 0x01	; 1
    2c8e:	9c 83       	std	Y+4, r25	; 0x04
    2c90:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2c92:	89 81       	ldd	r24, Y+1	; 0x01
    2c94:	9a 81       	ldd	r25, Y+2	; 0x02
    2c96:	89 2f       	mov	r24, r25
    2c98:	99 27       	eor	r25, r25
    2c9a:	9a 83       	std	Y+2, r25	; 0x02
    2c9c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    2c9e:	29 81       	ldd	r18, Y+1	; 0x01
    2ca0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ca2:	9c 81       	ldd	r25, Y+4	; 0x04
    2ca4:	fc 01       	movw	r30, r24
    2ca6:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ca8:	8b 81       	ldd	r24, Y+3	; 0x03
    2caa:	9c 81       	ldd	r25, Y+4	; 0x04
    2cac:	01 97       	sbiw	r24, 0x01	; 1
    2cae:	9c 83       	std	Y+4, r25	; 0x04
    2cb0:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = 0;
    2cb2:	8b 81       	ldd	r24, Y+3	; 0x03
    2cb4:	9c 81       	ldd	r25, Y+4	; 0x04
    2cb6:	fc 01       	movw	r30, r24
    2cb8:	10 82       	st	Z, r1
	pxTopOfStack--;
    2cba:	8b 81       	ldd	r24, Y+3	; 0x03
    2cbc:	9c 81       	ldd	r25, Y+4	; 0x04
    2cbe:	01 97       	sbiw	r24, 0x01	; 1
    2cc0:	9c 83       	std	Y+4, r25	; 0x04
    2cc2:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    2cc4:	8b 81       	ldd	r24, Y+3	; 0x03
    2cc6:	9c 81       	ldd	r25, Y+4	; 0x04
    2cc8:	fc 01       	movw	r30, r24
    2cca:	10 82       	st	Z, r1
	pxTopOfStack--;
    2ccc:	8b 81       	ldd	r24, Y+3	; 0x03
    2cce:	9c 81       	ldd	r25, Y+4	; 0x04
    2cd0:	01 97       	sbiw	r24, 0x01	; 1
    2cd2:	9c 83       	std	Y+4, r25	; 0x04
    2cd4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2cd6:	8b 81       	ldd	r24, Y+3	; 0x03
    2cd8:	9c 81       	ldd	r25, Y+4	; 0x04
    2cda:	20 e8       	ldi	r18, 0x80	; 128
    2cdc:	fc 01       	movw	r30, r24
    2cde:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ce0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ce2:	9c 81       	ldd	r25, Y+4	; 0x04
    2ce4:	01 97       	sbiw	r24, 0x01	; 1
    2ce6:	9c 83       	std	Y+4, r25	; 0x04
    2ce8:	8b 83       	std	Y+3, r24	; 0x03
#if defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

	/* If we have an ATmega256x, we are also saving the RAMPZ and EIND registers.
	 * We should default those to 0.
	 */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* EIND */
    2cea:	8b 81       	ldd	r24, Y+3	; 0x03
    2cec:	9c 81       	ldd	r25, Y+4	; 0x04
    2cee:	fc 01       	movw	r30, r24
    2cf0:	10 82       	st	Z, r1
	pxTopOfStack--;
    2cf2:	8b 81       	ldd	r24, Y+3	; 0x03
    2cf4:	9c 81       	ldd	r25, Y+4	; 0x04
    2cf6:	01 97       	sbiw	r24, 0x01	; 1
    2cf8:	9c 83       	std	Y+4, r25	; 0x04
    2cfa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* RAMPZ */
    2cfc:	8b 81       	ldd	r24, Y+3	; 0x03
    2cfe:	9c 81       	ldd	r25, Y+4	; 0x04
    2d00:	fc 01       	movw	r30, r24
    2d02:	10 82       	st	Z, r1
	pxTopOfStack--;
    2d04:	8b 81       	ldd	r24, Y+3	; 0x03
    2d06:	9c 81       	ldd	r25, Y+4	; 0x04
    2d08:	01 97       	sbiw	r24, 0x01	; 1
    2d0a:	9c 83       	std	Y+4, r25	; 0x04
    2d0c:	8b 83       	std	Y+3, r24	; 0x03

#endif

	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    2d0e:	8b 81       	ldd	r24, Y+3	; 0x03
    2d10:	9c 81       	ldd	r25, Y+4	; 0x04
    2d12:	fc 01       	movw	r30, r24
    2d14:	10 82       	st	Z, r1
	pxTopOfStack--;
    2d16:	8b 81       	ldd	r24, Y+3	; 0x03
    2d18:	9c 81       	ldd	r25, Y+4	; 0x04
    2d1a:	01 97       	sbiw	r24, 0x01	; 1
    2d1c:	9c 83       	std	Y+4, r25	; 0x04
    2d1e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    2d20:	8b 81       	ldd	r24, Y+3	; 0x03
    2d22:	9c 81       	ldd	r25, Y+4	; 0x04
    2d24:	22 e0       	ldi	r18, 0x02	; 2
    2d26:	fc 01       	movw	r30, r24
    2d28:	20 83       	st	Z, r18
	pxTopOfStack--;
    2d2a:	8b 81       	ldd	r24, Y+3	; 0x03
    2d2c:	9c 81       	ldd	r25, Y+4	; 0x04
    2d2e:	01 97       	sbiw	r24, 0x01	; 1
    2d30:	9c 83       	std	Y+4, r25	; 0x04
    2d32:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    2d34:	8b 81       	ldd	r24, Y+3	; 0x03
    2d36:	9c 81       	ldd	r25, Y+4	; 0x04
    2d38:	23 e0       	ldi	r18, 0x03	; 3
    2d3a:	fc 01       	movw	r30, r24
    2d3c:	20 83       	st	Z, r18
	pxTopOfStack--;
    2d3e:	8b 81       	ldd	r24, Y+3	; 0x03
    2d40:	9c 81       	ldd	r25, Y+4	; 0x04
    2d42:	01 97       	sbiw	r24, 0x01	; 1
    2d44:	9c 83       	std	Y+4, r25	; 0x04
    2d46:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    2d48:	8b 81       	ldd	r24, Y+3	; 0x03
    2d4a:	9c 81       	ldd	r25, Y+4	; 0x04
    2d4c:	24 e0       	ldi	r18, 0x04	; 4
    2d4e:	fc 01       	movw	r30, r24
    2d50:	20 83       	st	Z, r18
	pxTopOfStack--;
    2d52:	8b 81       	ldd	r24, Y+3	; 0x03
    2d54:	9c 81       	ldd	r25, Y+4	; 0x04
    2d56:	01 97       	sbiw	r24, 0x01	; 1
    2d58:	9c 83       	std	Y+4, r25	; 0x04
    2d5a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    2d5c:	8b 81       	ldd	r24, Y+3	; 0x03
    2d5e:	9c 81       	ldd	r25, Y+4	; 0x04
    2d60:	25 e0       	ldi	r18, 0x05	; 5
    2d62:	fc 01       	movw	r30, r24
    2d64:	20 83       	st	Z, r18
	pxTopOfStack--;
    2d66:	8b 81       	ldd	r24, Y+3	; 0x03
    2d68:	9c 81       	ldd	r25, Y+4	; 0x04
    2d6a:	01 97       	sbiw	r24, 0x01	; 1
    2d6c:	9c 83       	std	Y+4, r25	; 0x04
    2d6e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    2d70:	8b 81       	ldd	r24, Y+3	; 0x03
    2d72:	9c 81       	ldd	r25, Y+4	; 0x04
    2d74:	26 e0       	ldi	r18, 0x06	; 6
    2d76:	fc 01       	movw	r30, r24
    2d78:	20 83       	st	Z, r18
	pxTopOfStack--;
    2d7a:	8b 81       	ldd	r24, Y+3	; 0x03
    2d7c:	9c 81       	ldd	r25, Y+4	; 0x04
    2d7e:	01 97       	sbiw	r24, 0x01	; 1
    2d80:	9c 83       	std	Y+4, r25	; 0x04
    2d82:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    2d84:	8b 81       	ldd	r24, Y+3	; 0x03
    2d86:	9c 81       	ldd	r25, Y+4	; 0x04
    2d88:	27 e0       	ldi	r18, 0x07	; 7
    2d8a:	fc 01       	movw	r30, r24
    2d8c:	20 83       	st	Z, r18
	pxTopOfStack--;
    2d8e:	8b 81       	ldd	r24, Y+3	; 0x03
    2d90:	9c 81       	ldd	r25, Y+4	; 0x04
    2d92:	01 97       	sbiw	r24, 0x01	; 1
    2d94:	9c 83       	std	Y+4, r25	; 0x04
    2d96:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    2d98:	8b 81       	ldd	r24, Y+3	; 0x03
    2d9a:	9c 81       	ldd	r25, Y+4	; 0x04
    2d9c:	28 e0       	ldi	r18, 0x08	; 8
    2d9e:	fc 01       	movw	r30, r24
    2da0:	20 83       	st	Z, r18
	pxTopOfStack--;
    2da2:	8b 81       	ldd	r24, Y+3	; 0x03
    2da4:	9c 81       	ldd	r25, Y+4	; 0x04
    2da6:	01 97       	sbiw	r24, 0x01	; 1
    2da8:	9c 83       	std	Y+4, r25	; 0x04
    2daa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    2dac:	8b 81       	ldd	r24, Y+3	; 0x03
    2dae:	9c 81       	ldd	r25, Y+4	; 0x04
    2db0:	29 e0       	ldi	r18, 0x09	; 9
    2db2:	fc 01       	movw	r30, r24
    2db4:	20 83       	st	Z, r18
	pxTopOfStack--;
    2db6:	8b 81       	ldd	r24, Y+3	; 0x03
    2db8:	9c 81       	ldd	r25, Y+4	; 0x04
    2dba:	01 97       	sbiw	r24, 0x01	; 1
    2dbc:	9c 83       	std	Y+4, r25	; 0x04
    2dbe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    2dc0:	8b 81       	ldd	r24, Y+3	; 0x03
    2dc2:	9c 81       	ldd	r25, Y+4	; 0x04
    2dc4:	20 e1       	ldi	r18, 0x10	; 16
    2dc6:	fc 01       	movw	r30, r24
    2dc8:	20 83       	st	Z, r18
	pxTopOfStack--;
    2dca:	8b 81       	ldd	r24, Y+3	; 0x03
    2dcc:	9c 81       	ldd	r25, Y+4	; 0x04
    2dce:	01 97       	sbiw	r24, 0x01	; 1
    2dd0:	9c 83       	std	Y+4, r25	; 0x04
    2dd2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    2dd4:	8b 81       	ldd	r24, Y+3	; 0x03
    2dd6:	9c 81       	ldd	r25, Y+4	; 0x04
    2dd8:	21 e1       	ldi	r18, 0x11	; 17
    2dda:	fc 01       	movw	r30, r24
    2ddc:	20 83       	st	Z, r18
	pxTopOfStack--;
    2dde:	8b 81       	ldd	r24, Y+3	; 0x03
    2de0:	9c 81       	ldd	r25, Y+4	; 0x04
    2de2:	01 97       	sbiw	r24, 0x01	; 1
    2de4:	9c 83       	std	Y+4, r25	; 0x04
    2de6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    2de8:	8b 81       	ldd	r24, Y+3	; 0x03
    2dea:	9c 81       	ldd	r25, Y+4	; 0x04
    2dec:	22 e1       	ldi	r18, 0x12	; 18
    2dee:	fc 01       	movw	r30, r24
    2df0:	20 83       	st	Z, r18
	pxTopOfStack--;
    2df2:	8b 81       	ldd	r24, Y+3	; 0x03
    2df4:	9c 81       	ldd	r25, Y+4	; 0x04
    2df6:	01 97       	sbiw	r24, 0x01	; 1
    2df8:	9c 83       	std	Y+4, r25	; 0x04
    2dfa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    2dfc:	8b 81       	ldd	r24, Y+3	; 0x03
    2dfe:	9c 81       	ldd	r25, Y+4	; 0x04
    2e00:	23 e1       	ldi	r18, 0x13	; 19
    2e02:	fc 01       	movw	r30, r24
    2e04:	20 83       	st	Z, r18
	pxTopOfStack--;
    2e06:	8b 81       	ldd	r24, Y+3	; 0x03
    2e08:	9c 81       	ldd	r25, Y+4	; 0x04
    2e0a:	01 97       	sbiw	r24, 0x01	; 1
    2e0c:	9c 83       	std	Y+4, r25	; 0x04
    2e0e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    2e10:	8b 81       	ldd	r24, Y+3	; 0x03
    2e12:	9c 81       	ldd	r25, Y+4	; 0x04
    2e14:	24 e1       	ldi	r18, 0x14	; 20
    2e16:	fc 01       	movw	r30, r24
    2e18:	20 83       	st	Z, r18
	pxTopOfStack--;
    2e1a:	8b 81       	ldd	r24, Y+3	; 0x03
    2e1c:	9c 81       	ldd	r25, Y+4	; 0x04
    2e1e:	01 97       	sbiw	r24, 0x01	; 1
    2e20:	9c 83       	std	Y+4, r25	; 0x04
    2e22:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    2e24:	8b 81       	ldd	r24, Y+3	; 0x03
    2e26:	9c 81       	ldd	r25, Y+4	; 0x04
    2e28:	25 e1       	ldi	r18, 0x15	; 21
    2e2a:	fc 01       	movw	r30, r24
    2e2c:	20 83       	st	Z, r18
	pxTopOfStack--;
    2e2e:	8b 81       	ldd	r24, Y+3	; 0x03
    2e30:	9c 81       	ldd	r25, Y+4	; 0x04
    2e32:	01 97       	sbiw	r24, 0x01	; 1
    2e34:	9c 83       	std	Y+4, r25	; 0x04
    2e36:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    2e38:	8b 81       	ldd	r24, Y+3	; 0x03
    2e3a:	9c 81       	ldd	r25, Y+4	; 0x04
    2e3c:	26 e1       	ldi	r18, 0x16	; 22
    2e3e:	fc 01       	movw	r30, r24
    2e40:	20 83       	st	Z, r18
	pxTopOfStack--;
    2e42:	8b 81       	ldd	r24, Y+3	; 0x03
    2e44:	9c 81       	ldd	r25, Y+4	; 0x04
    2e46:	01 97       	sbiw	r24, 0x01	; 1
    2e48:	9c 83       	std	Y+4, r25	; 0x04
    2e4a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    2e4c:	8b 81       	ldd	r24, Y+3	; 0x03
    2e4e:	9c 81       	ldd	r25, Y+4	; 0x04
    2e50:	27 e1       	ldi	r18, 0x17	; 23
    2e52:	fc 01       	movw	r30, r24
    2e54:	20 83       	st	Z, r18
	pxTopOfStack--;
    2e56:	8b 81       	ldd	r24, Y+3	; 0x03
    2e58:	9c 81       	ldd	r25, Y+4	; 0x04
    2e5a:	01 97       	sbiw	r24, 0x01	; 1
    2e5c:	9c 83       	std	Y+4, r25	; 0x04
    2e5e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    2e60:	8b 81       	ldd	r24, Y+3	; 0x03
    2e62:	9c 81       	ldd	r25, Y+4	; 0x04
    2e64:	28 e1       	ldi	r18, 0x18	; 24
    2e66:	fc 01       	movw	r30, r24
    2e68:	20 83       	st	Z, r18
	pxTopOfStack--;
    2e6a:	8b 81       	ldd	r24, Y+3	; 0x03
    2e6c:	9c 81       	ldd	r25, Y+4	; 0x04
    2e6e:	01 97       	sbiw	r24, 0x01	; 1
    2e70:	9c 83       	std	Y+4, r25	; 0x04
    2e72:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    2e74:	8b 81       	ldd	r24, Y+3	; 0x03
    2e76:	9c 81       	ldd	r25, Y+4	; 0x04
    2e78:	29 e1       	ldi	r18, 0x19	; 25
    2e7a:	fc 01       	movw	r30, r24
    2e7c:	20 83       	st	Z, r18
	pxTopOfStack--;
    2e7e:	8b 81       	ldd	r24, Y+3	; 0x03
    2e80:	9c 81       	ldd	r25, Y+4	; 0x04
    2e82:	01 97       	sbiw	r24, 0x01	; 1
    2e84:	9c 83       	std	Y+4, r25	; 0x04
    2e86:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    2e88:	8b 81       	ldd	r24, Y+3	; 0x03
    2e8a:	9c 81       	ldd	r25, Y+4	; 0x04
    2e8c:	20 e2       	ldi	r18, 0x20	; 32
    2e8e:	fc 01       	movw	r30, r24
    2e90:	20 83       	st	Z, r18
	pxTopOfStack--;
    2e92:	8b 81       	ldd	r24, Y+3	; 0x03
    2e94:	9c 81       	ldd	r25, Y+4	; 0x04
    2e96:	01 97       	sbiw	r24, 0x01	; 1
    2e98:	9c 83       	std	Y+4, r25	; 0x04
    2e9a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    2e9c:	8b 81       	ldd	r24, Y+3	; 0x03
    2e9e:	9c 81       	ldd	r25, Y+4	; 0x04
    2ea0:	21 e2       	ldi	r18, 0x21	; 33
    2ea2:	fc 01       	movw	r30, r24
    2ea4:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ea6:	8b 81       	ldd	r24, Y+3	; 0x03
    2ea8:	9c 81       	ldd	r25, Y+4	; 0x04
    2eaa:	01 97       	sbiw	r24, 0x01	; 1
    2eac:	9c 83       	std	Y+4, r25	; 0x04
    2eae:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    2eb0:	8b 81       	ldd	r24, Y+3	; 0x03
    2eb2:	9c 81       	ldd	r25, Y+4	; 0x04
    2eb4:	22 e2       	ldi	r18, 0x22	; 34
    2eb6:	fc 01       	movw	r30, r24
    2eb8:	20 83       	st	Z, r18
	pxTopOfStack--;
    2eba:	8b 81       	ldd	r24, Y+3	; 0x03
    2ebc:	9c 81       	ldd	r25, Y+4	; 0x04
    2ebe:	01 97       	sbiw	r24, 0x01	; 1
    2ec0:	9c 83       	std	Y+4, r25	; 0x04
    2ec2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    2ec4:	8b 81       	ldd	r24, Y+3	; 0x03
    2ec6:	9c 81       	ldd	r25, Y+4	; 0x04
    2ec8:	23 e2       	ldi	r18, 0x23	; 35
    2eca:	fc 01       	movw	r30, r24
    2ecc:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ece:	8b 81       	ldd	r24, Y+3	; 0x03
    2ed0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ed2:	01 97       	sbiw	r24, 0x01	; 1
    2ed4:	9c 83       	std	Y+4, r25	; 0x04
    2ed6:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    2ed8:	8f 81       	ldd	r24, Y+7	; 0x07
    2eda:	98 85       	ldd	r25, Y+8	; 0x08
    2edc:	9a 83       	std	Y+2, r25	; 0x02
    2ede:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2ee0:	29 81       	ldd	r18, Y+1	; 0x01
    2ee2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ee4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ee6:	fc 01       	movw	r30, r24
    2ee8:	20 83       	st	Z, r18
	pxTopOfStack--;
    2eea:	8b 81       	ldd	r24, Y+3	; 0x03
    2eec:	9c 81       	ldd	r25, Y+4	; 0x04
    2eee:	01 97       	sbiw	r24, 0x01	; 1
    2ef0:	9c 83       	std	Y+4, r25	; 0x04
    2ef2:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2ef4:	89 81       	ldd	r24, Y+1	; 0x01
    2ef6:	9a 81       	ldd	r25, Y+2	; 0x02
    2ef8:	89 2f       	mov	r24, r25
    2efa:	99 27       	eor	r25, r25
    2efc:	9a 83       	std	Y+2, r25	; 0x02
    2efe:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2f00:	29 81       	ldd	r18, Y+1	; 0x01
    2f02:	8b 81       	ldd	r24, Y+3	; 0x03
    2f04:	9c 81       	ldd	r25, Y+4	; 0x04
    2f06:	fc 01       	movw	r30, r24
    2f08:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f0a:	8b 81       	ldd	r24, Y+3	; 0x03
    2f0c:	9c 81       	ldd	r25, Y+4	; 0x04
    2f0e:	01 97       	sbiw	r24, 0x01	; 1
    2f10:	9c 83       	std	Y+4, r25	; 0x04
    2f12:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    2f14:	8b 81       	ldd	r24, Y+3	; 0x03
    2f16:	9c 81       	ldd	r25, Y+4	; 0x04
    2f18:	26 e2       	ldi	r18, 0x26	; 38
    2f1a:	fc 01       	movw	r30, r24
    2f1c:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f1e:	8b 81       	ldd	r24, Y+3	; 0x03
    2f20:	9c 81       	ldd	r25, Y+4	; 0x04
    2f22:	01 97       	sbiw	r24, 0x01	; 1
    2f24:	9c 83       	std	Y+4, r25	; 0x04
    2f26:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    2f28:	8b 81       	ldd	r24, Y+3	; 0x03
    2f2a:	9c 81       	ldd	r25, Y+4	; 0x04
    2f2c:	27 e2       	ldi	r18, 0x27	; 39
    2f2e:	fc 01       	movw	r30, r24
    2f30:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f32:	8b 81       	ldd	r24, Y+3	; 0x03
    2f34:	9c 81       	ldd	r25, Y+4	; 0x04
    2f36:	01 97       	sbiw	r24, 0x01	; 1
    2f38:	9c 83       	std	Y+4, r25	; 0x04
    2f3a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    2f3c:	8b 81       	ldd	r24, Y+3	; 0x03
    2f3e:	9c 81       	ldd	r25, Y+4	; 0x04
    2f40:	28 e2       	ldi	r18, 0x28	; 40
    2f42:	fc 01       	movw	r30, r24
    2f44:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f46:	8b 81       	ldd	r24, Y+3	; 0x03
    2f48:	9c 81       	ldd	r25, Y+4	; 0x04
    2f4a:	01 97       	sbiw	r24, 0x01	; 1
    2f4c:	9c 83       	std	Y+4, r25	; 0x04
    2f4e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    2f50:	8b 81       	ldd	r24, Y+3	; 0x03
    2f52:	9c 81       	ldd	r25, Y+4	; 0x04
    2f54:	29 e2       	ldi	r18, 0x29	; 41
    2f56:	fc 01       	movw	r30, r24
    2f58:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f5a:	8b 81       	ldd	r24, Y+3	; 0x03
    2f5c:	9c 81       	ldd	r25, Y+4	; 0x04
    2f5e:	01 97       	sbiw	r24, 0x01	; 1
    2f60:	9c 83       	std	Y+4, r25	; 0x04
    2f62:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    2f64:	8b 81       	ldd	r24, Y+3	; 0x03
    2f66:	9c 81       	ldd	r25, Y+4	; 0x04
    2f68:	20 e3       	ldi	r18, 0x30	; 48
    2f6a:	fc 01       	movw	r30, r24
    2f6c:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f6e:	8b 81       	ldd	r24, Y+3	; 0x03
    2f70:	9c 81       	ldd	r25, Y+4	; 0x04
    2f72:	01 97       	sbiw	r24, 0x01	; 1
    2f74:	9c 83       	std	Y+4, r25	; 0x04
    2f76:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    2f78:	8b 81       	ldd	r24, Y+3	; 0x03
    2f7a:	9c 81       	ldd	r25, Y+4	; 0x04
    2f7c:	21 e3       	ldi	r18, 0x31	; 49
    2f7e:	fc 01       	movw	r30, r24
    2f80:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f82:	8b 81       	ldd	r24, Y+3	; 0x03
    2f84:	9c 81       	ldd	r25, Y+4	; 0x04
    2f86:	01 97       	sbiw	r24, 0x01	; 1
    2f88:	9c 83       	std	Y+4, r25	; 0x04
    2f8a:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    2f8c:	8b 81       	ldd	r24, Y+3	; 0x03
    2f8e:	9c 81       	ldd	r25, Y+4	; 0x04
}
    2f90:	28 96       	adiw	r28, 0x08	; 8
    2f92:	0f b6       	in	r0, 0x3f	; 63
    2f94:	f8 94       	cli
    2f96:	de bf       	out	0x3e, r29	; 62
    2f98:	0f be       	out	0x3f, r0	; 63
    2f9a:	cd bf       	out	0x3d, r28	; 61
    2f9c:	df 91       	pop	r29
    2f9e:	cf 91       	pop	r28
    2fa0:	08 95       	ret

00002fa2 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    2fa2:	cf 93       	push	r28
    2fa4:	df 93       	push	r29
    2fa6:	cd b7       	in	r28, 0x3d	; 61
    2fa8:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    2faa:	0e 94 d5 18 	call	0x31aa	; 0x31aa <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2fae:	a0 91 1c 02 	lds	r26, 0x021C
    2fb2:	b0 91 1d 02 	lds	r27, 0x021D
    2fb6:	cd 91       	ld	r28, X+
    2fb8:	cd bf       	out	0x3d, r28	; 61
    2fba:	dd 91       	ld	r29, X+
    2fbc:	de bf       	out	0x3e, r29	; 62
    2fbe:	ff 91       	pop	r31
    2fc0:	ef 91       	pop	r30
    2fc2:	df 91       	pop	r29
    2fc4:	cf 91       	pop	r28
    2fc6:	bf 91       	pop	r27
    2fc8:	af 91       	pop	r26
    2fca:	9f 91       	pop	r25
    2fcc:	8f 91       	pop	r24
    2fce:	7f 91       	pop	r23
    2fd0:	6f 91       	pop	r22
    2fd2:	5f 91       	pop	r21
    2fd4:	4f 91       	pop	r20
    2fd6:	3f 91       	pop	r19
    2fd8:	2f 91       	pop	r18
    2fda:	1f 91       	pop	r17
    2fdc:	0f 91       	pop	r16
    2fde:	ff 90       	pop	r15
    2fe0:	ef 90       	pop	r14
    2fe2:	df 90       	pop	r13
    2fe4:	cf 90       	pop	r12
    2fe6:	bf 90       	pop	r11
    2fe8:	af 90       	pop	r10
    2fea:	9f 90       	pop	r9
    2fec:	8f 90       	pop	r8
    2fee:	7f 90       	pop	r7
    2ff0:	6f 90       	pop	r6
    2ff2:	5f 90       	pop	r5
    2ff4:	4f 90       	pop	r4
    2ff6:	3f 90       	pop	r3
    2ff8:	2f 90       	pop	r2
    2ffa:	1f 90       	pop	r1
    2ffc:	0f 90       	pop	r0
    2ffe:	0c be       	out	0x3c, r0	; 60
    3000:	0f 90       	pop	r0
    3002:	0b be       	out	0x3b, r0	; 59
    3004:	0f 90       	pop	r0
    3006:	0f be       	out	0x3f, r0	; 63
    3008:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    300a:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    300c:	81 e0       	ldi	r24, 0x01	; 1
}
    300e:	df 91       	pop	r29
    3010:	cf 91       	pop	r28
    3012:	08 95       	ret

00003014 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    3014:	cf 93       	push	r28
    3016:	df 93       	push	r29
    3018:	cd b7       	in	r28, 0x3d	; 61
    301a:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    301c:	df 91       	pop	r29
    301e:	cf 91       	pop	r28
    3020:	08 95       	ret

00003022 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    3022:	0f 92       	push	r0
    3024:	0f b6       	in	r0, 0x3f	; 63
    3026:	f8 94       	cli
    3028:	0f 92       	push	r0
    302a:	0b b6       	in	r0, 0x3b	; 59
    302c:	0f 92       	push	r0
    302e:	0c b6       	in	r0, 0x3c	; 60
    3030:	0f 92       	push	r0
    3032:	1f 92       	push	r1
    3034:	11 24       	eor	r1, r1
    3036:	2f 92       	push	r2
    3038:	3f 92       	push	r3
    303a:	4f 92       	push	r4
    303c:	5f 92       	push	r5
    303e:	6f 92       	push	r6
    3040:	7f 92       	push	r7
    3042:	8f 92       	push	r8
    3044:	9f 92       	push	r9
    3046:	af 92       	push	r10
    3048:	bf 92       	push	r11
    304a:	cf 92       	push	r12
    304c:	df 92       	push	r13
    304e:	ef 92       	push	r14
    3050:	ff 92       	push	r15
    3052:	0f 93       	push	r16
    3054:	1f 93       	push	r17
    3056:	2f 93       	push	r18
    3058:	3f 93       	push	r19
    305a:	4f 93       	push	r20
    305c:	5f 93       	push	r21
    305e:	6f 93       	push	r22
    3060:	7f 93       	push	r23
    3062:	8f 93       	push	r24
    3064:	9f 93       	push	r25
    3066:	af 93       	push	r26
    3068:	bf 93       	push	r27
    306a:	cf 93       	push	r28
    306c:	df 93       	push	r29
    306e:	ef 93       	push	r30
    3070:	ff 93       	push	r31
    3072:	a0 91 1c 02 	lds	r26, 0x021C
    3076:	b0 91 1d 02 	lds	r27, 0x021D
    307a:	0d b6       	in	r0, 0x3d	; 61
    307c:	0d 92       	st	X+, r0
    307e:	0e b6       	in	r0, 0x3e	; 62
    3080:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    3082:	0e 94 31 07 	call	0xe62	; 0xe62 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3086:	a0 91 1c 02 	lds	r26, 0x021C
    308a:	b0 91 1d 02 	lds	r27, 0x021D
    308e:	cd 91       	ld	r28, X+
    3090:	cd bf       	out	0x3d, r28	; 61
    3092:	dd 91       	ld	r29, X+
    3094:	de bf       	out	0x3e, r29	; 62
    3096:	ff 91       	pop	r31
    3098:	ef 91       	pop	r30
    309a:	df 91       	pop	r29
    309c:	cf 91       	pop	r28
    309e:	bf 91       	pop	r27
    30a0:	af 91       	pop	r26
    30a2:	9f 91       	pop	r25
    30a4:	8f 91       	pop	r24
    30a6:	7f 91       	pop	r23
    30a8:	6f 91       	pop	r22
    30aa:	5f 91       	pop	r21
    30ac:	4f 91       	pop	r20
    30ae:	3f 91       	pop	r19
    30b0:	2f 91       	pop	r18
    30b2:	1f 91       	pop	r17
    30b4:	0f 91       	pop	r16
    30b6:	ff 90       	pop	r15
    30b8:	ef 90       	pop	r14
    30ba:	df 90       	pop	r13
    30bc:	cf 90       	pop	r12
    30be:	bf 90       	pop	r11
    30c0:	af 90       	pop	r10
    30c2:	9f 90       	pop	r9
    30c4:	8f 90       	pop	r8
    30c6:	7f 90       	pop	r7
    30c8:	6f 90       	pop	r6
    30ca:	5f 90       	pop	r5
    30cc:	4f 90       	pop	r4
    30ce:	3f 90       	pop	r3
    30d0:	2f 90       	pop	r2
    30d2:	1f 90       	pop	r1
    30d4:	0f 90       	pop	r0
    30d6:	0c be       	out	0x3c, r0	; 60
    30d8:	0f 90       	pop	r0
    30da:	0b be       	out	0x3b, r0	; 59
    30dc:	0f 90       	pop	r0
    30de:	0f be       	out	0x3f, r0	; 63
    30e0:	0f 90       	pop	r0

	asm volatile ( "ret" );
    30e2:	08 95       	ret

000030e4 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    30e4:	0f 92       	push	r0
    30e6:	0f b6       	in	r0, 0x3f	; 63
    30e8:	f8 94       	cli
    30ea:	0f 92       	push	r0
    30ec:	0b b6       	in	r0, 0x3b	; 59
    30ee:	0f 92       	push	r0
    30f0:	0c b6       	in	r0, 0x3c	; 60
    30f2:	0f 92       	push	r0
    30f4:	1f 92       	push	r1
    30f6:	11 24       	eor	r1, r1
    30f8:	2f 92       	push	r2
    30fa:	3f 92       	push	r3
    30fc:	4f 92       	push	r4
    30fe:	5f 92       	push	r5
    3100:	6f 92       	push	r6
    3102:	7f 92       	push	r7
    3104:	8f 92       	push	r8
    3106:	9f 92       	push	r9
    3108:	af 92       	push	r10
    310a:	bf 92       	push	r11
    310c:	cf 92       	push	r12
    310e:	df 92       	push	r13
    3110:	ef 92       	push	r14
    3112:	ff 92       	push	r15
    3114:	0f 93       	push	r16
    3116:	1f 93       	push	r17
    3118:	2f 93       	push	r18
    311a:	3f 93       	push	r19
    311c:	4f 93       	push	r20
    311e:	5f 93       	push	r21
    3120:	6f 93       	push	r22
    3122:	7f 93       	push	r23
    3124:	8f 93       	push	r24
    3126:	9f 93       	push	r25
    3128:	af 93       	push	r26
    312a:	bf 93       	push	r27
    312c:	cf 93       	push	r28
    312e:	df 93       	push	r29
    3130:	ef 93       	push	r30
    3132:	ff 93       	push	r31
    3134:	a0 91 1c 02 	lds	r26, 0x021C
    3138:	b0 91 1d 02 	lds	r27, 0x021D
    313c:	0d b6       	in	r0, 0x3d	; 61
    313e:	0d 92       	st	X+, r0
    3140:	0e b6       	in	r0, 0x3e	; 62
    3142:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    3144:	0e 94 4c 06 	call	0xc98	; 0xc98 <vTaskIncrementTick>
	vTaskSwitchContext();
    3148:	0e 94 31 07 	call	0xe62	; 0xe62 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    314c:	a0 91 1c 02 	lds	r26, 0x021C
    3150:	b0 91 1d 02 	lds	r27, 0x021D
    3154:	cd 91       	ld	r28, X+
    3156:	cd bf       	out	0x3d, r28	; 61
    3158:	dd 91       	ld	r29, X+
    315a:	de bf       	out	0x3e, r29	; 62
    315c:	ff 91       	pop	r31
    315e:	ef 91       	pop	r30
    3160:	df 91       	pop	r29
    3162:	cf 91       	pop	r28
    3164:	bf 91       	pop	r27
    3166:	af 91       	pop	r26
    3168:	9f 91       	pop	r25
    316a:	8f 91       	pop	r24
    316c:	7f 91       	pop	r23
    316e:	6f 91       	pop	r22
    3170:	5f 91       	pop	r21
    3172:	4f 91       	pop	r20
    3174:	3f 91       	pop	r19
    3176:	2f 91       	pop	r18
    3178:	1f 91       	pop	r17
    317a:	0f 91       	pop	r16
    317c:	ff 90       	pop	r15
    317e:	ef 90       	pop	r14
    3180:	df 90       	pop	r13
    3182:	cf 90       	pop	r12
    3184:	bf 90       	pop	r11
    3186:	af 90       	pop	r10
    3188:	9f 90       	pop	r9
    318a:	8f 90       	pop	r8
    318c:	7f 90       	pop	r7
    318e:	6f 90       	pop	r6
    3190:	5f 90       	pop	r5
    3192:	4f 90       	pop	r4
    3194:	3f 90       	pop	r3
    3196:	2f 90       	pop	r2
    3198:	1f 90       	pop	r1
    319a:	0f 90       	pop	r0
    319c:	0c be       	out	0x3c, r0	; 60
    319e:	0f 90       	pop	r0
    31a0:	0b be       	out	0x3b, r0	; 59
    31a2:	0f 90       	pop	r0
    31a4:	0f be       	out	0x3f, r0	; 63
    31a6:	0f 90       	pop	r0

	asm volatile ( "ret" );
    31a8:	08 95       	ret

000031aa <prvSetupTimerInterrupt>:

/*
 * Setup timer 0 or 3 or 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    31aa:	cf 93       	push	r28
    31ac:	df 93       	push	r29
    31ae:	00 d0       	rcall	.+0      	; 0x31b0 <prvSetupTimerInterrupt+0x6>
    31b0:	00 d0       	rcall	.+0      	; 0x31b2 <prvSetupTimerInterrupt+0x8>
    31b2:	cd b7       	in	r28, 0x3d	; 61
    31b4:	de b7       	in	r29, 0x3e	; 62

    /* Using 8bit Timer0 or 16bit Timer1 or Timer3 to generate the tick. */

    // ulCompareMatch 40,000 = 20,000,000 / 500; 20MHz
    // ulCompareMatch 110,592 = 22,118,400 / 200; 22.1184 MHz
    ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    31b6:	80 e0       	ldi	r24, 0x00	; 0
    31b8:	9d e7       	ldi	r25, 0x7D	; 125
    31ba:	a0 e0       	ldi	r26, 0x00	; 0
    31bc:	b0 e0       	ldi	r27, 0x00	; 0
    31be:	89 83       	std	Y+1, r24	; 0x01
    31c0:	9a 83       	std	Y+2, r25	; 0x02
    31c2:	ab 83       	std	Y+3, r26	; 0x03
    31c4:	bc 83       	std	Y+4, r27	; 0x04

    /* We only have 8 or 16 bits so have to scale 64 or 256 to get our required tick rate. */
    //ulCompareMatch = 625 /= portCLOCK_PRESCALER; 20MHz with 64 prescale
    //ulCompareMatch = 108 /= portCLOCK_PRESCALER; 22.1184 MHz with 1024 prescale
    ulCompareMatch /= portCLOCK_PRESCALER;
    31c6:	89 81       	ldd	r24, Y+1	; 0x01
    31c8:	9a 81       	ldd	r25, Y+2	; 0x02
    31ca:	ab 81       	ldd	r26, Y+3	; 0x03
    31cc:	bc 81       	ldd	r27, Y+4	; 0x04
    31ce:	68 94       	set
    31d0:	15 f8       	bld	r1, 5
    31d2:	b6 95       	lsr	r27
    31d4:	a7 95       	ror	r26
    31d6:	97 95       	ror	r25
    31d8:	87 95       	ror	r24
    31da:	16 94       	lsr	r1
    31dc:	d1 f7       	brne	.-12     	; 0x31d2 <prvSetupTimerInterrupt+0x28>
    31de:	89 83       	std	Y+1, r24	; 0x01
    31e0:	9a 83       	std	Y+2, r25	; 0x02
    31e2:	ab 83       	std	Y+3, r26	; 0x03
    31e4:	bc 83       	std	Y+4, r27	; 0x04

    /* Adjust for correct value. */
    ulCompareMatch -= ( unsigned portLONG ) 1;
    31e6:	89 81       	ldd	r24, Y+1	; 0x01
    31e8:	9a 81       	ldd	r25, Y+2	; 0x02
    31ea:	ab 81       	ldd	r26, Y+3	; 0x03
    31ec:	bc 81       	ldd	r27, Y+4	; 0x04
    31ee:	01 97       	sbiw	r24, 0x01	; 1
    31f0:	a1 09       	sbc	r26, r1
    31f2:	b1 09       	sbc	r27, r1
    31f4:	89 83       	std	Y+1, r24	; 0x01
    31f6:	9a 83       	std	Y+2, r25	; 0x02
    31f8:	ab 83       	std	Y+3, r26	; 0x03
    31fa:	bc 83       	std	Y+4, r27	; 0x04

    /* Setup compare match value for compare match A.  Interrupts are disabled
    before this is called so we need not worry here. */
    ucLowByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
    31fc:	89 81       	ldd	r24, Y+1	; 0x01
    31fe:	8d 83       	std	Y+5, r24	; 0x05
    //  OCR3AL = ucLowByte;

    // the HiByte is only needed, if a 16 Bit counter is being utilized
#ifdef portOCRH

    ulCompareMatch >>= 8;
    3200:	89 81       	ldd	r24, Y+1	; 0x01
    3202:	9a 81       	ldd	r25, Y+2	; 0x02
    3204:	ab 81       	ldd	r26, Y+3	; 0x03
    3206:	bc 81       	ldd	r27, Y+4	; 0x04
    3208:	89 2f       	mov	r24, r25
    320a:	9a 2f       	mov	r25, r26
    320c:	ab 2f       	mov	r26, r27
    320e:	bb 27       	eor	r27, r27
    3210:	89 83       	std	Y+1, r24	; 0x01
    3212:	9a 83       	std	Y+2, r25	; 0x02
    3214:	ab 83       	std	Y+3, r26	; 0x03
    3216:	bc 83       	std	Y+4, r27	; 0x04
    ucHighByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
    3218:	89 81       	ldd	r24, Y+1	; 0x01
    321a:	8e 83       	std	Y+6, r24	; 0x06
    portOCRH = ucHighByte;
    321c:	89 e9       	ldi	r24, 0x99	; 153
    321e:	90 e0       	ldi	r25, 0x00	; 0
    3220:	2e 81       	ldd	r18, Y+6	; 0x06
    3222:	fc 01       	movw	r30, r24
    3224:	20 83       	st	Z, r18

#endif

    portOCRL = ucLowByte;
    3226:	88 e9       	ldi	r24, 0x98	; 152
    3228:	90 e0       	ldi	r25, 0x00	; 0
    322a:	2d 81       	ldd	r18, Y+5	; 0x05
    322c:	fc 01       	movw	r30, r24
    322e:	20 83       	st	Z, r18
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	portTCCRb = ucLowByte;

#elif defined( portUSE_TIMER3 )
	/* Setup clock source and compare match behaviour. Assuming  640 / 1280 /1281 / 1284p / 2560 / 2561 (with Timer3) */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    3230:	8b e0       	ldi	r24, 0x0B	; 11
    3232:	8d 83       	std	Y+5, r24	; 0x05
	portTCCRb = ucLowByte;
    3234:	81 e9       	ldi	r24, 0x91	; 145
    3236:	90 e0       	ldi	r25, 0x00	; 0
    3238:	2d 81       	ldd	r18, Y+5	; 0x05
    323a:	fc 01       	movw	r30, r24
    323c:	20 83       	st	Z, r18
#endif

    /* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
    ucLowByte = portTIMSK;
    323e:	81 e7       	ldi	r24, 0x71	; 113
    3240:	90 e0       	ldi	r25, 0x00	; 0
    3242:	fc 01       	movw	r30, r24
    3244:	80 81       	ld	r24, Z
    3246:	8d 83       	std	Y+5, r24	; 0x05
    ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    3248:	8d 81       	ldd	r24, Y+5	; 0x05
    324a:	82 60       	ori	r24, 0x02	; 2
    324c:	8d 83       	std	Y+5, r24	; 0x05
    portTIMSK = ucLowByte;
    324e:	81 e7       	ldi	r24, 0x71	; 113
    3250:	90 e0       	ldi	r25, 0x00	; 0
    3252:	2d 81       	ldd	r18, Y+5	; 0x05
    3254:	fc 01       	movw	r30, r24
    3256:	20 83       	st	Z, r18

}
    3258:	26 96       	adiw	r28, 0x06	; 6
    325a:	0f b6       	in	r0, 0x3f	; 63
    325c:	f8 94       	cli
    325e:	de bf       	out	0x3e, r29	; 62
    3260:	0f be       	out	0x3f, r0	; 63
    3262:	cd bf       	out	0x3d, r28	; 61
    3264:	df 91       	pop	r29
    3266:	cf 91       	pop	r28
    3268:	08 95       	ret

0000326a <__vector_32>:

	#elif defined( portUSE_TIMER3 )
		#warning "Timer3 used for PRE-EMPTIVE scheduler."
		ISR(TIMER3_COMPA_vect, ISR_NAKED)
		{
			vPortYieldFromTick();
    326a:	0e 94 72 18 	call	0x30e4	; 0x30e4 <vPortYieldFromTick>
			asm volatile ( "reti" );
    326e:	18 95       	reti

00003270 <USART_Init>:
*  the specified baud rate and clk speed.
*
* Param buadin: The desired Baud rate.
* Param clk_seedin: The clk speed of the ATmega328p
************************************/
void USART_Init(uint16_t baudin, uint32_t clk_speedin) {
    3270:	cf 93       	push	r28
    3272:	df 93       	push	r29
    3274:	cd b7       	in	r28, 0x3d	; 61
    3276:	de b7       	in	r29, 0x3e	; 62
    3278:	2e 97       	sbiw	r28, 0x0e	; 14
    327a:	0f b6       	in	r0, 0x3f	; 63
    327c:	f8 94       	cli
    327e:	de bf       	out	0x3e, r29	; 62
    3280:	0f be       	out	0x3f, r0	; 63
    3282:	cd bf       	out	0x3d, r28	; 61
    3284:	9e 83       	std	Y+6, r25	; 0x06
    3286:	8d 83       	std	Y+5, r24	; 0x05
    3288:	4f 83       	std	Y+7, r20	; 0x07
    328a:	58 87       	std	Y+8, r21	; 0x08
    328c:	69 87       	std	Y+9, r22	; 0x09
    328e:	7a 87       	std	Y+10, r23	; 0x0a
    USART_WriteQueue = xQueueCreate(32,sizeof(uint8_t));
    3290:	40 e0       	ldi	r20, 0x00	; 0
    3292:	61 e0       	ldi	r22, 0x01	; 1
    3294:	80 e2       	ldi	r24, 0x20	; 32
    3296:	0e 94 14 0c 	call	0x1828	; 0x1828 <xQueueGenericCreate>
    329a:	90 93 b7 1a 	sts	0x1AB7, r25
    329e:	80 93 b6 1a 	sts	0x1AB6, r24
    USART_ReadQueue = xQueueCreate(8,sizeof(uint8_t));
    32a2:	40 e0       	ldi	r20, 0x00	; 0
    32a4:	61 e0       	ldi	r22, 0x01	; 1
    32a6:	88 e0       	ldi	r24, 0x08	; 8
    32a8:	0e 94 14 0c 	call	0x1828	; 0x1828 <xQueueGenericCreate>
    32ac:	90 93 b5 1a 	sts	0x1AB5, r25
    32b0:	80 93 b4 1a 	sts	0x1AB4, r24

    uint32_t ubrr = clk_speedin/(16UL)/baudin-1;
    32b4:	8f 81       	ldd	r24, Y+7	; 0x07
    32b6:	98 85       	ldd	r25, Y+8	; 0x08
    32b8:	a9 85       	ldd	r26, Y+9	; 0x09
    32ba:	ba 85       	ldd	r27, Y+10	; 0x0a
    32bc:	68 94       	set
    32be:	13 f8       	bld	r1, 3
    32c0:	b6 95       	lsr	r27
    32c2:	a7 95       	ror	r26
    32c4:	97 95       	ror	r25
    32c6:	87 95       	ror	r24
    32c8:	16 94       	lsr	r1
    32ca:	d1 f7       	brne	.-12     	; 0x32c0 <USART_Init+0x50>
    32cc:	2d 81       	ldd	r18, Y+5	; 0x05
    32ce:	3e 81       	ldd	r19, Y+6	; 0x06
    32d0:	99 01       	movw	r18, r18
    32d2:	40 e0       	ldi	r20, 0x00	; 0
    32d4:	50 e0       	ldi	r21, 0x00	; 0
    32d6:	bc 01       	movw	r22, r24
    32d8:	cd 01       	movw	r24, r26
    32da:	0e 94 83 1d 	call	0x3b06	; 0x3b06 <__udivmodsi4>
    32de:	da 01       	movw	r26, r20
    32e0:	c9 01       	movw	r24, r18
    32e2:	01 97       	sbiw	r24, 0x01	; 1
    32e4:	a1 09       	sbc	r26, r1
    32e6:	b1 09       	sbc	r27, r1
    32e8:	89 83       	std	Y+1, r24	; 0x01
    32ea:	9a 83       	std	Y+2, r25	; 0x02
    32ec:	ab 83       	std	Y+3, r26	; 0x03
    32ee:	bc 83       	std	Y+4, r27	; 0x04
    UBRR1H = (unsigned char)(ubrr>>8) ;// & 0x7F;
    32f0:	2d ec       	ldi	r18, 0xCD	; 205
    32f2:	30 e0       	ldi	r19, 0x00	; 0
    32f4:	89 81       	ldd	r24, Y+1	; 0x01
    32f6:	9a 81       	ldd	r25, Y+2	; 0x02
    32f8:	ab 81       	ldd	r26, Y+3	; 0x03
    32fa:	bc 81       	ldd	r27, Y+4	; 0x04
    32fc:	89 2f       	mov	r24, r25
    32fe:	9a 2f       	mov	r25, r26
    3300:	ab 2f       	mov	r26, r27
    3302:	bb 27       	eor	r27, r27
    3304:	f9 01       	movw	r30, r18
    3306:	80 83       	st	Z, r24
    UBRR1L = (unsigned char)ubrr;
    3308:	8c ec       	ldi	r24, 0xCC	; 204
    330a:	90 e0       	ldi	r25, 0x00	; 0
    330c:	29 81       	ldd	r18, Y+1	; 0x01
    330e:	fc 01       	movw	r30, r24
    3310:	20 83       	st	Z, r18
    
    //UBRR0H = 0; //115200
    //UBRR0L = 8;

    /* Enable receiver and transmitter */
    UCSR1B = (1<<RXEN1)|(1<<TXEN1);
    3312:	89 ec       	ldi	r24, 0xC9	; 201
    3314:	90 e0       	ldi	r25, 0x00	; 0
    3316:	28 e1       	ldi	r18, 0x18	; 24
    3318:	fc 01       	movw	r30, r24
    331a:	20 83       	st	Z, r18
    /* Set frame format: 8data, 1stop bit */
    UCSR1C = (1<<UCSZ11)|(1<<UCSZ10);
    331c:	8a ec       	ldi	r24, 0xCA	; 202
    331e:	90 e0       	ldi	r25, 0x00	; 0
    3320:	26 e0       	ldi	r18, 0x06	; 6
    3322:	fc 01       	movw	r30, r24
    3324:	20 83       	st	Z, r18
	// clear U2X0 for Synchronous operation
    UCSR1A &= ~(1<<U2X1);
    3326:	88 ec       	ldi	r24, 0xC8	; 200
    3328:	90 e0       	ldi	r25, 0x00	; 0
    332a:	28 ec       	ldi	r18, 0xC8	; 200
    332c:	30 e0       	ldi	r19, 0x00	; 0
    332e:	f9 01       	movw	r30, r18
    3330:	20 81       	ld	r18, Z
    3332:	2d 7f       	andi	r18, 0xFD	; 253
    3334:	fc 01       	movw	r30, r24
    3336:	20 83       	st	Z, r18

    //UCSR0B |= (1<<UDRIE0);

}
    3338:	2e 96       	adiw	r28, 0x0e	; 14
    333a:	0f b6       	in	r0, 0x3f	; 63
    333c:	f8 94       	cli
    333e:	de bf       	out	0x3e, r29	; 62
    3340:	0f be       	out	0x3f, r0	; 63
    3342:	cd bf       	out	0x3d, r28	; 61
    3344:	df 91       	pop	r29
    3346:	cf 91       	pop	r28
    3348:	08 95       	ret

0000334a <USART_Write>:

/*the send function will put 8bits on the trans line. */
void USART_Write(uint8_t data) {
    334a:	cf 93       	push	r28
    334c:	df 93       	push	r29
    334e:	1f 92       	push	r1
    3350:	cd b7       	in	r28, 0x3d	; 61
    3352:	de b7       	in	r29, 0x3e	; 62
    3354:	89 83       	std	Y+1, r24	; 0x01
		/* Wait for empty transmit buffer */
		while ( !( UCSR0A & (1<<UDRE0)) )
    3356:	00 00       	nop
    3358:	80 ec       	ldi	r24, 0xC0	; 192
    335a:	90 e0       	ldi	r25, 0x00	; 0
    335c:	fc 01       	movw	r30, r24
    335e:	80 81       	ld	r24, Z
    3360:	88 2f       	mov	r24, r24
    3362:	90 e0       	ldi	r25, 0x00	; 0
    3364:	80 72       	andi	r24, 0x20	; 32
    3366:	99 27       	eor	r25, r25
    3368:	00 97       	sbiw	r24, 0x00	; 0
    336a:	b1 f3       	breq	.-20     	; 0x3358 <USART_Write+0xe>
		;
		/* Put data into buffer, sends the data */
		UDR0 = data;
    336c:	86 ec       	ldi	r24, 0xC6	; 198
    336e:	90 e0       	ldi	r25, 0x00	; 0
    3370:	29 81       	ldd	r18, Y+1	; 0x01
    3372:	fc 01       	movw	r30, r24
    3374:	20 83       	st	Z, r18
}
    3376:	0f 90       	pop	r0
    3378:	df 91       	pop	r29
    337a:	cf 91       	pop	r28
    337c:	08 95       	ret

0000337e <USART_Write_Unprotected>:

/*the send function will put 8bits on the trans line. */
void USART_Write_Unprotected(uint8_t data) {
    337e:	cf 93       	push	r28
    3380:	df 93       	push	r29
    3382:	1f 92       	push	r1
    3384:	cd b7       	in	r28, 0x3d	; 61
    3386:	de b7       	in	r29, 0x3e	; 62
    3388:	89 83       	std	Y+1, r24	; 0x01
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)) )
    338a:	00 00       	nop
    338c:	80 ec       	ldi	r24, 0xC0	; 192
    338e:	90 e0       	ldi	r25, 0x00	; 0
    3390:	fc 01       	movw	r30, r24
    3392:	80 81       	ld	r24, Z
    3394:	88 2f       	mov	r24, r24
    3396:	90 e0       	ldi	r25, 0x00	; 0
    3398:	80 72       	andi	r24, 0x20	; 32
    339a:	99 27       	eor	r25, r25
    339c:	00 97       	sbiw	r24, 0x00	; 0
    339e:	b1 f3       	breq	.-20     	; 0x338c <USART_Write_Unprotected+0xe>
	;
	/* Put data into buffer, sends the data */
	UDR0 = data;
    33a0:	86 ec       	ldi	r24, 0xC6	; 198
    33a2:	90 e0       	ldi	r25, 0x00	; 0
    33a4:	29 81       	ldd	r18, Y+1	; 0x01
    33a6:	fc 01       	movw	r30, r24
    33a8:	20 83       	st	Z, r18
}
    33aa:	0f 90       	pop	r0
    33ac:	df 91       	pop	r29
    33ae:	cf 91       	pop	r28
    33b0:	08 95       	ret

000033b2 <USART_Read>:
Therefore you may not get control back after this is called 
until a much later time. It may be helpful to use the 
istheredata() function to check before calling this function
        @return 8bit data packet from sender
*/
uint8_t USART_Read(void) {
    33b2:	cf 93       	push	r28
    33b4:	df 93       	push	r29
    33b6:	cd b7       	in	r28, 0x3d	; 61
    33b8:	de b7       	in	r29, 0x3e	; 62
    /* Wait for data to be received */
    while ( !(UCSR0A & (1<<RXC0)) )
    33ba:	00 00       	nop
    33bc:	80 ec       	ldi	r24, 0xC0	; 192
    33be:	90 e0       	ldi	r25, 0x00	; 0
    33c0:	fc 01       	movw	r30, r24
    33c2:	80 81       	ld	r24, Z
    33c4:	88 23       	and	r24, r24
    33c6:	d4 f7       	brge	.-12     	; 0x33bc <USART_Read+0xa>
        ;
    /* Get and return received data from buffer */
    return UDR0;
    33c8:	86 ec       	ldi	r24, 0xC6	; 198
    33ca:	90 e0       	ldi	r25, 0x00	; 0
    33cc:	fc 01       	movw	r30, r24
    33ce:	80 81       	ld	r24, Z
}
    33d0:	df 91       	pop	r29
    33d2:	cf 91       	pop	r28
    33d4:	08 95       	ret

000033d6 <ISR>:


ISR(USART1_RX_vect){
    33d6:	cf 93       	push	r28
    33d8:	df 93       	push	r29
    33da:	00 d0       	rcall	.+0      	; 0x33dc <ISR+0x6>
    33dc:	cd b7       	in	r28, 0x3d	; 61
    33de:	de b7       	in	r29, 0x3e	; 62
    33e0:	9b 83       	std	Y+3, r25	; 0x03
    33e2:	8a 83       	std	Y+2, r24	; 0x02
    uint8_t data;
    data = UDR1;
    33e4:	8e ec       	ldi	r24, 0xCE	; 206
    33e6:	90 e0       	ldi	r25, 0x00	; 0
    33e8:	fc 01       	movw	r30, r24
    33ea:	80 81       	ld	r24, Z
    33ec:	89 83       	std	Y+1, r24	; 0x01
    xQueueSendToBackFromISR(USART_ReadQueue,&data,NULL);
    33ee:	80 91 b4 1a 	lds	r24, 0x1AB4
    33f2:	90 91 b5 1a 	lds	r25, 0x1AB5
    33f6:	20 e0       	ldi	r18, 0x00	; 0
    33f8:	40 e0       	ldi	r20, 0x00	; 0
    33fa:	50 e0       	ldi	r21, 0x00	; 0
    33fc:	be 01       	movw	r22, r28
    33fe:	6f 5f       	subi	r22, 0xFF	; 255
    3400:	7f 4f       	sbci	r23, 0xFF	; 255
    3402:	0e 94 6f 0d 	call	0x1ade	; 0x1ade <xQueueGenericSendFromISR>
}
    3406:	0f 90       	pop	r0
    3408:	0f 90       	pop	r0
    340a:	0f 90       	pop	r0
    340c:	df 91       	pop	r29
    340e:	cf 91       	pop	r28
    3410:	08 95       	ret

00003412 <USART_AddToQueue>:

void USART_AddToQueue(uint8_t data){
    3412:	cf 93       	push	r28
    3414:	df 93       	push	r29
    3416:	1f 92       	push	r1
    3418:	cd b7       	in	r28, 0x3d	; 61
    341a:	de b7       	in	r29, 0x3e	; 62
    341c:	89 83       	std	Y+1, r24	; 0x01
    
    xQueueSendToBack(USART_WriteQueue,&data,portMAX_DELAY);
    341e:	80 91 b6 1a 	lds	r24, 0x1AB6
    3422:	90 91 b7 1a 	lds	r25, 0x1AB7
    3426:	20 e0       	ldi	r18, 0x00	; 0
    3428:	4f ef       	ldi	r20, 0xFF	; 255
    342a:	5f ef       	ldi	r21, 0xFF	; 255
    342c:	be 01       	movw	r22, r28
    342e:	6f 5f       	subi	r22, 0xFF	; 255
    3430:	7f 4f       	sbci	r23, 0xFF	; 255
    3432:	0e 94 cb 0c 	call	0x1996	; 0x1996 <xQueueGenericSend>

}
    3436:	0f 90       	pop	r0
    3438:	df 91       	pop	r29
    343a:	cf 91       	pop	r28
    343c:	08 95       	ret

0000343e <USART_TransmitString>:

void USART_TransmitString(char* str){
    343e:	cf 93       	push	r28
    3440:	df 93       	push	r29
    3442:	1f 92       	push	r1
    3444:	1f 92       	push	r1
    3446:	cd b7       	in	r28, 0x3d	; 61
    3448:	de b7       	in	r29, 0x3e	; 62
    344a:	9a 83       	std	Y+2, r25	; 0x02
    344c:	89 83       	std	Y+1, r24	; 0x01
    while(*str) {
    344e:	0b c0       	rjmp	.+22     	; 0x3466 <USART_TransmitString+0x28>
        USART_AddToQueue(*str);
    3450:	89 81       	ldd	r24, Y+1	; 0x01
    3452:	9a 81       	ldd	r25, Y+2	; 0x02
    3454:	fc 01       	movw	r30, r24
    3456:	80 81       	ld	r24, Z
    3458:	0e 94 09 1a 	call	0x3412	; 0x3412 <USART_AddToQueue>
        str++;
    345c:	89 81       	ldd	r24, Y+1	; 0x01
    345e:	9a 81       	ldd	r25, Y+2	; 0x02
    3460:	01 96       	adiw	r24, 0x01	; 1
    3462:	9a 83       	std	Y+2, r25	; 0x02
    3464:	89 83       	std	Y+1, r24	; 0x01
    xQueueSendToBack(USART_WriteQueue,&data,portMAX_DELAY);

}

void USART_TransmitString(char* str){
    while(*str) {
    3466:	89 81       	ldd	r24, Y+1	; 0x01
    3468:	9a 81       	ldd	r25, Y+2	; 0x02
    346a:	fc 01       	movw	r30, r24
    346c:	80 81       	ld	r24, Z
    346e:	88 23       	and	r24, r24
    3470:	79 f7       	brne	.-34     	; 0x3450 <USART_TransmitString+0x12>
        USART_AddToQueue(*str);
        str++;
    }
}
    3472:	0f 90       	pop	r0
    3474:	0f 90       	pop	r0
    3476:	df 91       	pop	r29
    3478:	cf 91       	pop	r28
    347a:	08 95       	ret

0000347c <vTaskUARTWrite>:

void vTaskUARTWrite(void *pvParameters)
{
    347c:	cf 93       	push	r28
    347e:	df 93       	push	r29
    3480:	00 d0       	rcall	.+0      	; 0x3482 <vTaskUARTWrite+0x6>
    3482:	cd b7       	in	r28, 0x3d	; 61
    3484:	de b7       	in	r29, 0x3e	; 62
    3486:	9b 83       	std	Y+3, r25	; 0x03
    3488:	8a 83       	std	Y+2, r24	; 0x02
    uint8_t data;
    while(1){
        while(xQueueReceive(USART_WriteQueue,&data,portMAX_DELAY)==pdFALSE);
    348a:	00 00       	nop
    348c:	80 91 b6 1a 	lds	r24, 0x1AB6
    3490:	90 91 b7 1a 	lds	r25, 0x1AB7
    3494:	20 e0       	ldi	r18, 0x00	; 0
    3496:	4f ef       	ldi	r20, 0xFF	; 255
    3498:	5f ef       	ldi	r21, 0xFF	; 255
    349a:	be 01       	movw	r22, r28
    349c:	6f 5f       	subi	r22, 0xFF	; 255
    349e:	7f 4f       	sbci	r23, 0xFF	; 255
    34a0:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <xQueueGenericReceive>
    34a4:	88 23       	and	r24, r24
    34a6:	91 f3       	breq	.-28     	; 0x348c <vTaskUARTWrite+0x10>

        while(!(UCSR1A & (1<<UDRE1))) vTaskDelay(1);
    34a8:	04 c0       	rjmp	.+8      	; 0x34b2 <vTaskUARTWrite+0x36>
    34aa:	81 e0       	ldi	r24, 0x01	; 1
    34ac:	90 e0       	ldi	r25, 0x00	; 0
    34ae:	0e 94 b3 03 	call	0x766	; 0x766 <vTaskDelay>
    34b2:	88 ec       	ldi	r24, 0xC8	; 200
    34b4:	90 e0       	ldi	r25, 0x00	; 0
    34b6:	fc 01       	movw	r30, r24
    34b8:	80 81       	ld	r24, Z
    34ba:	88 2f       	mov	r24, r24
    34bc:	90 e0       	ldi	r25, 0x00	; 0
    34be:	80 72       	andi	r24, 0x20	; 32
    34c0:	99 27       	eor	r25, r25
    34c2:	00 97       	sbiw	r24, 0x00	; 0
    34c4:	91 f3       	breq	.-28     	; 0x34aa <vTaskUARTWrite+0x2e>
        UDR1 = data;
    34c6:	8e ec       	ldi	r24, 0xCE	; 206
    34c8:	90 e0       	ldi	r25, 0x00	; 0
    34ca:	29 81       	ldd	r18, Y+1	; 0x01
    34cc:	fc 01       	movw	r30, r24
    34ce:	20 83       	st	Z, r18

    }
    34d0:	00 00       	nop

void vTaskUARTWrite(void *pvParameters)
{
    uint8_t data;
    while(1){
        while(xQueueReceive(USART_WriteQueue,&data,portMAX_DELAY)==pdFALSE);
    34d2:	db cf       	rjmp	.-74     	; 0x348a <vTaskUARTWrite+0xe>

000034d4 <vTaskUARTRead>:
        UDR1 = data;

    }
}

void vTaskUARTRead(void *pvParameters){
    34d4:	cf 93       	push	r28
    34d6:	df 93       	push	r29
    34d8:	cd b7       	in	r28, 0x3d	; 61
    34da:	de b7       	in	r29, 0x3e	; 62
    34dc:	2e 97       	sbiw	r28, 0x0e	; 14
    34de:	0f b6       	in	r0, 0x3f	; 63
    34e0:	f8 94       	cli
    34e2:	de bf       	out	0x3e, r29	; 62
    34e4:	0f be       	out	0x3f, r0	; 63
    34e6:	cd bf       	out	0x3d, r28	; 61
    34e8:	9e 87       	std	Y+14, r25	; 0x0e
    34ea:	8d 87       	std	Y+13, r24	; 0x0d
    //Command command;
    //Response response;

    while(1){
        //Get Header
        bytesRecieved = 0;
    34ec:	19 82       	std	Y+1, r1	; 0x01
        while(bytesRecieved < 4){
    34ee:	1a c0       	rjmp	.+52     	; 0x3524 <vTaskUARTRead+0x50>
            if((UCSR1A & (1<<RXC1))){
    34f0:	88 ec       	ldi	r24, 0xC8	; 200
    34f2:	90 e0       	ldi	r25, 0x00	; 0
    34f4:	fc 01       	movw	r30, r24
    34f6:	80 81       	ld	r24, Z
    34f8:	88 23       	and	r24, r24
    34fa:	a4 f4       	brge	.+40     	; 0x3524 <vTaskUARTRead+0x50>
                rxData = UDR1;
    34fc:	8e ec       	ldi	r24, 0xCE	; 206
    34fe:	90 e0       	ldi	r25, 0x00	; 0
    3500:	fc 01       	movw	r30, r24
    3502:	80 81       	ld	r24, Z
    3504:	8b 83       	std	Y+3, r24	; 0x03
                //PORTB = 0;
            //if(xQueueReceive(USART_ReadQueue,&rxData,portMAX_DELAY) == pdTRUE){
                buffer[bytesRecieved] = rxData;
    3506:	89 81       	ldd	r24, Y+1	; 0x01
    3508:	99 27       	eor	r25, r25
    350a:	87 fd       	sbrc	r24, 7
    350c:	90 95       	com	r25
    350e:	9e 01       	movw	r18, r28
    3510:	2b 5f       	subi	r18, 0xFB	; 251
    3512:	3f 4f       	sbci	r19, 0xFF	; 255
    3514:	82 0f       	add	r24, r18
    3516:	93 1f       	adc	r25, r19
    3518:	2b 81       	ldd	r18, Y+3	; 0x03
    351a:	fc 01       	movw	r30, r24
    351c:	20 83       	st	Z, r18
                //USART_AddToQueue(rxData);
                bytesRecieved++;
    351e:	89 81       	ldd	r24, Y+1	; 0x01
    3520:	8f 5f       	subi	r24, 0xFF	; 255
    3522:	89 83       	std	Y+1, r24	; 0x01
    //Response response;

    while(1){
        //Get Header
        bytesRecieved = 0;
        while(bytesRecieved < 4){
    3524:	89 81       	ldd	r24, Y+1	; 0x01
    3526:	84 30       	cpi	r24, 0x04	; 4
    3528:	1c f3       	brlt	.-58     	; 0x34f0 <vTaskUARTRead+0x1c>
                buffer[bytesRecieved] = rxData;
                //USART_AddToQueue(rxData);
                bytesRecieved++;
            }
        }
        if(calcChecksum(buffer,3) != buffer[3]){
    352a:	ce 01       	movw	r24, r28
    352c:	05 96       	adiw	r24, 0x05	; 5
    352e:	63 e0       	ldi	r22, 0x03	; 3
    3530:	0e 94 0e 1b 	call	0x361c	; 0x361c <calcChecksum>
    3534:	98 2f       	mov	r25, r24
    3536:	88 85       	ldd	r24, Y+8	; 0x08
    3538:	98 17       	cp	r25, r24
    353a:	19 f0       	breq	.+6      	; 0x3542 <vTaskUARTRead+0x6e>
            sendNACK();
    353c:	0e 94 04 1b 	call	0x3608	; 0x3608 <sendNACK>
    3540:	58 c0       	rjmp	.+176    	; 0x35f2 <vTaskUARTRead+0x11e>
        } else {
            sendACK();
    3542:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <sendACK>
            bytesRecieved = 0;
    3546:	19 82       	std	Y+1, r1	; 0x01
            //command.groupID = buffer[0];
            //command.cmd = buffer[1];
            //command.crc = buffer[3];
            size = buffer[2];
    3548:	8f 81       	ldd	r24, Y+7	; 0x07
    354a:	8c 83       	std	Y+4, r24	; 0x04
            timeout = 0;
    354c:	1a 82       	std	Y+2, r1	; 0x02
            while(1){
                if(size == 0){
                    //processCommand(&command,&response);
                }
                while((bytesRecieved < size+1) && (timeout < 50)){  //1 for crc
    354e:	1d c0       	rjmp	.+58     	; 0x358a <vTaskUARTRead+0xb6>
                    if(UCSR1A & (1<<RXC1)){
    3550:	88 ec       	ldi	r24, 0xC8	; 200
    3552:	90 e0       	ldi	r25, 0x00	; 0
    3554:	fc 01       	movw	r30, r24
    3556:	80 81       	ld	r24, Z
    3558:	88 23       	and	r24, r24
    355a:	ac f4       	brge	.+42     	; 0x3586 <vTaskUARTRead+0xb2>
                        rxData = UDR1;
    355c:	8e ec       	ldi	r24, 0xCE	; 206
    355e:	90 e0       	ldi	r25, 0x00	; 0
    3560:	fc 01       	movw	r30, r24
    3562:	80 81       	ld	r24, Z
    3564:	8b 83       	std	Y+3, r24	; 0x03

                        //PORTB = 0xFF;
                    //if(xQueueReceive(USART_ReadQueue,&rxData,portMAX_DELAY) == pdTRUE){
                        buffer[bytesRecieved] = rxData;
    3566:	89 81       	ldd	r24, Y+1	; 0x01
    3568:	99 27       	eor	r25, r25
    356a:	87 fd       	sbrc	r24, 7
    356c:	90 95       	com	r25
    356e:	9e 01       	movw	r18, r28
    3570:	2b 5f       	subi	r18, 0xFB	; 251
    3572:	3f 4f       	sbci	r19, 0xFF	; 255
    3574:	82 0f       	add	r24, r18
    3576:	93 1f       	adc	r25, r19
    3578:	2b 81       	ldd	r18, Y+3	; 0x03
    357a:	fc 01       	movw	r30, r24
    357c:	20 83       	st	Z, r18
                        bytesRecieved++;
    357e:	89 81       	ldd	r24, Y+1	; 0x01
    3580:	8f 5f       	subi	r24, 0xFF	; 255
    3582:	89 83       	std	Y+1, r24	; 0x01
    3584:	02 c0       	rjmp	.+4      	; 0x358a <vTaskUARTRead+0xb6>
                    } else {
                        //timeout++;
                        timeout = 1;
    3586:	81 e0       	ldi	r24, 0x01	; 1
    3588:	8a 83       	std	Y+2, r24	; 0x02
            timeout = 0;
            while(1){
                if(size == 0){
                    //processCommand(&command,&response);
                }
                while((bytesRecieved < size+1) && (timeout < 50)){  //1 for crc
    358a:	89 81       	ldd	r24, Y+1	; 0x01
    358c:	28 2f       	mov	r18, r24
    358e:	33 27       	eor	r19, r19
    3590:	27 fd       	sbrc	r18, 7
    3592:	30 95       	com	r19
    3594:	8c 81       	ldd	r24, Y+4	; 0x04
    3596:	99 27       	eor	r25, r25
    3598:	87 fd       	sbrc	r24, 7
    359a:	90 95       	com	r25
    359c:	01 96       	adiw	r24, 0x01	; 1
    359e:	28 17       	cp	r18, r24
    35a0:	39 07       	cpc	r19, r25
    35a2:	1c f4       	brge	.+6      	; 0x35aa <vTaskUARTRead+0xd6>
    35a4:	8a 81       	ldd	r24, Y+2	; 0x02
    35a6:	82 33       	cpi	r24, 0x32	; 50
    35a8:	9c f2       	brlt	.-90     	; 0x3550 <vTaskUARTRead+0x7c>
                    } else {
                        //timeout++;
                        timeout = 1;
                    }
                } 
                if(timeout >= 50){
    35aa:	8a 81       	ldd	r24, Y+2	; 0x02
    35ac:	82 33       	cpi	r24, 0x32	; 50
    35ae:	0c f0       	brlt	.+2      	; 0x35b2 <vTaskUARTRead+0xde>
                    break;
    35b0:	20 c0       	rjmp	.+64     	; 0x35f2 <vTaskUARTRead+0x11e>
                }
                if(calcChecksum(buffer,size) != buffer[size]){
    35b2:	2c 81       	ldd	r18, Y+4	; 0x04
    35b4:	ce 01       	movw	r24, r28
    35b6:	05 96       	adiw	r24, 0x05	; 5
    35b8:	62 2f       	mov	r22, r18
    35ba:	0e 94 0e 1b 	call	0x361c	; 0x361c <calcChecksum>
    35be:	48 2f       	mov	r20, r24
    35c0:	8c 81       	ldd	r24, Y+4	; 0x04
    35c2:	99 27       	eor	r25, r25
    35c4:	87 fd       	sbrc	r24, 7
    35c6:	90 95       	com	r25
    35c8:	9e 01       	movw	r18, r28
    35ca:	2b 5f       	subi	r18, 0xFB	; 251
    35cc:	3f 4f       	sbci	r19, 0xFF	; 255
    35ce:	82 0f       	add	r24, r18
    35d0:	93 1f       	adc	r25, r19
    35d2:	fc 01       	movw	r30, r24
    35d4:	80 81       	ld	r24, Z
    35d6:	48 17       	cp	r20, r24
    35d8:	21 f0       	breq	.+8      	; 0x35e2 <vTaskUARTRead+0x10e>
                    sendNACK();
    35da:	0e 94 04 1b 	call	0x3608	; 0x3608 <sendNACK>
                    bytesRecieved = 0;
    35de:	19 82       	std	Y+1, r1	; 0x01
                    sendACK();
                    //memcpy(command.payload,buffer,size);
                    //processCommand(&command,&response);
                    break;
                }
            }
    35e0:	b6 cf       	rjmp	.-148    	; 0x354e <vTaskUARTRead+0x7a>
                }
                if(calcChecksum(buffer,size) != buffer[size]){
                    sendNACK();
                    bytesRecieved = 0;
                } else {
                    PORTB = buffer[0];
    35e2:	85 e2       	ldi	r24, 0x25	; 37
    35e4:	90 e0       	ldi	r25, 0x00	; 0
    35e6:	2d 81       	ldd	r18, Y+5	; 0x05
    35e8:	fc 01       	movw	r30, r24
    35ea:	20 83       	st	Z, r18
                    sendACK();
    35ec:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <sendACK>
                    //memcpy(command.payload,buffer,size);
                    //processCommand(&command,&response);
                    break;
    35f0:	00 00       	nop
                }
            }
        }

    }
    35f2:	7c cf       	rjmp	.-264    	; 0x34ec <vTaskUARTRead+0x18>

000035f4 <sendACK>:

}

void sendACK(){
    35f4:	cf 93       	push	r28
    35f6:	df 93       	push	r29
    35f8:	cd b7       	in	r28, 0x3d	; 61
    35fa:	de b7       	in	r29, 0x3e	; 62
    USART_AddToQueue(0xFF);
    35fc:	8f ef       	ldi	r24, 0xFF	; 255
    35fe:	0e 94 09 1a 	call	0x3412	; 0x3412 <USART_AddToQueue>
}
    3602:	df 91       	pop	r29
    3604:	cf 91       	pop	r28
    3606:	08 95       	ret

00003608 <sendNACK>:

void sendNACK(){
    3608:	cf 93       	push	r28
    360a:	df 93       	push	r29
    360c:	cd b7       	in	r28, 0x3d	; 61
    360e:	de b7       	in	r29, 0x3e	; 62
    USART_AddToQueue(0);
    3610:	80 e0       	ldi	r24, 0x00	; 0
    3612:	0e 94 09 1a 	call	0x3412	; 0x3412 <USART_AddToQueue>
}
    3616:	df 91       	pop	r29
    3618:	cf 91       	pop	r28
    361a:	08 95       	ret

0000361c <calcChecksum>:

uint8_t calcChecksum(uint8_t* buffer,uint8_t size){
    361c:	cf 93       	push	r28
    361e:	df 93       	push	r29
    3620:	00 d0       	rcall	.+0      	; 0x3622 <calcChecksum+0x6>
    3622:	1f 92       	push	r1
    3624:	cd b7       	in	r28, 0x3d	; 61
    3626:	de b7       	in	r29, 0x3e	; 62
    3628:	9b 83       	std	Y+3, r25	; 0x03
    362a:	8a 83       	std	Y+2, r24	; 0x02
    362c:	6c 83       	std	Y+4, r22	; 0x04
    uint8_t checksum = 0;
    362e:	19 82       	std	Y+1, r1	; 0x01
    while(size-- > 0){
    3630:	0c c0       	rjmp	.+24     	; 0x364a <calcChecksum+0x2e>
        checksum += *(buffer++);
    3632:	8a 81       	ldd	r24, Y+2	; 0x02
    3634:	9b 81       	ldd	r25, Y+3	; 0x03
    3636:	9c 01       	movw	r18, r24
    3638:	2f 5f       	subi	r18, 0xFF	; 255
    363a:	3f 4f       	sbci	r19, 0xFF	; 255
    363c:	3b 83       	std	Y+3, r19	; 0x03
    363e:	2a 83       	std	Y+2, r18	; 0x02
    3640:	fc 01       	movw	r30, r24
    3642:	80 81       	ld	r24, Z
    3644:	99 81       	ldd	r25, Y+1	; 0x01
    3646:	89 0f       	add	r24, r25
    3648:	89 83       	std	Y+1, r24	; 0x01
    USART_AddToQueue(0);
}

uint8_t calcChecksum(uint8_t* buffer,uint8_t size){
    uint8_t checksum = 0;
    while(size-- > 0){
    364a:	8c 81       	ldd	r24, Y+4	; 0x04
    364c:	9f ef       	ldi	r25, 0xFF	; 255
    364e:	98 0f       	add	r25, r24
    3650:	9c 83       	std	Y+4, r25	; 0x04
    3652:	88 23       	and	r24, r24
    3654:	71 f7       	brne	.-36     	; 0x3632 <calcChecksum+0x16>
        checksum += *(buffer++);
    }
    return checksum;
    3656:	89 81       	ldd	r24, Y+1	; 0x01
    3658:	0f 90       	pop	r0
    365a:	0f 90       	pop	r0
    365c:	0f 90       	pop	r0
    365e:	0f 90       	pop	r0
    3660:	df 91       	pop	r29
    3662:	cf 91       	pop	r28
    3664:	08 95       	ret

00003666 <setSonarData>:
extern int count;

unsigned char currSonar;
unsigned char lastSonarData = 0;
	
void setSonarData(int i,unsigned char data){
    3666:	cf 93       	push	r28
    3668:	df 93       	push	r29
    366a:	00 d0       	rcall	.+0      	; 0x366c <setSonarData+0x6>
    366c:	cd b7       	in	r28, 0x3d	; 61
    366e:	de b7       	in	r29, 0x3e	; 62
    3670:	9a 83       	std	Y+2, r25	; 0x02
    3672:	89 83       	std	Y+1, r24	; 0x01
    3674:	6b 83       	std	Y+3, r22	; 0x03
//	xSemaphoreTake(sonarDataMutex[i],portMAX_DELAY);
	sonarData[i] = data;
    3676:	89 81       	ldd	r24, Y+1	; 0x01
    3678:	9a 81       	ldd	r25, Y+2	; 0x02
    367a:	88 54       	subi	r24, 0x48	; 72
    367c:	95 4e       	sbci	r25, 0xE5	; 229
    367e:	2b 81       	ldd	r18, Y+3	; 0x03
    3680:	fc 01       	movw	r30, r24
    3682:	20 83       	st	Z, r18
	//xSemaphoreGive(sonarDataMutex[i]);
}
    3684:	0f 90       	pop	r0
    3686:	0f 90       	pop	r0
    3688:	0f 90       	pop	r0
    368a:	df 91       	pop	r29
    368c:	cf 91       	pop	r28
    368e:	08 95       	ret

00003690 <getSonarData>:

unsigned char getSonarData(int i){
    3690:	cf 93       	push	r28
    3692:	df 93       	push	r29
    3694:	1f 92       	push	r1
    3696:	1f 92       	push	r1
    3698:	cd b7       	in	r28, 0x3d	; 61
    369a:	de b7       	in	r29, 0x3e	; 62
    369c:	9a 83       	std	Y+2, r25	; 0x02
    369e:	89 83       	std	Y+1, r24	; 0x01
	//xSemaphoreTake(sonarDataMutex[i],portMAX_DELAY);
	return sonarData[i];
    36a0:	89 81       	ldd	r24, Y+1	; 0x01
    36a2:	9a 81       	ldd	r25, Y+2	; 0x02
    36a4:	88 54       	subi	r24, 0x48	; 72
    36a6:	95 4e       	sbci	r25, 0xE5	; 229
    36a8:	fc 01       	movw	r30, r24
    36aa:	80 81       	ld	r24, Z
	//xSemaphoreGive(sonarDataMutex[i]);
}
    36ac:	0f 90       	pop	r0
    36ae:	0f 90       	pop	r0
    36b0:	df 91       	pop	r29
    36b2:	cf 91       	pop	r28
    36b4:	08 95       	ret

000036b6 <getTimerCount>:

unsigned char getTimerCount(){
    36b6:	cf 93       	push	r28
    36b8:	df 93       	push	r29
    36ba:	cd b7       	in	r28, 0x3d	; 61
    36bc:	de b7       	in	r29, 0x3e	; 62
	return TCNT0;
    36be:	86 e4       	ldi	r24, 0x46	; 70
    36c0:	90 e0       	ldi	r25, 0x00	; 0
    36c2:	fc 01       	movw	r30, r24
    36c4:	80 81       	ld	r24, Z
}
    36c6:	df 91       	pop	r29
    36c8:	cf 91       	pop	r28
    36ca:	08 95       	ret

000036cc <__vector_11>:

inline void setTimerCount(unsigned char i){
	TCNT0 = i;
}

ISR(PCINT2_vect) {
    36cc:	1f 92       	push	r1
    36ce:	0f 92       	push	r0
    36d0:	00 90 5f 00 	lds	r0, 0x005F
    36d4:	0f 92       	push	r0
    36d6:	11 24       	eor	r1, r1
    36d8:	00 90 5b 00 	lds	r0, 0x005B
    36dc:	0f 92       	push	r0
    36de:	2f 93       	push	r18
    36e0:	3f 93       	push	r19
    36e2:	4f 93       	push	r20
    36e4:	5f 93       	push	r21
    36e6:	6f 93       	push	r22
    36e8:	7f 93       	push	r23
    36ea:	8f 93       	push	r24
    36ec:	9f 93       	push	r25
    36ee:	af 93       	push	r26
    36f0:	bf 93       	push	r27
    36f2:	ef 93       	push	r30
    36f4:	ff 93       	push	r31
    36f6:	cf 93       	push	r28
    36f8:	df 93       	push	r29
    36fa:	00 d0       	rcall	.+0      	; 0x36fc <__vector_11+0x30>
    36fc:	cd b7       	in	r28, 0x3d	; 61
    36fe:	de b7       	in	r29, 0x3e	; 62

	unsigned char beginCount;
	unsigned char currCount;
	char i=0;	
    3700:	19 82       	std	Y+1, r1	; 0x01

	if(PINK&(1<<currSonar)){
    3702:	86 e0       	ldi	r24, 0x06	; 6
    3704:	91 e0       	ldi	r25, 0x01	; 1
    3706:	fc 01       	movw	r30, r24
    3708:	80 81       	ld	r24, Z
    370a:	88 2f       	mov	r24, r24
    370c:	90 e0       	ldi	r25, 0x00	; 0
    370e:	20 91 cc 1a 	lds	r18, 0x1ACC
    3712:	22 2f       	mov	r18, r18
    3714:	30 e0       	ldi	r19, 0x00	; 0
    3716:	02 2e       	mov	r0, r18
    3718:	02 c0       	rjmp	.+4      	; 0x371e <__vector_11+0x52>
    371a:	95 95       	asr	r25
    371c:	87 95       	ror	r24
    371e:	0a 94       	dec	r0
    3720:	e2 f7       	brpl	.-8      	; 0x371a <__vector_11+0x4e>
    3722:	81 70       	andi	r24, 0x01	; 1
    3724:	99 27       	eor	r25, r25
    3726:	00 97       	sbiw	r24, 0x00	; 0
    3728:	49 f0       	breq	.+18     	; 0x373c <__vector_11+0x70>
		beginCount = getTimerCount();
    372a:	0e 94 5b 1b 	call	0x36b6	; 0x36b6 <getTimerCount>
    372e:	8a 83       	std	Y+2, r24	; 0x02
		PORTE = 0xFF;
    3730:	8e e2       	ldi	r24, 0x2E	; 46
    3732:	90 e0       	ldi	r25, 0x00	; 0
    3734:	2f ef       	ldi	r18, 0xFF	; 255
    3736:	fc 01       	movw	r30, r24
    3738:	20 83       	st	Z, r18
    373a:	1d c0       	rjmp	.+58     	; 0x3776 <__vector_11+0xaa>
	} else {
		currCount = getTimerCount();
    373c:	0e 94 5b 1b 	call	0x36b6	; 0x36b6 <getTimerCount>
    3740:	8b 83       	std	Y+3, r24	; 0x03
		if(currCount > beginCount){
    3742:	9b 81       	ldd	r25, Y+3	; 0x03
    3744:	8a 81       	ldd	r24, Y+2	; 0x02
    3746:	89 17       	cp	r24, r25
    3748:	38 f4       	brcc	.+14     	; 0x3758 <__vector_11+0x8c>
			lastSonarData = currCount - beginCount;
    374a:	9b 81       	ldd	r25, Y+3	; 0x03
    374c:	8a 81       	ldd	r24, Y+2	; 0x02
    374e:	f9 2f       	mov	r31, r25
    3750:	f8 1b       	sub	r31, r24
    3752:	8f 2f       	mov	r24, r31
    3754:	80 93 b1 1a 	sts	0x1AB1, r24
		}
		PORTE = 0;
    3758:	8e e2       	ldi	r24, 0x2E	; 46
    375a:	90 e0       	ldi	r25, 0x00	; 0
    375c:	fc 01       	movw	r30, r24
    375e:	10 82       	st	Z, r1
		xSemaphoreGiveFromISR(sonarSemaphore,0);
    3760:	80 91 be 1a 	lds	r24, 0x1ABE
    3764:	90 91 bf 1a 	lds	r25, 0x1ABF
    3768:	20 e0       	ldi	r18, 0x00	; 0
    376a:	40 e0       	ldi	r20, 0x00	; 0
    376c:	50 e0       	ldi	r21, 0x00	; 0
    376e:	60 e0       	ldi	r22, 0x00	; 0
    3770:	70 e0       	ldi	r23, 0x00	; 0
    3772:	0e 94 6f 0d 	call	0x1ade	; 0x1ade <xQueueGenericSendFromISR>
	}

}
    3776:	0f 90       	pop	r0
    3778:	0f 90       	pop	r0
    377a:	0f 90       	pop	r0
    377c:	df 91       	pop	r29
    377e:	cf 91       	pop	r28
    3780:	ff 91       	pop	r31
    3782:	ef 91       	pop	r30
    3784:	bf 91       	pop	r27
    3786:	af 91       	pop	r26
    3788:	9f 91       	pop	r25
    378a:	8f 91       	pop	r24
    378c:	7f 91       	pop	r23
    378e:	6f 91       	pop	r22
    3790:	5f 91       	pop	r21
    3792:	4f 91       	pop	r20
    3794:	3f 91       	pop	r19
    3796:	2f 91       	pop	r18
    3798:	0f 90       	pop	r0
    379a:	00 92 5b 00 	sts	0x005B, r0
    379e:	0f 90       	pop	r0
    37a0:	00 92 5f 00 	sts	0x005F, r0
    37a4:	0f 90       	pop	r0
    37a6:	1f 90       	pop	r1
    37a8:	18 95       	reti

000037aa <initializeSonarSensors>:

void initializeSonarSensors(){
    37aa:	cf 93       	push	r28
    37ac:	df 93       	push	r29
    37ae:	cd b7       	in	r28, 0x3d	; 61
    37b0:	de b7       	in	r29, 0x3e	; 62
	//DDRD &= 0xFE;	
	DIDR2 = 0;
    37b2:	8d e7       	ldi	r24, 0x7D	; 125
    37b4:	90 e0       	ldi	r25, 0x00	; 0
    37b6:	fc 01       	movw	r30, r24
    37b8:	10 82       	st	Z, r1
	DDRK = 0;
    37ba:	87 e0       	ldi	r24, 0x07	; 7
    37bc:	91 e0       	ldi	r25, 0x01	; 1
    37be:	fc 01       	movw	r30, r24
    37c0:	10 82       	st	Z, r1
	DDRC = 0;
    37c2:	87 e2       	ldi	r24, 0x27	; 39
    37c4:	90 e0       	ldi	r25, 0x00	; 0
    37c6:	fc 01       	movw	r30, r24
    37c8:	10 82       	st	Z, r1

	PORTC = 0;
    37ca:	88 e2       	ldi	r24, 0x28	; 40
    37cc:	90 e0       	ldi	r25, 0x00	; 0
    37ce:	fc 01       	movw	r30, r24
    37d0:	10 82       	st	Z, r1

	//EICRA = 1;
	//EIMSK = 1;

	PCMSK2 = 0xFF;
    37d2:	8d e6       	ldi	r24, 0x6D	; 109
    37d4:	90 e0       	ldi	r25, 0x00	; 0
    37d6:	2f ef       	ldi	r18, 0xFF	; 255
    37d8:	fc 01       	movw	r30, r24
    37da:	20 83       	st	Z, r18
	PCICR = 0x7;
    37dc:	88 e6       	ldi	r24, 0x68	; 104
    37de:	90 e0       	ldi	r25, 0x00	; 0
    37e0:	27 e0       	ldi	r18, 0x07	; 7
    37e2:	fc 01       	movw	r30, r24
    37e4:	20 83       	st	Z, r18

	TCCR0A = 0;
    37e6:	84 e4       	ldi	r24, 0x44	; 68
    37e8:	90 e0       	ldi	r25, 0x00	; 0
    37ea:	fc 01       	movw	r30, r24
    37ec:	10 82       	st	Z, r1
	TCCR0B = 5;
    37ee:	85 e4       	ldi	r24, 0x45	; 69
    37f0:	90 e0       	ldi	r25, 0x00	; 0
    37f2:	25 e0       	ldi	r18, 0x05	; 5
    37f4:	fc 01       	movw	r30, r24
    37f6:	20 83       	st	Z, r18

}
    37f8:	df 91       	pop	r29
    37fa:	cf 91       	pop	r28
    37fc:	08 95       	ret

000037fe <vTaskSonar>:

void vTaskSonar(void* parameter){
    37fe:	cf 93       	push	r28
    3800:	df 93       	push	r29
    3802:	00 d0       	rcall	.+0      	; 0x3804 <vTaskSonar+0x6>
    3804:	1f 92       	push	r1
    3806:	cd b7       	in	r28, 0x3d	; 61
    3808:	de b7       	in	r29, 0x3e	; 62
    380a:	9c 83       	std	Y+4, r25	; 0x04
    380c:	8b 83       	std	Y+3, r24	; 0x03

	int i;
	initializeSonarSensors();
    380e:	0e 94 d5 1b 	call	0x37aa	; 0x37aa <initializeSonarSensors>
	
	vSemaphoreCreateBinary(sonarSemaphore);
    3812:	43 e0       	ldi	r20, 0x03	; 3
    3814:	60 e0       	ldi	r22, 0x00	; 0
    3816:	81 e0       	ldi	r24, 0x01	; 1
    3818:	0e 94 14 0c 	call	0x1828	; 0x1828 <xQueueGenericCreate>
    381c:	90 93 bf 1a 	sts	0x1ABF, r25
    3820:	80 93 be 1a 	sts	0x1ABE, r24
    3824:	80 91 be 1a 	lds	r24, 0x1ABE
    3828:	90 91 bf 1a 	lds	r25, 0x1ABF
    382c:	00 97       	sbiw	r24, 0x00	; 0
    382e:	59 f0       	breq	.+22     	; 0x3846 <vTaskSonar+0x48>
    3830:	80 91 be 1a 	lds	r24, 0x1ABE
    3834:	90 91 bf 1a 	lds	r25, 0x1ABF
    3838:	20 e0       	ldi	r18, 0x00	; 0
    383a:	40 e0       	ldi	r20, 0x00	; 0
    383c:	50 e0       	ldi	r21, 0x00	; 0
    383e:	60 e0       	ldi	r22, 0x00	; 0
    3840:	70 e0       	ldi	r23, 0x00	; 0
    3842:	0e 94 cb 0c 	call	0x1996	; 0x1996 <xQueueGenericSend>
		
	currSonar = 0;
    3846:	10 92 cc 1a 	sts	0x1ACC, r1

	while(1){
		for(i=0;i<2;i++){
    384a:	1a 82       	std	Y+2, r1	; 0x02
    384c:	19 82       	std	Y+1, r1	; 0x01
    384e:	26 c0       	rjmp	.+76     	; 0x389c <vTaskSonar+0x9e>
			currSonar = i;
    3850:	89 81       	ldd	r24, Y+1	; 0x01
    3852:	80 93 cc 1a 	sts	0x1ACC, r24
			PORTC = (1<<i);
    3856:	88 e2       	ldi	r24, 0x28	; 40
    3858:	90 e0       	ldi	r25, 0x00	; 0
    385a:	21 e0       	ldi	r18, 0x01	; 1
    385c:	30 e0       	ldi	r19, 0x00	; 0
    385e:	09 80       	ldd	r0, Y+1	; 0x01
    3860:	02 c0       	rjmp	.+4      	; 0x3866 <vTaskSonar+0x68>
    3862:	22 0f       	add	r18, r18
    3864:	33 1f       	adc	r19, r19
    3866:	0a 94       	dec	r0
    3868:	e2 f7       	brpl	.-8      	; 0x3862 <vTaskSonar+0x64>
    386a:	fc 01       	movw	r30, r24
    386c:	20 83       	st	Z, r18
			xSemaphoreTake(sonarSemaphore,portMAX_DELAY);
    386e:	80 91 be 1a 	lds	r24, 0x1ABE
    3872:	90 91 bf 1a 	lds	r25, 0x1ABF
    3876:	20 e0       	ldi	r18, 0x00	; 0
    3878:	4f ef       	ldi	r20, 0xFF	; 255
    387a:	5f ef       	ldi	r21, 0xFF	; 255
    387c:	60 e0       	ldi	r22, 0x00	; 0
    387e:	70 e0       	ldi	r23, 0x00	; 0
    3880:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <xQueueGenericReceive>
			setSonarData(i,lastSonarData);
    3884:	20 91 b1 1a 	lds	r18, 0x1AB1
    3888:	89 81       	ldd	r24, Y+1	; 0x01
    388a:	9a 81       	ldd	r25, Y+2	; 0x02
    388c:	62 2f       	mov	r22, r18
    388e:	0e 94 33 1b 	call	0x3666	; 0x3666 <setSonarData>
	vSemaphoreCreateBinary(sonarSemaphore);
		
	currSonar = 0;

	while(1){
		for(i=0;i<2;i++){
    3892:	89 81       	ldd	r24, Y+1	; 0x01
    3894:	9a 81       	ldd	r25, Y+2	; 0x02
    3896:	01 96       	adiw	r24, 0x01	; 1
    3898:	9a 83       	std	Y+2, r25	; 0x02
    389a:	89 83       	std	Y+1, r24	; 0x01
    389c:	89 81       	ldd	r24, Y+1	; 0x01
    389e:	9a 81       	ldd	r25, Y+2	; 0x02
    38a0:	82 30       	cpi	r24, 0x02	; 2
    38a2:	91 05       	cpc	r25, r1
    38a4:	ac f2       	brlt	.-86     	; 0x3850 <vTaskSonar+0x52>
			currSonar = i;
			PORTC = (1<<i);
			xSemaphoreTake(sonarSemaphore,portMAX_DELAY);
			setSonarData(i,lastSonarData);
		}
	}
    38a6:	d1 cf       	rjmp	.-94     	; 0x384a <vTaskSonar+0x4c>

000038a8 <getBatteryVoltage>:

//battery controller functions

//read battery strength in a char. Might need to be unsigned, specs don't say
//anything regarding that.
char getBatteryVoltage(char *sensorResponse) {
    38a8:	cf 93       	push	r28
    38aa:	df 93       	push	r29
    38ac:	1f 92       	push	r1
    38ae:	1f 92       	push	r1
    38b0:	cd b7       	in	r28, 0x3d	; 61
    38b2:	de b7       	in	r29, 0x3e	; 62
    38b4:	9a 83       	std	Y+2, r25	; 0x02
    38b6:	89 83       	std	Y+1, r24	; 0x01
   //fake battery reading
   *sensorResponse = 0;
    38b8:	89 81       	ldd	r24, Y+1	; 0x01
    38ba:	9a 81       	ldd	r25, Y+2	; 0x02
    38bc:	fc 01       	movw	r30, r24
    38be:	10 82       	st	Z, r1
   //return success
   return 1;
    38c0:	81 e0       	ldi	r24, 0x01	; 1
}
    38c2:	0f 90       	pop	r0
    38c4:	0f 90       	pop	r0
    38c6:	df 91       	pop	r29
    38c8:	cf 91       	pop	r28
    38ca:	08 95       	ret

000038cc <getSteeringVoltage>:

//gets voltage from steering?
char getSteeringVoltage(char *sensorResponse) {
    38cc:	cf 93       	push	r28
    38ce:	df 93       	push	r29
    38d0:	1f 92       	push	r1
    38d2:	1f 92       	push	r1
    38d4:	cd b7       	in	r28, 0x3d	; 61
    38d6:	de b7       	in	r29, 0x3e	; 62
    38d8:	9a 83       	std	Y+2, r25	; 0x02
    38da:	89 83       	std	Y+1, r24	; 0x01
   //fake steering voltage reading
   *sensorResponse = 0;
    38dc:	89 81       	ldd	r24, Y+1	; 0x01
    38de:	9a 81       	ldd	r25, Y+2	; 0x02
    38e0:	fc 01       	movw	r30, r24
    38e2:	10 82       	st	Z, r1
   //return success
   return 1;
    38e4:	81 e0       	ldi	r24, 0x01	; 1
}
    38e6:	0f 90       	pop	r0
    38e8:	0f 90       	pop	r0
    38ea:	df 91       	pop	r29
    38ec:	cf 91       	pop	r28
    38ee:	08 95       	ret

000038f0 <setBrake>:
//Brake controller functions. THERE IS CURRENTLY NO WAY TO GET THE DESIRED
//BRAKE TARGET IN THE SPECS

//set brake target
char setBrake(char gainTarget) {
    38f0:	cf 93       	push	r28
    38f2:	df 93       	push	r29
    38f4:	1f 92       	push	r1
    38f6:	cd b7       	in	r28, 0x3d	; 61
    38f8:	de b7       	in	r29, 0x3e	; 62
    38fa:	89 83       	std	Y+1, r24	; 0x01
   //dummy function, nothing happens
   //return success
   return 1;
    38fc:	81 e0       	ldi	r24, 0x01	; 1
}
    38fe:	0f 90       	pop	r0
    3900:	df 91       	pop	r29
    3902:	cf 91       	pop	r28
    3904:	08 95       	ret

00003906 <getBrake>:

//get what is assumed to be the current brake value?
char getBrake(char* sensorResponse) {
    3906:	cf 93       	push	r28
    3908:	df 93       	push	r29
    390a:	1f 92       	push	r1
    390c:	1f 92       	push	r1
    390e:	cd b7       	in	r28, 0x3d	; 61
    3910:	de b7       	in	r29, 0x3e	; 62
    3912:	9a 83       	std	Y+2, r25	; 0x02
    3914:	89 83       	std	Y+1, r24	; 0x01
   //fake brake reading
   *sensorResponse = 0;
    3916:	89 81       	ldd	r24, Y+1	; 0x01
    3918:	9a 81       	ldd	r25, Y+2	; 0x02
    391a:	fc 01       	movw	r30, r24
    391c:	10 82       	st	Z, r1
   //return success
   return 1;
    391e:	81 e0       	ldi	r24, 0x01	; 1
}
    3920:	0f 90       	pop	r0
    3922:	0f 90       	pop	r0
    3924:	df 91       	pop	r29
    3926:	cf 91       	pop	r28
    3928:	08 95       	ret

0000392a <setFNR>:
//FNR controller functions

//set the FNR controller, inputs are either -1, 0, or 1.
char setFNR(char FNR) {
    392a:	cf 93       	push	r28
    392c:	df 93       	push	r29
    392e:	1f 92       	push	r1
    3930:	cd b7       	in	r28, 0x3d	; 61
    3932:	de b7       	in	r29, 0x3e	; 62
    3934:	89 83       	std	Y+1, r24	; 0x01
   //dummy function, nothing happens
   //return success
   return 1;
    3936:	81 e0       	ldi	r24, 0x01	; 1
}
    3938:	0f 90       	pop	r0
    393a:	df 91       	pop	r29
    393c:	cf 91       	pop	r28
    393e:	08 95       	ret

00003940 <getFNR>:

//get the current FNR state. Function follows same format for consistancy
char getFNR(char *sensorResponse) {
    3940:	cf 93       	push	r28
    3942:	df 93       	push	r29
    3944:	1f 92       	push	r1
    3946:	1f 92       	push	r1
    3948:	cd b7       	in	r28, 0x3d	; 61
    394a:	de b7       	in	r29, 0x3e	; 62
    394c:	9a 83       	std	Y+2, r25	; 0x02
    394e:	89 83       	std	Y+1, r24	; 0x01
   //fake reading
   *sensorResponse = 0;
    3950:	89 81       	ldd	r24, Y+1	; 0x01
    3952:	9a 81       	ldd	r25, Y+2	; 0x02
    3954:	fc 01       	movw	r30, r24
    3956:	10 82       	st	Z, r1
   //return success
   return 1;
    3958:	81 e0       	ldi	r24, 0x01	; 1
}
    395a:	0f 90       	pop	r0
    395c:	0f 90       	pop	r0
    395e:	df 91       	pop	r29
    3960:	cf 91       	pop	r28
    3962:	08 95       	ret

00003964 <setLight>:
//light controller functions

//turn lights on and off
char setLight(char lightTarget) {
    3964:	cf 93       	push	r28
    3966:	df 93       	push	r29
    3968:	1f 92       	push	r1
    396a:	cd b7       	in	r28, 0x3d	; 61
    396c:	de b7       	in	r29, 0x3e	; 62
    396e:	89 83       	std	Y+1, r24	; 0x01
   //dummy function, nothing happens
   //return success
   return 1;
    3970:	81 e0       	ldi	r24, 0x01	; 1
}
    3972:	0f 90       	pop	r0
    3974:	df 91       	pop	r29
    3976:	cf 91       	pop	r28
    3978:	08 95       	ret

0000397a <getCertainSensor>:

//Ultrasonic group

//distance in cm stored as int in sensorResponse, returns success
char getCertainSensor(char sensor, int* sensorResponse) {
    397a:	cf 93       	push	r28
    397c:	df 93       	push	r29
    397e:	00 d0       	rcall	.+0      	; 0x3980 <getCertainSensor+0x6>
    3980:	cd b7       	in	r28, 0x3d	; 61
    3982:	de b7       	in	r29, 0x3e	; 62
    3984:	89 83       	std	Y+1, r24	; 0x01
    3986:	7b 83       	std	Y+3, r23	; 0x03
    3988:	6a 83       	std	Y+2, r22	; 0x02
   //returns dummy value for now
   *sensorResponse = 0;
    398a:	8a 81       	ldd	r24, Y+2	; 0x02
    398c:	9b 81       	ldd	r25, Y+3	; 0x03
    398e:	fc 01       	movw	r30, r24
    3990:	11 82       	std	Z+1, r1	; 0x01
    3992:	10 82       	st	Z, r1
   //return success
   return 1;
    3994:	81 e0       	ldi	r24, 0x01	; 1
}
    3996:	0f 90       	pop	r0
    3998:	0f 90       	pop	r0
    399a:	0f 90       	pop	r0
    399c:	df 91       	pop	r29
    399e:	cf 91       	pop	r28
    39a0:	08 95       	ret

000039a2 <getAllSensors>:

//takes in 6 int array to store response, returns success
char getAllSensors(int* sensorResponse) {
    39a2:	cf 93       	push	r28
    39a4:	df 93       	push	r29
    39a6:	00 d0       	rcall	.+0      	; 0x39a8 <getAllSensors+0x6>
    39a8:	cd b7       	in	r28, 0x3d	; 61
    39aa:	de b7       	in	r29, 0x3e	; 62
    39ac:	9b 83       	std	Y+3, r25	; 0x03
    39ae:	8a 83       	std	Y+2, r24	; 0x02
   for(char i = 0; i < 6; i++) {
    39b0:	19 82       	std	Y+1, r1	; 0x01
    39b2:	11 c0       	rjmp	.+34     	; 0x39d6 <getAllSensors+0x34>
      getCertainSensor(i, &sensorResponse[i]);
    39b4:	89 81       	ldd	r24, Y+1	; 0x01
    39b6:	99 27       	eor	r25, r25
    39b8:	87 fd       	sbrc	r24, 7
    39ba:	90 95       	com	r25
    39bc:	88 0f       	add	r24, r24
    39be:	99 1f       	adc	r25, r25
    39c0:	2a 81       	ldd	r18, Y+2	; 0x02
    39c2:	3b 81       	ldd	r19, Y+3	; 0x03
    39c4:	82 0f       	add	r24, r18
    39c6:	93 1f       	adc	r25, r19
    39c8:	bc 01       	movw	r22, r24
    39ca:	89 81       	ldd	r24, Y+1	; 0x01
    39cc:	0e 94 bd 1c 	call	0x397a	; 0x397a <getCertainSensor>
   return 1;
}

//takes in 6 int array to store response, returns success
char getAllSensors(int* sensorResponse) {
   for(char i = 0; i < 6; i++) {
    39d0:	89 81       	ldd	r24, Y+1	; 0x01
    39d2:	8f 5f       	subi	r24, 0xFF	; 255
    39d4:	89 83       	std	Y+1, r24	; 0x01
    39d6:	89 81       	ldd	r24, Y+1	; 0x01
    39d8:	86 30       	cpi	r24, 0x06	; 6
    39da:	64 f3       	brlt	.-40     	; 0x39b4 <getAllSensors+0x12>
      getCertainSensor(i, &sensorResponse[i]);
   }
   //no error checking for now, return success
   return 1;
    39dc:	81 e0       	ldi	r24, 0x01	; 1
}
    39de:	0f 90       	pop	r0
    39e0:	0f 90       	pop	r0
    39e2:	0f 90       	pop	r0
    39e4:	df 91       	pop	r29
    39e6:	cf 91       	pop	r28
    39e8:	08 95       	ret

000039ea <getSensorGroup>:

//stores cm values of a sensor group in sensorResponse
char getSensorGroup(char groupID, int *sensorResponse) {
    39ea:	cf 93       	push	r28
    39ec:	df 93       	push	r29
    39ee:	00 d0       	rcall	.+0      	; 0x39f0 <getSensorGroup+0x6>
    39f0:	1f 92       	push	r1
    39f2:	1f 92       	push	r1
    39f4:	cd b7       	in	r28, 0x3d	; 61
    39f6:	de b7       	in	r29, 0x3e	; 62
    39f8:	8b 83       	std	Y+3, r24	; 0x03
    39fa:	7d 83       	std	Y+5, r23	; 0x05
    39fc:	6c 83       	std	Y+4, r22	; 0x04
   //different group ID's might mean different lengths. the dummy
   //implementation will place 3 0x0000's in the response
   for(int i = 0; i < 3; i++) {
    39fe:	1a 82       	std	Y+2, r1	; 0x02
    3a00:	19 82       	std	Y+1, r1	; 0x01
    3a02:	0a c0       	rjmp	.+20     	; 0x3a18 <getSensorGroup+0x2e>
      *sensorResponse=0;
    3a04:	8c 81       	ldd	r24, Y+4	; 0x04
    3a06:	9d 81       	ldd	r25, Y+5	; 0x05
    3a08:	fc 01       	movw	r30, r24
    3a0a:	11 82       	std	Z+1, r1	; 0x01
    3a0c:	10 82       	st	Z, r1

//stores cm values of a sensor group in sensorResponse
char getSensorGroup(char groupID, int *sensorResponse) {
   //different group ID's might mean different lengths. the dummy
   //implementation will place 3 0x0000's in the response
   for(int i = 0; i < 3; i++) {
    3a0e:	89 81       	ldd	r24, Y+1	; 0x01
    3a10:	9a 81       	ldd	r25, Y+2	; 0x02
    3a12:	01 96       	adiw	r24, 0x01	; 1
    3a14:	9a 83       	std	Y+2, r25	; 0x02
    3a16:	89 83       	std	Y+1, r24	; 0x01
    3a18:	89 81       	ldd	r24, Y+1	; 0x01
    3a1a:	9a 81       	ldd	r25, Y+2	; 0x02
    3a1c:	83 30       	cpi	r24, 0x03	; 3
    3a1e:	91 05       	cpc	r25, r1
    3a20:	8c f3       	brlt	.-30     	; 0x3a04 <getSensorGroup+0x1a>
      *sensorResponse=0;
   }
   //return success
   return 1;
    3a22:	81 e0       	ldi	r24, 0x01	; 1
}
    3a24:	0f 90       	pop	r0
    3a26:	0f 90       	pop	r0
    3a28:	0f 90       	pop	r0
    3a2a:	0f 90       	pop	r0
    3a2c:	0f 90       	pop	r0
    3a2e:	df 91       	pop	r29
    3a30:	cf 91       	pop	r28
    3a32:	08 95       	ret

00003a34 <getSpeed>:
//Speed Sensor group

//get the speed of the vehicle
char getSpeed(char* sensorResponse) {
    3a34:	cf 93       	push	r28
    3a36:	df 93       	push	r29
    3a38:	1f 92       	push	r1
    3a3a:	1f 92       	push	r1
    3a3c:	cd b7       	in	r28, 0x3d	; 61
    3a3e:	de b7       	in	r29, 0x3e	; 62
    3a40:	9a 83       	std	Y+2, r25	; 0x02
    3a42:	89 83       	std	Y+1, r24	; 0x01
   //store dummy speed value
   *sensorResponse = 0;
    3a44:	89 81       	ldd	r24, Y+1	; 0x01
    3a46:	9a 81       	ldd	r25, Y+2	; 0x02
    3a48:	fc 01       	movw	r30, r24
    3a4a:	10 82       	st	Z, r1
   //return success
   return 1;
    3a4c:	81 e0       	ldi	r24, 0x01	; 1
}
    3a4e:	0f 90       	pop	r0
    3a50:	0f 90       	pop	r0
    3a52:	df 91       	pop	r29
    3a54:	cf 91       	pop	r28
    3a56:	08 95       	ret

00003a58 <setSpeed>:

//will set just the speed of the wheels of the car
char setSpeed(char speedTarget) {
    3a58:	cf 93       	push	r28
    3a5a:	df 93       	push	r29
    3a5c:	1f 92       	push	r1
    3a5e:	cd b7       	in	r28, 0x3d	; 61
    3a60:	de b7       	in	r29, 0x3e	; 62
    3a62:	89 83       	std	Y+1, r24	; 0x01
   //nothing done down here
   //return success
   return 1;
    3a64:	81 e0       	ldi	r24, 0x01	; 1
}
    3a66:	0f 90       	pop	r0
    3a68:	df 91       	pop	r29
    3a6a:	cf 91       	pop	r28
    3a6c:	08 95       	ret

00003a6e <setAngle>:

//Steering group

//JUST SETS ANGLE TARGET. Actual angle changing is lower level
char setAngle(char angleTarget) {
    3a6e:	cf 93       	push	r28
    3a70:	df 93       	push	r29
    3a72:	1f 92       	push	r1
    3a74:	cd b7       	in	r28, 0x3d	; 61
    3a76:	de b7       	in	r29, 0x3e	; 62
    3a78:	89 83       	std	Y+1, r24	; 0x01
   //dummy function, nothing will happen for now...
   //return success
   return 1;
    3a7a:	81 e0       	ldi	r24, 0x01	; 1
}
    3a7c:	0f 90       	pop	r0
    3a7e:	df 91       	pop	r29
    3a80:	cf 91       	pop	r28
    3a82:	08 95       	ret

00003a84 <getAngle>:

//get the current angle of the steering system
char getAngle(char* sensorResponse) {
    3a84:	cf 93       	push	r28
    3a86:	df 93       	push	r29
    3a88:	1f 92       	push	r1
    3a8a:	1f 92       	push	r1
    3a8c:	cd b7       	in	r28, 0x3d	; 61
    3a8e:	de b7       	in	r29, 0x3e	; 62
    3a90:	9a 83       	std	Y+2, r25	; 0x02
    3a92:	89 83       	std	Y+1, r24	; 0x01
   //store fake angle reading
   *sensorResponse = 0;
    3a94:	89 81       	ldd	r24, Y+1	; 0x01
    3a96:	9a 81       	ldd	r25, Y+2	; 0x02
    3a98:	fc 01       	movw	r30, r24
    3a9a:	10 82       	st	Z, r1
   //return success
   return 1;
    3a9c:	81 e0       	ldi	r24, 0x01	; 1
}
    3a9e:	0f 90       	pop	r0
    3aa0:	0f 90       	pop	r0
    3aa2:	df 91       	pop	r29
    3aa4:	cf 91       	pop	r28
    3aa6:	08 95       	ret

00003aa8 <getDesiredAngle>:

//get the angle target. argument name is sensorResponse for the sake of consistancy
char getDesiredAngle(char* sensorResponse) {
    3aa8:	cf 93       	push	r28
    3aaa:	df 93       	push	r29
    3aac:	1f 92       	push	r1
    3aae:	1f 92       	push	r1
    3ab0:	cd b7       	in	r28, 0x3d	; 61
    3ab2:	de b7       	in	r29, 0x3e	; 62
    3ab4:	9a 83       	std	Y+2, r25	; 0x02
    3ab6:	89 83       	std	Y+1, r24	; 0x01
   //fake response
   *sensorResponse = 0;
    3ab8:	89 81       	ldd	r24, Y+1	; 0x01
    3aba:	9a 81       	ldd	r25, Y+2	; 0x02
    3abc:	fc 01       	movw	r30, r24
    3abe:	10 82       	st	Z, r1
   //return success
   return 1;
    3ac0:	81 e0       	ldi	r24, 0x01	; 1
}
    3ac2:	0f 90       	pop	r0
    3ac4:	0f 90       	pop	r0
    3ac6:	df 91       	pop	r29
    3ac8:	cf 91       	pop	r28
    3aca:	08 95       	ret

00003acc <changePID>:

//change the PID controller
char changePID(char P, char I, char D) {
    3acc:	cf 93       	push	r28
    3ace:	df 93       	push	r29
    3ad0:	00 d0       	rcall	.+0      	; 0x3ad2 <changePID+0x6>
    3ad2:	cd b7       	in	r28, 0x3d	; 61
    3ad4:	de b7       	in	r29, 0x3e	; 62
    3ad6:	89 83       	std	Y+1, r24	; 0x01
    3ad8:	6a 83       	std	Y+2, r22	; 0x02
    3ada:	4b 83       	std	Y+3, r20	; 0x03
   //dummy function, nothing happens
   //return success
   return 1;
    3adc:	81 e0       	ldi	r24, 0x01	; 1
}
    3ade:	0f 90       	pop	r0
    3ae0:	0f 90       	pop	r0
    3ae2:	0f 90       	pop	r0
    3ae4:	df 91       	pop	r29
    3ae6:	cf 91       	pop	r28
    3ae8:	08 95       	ret

00003aea <setLimits>:

//not sure what this does. Also not sure why upper and lower are separated
//but its in the specs so...
char setLimits(char upper, char lower) {
    3aea:	cf 93       	push	r28
    3aec:	df 93       	push	r29
    3aee:	1f 92       	push	r1
    3af0:	1f 92       	push	r1
    3af2:	cd b7       	in	r28, 0x3d	; 61
    3af4:	de b7       	in	r29, 0x3e	; 62
    3af6:	89 83       	std	Y+1, r24	; 0x01
    3af8:	6a 83       	std	Y+2, r22	; 0x02
   //dummy function, nothing happens
   //return success
   return 1;
    3afa:	81 e0       	ldi	r24, 0x01	; 1
}
    3afc:	0f 90       	pop	r0
    3afe:	0f 90       	pop	r0
    3b00:	df 91       	pop	r29
    3b02:	cf 91       	pop	r28
    3b04:	08 95       	ret

00003b06 <__udivmodsi4>:
    3b06:	a1 e2       	ldi	r26, 0x21	; 33
    3b08:	1a 2e       	mov	r1, r26
    3b0a:	aa 1b       	sub	r26, r26
    3b0c:	bb 1b       	sub	r27, r27
    3b0e:	fd 01       	movw	r30, r26
    3b10:	0d c0       	rjmp	.+26     	; 0x3b2c <__udivmodsi4_ep>

00003b12 <__udivmodsi4_loop>:
    3b12:	aa 1f       	adc	r26, r26
    3b14:	bb 1f       	adc	r27, r27
    3b16:	ee 1f       	adc	r30, r30
    3b18:	ff 1f       	adc	r31, r31
    3b1a:	a2 17       	cp	r26, r18
    3b1c:	b3 07       	cpc	r27, r19
    3b1e:	e4 07       	cpc	r30, r20
    3b20:	f5 07       	cpc	r31, r21
    3b22:	20 f0       	brcs	.+8      	; 0x3b2c <__udivmodsi4_ep>
    3b24:	a2 1b       	sub	r26, r18
    3b26:	b3 0b       	sbc	r27, r19
    3b28:	e4 0b       	sbc	r30, r20
    3b2a:	f5 0b       	sbc	r31, r21

00003b2c <__udivmodsi4_ep>:
    3b2c:	66 1f       	adc	r22, r22
    3b2e:	77 1f       	adc	r23, r23
    3b30:	88 1f       	adc	r24, r24
    3b32:	99 1f       	adc	r25, r25
    3b34:	1a 94       	dec	r1
    3b36:	69 f7       	brne	.-38     	; 0x3b12 <__udivmodsi4_loop>
    3b38:	60 95       	com	r22
    3b3a:	70 95       	com	r23
    3b3c:	80 95       	com	r24
    3b3e:	90 95       	com	r25
    3b40:	9b 01       	movw	r18, r22
    3b42:	ac 01       	movw	r20, r24
    3b44:	bd 01       	movw	r22, r26
    3b46:	cf 01       	movw	r24, r30
    3b48:	08 95       	ret

00003b4a <memcpy>:
    3b4a:	fb 01       	movw	r30, r22
    3b4c:	dc 01       	movw	r26, r24
    3b4e:	02 c0       	rjmp	.+4      	; 0x3b54 <memcpy+0xa>
    3b50:	01 90       	ld	r0, Z+
    3b52:	0d 92       	st	X+, r0
    3b54:	41 50       	subi	r20, 0x01	; 1
    3b56:	50 40       	sbci	r21, 0x00	; 0
    3b58:	d8 f7       	brcc	.-10     	; 0x3b50 <memcpy+0x6>
    3b5a:	08 95       	ret

00003b5c <memset>:
    3b5c:	dc 01       	movw	r26, r24
    3b5e:	01 c0       	rjmp	.+2      	; 0x3b62 <memset+0x6>
    3b60:	6d 93       	st	X+, r22
    3b62:	41 50       	subi	r20, 0x01	; 1
    3b64:	50 40       	sbci	r21, 0x00	; 0
    3b66:	e0 f7       	brcc	.-8      	; 0x3b60 <memset+0x4>
    3b68:	08 95       	ret

00003b6a <strncpy>:
    3b6a:	fb 01       	movw	r30, r22
    3b6c:	dc 01       	movw	r26, r24
    3b6e:	41 50       	subi	r20, 0x01	; 1
    3b70:	50 40       	sbci	r21, 0x00	; 0
    3b72:	48 f0       	brcs	.+18     	; 0x3b86 <strncpy+0x1c>
    3b74:	01 90       	ld	r0, Z+
    3b76:	0d 92       	st	X+, r0
    3b78:	00 20       	and	r0, r0
    3b7a:	c9 f7       	brne	.-14     	; 0x3b6e <strncpy+0x4>
    3b7c:	01 c0       	rjmp	.+2      	; 0x3b80 <strncpy+0x16>
    3b7e:	1d 92       	st	X+, r1
    3b80:	41 50       	subi	r20, 0x01	; 1
    3b82:	50 40       	sbci	r21, 0x00	; 0
    3b84:	e0 f7       	brcc	.-8      	; 0x3b7e <strncpy+0x14>
    3b86:	08 95       	ret

00003b88 <itoa>:
    3b88:	fb 01       	movw	r30, r22
    3b8a:	9f 01       	movw	r18, r30
    3b8c:	e8 94       	clt
    3b8e:	42 30       	cpi	r20, 0x02	; 2
    3b90:	c4 f0       	brlt	.+48     	; 0x3bc2 <itoa+0x3a>
    3b92:	45 32       	cpi	r20, 0x25	; 37
    3b94:	b4 f4       	brge	.+44     	; 0x3bc2 <itoa+0x3a>
    3b96:	4a 30       	cpi	r20, 0x0A	; 10
    3b98:	29 f4       	brne	.+10     	; 0x3ba4 <itoa+0x1c>
    3b9a:	97 fb       	bst	r25, 7
    3b9c:	1e f4       	brtc	.+6      	; 0x3ba4 <itoa+0x1c>
    3b9e:	90 95       	com	r25
    3ba0:	81 95       	neg	r24
    3ba2:	9f 4f       	sbci	r25, 0xFF	; 255
    3ba4:	64 2f       	mov	r22, r20
    3ba6:	77 27       	eor	r23, r23
    3ba8:	0e 94 f5 1d 	call	0x3bea	; 0x3bea <__udivmodhi4>
    3bac:	80 5d       	subi	r24, 0xD0	; 208
    3bae:	8a 33       	cpi	r24, 0x3A	; 58
    3bb0:	0c f0       	brlt	.+2      	; 0x3bb4 <itoa+0x2c>
    3bb2:	89 5d       	subi	r24, 0xD9	; 217
    3bb4:	81 93       	st	Z+, r24
    3bb6:	cb 01       	movw	r24, r22
    3bb8:	00 97       	sbiw	r24, 0x00	; 0
    3bba:	a1 f7       	brne	.-24     	; 0x3ba4 <itoa+0x1c>
    3bbc:	16 f4       	brtc	.+4      	; 0x3bc2 <itoa+0x3a>
    3bbe:	5d e2       	ldi	r21, 0x2D	; 45
    3bc0:	51 93       	st	Z+, r21
    3bc2:	10 82       	st	Z, r1
    3bc4:	c9 01       	movw	r24, r18
    3bc6:	0c 94 e5 1d 	jmp	0x3bca	; 0x3bca <strrev>

00003bca <strrev>:
    3bca:	dc 01       	movw	r26, r24
    3bcc:	fc 01       	movw	r30, r24
    3bce:	67 2f       	mov	r22, r23
    3bd0:	71 91       	ld	r23, Z+
    3bd2:	77 23       	and	r23, r23
    3bd4:	e1 f7       	brne	.-8      	; 0x3bce <strrev+0x4>
    3bd6:	32 97       	sbiw	r30, 0x02	; 2
    3bd8:	04 c0       	rjmp	.+8      	; 0x3be2 <strrev+0x18>
    3bda:	7c 91       	ld	r23, X
    3bdc:	6d 93       	st	X+, r22
    3bde:	70 83       	st	Z, r23
    3be0:	62 91       	ld	r22, -Z
    3be2:	ae 17       	cp	r26, r30
    3be4:	bf 07       	cpc	r27, r31
    3be6:	c8 f3       	brcs	.-14     	; 0x3bda <strrev+0x10>
    3be8:	08 95       	ret

00003bea <__udivmodhi4>:
    3bea:	aa 1b       	sub	r26, r26
    3bec:	bb 1b       	sub	r27, r27
    3bee:	51 e1       	ldi	r21, 0x11	; 17
    3bf0:	07 c0       	rjmp	.+14     	; 0x3c00 <__udivmodhi4_ep>

00003bf2 <__udivmodhi4_loop>:
    3bf2:	aa 1f       	adc	r26, r26
    3bf4:	bb 1f       	adc	r27, r27
    3bf6:	a6 17       	cp	r26, r22
    3bf8:	b7 07       	cpc	r27, r23
    3bfa:	10 f0       	brcs	.+4      	; 0x3c00 <__udivmodhi4_ep>
    3bfc:	a6 1b       	sub	r26, r22
    3bfe:	b7 0b       	sbc	r27, r23

00003c00 <__udivmodhi4_ep>:
    3c00:	88 1f       	adc	r24, r24
    3c02:	99 1f       	adc	r25, r25
    3c04:	5a 95       	dec	r21
    3c06:	a9 f7       	brne	.-22     	; 0x3bf2 <__udivmodhi4_loop>
    3c08:	80 95       	com	r24
    3c0a:	90 95       	com	r25
    3c0c:	bc 01       	movw	r22, r24
    3c0e:	cd 01       	movw	r24, r26
    3c10:	08 95       	ret

00003c12 <_exit>:
    3c12:	f8 94       	cli

00003c14 <__stop_program>:
    3c14:	ff cf       	rjmp	.-2      	; 0x3c14 <__stop_program>
