
rtosdemo.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000002e  00800200  00004fdc  00005070  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00004fdc  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000193d  0080022e  0080022e  0000509e  2**0
                  ALLOC
  3 .stab         0000c3cc  00000000  00000000  000050a0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004749  00000000  00000000  0001146c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  00015bb5  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 90 00 	jmp	0x120	; 0x120 <__ctors_end>
       4:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
       8:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
       c:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      10:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      14:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      18:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      1c:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      20:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      24:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      28:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      2c:	0c 94 9e 21 	jmp	0x433c	; 0x433c <__vector_11>
      30:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      34:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      38:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      3c:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      40:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      44:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      48:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      4c:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      50:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      54:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      58:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      5c:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      60:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      64:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      68:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      6c:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      70:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      74:	0c 94 9f 25 	jmp	0x4b3e	; 0x4b3e <__vector_29>
      78:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      7c:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      80:	0c 94 63 1a 	jmp	0x34c6	; 0x34c6 <__vector_32>
      84:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      88:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      8c:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      90:	0c 94 ef 1a 	jmp	0x35de	; 0x35de <__vector_36>
      94:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      98:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      9c:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      a0:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      a4:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      a8:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      ac:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      b0:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      b4:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      b8:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      bc:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      c0:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      c4:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      c8:	0c 94 05 02 	jmp	0x40a	; 0x40a <__vector_50>
      cc:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      d0:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      d4:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      d8:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      dc:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      e0:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      e4:	ef 1f       	adc	r30, r31
      e6:	06 20       	and	r0, r6
      e8:	36 20       	and	r3, r6
      ea:	16 20       	and	r1, r6
      ec:	36 20       	and	r3, r6
      ee:	36 20       	and	r3, r6
      f0:	26 20       	and	r2, r6
      f2:	36 20       	and	r3, r6

000000f4 <__trampolines_start>:
      f4:	0c 94 42 22 	jmp	0x4484	; 0x4484 <vTaskSonar>
      f8:	0c 94 ef 1f 	jmp	0x3fde	; 0x3fde <processCommand+0x5a>
      fc:	0c 94 36 20 	jmp	0x406c	; 0x406c <processCommand+0xe8>
     100:	0c 94 06 20 	jmp	0x400c	; 0x400c <processCommand+0x88>
     104:	0c 94 11 0a 	jmp	0x1422	; 0x1422 <prvIdleTask>
     108:	0c 94 ab 1c 	jmp	0x3956	; 0x3956 <vTaskUSARTRead>
     10c:	0c 94 26 20 	jmp	0x404c	; 0x404c <processCommand+0xc8>
     110:	0c 94 0d 22 	jmp	0x441a	; 0x441a <sonarADCHandler>
     114:	0c 94 9b 02 	jmp	0x536	; 0x536 <vTaskFunction_1>
     118:	0c 94 2c 26 	jmp	0x4c58	; 0x4c58 <vTaskADC>
     11c:	0c 94 16 20 	jmp	0x402c	; 0x402c <processCommand+0xa8>

00000120 <__ctors_end>:
     120:	11 24       	eor	r1, r1
     122:	1f be       	out	0x3f, r1	; 63
     124:	cf ef       	ldi	r28, 0xFF	; 255
     126:	d1 e2       	ldi	r29, 0x21	; 33
     128:	de bf       	out	0x3e, r29	; 62
     12a:	cd bf       	out	0x3d, r28	; 61
     12c:	00 e0       	ldi	r16, 0x00	; 0
     12e:	0c bf       	out	0x3c, r16	; 60

00000130 <__do_copy_data>:
     130:	12 e0       	ldi	r17, 0x02	; 2
     132:	a0 e0       	ldi	r26, 0x00	; 0
     134:	b2 e0       	ldi	r27, 0x02	; 2
     136:	ec ed       	ldi	r30, 0xDC	; 220
     138:	ff e4       	ldi	r31, 0x4F	; 79
     13a:	00 e0       	ldi	r16, 0x00	; 0
     13c:	0b bf       	out	0x3b, r16	; 59
     13e:	02 c0       	rjmp	.+4      	; 0x144 <__do_copy_data+0x14>
     140:	07 90       	elpm	r0, Z+
     142:	0d 92       	st	X+, r0
     144:	ae 32       	cpi	r26, 0x2E	; 46
     146:	b1 07       	cpc	r27, r17
     148:	d9 f7       	brne	.-10     	; 0x140 <__do_copy_data+0x10>

0000014a <__do_clear_bss>:
     14a:	1b e1       	ldi	r17, 0x1B	; 27
     14c:	ae e2       	ldi	r26, 0x2E	; 46
     14e:	b2 e0       	ldi	r27, 0x02	; 2
     150:	01 c0       	rjmp	.+2      	; 0x154 <.do_clear_bss_start>

00000152 <.do_clear_bss_loop>:
     152:	1d 92       	st	X+, r1

00000154 <.do_clear_bss_start>:
     154:	ab 36       	cpi	r26, 0x6B	; 107
     156:	b1 07       	cpc	r27, r17
     158:	e1 f7       	brne	.-8      	; 0x152 <.do_clear_bss_loop>
     15a:	0e 94 cb 00 	call	0x196	; 0x196 <main>
     15e:	0c 94 ec 27 	jmp	0x4fd8	; 0x4fd8 <_exit>

00000162 <__bad_interrupt>:
     162:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000166 <vApplicationTickHook>:
int count = 0;

int sonarTime;

void vApplicationTickHook()
{
     166:	cf 93       	push	r28
     168:	df 93       	push	r29
     16a:	cd b7       	in	r28, 0x3d	; 61
     16c:	de b7       	in	r29, 0x3e	; 62
    count++;
     16e:	80 91 2e 02 	lds	r24, 0x022E
     172:	90 91 2f 02 	lds	r25, 0x022F
     176:	01 96       	adiw	r24, 0x01	; 1
     178:	90 93 2f 02 	sts	0x022F, r25
     17c:	80 93 2e 02 	sts	0x022E, r24
}
     180:	df 91       	pop	r29
     182:	cf 91       	pop	r28
     184:	08 95       	ret

00000186 <vApplicationStackOverflowHook>:

void vApplicationStackOverflowHook(){
     186:	cf 93       	push	r28
     188:	df 93       	push	r29
     18a:	cd b7       	in	r28, 0x3d	; 61
     18c:	de b7       	in	r29, 0x3e	; 62
	return;
     18e:	00 00       	nop
}
     190:	df 91       	pop	r29
     192:	cf 91       	pop	r28
     194:	08 95       	ret

00000196 <main>:
/*-----------------------------------------------------------*/

int main( void )
{
     196:	af 92       	push	r10
     198:	bf 92       	push	r11
     19a:	cf 92       	push	r12
     19c:	df 92       	push	r13
     19e:	ef 92       	push	r14
     1a0:	ff 92       	push	r15
     1a2:	0f 93       	push	r16
     1a4:	cf 93       	push	r28
     1a6:	df 93       	push	r29
     1a8:	00 d0       	rcall	.+0      	; 0x1aa <main+0x14>
     1aa:	00 d0       	rcall	.+0      	; 0x1ac <main+0x16>
     1ac:	cd b7       	in	r28, 0x3d	; 61
     1ae:	de b7       	in	r29, 0x3e	; 62
    
    //- wimpy variable defs
	uint8_t val[2] = {0x3F, 0xFE};
     1b0:	8f e3       	ldi	r24, 0x3F	; 63
     1b2:	8d 83       	std	Y+5, r24	; 0x05
     1b4:	8e ef       	ldi	r24, 0xFE	; 254
     1b6:	8e 83       	std	Y+6, r24	; 0x06
    uint8_t *val0, *val1;
    
	//- avoid pesky warnings...
	val0 = val + 0;
     1b8:	ce 01       	movw	r24, r28
     1ba:	05 96       	adiw	r24, 0x05	; 5
     1bc:	9a 83       	std	Y+2, r25	; 0x02
     1be:	89 83       	std	Y+1, r24	; 0x01
	val1 = val + 1;
     1c0:	ce 01       	movw	r24, r28
     1c2:	05 96       	adiw	r24, 0x05	; 5
     1c4:	01 96       	adiw	r24, 0x01	; 1
     1c6:	9c 83       	std	Y+4, r25	; 0x04
     1c8:	8b 83       	std	Y+3, r24	; 0x03
    
	DDRA = 0xF7;
     1ca:	81 e2       	ldi	r24, 0x21	; 33
     1cc:	90 e0       	ldi	r25, 0x00	; 0
     1ce:	27 ef       	ldi	r18, 0xF7	; 247
     1d0:	fc 01       	movw	r30, r24
     1d2:	20 83       	st	Z, r18
	//PORTA = 0;
	DDRD = 0xFF;
     1d4:	8a e2       	ldi	r24, 0x2A	; 42
     1d6:	90 e0       	ldi	r25, 0x00	; 0
     1d8:	2f ef       	ldi	r18, 0xFF	; 255
     1da:	fc 01       	movw	r30, r24
     1dc:	20 83       	st	Z, r18
	DDRE = 0xFF;
     1de:	8d e2       	ldi	r24, 0x2D	; 45
     1e0:	90 e0       	ldi	r25, 0x00	; 0
     1e2:	2f ef       	ldi	r18, 0xFF	; 255
     1e4:	fc 01       	movw	r30, r24
     1e6:	20 83       	st	Z, r18
	DDRB = 0xFF; 
     1e8:	84 e2       	ldi	r24, 0x24	; 36
     1ea:	90 e0       	ldi	r25, 0x00	; 0
     1ec:	2f ef       	ldi	r18, 0xFF	; 255
     1ee:	fc 01       	movw	r30, r24
     1f0:	20 83       	st	Z, r18
	DDRK = 0;
     1f2:	87 e0       	ldi	r24, 0x07	; 7
     1f4:	91 e0       	ldi	r25, 0x01	; 1
     1f6:	fc 01       	movw	r30, r24
     1f8:	10 82       	st	Z, r1

	PORTD = 0;
     1fa:	8b e2       	ldi	r24, 0x2B	; 43
     1fc:	90 e0       	ldi	r25, 0x00	; 0
     1fe:	fc 01       	movw	r30, r24
     200:	10 82       	st	Z, r1
	PORTE = 0;
     202:	8e e2       	ldi	r24, 0x2E	; 46
     204:	90 e0       	ldi	r25, 0x00	; 0
     206:	fc 01       	movw	r30, r24
     208:	10 82       	st	Z, r1
	PORTK = 2;
     20a:	88 e0       	ldi	r24, 0x08	; 8
     20c:	91 e0       	ldi	r25, 0x01	; 1
     20e:	22 e0       	ldi	r18, 0x02	; 2
     210:	fc 01       	movw	r30, r24
     212:	20 83       	st	Z, r18

    //- init IO with goodness
	vIO_init();
     214:	0e 94 4d 03 	call	0x69a	; 0x69a <vIO_init>

	//- Create a 
	xTaskCreate( (pdTASK_CODE) vTaskFunction_1, (signed char *) "T0", configMINIMAL_STACK_SIZE+1000,
     218:	8b 81       	ldd	r24, Y+3	; 0x03
     21a:	9c 81       	ldd	r25, Y+4	; 0x04
     21c:	a1 2c       	mov	r10, r1
     21e:	b1 2c       	mov	r11, r1
     220:	c1 2c       	mov	r12, r1
     222:	d1 2c       	mov	r13, r1
     224:	e1 2c       	mov	r14, r1
     226:	f1 2c       	mov	r15, r1
     228:	01 e0       	ldi	r16, 0x01	; 1
     22a:	9c 01       	movw	r18, r24
     22c:	4d e3       	ldi	r20, 0x3D	; 61
     22e:	54 e0       	ldi	r21, 0x04	; 4
     230:	64 e0       	ldi	r22, 0x04	; 4
     232:	72 e0       	ldi	r23, 0x02	; 2
     234:	8b e9       	ldi	r24, 0x9B	; 155
     236:	92 e0       	ldi	r25, 0x02	; 2
     238:	0e 94 5d 03 	call	0x6ba	; 0x6ba <xTaskGenericCreate>
                (void *) val1, 1, NULL );
	xTaskCreate( (pdTASK_CODE) vTaskPot, (signed char *) "T0", configMINIMAL_STACK_SIZE+1000,
                (void *) val1, 1, NULL );*/

 
   xTaskCreate( (pdTASK_CODE) vTaskSonar, (signed char *) "TS", configMINIMAL_STACK_SIZE+1000,
     23c:	8b 81       	ldd	r24, Y+3	; 0x03
     23e:	9c 81       	ldd	r25, Y+4	; 0x04
     240:	a1 2c       	mov	r10, r1
     242:	b1 2c       	mov	r11, r1
     244:	c1 2c       	mov	r12, r1
     246:	d1 2c       	mov	r13, r1
     248:	e1 2c       	mov	r14, r1
     24a:	f1 2c       	mov	r15, r1
     24c:	01 e0       	ldi	r16, 0x01	; 1
     24e:	9c 01       	movw	r18, r24
     250:	4d e3       	ldi	r20, 0x3D	; 61
     252:	54 e0       	ldi	r21, 0x04	; 4
     254:	67 e0       	ldi	r22, 0x07	; 7
     256:	72 e0       	ldi	r23, 0x02	; 2
     258:	82 e4       	ldi	r24, 0x42	; 66
     25a:	92 e2       	ldi	r25, 0x22	; 34
     25c:	0e 94 5d 03 	call	0x6ba	; 0x6ba <xTaskGenericCreate>
                (void *) val1, 1, NULL );

   /*xTaskCreate( (pdTASK_CODE) vTaskUSARTWrite, (signed char *) "T2", configMINIMAL_STACK_SIZE+1000,
   				(void *) val1, 1, NULL);*/

   xTaskCreate( (pdTASK_CODE) vTaskUSARTRead, (signed char *) "T3", configMINIMAL_STACK_SIZE+1000,
     260:	8b 81       	ldd	r24, Y+3	; 0x03
     262:	9c 81       	ldd	r25, Y+4	; 0x04
     264:	a1 2c       	mov	r10, r1
     266:	b1 2c       	mov	r11, r1
     268:	c1 2c       	mov	r12, r1
     26a:	d1 2c       	mov	r13, r1
     26c:	e1 2c       	mov	r14, r1
     26e:	f1 2c       	mov	r15, r1
     270:	01 e0       	ldi	r16, 0x01	; 1
     272:	9c 01       	movw	r18, r24
     274:	4d e3       	ldi	r20, 0x3D	; 61
     276:	54 e0       	ldi	r21, 0x04	; 4
     278:	6a e0       	ldi	r22, 0x0A	; 10
     27a:	72 e0       	ldi	r23, 0x02	; 2
     27c:	8b ea       	ldi	r24, 0xAB	; 171
     27e:	9c e1       	ldi	r25, 0x1C	; 28
     280:	0e 94 5d 03 	call	0x6ba	; 0x6ba <xTaskGenericCreate>
   				(void *) val1, 1, NULL);

	
	xTaskCreate( (pdTASK_CODE) vTaskADC, (signed char *) "T5", configMINIMAL_STACK_SIZE+1000,
     284:	8b 81       	ldd	r24, Y+3	; 0x03
     286:	9c 81       	ldd	r25, Y+4	; 0x04
     288:	a1 2c       	mov	r10, r1
     28a:	b1 2c       	mov	r11, r1
     28c:	c1 2c       	mov	r12, r1
     28e:	d1 2c       	mov	r13, r1
     290:	e1 2c       	mov	r14, r1
     292:	f1 2c       	mov	r15, r1
     294:	01 e0       	ldi	r16, 0x01	; 1
     296:	9c 01       	movw	r18, r24
     298:	4d e3       	ldi	r20, 0x3D	; 61
     29a:	54 e0       	ldi	r21, 0x04	; 4
     29c:	6d e0       	ldi	r22, 0x0D	; 13
     29e:	72 e0       	ldi	r23, 0x02	; 2
     2a0:	8c e2       	ldi	r24, 0x2C	; 44
     2a2:	96 e2       	ldi	r25, 0x26	; 38
     2a4:	0e 94 5d 03 	call	0x6ba	; 0x6ba <xTaskGenericCreate>

//   xTaskCreate( (pdTASK_CODE) vTaskUSARTLog, (signed char *) "T4", configMINIMAL_STACK_SIZE+1000,
//   				(void *) val1, 1, NULL);
    
    //- kick off the scheduler
	vTaskStartScheduler();
     2a8:	0e 94 5c 06 	call	0xcb8	; 0xcb8 <vTaskStartScheduler>
    
	return 0;
     2ac:	80 e0       	ldi	r24, 0x00	; 0
     2ae:	90 e0       	ldi	r25, 0x00	; 0
}
     2b0:	26 96       	adiw	r28, 0x06	; 6
     2b2:	0f b6       	in	r0, 0x3f	; 63
     2b4:	f8 94       	cli
     2b6:	de bf       	out	0x3e, r29	; 62
     2b8:	0f be       	out	0x3f, r0	; 63
     2ba:	cd bf       	out	0x3d, r28	; 61
     2bc:	df 91       	pop	r29
     2be:	cf 91       	pop	r28
     2c0:	0f 91       	pop	r16
     2c2:	ff 90       	pop	r15
     2c4:	ef 90       	pop	r14
     2c6:	df 90       	pop	r13
     2c8:	cf 90       	pop	r12
     2ca:	bf 90       	pop	r11
     2cc:	af 90       	pop	r10
     2ce:	08 95       	ret

000002d0 <printHex>:
/*-----------------------------------------------------------*/

void printHex(int i){
     2d0:	cf 93       	push	r28
     2d2:	df 93       	push	r29
     2d4:	cd b7       	in	r28, 0x3d	; 61
     2d6:	de b7       	in	r29, 0x3e	; 62
     2d8:	62 97       	sbiw	r28, 0x12	; 18
     2da:	0f b6       	in	r0, 0x3f	; 63
     2dc:	f8 94       	cli
     2de:	de bf       	out	0x3e, r29	; 62
     2e0:	0f be       	out	0x3f, r0	; 63
     2e2:	cd bf       	out	0x3d, r28	; 61
     2e4:	9a 8b       	std	Y+18, r25	; 0x12
     2e6:	89 8b       	std	Y+17, r24	; 0x11
	char hex[] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
     2e8:	20 e1       	ldi	r18, 0x10	; 16
     2ea:	e0 e1       	ldi	r30, 0x10	; 16
     2ec:	f2 e0       	ldi	r31, 0x02	; 2
     2ee:	ce 01       	movw	r24, r28
     2f0:	01 96       	adiw	r24, 0x01	; 1
     2f2:	dc 01       	movw	r26, r24
     2f4:	01 90       	ld	r0, Z+
     2f6:	0d 92       	st	X+, r0
     2f8:	2a 95       	dec	r18
     2fa:	e1 f7       	brne	.-8      	; 0x2f4 <printHex+0x24>

	USART_Write(hex[(i&0xF000) >> 12]);
     2fc:	89 89       	ldd	r24, Y+17	; 0x11
     2fe:	9a 89       	ldd	r25, Y+18	; 0x12
     300:	89 2f       	mov	r24, r25
     302:	99 27       	eor	r25, r25
     304:	82 95       	swap	r24
     306:	8f 70       	andi	r24, 0x0F	; 15
     308:	9e 01       	movw	r18, r28
     30a:	2f 5f       	subi	r18, 0xFF	; 255
     30c:	3f 4f       	sbci	r19, 0xFF	; 255
     30e:	82 0f       	add	r24, r18
     310:	93 1f       	adc	r25, r19
     312:	fc 01       	movw	r30, r24
     314:	80 81       	ld	r24, Z
     316:	0e 94 a9 1a 	call	0x3552	; 0x3552 <USART_Write>
	USART_Write(hex[(i&0xF00) >> 8]);
     31a:	89 89       	ldd	r24, Y+17	; 0x11
     31c:	9a 89       	ldd	r25, Y+18	; 0x12
     31e:	88 27       	eor	r24, r24
     320:	9f 70       	andi	r25, 0x0F	; 15
     322:	89 2f       	mov	r24, r25
     324:	99 0f       	add	r25, r25
     326:	99 0b       	sbc	r25, r25
     328:	9e 01       	movw	r18, r28
     32a:	2f 5f       	subi	r18, 0xFF	; 255
     32c:	3f 4f       	sbci	r19, 0xFF	; 255
     32e:	82 0f       	add	r24, r18
     330:	93 1f       	adc	r25, r19
     332:	fc 01       	movw	r30, r24
     334:	80 81       	ld	r24, Z
     336:	0e 94 a9 1a 	call	0x3552	; 0x3552 <USART_Write>
	USART_Write(hex[(i&0xF0) >> 4]);
     33a:	89 89       	ldd	r24, Y+17	; 0x11
     33c:	9a 89       	ldd	r25, Y+18	; 0x12
     33e:	80 7f       	andi	r24, 0xF0	; 240
     340:	99 27       	eor	r25, r25
     342:	95 95       	asr	r25
     344:	87 95       	ror	r24
     346:	95 95       	asr	r25
     348:	87 95       	ror	r24
     34a:	95 95       	asr	r25
     34c:	87 95       	ror	r24
     34e:	95 95       	asr	r25
     350:	87 95       	ror	r24
     352:	9e 01       	movw	r18, r28
     354:	2f 5f       	subi	r18, 0xFF	; 255
     356:	3f 4f       	sbci	r19, 0xFF	; 255
     358:	82 0f       	add	r24, r18
     35a:	93 1f       	adc	r25, r19
     35c:	fc 01       	movw	r30, r24
     35e:	80 81       	ld	r24, Z
     360:	0e 94 a9 1a 	call	0x3552	; 0x3552 <USART_Write>
	USART_Write(hex[i&0xF]);
     364:	89 89       	ldd	r24, Y+17	; 0x11
     366:	9a 89       	ldd	r25, Y+18	; 0x12
     368:	8f 70       	andi	r24, 0x0F	; 15
     36a:	99 27       	eor	r25, r25
     36c:	9e 01       	movw	r18, r28
     36e:	2f 5f       	subi	r18, 0xFF	; 255
     370:	3f 4f       	sbci	r19, 0xFF	; 255
     372:	82 0f       	add	r24, r18
     374:	93 1f       	adc	r25, r19
     376:	fc 01       	movw	r30, r24
     378:	80 81       	ld	r24, Z
     37a:	0e 94 a9 1a 	call	0x3552	; 0x3552 <USART_Write>

}
     37e:	62 96       	adiw	r28, 0x12	; 18
     380:	0f b6       	in	r0, 0x3f	; 63
     382:	f8 94       	cli
     384:	de bf       	out	0x3e, r29	; 62
     386:	0f be       	out	0x3f, r0	; 63
     388:	cd bf       	out	0x3d, r28	; 61
     38a:	df 91       	pop	r29
     38c:	cf 91       	pop	r28
     38e:	08 95       	ret

00000390 <printNum>:

void printNum(unsigned char i){
     390:	cf 93       	push	r28
     392:	df 93       	push	r29
     394:	cd b7       	in	r28, 0x3d	; 61
     396:	de b7       	in	r29, 0x3e	; 62
     398:	2d 97       	sbiw	r28, 0x0d	; 13
     39a:	0f b6       	in	r0, 0x3f	; 63
     39c:	f8 94       	cli
     39e:	de bf       	out	0x3e, r29	; 62
     3a0:	0f be       	out	0x3f, r0	; 63
     3a2:	cd bf       	out	0x3d, r28	; 61
     3a4:	8d 87       	std	Y+13, r24	; 0x0d
    
    char str[10];
    memset(str,0,10);
     3a6:	ce 01       	movw	r24, r28
     3a8:	03 96       	adiw	r24, 0x03	; 3
     3aa:	4a e0       	ldi	r20, 0x0A	; 10
     3ac:	50 e0       	ldi	r21, 0x00	; 0
     3ae:	60 e0       	ldi	r22, 0x00	; 0
     3b0:	70 e0       	ldi	r23, 0x00	; 0
     3b2:	0e 94 91 27 	call	0x4f22	; 0x4f22 <memset>
    itoa(i,str,10);
     3b6:	8d 85       	ldd	r24, Y+13	; 0x0d
     3b8:	88 2f       	mov	r24, r24
     3ba:	90 e0       	ldi	r25, 0x00	; 0
     3bc:	9e 01       	movw	r18, r28
     3be:	2d 5f       	subi	r18, 0xFD	; 253
     3c0:	3f 4f       	sbci	r19, 0xFF	; 255
     3c2:	4a e0       	ldi	r20, 0x0A	; 10
     3c4:	50 e0       	ldi	r21, 0x00	; 0
     3c6:	b9 01       	movw	r22, r18
     3c8:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <itoa>
    char * irr = str;
     3cc:	ce 01       	movw	r24, r28
     3ce:	03 96       	adiw	r24, 0x03	; 3
     3d0:	9a 83       	std	Y+2, r25	; 0x02
     3d2:	89 83       	std	Y+1, r24	; 0x01
    while(*irr){
     3d4:	0b c0       	rjmp	.+22     	; 0x3ec <printNum+0x5c>
        USART_AddToQueue((unsigned char )*irr);
     3d6:	89 81       	ldd	r24, Y+1	; 0x01
     3d8:	9a 81       	ldd	r25, Y+2	; 0x02
     3da:	fc 01       	movw	r30, r24
     3dc:	80 81       	ld	r24, Z
     3de:	0e 94 16 1b 	call	0x362c	; 0x362c <USART_AddToQueue>
        irr++;
     3e2:	89 81       	ldd	r24, Y+1	; 0x01
     3e4:	9a 81       	ldd	r25, Y+2	; 0x02
     3e6:	01 96       	adiw	r24, 0x01	; 1
     3e8:	9a 83       	std	Y+2, r25	; 0x02
     3ea:	89 83       	std	Y+1, r24	; 0x01
    
    char str[10];
    memset(str,0,10);
    itoa(i,str,10);
    char * irr = str;
    while(*irr){
     3ec:	89 81       	ldd	r24, Y+1	; 0x01
     3ee:	9a 81       	ldd	r25, Y+2	; 0x02
     3f0:	fc 01       	movw	r30, r24
     3f2:	80 81       	ld	r24, Z
     3f4:	88 23       	and	r24, r24
     3f6:	79 f7       	brne	.-34     	; 0x3d6 <printNum+0x46>
        USART_AddToQueue((unsigned char )*irr);
        irr++;
    }
    
}
     3f8:	2d 96       	adiw	r28, 0x0d	; 13
     3fa:	0f b6       	in	r0, 0x3f	; 63
     3fc:	f8 94       	cli
     3fe:	de bf       	out	0x3e, r29	; 62
     400:	0f be       	out	0x3f, r0	; 63
     402:	cd bf       	out	0x3d, r28	; 61
     404:	df 91       	pop	r29
     406:	cf 91       	pop	r28
     408:	08 95       	ret

0000040a <__vector_50>:

ISR(TIMER5_OVF_vect){
     40a:	1f 92       	push	r1
     40c:	0f 92       	push	r0
     40e:	00 90 5f 00 	lds	r0, 0x005F
     412:	0f 92       	push	r0
     414:	11 24       	eor	r1, r1
     416:	00 90 5b 00 	lds	r0, 0x005B
     41a:	0f 92       	push	r0
     41c:	2f 93       	push	r18
     41e:	3f 93       	push	r19
     420:	8f 93       	push	r24
     422:	9f 93       	push	r25
     424:	ef 93       	push	r30
     426:	ff 93       	push	r31
     428:	cf 93       	push	r28
     42a:	df 93       	push	r29
     42c:	cd b7       	in	r28, 0x3d	; 61
     42e:	de b7       	in	r29, 0x3e	; 62

	PORTB ^= 0xFF;
     430:	85 e2       	ldi	r24, 0x25	; 37
     432:	90 e0       	ldi	r25, 0x00	; 0
     434:	25 e2       	ldi	r18, 0x25	; 37
     436:	30 e0       	ldi	r19, 0x00	; 0
     438:	f9 01       	movw	r30, r18
     43a:	20 81       	ld	r18, Z
     43c:	20 95       	com	r18
     43e:	fc 01       	movw	r30, r24
     440:	20 83       	st	Z, r18
	TCNT3L = 0;
     442:	84 e9       	ldi	r24, 0x94	; 148
     444:	90 e0       	ldi	r25, 0x00	; 0
     446:	fc 01       	movw	r30, r24
     448:	10 82       	st	Z, r1
	TCNT3H = 0;
     44a:	85 e9       	ldi	r24, 0x95	; 149
     44c:	90 e0       	ldi	r25, 0x00	; 0
     44e:	fc 01       	movw	r30, r24
     450:	10 82       	st	Z, r1

}
     452:	df 91       	pop	r29
     454:	cf 91       	pop	r28
     456:	ff 91       	pop	r31
     458:	ef 91       	pop	r30
     45a:	9f 91       	pop	r25
     45c:	8f 91       	pop	r24
     45e:	3f 91       	pop	r19
     460:	2f 91       	pop	r18
     462:	0f 90       	pop	r0
     464:	00 92 5b 00 	sts	0x005B, r0
     468:	0f 90       	pop	r0
     46a:	00 92 5f 00 	sts	0x005F, r0
     46e:	0f 90       	pop	r0
     470:	1f 90       	pop	r1
     472:	18 95       	reti

00000474 <getTimerCount2>:

unsigned int getTimerCount2(){
     474:	cf 93       	push	r28
     476:	df 93       	push	r29
     478:	cd b7       	in	r28, 0x3d	; 61
     47a:	de b7       	in	r29, 0x3e	; 62

	//volatile char timerLow = TCNT3L;

	return TCNT0;
     47c:	86 e4       	ldi	r24, 0x46	; 70
     47e:	90 e0       	ldi	r25, 0x00	; 0
     480:	fc 01       	movw	r30, r24
     482:	80 81       	ld	r24, Z
     484:	88 2f       	mov	r24, r24
     486:	90 e0       	ldi	r25, 0x00	; 0

}
     488:	df 91       	pop	r29
     48a:	cf 91       	pop	r28
     48c:	08 95       	ret

0000048e <potValue>:


int potValue(int sonarMax,int sonarMin,int potMax,int potMin,int x){
     48e:	0f 93       	push	r16
     490:	1f 93       	push	r17
     492:	cf 93       	push	r28
     494:	df 93       	push	r29
     496:	cd b7       	in	r28, 0x3d	; 61
     498:	de b7       	in	r29, 0x3e	; 62
     49a:	2c 97       	sbiw	r28, 0x0c	; 12
     49c:	0f b6       	in	r0, 0x3f	; 63
     49e:	f8 94       	cli
     4a0:	de bf       	out	0x3e, r29	; 62
     4a2:	0f be       	out	0x3f, r0	; 63
     4a4:	cd bf       	out	0x3d, r28	; 61
     4a6:	9c 83       	std	Y+4, r25	; 0x04
     4a8:	8b 83       	std	Y+3, r24	; 0x03
     4aa:	7e 83       	std	Y+6, r23	; 0x06
     4ac:	6d 83       	std	Y+5, r22	; 0x05
     4ae:	58 87       	std	Y+8, r21	; 0x08
     4b0:	4f 83       	std	Y+7, r20	; 0x07
     4b2:	3a 87       	std	Y+10, r19	; 0x0a
     4b4:	29 87       	std	Y+9, r18	; 0x09
     4b6:	1c 87       	std	Y+12, r17	; 0x0c
     4b8:	0b 87       	std	Y+11, r16	; 0x0b
	int value;	
	if(x < sonarMin){
     4ba:	2b 85       	ldd	r18, Y+11	; 0x0b
     4bc:	3c 85       	ldd	r19, Y+12	; 0x0c
     4be:	8d 81       	ldd	r24, Y+5	; 0x05
     4c0:	9e 81       	ldd	r25, Y+6	; 0x06
     4c2:	28 17       	cp	r18, r24
     4c4:	39 07       	cpc	r19, r25
     4c6:	1c f4       	brge	.+6      	; 0x4ce <potValue+0x40>
		return potMin;
     4c8:	89 85       	ldd	r24, Y+9	; 0x09
     4ca:	9a 85       	ldd	r25, Y+10	; 0x0a
     4cc:	29 c0       	rjmp	.+82     	; 0x520 <potValue+0x92>
	} else if (x > sonarMax){
     4ce:	2b 85       	ldd	r18, Y+11	; 0x0b
     4d0:	3c 85       	ldd	r19, Y+12	; 0x0c
     4d2:	8b 81       	ldd	r24, Y+3	; 0x03
     4d4:	9c 81       	ldd	r25, Y+4	; 0x04
     4d6:	82 17       	cp	r24, r18
     4d8:	93 07       	cpc	r25, r19
     4da:	1c f4       	brge	.+6      	; 0x4e2 <potValue+0x54>
		return potMax;
     4dc:	8f 81       	ldd	r24, Y+7	; 0x07
     4de:	98 85       	ldd	r25, Y+8	; 0x08
     4e0:	1f c0       	rjmp	.+62     	; 0x520 <potValue+0x92>
	} else {
		value = x / 4 - 140;
     4e2:	8b 85       	ldd	r24, Y+11	; 0x0b
     4e4:	9c 85       	ldd	r25, Y+12	; 0x0c
     4e6:	99 23       	and	r25, r25
     4e8:	0c f4       	brge	.+2      	; 0x4ec <potValue+0x5e>
     4ea:	03 96       	adiw	r24, 0x03	; 3
     4ec:	95 95       	asr	r25
     4ee:	87 95       	ror	r24
     4f0:	95 95       	asr	r25
     4f2:	87 95       	ror	r24
     4f4:	8c 58       	subi	r24, 0x8C	; 140
     4f6:	91 09       	sbc	r25, r1
     4f8:	9a 83       	std	Y+2, r25	; 0x02
     4fa:	89 83       	std	Y+1, r24	; 0x01
		return value > potMax?potMax:value < potMin?potMin:value;
     4fc:	29 81       	ldd	r18, Y+1	; 0x01
     4fe:	3a 81       	ldd	r19, Y+2	; 0x02
     500:	8f 81       	ldd	r24, Y+7	; 0x07
     502:	98 85       	ldd	r25, Y+8	; 0x08
     504:	82 17       	cp	r24, r18
     506:	93 07       	cpc	r25, r19
     508:	4c f0       	brlt	.+18     	; 0x51c <potValue+0x8e>
     50a:	29 85       	ldd	r18, Y+9	; 0x09
     50c:	3a 85       	ldd	r19, Y+10	; 0x0a
     50e:	89 81       	ldd	r24, Y+1	; 0x01
     510:	9a 81       	ldd	r25, Y+2	; 0x02
     512:	82 17       	cp	r24, r18
     514:	93 07       	cpc	r25, r19
     516:	24 f4       	brge	.+8      	; 0x520 <potValue+0x92>
     518:	c9 01       	movw	r24, r18
     51a:	02 c0       	rjmp	.+4      	; 0x520 <potValue+0x92>
     51c:	8f 81       	ldd	r24, Y+7	; 0x07
     51e:	98 85       	ldd	r25, Y+8	; 0x08
	}
} 
     520:	2c 96       	adiw	r28, 0x0c	; 12
     522:	0f b6       	in	r0, 0x3f	; 63
     524:	f8 94       	cli
     526:	de bf       	out	0x3e, r29	; 62
     528:	0f be       	out	0x3f, r0	; 63
     52a:	cd bf       	out	0x3d, r28	; 61
     52c:	df 91       	pop	r29
     52e:	cf 91       	pop	r28
     530:	1f 91       	pop	r17
     532:	0f 91       	pop	r16
     534:	08 95       	ret

00000536 <vTaskFunction_1>:

void vTaskFunction_1(void *pvParameters)
{	
     536:	cf 93       	push	r28
     538:	df 93       	push	r29
     53a:	cd b7       	in	r28, 0x3d	; 61
     53c:	de b7       	in	r29, 0x3e	; 62
     53e:	67 97       	sbiw	r28, 0x17	; 23
     540:	0f b6       	in	r0, 0x3f	; 63
     542:	f8 94       	cli
     544:	de bf       	out	0x3e, r29	; 62
     546:	0f be       	out	0x3f, r0	; 63
     548:	cd bf       	out	0x3d, r28	; 61
     54a:	9f 8b       	std	Y+23, r25	; 0x17
     54c:	8e 8b       	std	Y+22, r24	; 0x16
	int sonarResult;
	int movingForward = 1;
     54e:	81 e0       	ldi	r24, 0x01	; 1
     550:	90 e0       	ldi	r25, 0x00	; 0
     552:	9a 83       	std	Y+2, r25	; 0x02
     554:	89 83       	std	Y+1, r24	; 0x01

	int sonarMax = 0x31C;
     556:	8c e1       	ldi	r24, 0x1C	; 28
     558:	93 e0       	ldi	r25, 0x03	; 3
     55a:	9c 83       	std	Y+4, r25	; 0x04
     55c:	8b 83       	std	Y+3, r24	; 0x03
	int sonarMin = 0xE0;
     55e:	80 ee       	ldi	r24, 0xE0	; 224
     560:	90 e0       	ldi	r25, 0x00	; 0
     562:	9e 83       	std	Y+6, r25	; 0x06
     564:	8d 83       	std	Y+5, r24	; 0x05
	int potMin = 0x18;
     566:	88 e1       	ldi	r24, 0x18	; 24
     568:	90 e0       	ldi	r25, 0x00	; 0
     56a:	98 87       	std	Y+8, r25	; 0x08
     56c:	8f 83       	std	Y+7, r24	; 0x07
	int potMax = 0x40;;
     56e:	80 e4       	ldi	r24, 0x40	; 64
     570:	90 e0       	ldi	r25, 0x00	; 0
     572:	9a 87       	std	Y+10, r25	; 0x0a
     574:	89 87       	std	Y+9, r24	; 0x09
	int backwardSwitch = 0x100;
     576:	80 e0       	ldi	r24, 0x00	; 0
     578:	91 e0       	ldi	r25, 0x01	; 1
     57a:	9c 87       	std	Y+12, r25	; 0x0c
     57c:	8b 87       	std	Y+11, r24	; 0x0b
	int neutralSwitch = 0x140;
     57e:	80 e4       	ldi	r24, 0x40	; 64
     580:	91 e0       	ldi	r25, 0x01	; 1
     582:	9e 87       	std	Y+14, r25	; 0x0e
     584:	8d 87       	std	Y+13, r24	; 0x0d
	int forwardSwitch = 0x160;
     586:	80 e6       	ldi	r24, 0x60	; 96
     588:	91 e0       	ldi	r25, 0x01	; 1
     58a:	98 8b       	std	Y+16, r25	; 0x10
     58c:	8f 87       	std	Y+15, r24	; 0x0f
	int minTicks = 450;
     58e:	82 ec       	ldi	r24, 0xC2	; 194
     590:	91 e0       	ldi	r25, 0x01	; 1
     592:	9a 8b       	std	Y+18, r25	; 0x12
     594:	89 8b       	std	Y+17, r24	; 0x11

	int tickCount;

	char a = 'a';
     596:	81 e6       	ldi	r24, 0x61	; 97
     598:	8b 8b       	std	Y+19, r24	; 0x13

	PORTA = 4;
     59a:	82 e2       	ldi	r24, 0x22	; 34
     59c:	90 e0       	ldi	r25, 0x00	; 0
     59e:	24 e0       	ldi	r18, 0x04	; 4
     5a0:	fc 01       	movw	r30, r24
     5a2:	20 83       	st	Z, r18

   USART_Init(9600, 16000000);
     5a4:	40 e0       	ldi	r20, 0x00	; 0
     5a6:	54 e2       	ldi	r21, 0x24	; 36
     5a8:	64 ef       	ldi	r22, 0xF4	; 244
     5aa:	70 e0       	ldi	r23, 0x00	; 0
     5ac:	80 e8       	ldi	r24, 0x80	; 128
     5ae:	95 e2       	ldi	r25, 0x25	; 37
     5b0:	0e 94 66 1a 	call	0x34cc	; 0x34cc <USART_Init>


	initializeSPI();
     5b4:	0e 94 d3 23 	call	0x47a6	; 0x47a6 <initializeSPI>
	initSpeedController();
     5b8:	0e 94 14 23 	call	0x4628	; 0x4628 <initSpeedController>

	//setPot(0x20);

	for(;;){
		int sonarData = getSonarData(0);
     5bc:	80 e0       	ldi	r24, 0x00	; 0
     5be:	90 e0       	ldi	r25, 0x00	; 0
     5c0:	0e 94 80 21 	call	0x4300	; 0x4300 <getSonarData>
     5c4:	88 2f       	mov	r24, r24
     5c6:	90 e0       	ldi	r25, 0x00	; 0
     5c8:	9d 8b       	std	Y+21, r25	; 0x15
     5ca:	8c 8b       	std	Y+20, r24	; 0x14
		printHex(sonarData);
     5cc:	8c 89       	ldd	r24, Y+20	; 0x14
     5ce:	9d 89       	ldd	r25, Y+21	; 0x15
     5d0:	0e 94 68 01 	call	0x2d0	; 0x2d0 <printHex>
		USART_Write('\n');
     5d4:	8a e0       	ldi	r24, 0x0A	; 10
     5d6:	0e 94 a9 1a 	call	0x3552	; 0x3552 <USART_Write>
		USART_Write('\r');
     5da:	8d e0       	ldi	r24, 0x0D	; 13
     5dc:	0e 94 a9 1a 	call	0x3552	; 0x3552 <USART_Write>
		sonarData = getSonarData(1);
     5e0:	81 e0       	ldi	r24, 0x01	; 1
     5e2:	90 e0       	ldi	r25, 0x00	; 0
     5e4:	0e 94 80 21 	call	0x4300	; 0x4300 <getSonarData>
     5e8:	88 2f       	mov	r24, r24
     5ea:	90 e0       	ldi	r25, 0x00	; 0
     5ec:	9d 8b       	std	Y+21, r25	; 0x15
     5ee:	8c 8b       	std	Y+20, r24	; 0x14
		printHex(sonarData);
     5f0:	8c 89       	ldd	r24, Y+20	; 0x14
     5f2:	9d 89       	ldd	r25, Y+21	; 0x15
     5f4:	0e 94 68 01 	call	0x2d0	; 0x2d0 <printHex>
		USART_Write('\n');
     5f8:	8a e0       	ldi	r24, 0x0A	; 10
     5fa:	0e 94 a9 1a 	call	0x3552	; 0x3552 <USART_Write>
		USART_Write('\r');	
     5fe:	8d e0       	ldi	r24, 0x0D	; 13
     600:	0e 94 a9 1a 	call	0x3552	; 0x3552 <USART_Write>
		vTaskDelay(5);	
     604:	85 e0       	ldi	r24, 0x05	; 5
     606:	90 e0       	ldi	r25, 0x00	; 0
     608:	0e 94 ca 04 	call	0x994	; 0x994 <vTaskDelay>
	}
     60c:	d7 cf       	rjmp	.-82     	; 0x5bc <vTaskFunction_1+0x86>

0000060e <vTaskFunction_2>:
		PORTL = 0x80;
		vTaskDelay(200);
	}
}

void vTaskFunction_2(void *pvParameters){
     60e:	cf 93       	push	r28
     610:	df 93       	push	r29
     612:	1f 92       	push	r1
     614:	1f 92       	push	r1
     616:	cd b7       	in	r28, 0x3d	; 61
     618:	de b7       	in	r29, 0x3e	; 62
     61a:	9a 83       	std	Y+2, r25	; 0x02
     61c:	89 83       	std	Y+1, r24	; 0x01
	DDRL = 0xF0;
     61e:	8a e0       	ldi	r24, 0x0A	; 10
     620:	91 e0       	ldi	r25, 0x01	; 1
     622:	20 ef       	ldi	r18, 0xF0	; 240
     624:	fc 01       	movw	r30, r24
     626:	20 83       	st	Z, r18
	PORTL = 0xC0;
     628:	8b e0       	ldi	r24, 0x0B	; 11
     62a:	91 e0       	ldi	r25, 0x01	; 1
     62c:	20 ec       	ldi	r18, 0xC0	; 192
     62e:	fc 01       	movw	r30, r24
     630:	20 83       	st	Z, r18
	for(;;){
		vTaskDelay(300);
     632:	8c e2       	ldi	r24, 0x2C	; 44
     634:	91 e0       	ldi	r25, 0x01	; 1
     636:	0e 94 ca 04 	call	0x994	; 0x994 <vTaskDelay>
	}	
     63a:	fb cf       	rjmp	.-10     	; 0x632 <vTaskFunction_2+0x24>

0000063c <vTaskPot>:
}

void vTaskPot(void *pvParameters){
     63c:	cf 93       	push	r28
     63e:	df 93       	push	r29
     640:	00 d0       	rcall	.+0      	; 0x642 <vTaskPot+0x6>
     642:	1f 92       	push	r1
     644:	cd b7       	in	r28, 0x3d	; 61
     646:	de b7       	in	r29, 0x3e	; 62
     648:	9c 83       	std	Y+4, r25	; 0x04
     64a:	8b 83       	std	Y+3, r24	; 0x03
	initializeSPI();
     64c:	0e 94 d3 23 	call	0x47a6	; 0x47a6 <initializeSPI>
	int a = 0;
     650:	1a 82       	std	Y+2, r1	; 0x02
     652:	19 82       	std	Y+1, r1	; 0x01
	initSpeedController();
     654:	0e 94 14 23 	call	0x4628	; 0x4628 <initSpeedController>
		setPot(a);
		vTaskDelay(80);
		a++;
	}*/
	for(;;){
		setPot(1);
     658:	81 e0       	ldi	r24, 0x01	; 1
     65a:	90 e0       	ldi	r25, 0x00	; 0
     65c:	0e 94 1f 23 	call	0x463e	; 0x463e <setPot>
		vTaskDelay(500);
     660:	84 ef       	ldi	r24, 0xF4	; 244
     662:	91 e0       	ldi	r25, 0x01	; 1
     664:	0e 94 ca 04 	call	0x994	; 0x994 <vTaskDelay>
		setPot(0x40);
     668:	80 e4       	ldi	r24, 0x40	; 64
     66a:	90 e0       	ldi	r25, 0x00	; 0
     66c:	0e 94 1f 23 	call	0x463e	; 0x463e <setPot>
		vTaskDelay(500);
     670:	84 ef       	ldi	r24, 0xF4	; 244
     672:	91 e0       	ldi	r25, 0x01	; 1
     674:	0e 94 ca 04 	call	0x994	; 0x994 <vTaskDelay>
		setPot(0x7F);
     678:	8f e7       	ldi	r24, 0x7F	; 127
     67a:	90 e0       	ldi	r25, 0x00	; 0
     67c:	0e 94 1f 23 	call	0x463e	; 0x463e <setPot>
		vTaskDelay(500);
     680:	84 ef       	ldi	r24, 0xF4	; 244
     682:	91 e0       	ldi	r25, 0x01	; 1
     684:	0e 94 ca 04 	call	0x994	; 0x994 <vTaskDelay>
		setPot(0x40);
     688:	80 e4       	ldi	r24, 0x40	; 64
     68a:	90 e0       	ldi	r25, 0x00	; 0
     68c:	0e 94 1f 23 	call	0x463e	; 0x463e <setPot>
		vTaskDelay(500);
     690:	84 ef       	ldi	r24, 0xF4	; 244
     692:	91 e0       	ldi	r25, 0x01	; 1
     694:	0e 94 ca 04 	call	0x994	; 0x994 <vTaskDelay>
	}
     698:	df cf       	rjmp	.-66     	; 0x658 <vTaskPot+0x1c>

0000069a <vIO_init>:
}


void vIO_init(void)
{
     69a:	cf 93       	push	r28
     69c:	df 93       	push	r29
     69e:	cd b7       	in	r28, 0x3d	; 61
     6a0:	de b7       	in	r29, 0x3e	; 62
    //- set PortB as output
	DDRB = 0xFF; 
     6a2:	84 e2       	ldi	r24, 0x24	; 36
     6a4:	90 e0       	ldi	r25, 0x00	; 0
     6a6:	2f ef       	ldi	r18, 0xFF	; 255
     6a8:	fc 01       	movw	r30, r24
     6aa:	20 83       	st	Z, r18
    PORTB = 0; 
     6ac:	85 e2       	ldi	r24, 0x25	; 37
     6ae:	90 e0       	ldi	r25, 0x00	; 0
     6b0:	fc 01       	movw	r30, r24
     6b2:	10 82       	st	Z, r1
}
     6b4:	df 91       	pop	r29
     6b6:	cf 91       	pop	r28
     6b8:	08 95       	ret

000006ba <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
     6ba:	af 92       	push	r10
     6bc:	bf 92       	push	r11
     6be:	cf 92       	push	r12
     6c0:	df 92       	push	r13
     6c2:	ef 92       	push	r14
     6c4:	ff 92       	push	r15
     6c6:	0f 93       	push	r16
     6c8:	1f 93       	push	r17
     6ca:	cf 93       	push	r28
     6cc:	df 93       	push	r29
     6ce:	cd b7       	in	r28, 0x3d	; 61
     6d0:	de b7       	in	r29, 0x3e	; 62
     6d2:	64 97       	sbiw	r28, 0x14	; 20
     6d4:	0f b6       	in	r0, 0x3f	; 63
     6d6:	f8 94       	cli
     6d8:	de bf       	out	0x3e, r29	; 62
     6da:	0f be       	out	0x3f, r0	; 63
     6dc:	cd bf       	out	0x3d, r28	; 61
     6de:	9f 83       	std	Y+7, r25	; 0x07
     6e0:	8e 83       	std	Y+6, r24	; 0x06
     6e2:	79 87       	std	Y+9, r23	; 0x09
     6e4:	68 87       	std	Y+8, r22	; 0x08
     6e6:	5b 87       	std	Y+11, r21	; 0x0b
     6e8:	4a 87       	std	Y+10, r20	; 0x0a
     6ea:	3d 87       	std	Y+13, r19	; 0x0d
     6ec:	2c 87       	std	Y+12, r18	; 0x0c
     6ee:	0e 87       	std	Y+14, r16	; 0x0e
     6f0:	f8 8a       	std	Y+16, r15	; 0x10
     6f2:	ef 86       	std	Y+15, r14	; 0x0f
     6f4:	da 8a       	std	Y+18, r13	; 0x12
     6f6:	c9 8a       	std	Y+17, r12	; 0x11
     6f8:	bc 8a       	std	Y+20, r11	; 0x14
     6fa:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
     6fc:	29 89       	ldd	r18, Y+17	; 0x11
     6fe:	3a 89       	ldd	r19, Y+18	; 0x12
     700:	8a 85       	ldd	r24, Y+10	; 0x0a
     702:	9b 85       	ldd	r25, Y+11	; 0x0b
     704:	b9 01       	movw	r22, r18
     706:	0e 94 13 0b 	call	0x1626	; 0x1626 <prvAllocateTCBAndStack>
     70a:	9b 83       	std	Y+3, r25	; 0x03
     70c:	8a 83       	std	Y+2, r24	; 0x02

	if( pxNewTCB != NULL )
     70e:	8a 81       	ldd	r24, Y+2	; 0x02
     710:	9b 81       	ldd	r25, Y+3	; 0x03
     712:	00 97       	sbiw	r24, 0x00	; 0
     714:	09 f4       	brne	.+2      	; 0x718 <xTaskGenericCreate+0x5e>
     716:	9f c0       	rjmp	.+318    	; 0x856 <xTaskGenericCreate+0x19c>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
     718:	8a 81       	ldd	r24, Y+2	; 0x02
     71a:	9b 81       	ldd	r25, Y+3	; 0x03
     71c:	fc 01       	movw	r30, r24
     71e:	27 89       	ldd	r18, Z+23	; 0x17
     720:	30 8d       	ldd	r19, Z+24	; 0x18
     722:	8a 85       	ldd	r24, Y+10	; 0x0a
     724:	9b 85       	ldd	r25, Y+11	; 0x0b
     726:	01 97       	sbiw	r24, 0x01	; 1
     728:	82 0f       	add	r24, r18
     72a:	93 1f       	adc	r25, r19
     72c:	9d 83       	std	Y+5, r25	; 0x05
     72e:	8c 83       	std	Y+4, r24	; 0x04
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
     730:	4a 85       	ldd	r20, Y+10	; 0x0a
     732:	5b 85       	ldd	r21, Y+11	; 0x0b
     734:	2b 89       	ldd	r18, Y+19	; 0x13
     736:	3c 89       	ldd	r19, Y+20	; 0x14
     738:	68 85       	ldd	r22, Y+8	; 0x08
     73a:	79 85       	ldd	r23, Y+9	; 0x09
     73c:	8a 81       	ldd	r24, Y+2	; 0x02
     73e:	9b 81       	ldd	r25, Y+3	; 0x03
     740:	8a 01       	movw	r16, r20
     742:	4e 85       	ldd	r20, Y+14	; 0x0e
     744:	0e 94 23 0a 	call	0x1446	; 0x1446 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     748:	4c 85       	ldd	r20, Y+12	; 0x0c
     74a:	5d 85       	ldd	r21, Y+13	; 0x0d
     74c:	2e 81       	ldd	r18, Y+6	; 0x06
     74e:	3f 81       	ldd	r19, Y+7	; 0x07
     750:	8c 81       	ldd	r24, Y+4	; 0x04
     752:	9d 81       	ldd	r25, Y+5	; 0x05
     754:	b9 01       	movw	r22, r18
     756:	0e 94 3b 17 	call	0x2e76	; 0x2e76 <pxPortInitialiseStack>
     75a:	9c 01       	movw	r18, r24
     75c:	8a 81       	ldd	r24, Y+2	; 0x02
     75e:	9b 81       	ldd	r25, Y+3	; 0x03
     760:	fc 01       	movw	r30, r24
     762:	31 83       	std	Z+1, r19	; 0x01
     764:	20 83       	st	Z, r18
		#endif

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
     766:	8f 85       	ldd	r24, Y+15	; 0x0f
     768:	98 89       	ldd	r25, Y+16	; 0x10
     76a:	00 97       	sbiw	r24, 0x00	; 0
     76c:	39 f0       	breq	.+14     	; 0x77c <xTaskGenericCreate+0xc2>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
     76e:	8f 85       	ldd	r24, Y+15	; 0x0f
     770:	98 89       	ldd	r25, Y+16	; 0x10
     772:	2a 81       	ldd	r18, Y+2	; 0x02
     774:	3b 81       	ldd	r19, Y+3	; 0x03
     776:	fc 01       	movw	r30, r24
     778:	31 83       	std	Z+1, r19	; 0x01
     77a:	20 83       	st	Z, r18
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
     77c:	0f b6       	in	r0, 0x3f	; 63
     77e:	f8 94       	cli
     780:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
     782:	80 91 7e 02 	lds	r24, 0x027E
     786:	8f 5f       	subi	r24, 0xFF	; 255
     788:	80 93 7e 02 	sts	0x027E, r24
			if( pxCurrentTCB == NULL )
     78c:	80 91 30 02 	lds	r24, 0x0230
     790:	90 91 31 02 	lds	r25, 0x0231
     794:	00 97       	sbiw	r24, 0x00	; 0
     796:	69 f4       	brne	.+26     	; 0x7b2 <xTaskGenericCreate+0xf8>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
     798:	8a 81       	ldd	r24, Y+2	; 0x02
     79a:	9b 81       	ldd	r25, Y+3	; 0x03
     79c:	90 93 31 02 	sts	0x0231, r25
     7a0:	80 93 30 02 	sts	0x0230, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
     7a4:	80 91 7e 02 	lds	r24, 0x027E
     7a8:	81 30       	cpi	r24, 0x01	; 1
     7aa:	b1 f4       	brne	.+44     	; 0x7d8 <xTaskGenericCreate+0x11e>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
     7ac:	0e 94 84 0a 	call	0x1508	; 0x1508 <prvInitialiseTaskLists>
     7b0:	13 c0       	rjmp	.+38     	; 0x7d8 <xTaskGenericCreate+0x11e>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
     7b2:	80 91 83 02 	lds	r24, 0x0283
     7b6:	88 23       	and	r24, r24
     7b8:	79 f4       	brne	.+30     	; 0x7d8 <xTaskGenericCreate+0x11e>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
     7ba:	80 91 30 02 	lds	r24, 0x0230
     7be:	90 91 31 02 	lds	r25, 0x0231
     7c2:	fc 01       	movw	r30, r24
     7c4:	96 89       	ldd	r25, Z+22	; 0x16
     7c6:	8e 85       	ldd	r24, Y+14	; 0x0e
     7c8:	89 17       	cp	r24, r25
     7ca:	30 f0       	brcs	.+12     	; 0x7d8 <xTaskGenericCreate+0x11e>
					{
						pxCurrentTCB = pxNewTCB;
     7cc:	8a 81       	ldd	r24, Y+2	; 0x02
     7ce:	9b 81       	ldd	r25, Y+3	; 0x03
     7d0:	90 93 31 02 	sts	0x0231, r25
     7d4:	80 93 30 02 	sts	0x0230, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
     7d8:	8a 81       	ldd	r24, Y+2	; 0x02
     7da:	9b 81       	ldd	r25, Y+3	; 0x03
     7dc:	fc 01       	movw	r30, r24
     7de:	96 89       	ldd	r25, Z+22	; 0x16
     7e0:	80 91 81 02 	lds	r24, 0x0281
     7e4:	89 17       	cp	r24, r25
     7e6:	30 f4       	brcc	.+12     	; 0x7f4 <xTaskGenericCreate+0x13a>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
     7e8:	8a 81       	ldd	r24, Y+2	; 0x02
     7ea:	9b 81       	ldd	r25, Y+3	; 0x03
     7ec:	fc 01       	movw	r30, r24
     7ee:	86 89       	ldd	r24, Z+22	; 0x16
     7f0:	80 93 81 02 	sts	0x0281, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
     7f4:	80 91 88 02 	lds	r24, 0x0288
     7f8:	8f 5f       	subi	r24, 0xFF	; 255
     7fa:	80 93 88 02 	sts	0x0288, r24

			prvAddTaskToReadyQueue( pxNewTCB );
     7fe:	8a 81       	ldd	r24, Y+2	; 0x02
     800:	9b 81       	ldd	r25, Y+3	; 0x03
     802:	fc 01       	movw	r30, r24
     804:	96 89       	ldd	r25, Z+22	; 0x16
     806:	80 91 82 02 	lds	r24, 0x0282
     80a:	89 17       	cp	r24, r25
     80c:	30 f4       	brcc	.+12     	; 0x81a <xTaskGenericCreate+0x160>
     80e:	8a 81       	ldd	r24, Y+2	; 0x02
     810:	9b 81       	ldd	r25, Y+3	; 0x03
     812:	fc 01       	movw	r30, r24
     814:	86 89       	ldd	r24, Z+22	; 0x16
     816:	80 93 82 02 	sts	0x0282, r24
     81a:	8a 81       	ldd	r24, Y+2	; 0x02
     81c:	9b 81       	ldd	r25, Y+3	; 0x03
     81e:	ac 01       	movw	r20, r24
     820:	4e 5f       	subi	r20, 0xFE	; 254
     822:	5f 4f       	sbci	r21, 0xFF	; 255
     824:	8a 81       	ldd	r24, Y+2	; 0x02
     826:	9b 81       	ldd	r25, Y+3	; 0x03
     828:	fc 01       	movw	r30, r24
     82a:	86 89       	ldd	r24, Z+22	; 0x16
     82c:	28 2f       	mov	r18, r24
     82e:	30 e0       	ldi	r19, 0x00	; 0
     830:	c9 01       	movw	r24, r18
     832:	88 0f       	add	r24, r24
     834:	99 1f       	adc	r25, r25
     836:	88 0f       	add	r24, r24
     838:	99 1f       	adc	r25, r25
     83a:	88 0f       	add	r24, r24
     83c:	99 1f       	adc	r25, r25
     83e:	82 0f       	add	r24, r18
     840:	93 1f       	adc	r25, r19
     842:	8e 5c       	subi	r24, 0xCE	; 206
     844:	9d 4f       	sbci	r25, 0xFD	; 253
     846:	ba 01       	movw	r22, r20
     848:	0e 94 ad 12 	call	0x255a	; 0x255a <vListInsertEnd>

			xReturn = pdPASS;
     84c:	81 e0       	ldi	r24, 0x01	; 1
     84e:	89 83       	std	Y+1, r24	; 0x01
			portSETUP_TCB( pxNewTCB );
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
     850:	0f 90       	pop	r0
     852:	0f be       	out	0x3f, r0	; 63
     854:	02 c0       	rjmp	.+4      	; 0x85a <xTaskGenericCreate+0x1a0>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     856:	8f ef       	ldi	r24, 0xFF	; 255
     858:	89 83       	std	Y+1, r24	; 0x01
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
     85a:	89 81       	ldd	r24, Y+1	; 0x01
     85c:	81 30       	cpi	r24, 0x01	; 1
     85e:	79 f4       	brne	.+30     	; 0x87e <xTaskGenericCreate+0x1c4>
	{
		if( xSchedulerRunning != pdFALSE )
     860:	80 91 83 02 	lds	r24, 0x0283
     864:	88 23       	and	r24, r24
     866:	59 f0       	breq	.+22     	; 0x87e <xTaskGenericCreate+0x1c4>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
     868:	80 91 30 02 	lds	r24, 0x0230
     86c:	90 91 31 02 	lds	r25, 0x0231
     870:	fc 01       	movw	r30, r24
     872:	96 89       	ldd	r25, Z+22	; 0x16
     874:	8e 85       	ldd	r24, Y+14	; 0x0e
     876:	98 17       	cp	r25, r24
     878:	10 f4       	brcc	.+4      	; 0x87e <xTaskGenericCreate+0x1c4>
			{
				portYIELD_WITHIN_API();
     87a:	0e 94 3f 19 	call	0x327e	; 0x327e <vPortYield>
			}
		}
	}

	return xReturn;
     87e:	89 81       	ldd	r24, Y+1	; 0x01
}
     880:	64 96       	adiw	r28, 0x14	; 20
     882:	0f b6       	in	r0, 0x3f	; 63
     884:	f8 94       	cli
     886:	de bf       	out	0x3e, r29	; 62
     888:	0f be       	out	0x3f, r0	; 63
     88a:	cd bf       	out	0x3d, r28	; 61
     88c:	df 91       	pop	r29
     88e:	cf 91       	pop	r28
     890:	1f 91       	pop	r17
     892:	0f 91       	pop	r16
     894:	ff 90       	pop	r15
     896:	ef 90       	pop	r14
     898:	df 90       	pop	r13
     89a:	cf 90       	pop	r12
     89c:	bf 90       	pop	r11
     89e:	af 90       	pop	r10
     8a0:	08 95       	ret

000008a2 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
     8a2:	cf 93       	push	r28
     8a4:	df 93       	push	r29
     8a6:	cd b7       	in	r28, 0x3d	; 61
     8a8:	de b7       	in	r29, 0x3e	; 62
     8aa:	28 97       	sbiw	r28, 0x08	; 8
     8ac:	0f b6       	in	r0, 0x3f	; 63
     8ae:	f8 94       	cli
     8b0:	de bf       	out	0x3e, r29	; 62
     8b2:	0f be       	out	0x3f, r0	; 63
     8b4:	cd bf       	out	0x3d, r28	; 61
     8b6:	9e 83       	std	Y+6, r25	; 0x06
     8b8:	8d 83       	std	Y+5, r24	; 0x05
     8ba:	78 87       	std	Y+8, r23	; 0x08
     8bc:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
     8be:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
     8c0:	0e 94 9e 06 	call	0xd3c	; 0xd3c <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     8c4:	8d 81       	ldd	r24, Y+5	; 0x05
     8c6:	9e 81       	ldd	r25, Y+6	; 0x06
     8c8:	fc 01       	movw	r30, r24
     8ca:	20 81       	ld	r18, Z
     8cc:	31 81       	ldd	r19, Z+1	; 0x01
     8ce:	8f 81       	ldd	r24, Y+7	; 0x07
     8d0:	98 85       	ldd	r25, Y+8	; 0x08
     8d2:	82 0f       	add	r24, r18
     8d4:	93 1f       	adc	r25, r19
     8d6:	9b 83       	std	Y+3, r25	; 0x03
     8d8:	8a 83       	std	Y+2, r24	; 0x02

			if( xTickCount < *pxPreviousWakeTime )
     8da:	8d 81       	ldd	r24, Y+5	; 0x05
     8dc:	9e 81       	ldd	r25, Y+6	; 0x06
     8de:	fc 01       	movw	r30, r24
     8e0:	20 81       	ld	r18, Z
     8e2:	31 81       	ldd	r19, Z+1	; 0x01
     8e4:	80 91 7f 02 	lds	r24, 0x027F
     8e8:	90 91 80 02 	lds	r25, 0x0280
     8ec:	82 17       	cp	r24, r18
     8ee:	93 07       	cpc	r25, r19
     8f0:	b0 f4       	brcc	.+44     	; 0x91e <vTaskDelayUntil+0x7c>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
     8f2:	8d 81       	ldd	r24, Y+5	; 0x05
     8f4:	9e 81       	ldd	r25, Y+6	; 0x06
     8f6:	fc 01       	movw	r30, r24
     8f8:	20 81       	ld	r18, Z
     8fa:	31 81       	ldd	r19, Z+1	; 0x01
     8fc:	8a 81       	ldd	r24, Y+2	; 0x02
     8fe:	9b 81       	ldd	r25, Y+3	; 0x03
     900:	82 17       	cp	r24, r18
     902:	93 07       	cpc	r25, r19
     904:	08 f5       	brcc	.+66     	; 0x948 <vTaskDelayUntil+0xa6>
     906:	80 91 7f 02 	lds	r24, 0x027F
     90a:	90 91 80 02 	lds	r25, 0x0280
     90e:	2a 81       	ldd	r18, Y+2	; 0x02
     910:	3b 81       	ldd	r19, Y+3	; 0x03
     912:	82 17       	cp	r24, r18
     914:	93 07       	cpc	r25, r19
     916:	c0 f4       	brcc	.+48     	; 0x948 <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
     918:	81 e0       	ldi	r24, 0x01	; 1
     91a:	89 83       	std	Y+1, r24	; 0x01
     91c:	15 c0       	rjmp	.+42     	; 0x948 <vTaskDelayUntil+0xa6>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
     91e:	8d 81       	ldd	r24, Y+5	; 0x05
     920:	9e 81       	ldd	r25, Y+6	; 0x06
     922:	fc 01       	movw	r30, r24
     924:	20 81       	ld	r18, Z
     926:	31 81       	ldd	r19, Z+1	; 0x01
     928:	8a 81       	ldd	r24, Y+2	; 0x02
     92a:	9b 81       	ldd	r25, Y+3	; 0x03
     92c:	82 17       	cp	r24, r18
     92e:	93 07       	cpc	r25, r19
     930:	48 f0       	brcs	.+18     	; 0x944 <vTaskDelayUntil+0xa2>
     932:	80 91 7f 02 	lds	r24, 0x027F
     936:	90 91 80 02 	lds	r25, 0x0280
     93a:	2a 81       	ldd	r18, Y+2	; 0x02
     93c:	3b 81       	ldd	r19, Y+3	; 0x03
     93e:	82 17       	cp	r24, r18
     940:	93 07       	cpc	r25, r19
     942:	10 f4       	brcc	.+4      	; 0x948 <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
     944:	81 e0       	ldi	r24, 0x01	; 1
     946:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     948:	8d 81       	ldd	r24, Y+5	; 0x05
     94a:	9e 81       	ldd	r25, Y+6	; 0x06
     94c:	2a 81       	ldd	r18, Y+2	; 0x02
     94e:	3b 81       	ldd	r19, Y+3	; 0x03
     950:	fc 01       	movw	r30, r24
     952:	31 83       	std	Z+1, r19	; 0x01
     954:	20 83       	st	Z, r18

			if( xShouldDelay != pdFALSE )
     956:	89 81       	ldd	r24, Y+1	; 0x01
     958:	88 23       	and	r24, r24
     95a:	59 f0       	breq	.+22     	; 0x972 <vTaskDelayUntil+0xd0>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
     95c:	80 91 30 02 	lds	r24, 0x0230
     960:	90 91 31 02 	lds	r25, 0x0231
     964:	02 96       	adiw	r24, 0x02	; 2
     966:	0e 94 7d 13 	call	0x26fa	; 0x26fa <uxListRemove>
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
     96a:	8a 81       	ldd	r24, Y+2	; 0x02
     96c:	9b 81       	ldd	r25, Y+3	; 0x03
     96e:	0e 94 c8 0a 	call	0x1590	; 0x1590 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     972:	0e 94 aa 06 	call	0xd54	; 0xd54 <xTaskResumeAll>
     976:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     978:	8c 81       	ldd	r24, Y+4	; 0x04
     97a:	88 23       	and	r24, r24
     97c:	11 f4       	brne	.+4      	; 0x982 <vTaskDelayUntil+0xe0>
		{
			portYIELD_WITHIN_API();
     97e:	0e 94 3f 19 	call	0x327e	; 0x327e <vPortYield>
		}
	}
     982:	28 96       	adiw	r28, 0x08	; 8
     984:	0f b6       	in	r0, 0x3f	; 63
     986:	f8 94       	cli
     988:	de bf       	out	0x3e, r29	; 62
     98a:	0f be       	out	0x3f, r0	; 63
     98c:	cd bf       	out	0x3d, r28	; 61
     98e:	df 91       	pop	r29
     990:	cf 91       	pop	r28
     992:	08 95       	ret

00000994 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
     994:	cf 93       	push	r28
     996:	df 93       	push	r29
     998:	00 d0       	rcall	.+0      	; 0x99a <vTaskDelay+0x6>
     99a:	1f 92       	push	r1
     99c:	1f 92       	push	r1
     99e:	cd b7       	in	r28, 0x3d	; 61
     9a0:	de b7       	in	r29, 0x3e	; 62
     9a2:	9d 83       	std	Y+5, r25	; 0x05
     9a4:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
     9a6:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
     9a8:	8c 81       	ldd	r24, Y+4	; 0x04
     9aa:	9d 81       	ldd	r25, Y+5	; 0x05
     9ac:	00 97       	sbiw	r24, 0x00	; 0
     9ae:	d1 f0       	breq	.+52     	; 0x9e4 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
     9b0:	0e 94 9e 06 	call	0xd3c	; 0xd3c <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
     9b4:	20 91 7f 02 	lds	r18, 0x027F
     9b8:	30 91 80 02 	lds	r19, 0x0280
     9bc:	8c 81       	ldd	r24, Y+4	; 0x04
     9be:	9d 81       	ldd	r25, Y+5	; 0x05
     9c0:	82 0f       	add	r24, r18
     9c2:	93 1f       	adc	r25, r19
     9c4:	9b 83       	std	Y+3, r25	; 0x03
     9c6:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
     9c8:	80 91 30 02 	lds	r24, 0x0230
     9cc:	90 91 31 02 	lds	r25, 0x0231
     9d0:	02 96       	adiw	r24, 0x02	; 2
     9d2:	0e 94 7d 13 	call	0x26fa	; 0x26fa <uxListRemove>
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
     9d6:	8a 81       	ldd	r24, Y+2	; 0x02
     9d8:	9b 81       	ldd	r25, Y+3	; 0x03
     9da:	0e 94 c8 0a 	call	0x1590	; 0x1590 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     9de:	0e 94 aa 06 	call	0xd54	; 0xd54 <xTaskResumeAll>
     9e2:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     9e4:	89 81       	ldd	r24, Y+1	; 0x01
     9e6:	88 23       	and	r24, r24
     9e8:	11 f4       	brne	.+4      	; 0x9ee <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
     9ea:	0e 94 3f 19 	call	0x327e	; 0x327e <vPortYield>
		}
	}
     9ee:	0f 90       	pop	r0
     9f0:	0f 90       	pop	r0
     9f2:	0f 90       	pop	r0
     9f4:	0f 90       	pop	r0
     9f6:	0f 90       	pop	r0
     9f8:	df 91       	pop	r29
     9fa:	cf 91       	pop	r28
     9fc:	08 95       	ret

000009fe <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
     9fe:	cf 93       	push	r28
     a00:	df 93       	push	r29
     a02:	00 d0       	rcall	.+0      	; 0xa04 <vTaskSuspend+0x6>
     a04:	1f 92       	push	r1
     a06:	cd b7       	in	r28, 0x3d	; 61
     a08:	de b7       	in	r29, 0x3e	; 62
     a0a:	9c 83       	std	Y+4, r25	; 0x04
     a0c:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
     a0e:	0f b6       	in	r0, 0x3f	; 63
     a10:	f8 94       	cli
     a12:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
     a14:	80 91 30 02 	lds	r24, 0x0230
     a18:	90 91 31 02 	lds	r25, 0x0231
     a1c:	2b 81       	ldd	r18, Y+3	; 0x03
     a1e:	3c 81       	ldd	r19, Y+4	; 0x04
     a20:	28 17       	cp	r18, r24
     a22:	39 07       	cpc	r19, r25
     a24:	11 f4       	brne	.+4      	; 0xa2a <vTaskSuspend+0x2c>
			{
				pxTaskToSuspend = NULL;
     a26:	1c 82       	std	Y+4, r1	; 0x04
     a28:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
     a2a:	8b 81       	ldd	r24, Y+3	; 0x03
     a2c:	9c 81       	ldd	r25, Y+4	; 0x04
     a2e:	00 97       	sbiw	r24, 0x00	; 0
     a30:	29 f4       	brne	.+10     	; 0xa3c <vTaskSuspend+0x3e>
     a32:	80 91 30 02 	lds	r24, 0x0230
     a36:	90 91 31 02 	lds	r25, 0x0231
     a3a:	02 c0       	rjmp	.+4      	; 0xa40 <vTaskSuspend+0x42>
     a3c:	8b 81       	ldd	r24, Y+3	; 0x03
     a3e:	9c 81       	ldd	r25, Y+4	; 0x04
     a40:	9a 83       	std	Y+2, r25	; 0x02
     a42:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
     a44:	89 81       	ldd	r24, Y+1	; 0x01
     a46:	9a 81       	ldd	r25, Y+2	; 0x02
     a48:	02 96       	adiw	r24, 0x02	; 2
     a4a:	0e 94 7d 13 	call	0x26fa	; 0x26fa <uxListRemove>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
			}

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
     a4e:	89 81       	ldd	r24, Y+1	; 0x01
     a50:	9a 81       	ldd	r25, Y+2	; 0x02
     a52:	fc 01       	movw	r30, r24
     a54:	84 89       	ldd	r24, Z+20	; 0x14
     a56:	95 89       	ldd	r25, Z+21	; 0x15
     a58:	00 97       	sbiw	r24, 0x00	; 0
     a5a:	29 f0       	breq	.+10     	; 0xa66 <vTaskSuspend+0x68>
			{
				uxListRemove( &( pxTCB->xEventListItem ) );
     a5c:	89 81       	ldd	r24, Y+1	; 0x01
     a5e:	9a 81       	ldd	r25, Y+2	; 0x02
     a60:	0c 96       	adiw	r24, 0x0c	; 12
     a62:	0e 94 7d 13 	call	0x26fa	; 0x26fa <uxListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
     a66:	89 81       	ldd	r24, Y+1	; 0x01
     a68:	9a 81       	ldd	r25, Y+2	; 0x02
     a6a:	02 96       	adiw	r24, 0x02	; 2
     a6c:	bc 01       	movw	r22, r24
     a6e:	85 e7       	ldi	r24, 0x75	; 117
     a70:	92 e0       	ldi	r25, 0x02	; 2
     a72:	0e 94 ad 12 	call	0x255a	; 0x255a <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
     a76:	0f 90       	pop	r0
     a78:	0f be       	out	0x3f, r0	; 63

		if( ( void * ) pxTaskToSuspend == NULL )
     a7a:	8b 81       	ldd	r24, Y+3	; 0x03
     a7c:	9c 81       	ldd	r25, Y+4	; 0x04
     a7e:	00 97       	sbiw	r24, 0x00	; 0
     a80:	a1 f4       	brne	.+40     	; 0xaaa <vTaskSuspend+0xac>
		{
			if( xSchedulerRunning != pdFALSE )
     a82:	80 91 83 02 	lds	r24, 0x0283
     a86:	88 23       	and	r24, r24
     a88:	19 f0       	breq	.+6      	; 0xa90 <vTaskSuspend+0x92>
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
     a8a:	0e 94 3f 19 	call	0x327e	; 0x327e <vPortYield>
     a8e:	0d c0       	rjmp	.+26     	; 0xaaa <vTaskSuspend+0xac>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
     a90:	90 91 75 02 	lds	r25, 0x0275
     a94:	80 91 7e 02 	lds	r24, 0x027E
     a98:	98 17       	cp	r25, r24
     a9a:	29 f4       	brne	.+10     	; 0xaa6 <vTaskSuspend+0xa8>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
     a9c:	10 92 31 02 	sts	0x0231, r1
     aa0:	10 92 30 02 	sts	0x0230, r1
     aa4:	02 c0       	rjmp	.+4      	; 0xaaa <vTaskSuspend+0xac>
				}
				else
				{
					vTaskSwitchContext();
     aa6:	0e 94 40 08 	call	0x1080	; 0x1080 <vTaskSwitchContext>
				}
			}
		}
	}
     aaa:	0f 90       	pop	r0
     aac:	0f 90       	pop	r0
     aae:	0f 90       	pop	r0
     ab0:	0f 90       	pop	r0
     ab2:	df 91       	pop	r29
     ab4:	cf 91       	pop	r28
     ab6:	08 95       	ret

00000ab8 <xTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
     ab8:	cf 93       	push	r28
     aba:	df 93       	push	r29
     abc:	00 d0       	rcall	.+0      	; 0xabe <xTaskIsTaskSuspended+0x6>
     abe:	1f 92       	push	r1
     ac0:	1f 92       	push	r1
     ac2:	cd b7       	in	r28, 0x3d	; 61
     ac4:	de b7       	in	r29, 0x3e	; 62
     ac6:	9d 83       	std	Y+5, r25	; 0x05
     ac8:	8c 83       	std	Y+4, r24	; 0x04
	portBASE_TYPE xReturn = pdFALSE;
     aca:	19 82       	std	Y+1, r1	; 0x01
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
     acc:	8c 81       	ldd	r24, Y+4	; 0x04
     ace:	9d 81       	ldd	r25, Y+5	; 0x05
     ad0:	9b 83       	std	Y+3, r25	; 0x03
     ad2:	8a 83       	std	Y+2, r24	; 0x02
		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
     ad4:	8a 81       	ldd	r24, Y+2	; 0x02
     ad6:	9b 81       	ldd	r25, Y+3	; 0x03
     ad8:	fc 01       	movw	r30, r24
     ada:	82 85       	ldd	r24, Z+10	; 0x0a
     adc:	93 85       	ldd	r25, Z+11	; 0x0b
     ade:	f2 e0       	ldi	r31, 0x02	; 2
     ae0:	85 37       	cpi	r24, 0x75	; 117
     ae2:	9f 07       	cpc	r25, r31
     ae4:	91 f4       	brne	.+36     	; 0xb0a <xTaskIsTaskSuspended+0x52>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
     ae6:	8a 81       	ldd	r24, Y+2	; 0x02
     ae8:	9b 81       	ldd	r25, Y+3	; 0x03
     aea:	fc 01       	movw	r30, r24
     aec:	84 89       	ldd	r24, Z+20	; 0x14
     aee:	95 89       	ldd	r25, Z+21	; 0x15
     af0:	f2 e0       	ldi	r31, 0x02	; 2
     af2:	8c 36       	cpi	r24, 0x6C	; 108
     af4:	9f 07       	cpc	r25, r31
     af6:	49 f0       	breq	.+18     	; 0xb0a <xTaskIsTaskSuspended+0x52>
			{
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
     af8:	8a 81       	ldd	r24, Y+2	; 0x02
     afa:	9b 81       	ldd	r25, Y+3	; 0x03
     afc:	fc 01       	movw	r30, r24
     afe:	84 89       	ldd	r24, Z+20	; 0x14
     b00:	95 89       	ldd	r25, Z+21	; 0x15
     b02:	00 97       	sbiw	r24, 0x00	; 0
     b04:	11 f4       	brne	.+4      	; 0xb0a <xTaskIsTaskSuspended+0x52>
				{
					xReturn = pdTRUE;
     b06:	81 e0       	ldi	r24, 0x01	; 1
     b08:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}

		return xReturn;
     b0a:	89 81       	ldd	r24, Y+1	; 0x01
	}
     b0c:	0f 90       	pop	r0
     b0e:	0f 90       	pop	r0
     b10:	0f 90       	pop	r0
     b12:	0f 90       	pop	r0
     b14:	0f 90       	pop	r0
     b16:	df 91       	pop	r29
     b18:	cf 91       	pop	r28
     b1a:	08 95       	ret

00000b1c <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
     b1c:	cf 93       	push	r28
     b1e:	df 93       	push	r29
     b20:	00 d0       	rcall	.+0      	; 0xb22 <vTaskResume+0x6>
     b22:	1f 92       	push	r1
     b24:	cd b7       	in	r28, 0x3d	; 61
     b26:	de b7       	in	r29, 0x3e	; 62
     b28:	9c 83       	std	Y+4, r25	; 0x04
     b2a:	8b 83       	std	Y+3, r24	; 0x03
		/* It does not make sense to resume the calling task. */
		configASSERT( pxTaskToResume );

		/* Remove the task from whichever list it is currently in, and place
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;
     b2c:	8b 81       	ldd	r24, Y+3	; 0x03
     b2e:	9c 81       	ldd	r25, Y+4	; 0x04
     b30:	9a 83       	std	Y+2, r25	; 0x02
     b32:	89 83       	std	Y+1, r24	; 0x01

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
     b34:	89 81       	ldd	r24, Y+1	; 0x01
     b36:	9a 81       	ldd	r25, Y+2	; 0x02
     b38:	00 97       	sbiw	r24, 0x00	; 0
     b3a:	09 f4       	brne	.+2      	; 0xb3e <vTaskResume+0x22>
     b3c:	4f c0       	rjmp	.+158    	; 0xbdc <vTaskResume+0xc0>
     b3e:	80 91 30 02 	lds	r24, 0x0230
     b42:	90 91 31 02 	lds	r25, 0x0231
     b46:	29 81       	ldd	r18, Y+1	; 0x01
     b48:	3a 81       	ldd	r19, Y+2	; 0x02
     b4a:	28 17       	cp	r18, r24
     b4c:	39 07       	cpc	r19, r25
     b4e:	09 f4       	brne	.+2      	; 0xb52 <vTaskResume+0x36>
     b50:	45 c0       	rjmp	.+138    	; 0xbdc <vTaskResume+0xc0>
		{
			taskENTER_CRITICAL();
     b52:	0f b6       	in	r0, 0x3f	; 63
     b54:	f8 94       	cli
     b56:	0f 92       	push	r0
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
     b58:	89 81       	ldd	r24, Y+1	; 0x01
     b5a:	9a 81       	ldd	r25, Y+2	; 0x02
     b5c:	0e 94 5c 05 	call	0xab8	; 0xab8 <xTaskIsTaskSuspended>
     b60:	81 30       	cpi	r24, 0x01	; 1
     b62:	d1 f5       	brne	.+116    	; 0xbd8 <vTaskResume+0xbc>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					uxListRemove(  &( pxTCB->xGenericListItem ) );
     b64:	89 81       	ldd	r24, Y+1	; 0x01
     b66:	9a 81       	ldd	r25, Y+2	; 0x02
     b68:	02 96       	adiw	r24, 0x02	; 2
     b6a:	0e 94 7d 13 	call	0x26fa	; 0x26fa <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
     b6e:	89 81       	ldd	r24, Y+1	; 0x01
     b70:	9a 81       	ldd	r25, Y+2	; 0x02
     b72:	fc 01       	movw	r30, r24
     b74:	96 89       	ldd	r25, Z+22	; 0x16
     b76:	80 91 82 02 	lds	r24, 0x0282
     b7a:	89 17       	cp	r24, r25
     b7c:	30 f4       	brcc	.+12     	; 0xb8a <vTaskResume+0x6e>
     b7e:	89 81       	ldd	r24, Y+1	; 0x01
     b80:	9a 81       	ldd	r25, Y+2	; 0x02
     b82:	fc 01       	movw	r30, r24
     b84:	86 89       	ldd	r24, Z+22	; 0x16
     b86:	80 93 82 02 	sts	0x0282, r24
     b8a:	89 81       	ldd	r24, Y+1	; 0x01
     b8c:	9a 81       	ldd	r25, Y+2	; 0x02
     b8e:	ac 01       	movw	r20, r24
     b90:	4e 5f       	subi	r20, 0xFE	; 254
     b92:	5f 4f       	sbci	r21, 0xFF	; 255
     b94:	89 81       	ldd	r24, Y+1	; 0x01
     b96:	9a 81       	ldd	r25, Y+2	; 0x02
     b98:	fc 01       	movw	r30, r24
     b9a:	86 89       	ldd	r24, Z+22	; 0x16
     b9c:	28 2f       	mov	r18, r24
     b9e:	30 e0       	ldi	r19, 0x00	; 0
     ba0:	c9 01       	movw	r24, r18
     ba2:	88 0f       	add	r24, r24
     ba4:	99 1f       	adc	r25, r25
     ba6:	88 0f       	add	r24, r24
     ba8:	99 1f       	adc	r25, r25
     baa:	88 0f       	add	r24, r24
     bac:	99 1f       	adc	r25, r25
     bae:	82 0f       	add	r24, r18
     bb0:	93 1f       	adc	r25, r19
     bb2:	8e 5c       	subi	r24, 0xCE	; 206
     bb4:	9d 4f       	sbci	r25, 0xFD	; 253
     bb6:	ba 01       	movw	r22, r20
     bb8:	0e 94 ad 12 	call	0x255a	; 0x255a <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     bbc:	89 81       	ldd	r24, Y+1	; 0x01
     bbe:	9a 81       	ldd	r25, Y+2	; 0x02
     bc0:	fc 01       	movw	r30, r24
     bc2:	26 89       	ldd	r18, Z+22	; 0x16
     bc4:	80 91 30 02 	lds	r24, 0x0230
     bc8:	90 91 31 02 	lds	r25, 0x0231
     bcc:	fc 01       	movw	r30, r24
     bce:	86 89       	ldd	r24, Z+22	; 0x16
     bd0:	28 17       	cp	r18, r24
     bd2:	10 f0       	brcs	.+4      	; 0xbd8 <vTaskResume+0xbc>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
     bd4:	0e 94 3f 19 	call	0x327e	; 0x327e <vPortYield>
					}
				}
			}
			taskEXIT_CRITICAL();
     bd8:	0f 90       	pop	r0
     bda:	0f be       	out	0x3f, r0	; 63
		}
	}
     bdc:	0f 90       	pop	r0
     bde:	0f 90       	pop	r0
     be0:	0f 90       	pop	r0
     be2:	0f 90       	pop	r0
     be4:	df 91       	pop	r29
     be6:	cf 91       	pop	r28
     be8:	08 95       	ret

00000bea <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
     bea:	cf 93       	push	r28
     bec:	df 93       	push	r29
     bee:	00 d0       	rcall	.+0      	; 0xbf0 <xTaskResumeFromISR+0x6>
     bf0:	00 d0       	rcall	.+0      	; 0xbf2 <xTaskResumeFromISR+0x8>
     bf2:	cd b7       	in	r28, 0x3d	; 61
     bf4:	de b7       	in	r29, 0x3e	; 62
     bf6:	9e 83       	std	Y+6, r25	; 0x06
     bf8:	8d 83       	std	Y+5, r24	; 0x05
	portBASE_TYPE xYieldRequired = pdFALSE;
     bfa:	19 82       	std	Y+1, r1	; 0x01
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxSavedInterruptStatus;

		configASSERT( pxTaskToResume );

		pxTCB = ( tskTCB * ) pxTaskToResume;
     bfc:	8d 81       	ldd	r24, Y+5	; 0x05
     bfe:	9e 81       	ldd	r25, Y+6	; 0x06
     c00:	9b 83       	std	Y+3, r25	; 0x03
     c02:	8a 83       	std	Y+2, r24	; 0x02

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     c04:	1c 82       	std	Y+4, r1	; 0x04
		{
			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
     c06:	8a 81       	ldd	r24, Y+2	; 0x02
     c08:	9b 81       	ldd	r25, Y+3	; 0x03
     c0a:	0e 94 5c 05 	call	0xab8	; 0xab8 <xTaskIsTaskSuspended>
     c0e:	81 30       	cpi	r24, 0x01	; 1
     c10:	09 f0       	breq	.+2      	; 0xc14 <xTaskResumeFromISR+0x2a>
     c12:	48 c0       	rjmp	.+144    	; 0xca4 <xTaskResumeFromISR+0xba>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     c14:	80 91 84 02 	lds	r24, 0x0284
     c18:	88 23       	and	r24, r24
     c1a:	e1 f5       	brne	.+120    	; 0xc94 <xTaskResumeFromISR+0xaa>
				{
					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
     c1c:	8a 81       	ldd	r24, Y+2	; 0x02
     c1e:	9b 81       	ldd	r25, Y+3	; 0x03
     c20:	fc 01       	movw	r30, r24
     c22:	26 89       	ldd	r18, Z+22	; 0x16
     c24:	80 91 30 02 	lds	r24, 0x0230
     c28:	90 91 31 02 	lds	r25, 0x0231
     c2c:	fc 01       	movw	r30, r24
     c2e:	96 89       	ldd	r25, Z+22	; 0x16
     c30:	81 e0       	ldi	r24, 0x01	; 1
     c32:	29 17       	cp	r18, r25
     c34:	08 f4       	brcc	.+2      	; 0xc38 <xTaskResumeFromISR+0x4e>
     c36:	80 e0       	ldi	r24, 0x00	; 0
     c38:	89 83       	std	Y+1, r24	; 0x01
					uxListRemove(  &( pxTCB->xGenericListItem ) );
     c3a:	8a 81       	ldd	r24, Y+2	; 0x02
     c3c:	9b 81       	ldd	r25, Y+3	; 0x03
     c3e:	02 96       	adiw	r24, 0x02	; 2
     c40:	0e 94 7d 13 	call	0x26fa	; 0x26fa <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
     c44:	8a 81       	ldd	r24, Y+2	; 0x02
     c46:	9b 81       	ldd	r25, Y+3	; 0x03
     c48:	fc 01       	movw	r30, r24
     c4a:	96 89       	ldd	r25, Z+22	; 0x16
     c4c:	80 91 82 02 	lds	r24, 0x0282
     c50:	89 17       	cp	r24, r25
     c52:	30 f4       	brcc	.+12     	; 0xc60 <xTaskResumeFromISR+0x76>
     c54:	8a 81       	ldd	r24, Y+2	; 0x02
     c56:	9b 81       	ldd	r25, Y+3	; 0x03
     c58:	fc 01       	movw	r30, r24
     c5a:	86 89       	ldd	r24, Z+22	; 0x16
     c5c:	80 93 82 02 	sts	0x0282, r24
     c60:	8a 81       	ldd	r24, Y+2	; 0x02
     c62:	9b 81       	ldd	r25, Y+3	; 0x03
     c64:	ac 01       	movw	r20, r24
     c66:	4e 5f       	subi	r20, 0xFE	; 254
     c68:	5f 4f       	sbci	r21, 0xFF	; 255
     c6a:	8a 81       	ldd	r24, Y+2	; 0x02
     c6c:	9b 81       	ldd	r25, Y+3	; 0x03
     c6e:	fc 01       	movw	r30, r24
     c70:	86 89       	ldd	r24, Z+22	; 0x16
     c72:	28 2f       	mov	r18, r24
     c74:	30 e0       	ldi	r19, 0x00	; 0
     c76:	c9 01       	movw	r24, r18
     c78:	88 0f       	add	r24, r24
     c7a:	99 1f       	adc	r25, r25
     c7c:	88 0f       	add	r24, r24
     c7e:	99 1f       	adc	r25, r25
     c80:	88 0f       	add	r24, r24
     c82:	99 1f       	adc	r25, r25
     c84:	82 0f       	add	r24, r18
     c86:	93 1f       	adc	r25, r19
     c88:	8e 5c       	subi	r24, 0xCE	; 206
     c8a:	9d 4f       	sbci	r25, 0xFD	; 253
     c8c:	ba 01       	movw	r22, r20
     c8e:	0e 94 ad 12 	call	0x255a	; 0x255a <vListInsertEnd>
     c92:	08 c0       	rjmp	.+16     	; 0xca4 <xTaskResumeFromISR+0xba>
				else
				{
					/* We cannot access the delayed or ready lists, so will hold this
					task pending until the scheduler is resumed, at which point a
					yield will be performed if necessary. */
					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
     c94:	8a 81       	ldd	r24, Y+2	; 0x02
     c96:	9b 81       	ldd	r25, Y+3	; 0x03
     c98:	0c 96       	adiw	r24, 0x0c	; 12
     c9a:	bc 01       	movw	r22, r24
     c9c:	8c e6       	ldi	r24, 0x6C	; 108
     c9e:	92 e0       	ldi	r25, 0x02	; 2
     ca0:	0e 94 ad 12 	call	0x255a	; 0x255a <vListInsertEnd>
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
     ca4:	89 81       	ldd	r24, Y+1	; 0x01
	}
     ca6:	26 96       	adiw	r28, 0x06	; 6
     ca8:	0f b6       	in	r0, 0x3f	; 63
     caa:	f8 94       	cli
     cac:	de bf       	out	0x3e, r29	; 62
     cae:	0f be       	out	0x3f, r0	; 63
     cb0:	cd bf       	out	0x3d, r28	; 61
     cb2:	df 91       	pop	r29
     cb4:	cf 91       	pop	r28
     cb6:	08 95       	ret

00000cb8 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
     cb8:	af 92       	push	r10
     cba:	bf 92       	push	r11
     cbc:	cf 92       	push	r12
     cbe:	df 92       	push	r13
     cc0:	ef 92       	push	r14
     cc2:	ff 92       	push	r15
     cc4:	0f 93       	push	r16
     cc6:	cf 93       	push	r28
     cc8:	df 93       	push	r29
     cca:	1f 92       	push	r1
     ccc:	cd b7       	in	r28, 0x3d	; 61
     cce:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
     cd0:	a1 2c       	mov	r10, r1
     cd2:	b1 2c       	mov	r11, r1
     cd4:	c1 2c       	mov	r12, r1
     cd6:	d1 2c       	mov	r13, r1
     cd8:	e1 2c       	mov	r14, r1
     cda:	f1 2c       	mov	r15, r1
     cdc:	00 e0       	ldi	r16, 0x00	; 0
     cde:	20 e0       	ldi	r18, 0x00	; 0
     ce0:	30 e0       	ldi	r19, 0x00	; 0
     ce2:	45 e5       	ldi	r20, 0x55	; 85
     ce4:	50 e0       	ldi	r21, 0x00	; 0
     ce6:	60 e2       	ldi	r22, 0x20	; 32
     ce8:	72 e0       	ldi	r23, 0x02	; 2
     cea:	81 e1       	ldi	r24, 0x11	; 17
     cec:	9a e0       	ldi	r25, 0x0A	; 10
     cee:	0e 94 5d 03 	call	0x6ba	; 0x6ba <xTaskGenericCreate>
     cf2:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
     cf4:	89 81       	ldd	r24, Y+1	; 0x01
     cf6:	81 30       	cpi	r24, 0x01	; 1
     cf8:	51 f4       	brne	.+20     	; 0xd0e <vTaskStartScheduler+0x56>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
     cfa:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
     cfc:	81 e0       	ldi	r24, 0x01	; 1
     cfe:	80 93 83 02 	sts	0x0283, r24
		xTickCount = ( portTickType ) 0U;
     d02:	10 92 80 02 	sts	0x0280, r1
     d06:	10 92 7f 02 	sts	0x027F, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     d0a:	0e 94 ff 18 	call	0x31fe	; 0x31fe <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
     d0e:	0f 90       	pop	r0
     d10:	df 91       	pop	r29
     d12:	cf 91       	pop	r28
     d14:	0f 91       	pop	r16
     d16:	ff 90       	pop	r15
     d18:	ef 90       	pop	r14
     d1a:	df 90       	pop	r13
     d1c:	cf 90       	pop	r12
     d1e:	bf 90       	pop	r11
     d20:	af 90       	pop	r10
     d22:	08 95       	ret

00000d24 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
     d24:	cf 93       	push	r28
     d26:	df 93       	push	r29
     d28:	cd b7       	in	r28, 0x3d	; 61
     d2a:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
     d2c:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
     d2e:	10 92 83 02 	sts	0x0283, r1
	vPortEndScheduler();
     d32:	0e 94 38 19 	call	0x3270	; 0x3270 <vPortEndScheduler>
}
     d36:	df 91       	pop	r29
     d38:	cf 91       	pop	r28
     d3a:	08 95       	ret

00000d3c <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
     d3c:	cf 93       	push	r28
     d3e:	df 93       	push	r29
     d40:	cd b7       	in	r28, 0x3d	; 61
     d42:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
     d44:	80 91 84 02 	lds	r24, 0x0284
     d48:	8f 5f       	subi	r24, 0xFF	; 255
     d4a:	80 93 84 02 	sts	0x0284, r24
}
     d4e:	df 91       	pop	r29
     d50:	cf 91       	pop	r28
     d52:	08 95       	ret

00000d54 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE != 0  */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
     d54:	0f 93       	push	r16
     d56:	1f 93       	push	r17
     d58:	cf 93       	push	r28
     d5a:	df 93       	push	r29
     d5c:	1f 92       	push	r1
     d5e:	1f 92       	push	r1
     d60:	cd b7       	in	r28, 0x3d	; 61
     d62:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
     d64:	19 82       	std	Y+1, r1	; 0x01
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     d66:	0f b6       	in	r0, 0x3f	; 63
     d68:	f8 94       	cli
     d6a:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     d6c:	80 91 84 02 	lds	r24, 0x0284
     d70:	81 50       	subi	r24, 0x01	; 1
     d72:	80 93 84 02 	sts	0x0284, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     d76:	80 91 84 02 	lds	r24, 0x0284
     d7a:	88 23       	and	r24, r24
     d7c:	09 f0       	breq	.+2      	; 0xd80 <xTaskResumeAll+0x2c>
     d7e:	64 c0       	rjmp	.+200    	; 0xe48 <xTaskResumeAll+0xf4>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
     d80:	80 91 7e 02 	lds	r24, 0x027E
     d84:	88 23       	and	r24, r24
     d86:	09 f4       	brne	.+2      	; 0xd8a <xTaskResumeAll+0x36>
     d88:	5f c0       	rjmp	.+190    	; 0xe48 <xTaskResumeAll+0xf4>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
     d8a:	1a 82       	std	Y+2, r1	; 0x02

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
     d8c:	3a c0       	rjmp	.+116    	; 0xe02 <xTaskResumeAll+0xae>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
     d8e:	80 91 71 02 	lds	r24, 0x0271
     d92:	90 91 72 02 	lds	r25, 0x0272
     d96:	fc 01       	movw	r30, r24
     d98:	06 81       	ldd	r16, Z+6	; 0x06
     d9a:	17 81       	ldd	r17, Z+7	; 0x07
					uxListRemove( &( pxTCB->xEventListItem ) );
     d9c:	c8 01       	movw	r24, r16
     d9e:	0c 96       	adiw	r24, 0x0c	; 12
     da0:	0e 94 7d 13 	call	0x26fa	; 0x26fa <uxListRemove>
					uxListRemove( &( pxTCB->xGenericListItem ) );
     da4:	c8 01       	movw	r24, r16
     da6:	02 96       	adiw	r24, 0x02	; 2
     da8:	0e 94 7d 13 	call	0x26fa	; 0x26fa <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
     dac:	f8 01       	movw	r30, r16
     dae:	96 89       	ldd	r25, Z+22	; 0x16
     db0:	80 91 82 02 	lds	r24, 0x0282
     db4:	89 17       	cp	r24, r25
     db6:	20 f4       	brcc	.+8      	; 0xdc0 <xTaskResumeAll+0x6c>
     db8:	f8 01       	movw	r30, r16
     dba:	86 89       	ldd	r24, Z+22	; 0x16
     dbc:	80 93 82 02 	sts	0x0282, r24
     dc0:	a8 01       	movw	r20, r16
     dc2:	4e 5f       	subi	r20, 0xFE	; 254
     dc4:	5f 4f       	sbci	r21, 0xFF	; 255
     dc6:	f8 01       	movw	r30, r16
     dc8:	86 89       	ldd	r24, Z+22	; 0x16
     dca:	28 2f       	mov	r18, r24
     dcc:	30 e0       	ldi	r19, 0x00	; 0
     dce:	c9 01       	movw	r24, r18
     dd0:	88 0f       	add	r24, r24
     dd2:	99 1f       	adc	r25, r25
     dd4:	88 0f       	add	r24, r24
     dd6:	99 1f       	adc	r25, r25
     dd8:	88 0f       	add	r24, r24
     dda:	99 1f       	adc	r25, r25
     ddc:	82 0f       	add	r24, r18
     dde:	93 1f       	adc	r25, r19
     de0:	8e 5c       	subi	r24, 0xCE	; 206
     de2:	9d 4f       	sbci	r25, 0xFD	; 253
     de4:	ba 01       	movw	r22, r20
     de6:	0e 94 ad 12 	call	0x255a	; 0x255a <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     dea:	f8 01       	movw	r30, r16
     dec:	26 89       	ldd	r18, Z+22	; 0x16
     dee:	80 91 30 02 	lds	r24, 0x0230
     df2:	90 91 31 02 	lds	r25, 0x0231
     df6:	fc 01       	movw	r30, r24
     df8:	86 89       	ldd	r24, Z+22	; 0x16
     dfa:	28 17       	cp	r18, r24
     dfc:	10 f0       	brcs	.+4      	; 0xe02 <xTaskResumeAll+0xae>
					{
						xYieldRequired = pdTRUE;
     dfe:	81 e0       	ldi	r24, 0x01	; 1
     e00:	8a 83       	std	Y+2, r24	; 0x02
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
     e02:	80 91 6c 02 	lds	r24, 0x026C
     e06:	88 23       	and	r24, r24
     e08:	11 f6       	brne	.-124    	; 0xd8e <xTaskResumeAll+0x3a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
     e0a:	80 91 85 02 	lds	r24, 0x0285
     e0e:	88 23       	and	r24, r24
     e10:	71 f0       	breq	.+28     	; 0xe2e <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
     e12:	07 c0       	rjmp	.+14     	; 0xe22 <xTaskResumeAll+0xce>
					{
						vTaskIncrementTick();
     e14:	0e 94 63 07 	call	0xec6	; 0xec6 <vTaskIncrementTick>
						--uxMissedTicks;
     e18:	80 91 85 02 	lds	r24, 0x0285
     e1c:	81 50       	subi	r24, 0x01	; 1
     e1e:	80 93 85 02 	sts	0x0285, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
     e22:	80 91 85 02 	lds	r24, 0x0285
     e26:	88 23       	and	r24, r24
     e28:	a9 f7       	brne	.-22     	; 0xe14 <xTaskResumeAll+0xc0>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
     e2a:	81 e0       	ldi	r24, 0x01	; 1
     e2c:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
     e2e:	8a 81       	ldd	r24, Y+2	; 0x02
     e30:	81 30       	cpi	r24, 0x01	; 1
     e32:	21 f0       	breq	.+8      	; 0xe3c <xTaskResumeAll+0xe8>
     e34:	80 91 86 02 	lds	r24, 0x0286
     e38:	81 30       	cpi	r24, 0x01	; 1
     e3a:	31 f4       	brne	.+12     	; 0xe48 <xTaskResumeAll+0xf4>
				{
					xAlreadyYielded = pdTRUE;
     e3c:	81 e0       	ldi	r24, 0x01	; 1
     e3e:	89 83       	std	Y+1, r24	; 0x01
					xMissedYield = pdFALSE;
     e40:	10 92 86 02 	sts	0x0286, r1
					portYIELD_WITHIN_API();
     e44:	0e 94 3f 19 	call	0x327e	; 0x327e <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
     e48:	0f 90       	pop	r0
     e4a:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
     e4c:	89 81       	ldd	r24, Y+1	; 0x01
}
     e4e:	0f 90       	pop	r0
     e50:	0f 90       	pop	r0
     e52:	df 91       	pop	r29
     e54:	cf 91       	pop	r28
     e56:	1f 91       	pop	r17
     e58:	0f 91       	pop	r16
     e5a:	08 95       	ret

00000e5c <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
     e5c:	cf 93       	push	r28
     e5e:	df 93       	push	r29
     e60:	1f 92       	push	r1
     e62:	1f 92       	push	r1
     e64:	cd b7       	in	r28, 0x3d	; 61
     e66:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
     e68:	0f b6       	in	r0, 0x3f	; 63
     e6a:	f8 94       	cli
     e6c:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     e6e:	80 91 7f 02 	lds	r24, 0x027F
     e72:	90 91 80 02 	lds	r25, 0x0280
     e76:	9a 83       	std	Y+2, r25	; 0x02
     e78:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
     e7a:	0f 90       	pop	r0
     e7c:	0f be       	out	0x3f, r0	; 63

	return xTicks;
     e7e:	89 81       	ldd	r24, Y+1	; 0x01
     e80:	9a 81       	ldd	r25, Y+2	; 0x02
}
     e82:	0f 90       	pop	r0
     e84:	0f 90       	pop	r0
     e86:	df 91       	pop	r29
     e88:	cf 91       	pop	r28
     e8a:	08 95       	ret

00000e8c <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
     e8c:	cf 93       	push	r28
     e8e:	df 93       	push	r29
     e90:	00 d0       	rcall	.+0      	; 0xe92 <xTaskGetTickCountFromISR+0x6>
     e92:	cd b7       	in	r28, 0x3d	; 61
     e94:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     e96:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
     e98:	80 91 7f 02 	lds	r24, 0x027F
     e9c:	90 91 80 02 	lds	r25, 0x0280
     ea0:	9b 83       	std	Y+3, r25	; 0x03
     ea2:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
     ea4:	8a 81       	ldd	r24, Y+2	; 0x02
     ea6:	9b 81       	ldd	r25, Y+3	; 0x03
}
     ea8:	0f 90       	pop	r0
     eaa:	0f 90       	pop	r0
     eac:	0f 90       	pop	r0
     eae:	df 91       	pop	r29
     eb0:	cf 91       	pop	r28
     eb2:	08 95       	ret

00000eb4 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
     eb4:	cf 93       	push	r28
     eb6:	df 93       	push	r29
     eb8:	cd b7       	in	r28, 0x3d	; 61
     eba:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
     ebc:	80 91 7e 02 	lds	r24, 0x027E
}
     ec0:	df 91       	pop	r29
     ec2:	cf 91       	pop	r28
     ec4:	08 95       	ret

00000ec6 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
     ec6:	cf 93       	push	r28
     ec8:	df 93       	push	r29
     eca:	00 d0       	rcall	.+0      	; 0xecc <vTaskIncrementTick+0x6>
     ecc:	00 d0       	rcall	.+0      	; 0xece <vTaskIncrementTick+0x8>
     ece:	cd b7       	in	r28, 0x3d	; 61
     ed0:	de b7       	in	r29, 0x3e	; 62

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     ed2:	80 91 84 02 	lds	r24, 0x0284
     ed6:	88 23       	and	r24, r24
     ed8:	09 f0       	breq	.+2      	; 0xedc <vTaskIncrementTick+0x16>
     eda:	c4 c0       	rjmp	.+392    	; 0x1064 <vTaskIncrementTick+0x19e>
	{
		++xTickCount;
     edc:	80 91 7f 02 	lds	r24, 0x027F
     ee0:	90 91 80 02 	lds	r25, 0x0280
     ee4:	01 96       	adiw	r24, 0x01	; 1
     ee6:	90 93 80 02 	sts	0x0280, r25
     eea:	80 93 7f 02 	sts	0x027F, r24
		if( xTickCount == ( portTickType ) 0U )
     eee:	80 91 7f 02 	lds	r24, 0x027F
     ef2:	90 91 80 02 	lds	r25, 0x0280
     ef6:	00 97       	sbiw	r24, 0x00	; 0
     ef8:	e9 f5       	brne	.+122    	; 0xf74 <vTaskIncrementTick+0xae>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
     efa:	80 91 68 02 	lds	r24, 0x0268
     efe:	90 91 69 02 	lds	r25, 0x0269
     f02:	9a 83       	std	Y+2, r25	; 0x02
     f04:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedTaskList = pxOverflowDelayedTaskList;
     f06:	80 91 6a 02 	lds	r24, 0x026A
     f0a:	90 91 6b 02 	lds	r25, 0x026B
     f0e:	90 93 69 02 	sts	0x0269, r25
     f12:	80 93 68 02 	sts	0x0268, r24
			pxOverflowDelayedTaskList = pxTemp;
     f16:	89 81       	ldd	r24, Y+1	; 0x01
     f18:	9a 81       	ldd	r25, Y+2	; 0x02
     f1a:	90 93 6b 02 	sts	0x026B, r25
     f1e:	80 93 6a 02 	sts	0x026A, r24
			xNumOfOverflows++;
     f22:	80 91 87 02 	lds	r24, 0x0287
     f26:	8f 5f       	subi	r24, 0xFF	; 255
     f28:	80 93 87 02 	sts	0x0287, r24

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     f2c:	80 91 68 02 	lds	r24, 0x0268
     f30:	90 91 69 02 	lds	r25, 0x0269
     f34:	fc 01       	movw	r30, r24
     f36:	80 81       	ld	r24, Z
     f38:	88 23       	and	r24, r24
     f3a:	39 f4       	brne	.+14     	; 0xf4a <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
     f3c:	8f ef       	ldi	r24, 0xFF	; 255
     f3e:	9f ef       	ldi	r25, 0xFF	; 255
     f40:	90 93 01 02 	sts	0x0201, r25
     f44:	80 93 00 02 	sts	0x0200, r24
     f48:	15 c0       	rjmp	.+42     	; 0xf74 <vTaskIncrementTick+0xae>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     f4a:	80 91 68 02 	lds	r24, 0x0268
     f4e:	90 91 69 02 	lds	r25, 0x0269
     f52:	fc 01       	movw	r30, r24
     f54:	85 81       	ldd	r24, Z+5	; 0x05
     f56:	96 81       	ldd	r25, Z+6	; 0x06
     f58:	fc 01       	movw	r30, r24
     f5a:	86 81       	ldd	r24, Z+6	; 0x06
     f5c:	97 81       	ldd	r25, Z+7	; 0x07
     f5e:	9c 83       	std	Y+4, r25	; 0x04
     f60:	8b 83       	std	Y+3, r24	; 0x03
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
     f62:	8b 81       	ldd	r24, Y+3	; 0x03
     f64:	9c 81       	ldd	r25, Y+4	; 0x04
     f66:	fc 01       	movw	r30, r24
     f68:	82 81       	ldd	r24, Z+2	; 0x02
     f6a:	93 81       	ldd	r25, Z+3	; 0x03
     f6c:	90 93 01 02 	sts	0x0201, r25
     f70:	80 93 00 02 	sts	0x0200, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
     f74:	20 91 7f 02 	lds	r18, 0x027F
     f78:	30 91 80 02 	lds	r19, 0x0280
     f7c:	80 91 00 02 	lds	r24, 0x0200
     f80:	90 91 01 02 	lds	r25, 0x0201
     f84:	28 17       	cp	r18, r24
     f86:	39 07       	cpc	r19, r25
     f88:	08 f4       	brcc	.+2      	; 0xf8c <vTaskIncrementTick+0xc6>
     f8a:	6b c0       	rjmp	.+214    	; 0x1062 <vTaskIncrementTick+0x19c>
     f8c:	80 91 68 02 	lds	r24, 0x0268
     f90:	90 91 69 02 	lds	r25, 0x0269
     f94:	fc 01       	movw	r30, r24
     f96:	80 81       	ld	r24, Z
     f98:	88 23       	and	r24, r24
     f9a:	39 f4       	brne	.+14     	; 0xfaa <vTaskIncrementTick+0xe4>
     f9c:	8f ef       	ldi	r24, 0xFF	; 255
     f9e:	9f ef       	ldi	r25, 0xFF	; 255
     fa0:	90 93 01 02 	sts	0x0201, r25
     fa4:	80 93 00 02 	sts	0x0200, r24
     fa8:	5c c0       	rjmp	.+184    	; 0x1062 <vTaskIncrementTick+0x19c>
     faa:	80 91 68 02 	lds	r24, 0x0268
     fae:	90 91 69 02 	lds	r25, 0x0269
     fb2:	fc 01       	movw	r30, r24
     fb4:	85 81       	ldd	r24, Z+5	; 0x05
     fb6:	96 81       	ldd	r25, Z+6	; 0x06
     fb8:	fc 01       	movw	r30, r24
     fba:	86 81       	ldd	r24, Z+6	; 0x06
     fbc:	97 81       	ldd	r25, Z+7	; 0x07
     fbe:	9c 83       	std	Y+4, r25	; 0x04
     fc0:	8b 83       	std	Y+3, r24	; 0x03
     fc2:	8b 81       	ldd	r24, Y+3	; 0x03
     fc4:	9c 81       	ldd	r25, Y+4	; 0x04
     fc6:	fc 01       	movw	r30, r24
     fc8:	82 81       	ldd	r24, Z+2	; 0x02
     fca:	93 81       	ldd	r25, Z+3	; 0x03
     fcc:	9e 83       	std	Y+6, r25	; 0x06
     fce:	8d 83       	std	Y+5, r24	; 0x05
     fd0:	20 91 7f 02 	lds	r18, 0x027F
     fd4:	30 91 80 02 	lds	r19, 0x0280
     fd8:	8d 81       	ldd	r24, Y+5	; 0x05
     fda:	9e 81       	ldd	r25, Y+6	; 0x06
     fdc:	28 17       	cp	r18, r24
     fde:	39 07       	cpc	r19, r25
     fe0:	38 f4       	brcc	.+14     	; 0xff0 <vTaskIncrementTick+0x12a>
     fe2:	8d 81       	ldd	r24, Y+5	; 0x05
     fe4:	9e 81       	ldd	r25, Y+6	; 0x06
     fe6:	90 93 01 02 	sts	0x0201, r25
     fea:	80 93 00 02 	sts	0x0200, r24
     fee:	39 c0       	rjmp	.+114    	; 0x1062 <vTaskIncrementTick+0x19c>
     ff0:	8b 81       	ldd	r24, Y+3	; 0x03
     ff2:	9c 81       	ldd	r25, Y+4	; 0x04
     ff4:	02 96       	adiw	r24, 0x02	; 2
     ff6:	0e 94 7d 13 	call	0x26fa	; 0x26fa <uxListRemove>
     ffa:	8b 81       	ldd	r24, Y+3	; 0x03
     ffc:	9c 81       	ldd	r25, Y+4	; 0x04
     ffe:	fc 01       	movw	r30, r24
    1000:	84 89       	ldd	r24, Z+20	; 0x14
    1002:	95 89       	ldd	r25, Z+21	; 0x15
    1004:	00 97       	sbiw	r24, 0x00	; 0
    1006:	29 f0       	breq	.+10     	; 0x1012 <vTaskIncrementTick+0x14c>
    1008:	8b 81       	ldd	r24, Y+3	; 0x03
    100a:	9c 81       	ldd	r25, Y+4	; 0x04
    100c:	0c 96       	adiw	r24, 0x0c	; 12
    100e:	0e 94 7d 13 	call	0x26fa	; 0x26fa <uxListRemove>
    1012:	8b 81       	ldd	r24, Y+3	; 0x03
    1014:	9c 81       	ldd	r25, Y+4	; 0x04
    1016:	fc 01       	movw	r30, r24
    1018:	96 89       	ldd	r25, Z+22	; 0x16
    101a:	80 91 82 02 	lds	r24, 0x0282
    101e:	89 17       	cp	r24, r25
    1020:	30 f4       	brcc	.+12     	; 0x102e <vTaskIncrementTick+0x168>
    1022:	8b 81       	ldd	r24, Y+3	; 0x03
    1024:	9c 81       	ldd	r25, Y+4	; 0x04
    1026:	fc 01       	movw	r30, r24
    1028:	86 89       	ldd	r24, Z+22	; 0x16
    102a:	80 93 82 02 	sts	0x0282, r24
    102e:	8b 81       	ldd	r24, Y+3	; 0x03
    1030:	9c 81       	ldd	r25, Y+4	; 0x04
    1032:	ac 01       	movw	r20, r24
    1034:	4e 5f       	subi	r20, 0xFE	; 254
    1036:	5f 4f       	sbci	r21, 0xFF	; 255
    1038:	8b 81       	ldd	r24, Y+3	; 0x03
    103a:	9c 81       	ldd	r25, Y+4	; 0x04
    103c:	fc 01       	movw	r30, r24
    103e:	86 89       	ldd	r24, Z+22	; 0x16
    1040:	28 2f       	mov	r18, r24
    1042:	30 e0       	ldi	r19, 0x00	; 0
    1044:	c9 01       	movw	r24, r18
    1046:	88 0f       	add	r24, r24
    1048:	99 1f       	adc	r25, r25
    104a:	88 0f       	add	r24, r24
    104c:	99 1f       	adc	r25, r25
    104e:	88 0f       	add	r24, r24
    1050:	99 1f       	adc	r25, r25
    1052:	82 0f       	add	r24, r18
    1054:	93 1f       	adc	r25, r19
    1056:	8e 5c       	subi	r24, 0xCE	; 206
    1058:	9d 4f       	sbci	r25, 0xFD	; 253
    105a:	ba 01       	movw	r22, r20
    105c:	0e 94 ad 12 	call	0x255a	; 0x255a <vListInsertEnd>
    1060:	95 cf       	rjmp	.-214    	; 0xf8c <vTaskIncrementTick+0xc6>
    1062:	05 c0       	rjmp	.+10     	; 0x106e <vTaskIncrementTick+0x1a8>
	}
	else
	{
		++uxMissedTicks;
    1064:	80 91 85 02 	lds	r24, 0x0285
    1068:	8f 5f       	subi	r24, 0xFF	; 255
    106a:	80 93 85 02 	sts	0x0285, r24
		{
			vApplicationTickHook();
		}
	}
	#endif
}
    106e:	26 96       	adiw	r28, 0x06	; 6
    1070:	0f b6       	in	r0, 0x3f	; 63
    1072:	f8 94       	cli
    1074:	de bf       	out	0x3e, r29	; 62
    1076:	0f be       	out	0x3f, r0	; 63
    1078:	cd bf       	out	0x3d, r28	; 61
    107a:	df 91       	pop	r29
    107c:	cf 91       	pop	r28
    107e:	08 95       	ret

00001080 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    1080:	cf 93       	push	r28
    1082:	df 93       	push	r29
    1084:	1f 92       	push	r1
    1086:	1f 92       	push	r1
    1088:	cd b7       	in	r28, 0x3d	; 61
    108a:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    108c:	80 91 84 02 	lds	r24, 0x0284
    1090:	88 23       	and	r24, r24
    1092:	21 f0       	breq	.+8      	; 0x109c <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    1094:	81 e0       	ldi	r24, 0x01	; 1
    1096:	80 93 86 02 	sts	0x0286, r24
    109a:	7a c0       	rjmp	.+244    	; 0x1190 <vTaskSwitchContext+0x110>
				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
				ulTaskSwitchedInTime = ulTempCounter;
		}
		#endif

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
    109c:	80 91 30 02 	lds	r24, 0x0230
    10a0:	90 91 31 02 	lds	r25, 0x0231
    10a4:	fc 01       	movw	r30, r24
    10a6:	20 81       	ld	r18, Z
    10a8:	31 81       	ldd	r19, Z+1	; 0x01
    10aa:	80 91 30 02 	lds	r24, 0x0230
    10ae:	90 91 31 02 	lds	r25, 0x0231
    10b2:	fc 01       	movw	r30, r24
    10b4:	87 89       	ldd	r24, Z+23	; 0x17
    10b6:	90 8d       	ldd	r25, Z+24	; 0x18
    10b8:	82 17       	cp	r24, r18
    10ba:	93 07       	cpc	r25, r19
    10bc:	70 f0       	brcs	.+28     	; 0x10da <vTaskSwitchContext+0x5a>
    10be:	80 91 30 02 	lds	r24, 0x0230
    10c2:	90 91 31 02 	lds	r25, 0x0231
    10c6:	9c 01       	movw	r18, r24
    10c8:	27 5e       	subi	r18, 0xE7	; 231
    10ca:	3f 4f       	sbci	r19, 0xFF	; 255
    10cc:	80 91 30 02 	lds	r24, 0x0230
    10d0:	90 91 31 02 	lds	r25, 0x0231
    10d4:	b9 01       	movw	r22, r18
    10d6:	0e 94 c3 00 	call	0x186	; 0x186 <vApplicationStackOverflowHook>
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
    10da:	05 c0       	rjmp	.+10     	; 0x10e6 <vTaskSwitchContext+0x66>
    10dc:	80 91 82 02 	lds	r24, 0x0282
    10e0:	81 50       	subi	r24, 0x01	; 1
    10e2:	80 93 82 02 	sts	0x0282, r24
    10e6:	80 91 82 02 	lds	r24, 0x0282
    10ea:	28 2f       	mov	r18, r24
    10ec:	30 e0       	ldi	r19, 0x00	; 0
    10ee:	c9 01       	movw	r24, r18
    10f0:	88 0f       	add	r24, r24
    10f2:	99 1f       	adc	r25, r25
    10f4:	88 0f       	add	r24, r24
    10f6:	99 1f       	adc	r25, r25
    10f8:	88 0f       	add	r24, r24
    10fa:	99 1f       	adc	r25, r25
    10fc:	82 0f       	add	r24, r18
    10fe:	93 1f       	adc	r25, r19
    1100:	8e 5c       	subi	r24, 0xCE	; 206
    1102:	9d 4f       	sbci	r25, 0xFD	; 253
    1104:	fc 01       	movw	r30, r24
    1106:	80 81       	ld	r24, Z
    1108:	88 23       	and	r24, r24
    110a:	41 f3       	breq	.-48     	; 0x10dc <vTaskSwitchContext+0x5c>
    110c:	80 91 82 02 	lds	r24, 0x0282
    1110:	28 2f       	mov	r18, r24
    1112:	30 e0       	ldi	r19, 0x00	; 0
    1114:	c9 01       	movw	r24, r18
    1116:	88 0f       	add	r24, r24
    1118:	99 1f       	adc	r25, r25
    111a:	88 0f       	add	r24, r24
    111c:	99 1f       	adc	r25, r25
    111e:	88 0f       	add	r24, r24
    1120:	99 1f       	adc	r25, r25
    1122:	82 0f       	add	r24, r18
    1124:	93 1f       	adc	r25, r19
    1126:	8e 5c       	subi	r24, 0xCE	; 206
    1128:	9d 4f       	sbci	r25, 0xFD	; 253
    112a:	9a 83       	std	Y+2, r25	; 0x02
    112c:	89 83       	std	Y+1, r24	; 0x01
    112e:	89 81       	ldd	r24, Y+1	; 0x01
    1130:	9a 81       	ldd	r25, Y+2	; 0x02
    1132:	fc 01       	movw	r30, r24
    1134:	81 81       	ldd	r24, Z+1	; 0x01
    1136:	92 81       	ldd	r25, Z+2	; 0x02
    1138:	fc 01       	movw	r30, r24
    113a:	22 81       	ldd	r18, Z+2	; 0x02
    113c:	33 81       	ldd	r19, Z+3	; 0x03
    113e:	89 81       	ldd	r24, Y+1	; 0x01
    1140:	9a 81       	ldd	r25, Y+2	; 0x02
    1142:	fc 01       	movw	r30, r24
    1144:	32 83       	std	Z+2, r19	; 0x02
    1146:	21 83       	std	Z+1, r18	; 0x01
    1148:	89 81       	ldd	r24, Y+1	; 0x01
    114a:	9a 81       	ldd	r25, Y+2	; 0x02
    114c:	fc 01       	movw	r30, r24
    114e:	21 81       	ldd	r18, Z+1	; 0x01
    1150:	32 81       	ldd	r19, Z+2	; 0x02
    1152:	89 81       	ldd	r24, Y+1	; 0x01
    1154:	9a 81       	ldd	r25, Y+2	; 0x02
    1156:	03 96       	adiw	r24, 0x03	; 3
    1158:	28 17       	cp	r18, r24
    115a:	39 07       	cpc	r19, r25
    115c:	69 f4       	brne	.+26     	; 0x1178 <vTaskSwitchContext+0xf8>
    115e:	89 81       	ldd	r24, Y+1	; 0x01
    1160:	9a 81       	ldd	r25, Y+2	; 0x02
    1162:	fc 01       	movw	r30, r24
    1164:	81 81       	ldd	r24, Z+1	; 0x01
    1166:	92 81       	ldd	r25, Z+2	; 0x02
    1168:	fc 01       	movw	r30, r24
    116a:	22 81       	ldd	r18, Z+2	; 0x02
    116c:	33 81       	ldd	r19, Z+3	; 0x03
    116e:	89 81       	ldd	r24, Y+1	; 0x01
    1170:	9a 81       	ldd	r25, Y+2	; 0x02
    1172:	fc 01       	movw	r30, r24
    1174:	32 83       	std	Z+2, r19	; 0x02
    1176:	21 83       	std	Z+1, r18	; 0x01
    1178:	89 81       	ldd	r24, Y+1	; 0x01
    117a:	9a 81       	ldd	r25, Y+2	; 0x02
    117c:	fc 01       	movw	r30, r24
    117e:	81 81       	ldd	r24, Z+1	; 0x01
    1180:	92 81       	ldd	r25, Z+2	; 0x02
    1182:	fc 01       	movw	r30, r24
    1184:	86 81       	ldd	r24, Z+6	; 0x06
    1186:	97 81       	ldd	r25, Z+7	; 0x07
    1188:	90 93 31 02 	sts	0x0231, r25
    118c:	80 93 30 02 	sts	0x0230, r24

		traceTASK_SWITCHED_IN();
	}
}
    1190:	0f 90       	pop	r0
    1192:	0f 90       	pop	r0
    1194:	df 91       	pop	r29
    1196:	cf 91       	pop	r28
    1198:	08 95       	ret

0000119a <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    119a:	cf 93       	push	r28
    119c:	df 93       	push	r29
    119e:	00 d0       	rcall	.+0      	; 0x11a0 <vTaskPlaceOnEventList+0x6>
    11a0:	00 d0       	rcall	.+0      	; 0x11a2 <vTaskPlaceOnEventList+0x8>
    11a2:	cd b7       	in	r28, 0x3d	; 61
    11a4:	de b7       	in	r29, 0x3e	; 62
    11a6:	9c 83       	std	Y+4, r25	; 0x04
    11a8:	8b 83       	std	Y+3, r24	; 0x03
    11aa:	7e 83       	std	Y+6, r23	; 0x06
    11ac:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    11ae:	80 91 30 02 	lds	r24, 0x0230
    11b2:	90 91 31 02 	lds	r25, 0x0231
    11b6:	9c 01       	movw	r18, r24
    11b8:	24 5f       	subi	r18, 0xF4	; 244
    11ba:	3f 4f       	sbci	r19, 0xFF	; 255
    11bc:	8b 81       	ldd	r24, Y+3	; 0x03
    11be:	9c 81       	ldd	r25, Y+4	; 0x04
    11c0:	b9 01       	movw	r22, r18
    11c2:	0e 94 04 13 	call	0x2608	; 0x2608 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    11c6:	80 91 30 02 	lds	r24, 0x0230
    11ca:	90 91 31 02 	lds	r25, 0x0231
    11ce:	02 96       	adiw	r24, 0x02	; 2
    11d0:	0e 94 7d 13 	call	0x26fa	; 0x26fa <uxListRemove>
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    11d4:	8d 81       	ldd	r24, Y+5	; 0x05
    11d6:	9e 81       	ldd	r25, Y+6	; 0x06
    11d8:	8f 3f       	cpi	r24, 0xFF	; 255
    11da:	2f ef       	ldi	r18, 0xFF	; 255
    11dc:	92 07       	cpc	r25, r18
    11de:	59 f4       	brne	.+22     	; 0x11f6 <vTaskPlaceOnEventList+0x5c>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    11e0:	80 91 30 02 	lds	r24, 0x0230
    11e4:	90 91 31 02 	lds	r25, 0x0231
    11e8:	02 96       	adiw	r24, 0x02	; 2
    11ea:	bc 01       	movw	r22, r24
    11ec:	85 e7       	ldi	r24, 0x75	; 117
    11ee:	92 e0       	ldi	r25, 0x02	; 2
    11f0:	0e 94 ad 12 	call	0x255a	; 0x255a <vListInsertEnd>
    11f4:	0e c0       	rjmp	.+28     	; 0x1212 <vTaskPlaceOnEventList+0x78>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    11f6:	20 91 7f 02 	lds	r18, 0x027F
    11fa:	30 91 80 02 	lds	r19, 0x0280
    11fe:	8d 81       	ldd	r24, Y+5	; 0x05
    1200:	9e 81       	ldd	r25, Y+6	; 0x06
    1202:	82 0f       	add	r24, r18
    1204:	93 1f       	adc	r25, r19
    1206:	9a 83       	std	Y+2, r25	; 0x02
    1208:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    120a:	89 81       	ldd	r24, Y+1	; 0x01
    120c:	9a 81       	ldd	r25, Y+2	; 0x02
    120e:	0e 94 c8 0a 	call	0x1590	; 0x1590 <prvAddCurrentTaskToDelayedList>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
    1212:	26 96       	adiw	r28, 0x06	; 6
    1214:	0f b6       	in	r0, 0x3f	; 63
    1216:	f8 94       	cli
    1218:	de bf       	out	0x3e, r29	; 62
    121a:	0f be       	out	0x3f, r0	; 63
    121c:	cd bf       	out	0x3d, r28	; 61
    121e:	df 91       	pop	r29
    1220:	cf 91       	pop	r28
    1222:	08 95       	ret

00001224 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    1224:	cf 93       	push	r28
    1226:	df 93       	push	r29
    1228:	00 d0       	rcall	.+0      	; 0x122a <xTaskRemoveFromEventList+0x6>
    122a:	1f 92       	push	r1
    122c:	1f 92       	push	r1
    122e:	cd b7       	in	r28, 0x3d	; 61
    1230:	de b7       	in	r29, 0x3e	; 62
    1232:	9d 83       	std	Y+5, r25	; 0x05
    1234:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1236:	8c 81       	ldd	r24, Y+4	; 0x04
    1238:	9d 81       	ldd	r25, Y+5	; 0x05
    123a:	fc 01       	movw	r30, r24
    123c:	85 81       	ldd	r24, Z+5	; 0x05
    123e:	96 81       	ldd	r25, Z+6	; 0x06
    1240:	fc 01       	movw	r30, r24
    1242:	86 81       	ldd	r24, Z+6	; 0x06
    1244:	97 81       	ldd	r25, Z+7	; 0x07
    1246:	9b 83       	std	Y+3, r25	; 0x03
    1248:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    124a:	8a 81       	ldd	r24, Y+2	; 0x02
    124c:	9b 81       	ldd	r25, Y+3	; 0x03
    124e:	0c 96       	adiw	r24, 0x0c	; 12
    1250:	0e 94 7d 13 	call	0x26fa	; 0x26fa <uxListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1254:	80 91 84 02 	lds	r24, 0x0284
    1258:	88 23       	and	r24, r24
    125a:	69 f5       	brne	.+90     	; 0x12b6 <xTaskRemoveFromEventList+0x92>
	{
		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    125c:	8a 81       	ldd	r24, Y+2	; 0x02
    125e:	9b 81       	ldd	r25, Y+3	; 0x03
    1260:	02 96       	adiw	r24, 0x02	; 2
    1262:	0e 94 7d 13 	call	0x26fa	; 0x26fa <uxListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    1266:	8a 81       	ldd	r24, Y+2	; 0x02
    1268:	9b 81       	ldd	r25, Y+3	; 0x03
    126a:	fc 01       	movw	r30, r24
    126c:	96 89       	ldd	r25, Z+22	; 0x16
    126e:	80 91 82 02 	lds	r24, 0x0282
    1272:	89 17       	cp	r24, r25
    1274:	30 f4       	brcc	.+12     	; 0x1282 <xTaskRemoveFromEventList+0x5e>
    1276:	8a 81       	ldd	r24, Y+2	; 0x02
    1278:	9b 81       	ldd	r25, Y+3	; 0x03
    127a:	fc 01       	movw	r30, r24
    127c:	86 89       	ldd	r24, Z+22	; 0x16
    127e:	80 93 82 02 	sts	0x0282, r24
    1282:	8a 81       	ldd	r24, Y+2	; 0x02
    1284:	9b 81       	ldd	r25, Y+3	; 0x03
    1286:	ac 01       	movw	r20, r24
    1288:	4e 5f       	subi	r20, 0xFE	; 254
    128a:	5f 4f       	sbci	r21, 0xFF	; 255
    128c:	8a 81       	ldd	r24, Y+2	; 0x02
    128e:	9b 81       	ldd	r25, Y+3	; 0x03
    1290:	fc 01       	movw	r30, r24
    1292:	86 89       	ldd	r24, Z+22	; 0x16
    1294:	28 2f       	mov	r18, r24
    1296:	30 e0       	ldi	r19, 0x00	; 0
    1298:	c9 01       	movw	r24, r18
    129a:	88 0f       	add	r24, r24
    129c:	99 1f       	adc	r25, r25
    129e:	88 0f       	add	r24, r24
    12a0:	99 1f       	adc	r25, r25
    12a2:	88 0f       	add	r24, r24
    12a4:	99 1f       	adc	r25, r25
    12a6:	82 0f       	add	r24, r18
    12a8:	93 1f       	adc	r25, r19
    12aa:	8e 5c       	subi	r24, 0xCE	; 206
    12ac:	9d 4f       	sbci	r25, 0xFD	; 253
    12ae:	ba 01       	movw	r22, r20
    12b0:	0e 94 ad 12 	call	0x255a	; 0x255a <vListInsertEnd>
    12b4:	08 c0       	rjmp	.+16     	; 0x12c6 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    12b6:	8a 81       	ldd	r24, Y+2	; 0x02
    12b8:	9b 81       	ldd	r25, Y+3	; 0x03
    12ba:	0c 96       	adiw	r24, 0x0c	; 12
    12bc:	bc 01       	movw	r22, r24
    12be:	8c e6       	ldi	r24, 0x6C	; 108
    12c0:	92 e0       	ldi	r25, 0x02	; 2
    12c2:	0e 94 ad 12 	call	0x255a	; 0x255a <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    12c6:	8a 81       	ldd	r24, Y+2	; 0x02
    12c8:	9b 81       	ldd	r25, Y+3	; 0x03
    12ca:	fc 01       	movw	r30, r24
    12cc:	26 89       	ldd	r18, Z+22	; 0x16
    12ce:	80 91 30 02 	lds	r24, 0x0230
    12d2:	90 91 31 02 	lds	r25, 0x0231
    12d6:	fc 01       	movw	r30, r24
    12d8:	86 89       	ldd	r24, Z+22	; 0x16
    12da:	28 17       	cp	r18, r24
    12dc:	18 f0       	brcs	.+6      	; 0x12e4 <xTaskRemoveFromEventList+0xc0>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    12de:	81 e0       	ldi	r24, 0x01	; 1
    12e0:	89 83       	std	Y+1, r24	; 0x01
    12e2:	01 c0       	rjmp	.+2      	; 0x12e6 <xTaskRemoveFromEventList+0xc2>
	}
	else
	{
		xReturn = pdFALSE;
    12e4:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    12e6:	89 81       	ldd	r24, Y+1	; 0x01
}
    12e8:	0f 90       	pop	r0
    12ea:	0f 90       	pop	r0
    12ec:	0f 90       	pop	r0
    12ee:	0f 90       	pop	r0
    12f0:	0f 90       	pop	r0
    12f2:	df 91       	pop	r29
    12f4:	cf 91       	pop	r28
    12f6:	08 95       	ret

000012f8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    12f8:	cf 93       	push	r28
    12fa:	df 93       	push	r29
    12fc:	1f 92       	push	r1
    12fe:	1f 92       	push	r1
    1300:	cd b7       	in	r28, 0x3d	; 61
    1302:	de b7       	in	r29, 0x3e	; 62
    1304:	9a 83       	std	Y+2, r25	; 0x02
    1306:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1308:	20 91 87 02 	lds	r18, 0x0287
    130c:	89 81       	ldd	r24, Y+1	; 0x01
    130e:	9a 81       	ldd	r25, Y+2	; 0x02
    1310:	fc 01       	movw	r30, r24
    1312:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    1314:	20 91 7f 02 	lds	r18, 0x027F
    1318:	30 91 80 02 	lds	r19, 0x0280
    131c:	89 81       	ldd	r24, Y+1	; 0x01
    131e:	9a 81       	ldd	r25, Y+2	; 0x02
    1320:	fc 01       	movw	r30, r24
    1322:	32 83       	std	Z+2, r19	; 0x02
    1324:	21 83       	std	Z+1, r18	; 0x01
}
    1326:	0f 90       	pop	r0
    1328:	0f 90       	pop	r0
    132a:	df 91       	pop	r29
    132c:	cf 91       	pop	r28
    132e:	08 95       	ret

00001330 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    1330:	cf 93       	push	r28
    1332:	df 93       	push	r29
    1334:	00 d0       	rcall	.+0      	; 0x1336 <xTaskCheckForTimeOut+0x6>
    1336:	1f 92       	push	r1
    1338:	1f 92       	push	r1
    133a:	cd b7       	in	r28, 0x3d	; 61
    133c:	de b7       	in	r29, 0x3e	; 62
    133e:	9b 83       	std	Y+3, r25	; 0x03
    1340:	8a 83       	std	Y+2, r24	; 0x02
    1342:	7d 83       	std	Y+5, r23	; 0x05
    1344:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1346:	0f b6       	in	r0, 0x3f	; 63
    1348:	f8 94       	cli
    134a:	0f 92       	push	r0
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    134c:	8c 81       	ldd	r24, Y+4	; 0x04
    134e:	9d 81       	ldd	r25, Y+5	; 0x05
    1350:	fc 01       	movw	r30, r24
    1352:	80 81       	ld	r24, Z
    1354:	91 81       	ldd	r25, Z+1	; 0x01
    1356:	8f 3f       	cpi	r24, 0xFF	; 255
    1358:	ff ef       	ldi	r31, 0xFF	; 255
    135a:	9f 07       	cpc	r25, r31
    135c:	11 f4       	brne	.+4      	; 0x1362 <xTaskCheckForTimeOut+0x32>
			{
				xReturn = pdFALSE;
    135e:	19 82       	std	Y+1, r1	; 0x01
    1360:	4b c0       	rjmp	.+150    	; 0x13f8 <xTaskCheckForTimeOut+0xc8>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    1362:	8a 81       	ldd	r24, Y+2	; 0x02
    1364:	9b 81       	ldd	r25, Y+3	; 0x03
    1366:	fc 01       	movw	r30, r24
    1368:	90 81       	ld	r25, Z
    136a:	80 91 87 02 	lds	r24, 0x0287
    136e:	98 17       	cp	r25, r24
    1370:	79 f0       	breq	.+30     	; 0x1390 <xTaskCheckForTimeOut+0x60>
    1372:	8a 81       	ldd	r24, Y+2	; 0x02
    1374:	9b 81       	ldd	r25, Y+3	; 0x03
    1376:	fc 01       	movw	r30, r24
    1378:	21 81       	ldd	r18, Z+1	; 0x01
    137a:	32 81       	ldd	r19, Z+2	; 0x02
    137c:	80 91 7f 02 	lds	r24, 0x027F
    1380:	90 91 80 02 	lds	r25, 0x0280
    1384:	82 17       	cp	r24, r18
    1386:	93 07       	cpc	r25, r19
    1388:	18 f0       	brcs	.+6      	; 0x1390 <xTaskCheckForTimeOut+0x60>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    138a:	81 e0       	ldi	r24, 0x01	; 1
    138c:	89 83       	std	Y+1, r24	; 0x01
    138e:	34 c0       	rjmp	.+104    	; 0x13f8 <xTaskCheckForTimeOut+0xc8>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    1390:	20 91 7f 02 	lds	r18, 0x027F
    1394:	30 91 80 02 	lds	r19, 0x0280
    1398:	8a 81       	ldd	r24, Y+2	; 0x02
    139a:	9b 81       	ldd	r25, Y+3	; 0x03
    139c:	fc 01       	movw	r30, r24
    139e:	81 81       	ldd	r24, Z+1	; 0x01
    13a0:	92 81       	ldd	r25, Z+2	; 0x02
    13a2:	28 1b       	sub	r18, r24
    13a4:	39 0b       	sbc	r19, r25
    13a6:	8c 81       	ldd	r24, Y+4	; 0x04
    13a8:	9d 81       	ldd	r25, Y+5	; 0x05
    13aa:	fc 01       	movw	r30, r24
    13ac:	80 81       	ld	r24, Z
    13ae:	91 81       	ldd	r25, Z+1	; 0x01
    13b0:	28 17       	cp	r18, r24
    13b2:	39 07       	cpc	r19, r25
    13b4:	f8 f4       	brcc	.+62     	; 0x13f4 <xTaskCheckForTimeOut+0xc4>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    13b6:	8c 81       	ldd	r24, Y+4	; 0x04
    13b8:	9d 81       	ldd	r25, Y+5	; 0x05
    13ba:	fc 01       	movw	r30, r24
    13bc:	20 81       	ld	r18, Z
    13be:	31 81       	ldd	r19, Z+1	; 0x01
    13c0:	8a 81       	ldd	r24, Y+2	; 0x02
    13c2:	9b 81       	ldd	r25, Y+3	; 0x03
    13c4:	fc 01       	movw	r30, r24
    13c6:	41 81       	ldd	r20, Z+1	; 0x01
    13c8:	52 81       	ldd	r21, Z+2	; 0x02
    13ca:	80 91 7f 02 	lds	r24, 0x027F
    13ce:	90 91 80 02 	lds	r25, 0x0280
    13d2:	ba 01       	movw	r22, r20
    13d4:	68 1b       	sub	r22, r24
    13d6:	79 0b       	sbc	r23, r25
    13d8:	cb 01       	movw	r24, r22
    13da:	28 0f       	add	r18, r24
    13dc:	39 1f       	adc	r19, r25
    13de:	8c 81       	ldd	r24, Y+4	; 0x04
    13e0:	9d 81       	ldd	r25, Y+5	; 0x05
    13e2:	fc 01       	movw	r30, r24
    13e4:	31 83       	std	Z+1, r19	; 0x01
    13e6:	20 83       	st	Z, r18
			vTaskSetTimeOutState( pxTimeOut );
    13e8:	8a 81       	ldd	r24, Y+2	; 0x02
    13ea:	9b 81       	ldd	r25, Y+3	; 0x03
    13ec:	0e 94 7c 09 	call	0x12f8	; 0x12f8 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    13f0:	19 82       	std	Y+1, r1	; 0x01
    13f2:	02 c0       	rjmp	.+4      	; 0x13f8 <xTaskCheckForTimeOut+0xc8>
		}
		else
		{
			xReturn = pdTRUE;
    13f4:	81 e0       	ldi	r24, 0x01	; 1
    13f6:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    13f8:	0f 90       	pop	r0
    13fa:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    13fc:	89 81       	ldd	r24, Y+1	; 0x01
}
    13fe:	0f 90       	pop	r0
    1400:	0f 90       	pop	r0
    1402:	0f 90       	pop	r0
    1404:	0f 90       	pop	r0
    1406:	0f 90       	pop	r0
    1408:	df 91       	pop	r29
    140a:	cf 91       	pop	r28
    140c:	08 95       	ret

0000140e <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    140e:	cf 93       	push	r28
    1410:	df 93       	push	r29
    1412:	cd b7       	in	r28, 0x3d	; 61
    1414:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    1416:	81 e0       	ldi	r24, 0x01	; 1
    1418:	80 93 86 02 	sts	0x0286, r24
}
    141c:	df 91       	pop	r29
    141e:	cf 91       	pop	r28
    1420:	08 95       	ret

00001422 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    1422:	cf 93       	push	r28
    1424:	df 93       	push	r29
    1426:	1f 92       	push	r1
    1428:	1f 92       	push	r1
    142a:	cd b7       	in	r28, 0x3d	; 61
    142c:	de b7       	in	r29, 0x3e	; 62
    142e:	9a 83       	std	Y+2, r25	; 0x02
    1430:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    1432:	0e 94 c1 0a 	call	0x1582	; 0x1582 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    1436:	80 91 32 02 	lds	r24, 0x0232
    143a:	82 30       	cpi	r24, 0x02	; 2
    143c:	18 f0       	brcs	.+6      	; 0x1444 <prvIdleTask+0x22>
			{
				taskYIELD();
    143e:	0e 94 3f 19 	call	0x327e	; 0x327e <vPortYield>
				}
				xTaskResumeAll();
			}
		}
		#endif
	}
    1442:	f7 cf       	rjmp	.-18     	; 0x1432 <prvIdleTask+0x10>
    1444:	f6 cf       	rjmp	.-20     	; 0x1432 <prvIdleTask+0x10>

00001446 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    1446:	0f 93       	push	r16
    1448:	1f 93       	push	r17
    144a:	cf 93       	push	r28
    144c:	df 93       	push	r29
    144e:	cd b7       	in	r28, 0x3d	; 61
    1450:	de b7       	in	r29, 0x3e	; 62
    1452:	29 97       	sbiw	r28, 0x09	; 9
    1454:	0f b6       	in	r0, 0x3f	; 63
    1456:	f8 94       	cli
    1458:	de bf       	out	0x3e, r29	; 62
    145a:	0f be       	out	0x3f, r0	; 63
    145c:	cd bf       	out	0x3d, r28	; 61
    145e:	9a 83       	std	Y+2, r25	; 0x02
    1460:	89 83       	std	Y+1, r24	; 0x01
    1462:	7c 83       	std	Y+4, r23	; 0x04
    1464:	6b 83       	std	Y+3, r22	; 0x03
    1466:	4d 83       	std	Y+5, r20	; 0x05
    1468:	3f 83       	std	Y+7, r19	; 0x07
    146a:	2e 83       	std	Y+6, r18	; 0x06
    146c:	19 87       	std	Y+9, r17	; 0x09
    146e:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    1470:	89 81       	ldd	r24, Y+1	; 0x01
    1472:	9a 81       	ldd	r25, Y+2	; 0x02
    1474:	49 96       	adiw	r24, 0x19	; 25
    1476:	2b 81       	ldd	r18, Y+3	; 0x03
    1478:	3c 81       	ldd	r19, Y+4	; 0x04
    147a:	40 e1       	ldi	r20, 0x10	; 16
    147c:	50 e0       	ldi	r21, 0x00	; 0
    147e:	b9 01       	movw	r22, r18
    1480:	0e 94 98 27 	call	0x4f30	; 0x4f30 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    1484:	89 81       	ldd	r24, Y+1	; 0x01
    1486:	9a 81       	ldd	r25, Y+2	; 0x02
    1488:	fc 01       	movw	r30, r24
    148a:	10 a6       	std	Z+40, r1	; 0x28

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    148c:	8d 81       	ldd	r24, Y+5	; 0x05
    148e:	84 30       	cpi	r24, 0x04	; 4
    1490:	10 f0       	brcs	.+4      	; 0x1496 <prvInitialiseTCBVariables+0x50>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    1492:	83 e0       	ldi	r24, 0x03	; 3
    1494:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    1496:	89 81       	ldd	r24, Y+1	; 0x01
    1498:	9a 81       	ldd	r25, Y+2	; 0x02
    149a:	2d 81       	ldd	r18, Y+5	; 0x05
    149c:	fc 01       	movw	r30, r24
    149e:	26 8b       	std	Z+22, r18	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    14a0:	89 81       	ldd	r24, Y+1	; 0x01
    14a2:	9a 81       	ldd	r25, Y+2	; 0x02
    14a4:	2d 81       	ldd	r18, Y+5	; 0x05
    14a6:	fc 01       	movw	r30, r24
    14a8:	21 a7       	std	Z+41, r18	; 0x29
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    14aa:	89 81       	ldd	r24, Y+1	; 0x01
    14ac:	9a 81       	ldd	r25, Y+2	; 0x02
    14ae:	02 96       	adiw	r24, 0x02	; 2
    14b0:	0e 94 9b 12 	call	0x2536	; 0x2536 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    14b4:	89 81       	ldd	r24, Y+1	; 0x01
    14b6:	9a 81       	ldd	r25, Y+2	; 0x02
    14b8:	0c 96       	adiw	r24, 0x0c	; 12
    14ba:	0e 94 9b 12 	call	0x2536	; 0x2536 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    14be:	89 81       	ldd	r24, Y+1	; 0x01
    14c0:	9a 81       	ldd	r25, Y+2	; 0x02
    14c2:	29 81       	ldd	r18, Y+1	; 0x01
    14c4:	3a 81       	ldd	r19, Y+2	; 0x02
    14c6:	fc 01       	movw	r30, r24
    14c8:	31 87       	std	Z+9, r19	; 0x09
    14ca:	20 87       	std	Z+8, r18	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    14cc:	8d 81       	ldd	r24, Y+5	; 0x05
    14ce:	88 2f       	mov	r24, r24
    14d0:	90 e0       	ldi	r25, 0x00	; 0
    14d2:	24 e0       	ldi	r18, 0x04	; 4
    14d4:	30 e0       	ldi	r19, 0x00	; 0
    14d6:	28 1b       	sub	r18, r24
    14d8:	39 0b       	sbc	r19, r25
    14da:	89 81       	ldd	r24, Y+1	; 0x01
    14dc:	9a 81       	ldd	r25, Y+2	; 0x02
    14de:	fc 01       	movw	r30, r24
    14e0:	35 87       	std	Z+13, r19	; 0x0d
    14e2:	24 87       	std	Z+12, r18	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    14e4:	89 81       	ldd	r24, Y+1	; 0x01
    14e6:	9a 81       	ldd	r25, Y+2	; 0x02
    14e8:	29 81       	ldd	r18, Y+1	; 0x01
    14ea:	3a 81       	ldd	r19, Y+2	; 0x02
    14ec:	fc 01       	movw	r30, r24
    14ee:	33 8b       	std	Z+19, r19	; 0x13
    14f0:	22 8b       	std	Z+18, r18	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    14f2:	29 96       	adiw	r28, 0x09	; 9
    14f4:	0f b6       	in	r0, 0x3f	; 63
    14f6:	f8 94       	cli
    14f8:	de bf       	out	0x3e, r29	; 62
    14fa:	0f be       	out	0x3f, r0	; 63
    14fc:	cd bf       	out	0x3d, r28	; 61
    14fe:	df 91       	pop	r29
    1500:	cf 91       	pop	r28
    1502:	1f 91       	pop	r17
    1504:	0f 91       	pop	r16
    1506:	08 95       	ret

00001508 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    1508:	cf 93       	push	r28
    150a:	df 93       	push	r29
    150c:	1f 92       	push	r1
    150e:	cd b7       	in	r28, 0x3d	; 61
    1510:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    1512:	19 82       	std	Y+1, r1	; 0x01
    1514:	13 c0       	rjmp	.+38     	; 0x153c <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    1516:	89 81       	ldd	r24, Y+1	; 0x01
    1518:	28 2f       	mov	r18, r24
    151a:	30 e0       	ldi	r19, 0x00	; 0
    151c:	c9 01       	movw	r24, r18
    151e:	88 0f       	add	r24, r24
    1520:	99 1f       	adc	r25, r25
    1522:	88 0f       	add	r24, r24
    1524:	99 1f       	adc	r25, r25
    1526:	88 0f       	add	r24, r24
    1528:	99 1f       	adc	r25, r25
    152a:	82 0f       	add	r24, r18
    152c:	93 1f       	adc	r25, r19
    152e:	8e 5c       	subi	r24, 0xCE	; 206
    1530:	9d 4f       	sbci	r25, 0xFD	; 253
    1532:	0e 94 65 12 	call	0x24ca	; 0x24ca <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    1536:	89 81       	ldd	r24, Y+1	; 0x01
    1538:	8f 5f       	subi	r24, 0xFF	; 255
    153a:	89 83       	std	Y+1, r24	; 0x01
    153c:	89 81       	ldd	r24, Y+1	; 0x01
    153e:	84 30       	cpi	r24, 0x04	; 4
    1540:	50 f3       	brcs	.-44     	; 0x1516 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    1542:	86 e5       	ldi	r24, 0x56	; 86
    1544:	92 e0       	ldi	r25, 0x02	; 2
    1546:	0e 94 65 12 	call	0x24ca	; 0x24ca <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    154a:	8f e5       	ldi	r24, 0x5F	; 95
    154c:	92 e0       	ldi	r25, 0x02	; 2
    154e:	0e 94 65 12 	call	0x24ca	; 0x24ca <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    1552:	8c e6       	ldi	r24, 0x6C	; 108
    1554:	92 e0       	ldi	r25, 0x02	; 2
    1556:	0e 94 65 12 	call	0x24ca	; 0x24ca <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
    155a:	85 e7       	ldi	r24, 0x75	; 117
    155c:	92 e0       	ldi	r25, 0x02	; 2
    155e:	0e 94 65 12 	call	0x24ca	; 0x24ca <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1562:	86 e5       	ldi	r24, 0x56	; 86
    1564:	92 e0       	ldi	r25, 0x02	; 2
    1566:	90 93 69 02 	sts	0x0269, r25
    156a:	80 93 68 02 	sts	0x0268, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    156e:	8f e5       	ldi	r24, 0x5F	; 95
    1570:	92 e0       	ldi	r25, 0x02	; 2
    1572:	90 93 6b 02 	sts	0x026B, r25
    1576:	80 93 6a 02 	sts	0x026A, r24
}
    157a:	0f 90       	pop	r0
    157c:	df 91       	pop	r29
    157e:	cf 91       	pop	r28
    1580:	08 95       	ret

00001582 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    1582:	cf 93       	push	r28
    1584:	df 93       	push	r29
    1586:	cd b7       	in	r28, 0x3d	; 61
    1588:	de b7       	in	r29, 0x3e	; 62
				prvDeleteTCB( pxTCB );
			}
		}
	}
	#endif
}
    158a:	df 91       	pop	r29
    158c:	cf 91       	pop	r28
    158e:	08 95       	ret

00001590 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    1590:	cf 93       	push	r28
    1592:	df 93       	push	r29
    1594:	1f 92       	push	r1
    1596:	1f 92       	push	r1
    1598:	cd b7       	in	r28, 0x3d	; 61
    159a:	de b7       	in	r29, 0x3e	; 62
    159c:	9a 83       	std	Y+2, r25	; 0x02
    159e:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    15a0:	80 91 30 02 	lds	r24, 0x0230
    15a4:	90 91 31 02 	lds	r25, 0x0231
    15a8:	29 81       	ldd	r18, Y+1	; 0x01
    15aa:	3a 81       	ldd	r19, Y+2	; 0x02
    15ac:	fc 01       	movw	r30, r24
    15ae:	33 83       	std	Z+3, r19	; 0x03
    15b0:	22 83       	std	Z+2, r18	; 0x02

	if( xTimeToWake < xTickCount )
    15b2:	80 91 7f 02 	lds	r24, 0x027F
    15b6:	90 91 80 02 	lds	r25, 0x0280
    15ba:	29 81       	ldd	r18, Y+1	; 0x01
    15bc:	3a 81       	ldd	r19, Y+2	; 0x02
    15be:	28 17       	cp	r18, r24
    15c0:	39 07       	cpc	r19, r25
    15c2:	78 f4       	brcc	.+30     	; 0x15e2 <prvAddCurrentTaskToDelayedList+0x52>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    15c4:	80 91 30 02 	lds	r24, 0x0230
    15c8:	90 91 31 02 	lds	r25, 0x0231
    15cc:	9c 01       	movw	r18, r24
    15ce:	2e 5f       	subi	r18, 0xFE	; 254
    15d0:	3f 4f       	sbci	r19, 0xFF	; 255
    15d2:	80 91 6a 02 	lds	r24, 0x026A
    15d6:	90 91 6b 02 	lds	r25, 0x026B
    15da:	b9 01       	movw	r22, r18
    15dc:	0e 94 04 13 	call	0x2608	; 0x2608 <vListInsert>
    15e0:	1d c0       	rjmp	.+58     	; 0x161c <prvAddCurrentTaskToDelayedList+0x8c>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    15e2:	80 91 30 02 	lds	r24, 0x0230
    15e6:	90 91 31 02 	lds	r25, 0x0231
    15ea:	9c 01       	movw	r18, r24
    15ec:	2e 5f       	subi	r18, 0xFE	; 254
    15ee:	3f 4f       	sbci	r19, 0xFF	; 255
    15f0:	80 91 68 02 	lds	r24, 0x0268
    15f4:	90 91 69 02 	lds	r25, 0x0269
    15f8:	b9 01       	movw	r22, r18
    15fa:	0e 94 04 13 	call	0x2608	; 0x2608 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    15fe:	80 91 00 02 	lds	r24, 0x0200
    1602:	90 91 01 02 	lds	r25, 0x0201
    1606:	29 81       	ldd	r18, Y+1	; 0x01
    1608:	3a 81       	ldd	r19, Y+2	; 0x02
    160a:	28 17       	cp	r18, r24
    160c:	39 07       	cpc	r19, r25
    160e:	30 f4       	brcc	.+12     	; 0x161c <prvAddCurrentTaskToDelayedList+0x8c>
		{
			xNextTaskUnblockTime = xTimeToWake;
    1610:	89 81       	ldd	r24, Y+1	; 0x01
    1612:	9a 81       	ldd	r25, Y+2	; 0x02
    1614:	90 93 01 02 	sts	0x0201, r25
    1618:	80 93 00 02 	sts	0x0200, r24
		}
	}
}
    161c:	0f 90       	pop	r0
    161e:	0f 90       	pop	r0
    1620:	df 91       	pop	r29
    1622:	cf 91       	pop	r28
    1624:	08 95       	ret

00001626 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    1626:	cf 93       	push	r28
    1628:	df 93       	push	r29
    162a:	00 d0       	rcall	.+0      	; 0x162c <prvAllocateTCBAndStack+0x6>
    162c:	00 d0       	rcall	.+0      	; 0x162e <prvAllocateTCBAndStack+0x8>
    162e:	cd b7       	in	r28, 0x3d	; 61
    1630:	de b7       	in	r29, 0x3e	; 62
    1632:	9c 83       	std	Y+4, r25	; 0x04
    1634:	8b 83       	std	Y+3, r24	; 0x03
    1636:	7e 83       	std	Y+6, r23	; 0x06
    1638:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    163a:	8a e2       	ldi	r24, 0x2A	; 42
    163c:	90 e0       	ldi	r25, 0x00	; 0
    163e:	0e 94 cc 16 	call	0x2d98	; 0x2d98 <pvPortMalloc>
    1642:	9a 83       	std	Y+2, r25	; 0x02
    1644:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    1646:	89 81       	ldd	r24, Y+1	; 0x01
    1648:	9a 81       	ldd	r25, Y+2	; 0x02
    164a:	00 97       	sbiw	r24, 0x00	; 0
    164c:	51 f1       	breq	.+84     	; 0x16a2 <prvAllocateTCBAndStack+0x7c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    164e:	8d 81       	ldd	r24, Y+5	; 0x05
    1650:	9e 81       	ldd	r25, Y+6	; 0x06
    1652:	00 97       	sbiw	r24, 0x00	; 0
    1654:	29 f4       	brne	.+10     	; 0x1660 <prvAllocateTCBAndStack+0x3a>
    1656:	8b 81       	ldd	r24, Y+3	; 0x03
    1658:	9c 81       	ldd	r25, Y+4	; 0x04
    165a:	0e 94 cc 16 	call	0x2d98	; 0x2d98 <pvPortMalloc>
    165e:	02 c0       	rjmp	.+4      	; 0x1664 <prvAllocateTCBAndStack+0x3e>
    1660:	8d 81       	ldd	r24, Y+5	; 0x05
    1662:	9e 81       	ldd	r25, Y+6	; 0x06
    1664:	29 81       	ldd	r18, Y+1	; 0x01
    1666:	3a 81       	ldd	r19, Y+2	; 0x02
    1668:	f9 01       	movw	r30, r18
    166a:	90 8f       	std	Z+24, r25	; 0x18
    166c:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    166e:	89 81       	ldd	r24, Y+1	; 0x01
    1670:	9a 81       	ldd	r25, Y+2	; 0x02
    1672:	fc 01       	movw	r30, r24
    1674:	87 89       	ldd	r24, Z+23	; 0x17
    1676:	90 8d       	ldd	r25, Z+24	; 0x18
    1678:	00 97       	sbiw	r24, 0x00	; 0
    167a:	39 f4       	brne	.+14     	; 0x168a <prvAllocateTCBAndStack+0x64>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    167c:	89 81       	ldd	r24, Y+1	; 0x01
    167e:	9a 81       	ldd	r25, Y+2	; 0x02
    1680:	0e 94 12 17 	call	0x2e24	; 0x2e24 <vPortFree>
			pxNewTCB = NULL;
    1684:	1a 82       	std	Y+2, r1	; 0x02
    1686:	19 82       	std	Y+1, r1	; 0x01
    1688:	0c c0       	rjmp	.+24     	; 0x16a2 <prvAllocateTCBAndStack+0x7c>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    168a:	89 81       	ldd	r24, Y+1	; 0x01
    168c:	9a 81       	ldd	r25, Y+2	; 0x02
    168e:	fc 01       	movw	r30, r24
    1690:	87 89       	ldd	r24, Z+23	; 0x17
    1692:	90 8d       	ldd	r25, Z+24	; 0x18
    1694:	2b 81       	ldd	r18, Y+3	; 0x03
    1696:	3c 81       	ldd	r19, Y+4	; 0x04
    1698:	a9 01       	movw	r20, r18
    169a:	65 ea       	ldi	r22, 0xA5	; 165
    169c:	70 e0       	ldi	r23, 0x00	; 0
    169e:	0e 94 91 27 	call	0x4f22	; 0x4f22 <memset>
		}
	}

	return pxNewTCB;
    16a2:	89 81       	ldd	r24, Y+1	; 0x01
    16a4:	9a 81       	ldd	r25, Y+2	; 0x02
}
    16a6:	26 96       	adiw	r28, 0x06	; 6
    16a8:	0f b6       	in	r0, 0x3f	; 63
    16aa:	f8 94       	cli
    16ac:	de bf       	out	0x3e, r29	; 62
    16ae:	0f be       	out	0x3f, r0	; 63
    16b0:	cd bf       	out	0x3d, r28	; 61
    16b2:	df 91       	pop	r29
    16b4:	cf 91       	pop	r28
    16b6:	08 95       	ret

000016b8 <usTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
    16b8:	0f 93       	push	r16
    16ba:	1f 93       	push	r17
    16bc:	cf 93       	push	r28
    16be:	df 93       	push	r29
    16c0:	1f 92       	push	r1
    16c2:	1f 92       	push	r1
    16c4:	cd b7       	in	r28, 0x3d	; 61
    16c6:	de b7       	in	r29, 0x3e	; 62
    16c8:	9a 83       	std	Y+2, r25	; 0x02
    16ca:	89 83       	std	Y+1, r24	; 0x01
	register unsigned short usCount = 0U;
    16cc:	00 e0       	ldi	r16, 0x00	; 0
    16ce:	10 e0       	ldi	r17, 0x00	; 0

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    16d0:	09 c0       	rjmp	.+18     	; 0x16e4 <usTaskCheckFreeStackSpace+0x2c>
		{
			pucStackByte -= portSTACK_GROWTH;
    16d2:	89 81       	ldd	r24, Y+1	; 0x01
    16d4:	9a 81       	ldd	r25, Y+2	; 0x02
    16d6:	01 96       	adiw	r24, 0x01	; 1
    16d8:	9a 83       	std	Y+2, r25	; 0x02
    16da:	89 83       	std	Y+1, r24	; 0x01
			usCount++;
    16dc:	c8 01       	movw	r24, r16
    16de:	8c 01       	movw	r16, r24
    16e0:	0f 5f       	subi	r16, 0xFF	; 255
    16e2:	1f 4f       	sbci	r17, 0xFF	; 255

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    16e4:	89 81       	ldd	r24, Y+1	; 0x01
    16e6:	9a 81       	ldd	r25, Y+2	; 0x02
    16e8:	fc 01       	movw	r30, r24
    16ea:	80 81       	ld	r24, Z
    16ec:	85 3a       	cpi	r24, 0xA5	; 165
    16ee:	89 f3       	breq	.-30     	; 0x16d2 <usTaskCheckFreeStackSpace+0x1a>
			usCount++;
		}

		usCount /= sizeof( portSTACK_TYPE );

		return usCount;
    16f0:	c8 01       	movw	r24, r16
	}
    16f2:	0f 90       	pop	r0
    16f4:	0f 90       	pop	r0
    16f6:	df 91       	pop	r29
    16f8:	cf 91       	pop	r28
    16fa:	1f 91       	pop	r17
    16fc:	0f 91       	pop	r16
    16fe:	08 95       	ret

00001700 <uxTaskGetStackHighWaterMark>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
	{
    1700:	cf 93       	push	r28
    1702:	df 93       	push	r29
    1704:	cd b7       	in	r28, 0x3d	; 61
    1706:	de b7       	in	r29, 0x3e	; 62
    1708:	27 97       	sbiw	r28, 0x07	; 7
    170a:	0f b6       	in	r0, 0x3f	; 63
    170c:	f8 94       	cli
    170e:	de bf       	out	0x3e, r29	; 62
    1710:	0f be       	out	0x3f, r0	; 63
    1712:	cd bf       	out	0x3d, r28	; 61
    1714:	9f 83       	std	Y+7, r25	; 0x07
    1716:	8e 83       	std	Y+6, r24	; 0x06
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    1718:	8e 81       	ldd	r24, Y+6	; 0x06
    171a:	9f 81       	ldd	r25, Y+7	; 0x07
    171c:	00 97       	sbiw	r24, 0x00	; 0
    171e:	29 f4       	brne	.+10     	; 0x172a <uxTaskGetStackHighWaterMark+0x2a>
    1720:	80 91 30 02 	lds	r24, 0x0230
    1724:	90 91 31 02 	lds	r25, 0x0231
    1728:	02 c0       	rjmp	.+4      	; 0x172e <uxTaskGetStackHighWaterMark+0x2e>
    172a:	8e 81       	ldd	r24, Y+6	; 0x06
    172c:	9f 81       	ldd	r25, Y+7	; 0x07
    172e:	9a 83       	std	Y+2, r25	; 0x02
    1730:	89 83       	std	Y+1, r24	; 0x01

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    1732:	89 81       	ldd	r24, Y+1	; 0x01
    1734:	9a 81       	ldd	r25, Y+2	; 0x02
    1736:	fc 01       	movw	r30, r24
    1738:	87 89       	ldd	r24, Z+23	; 0x17
    173a:	90 8d       	ldd	r25, Z+24	; 0x18
    173c:	9c 83       	std	Y+4, r25	; 0x04
    173e:	8b 83       	std	Y+3, r24	; 0x03
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
		}
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
    1740:	8b 81       	ldd	r24, Y+3	; 0x03
    1742:	9c 81       	ldd	r25, Y+4	; 0x04
    1744:	0e 94 5c 0b 	call	0x16b8	; 0x16b8 <usTaskCheckFreeStackSpace>
    1748:	8d 83       	std	Y+5, r24	; 0x05

		return uxReturn;
    174a:	8d 81       	ldd	r24, Y+5	; 0x05
	}
    174c:	27 96       	adiw	r28, 0x07	; 7
    174e:	0f b6       	in	r0, 0x3f	; 63
    1750:	f8 94       	cli
    1752:	de bf       	out	0x3e, r29	; 62
    1754:	0f be       	out	0x3f, r0	; 63
    1756:	cd bf       	out	0x3d, r28	; 61
    1758:	df 91       	pop	r29
    175a:	cf 91       	pop	r28
    175c:	08 95       	ret

0000175e <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	xTaskHandle xTaskGetCurrentTaskHandle( void )
	{
    175e:	cf 93       	push	r28
    1760:	df 93       	push	r29
    1762:	1f 92       	push	r1
    1764:	1f 92       	push	r1
    1766:	cd b7       	in	r28, 0x3d	; 61
    1768:	de b7       	in	r29, 0x3e	; 62
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    176a:	80 91 30 02 	lds	r24, 0x0230
    176e:	90 91 31 02 	lds	r25, 0x0231
    1772:	9a 83       	std	Y+2, r25	; 0x02
    1774:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    1776:	89 81       	ldd	r24, Y+1	; 0x01
    1778:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    177a:	0f 90       	pop	r0
    177c:	0f 90       	pop	r0
    177e:	df 91       	pop	r29
    1780:	cf 91       	pop	r28
    1782:	08 95       	ret

00001784 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    1784:	cf 93       	push	r28
    1786:	df 93       	push	r29
    1788:	00 d0       	rcall	.+0      	; 0x178a <vTaskPriorityInherit+0x6>
    178a:	1f 92       	push	r1
    178c:	cd b7       	in	r28, 0x3d	; 61
    178e:	de b7       	in	r29, 0x3e	; 62
    1790:	9c 83       	std	Y+4, r25	; 0x04
    1792:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
    1794:	8b 81       	ldd	r24, Y+3	; 0x03
    1796:	9c 81       	ldd	r25, Y+4	; 0x04
    1798:	9a 83       	std	Y+2, r25	; 0x02
    179a:	89 83       	std	Y+1, r24	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    179c:	8b 81       	ldd	r24, Y+3	; 0x03
    179e:	9c 81       	ldd	r25, Y+4	; 0x04
    17a0:	00 97       	sbiw	r24, 0x00	; 0
    17a2:	09 f4       	brne	.+2      	; 0x17a6 <vTaskPriorityInherit+0x22>
    17a4:	78 c0       	rjmp	.+240    	; 0x1896 <vTaskPriorityInherit+0x112>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    17a6:	89 81       	ldd	r24, Y+1	; 0x01
    17a8:	9a 81       	ldd	r25, Y+2	; 0x02
    17aa:	fc 01       	movw	r30, r24
    17ac:	26 89       	ldd	r18, Z+22	; 0x16
    17ae:	80 91 30 02 	lds	r24, 0x0230
    17b2:	90 91 31 02 	lds	r25, 0x0231
    17b6:	fc 01       	movw	r30, r24
    17b8:	86 89       	ldd	r24, Z+22	; 0x16
    17ba:	28 17       	cp	r18, r24
    17bc:	08 f0       	brcs	.+2      	; 0x17c0 <vTaskPriorityInherit+0x3c>
    17be:	6b c0       	rjmp	.+214    	; 0x1896 <vTaskPriorityInherit+0x112>
			{
				/* Adjust the mutex holder state to account for its new priority. */
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    17c0:	80 91 30 02 	lds	r24, 0x0230
    17c4:	90 91 31 02 	lds	r25, 0x0231
    17c8:	fc 01       	movw	r30, r24
    17ca:	86 89       	ldd	r24, Z+22	; 0x16
    17cc:	88 2f       	mov	r24, r24
    17ce:	90 e0       	ldi	r25, 0x00	; 0
    17d0:	24 e0       	ldi	r18, 0x04	; 4
    17d2:	30 e0       	ldi	r19, 0x00	; 0
    17d4:	28 1b       	sub	r18, r24
    17d6:	39 0b       	sbc	r19, r25
    17d8:	89 81       	ldd	r24, Y+1	; 0x01
    17da:	9a 81       	ldd	r25, Y+2	; 0x02
    17dc:	fc 01       	movw	r30, r24
    17de:	35 87       	std	Z+13, r19	; 0x0d
    17e0:	24 87       	std	Z+12, r18	; 0x0c

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    17e2:	89 81       	ldd	r24, Y+1	; 0x01
    17e4:	9a 81       	ldd	r25, Y+2	; 0x02
    17e6:	fc 01       	movw	r30, r24
    17e8:	42 85       	ldd	r20, Z+10	; 0x0a
    17ea:	53 85       	ldd	r21, Z+11	; 0x0b
    17ec:	89 81       	ldd	r24, Y+1	; 0x01
    17ee:	9a 81       	ldd	r25, Y+2	; 0x02
    17f0:	fc 01       	movw	r30, r24
    17f2:	86 89       	ldd	r24, Z+22	; 0x16
    17f4:	28 2f       	mov	r18, r24
    17f6:	30 e0       	ldi	r19, 0x00	; 0
    17f8:	c9 01       	movw	r24, r18
    17fa:	88 0f       	add	r24, r24
    17fc:	99 1f       	adc	r25, r25
    17fe:	88 0f       	add	r24, r24
    1800:	99 1f       	adc	r25, r25
    1802:	88 0f       	add	r24, r24
    1804:	99 1f       	adc	r25, r25
    1806:	82 0f       	add	r24, r18
    1808:	93 1f       	adc	r25, r19
    180a:	8e 5c       	subi	r24, 0xCE	; 206
    180c:	9d 4f       	sbci	r25, 0xFD	; 253
    180e:	48 17       	cp	r20, r24
    1810:	59 07       	cpc	r21, r25
    1812:	b9 f5       	brne	.+110    	; 0x1882 <vTaskPriorityInherit+0xfe>
				{
					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    1814:	89 81       	ldd	r24, Y+1	; 0x01
    1816:	9a 81       	ldd	r25, Y+2	; 0x02
    1818:	02 96       	adiw	r24, 0x02	; 2
    181a:	0e 94 7d 13 	call	0x26fa	; 0x26fa <uxListRemove>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    181e:	80 91 30 02 	lds	r24, 0x0230
    1822:	90 91 31 02 	lds	r25, 0x0231
    1826:	fc 01       	movw	r30, r24
    1828:	26 89       	ldd	r18, Z+22	; 0x16
    182a:	89 81       	ldd	r24, Y+1	; 0x01
    182c:	9a 81       	ldd	r25, Y+2	; 0x02
    182e:	fc 01       	movw	r30, r24
    1830:	26 8b       	std	Z+22, r18	; 0x16
					prvAddTaskToReadyQueue( pxTCB );
    1832:	89 81       	ldd	r24, Y+1	; 0x01
    1834:	9a 81       	ldd	r25, Y+2	; 0x02
    1836:	fc 01       	movw	r30, r24
    1838:	96 89       	ldd	r25, Z+22	; 0x16
    183a:	80 91 82 02 	lds	r24, 0x0282
    183e:	89 17       	cp	r24, r25
    1840:	30 f4       	brcc	.+12     	; 0x184e <vTaskPriorityInherit+0xca>
    1842:	89 81       	ldd	r24, Y+1	; 0x01
    1844:	9a 81       	ldd	r25, Y+2	; 0x02
    1846:	fc 01       	movw	r30, r24
    1848:	86 89       	ldd	r24, Z+22	; 0x16
    184a:	80 93 82 02 	sts	0x0282, r24
    184e:	89 81       	ldd	r24, Y+1	; 0x01
    1850:	9a 81       	ldd	r25, Y+2	; 0x02
    1852:	ac 01       	movw	r20, r24
    1854:	4e 5f       	subi	r20, 0xFE	; 254
    1856:	5f 4f       	sbci	r21, 0xFF	; 255
    1858:	89 81       	ldd	r24, Y+1	; 0x01
    185a:	9a 81       	ldd	r25, Y+2	; 0x02
    185c:	fc 01       	movw	r30, r24
    185e:	86 89       	ldd	r24, Z+22	; 0x16
    1860:	28 2f       	mov	r18, r24
    1862:	30 e0       	ldi	r19, 0x00	; 0
    1864:	c9 01       	movw	r24, r18
    1866:	88 0f       	add	r24, r24
    1868:	99 1f       	adc	r25, r25
    186a:	88 0f       	add	r24, r24
    186c:	99 1f       	adc	r25, r25
    186e:	88 0f       	add	r24, r24
    1870:	99 1f       	adc	r25, r25
    1872:	82 0f       	add	r24, r18
    1874:	93 1f       	adc	r25, r19
    1876:	8e 5c       	subi	r24, 0xCE	; 206
    1878:	9d 4f       	sbci	r25, 0xFD	; 253
    187a:	ba 01       	movw	r22, r20
    187c:	0e 94 ad 12 	call	0x255a	; 0x255a <vListInsertEnd>
    1880:	0a c0       	rjmp	.+20     	; 0x1896 <vTaskPriorityInherit+0x112>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    1882:	80 91 30 02 	lds	r24, 0x0230
    1886:	90 91 31 02 	lds	r25, 0x0231
    188a:	fc 01       	movw	r30, r24
    188c:	26 89       	ldd	r18, Z+22	; 0x16
    188e:	89 81       	ldd	r24, Y+1	; 0x01
    1890:	9a 81       	ldd	r25, Y+2	; 0x02
    1892:	fc 01       	movw	r30, r24
    1894:	26 8b       	std	Z+22, r18	; 0x16
				}

				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
			}
		}
	}
    1896:	0f 90       	pop	r0
    1898:	0f 90       	pop	r0
    189a:	0f 90       	pop	r0
    189c:	0f 90       	pop	r0
    189e:	df 91       	pop	r29
    18a0:	cf 91       	pop	r28
    18a2:	08 95       	ret

000018a4 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    18a4:	cf 93       	push	r28
    18a6:	df 93       	push	r29
    18a8:	00 d0       	rcall	.+0      	; 0x18aa <vTaskPriorityDisinherit+0x6>
    18aa:	1f 92       	push	r1
    18ac:	cd b7       	in	r28, 0x3d	; 61
    18ae:	de b7       	in	r29, 0x3e	; 62
    18b0:	9c 83       	std	Y+4, r25	; 0x04
    18b2:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
    18b4:	8b 81       	ldd	r24, Y+3	; 0x03
    18b6:	9c 81       	ldd	r25, Y+4	; 0x04
    18b8:	9a 83       	std	Y+2, r25	; 0x02
    18ba:	89 83       	std	Y+1, r24	; 0x01

		if( pxMutexHolder != NULL )
    18bc:	8b 81       	ldd	r24, Y+3	; 0x03
    18be:	9c 81       	ldd	r25, Y+4	; 0x04
    18c0:	00 97       	sbiw	r24, 0x00	; 0
    18c2:	09 f4       	brne	.+2      	; 0x18c6 <vTaskPriorityDisinherit+0x22>
    18c4:	4e c0       	rjmp	.+156    	; 0x1962 <vTaskPriorityDisinherit+0xbe>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    18c6:	89 81       	ldd	r24, Y+1	; 0x01
    18c8:	9a 81       	ldd	r25, Y+2	; 0x02
    18ca:	fc 01       	movw	r30, r24
    18cc:	26 89       	ldd	r18, Z+22	; 0x16
    18ce:	89 81       	ldd	r24, Y+1	; 0x01
    18d0:	9a 81       	ldd	r25, Y+2	; 0x02
    18d2:	fc 01       	movw	r30, r24
    18d4:	81 a5       	ldd	r24, Z+41	; 0x29
    18d6:	28 17       	cp	r18, r24
    18d8:	09 f4       	brne	.+2      	; 0x18dc <vTaskPriorityDisinherit+0x38>
    18da:	43 c0       	rjmp	.+134    	; 0x1962 <vTaskPriorityDisinherit+0xbe>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    18dc:	89 81       	ldd	r24, Y+1	; 0x01
    18de:	9a 81       	ldd	r25, Y+2	; 0x02
    18e0:	02 96       	adiw	r24, 0x02	; 2
    18e2:	0e 94 7d 13 	call	0x26fa	; 0x26fa <uxListRemove>
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    18e6:	89 81       	ldd	r24, Y+1	; 0x01
    18e8:	9a 81       	ldd	r25, Y+2	; 0x02
    18ea:	fc 01       	movw	r30, r24
    18ec:	21 a5       	ldd	r18, Z+41	; 0x29
    18ee:	89 81       	ldd	r24, Y+1	; 0x01
    18f0:	9a 81       	ldd	r25, Y+2	; 0x02
    18f2:	fc 01       	movw	r30, r24
    18f4:	26 8b       	std	Z+22, r18	; 0x16
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    18f6:	89 81       	ldd	r24, Y+1	; 0x01
    18f8:	9a 81       	ldd	r25, Y+2	; 0x02
    18fa:	fc 01       	movw	r30, r24
    18fc:	86 89       	ldd	r24, Z+22	; 0x16
    18fe:	88 2f       	mov	r24, r24
    1900:	90 e0       	ldi	r25, 0x00	; 0
    1902:	24 e0       	ldi	r18, 0x04	; 4
    1904:	30 e0       	ldi	r19, 0x00	; 0
    1906:	28 1b       	sub	r18, r24
    1908:	39 0b       	sbc	r19, r25
    190a:	89 81       	ldd	r24, Y+1	; 0x01
    190c:	9a 81       	ldd	r25, Y+2	; 0x02
    190e:	fc 01       	movw	r30, r24
    1910:	35 87       	std	Z+13, r19	; 0x0d
    1912:	24 87       	std	Z+12, r18	; 0x0c
				prvAddTaskToReadyQueue( pxTCB );
    1914:	89 81       	ldd	r24, Y+1	; 0x01
    1916:	9a 81       	ldd	r25, Y+2	; 0x02
    1918:	fc 01       	movw	r30, r24
    191a:	96 89       	ldd	r25, Z+22	; 0x16
    191c:	80 91 82 02 	lds	r24, 0x0282
    1920:	89 17       	cp	r24, r25
    1922:	30 f4       	brcc	.+12     	; 0x1930 <vTaskPriorityDisinherit+0x8c>
    1924:	89 81       	ldd	r24, Y+1	; 0x01
    1926:	9a 81       	ldd	r25, Y+2	; 0x02
    1928:	fc 01       	movw	r30, r24
    192a:	86 89       	ldd	r24, Z+22	; 0x16
    192c:	80 93 82 02 	sts	0x0282, r24
    1930:	89 81       	ldd	r24, Y+1	; 0x01
    1932:	9a 81       	ldd	r25, Y+2	; 0x02
    1934:	ac 01       	movw	r20, r24
    1936:	4e 5f       	subi	r20, 0xFE	; 254
    1938:	5f 4f       	sbci	r21, 0xFF	; 255
    193a:	89 81       	ldd	r24, Y+1	; 0x01
    193c:	9a 81       	ldd	r25, Y+2	; 0x02
    193e:	fc 01       	movw	r30, r24
    1940:	86 89       	ldd	r24, Z+22	; 0x16
    1942:	28 2f       	mov	r18, r24
    1944:	30 e0       	ldi	r19, 0x00	; 0
    1946:	c9 01       	movw	r24, r18
    1948:	88 0f       	add	r24, r24
    194a:	99 1f       	adc	r25, r25
    194c:	88 0f       	add	r24, r24
    194e:	99 1f       	adc	r25, r25
    1950:	88 0f       	add	r24, r24
    1952:	99 1f       	adc	r25, r25
    1954:	82 0f       	add	r24, r18
    1956:	93 1f       	adc	r25, r19
    1958:	8e 5c       	subi	r24, 0xCE	; 206
    195a:	9d 4f       	sbci	r25, 0xFD	; 253
    195c:	ba 01       	movw	r22, r20
    195e:	0e 94 ad 12 	call	0x255a	; 0x255a <vListInsertEnd>
			}
		}
	}
    1962:	0f 90       	pop	r0
    1964:	0f 90       	pop	r0
    1966:	0f 90       	pop	r0
    1968:	0f 90       	pop	r0
    196a:	df 91       	pop	r29
    196c:	cf 91       	pop	r28
    196e:	08 95       	ret

00001970 <xQueueGenericReset>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle pxQueue, portBASE_TYPE xNewQueue )
{
    1970:	cf 93       	push	r28
    1972:	df 93       	push	r29
    1974:	00 d0       	rcall	.+0      	; 0x1976 <xQueueGenericReset+0x6>
    1976:	cd b7       	in	r28, 0x3d	; 61
    1978:	de b7       	in	r29, 0x3e	; 62
    197a:	9a 83       	std	Y+2, r25	; 0x02
    197c:	89 83       	std	Y+1, r24	; 0x01
    197e:	6b 83       	std	Y+3, r22	; 0x03
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1980:	0f b6       	in	r0, 0x3f	; 63
    1982:	f8 94       	cli
    1984:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1986:	89 81       	ldd	r24, Y+1	; 0x01
    1988:	9a 81       	ldd	r25, Y+2	; 0x02
    198a:	fc 01       	movw	r30, r24
    198c:	20 81       	ld	r18, Z
    198e:	31 81       	ldd	r19, Z+1	; 0x01
    1990:	89 81       	ldd	r24, Y+1	; 0x01
    1992:	9a 81       	ldd	r25, Y+2	; 0x02
    1994:	fc 01       	movw	r30, r24
    1996:	83 8d       	ldd	r24, Z+27	; 0x1b
    1998:	68 2f       	mov	r22, r24
    199a:	70 e0       	ldi	r23, 0x00	; 0
    199c:	89 81       	ldd	r24, Y+1	; 0x01
    199e:	9a 81       	ldd	r25, Y+2	; 0x02
    19a0:	fc 01       	movw	r30, r24
    19a2:	84 8d       	ldd	r24, Z+28	; 0x1c
    19a4:	48 2f       	mov	r20, r24
    19a6:	50 e0       	ldi	r21, 0x00	; 0
    19a8:	64 9f       	mul	r22, r20
    19aa:	c0 01       	movw	r24, r0
    19ac:	65 9f       	mul	r22, r21
    19ae:	90 0d       	add	r25, r0
    19b0:	74 9f       	mul	r23, r20
    19b2:	90 0d       	add	r25, r0
    19b4:	11 24       	eor	r1, r1
    19b6:	28 0f       	add	r18, r24
    19b8:	39 1f       	adc	r19, r25
    19ba:	89 81       	ldd	r24, Y+1	; 0x01
    19bc:	9a 81       	ldd	r25, Y+2	; 0x02
    19be:	fc 01       	movw	r30, r24
    19c0:	33 83       	std	Z+3, r19	; 0x03
    19c2:	22 83       	std	Z+2, r18	; 0x02
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    19c4:	89 81       	ldd	r24, Y+1	; 0x01
    19c6:	9a 81       	ldd	r25, Y+2	; 0x02
    19c8:	fc 01       	movw	r30, r24
    19ca:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    19cc:	89 81       	ldd	r24, Y+1	; 0x01
    19ce:	9a 81       	ldd	r25, Y+2	; 0x02
    19d0:	fc 01       	movw	r30, r24
    19d2:	20 81       	ld	r18, Z
    19d4:	31 81       	ldd	r19, Z+1	; 0x01
    19d6:	89 81       	ldd	r24, Y+1	; 0x01
    19d8:	9a 81       	ldd	r25, Y+2	; 0x02
    19da:	fc 01       	movw	r30, r24
    19dc:	35 83       	std	Z+5, r19	; 0x05
    19de:	24 83       	std	Z+4, r18	; 0x04
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
    19e0:	89 81       	ldd	r24, Y+1	; 0x01
    19e2:	9a 81       	ldd	r25, Y+2	; 0x02
    19e4:	fc 01       	movw	r30, r24
    19e6:	20 81       	ld	r18, Z
    19e8:	31 81       	ldd	r19, Z+1	; 0x01
    19ea:	89 81       	ldd	r24, Y+1	; 0x01
    19ec:	9a 81       	ldd	r25, Y+2	; 0x02
    19ee:	fc 01       	movw	r30, r24
    19f0:	83 8d       	ldd	r24, Z+27	; 0x1b
    19f2:	88 2f       	mov	r24, r24
    19f4:	90 e0       	ldi	r25, 0x00	; 0
    19f6:	bc 01       	movw	r22, r24
    19f8:	61 50       	subi	r22, 0x01	; 1
    19fa:	71 09       	sbc	r23, r1
    19fc:	89 81       	ldd	r24, Y+1	; 0x01
    19fe:	9a 81       	ldd	r25, Y+2	; 0x02
    1a00:	fc 01       	movw	r30, r24
    1a02:	84 8d       	ldd	r24, Z+28	; 0x1c
    1a04:	48 2f       	mov	r20, r24
    1a06:	50 e0       	ldi	r21, 0x00	; 0
    1a08:	64 9f       	mul	r22, r20
    1a0a:	c0 01       	movw	r24, r0
    1a0c:	65 9f       	mul	r22, r21
    1a0e:	90 0d       	add	r25, r0
    1a10:	74 9f       	mul	r23, r20
    1a12:	90 0d       	add	r25, r0
    1a14:	11 24       	eor	r1, r1
    1a16:	28 0f       	add	r18, r24
    1a18:	39 1f       	adc	r19, r25
    1a1a:	89 81       	ldd	r24, Y+1	; 0x01
    1a1c:	9a 81       	ldd	r25, Y+2	; 0x02
    1a1e:	fc 01       	movw	r30, r24
    1a20:	37 83       	std	Z+7, r19	; 0x07
    1a22:	26 83       	std	Z+6, r18	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    1a24:	89 81       	ldd	r24, Y+1	; 0x01
    1a26:	9a 81       	ldd	r25, Y+2	; 0x02
    1a28:	2f ef       	ldi	r18, 0xFF	; 255
    1a2a:	fc 01       	movw	r30, r24
    1a2c:	25 8f       	std	Z+29, r18	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    1a2e:	89 81       	ldd	r24, Y+1	; 0x01
    1a30:	9a 81       	ldd	r25, Y+2	; 0x02
    1a32:	2f ef       	ldi	r18, 0xFF	; 255
    1a34:	fc 01       	movw	r30, r24
    1a36:	26 8f       	std	Z+30, r18	; 0x1e

		if( xNewQueue == pdFALSE )
    1a38:	8b 81       	ldd	r24, Y+3	; 0x03
    1a3a:	88 23       	and	r24, r24
    1a3c:	81 f4       	brne	.+32     	; 0x1a5e <xQueueGenericReset+0xee>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to	write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1a3e:	89 81       	ldd	r24, Y+1	; 0x01
    1a40:	9a 81       	ldd	r25, Y+2	; 0x02
    1a42:	fc 01       	movw	r30, r24
    1a44:	80 85       	ldd	r24, Z+8	; 0x08
    1a46:	88 23       	and	r24, r24
    1a48:	a1 f0       	breq	.+40     	; 0x1a72 <xQueueGenericReset+0x102>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1a4a:	89 81       	ldd	r24, Y+1	; 0x01
    1a4c:	9a 81       	ldd	r25, Y+2	; 0x02
    1a4e:	08 96       	adiw	r24, 0x08	; 8
    1a50:	0e 94 12 09 	call	0x1224	; 0x1224 <xTaskRemoveFromEventList>
    1a54:	81 30       	cpi	r24, 0x01	; 1
    1a56:	69 f4       	brne	.+26     	; 0x1a72 <xQueueGenericReset+0x102>
				{
					portYIELD_WITHIN_API();
    1a58:	0e 94 3f 19 	call	0x327e	; 0x327e <vPortYield>
    1a5c:	0a c0       	rjmp	.+20     	; 0x1a72 <xQueueGenericReset+0x102>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1a5e:	89 81       	ldd	r24, Y+1	; 0x01
    1a60:	9a 81       	ldd	r25, Y+2	; 0x02
    1a62:	08 96       	adiw	r24, 0x08	; 8
    1a64:	0e 94 65 12 	call	0x24ca	; 0x24ca <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1a68:	89 81       	ldd	r24, Y+1	; 0x01
    1a6a:	9a 81       	ldd	r25, Y+2	; 0x02
    1a6c:	41 96       	adiw	r24, 0x11	; 17
    1a6e:	0e 94 65 12 	call	0x24ca	; 0x24ca <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1a72:	0f 90       	pop	r0
    1a74:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    1a76:	81 e0       	ldi	r24, 0x01	; 1
}
    1a78:	0f 90       	pop	r0
    1a7a:	0f 90       	pop	r0
    1a7c:	0f 90       	pop	r0
    1a7e:	df 91       	pop	r29
    1a80:	cf 91       	pop	r28
    1a82:	08 95       	ret

00001a84 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
    1a84:	cf 93       	push	r28
    1a86:	df 93       	push	r29
    1a88:	cd b7       	in	r28, 0x3d	; 61
    1a8a:	de b7       	in	r29, 0x3e	; 62
    1a8c:	29 97       	sbiw	r28, 0x09	; 9
    1a8e:	0f b6       	in	r0, 0x3f	; 63
    1a90:	f8 94       	cli
    1a92:	de bf       	out	0x3e, r29	; 62
    1a94:	0f be       	out	0x3f, r0	; 63
    1a96:	cd bf       	out	0x3d, r28	; 61
    1a98:	8f 83       	std	Y+7, r24	; 0x07
    1a9a:	68 87       	std	Y+8, r22	; 0x08
    1a9c:	49 87       	std	Y+9, r20	; 0x09
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    1a9e:	1a 82       	std	Y+2, r1	; 0x02
    1aa0:	19 82       	std	Y+1, r1	; 0x01
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    1aa2:	8f 81       	ldd	r24, Y+7	; 0x07
    1aa4:	88 23       	and	r24, r24
    1aa6:	09 f4       	brne	.+2      	; 0x1aaa <xQueueGenericCreate+0x26>
    1aa8:	43 c0       	rjmp	.+134    	; 0x1b30 <xQueueGenericCreate+0xac>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    1aaa:	8f e1       	ldi	r24, 0x1F	; 31
    1aac:	90 e0       	ldi	r25, 0x00	; 0
    1aae:	0e 94 cc 16 	call	0x2d98	; 0x2d98 <pvPortMalloc>
    1ab2:	9c 83       	std	Y+4, r25	; 0x04
    1ab4:	8b 83       	std	Y+3, r24	; 0x03
		if( pxNewQueue != NULL )
    1ab6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ab8:	9c 81       	ldd	r25, Y+4	; 0x04
    1aba:	00 97       	sbiw	r24, 0x00	; 0
    1abc:	c9 f1       	breq	.+114    	; 0x1b30 <xQueueGenericCreate+0xac>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    1abe:	8f 81       	ldd	r24, Y+7	; 0x07
    1ac0:	48 2f       	mov	r20, r24
    1ac2:	50 e0       	ldi	r21, 0x00	; 0
    1ac4:	88 85       	ldd	r24, Y+8	; 0x08
    1ac6:	28 2f       	mov	r18, r24
    1ac8:	30 e0       	ldi	r19, 0x00	; 0
    1aca:	42 9f       	mul	r20, r18
    1acc:	c0 01       	movw	r24, r0
    1ace:	43 9f       	mul	r20, r19
    1ad0:	90 0d       	add	r25, r0
    1ad2:	52 9f       	mul	r21, r18
    1ad4:	90 0d       	add	r25, r0
    1ad6:	11 24       	eor	r1, r1
    1ad8:	01 96       	adiw	r24, 0x01	; 1
    1ada:	9e 83       	std	Y+6, r25	; 0x06
    1adc:	8d 83       	std	Y+5, r24	; 0x05

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    1ade:	8d 81       	ldd	r24, Y+5	; 0x05
    1ae0:	9e 81       	ldd	r25, Y+6	; 0x06
    1ae2:	0e 94 cc 16 	call	0x2d98	; 0x2d98 <pvPortMalloc>
    1ae6:	9c 01       	movw	r18, r24
    1ae8:	8b 81       	ldd	r24, Y+3	; 0x03
    1aea:	9c 81       	ldd	r25, Y+4	; 0x04
    1aec:	fc 01       	movw	r30, r24
    1aee:	31 83       	std	Z+1, r19	; 0x01
    1af0:	20 83       	st	Z, r18
			if( pxNewQueue->pcHead != NULL )
    1af2:	8b 81       	ldd	r24, Y+3	; 0x03
    1af4:	9c 81       	ldd	r25, Y+4	; 0x04
    1af6:	fc 01       	movw	r30, r24
    1af8:	80 81       	ld	r24, Z
    1afa:	91 81       	ldd	r25, Z+1	; 0x01
    1afc:	00 97       	sbiw	r24, 0x00	; 0
    1afe:	a1 f0       	breq	.+40     	; 0x1b28 <xQueueGenericCreate+0xa4>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    1b00:	8b 81       	ldd	r24, Y+3	; 0x03
    1b02:	9c 81       	ldd	r25, Y+4	; 0x04
    1b04:	2f 81       	ldd	r18, Y+7	; 0x07
    1b06:	fc 01       	movw	r30, r24
    1b08:	23 8f       	std	Z+27, r18	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1b0a:	8b 81       	ldd	r24, Y+3	; 0x03
    1b0c:	9c 81       	ldd	r25, Y+4	; 0x04
    1b0e:	28 85       	ldd	r18, Y+8	; 0x08
    1b10:	fc 01       	movw	r30, r24
    1b12:	24 8f       	std	Z+28, r18	; 0x1c
				xQueueGenericReset( pxNewQueue, pdTRUE );
    1b14:	8b 81       	ldd	r24, Y+3	; 0x03
    1b16:	9c 81       	ldd	r25, Y+4	; 0x04
    1b18:	61 e0       	ldi	r22, 0x01	; 1
    1b1a:	0e 94 b8 0c 	call	0x1970	; 0x1970 <xQueueGenericReset>
					pxNewQueue->ucQueueType = ucQueueType;
				}
				#endif /* configUSE_TRACE_FACILITY */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    1b1e:	8b 81       	ldd	r24, Y+3	; 0x03
    1b20:	9c 81       	ldd	r25, Y+4	; 0x04
    1b22:	9a 83       	std	Y+2, r25	; 0x02
    1b24:	89 83       	std	Y+1, r24	; 0x01
    1b26:	04 c0       	rjmp	.+8      	; 0x1b30 <xQueueGenericCreate+0xac>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    1b28:	8b 81       	ldd	r24, Y+3	; 0x03
    1b2a:	9c 81       	ldd	r25, Y+4	; 0x04
    1b2c:	0e 94 12 17 	call	0x2e24	; 0x2e24 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    1b30:	89 81       	ldd	r24, Y+1	; 0x01
    1b32:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1b34:	29 96       	adiw	r28, 0x09	; 9
    1b36:	0f b6       	in	r0, 0x3f	; 63
    1b38:	f8 94       	cli
    1b3a:	de bf       	out	0x3e, r29	; 62
    1b3c:	0f be       	out	0x3f, r0	; 63
    1b3e:	cd bf       	out	0x3d, r28	; 61
    1b40:	df 91       	pop	r29
    1b42:	cf 91       	pop	r28
    1b44:	08 95       	ret

00001b46 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
	{
    1b46:	cf 93       	push	r28
    1b48:	df 93       	push	r29
    1b4a:	00 d0       	rcall	.+0      	; 0x1b4c <xQueueCreateMutex+0x6>
    1b4c:	cd b7       	in	r28, 0x3d	; 61
    1b4e:	de b7       	in	r29, 0x3e	; 62
    1b50:	8b 83       	std	Y+3, r24	; 0x03
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    1b52:	8f e1       	ldi	r24, 0x1F	; 31
    1b54:	90 e0       	ldi	r25, 0x00	; 0
    1b56:	0e 94 cc 16 	call	0x2d98	; 0x2d98 <pvPortMalloc>
    1b5a:	9a 83       	std	Y+2, r25	; 0x02
    1b5c:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    1b5e:	89 81       	ldd	r24, Y+1	; 0x01
    1b60:	9a 81       	ldd	r25, Y+2	; 0x02
    1b62:	00 97       	sbiw	r24, 0x00	; 0
    1b64:	f1 f1       	breq	.+124    	; 0x1be2 <xQueueCreateMutex+0x9c>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    1b66:	89 81       	ldd	r24, Y+1	; 0x01
    1b68:	9a 81       	ldd	r25, Y+2	; 0x02
    1b6a:	fc 01       	movw	r30, r24
    1b6c:	13 82       	std	Z+3, r1	; 0x03
    1b6e:	12 82       	std	Z+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    1b70:	89 81       	ldd	r24, Y+1	; 0x01
    1b72:	9a 81       	ldd	r25, Y+2	; 0x02
    1b74:	fc 01       	movw	r30, r24
    1b76:	11 82       	std	Z+1, r1	; 0x01
    1b78:	10 82       	st	Z, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    1b7a:	89 81       	ldd	r24, Y+1	; 0x01
    1b7c:	9a 81       	ldd	r25, Y+2	; 0x02
    1b7e:	fc 01       	movw	r30, r24
    1b80:	15 82       	std	Z+5, r1	; 0x05
    1b82:	14 82       	std	Z+4, r1	; 0x04
			pxNewQueue->pcReadFrom = NULL;
    1b84:	89 81       	ldd	r24, Y+1	; 0x01
    1b86:	9a 81       	ldd	r25, Y+2	; 0x02
    1b88:	fc 01       	movw	r30, r24
    1b8a:	17 82       	std	Z+7, r1	; 0x07
    1b8c:	16 82       	std	Z+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1b8e:	89 81       	ldd	r24, Y+1	; 0x01
    1b90:	9a 81       	ldd	r25, Y+2	; 0x02
    1b92:	fc 01       	movw	r30, r24
    1b94:	12 8e       	std	Z+26, r1	; 0x1a
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
    1b96:	89 81       	ldd	r24, Y+1	; 0x01
    1b98:	9a 81       	ldd	r25, Y+2	; 0x02
    1b9a:	21 e0       	ldi	r18, 0x01	; 1
    1b9c:	fc 01       	movw	r30, r24
    1b9e:	23 8f       	std	Z+27, r18	; 0x1b
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
    1ba0:	89 81       	ldd	r24, Y+1	; 0x01
    1ba2:	9a 81       	ldd	r25, Y+2	; 0x02
    1ba4:	fc 01       	movw	r30, r24
    1ba6:	14 8e       	std	Z+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    1ba8:	89 81       	ldd	r24, Y+1	; 0x01
    1baa:	9a 81       	ldd	r25, Y+2	; 0x02
    1bac:	2f ef       	ldi	r18, 0xFF	; 255
    1bae:	fc 01       	movw	r30, r24
    1bb0:	25 8f       	std	Z+29, r18	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    1bb2:	89 81       	ldd	r24, Y+1	; 0x01
    1bb4:	9a 81       	ldd	r25, Y+2	; 0x02
    1bb6:	2f ef       	ldi	r18, 0xFF	; 255
    1bb8:	fc 01       	movw	r30, r24
    1bba:	26 8f       	std	Z+30, r18	; 0x1e
				pxNewQueue->ucQueueType = ucQueueType;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1bbc:	89 81       	ldd	r24, Y+1	; 0x01
    1bbe:	9a 81       	ldd	r25, Y+2	; 0x02
    1bc0:	08 96       	adiw	r24, 0x08	; 8
    1bc2:	0e 94 65 12 	call	0x24ca	; 0x24ca <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1bc6:	89 81       	ldd	r24, Y+1	; 0x01
    1bc8:	9a 81       	ldd	r25, Y+2	; 0x02
    1bca:	41 96       	adiw	r24, 0x11	; 17
    1bcc:	0e 94 65 12 	call	0x24ca	; 0x24ca <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
    1bd0:	89 81       	ldd	r24, Y+1	; 0x01
    1bd2:	9a 81       	ldd	r25, Y+2	; 0x02
    1bd4:	20 e0       	ldi	r18, 0x00	; 0
    1bd6:	40 e0       	ldi	r20, 0x00	; 0
    1bd8:	50 e0       	ldi	r21, 0x00	; 0
    1bda:	60 e0       	ldi	r22, 0x00	; 0
    1bdc:	70 e0       	ldi	r23, 0x00	; 0
    1bde:	0e 94 f9 0d 	call	0x1bf2	; 0x1bf2 <xQueueGenericSend>
		{
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
    1be2:	89 81       	ldd	r24, Y+1	; 0x01
    1be4:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    1be6:	0f 90       	pop	r0
    1be8:	0f 90       	pop	r0
    1bea:	0f 90       	pop	r0
    1bec:	df 91       	pop	r29
    1bee:	cf 91       	pop	r28
    1bf0:	08 95       	ret

00001bf2 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    1bf2:	cf 93       	push	r28
    1bf4:	df 93       	push	r29
    1bf6:	cd b7       	in	r28, 0x3d	; 61
    1bf8:	de b7       	in	r29, 0x3e	; 62
    1bfa:	2b 97       	sbiw	r28, 0x0b	; 11
    1bfc:	0f b6       	in	r0, 0x3f	; 63
    1bfe:	f8 94       	cli
    1c00:	de bf       	out	0x3e, r29	; 62
    1c02:	0f be       	out	0x3f, r0	; 63
    1c04:	cd bf       	out	0x3d, r28	; 61
    1c06:	9e 83       	std	Y+6, r25	; 0x06
    1c08:	8d 83       	std	Y+5, r24	; 0x05
    1c0a:	78 87       	std	Y+8, r23	; 0x08
    1c0c:	6f 83       	std	Y+7, r22	; 0x07
    1c0e:	5a 87       	std	Y+10, r21	; 0x0a
    1c10:	49 87       	std	Y+9, r20	; 0x09
    1c12:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1c14:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1c16:	0f b6       	in	r0, 0x3f	; 63
    1c18:	f8 94       	cli
    1c1a:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1c1c:	8d 81       	ldd	r24, Y+5	; 0x05
    1c1e:	9e 81       	ldd	r25, Y+6	; 0x06
    1c20:	fc 01       	movw	r30, r24
    1c22:	22 8d       	ldd	r18, Z+26	; 0x1a
    1c24:	8d 81       	ldd	r24, Y+5	; 0x05
    1c26:	9e 81       	ldd	r25, Y+6	; 0x06
    1c28:	fc 01       	movw	r30, r24
    1c2a:	83 8d       	ldd	r24, Z+27	; 0x1b
    1c2c:	28 17       	cp	r18, r24
    1c2e:	d8 f4       	brcc	.+54     	; 0x1c66 <xQueueGenericSend+0x74>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1c30:	2f 81       	ldd	r18, Y+7	; 0x07
    1c32:	38 85       	ldd	r19, Y+8	; 0x08
    1c34:	8d 81       	ldd	r24, Y+5	; 0x05
    1c36:	9e 81       	ldd	r25, Y+6	; 0x06
    1c38:	4b 85       	ldd	r20, Y+11	; 0x0b
    1c3a:	b9 01       	movw	r22, r18
    1c3c:	0e 94 83 10 	call	0x2106	; 0x2106 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1c40:	8d 81       	ldd	r24, Y+5	; 0x05
    1c42:	9e 81       	ldd	r25, Y+6	; 0x06
    1c44:	fc 01       	movw	r30, r24
    1c46:	81 89       	ldd	r24, Z+17	; 0x11
    1c48:	88 23       	and	r24, r24
    1c4a:	49 f0       	breq	.+18     	; 0x1c5e <xQueueGenericSend+0x6c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1c4c:	8d 81       	ldd	r24, Y+5	; 0x05
    1c4e:	9e 81       	ldd	r25, Y+6	; 0x06
    1c50:	41 96       	adiw	r24, 0x11	; 17
    1c52:	0e 94 12 09 	call	0x1224	; 0x1224 <xTaskRemoveFromEventList>
    1c56:	81 30       	cpi	r24, 0x01	; 1
    1c58:	11 f4       	brne	.+4      	; 0x1c5e <xQueueGenericSend+0x6c>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    1c5a:	0e 94 3f 19 	call	0x327e	; 0x327e <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    1c5e:	0f 90       	pop	r0
    1c60:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    1c62:	81 e0       	ldi	r24, 0x01	; 1
    1c64:	61 c0       	rjmp	.+194    	; 0x1d28 <xQueueGenericSend+0x136>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1c66:	89 85       	ldd	r24, Y+9	; 0x09
    1c68:	9a 85       	ldd	r25, Y+10	; 0x0a
    1c6a:	00 97       	sbiw	r24, 0x00	; 0
    1c6c:	21 f4       	brne	.+8      	; 0x1c76 <xQueueGenericSend+0x84>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1c6e:	0f 90       	pop	r0
    1c70:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1c72:	80 e0       	ldi	r24, 0x00	; 0
    1c74:	59 c0       	rjmp	.+178    	; 0x1d28 <xQueueGenericSend+0x136>
				}
				else if( xEntryTimeSet == pdFALSE )
    1c76:	89 81       	ldd	r24, Y+1	; 0x01
    1c78:	88 23       	and	r24, r24
    1c7a:	31 f4       	brne	.+12     	; 0x1c88 <xQueueGenericSend+0x96>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1c7c:	ce 01       	movw	r24, r28
    1c7e:	02 96       	adiw	r24, 0x02	; 2
    1c80:	0e 94 7c 09 	call	0x12f8	; 0x12f8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1c84:	81 e0       	ldi	r24, 0x01	; 1
    1c86:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    1c88:	0f 90       	pop	r0
    1c8a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1c8c:	0e 94 9e 06 	call	0xd3c	; 0xd3c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1c90:	0f b6       	in	r0, 0x3f	; 63
    1c92:	f8 94       	cli
    1c94:	0f 92       	push	r0
    1c96:	8d 81       	ldd	r24, Y+5	; 0x05
    1c98:	9e 81       	ldd	r25, Y+6	; 0x06
    1c9a:	fc 01       	movw	r30, r24
    1c9c:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c9e:	8f 3f       	cpi	r24, 0xFF	; 255
    1ca0:	21 f4       	brne	.+8      	; 0x1caa <xQueueGenericSend+0xb8>
    1ca2:	8d 81       	ldd	r24, Y+5	; 0x05
    1ca4:	9e 81       	ldd	r25, Y+6	; 0x06
    1ca6:	fc 01       	movw	r30, r24
    1ca8:	15 8e       	std	Z+29, r1	; 0x1d
    1caa:	8d 81       	ldd	r24, Y+5	; 0x05
    1cac:	9e 81       	ldd	r25, Y+6	; 0x06
    1cae:	fc 01       	movw	r30, r24
    1cb0:	86 8d       	ldd	r24, Z+30	; 0x1e
    1cb2:	8f 3f       	cpi	r24, 0xFF	; 255
    1cb4:	21 f4       	brne	.+8      	; 0x1cbe <xQueueGenericSend+0xcc>
    1cb6:	8d 81       	ldd	r24, Y+5	; 0x05
    1cb8:	9e 81       	ldd	r25, Y+6	; 0x06
    1cba:	fc 01       	movw	r30, r24
    1cbc:	16 8e       	std	Z+30, r1	; 0x1e
    1cbe:	0f 90       	pop	r0
    1cc0:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1cc2:	9e 01       	movw	r18, r28
    1cc4:	27 5f       	subi	r18, 0xF7	; 247
    1cc6:	3f 4f       	sbci	r19, 0xFF	; 255
    1cc8:	ce 01       	movw	r24, r28
    1cca:	02 96       	adiw	r24, 0x02	; 2
    1ccc:	b9 01       	movw	r22, r18
    1cce:	0e 94 98 09 	call	0x1330	; 0x1330 <xTaskCheckForTimeOut>
    1cd2:	88 23       	and	r24, r24
    1cd4:	01 f5       	brne	.+64     	; 0x1d16 <xQueueGenericSend+0x124>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1cd6:	8d 81       	ldd	r24, Y+5	; 0x05
    1cd8:	9e 81       	ldd	r25, Y+6	; 0x06
    1cda:	0e 94 2a 12 	call	0x2454	; 0x2454 <prvIsQueueFull>
    1cde:	88 23       	and	r24, r24
    1ce0:	99 f0       	breq	.+38     	; 0x1d08 <xQueueGenericSend+0x116>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1ce2:	29 85       	ldd	r18, Y+9	; 0x09
    1ce4:	3a 85       	ldd	r19, Y+10	; 0x0a
    1ce6:	8d 81       	ldd	r24, Y+5	; 0x05
    1ce8:	9e 81       	ldd	r25, Y+6	; 0x06
    1cea:	08 96       	adiw	r24, 0x08	; 8
    1cec:	b9 01       	movw	r22, r18
    1cee:	0e 94 cd 08 	call	0x119a	; 0x119a <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1cf2:	8d 81       	ldd	r24, Y+5	; 0x05
    1cf4:	9e 81       	ldd	r25, Y+6	; 0x06
    1cf6:	0e 94 92 11 	call	0x2324	; 0x2324 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1cfa:	0e 94 aa 06 	call	0xd54	; 0xd54 <xTaskResumeAll>
    1cfe:	88 23       	and	r24, r24
    1d00:	91 f4       	brne	.+36     	; 0x1d26 <xQueueGenericSend+0x134>
				{
					portYIELD_WITHIN_API();
    1d02:	0e 94 3f 19 	call	0x327e	; 0x327e <vPortYield>
    1d06:	0f c0       	rjmp	.+30     	; 0x1d26 <xQueueGenericSend+0x134>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1d08:	8d 81       	ldd	r24, Y+5	; 0x05
    1d0a:	9e 81       	ldd	r25, Y+6	; 0x06
    1d0c:	0e 94 92 11 	call	0x2324	; 0x2324 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1d10:	0e 94 aa 06 	call	0xd54	; 0xd54 <xTaskResumeAll>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
    1d14:	80 cf       	rjmp	.-256    	; 0x1c16 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1d16:	8d 81       	ldd	r24, Y+5	; 0x05
    1d18:	9e 81       	ldd	r25, Y+6	; 0x06
    1d1a:	0e 94 92 11 	call	0x2324	; 0x2324 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1d1e:	0e 94 aa 06 	call	0xd54	; 0xd54 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1d22:	80 e0       	ldi	r24, 0x00	; 0
    1d24:	01 c0       	rjmp	.+2      	; 0x1d28 <xQueueGenericSend+0x136>
		}
	}
    1d26:	77 cf       	rjmp	.-274    	; 0x1c16 <xQueueGenericSend+0x24>
}
    1d28:	2b 96       	adiw	r28, 0x0b	; 11
    1d2a:	0f b6       	in	r0, 0x3f	; 63
    1d2c:	f8 94       	cli
    1d2e:	de bf       	out	0x3e, r29	; 62
    1d30:	0f be       	out	0x3f, r0	; 63
    1d32:	cd bf       	out	0x3d, r28	; 61
    1d34:	df 91       	pop	r29
    1d36:	cf 91       	pop	r28
    1d38:	08 95       	ret

00001d3a <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1d3a:	cf 93       	push	r28
    1d3c:	df 93       	push	r29
    1d3e:	cd b7       	in	r28, 0x3d	; 61
    1d40:	de b7       	in	r29, 0x3e	; 62
    1d42:	29 97       	sbiw	r28, 0x09	; 9
    1d44:	0f b6       	in	r0, 0x3f	; 63
    1d46:	f8 94       	cli
    1d48:	de bf       	out	0x3e, r29	; 62
    1d4a:	0f be       	out	0x3f, r0	; 63
    1d4c:	cd bf       	out	0x3d, r28	; 61
    1d4e:	9c 83       	std	Y+4, r25	; 0x04
    1d50:	8b 83       	std	Y+3, r24	; 0x03
    1d52:	7e 83       	std	Y+6, r23	; 0x06
    1d54:	6d 83       	std	Y+5, r22	; 0x05
    1d56:	58 87       	std	Y+8, r21	; 0x08
    1d58:	4f 83       	std	Y+7, r20	; 0x07
    1d5a:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1d5c:	1a 82       	std	Y+2, r1	; 0x02
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1d5e:	8b 81       	ldd	r24, Y+3	; 0x03
    1d60:	9c 81       	ldd	r25, Y+4	; 0x04
    1d62:	fc 01       	movw	r30, r24
    1d64:	22 8d       	ldd	r18, Z+26	; 0x1a
    1d66:	8b 81       	ldd	r24, Y+3	; 0x03
    1d68:	9c 81       	ldd	r25, Y+4	; 0x04
    1d6a:	fc 01       	movw	r30, r24
    1d6c:	83 8d       	ldd	r24, Z+27	; 0x1b
    1d6e:	28 17       	cp	r18, r24
    1d70:	90 f5       	brcc	.+100    	; 0x1dd6 <xQueueGenericSendFromISR+0x9c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1d72:	2d 81       	ldd	r18, Y+5	; 0x05
    1d74:	3e 81       	ldd	r19, Y+6	; 0x06
    1d76:	8b 81       	ldd	r24, Y+3	; 0x03
    1d78:	9c 81       	ldd	r25, Y+4	; 0x04
    1d7a:	49 85       	ldd	r20, Y+9	; 0x09
    1d7c:	b9 01       	movw	r22, r18
    1d7e:	0e 94 83 10 	call	0x2106	; 0x2106 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1d82:	8b 81       	ldd	r24, Y+3	; 0x03
    1d84:	9c 81       	ldd	r25, Y+4	; 0x04
    1d86:	fc 01       	movw	r30, r24
    1d88:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d8a:	8f 3f       	cpi	r24, 0xFF	; 255
    1d8c:	b9 f4       	brne	.+46     	; 0x1dbc <xQueueGenericSendFromISR+0x82>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1d8e:	8b 81       	ldd	r24, Y+3	; 0x03
    1d90:	9c 81       	ldd	r25, Y+4	; 0x04
    1d92:	fc 01       	movw	r30, r24
    1d94:	81 89       	ldd	r24, Z+17	; 0x11
    1d96:	88 23       	and	r24, r24
    1d98:	d9 f0       	breq	.+54     	; 0x1dd0 <xQueueGenericSendFromISR+0x96>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1d9a:	8b 81       	ldd	r24, Y+3	; 0x03
    1d9c:	9c 81       	ldd	r25, Y+4	; 0x04
    1d9e:	41 96       	adiw	r24, 0x11	; 17
    1da0:	0e 94 12 09 	call	0x1224	; 0x1224 <xTaskRemoveFromEventList>
    1da4:	88 23       	and	r24, r24
    1da6:	a1 f0       	breq	.+40     	; 0x1dd0 <xQueueGenericSendFromISR+0x96>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						if( pxHigherPriorityTaskWoken != NULL )
    1da8:	8f 81       	ldd	r24, Y+7	; 0x07
    1daa:	98 85       	ldd	r25, Y+8	; 0x08
    1dac:	00 97       	sbiw	r24, 0x00	; 0
    1dae:	81 f0       	breq	.+32     	; 0x1dd0 <xQueueGenericSendFromISR+0x96>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1db0:	8f 81       	ldd	r24, Y+7	; 0x07
    1db2:	98 85       	ldd	r25, Y+8	; 0x08
    1db4:	21 e0       	ldi	r18, 0x01	; 1
    1db6:	fc 01       	movw	r30, r24
    1db8:	20 83       	st	Z, r18
    1dba:	0a c0       	rjmp	.+20     	; 0x1dd0 <xQueueGenericSendFromISR+0x96>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1dbc:	8b 81       	ldd	r24, Y+3	; 0x03
    1dbe:	9c 81       	ldd	r25, Y+4	; 0x04
    1dc0:	fc 01       	movw	r30, r24
    1dc2:	86 8d       	ldd	r24, Z+30	; 0x1e
    1dc4:	21 e0       	ldi	r18, 0x01	; 1
    1dc6:	28 0f       	add	r18, r24
    1dc8:	8b 81       	ldd	r24, Y+3	; 0x03
    1dca:	9c 81       	ldd	r25, Y+4	; 0x04
    1dcc:	fc 01       	movw	r30, r24
    1dce:	26 8f       	std	Z+30, r18	; 0x1e
			}

			xReturn = pdPASS;
    1dd0:	81 e0       	ldi	r24, 0x01	; 1
    1dd2:	89 83       	std	Y+1, r24	; 0x01
    1dd4:	01 c0       	rjmp	.+2      	; 0x1dd8 <xQueueGenericSendFromISR+0x9e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1dd6:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1dd8:	89 81       	ldd	r24, Y+1	; 0x01
}
    1dda:	29 96       	adiw	r28, 0x09	; 9
    1ddc:	0f b6       	in	r0, 0x3f	; 63
    1dde:	f8 94       	cli
    1de0:	de bf       	out	0x3e, r29	; 62
    1de2:	0f be       	out	0x3f, r0	; 63
    1de4:	cd bf       	out	0x3d, r28	; 61
    1de6:	df 91       	pop	r29
    1de8:	cf 91       	pop	r28
    1dea:	08 95       	ret

00001dec <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1dec:	cf 93       	push	r28
    1dee:	df 93       	push	r29
    1df0:	cd b7       	in	r28, 0x3d	; 61
    1df2:	de b7       	in	r29, 0x3e	; 62
    1df4:	2d 97       	sbiw	r28, 0x0d	; 13
    1df6:	0f b6       	in	r0, 0x3f	; 63
    1df8:	f8 94       	cli
    1dfa:	de bf       	out	0x3e, r29	; 62
    1dfc:	0f be       	out	0x3f, r0	; 63
    1dfe:	cd bf       	out	0x3d, r28	; 61
    1e00:	98 87       	std	Y+8, r25	; 0x08
    1e02:	8f 83       	std	Y+7, r24	; 0x07
    1e04:	7a 87       	std	Y+10, r23	; 0x0a
    1e06:	69 87       	std	Y+9, r22	; 0x09
    1e08:	5c 87       	std	Y+12, r21	; 0x0c
    1e0a:	4b 87       	std	Y+11, r20	; 0x0b
    1e0c:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1e0e:	19 82       	std	Y+1, r1	; 0x01
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1e10:	0f b6       	in	r0, 0x3f	; 63
    1e12:	f8 94       	cli
    1e14:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1e16:	8f 81       	ldd	r24, Y+7	; 0x07
    1e18:	98 85       	ldd	r25, Y+8	; 0x08
    1e1a:	fc 01       	movw	r30, r24
    1e1c:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e1e:	88 23       	and	r24, r24
    1e20:	09 f4       	brne	.+2      	; 0x1e24 <xQueueGenericReceive+0x38>
    1e22:	54 c0       	rjmp	.+168    	; 0x1ecc <xQueueGenericReceive+0xe0>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1e24:	8f 81       	ldd	r24, Y+7	; 0x07
    1e26:	98 85       	ldd	r25, Y+8	; 0x08
    1e28:	fc 01       	movw	r30, r24
    1e2a:	86 81       	ldd	r24, Z+6	; 0x06
    1e2c:	97 81       	ldd	r25, Z+7	; 0x07
    1e2e:	9b 83       	std	Y+3, r25	; 0x03
    1e30:	8a 83       	std	Y+2, r24	; 0x02

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1e32:	29 85       	ldd	r18, Y+9	; 0x09
    1e34:	3a 85       	ldd	r19, Y+10	; 0x0a
    1e36:	8f 81       	ldd	r24, Y+7	; 0x07
    1e38:	98 85       	ldd	r25, Y+8	; 0x08
    1e3a:	b9 01       	movw	r22, r18
    1e3c:	0e 94 41 11 	call	0x2282	; 0x2282 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1e40:	8d 85       	ldd	r24, Y+13	; 0x0d
    1e42:	88 23       	and	r24, r24
    1e44:	49 f5       	brne	.+82     	; 0x1e98 <xQueueGenericReceive+0xac>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1e46:	8f 81       	ldd	r24, Y+7	; 0x07
    1e48:	98 85       	ldd	r25, Y+8	; 0x08
    1e4a:	fc 01       	movw	r30, r24
    1e4c:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e4e:	2f ef       	ldi	r18, 0xFF	; 255
    1e50:	28 0f       	add	r18, r24
    1e52:	8f 81       	ldd	r24, Y+7	; 0x07
    1e54:	98 85       	ldd	r25, Y+8	; 0x08
    1e56:	fc 01       	movw	r30, r24
    1e58:	22 8f       	std	Z+26, r18	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1e5a:	8f 81       	ldd	r24, Y+7	; 0x07
    1e5c:	98 85       	ldd	r25, Y+8	; 0x08
    1e5e:	fc 01       	movw	r30, r24
    1e60:	80 81       	ld	r24, Z
    1e62:	91 81       	ldd	r25, Z+1	; 0x01
    1e64:	00 97       	sbiw	r24, 0x00	; 0
    1e66:	41 f4       	brne	.+16     	; 0x1e78 <xQueueGenericReceive+0x8c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    1e68:	0e 94 af 0b 	call	0x175e	; 0x175e <xTaskGetCurrentTaskHandle>
    1e6c:	9c 01       	movw	r18, r24
    1e6e:	8f 81       	ldd	r24, Y+7	; 0x07
    1e70:	98 85       	ldd	r25, Y+8	; 0x08
    1e72:	fc 01       	movw	r30, r24
    1e74:	33 83       	std	Z+3, r19	; 0x03
    1e76:	22 83       	std	Z+2, r18	; 0x02
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1e78:	8f 81       	ldd	r24, Y+7	; 0x07
    1e7a:	98 85       	ldd	r25, Y+8	; 0x08
    1e7c:	fc 01       	movw	r30, r24
    1e7e:	80 85       	ldd	r24, Z+8	; 0x08
    1e80:	88 23       	and	r24, r24
    1e82:	01 f1       	breq	.+64     	; 0x1ec4 <xQueueGenericReceive+0xd8>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1e84:	8f 81       	ldd	r24, Y+7	; 0x07
    1e86:	98 85       	ldd	r25, Y+8	; 0x08
    1e88:	08 96       	adiw	r24, 0x08	; 8
    1e8a:	0e 94 12 09 	call	0x1224	; 0x1224 <xTaskRemoveFromEventList>
    1e8e:	81 30       	cpi	r24, 0x01	; 1
    1e90:	c9 f4       	brne	.+50     	; 0x1ec4 <xQueueGenericReceive+0xd8>
						{
							portYIELD_WITHIN_API();
    1e92:	0e 94 3f 19 	call	0x327e	; 0x327e <vPortYield>
    1e96:	16 c0       	rjmp	.+44     	; 0x1ec4 <xQueueGenericReceive+0xd8>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1e98:	8f 81       	ldd	r24, Y+7	; 0x07
    1e9a:	98 85       	ldd	r25, Y+8	; 0x08
    1e9c:	2a 81       	ldd	r18, Y+2	; 0x02
    1e9e:	3b 81       	ldd	r19, Y+3	; 0x03
    1ea0:	fc 01       	movw	r30, r24
    1ea2:	37 83       	std	Z+7, r19	; 0x07
    1ea4:	26 83       	std	Z+6, r18	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1ea6:	8f 81       	ldd	r24, Y+7	; 0x07
    1ea8:	98 85       	ldd	r25, Y+8	; 0x08
    1eaa:	fc 01       	movw	r30, r24
    1eac:	81 89       	ldd	r24, Z+17	; 0x11
    1eae:	88 23       	and	r24, r24
    1eb0:	49 f0       	breq	.+18     	; 0x1ec4 <xQueueGenericReceive+0xd8>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1eb2:	8f 81       	ldd	r24, Y+7	; 0x07
    1eb4:	98 85       	ldd	r25, Y+8	; 0x08
    1eb6:	41 96       	adiw	r24, 0x11	; 17
    1eb8:	0e 94 12 09 	call	0x1224	; 0x1224 <xTaskRemoveFromEventList>
    1ebc:	88 23       	and	r24, r24
    1ebe:	11 f0       	breq	.+4      	; 0x1ec4 <xQueueGenericReceive+0xd8>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1ec0:	0e 94 3f 19 	call	0x327e	; 0x327e <vPortYield>
						}
					}
				}

				taskEXIT_CRITICAL();
    1ec4:	0f 90       	pop	r0
    1ec6:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1ec8:	81 e0       	ldi	r24, 0x01	; 1
    1eca:	74 c0       	rjmp	.+232    	; 0x1fb4 <xQueueGenericReceive+0x1c8>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1ecc:	8b 85       	ldd	r24, Y+11	; 0x0b
    1ece:	9c 85       	ldd	r25, Y+12	; 0x0c
    1ed0:	00 97       	sbiw	r24, 0x00	; 0
    1ed2:	21 f4       	brne	.+8      	; 0x1edc <xQueueGenericReceive+0xf0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1ed4:	0f 90       	pop	r0
    1ed6:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1ed8:	80 e0       	ldi	r24, 0x00	; 0
    1eda:	6c c0       	rjmp	.+216    	; 0x1fb4 <xQueueGenericReceive+0x1c8>
				}
				else if( xEntryTimeSet == pdFALSE )
    1edc:	89 81       	ldd	r24, Y+1	; 0x01
    1ede:	88 23       	and	r24, r24
    1ee0:	31 f4       	brne	.+12     	; 0x1eee <xQueueGenericReceive+0x102>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1ee2:	ce 01       	movw	r24, r28
    1ee4:	04 96       	adiw	r24, 0x04	; 4
    1ee6:	0e 94 7c 09 	call	0x12f8	; 0x12f8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1eea:	81 e0       	ldi	r24, 0x01	; 1
    1eec:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    1eee:	0f 90       	pop	r0
    1ef0:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1ef2:	0e 94 9e 06 	call	0xd3c	; 0xd3c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1ef6:	0f b6       	in	r0, 0x3f	; 63
    1ef8:	f8 94       	cli
    1efa:	0f 92       	push	r0
    1efc:	8f 81       	ldd	r24, Y+7	; 0x07
    1efe:	98 85       	ldd	r25, Y+8	; 0x08
    1f00:	fc 01       	movw	r30, r24
    1f02:	85 8d       	ldd	r24, Z+29	; 0x1d
    1f04:	8f 3f       	cpi	r24, 0xFF	; 255
    1f06:	21 f4       	brne	.+8      	; 0x1f10 <xQueueGenericReceive+0x124>
    1f08:	8f 81       	ldd	r24, Y+7	; 0x07
    1f0a:	98 85       	ldd	r25, Y+8	; 0x08
    1f0c:	fc 01       	movw	r30, r24
    1f0e:	15 8e       	std	Z+29, r1	; 0x1d
    1f10:	8f 81       	ldd	r24, Y+7	; 0x07
    1f12:	98 85       	ldd	r25, Y+8	; 0x08
    1f14:	fc 01       	movw	r30, r24
    1f16:	86 8d       	ldd	r24, Z+30	; 0x1e
    1f18:	8f 3f       	cpi	r24, 0xFF	; 255
    1f1a:	21 f4       	brne	.+8      	; 0x1f24 <xQueueGenericReceive+0x138>
    1f1c:	8f 81       	ldd	r24, Y+7	; 0x07
    1f1e:	98 85       	ldd	r25, Y+8	; 0x08
    1f20:	fc 01       	movw	r30, r24
    1f22:	16 8e       	std	Z+30, r1	; 0x1e
    1f24:	0f 90       	pop	r0
    1f26:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1f28:	9e 01       	movw	r18, r28
    1f2a:	25 5f       	subi	r18, 0xF5	; 245
    1f2c:	3f 4f       	sbci	r19, 0xFF	; 255
    1f2e:	ce 01       	movw	r24, r28
    1f30:	04 96       	adiw	r24, 0x04	; 4
    1f32:	b9 01       	movw	r22, r18
    1f34:	0e 94 98 09 	call	0x1330	; 0x1330 <xTaskCheckForTimeOut>
    1f38:	88 23       	and	r24, r24
    1f3a:	99 f5       	brne	.+102    	; 0x1fa2 <xQueueGenericReceive+0x1b6>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1f3c:	8f 81       	ldd	r24, Y+7	; 0x07
    1f3e:	98 85       	ldd	r25, Y+8	; 0x08
    1f40:	0e 94 f7 11 	call	0x23ee	; 0x23ee <prvIsQueueEmpty>
    1f44:	88 23       	and	r24, r24
    1f46:	31 f1       	breq	.+76     	; 0x1f94 <xQueueGenericReceive+0x1a8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1f48:	8f 81       	ldd	r24, Y+7	; 0x07
    1f4a:	98 85       	ldd	r25, Y+8	; 0x08
    1f4c:	fc 01       	movw	r30, r24
    1f4e:	80 81       	ld	r24, Z
    1f50:	91 81       	ldd	r25, Z+1	; 0x01
    1f52:	00 97       	sbiw	r24, 0x00	; 0
    1f54:	61 f4       	brne	.+24     	; 0x1f6e <xQueueGenericReceive+0x182>
					{
						portENTER_CRITICAL();
    1f56:	0f b6       	in	r0, 0x3f	; 63
    1f58:	f8 94       	cli
    1f5a:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1f5c:	8f 81       	ldd	r24, Y+7	; 0x07
    1f5e:	98 85       	ldd	r25, Y+8	; 0x08
    1f60:	fc 01       	movw	r30, r24
    1f62:	82 81       	ldd	r24, Z+2	; 0x02
    1f64:	93 81       	ldd	r25, Z+3	; 0x03
    1f66:	0e 94 c2 0b 	call	0x1784	; 0x1784 <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    1f6a:	0f 90       	pop	r0
    1f6c:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1f6e:	2b 85       	ldd	r18, Y+11	; 0x0b
    1f70:	3c 85       	ldd	r19, Y+12	; 0x0c
    1f72:	8f 81       	ldd	r24, Y+7	; 0x07
    1f74:	98 85       	ldd	r25, Y+8	; 0x08
    1f76:	41 96       	adiw	r24, 0x11	; 17
    1f78:	b9 01       	movw	r22, r18
    1f7a:	0e 94 cd 08 	call	0x119a	; 0x119a <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1f7e:	8f 81       	ldd	r24, Y+7	; 0x07
    1f80:	98 85       	ldd	r25, Y+8	; 0x08
    1f82:	0e 94 92 11 	call	0x2324	; 0x2324 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1f86:	0e 94 aa 06 	call	0xd54	; 0xd54 <xTaskResumeAll>
    1f8a:	88 23       	and	r24, r24
    1f8c:	91 f4       	brne	.+36     	; 0x1fb2 <xQueueGenericReceive+0x1c6>
				{
					portYIELD_WITHIN_API();
    1f8e:	0e 94 3f 19 	call	0x327e	; 0x327e <vPortYield>
    1f92:	0f c0       	rjmp	.+30     	; 0x1fb2 <xQueueGenericReceive+0x1c6>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1f94:	8f 81       	ldd	r24, Y+7	; 0x07
    1f96:	98 85       	ldd	r25, Y+8	; 0x08
    1f98:	0e 94 92 11 	call	0x2324	; 0x2324 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1f9c:	0e 94 aa 06 	call	0xd54	; 0xd54 <xTaskResumeAll>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
    1fa0:	37 cf       	rjmp	.-402    	; 0x1e10 <xQueueGenericReceive+0x24>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1fa2:	8f 81       	ldd	r24, Y+7	; 0x07
    1fa4:	98 85       	ldd	r25, Y+8	; 0x08
    1fa6:	0e 94 92 11 	call	0x2324	; 0x2324 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1faa:	0e 94 aa 06 	call	0xd54	; 0xd54 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1fae:	80 e0       	ldi	r24, 0x00	; 0
    1fb0:	01 c0       	rjmp	.+2      	; 0x1fb4 <xQueueGenericReceive+0x1c8>
		}
	}
    1fb2:	2e cf       	rjmp	.-420    	; 0x1e10 <xQueueGenericReceive+0x24>
}
    1fb4:	2d 96       	adiw	r28, 0x0d	; 13
    1fb6:	0f b6       	in	r0, 0x3f	; 63
    1fb8:	f8 94       	cli
    1fba:	de bf       	out	0x3e, r29	; 62
    1fbc:	0f be       	out	0x3f, r0	; 63
    1fbe:	cd bf       	out	0x3d, r28	; 61
    1fc0:	df 91       	pop	r29
    1fc2:	cf 91       	pop	r28
    1fc4:	08 95       	ret

00001fc6 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
{
    1fc6:	cf 93       	push	r28
    1fc8:	df 93       	push	r29
    1fca:	cd b7       	in	r28, 0x3d	; 61
    1fcc:	de b7       	in	r29, 0x3e	; 62
    1fce:	28 97       	sbiw	r28, 0x08	; 8
    1fd0:	0f b6       	in	r0, 0x3f	; 63
    1fd2:	f8 94       	cli
    1fd4:	de bf       	out	0x3e, r29	; 62
    1fd6:	0f be       	out	0x3f, r0	; 63
    1fd8:	cd bf       	out	0x3d, r28	; 61
    1fda:	9c 83       	std	Y+4, r25	; 0x04
    1fdc:	8b 83       	std	Y+3, r24	; 0x03
    1fde:	7e 83       	std	Y+6, r23	; 0x06
    1fe0:	6d 83       	std	Y+5, r22	; 0x05
    1fe2:	58 87       	std	Y+8, r21	; 0x08
    1fe4:	4f 83       	std	Y+7, r20	; 0x07
unsigned portBASE_TYPE uxSavedInterruptStatus;

	configASSERT( pxQueue );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1fe6:	1a 82       	std	Y+2, r1	; 0x02
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1fe8:	8b 81       	ldd	r24, Y+3	; 0x03
    1fea:	9c 81       	ldd	r25, Y+4	; 0x04
    1fec:	fc 01       	movw	r30, r24
    1fee:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ff0:	88 23       	and	r24, r24
    1ff2:	d9 f1       	breq	.+118    	; 0x206a <xQueueReceiveFromISR+0xa4>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1ff4:	2d 81       	ldd	r18, Y+5	; 0x05
    1ff6:	3e 81       	ldd	r19, Y+6	; 0x06
    1ff8:	8b 81       	ldd	r24, Y+3	; 0x03
    1ffa:	9c 81       	ldd	r25, Y+4	; 0x04
    1ffc:	b9 01       	movw	r22, r18
    1ffe:	0e 94 41 11 	call	0x2282	; 0x2282 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    2002:	8b 81       	ldd	r24, Y+3	; 0x03
    2004:	9c 81       	ldd	r25, Y+4	; 0x04
    2006:	fc 01       	movw	r30, r24
    2008:	82 8d       	ldd	r24, Z+26	; 0x1a
    200a:	2f ef       	ldi	r18, 0xFF	; 255
    200c:	28 0f       	add	r18, r24
    200e:	8b 81       	ldd	r24, Y+3	; 0x03
    2010:	9c 81       	ldd	r25, Y+4	; 0x04
    2012:	fc 01       	movw	r30, r24
    2014:	22 8f       	std	Z+26, r18	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    2016:	8b 81       	ldd	r24, Y+3	; 0x03
    2018:	9c 81       	ldd	r25, Y+4	; 0x04
    201a:	fc 01       	movw	r30, r24
    201c:	85 8d       	ldd	r24, Z+29	; 0x1d
    201e:	8f 3f       	cpi	r24, 0xFF	; 255
    2020:	b9 f4       	brne	.+46     	; 0x2050 <xQueueReceiveFromISR+0x8a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2022:	8b 81       	ldd	r24, Y+3	; 0x03
    2024:	9c 81       	ldd	r25, Y+4	; 0x04
    2026:	fc 01       	movw	r30, r24
    2028:	80 85       	ldd	r24, Z+8	; 0x08
    202a:	88 23       	and	r24, r24
    202c:	d9 f0       	breq	.+54     	; 0x2064 <xQueueReceiveFromISR+0x9e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    202e:	8b 81       	ldd	r24, Y+3	; 0x03
    2030:	9c 81       	ldd	r25, Y+4	; 0x04
    2032:	08 96       	adiw	r24, 0x08	; 8
    2034:	0e 94 12 09 	call	0x1224	; 0x1224 <xTaskRemoveFromEventList>
    2038:	88 23       	and	r24, r24
    203a:	a1 f0       	breq	.+40     	; 0x2064 <xQueueReceiveFromISR+0x9e>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    203c:	8f 81       	ldd	r24, Y+7	; 0x07
    203e:	98 85       	ldd	r25, Y+8	; 0x08
    2040:	00 97       	sbiw	r24, 0x00	; 0
    2042:	81 f0       	breq	.+32     	; 0x2064 <xQueueReceiveFromISR+0x9e>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    2044:	8f 81       	ldd	r24, Y+7	; 0x07
    2046:	98 85       	ldd	r25, Y+8	; 0x08
    2048:	21 e0       	ldi	r18, 0x01	; 1
    204a:	fc 01       	movw	r30, r24
    204c:	20 83       	st	Z, r18
    204e:	0a c0       	rjmp	.+20     	; 0x2064 <xQueueReceiveFromISR+0x9e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    2050:	8b 81       	ldd	r24, Y+3	; 0x03
    2052:	9c 81       	ldd	r25, Y+4	; 0x04
    2054:	fc 01       	movw	r30, r24
    2056:	85 8d       	ldd	r24, Z+29	; 0x1d
    2058:	21 e0       	ldi	r18, 0x01	; 1
    205a:	28 0f       	add	r18, r24
    205c:	8b 81       	ldd	r24, Y+3	; 0x03
    205e:	9c 81       	ldd	r25, Y+4	; 0x04
    2060:	fc 01       	movw	r30, r24
    2062:	25 8f       	std	Z+29, r18	; 0x1d
			}

			xReturn = pdPASS;
    2064:	81 e0       	ldi	r24, 0x01	; 1
    2066:	89 83       	std	Y+1, r24	; 0x01
    2068:	01 c0       	rjmp	.+2      	; 0x206c <xQueueReceiveFromISR+0xa6>
		}
		else
		{
			xReturn = pdFAIL;
    206a:	19 82       	std	Y+1, r1	; 0x01
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    206c:	89 81       	ldd	r24, Y+1	; 0x01
}
    206e:	28 96       	adiw	r28, 0x08	; 8
    2070:	0f b6       	in	r0, 0x3f	; 63
    2072:	f8 94       	cli
    2074:	de bf       	out	0x3e, r29	; 62
    2076:	0f be       	out	0x3f, r0	; 63
    2078:	cd bf       	out	0x3d, r28	; 61
    207a:	df 91       	pop	r29
    207c:	cf 91       	pop	r28
    207e:	08 95       	ret

00002080 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    2080:	cf 93       	push	r28
    2082:	df 93       	push	r29
    2084:	00 d0       	rcall	.+0      	; 0x2086 <uxQueueMessagesWaiting+0x6>
    2086:	cd b7       	in	r28, 0x3d	; 61
    2088:	de b7       	in	r29, 0x3e	; 62
    208a:	9b 83       	std	Y+3, r25	; 0x03
    208c:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    208e:	0f b6       	in	r0, 0x3f	; 63
    2090:	f8 94       	cli
    2092:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    2094:	8a 81       	ldd	r24, Y+2	; 0x02
    2096:	9b 81       	ldd	r25, Y+3	; 0x03
    2098:	fc 01       	movw	r30, r24
    209a:	82 8d       	ldd	r24, Z+26	; 0x1a
    209c:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    209e:	0f 90       	pop	r0
    20a0:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    20a2:	89 81       	ldd	r24, Y+1	; 0x01
}
    20a4:	0f 90       	pop	r0
    20a6:	0f 90       	pop	r0
    20a8:	0f 90       	pop	r0
    20aa:	df 91       	pop	r29
    20ac:	cf 91       	pop	r28
    20ae:	08 95       	ret

000020b0 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    20b0:	cf 93       	push	r28
    20b2:	df 93       	push	r29
    20b4:	00 d0       	rcall	.+0      	; 0x20b6 <uxQueueMessagesWaitingFromISR+0x6>
    20b6:	cd b7       	in	r28, 0x3d	; 61
    20b8:	de b7       	in	r29, 0x3e	; 62
    20ba:	9b 83       	std	Y+3, r25	; 0x03
    20bc:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    20be:	8a 81       	ldd	r24, Y+2	; 0x02
    20c0:	9b 81       	ldd	r25, Y+3	; 0x03
    20c2:	fc 01       	movw	r30, r24
    20c4:	82 8d       	ldd	r24, Z+26	; 0x1a
    20c6:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    20c8:	89 81       	ldd	r24, Y+1	; 0x01
}
    20ca:	0f 90       	pop	r0
    20cc:	0f 90       	pop	r0
    20ce:	0f 90       	pop	r0
    20d0:	df 91       	pop	r29
    20d2:	cf 91       	pop	r28
    20d4:	08 95       	ret

000020d6 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    20d6:	cf 93       	push	r28
    20d8:	df 93       	push	r29
    20da:	1f 92       	push	r1
    20dc:	1f 92       	push	r1
    20de:	cd b7       	in	r28, 0x3d	; 61
    20e0:	de b7       	in	r29, 0x3e	; 62
    20e2:	9a 83       	std	Y+2, r25	; 0x02
    20e4:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    20e6:	89 81       	ldd	r24, Y+1	; 0x01
    20e8:	9a 81       	ldd	r25, Y+2	; 0x02
    20ea:	fc 01       	movw	r30, r24
    20ec:	80 81       	ld	r24, Z
    20ee:	91 81       	ldd	r25, Z+1	; 0x01
    20f0:	0e 94 12 17 	call	0x2e24	; 0x2e24 <vPortFree>
	vPortFree( pxQueue );
    20f4:	89 81       	ldd	r24, Y+1	; 0x01
    20f6:	9a 81       	ldd	r25, Y+2	; 0x02
    20f8:	0e 94 12 17 	call	0x2e24	; 0x2e24 <vPortFree>
}
    20fc:	0f 90       	pop	r0
    20fe:	0f 90       	pop	r0
    2100:	df 91       	pop	r29
    2102:	cf 91       	pop	r28
    2104:	08 95       	ret

00002106 <prvCopyDataToQueue>:

#endif
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    2106:	cf 93       	push	r28
    2108:	df 93       	push	r29
    210a:	00 d0       	rcall	.+0      	; 0x210c <prvCopyDataToQueue+0x6>
    210c:	1f 92       	push	r1
    210e:	1f 92       	push	r1
    2110:	cd b7       	in	r28, 0x3d	; 61
    2112:	de b7       	in	r29, 0x3e	; 62
    2114:	9a 83       	std	Y+2, r25	; 0x02
    2116:	89 83       	std	Y+1, r24	; 0x01
    2118:	7c 83       	std	Y+4, r23	; 0x04
    211a:	6b 83       	std	Y+3, r22	; 0x03
    211c:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    211e:	89 81       	ldd	r24, Y+1	; 0x01
    2120:	9a 81       	ldd	r25, Y+2	; 0x02
    2122:	fc 01       	movw	r30, r24
    2124:	84 8d       	ldd	r24, Z+28	; 0x1c
    2126:	88 23       	and	r24, r24
    2128:	a9 f4       	brne	.+42     	; 0x2154 <prvCopyDataToQueue+0x4e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    212a:	89 81       	ldd	r24, Y+1	; 0x01
    212c:	9a 81       	ldd	r25, Y+2	; 0x02
    212e:	fc 01       	movw	r30, r24
    2130:	80 81       	ld	r24, Z
    2132:	91 81       	ldd	r25, Z+1	; 0x01
    2134:	00 97       	sbiw	r24, 0x00	; 0
    2136:	09 f0       	breq	.+2      	; 0x213a <prvCopyDataToQueue+0x34>
    2138:	92 c0       	rjmp	.+292    	; 0x225e <__stack+0x5f>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    213a:	89 81       	ldd	r24, Y+1	; 0x01
    213c:	9a 81       	ldd	r25, Y+2	; 0x02
    213e:	fc 01       	movw	r30, r24
    2140:	82 81       	ldd	r24, Z+2	; 0x02
    2142:	93 81       	ldd	r25, Z+3	; 0x03
    2144:	0e 94 52 0c 	call	0x18a4	; 0x18a4 <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    2148:	89 81       	ldd	r24, Y+1	; 0x01
    214a:	9a 81       	ldd	r25, Y+2	; 0x02
    214c:	fc 01       	movw	r30, r24
    214e:	13 82       	std	Z+3, r1	; 0x03
    2150:	12 82       	std	Z+2, r1	; 0x02
    2152:	85 c0       	rjmp	.+266    	; 0x225e <__stack+0x5f>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    2154:	8d 81       	ldd	r24, Y+5	; 0x05
    2156:	88 23       	and	r24, r24
    2158:	d9 f5       	brne	.+118    	; 0x21d0 <prvCopyDataToQueue+0xca>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    215a:	89 81       	ldd	r24, Y+1	; 0x01
    215c:	9a 81       	ldd	r25, Y+2	; 0x02
    215e:	fc 01       	movw	r30, r24
    2160:	84 8d       	ldd	r24, Z+28	; 0x1c
    2162:	48 2f       	mov	r20, r24
    2164:	50 e0       	ldi	r21, 0x00	; 0
    2166:	89 81       	ldd	r24, Y+1	; 0x01
    2168:	9a 81       	ldd	r25, Y+2	; 0x02
    216a:	fc 01       	movw	r30, r24
    216c:	84 81       	ldd	r24, Z+4	; 0x04
    216e:	95 81       	ldd	r25, Z+5	; 0x05
    2170:	2b 81       	ldd	r18, Y+3	; 0x03
    2172:	3c 81       	ldd	r19, Y+4	; 0x04
    2174:	b9 01       	movw	r22, r18
    2176:	0e 94 88 27 	call	0x4f10	; 0x4f10 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    217a:	89 81       	ldd	r24, Y+1	; 0x01
    217c:	9a 81       	ldd	r25, Y+2	; 0x02
    217e:	fc 01       	movw	r30, r24
    2180:	24 81       	ldd	r18, Z+4	; 0x04
    2182:	35 81       	ldd	r19, Z+5	; 0x05
    2184:	89 81       	ldd	r24, Y+1	; 0x01
    2186:	9a 81       	ldd	r25, Y+2	; 0x02
    2188:	fc 01       	movw	r30, r24
    218a:	84 8d       	ldd	r24, Z+28	; 0x1c
    218c:	88 2f       	mov	r24, r24
    218e:	90 e0       	ldi	r25, 0x00	; 0
    2190:	28 0f       	add	r18, r24
    2192:	39 1f       	adc	r19, r25
    2194:	89 81       	ldd	r24, Y+1	; 0x01
    2196:	9a 81       	ldd	r25, Y+2	; 0x02
    2198:	fc 01       	movw	r30, r24
    219a:	35 83       	std	Z+5, r19	; 0x05
    219c:	24 83       	std	Z+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    219e:	89 81       	ldd	r24, Y+1	; 0x01
    21a0:	9a 81       	ldd	r25, Y+2	; 0x02
    21a2:	fc 01       	movw	r30, r24
    21a4:	24 81       	ldd	r18, Z+4	; 0x04
    21a6:	35 81       	ldd	r19, Z+5	; 0x05
    21a8:	89 81       	ldd	r24, Y+1	; 0x01
    21aa:	9a 81       	ldd	r25, Y+2	; 0x02
    21ac:	fc 01       	movw	r30, r24
    21ae:	82 81       	ldd	r24, Z+2	; 0x02
    21b0:	93 81       	ldd	r25, Z+3	; 0x03
    21b2:	28 17       	cp	r18, r24
    21b4:	39 07       	cpc	r19, r25
    21b6:	08 f4       	brcc	.+2      	; 0x21ba <prvCopyDataToQueue+0xb4>
    21b8:	52 c0       	rjmp	.+164    	; 0x225e <__stack+0x5f>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    21ba:	89 81       	ldd	r24, Y+1	; 0x01
    21bc:	9a 81       	ldd	r25, Y+2	; 0x02
    21be:	fc 01       	movw	r30, r24
    21c0:	20 81       	ld	r18, Z
    21c2:	31 81       	ldd	r19, Z+1	; 0x01
    21c4:	89 81       	ldd	r24, Y+1	; 0x01
    21c6:	9a 81       	ldd	r25, Y+2	; 0x02
    21c8:	fc 01       	movw	r30, r24
    21ca:	35 83       	std	Z+5, r19	; 0x05
    21cc:	24 83       	std	Z+4, r18	; 0x04
    21ce:	47 c0       	rjmp	.+142    	; 0x225e <__stack+0x5f>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    21d0:	89 81       	ldd	r24, Y+1	; 0x01
    21d2:	9a 81       	ldd	r25, Y+2	; 0x02
    21d4:	fc 01       	movw	r30, r24
    21d6:	84 8d       	ldd	r24, Z+28	; 0x1c
    21d8:	48 2f       	mov	r20, r24
    21da:	50 e0       	ldi	r21, 0x00	; 0
    21dc:	89 81       	ldd	r24, Y+1	; 0x01
    21de:	9a 81       	ldd	r25, Y+2	; 0x02
    21e0:	fc 01       	movw	r30, r24
    21e2:	86 81       	ldd	r24, Z+6	; 0x06
    21e4:	97 81       	ldd	r25, Z+7	; 0x07
    21e6:	2b 81       	ldd	r18, Y+3	; 0x03
    21e8:	3c 81       	ldd	r19, Y+4	; 0x04
    21ea:	b9 01       	movw	r22, r18
    21ec:	0e 94 88 27 	call	0x4f10	; 0x4f10 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    21f0:	89 81       	ldd	r24, Y+1	; 0x01
    21f2:	9a 81       	ldd	r25, Y+2	; 0x02
    21f4:	fc 01       	movw	r30, r24
    21f6:	26 81       	ldd	r18, Z+6	; 0x06
    21f8:	37 81       	ldd	r19, Z+7	; 0x07
    21fa:	89 81       	ldd	r24, Y+1	; 0x01
    21fc:	9a 81       	ldd	r25, Y+2	; 0x02
    21fe:	fc 01       	movw	r30, r24
    2200:	84 8d       	ldd	r24, Z+28	; 0x1c
    2202:	88 2f       	mov	r24, r24
    2204:	90 e0       	ldi	r25, 0x00	; 0
    2206:	91 95       	neg	r25
    2208:	81 95       	neg	r24
    220a:	91 09       	sbc	r25, r1
    220c:	28 0f       	add	r18, r24
    220e:	39 1f       	adc	r19, r25
    2210:	89 81       	ldd	r24, Y+1	; 0x01
    2212:	9a 81       	ldd	r25, Y+2	; 0x02
    2214:	fc 01       	movw	r30, r24
    2216:	37 83       	std	Z+7, r19	; 0x07
    2218:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    221a:	89 81       	ldd	r24, Y+1	; 0x01
    221c:	9a 81       	ldd	r25, Y+2	; 0x02
    221e:	fc 01       	movw	r30, r24
    2220:	26 81       	ldd	r18, Z+6	; 0x06
    2222:	37 81       	ldd	r19, Z+7	; 0x07
    2224:	89 81       	ldd	r24, Y+1	; 0x01
    2226:	9a 81       	ldd	r25, Y+2	; 0x02
    2228:	fc 01       	movw	r30, r24
    222a:	80 81       	ld	r24, Z
    222c:	91 81       	ldd	r25, Z+1	; 0x01
    222e:	28 17       	cp	r18, r24
    2230:	39 07       	cpc	r19, r25
    2232:	a8 f4       	brcc	.+42     	; 0x225e <__stack+0x5f>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    2234:	89 81       	ldd	r24, Y+1	; 0x01
    2236:	9a 81       	ldd	r25, Y+2	; 0x02
    2238:	fc 01       	movw	r30, r24
    223a:	22 81       	ldd	r18, Z+2	; 0x02
    223c:	33 81       	ldd	r19, Z+3	; 0x03
    223e:	89 81       	ldd	r24, Y+1	; 0x01
    2240:	9a 81       	ldd	r25, Y+2	; 0x02
    2242:	fc 01       	movw	r30, r24
    2244:	84 8d       	ldd	r24, Z+28	; 0x1c
    2246:	88 2f       	mov	r24, r24
    2248:	90 e0       	ldi	r25, 0x00	; 0
    224a:	91 95       	neg	r25
    224c:	81 95       	neg	r24
    224e:	91 09       	sbc	r25, r1
    2250:	28 0f       	add	r18, r24
    2252:	39 1f       	adc	r19, r25
    2254:	89 81       	ldd	r24, Y+1	; 0x01
    2256:	9a 81       	ldd	r25, Y+2	; 0x02
    2258:	fc 01       	movw	r30, r24
    225a:	37 83       	std	Z+7, r19	; 0x07
    225c:	26 83       	std	Z+6, r18	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    225e:	89 81       	ldd	r24, Y+1	; 0x01
    2260:	9a 81       	ldd	r25, Y+2	; 0x02
    2262:	fc 01       	movw	r30, r24
    2264:	82 8d       	ldd	r24, Z+26	; 0x1a
    2266:	21 e0       	ldi	r18, 0x01	; 1
    2268:	28 0f       	add	r18, r24
    226a:	89 81       	ldd	r24, Y+1	; 0x01
    226c:	9a 81       	ldd	r25, Y+2	; 0x02
    226e:	fc 01       	movw	r30, r24
    2270:	22 8f       	std	Z+26, r18	; 0x1a
}
    2272:	0f 90       	pop	r0
    2274:	0f 90       	pop	r0
    2276:	0f 90       	pop	r0
    2278:	0f 90       	pop	r0
    227a:	0f 90       	pop	r0
    227c:	df 91       	pop	r29
    227e:	cf 91       	pop	r28
    2280:	08 95       	ret

00002282 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    2282:	cf 93       	push	r28
    2284:	df 93       	push	r29
    2286:	00 d0       	rcall	.+0      	; 0x2288 <prvCopyDataFromQueue+0x6>
    2288:	1f 92       	push	r1
    228a:	cd b7       	in	r28, 0x3d	; 61
    228c:	de b7       	in	r29, 0x3e	; 62
    228e:	9a 83       	std	Y+2, r25	; 0x02
    2290:	89 83       	std	Y+1, r24	; 0x01
    2292:	7c 83       	std	Y+4, r23	; 0x04
    2294:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    2296:	89 81       	ldd	r24, Y+1	; 0x01
    2298:	9a 81       	ldd	r25, Y+2	; 0x02
    229a:	fc 01       	movw	r30, r24
    229c:	80 81       	ld	r24, Z
    229e:	91 81       	ldd	r25, Z+1	; 0x01
    22a0:	00 97       	sbiw	r24, 0x00	; 0
    22a2:	c9 f1       	breq	.+114    	; 0x2316 <prvCopyDataFromQueue+0x94>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    22a4:	89 81       	ldd	r24, Y+1	; 0x01
    22a6:	9a 81       	ldd	r25, Y+2	; 0x02
    22a8:	fc 01       	movw	r30, r24
    22aa:	26 81       	ldd	r18, Z+6	; 0x06
    22ac:	37 81       	ldd	r19, Z+7	; 0x07
    22ae:	89 81       	ldd	r24, Y+1	; 0x01
    22b0:	9a 81       	ldd	r25, Y+2	; 0x02
    22b2:	fc 01       	movw	r30, r24
    22b4:	84 8d       	ldd	r24, Z+28	; 0x1c
    22b6:	88 2f       	mov	r24, r24
    22b8:	90 e0       	ldi	r25, 0x00	; 0
    22ba:	28 0f       	add	r18, r24
    22bc:	39 1f       	adc	r19, r25
    22be:	89 81       	ldd	r24, Y+1	; 0x01
    22c0:	9a 81       	ldd	r25, Y+2	; 0x02
    22c2:	fc 01       	movw	r30, r24
    22c4:	37 83       	std	Z+7, r19	; 0x07
    22c6:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    22c8:	89 81       	ldd	r24, Y+1	; 0x01
    22ca:	9a 81       	ldd	r25, Y+2	; 0x02
    22cc:	fc 01       	movw	r30, r24
    22ce:	26 81       	ldd	r18, Z+6	; 0x06
    22d0:	37 81       	ldd	r19, Z+7	; 0x07
    22d2:	89 81       	ldd	r24, Y+1	; 0x01
    22d4:	9a 81       	ldd	r25, Y+2	; 0x02
    22d6:	fc 01       	movw	r30, r24
    22d8:	82 81       	ldd	r24, Z+2	; 0x02
    22da:	93 81       	ldd	r25, Z+3	; 0x03
    22dc:	28 17       	cp	r18, r24
    22de:	39 07       	cpc	r19, r25
    22e0:	50 f0       	brcs	.+20     	; 0x22f6 <prvCopyDataFromQueue+0x74>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    22e2:	89 81       	ldd	r24, Y+1	; 0x01
    22e4:	9a 81       	ldd	r25, Y+2	; 0x02
    22e6:	fc 01       	movw	r30, r24
    22e8:	20 81       	ld	r18, Z
    22ea:	31 81       	ldd	r19, Z+1	; 0x01
    22ec:	89 81       	ldd	r24, Y+1	; 0x01
    22ee:	9a 81       	ldd	r25, Y+2	; 0x02
    22f0:	fc 01       	movw	r30, r24
    22f2:	37 83       	std	Z+7, r19	; 0x07
    22f4:	26 83       	std	Z+6, r18	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    22f6:	89 81       	ldd	r24, Y+1	; 0x01
    22f8:	9a 81       	ldd	r25, Y+2	; 0x02
    22fa:	fc 01       	movw	r30, r24
    22fc:	84 8d       	ldd	r24, Z+28	; 0x1c
    22fe:	48 2f       	mov	r20, r24
    2300:	50 e0       	ldi	r21, 0x00	; 0
    2302:	89 81       	ldd	r24, Y+1	; 0x01
    2304:	9a 81       	ldd	r25, Y+2	; 0x02
    2306:	fc 01       	movw	r30, r24
    2308:	26 81       	ldd	r18, Z+6	; 0x06
    230a:	37 81       	ldd	r19, Z+7	; 0x07
    230c:	8b 81       	ldd	r24, Y+3	; 0x03
    230e:	9c 81       	ldd	r25, Y+4	; 0x04
    2310:	b9 01       	movw	r22, r18
    2312:	0e 94 88 27 	call	0x4f10	; 0x4f10 <memcpy>
	}
}
    2316:	0f 90       	pop	r0
    2318:	0f 90       	pop	r0
    231a:	0f 90       	pop	r0
    231c:	0f 90       	pop	r0
    231e:	df 91       	pop	r29
    2320:	cf 91       	pop	r28
    2322:	08 95       	ret

00002324 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    2324:	cf 93       	push	r28
    2326:	df 93       	push	r29
    2328:	1f 92       	push	r1
    232a:	1f 92       	push	r1
    232c:	cd b7       	in	r28, 0x3d	; 61
    232e:	de b7       	in	r29, 0x3e	; 62
    2330:	9a 83       	std	Y+2, r25	; 0x02
    2332:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    2334:	0f b6       	in	r0, 0x3f	; 63
    2336:	f8 94       	cli
    2338:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    233a:	1b c0       	rjmp	.+54     	; 0x2372 <prvUnlockQueue+0x4e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    233c:	89 81       	ldd	r24, Y+1	; 0x01
    233e:	9a 81       	ldd	r25, Y+2	; 0x02
    2340:	fc 01       	movw	r30, r24
    2342:	81 89       	ldd	r24, Z+17	; 0x11
    2344:	88 23       	and	r24, r24
    2346:	a1 f0       	breq	.+40     	; 0x2370 <prvUnlockQueue+0x4c>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2348:	89 81       	ldd	r24, Y+1	; 0x01
    234a:	9a 81       	ldd	r25, Y+2	; 0x02
    234c:	41 96       	adiw	r24, 0x11	; 17
    234e:	0e 94 12 09 	call	0x1224	; 0x1224 <xTaskRemoveFromEventList>
    2352:	88 23       	and	r24, r24
    2354:	11 f0       	breq	.+4      	; 0x235a <prvUnlockQueue+0x36>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    2356:	0e 94 07 0a 	call	0x140e	; 0x140e <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    235a:	89 81       	ldd	r24, Y+1	; 0x01
    235c:	9a 81       	ldd	r25, Y+2	; 0x02
    235e:	fc 01       	movw	r30, r24
    2360:	86 8d       	ldd	r24, Z+30	; 0x1e
    2362:	2f ef       	ldi	r18, 0xFF	; 255
    2364:	28 0f       	add	r18, r24
    2366:	89 81       	ldd	r24, Y+1	; 0x01
    2368:	9a 81       	ldd	r25, Y+2	; 0x02
    236a:	fc 01       	movw	r30, r24
    236c:	26 8f       	std	Z+30, r18	; 0x1e
    236e:	01 c0       	rjmp	.+2      	; 0x2372 <prvUnlockQueue+0x4e>
			}
			else
			{
				break;
    2370:	06 c0       	rjmp	.+12     	; 0x237e <prvUnlockQueue+0x5a>
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2372:	89 81       	ldd	r24, Y+1	; 0x01
    2374:	9a 81       	ldd	r25, Y+2	; 0x02
    2376:	fc 01       	movw	r30, r24
    2378:	86 8d       	ldd	r24, Z+30	; 0x1e
    237a:	18 16       	cp	r1, r24
    237c:	fc f2       	brlt	.-66     	; 0x233c <prvUnlockQueue+0x18>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    237e:	89 81       	ldd	r24, Y+1	; 0x01
    2380:	9a 81       	ldd	r25, Y+2	; 0x02
    2382:	2f ef       	ldi	r18, 0xFF	; 255
    2384:	fc 01       	movw	r30, r24
    2386:	26 8f       	std	Z+30, r18	; 0x1e
	}
	taskEXIT_CRITICAL();
    2388:	0f 90       	pop	r0
    238a:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    238c:	0f b6       	in	r0, 0x3f	; 63
    238e:	f8 94       	cli
    2390:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2392:	1b c0       	rjmp	.+54     	; 0x23ca <prvUnlockQueue+0xa6>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2394:	89 81       	ldd	r24, Y+1	; 0x01
    2396:	9a 81       	ldd	r25, Y+2	; 0x02
    2398:	fc 01       	movw	r30, r24
    239a:	80 85       	ldd	r24, Z+8	; 0x08
    239c:	88 23       	and	r24, r24
    239e:	a1 f0       	breq	.+40     	; 0x23c8 <prvUnlockQueue+0xa4>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    23a0:	89 81       	ldd	r24, Y+1	; 0x01
    23a2:	9a 81       	ldd	r25, Y+2	; 0x02
    23a4:	08 96       	adiw	r24, 0x08	; 8
    23a6:	0e 94 12 09 	call	0x1224	; 0x1224 <xTaskRemoveFromEventList>
    23aa:	88 23       	and	r24, r24
    23ac:	11 f0       	breq	.+4      	; 0x23b2 <prvUnlockQueue+0x8e>
				{
					vTaskMissedYield();
    23ae:	0e 94 07 0a 	call	0x140e	; 0x140e <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    23b2:	89 81       	ldd	r24, Y+1	; 0x01
    23b4:	9a 81       	ldd	r25, Y+2	; 0x02
    23b6:	fc 01       	movw	r30, r24
    23b8:	85 8d       	ldd	r24, Z+29	; 0x1d
    23ba:	2f ef       	ldi	r18, 0xFF	; 255
    23bc:	28 0f       	add	r18, r24
    23be:	89 81       	ldd	r24, Y+1	; 0x01
    23c0:	9a 81       	ldd	r25, Y+2	; 0x02
    23c2:	fc 01       	movw	r30, r24
    23c4:	25 8f       	std	Z+29, r18	; 0x1d
    23c6:	01 c0       	rjmp	.+2      	; 0x23ca <prvUnlockQueue+0xa6>
			}
			else
			{
				break;
    23c8:	06 c0       	rjmp	.+12     	; 0x23d6 <prvUnlockQueue+0xb2>
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    23ca:	89 81       	ldd	r24, Y+1	; 0x01
    23cc:	9a 81       	ldd	r25, Y+2	; 0x02
    23ce:	fc 01       	movw	r30, r24
    23d0:	85 8d       	ldd	r24, Z+29	; 0x1d
    23d2:	18 16       	cp	r1, r24
    23d4:	fc f2       	brlt	.-66     	; 0x2394 <prvUnlockQueue+0x70>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    23d6:	89 81       	ldd	r24, Y+1	; 0x01
    23d8:	9a 81       	ldd	r25, Y+2	; 0x02
    23da:	2f ef       	ldi	r18, 0xFF	; 255
    23dc:	fc 01       	movw	r30, r24
    23de:	25 8f       	std	Z+29, r18	; 0x1d
	}
	taskEXIT_CRITICAL();
    23e0:	0f 90       	pop	r0
    23e2:	0f be       	out	0x3f, r0	; 63
}
    23e4:	0f 90       	pop	r0
    23e6:	0f 90       	pop	r0
    23e8:	df 91       	pop	r29
    23ea:	cf 91       	pop	r28
    23ec:	08 95       	ret

000023ee <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    23ee:	cf 93       	push	r28
    23f0:	df 93       	push	r29
    23f2:	00 d0       	rcall	.+0      	; 0x23f4 <prvIsQueueEmpty+0x6>
    23f4:	cd b7       	in	r28, 0x3d	; 61
    23f6:	de b7       	in	r29, 0x3e	; 62
    23f8:	9b 83       	std	Y+3, r25	; 0x03
    23fa:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    23fc:	0f b6       	in	r0, 0x3f	; 63
    23fe:	f8 94       	cli
    2400:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    2402:	8a 81       	ldd	r24, Y+2	; 0x02
    2404:	9b 81       	ldd	r25, Y+3	; 0x03
    2406:	fc 01       	movw	r30, r24
    2408:	92 8d       	ldd	r25, Z+26	; 0x1a
    240a:	81 e0       	ldi	r24, 0x01	; 1
    240c:	99 23       	and	r25, r25
    240e:	09 f0       	breq	.+2      	; 0x2412 <prvIsQueueEmpty+0x24>
    2410:	80 e0       	ldi	r24, 0x00	; 0
    2412:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    2414:	0f 90       	pop	r0
    2416:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2418:	89 81       	ldd	r24, Y+1	; 0x01
}
    241a:	0f 90       	pop	r0
    241c:	0f 90       	pop	r0
    241e:	0f 90       	pop	r0
    2420:	df 91       	pop	r29
    2422:	cf 91       	pop	r28
    2424:	08 95       	ret

00002426 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    2426:	cf 93       	push	r28
    2428:	df 93       	push	r29
    242a:	00 d0       	rcall	.+0      	; 0x242c <xQueueIsQueueEmptyFromISR+0x6>
    242c:	cd b7       	in	r28, 0x3d	; 61
    242e:	de b7       	in	r29, 0x3e	; 62
    2430:	9b 83       	std	Y+3, r25	; 0x03
    2432:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    2434:	8a 81       	ldd	r24, Y+2	; 0x02
    2436:	9b 81       	ldd	r25, Y+3	; 0x03
    2438:	fc 01       	movw	r30, r24
    243a:	92 8d       	ldd	r25, Z+26	; 0x1a
    243c:	81 e0       	ldi	r24, 0x01	; 1
    243e:	99 23       	and	r25, r25
    2440:	09 f0       	breq	.+2      	; 0x2444 <xQueueIsQueueEmptyFromISR+0x1e>
    2442:	80 e0       	ldi	r24, 0x00	; 0
    2444:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    2446:	89 81       	ldd	r24, Y+1	; 0x01
}
    2448:	0f 90       	pop	r0
    244a:	0f 90       	pop	r0
    244c:	0f 90       	pop	r0
    244e:	df 91       	pop	r29
    2450:	cf 91       	pop	r28
    2452:	08 95       	ret

00002454 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    2454:	cf 93       	push	r28
    2456:	df 93       	push	r29
    2458:	00 d0       	rcall	.+0      	; 0x245a <prvIsQueueFull+0x6>
    245a:	cd b7       	in	r28, 0x3d	; 61
    245c:	de b7       	in	r29, 0x3e	; 62
    245e:	9b 83       	std	Y+3, r25	; 0x03
    2460:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    2462:	0f b6       	in	r0, 0x3f	; 63
    2464:	f8 94       	cli
    2466:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    2468:	8a 81       	ldd	r24, Y+2	; 0x02
    246a:	9b 81       	ldd	r25, Y+3	; 0x03
    246c:	fc 01       	movw	r30, r24
    246e:	22 8d       	ldd	r18, Z+26	; 0x1a
    2470:	8a 81       	ldd	r24, Y+2	; 0x02
    2472:	9b 81       	ldd	r25, Y+3	; 0x03
    2474:	fc 01       	movw	r30, r24
    2476:	93 8d       	ldd	r25, Z+27	; 0x1b
    2478:	81 e0       	ldi	r24, 0x01	; 1
    247a:	29 17       	cp	r18, r25
    247c:	09 f0       	breq	.+2      	; 0x2480 <prvIsQueueFull+0x2c>
    247e:	80 e0       	ldi	r24, 0x00	; 0
    2480:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    2482:	0f 90       	pop	r0
    2484:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2486:	89 81       	ldd	r24, Y+1	; 0x01
}
    2488:	0f 90       	pop	r0
    248a:	0f 90       	pop	r0
    248c:	0f 90       	pop	r0
    248e:	df 91       	pop	r29
    2490:	cf 91       	pop	r28
    2492:	08 95       	ret

00002494 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    2494:	cf 93       	push	r28
    2496:	df 93       	push	r29
    2498:	00 d0       	rcall	.+0      	; 0x249a <xQueueIsQueueFullFromISR+0x6>
    249a:	cd b7       	in	r28, 0x3d	; 61
    249c:	de b7       	in	r29, 0x3e	; 62
    249e:	9b 83       	std	Y+3, r25	; 0x03
    24a0:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    24a2:	8a 81       	ldd	r24, Y+2	; 0x02
    24a4:	9b 81       	ldd	r25, Y+3	; 0x03
    24a6:	fc 01       	movw	r30, r24
    24a8:	22 8d       	ldd	r18, Z+26	; 0x1a
    24aa:	8a 81       	ldd	r24, Y+2	; 0x02
    24ac:	9b 81       	ldd	r25, Y+3	; 0x03
    24ae:	fc 01       	movw	r30, r24
    24b0:	93 8d       	ldd	r25, Z+27	; 0x1b
    24b2:	81 e0       	ldi	r24, 0x01	; 1
    24b4:	29 17       	cp	r18, r25
    24b6:	09 f0       	breq	.+2      	; 0x24ba <xQueueIsQueueFullFromISR+0x26>
    24b8:	80 e0       	ldi	r24, 0x00	; 0
    24ba:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    24bc:	89 81       	ldd	r24, Y+1	; 0x01
}
    24be:	0f 90       	pop	r0
    24c0:	0f 90       	pop	r0
    24c2:	0f 90       	pop	r0
    24c4:	df 91       	pop	r29
    24c6:	cf 91       	pop	r28
    24c8:	08 95       	ret

000024ca <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    24ca:	cf 93       	push	r28
    24cc:	df 93       	push	r29
    24ce:	1f 92       	push	r1
    24d0:	1f 92       	push	r1
    24d2:	cd b7       	in	r28, 0x3d	; 61
    24d4:	de b7       	in	r29, 0x3e	; 62
    24d6:	9a 83       	std	Y+2, r25	; 0x02
    24d8:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    24da:	89 81       	ldd	r24, Y+1	; 0x01
    24dc:	9a 81       	ldd	r25, Y+2	; 0x02
    24de:	9c 01       	movw	r18, r24
    24e0:	2d 5f       	subi	r18, 0xFD	; 253
    24e2:	3f 4f       	sbci	r19, 0xFF	; 255
    24e4:	89 81       	ldd	r24, Y+1	; 0x01
    24e6:	9a 81       	ldd	r25, Y+2	; 0x02
    24e8:	fc 01       	movw	r30, r24
    24ea:	32 83       	std	Z+2, r19	; 0x02
    24ec:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    24ee:	89 81       	ldd	r24, Y+1	; 0x01
    24f0:	9a 81       	ldd	r25, Y+2	; 0x02
    24f2:	2f ef       	ldi	r18, 0xFF	; 255
    24f4:	3f ef       	ldi	r19, 0xFF	; 255
    24f6:	fc 01       	movw	r30, r24
    24f8:	34 83       	std	Z+4, r19	; 0x04
    24fa:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    24fc:	89 81       	ldd	r24, Y+1	; 0x01
    24fe:	9a 81       	ldd	r25, Y+2	; 0x02
    2500:	9c 01       	movw	r18, r24
    2502:	2d 5f       	subi	r18, 0xFD	; 253
    2504:	3f 4f       	sbci	r19, 0xFF	; 255
    2506:	89 81       	ldd	r24, Y+1	; 0x01
    2508:	9a 81       	ldd	r25, Y+2	; 0x02
    250a:	fc 01       	movw	r30, r24
    250c:	36 83       	std	Z+6, r19	; 0x06
    250e:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    2510:	89 81       	ldd	r24, Y+1	; 0x01
    2512:	9a 81       	ldd	r25, Y+2	; 0x02
    2514:	9c 01       	movw	r18, r24
    2516:	2d 5f       	subi	r18, 0xFD	; 253
    2518:	3f 4f       	sbci	r19, 0xFF	; 255
    251a:	89 81       	ldd	r24, Y+1	; 0x01
    251c:	9a 81       	ldd	r25, Y+2	; 0x02
    251e:	fc 01       	movw	r30, r24
    2520:	30 87       	std	Z+8, r19	; 0x08
    2522:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    2524:	89 81       	ldd	r24, Y+1	; 0x01
    2526:	9a 81       	ldd	r25, Y+2	; 0x02
    2528:	fc 01       	movw	r30, r24
    252a:	10 82       	st	Z, r1
}
    252c:	0f 90       	pop	r0
    252e:	0f 90       	pop	r0
    2530:	df 91       	pop	r29
    2532:	cf 91       	pop	r28
    2534:	08 95       	ret

00002536 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    2536:	cf 93       	push	r28
    2538:	df 93       	push	r29
    253a:	1f 92       	push	r1
    253c:	1f 92       	push	r1
    253e:	cd b7       	in	r28, 0x3d	; 61
    2540:	de b7       	in	r29, 0x3e	; 62
    2542:	9a 83       	std	Y+2, r25	; 0x02
    2544:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    2546:	89 81       	ldd	r24, Y+1	; 0x01
    2548:	9a 81       	ldd	r25, Y+2	; 0x02
    254a:	fc 01       	movw	r30, r24
    254c:	11 86       	std	Z+9, r1	; 0x09
    254e:	10 86       	std	Z+8, r1	; 0x08
}
    2550:	0f 90       	pop	r0
    2552:	0f 90       	pop	r0
    2554:	df 91       	pop	r29
    2556:	cf 91       	pop	r28
    2558:	08 95       	ret

0000255a <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    255a:	cf 93       	push	r28
    255c:	df 93       	push	r29
    255e:	00 d0       	rcall	.+0      	; 0x2560 <vListInsertEnd+0x6>
    2560:	00 d0       	rcall	.+0      	; 0x2562 <vListInsertEnd+0x8>
    2562:	cd b7       	in	r28, 0x3d	; 61
    2564:	de b7       	in	r29, 0x3e	; 62
    2566:	9c 83       	std	Y+4, r25	; 0x04
    2568:	8b 83       	std	Y+3, r24	; 0x03
    256a:	7e 83       	std	Y+6, r23	; 0x06
    256c:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    256e:	8b 81       	ldd	r24, Y+3	; 0x03
    2570:	9c 81       	ldd	r25, Y+4	; 0x04
    2572:	fc 01       	movw	r30, r24
    2574:	81 81       	ldd	r24, Z+1	; 0x01
    2576:	92 81       	ldd	r25, Z+2	; 0x02
    2578:	9a 83       	std	Y+2, r25	; 0x02
    257a:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    257c:	89 81       	ldd	r24, Y+1	; 0x01
    257e:	9a 81       	ldd	r25, Y+2	; 0x02
    2580:	fc 01       	movw	r30, r24
    2582:	22 81       	ldd	r18, Z+2	; 0x02
    2584:	33 81       	ldd	r19, Z+3	; 0x03
    2586:	8d 81       	ldd	r24, Y+5	; 0x05
    2588:	9e 81       	ldd	r25, Y+6	; 0x06
    258a:	fc 01       	movw	r30, r24
    258c:	33 83       	std	Z+3, r19	; 0x03
    258e:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    2590:	8b 81       	ldd	r24, Y+3	; 0x03
    2592:	9c 81       	ldd	r25, Y+4	; 0x04
    2594:	fc 01       	movw	r30, r24
    2596:	21 81       	ldd	r18, Z+1	; 0x01
    2598:	32 81       	ldd	r19, Z+2	; 0x02
    259a:	8d 81       	ldd	r24, Y+5	; 0x05
    259c:	9e 81       	ldd	r25, Y+6	; 0x06
    259e:	fc 01       	movw	r30, r24
    25a0:	35 83       	std	Z+5, r19	; 0x05
    25a2:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    25a4:	89 81       	ldd	r24, Y+1	; 0x01
    25a6:	9a 81       	ldd	r25, Y+2	; 0x02
    25a8:	fc 01       	movw	r30, r24
    25aa:	82 81       	ldd	r24, Z+2	; 0x02
    25ac:	93 81       	ldd	r25, Z+3	; 0x03
    25ae:	2d 81       	ldd	r18, Y+5	; 0x05
    25b0:	3e 81       	ldd	r19, Y+6	; 0x06
    25b2:	fc 01       	movw	r30, r24
    25b4:	35 83       	std	Z+5, r19	; 0x05
    25b6:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    25b8:	89 81       	ldd	r24, Y+1	; 0x01
    25ba:	9a 81       	ldd	r25, Y+2	; 0x02
    25bc:	2d 81       	ldd	r18, Y+5	; 0x05
    25be:	3e 81       	ldd	r19, Y+6	; 0x06
    25c0:	fc 01       	movw	r30, r24
    25c2:	33 83       	std	Z+3, r19	; 0x03
    25c4:	22 83       	std	Z+2, r18	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    25c6:	8b 81       	ldd	r24, Y+3	; 0x03
    25c8:	9c 81       	ldd	r25, Y+4	; 0x04
    25ca:	2d 81       	ldd	r18, Y+5	; 0x05
    25cc:	3e 81       	ldd	r19, Y+6	; 0x06
    25ce:	fc 01       	movw	r30, r24
    25d0:	32 83       	std	Z+2, r19	; 0x02
    25d2:	21 83       	std	Z+1, r18	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    25d4:	8d 81       	ldd	r24, Y+5	; 0x05
    25d6:	9e 81       	ldd	r25, Y+6	; 0x06
    25d8:	2b 81       	ldd	r18, Y+3	; 0x03
    25da:	3c 81       	ldd	r19, Y+4	; 0x04
    25dc:	fc 01       	movw	r30, r24
    25de:	31 87       	std	Z+9, r19	; 0x09
    25e0:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    25e2:	8b 81       	ldd	r24, Y+3	; 0x03
    25e4:	9c 81       	ldd	r25, Y+4	; 0x04
    25e6:	fc 01       	movw	r30, r24
    25e8:	80 81       	ld	r24, Z
    25ea:	21 e0       	ldi	r18, 0x01	; 1
    25ec:	28 0f       	add	r18, r24
    25ee:	8b 81       	ldd	r24, Y+3	; 0x03
    25f0:	9c 81       	ldd	r25, Y+4	; 0x04
    25f2:	fc 01       	movw	r30, r24
    25f4:	20 83       	st	Z, r18
}
    25f6:	26 96       	adiw	r28, 0x06	; 6
    25f8:	0f b6       	in	r0, 0x3f	; 63
    25fa:	f8 94       	cli
    25fc:	de bf       	out	0x3e, r29	; 62
    25fe:	0f be       	out	0x3f, r0	; 63
    2600:	cd bf       	out	0x3d, r28	; 61
    2602:	df 91       	pop	r29
    2604:	cf 91       	pop	r28
    2606:	08 95       	ret

00002608 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    2608:	cf 93       	push	r28
    260a:	df 93       	push	r29
    260c:	cd b7       	in	r28, 0x3d	; 61
    260e:	de b7       	in	r29, 0x3e	; 62
    2610:	28 97       	sbiw	r28, 0x08	; 8
    2612:	0f b6       	in	r0, 0x3f	; 63
    2614:	f8 94       	cli
    2616:	de bf       	out	0x3e, r29	; 62
    2618:	0f be       	out	0x3f, r0	; 63
    261a:	cd bf       	out	0x3d, r28	; 61
    261c:	9e 83       	std	Y+6, r25	; 0x06
    261e:	8d 83       	std	Y+5, r24	; 0x05
    2620:	78 87       	std	Y+8, r23	; 0x08
    2622:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    2624:	8f 81       	ldd	r24, Y+7	; 0x07
    2626:	98 85       	ldd	r25, Y+8	; 0x08
    2628:	fc 01       	movw	r30, r24
    262a:	80 81       	ld	r24, Z
    262c:	91 81       	ldd	r25, Z+1	; 0x01
    262e:	9c 83       	std	Y+4, r25	; 0x04
    2630:	8b 83       	std	Y+3, r24	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    2632:	8b 81       	ldd	r24, Y+3	; 0x03
    2634:	9c 81       	ldd	r25, Y+4	; 0x04
    2636:	8f 3f       	cpi	r24, 0xFF	; 255
    2638:	ff ef       	ldi	r31, 0xFF	; 255
    263a:	9f 07       	cpc	r25, r31
    263c:	41 f4       	brne	.+16     	; 0x264e <vListInsert+0x46>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    263e:	8d 81       	ldd	r24, Y+5	; 0x05
    2640:	9e 81       	ldd	r25, Y+6	; 0x06
    2642:	fc 01       	movw	r30, r24
    2644:	87 81       	ldd	r24, Z+7	; 0x07
    2646:	90 85       	ldd	r25, Z+8	; 0x08
    2648:	9a 83       	std	Y+2, r25	; 0x02
    264a:	89 83       	std	Y+1, r24	; 0x01
    264c:	1a c0       	rjmp	.+52     	; 0x2682 <vListInsert+0x7a>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    264e:	8d 81       	ldd	r24, Y+5	; 0x05
    2650:	9e 81       	ldd	r25, Y+6	; 0x06
    2652:	03 96       	adiw	r24, 0x03	; 3
    2654:	9a 83       	std	Y+2, r25	; 0x02
    2656:	89 83       	std	Y+1, r24	; 0x01
    2658:	07 c0       	rjmp	.+14     	; 0x2668 <vListInsert+0x60>
    265a:	89 81       	ldd	r24, Y+1	; 0x01
    265c:	9a 81       	ldd	r25, Y+2	; 0x02
    265e:	fc 01       	movw	r30, r24
    2660:	82 81       	ldd	r24, Z+2	; 0x02
    2662:	93 81       	ldd	r25, Z+3	; 0x03
    2664:	9a 83       	std	Y+2, r25	; 0x02
    2666:	89 83       	std	Y+1, r24	; 0x01
    2668:	89 81       	ldd	r24, Y+1	; 0x01
    266a:	9a 81       	ldd	r25, Y+2	; 0x02
    266c:	fc 01       	movw	r30, r24
    266e:	82 81       	ldd	r24, Z+2	; 0x02
    2670:	93 81       	ldd	r25, Z+3	; 0x03
    2672:	fc 01       	movw	r30, r24
    2674:	20 81       	ld	r18, Z
    2676:	31 81       	ldd	r19, Z+1	; 0x01
    2678:	8b 81       	ldd	r24, Y+3	; 0x03
    267a:	9c 81       	ldd	r25, Y+4	; 0x04
    267c:	82 17       	cp	r24, r18
    267e:	93 07       	cpc	r25, r19
    2680:	60 f7       	brcc	.-40     	; 0x265a <vListInsert+0x52>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2682:	89 81       	ldd	r24, Y+1	; 0x01
    2684:	9a 81       	ldd	r25, Y+2	; 0x02
    2686:	fc 01       	movw	r30, r24
    2688:	22 81       	ldd	r18, Z+2	; 0x02
    268a:	33 81       	ldd	r19, Z+3	; 0x03
    268c:	8f 81       	ldd	r24, Y+7	; 0x07
    268e:	98 85       	ldd	r25, Y+8	; 0x08
    2690:	fc 01       	movw	r30, r24
    2692:	33 83       	std	Z+3, r19	; 0x03
    2694:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2696:	8f 81       	ldd	r24, Y+7	; 0x07
    2698:	98 85       	ldd	r25, Y+8	; 0x08
    269a:	fc 01       	movw	r30, r24
    269c:	82 81       	ldd	r24, Z+2	; 0x02
    269e:	93 81       	ldd	r25, Z+3	; 0x03
    26a0:	2f 81       	ldd	r18, Y+7	; 0x07
    26a2:	38 85       	ldd	r19, Y+8	; 0x08
    26a4:	fc 01       	movw	r30, r24
    26a6:	35 83       	std	Z+5, r19	; 0x05
    26a8:	24 83       	std	Z+4, r18	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    26aa:	8f 81       	ldd	r24, Y+7	; 0x07
    26ac:	98 85       	ldd	r25, Y+8	; 0x08
    26ae:	29 81       	ldd	r18, Y+1	; 0x01
    26b0:	3a 81       	ldd	r19, Y+2	; 0x02
    26b2:	fc 01       	movw	r30, r24
    26b4:	35 83       	std	Z+5, r19	; 0x05
    26b6:	24 83       	std	Z+4, r18	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    26b8:	89 81       	ldd	r24, Y+1	; 0x01
    26ba:	9a 81       	ldd	r25, Y+2	; 0x02
    26bc:	2f 81       	ldd	r18, Y+7	; 0x07
    26be:	38 85       	ldd	r19, Y+8	; 0x08
    26c0:	fc 01       	movw	r30, r24
    26c2:	33 83       	std	Z+3, r19	; 0x03
    26c4:	22 83       	std	Z+2, r18	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    26c6:	8f 81       	ldd	r24, Y+7	; 0x07
    26c8:	98 85       	ldd	r25, Y+8	; 0x08
    26ca:	2d 81       	ldd	r18, Y+5	; 0x05
    26cc:	3e 81       	ldd	r19, Y+6	; 0x06
    26ce:	fc 01       	movw	r30, r24
    26d0:	31 87       	std	Z+9, r19	; 0x09
    26d2:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    26d4:	8d 81       	ldd	r24, Y+5	; 0x05
    26d6:	9e 81       	ldd	r25, Y+6	; 0x06
    26d8:	fc 01       	movw	r30, r24
    26da:	80 81       	ld	r24, Z
    26dc:	21 e0       	ldi	r18, 0x01	; 1
    26de:	28 0f       	add	r18, r24
    26e0:	8d 81       	ldd	r24, Y+5	; 0x05
    26e2:	9e 81       	ldd	r25, Y+6	; 0x06
    26e4:	fc 01       	movw	r30, r24
    26e6:	20 83       	st	Z, r18
}
    26e8:	28 96       	adiw	r28, 0x08	; 8
    26ea:	0f b6       	in	r0, 0x3f	; 63
    26ec:	f8 94       	cli
    26ee:	de bf       	out	0x3e, r29	; 62
    26f0:	0f be       	out	0x3f, r0	; 63
    26f2:	cd bf       	out	0x3d, r28	; 61
    26f4:	df 91       	pop	r29
    26f6:	cf 91       	pop	r28
    26f8:	08 95       	ret

000026fa <uxListRemove>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
{
    26fa:	cf 93       	push	r28
    26fc:	df 93       	push	r29
    26fe:	00 d0       	rcall	.+0      	; 0x2700 <uxListRemove+0x6>
    2700:	1f 92       	push	r1
    2702:	cd b7       	in	r28, 0x3d	; 61
    2704:	de b7       	in	r29, 0x3e	; 62
    2706:	9c 83       	std	Y+4, r25	; 0x04
    2708:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    270a:	8b 81       	ldd	r24, Y+3	; 0x03
    270c:	9c 81       	ldd	r25, Y+4	; 0x04
    270e:	fc 01       	movw	r30, r24
    2710:	82 81       	ldd	r24, Z+2	; 0x02
    2712:	93 81       	ldd	r25, Z+3	; 0x03
    2714:	2b 81       	ldd	r18, Y+3	; 0x03
    2716:	3c 81       	ldd	r19, Y+4	; 0x04
    2718:	f9 01       	movw	r30, r18
    271a:	24 81       	ldd	r18, Z+4	; 0x04
    271c:	35 81       	ldd	r19, Z+5	; 0x05
    271e:	fc 01       	movw	r30, r24
    2720:	35 83       	std	Z+5, r19	; 0x05
    2722:	24 83       	std	Z+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2724:	8b 81       	ldd	r24, Y+3	; 0x03
    2726:	9c 81       	ldd	r25, Y+4	; 0x04
    2728:	fc 01       	movw	r30, r24
    272a:	84 81       	ldd	r24, Z+4	; 0x04
    272c:	95 81       	ldd	r25, Z+5	; 0x05
    272e:	2b 81       	ldd	r18, Y+3	; 0x03
    2730:	3c 81       	ldd	r19, Y+4	; 0x04
    2732:	f9 01       	movw	r30, r18
    2734:	22 81       	ldd	r18, Z+2	; 0x02
    2736:	33 81       	ldd	r19, Z+3	; 0x03
    2738:	fc 01       	movw	r30, r24
    273a:	33 83       	std	Z+3, r19	; 0x03
    273c:	22 83       	std	Z+2, r18	; 0x02

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    273e:	8b 81       	ldd	r24, Y+3	; 0x03
    2740:	9c 81       	ldd	r25, Y+4	; 0x04
    2742:	fc 01       	movw	r30, r24
    2744:	80 85       	ldd	r24, Z+8	; 0x08
    2746:	91 85       	ldd	r25, Z+9	; 0x09
    2748:	9a 83       	std	Y+2, r25	; 0x02
    274a:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    274c:	89 81       	ldd	r24, Y+1	; 0x01
    274e:	9a 81       	ldd	r25, Y+2	; 0x02
    2750:	fc 01       	movw	r30, r24
    2752:	21 81       	ldd	r18, Z+1	; 0x01
    2754:	32 81       	ldd	r19, Z+2	; 0x02
    2756:	8b 81       	ldd	r24, Y+3	; 0x03
    2758:	9c 81       	ldd	r25, Y+4	; 0x04
    275a:	28 17       	cp	r18, r24
    275c:	39 07       	cpc	r19, r25
    275e:	51 f4       	brne	.+20     	; 0x2774 <uxListRemove+0x7a>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2760:	8b 81       	ldd	r24, Y+3	; 0x03
    2762:	9c 81       	ldd	r25, Y+4	; 0x04
    2764:	fc 01       	movw	r30, r24
    2766:	24 81       	ldd	r18, Z+4	; 0x04
    2768:	35 81       	ldd	r19, Z+5	; 0x05
    276a:	89 81       	ldd	r24, Y+1	; 0x01
    276c:	9a 81       	ldd	r25, Y+2	; 0x02
    276e:	fc 01       	movw	r30, r24
    2770:	32 83       	std	Z+2, r19	; 0x02
    2772:	21 83       	std	Z+1, r18	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    2774:	8b 81       	ldd	r24, Y+3	; 0x03
    2776:	9c 81       	ldd	r25, Y+4	; 0x04
    2778:	fc 01       	movw	r30, r24
    277a:	11 86       	std	Z+9, r1	; 0x09
    277c:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    277e:	89 81       	ldd	r24, Y+1	; 0x01
    2780:	9a 81       	ldd	r25, Y+2	; 0x02
    2782:	fc 01       	movw	r30, r24
    2784:	80 81       	ld	r24, Z
    2786:	2f ef       	ldi	r18, 0xFF	; 255
    2788:	28 0f       	add	r18, r24
    278a:	89 81       	ldd	r24, Y+1	; 0x01
    278c:	9a 81       	ldd	r25, Y+2	; 0x02
    278e:	fc 01       	movw	r30, r24
    2790:	20 83       	st	Z, r18

	return pxList->uxNumberOfItems;
    2792:	89 81       	ldd	r24, Y+1	; 0x01
    2794:	9a 81       	ldd	r25, Y+2	; 0x02
    2796:	fc 01       	movw	r30, r24
    2798:	80 81       	ld	r24, Z
}
    279a:	0f 90       	pop	r0
    279c:	0f 90       	pop	r0
    279e:	0f 90       	pop	r0
    27a0:	0f 90       	pop	r0
    27a2:	df 91       	pop	r29
    27a4:	cf 91       	pop	r28
    27a6:	08 95       	ret

000027a8 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    27a8:	cf 93       	push	r28
    27aa:	df 93       	push	r29
    27ac:	cd b7       	in	r28, 0x3d	; 61
    27ae:	de b7       	in	r29, 0x3e	; 62
    27b0:	27 97       	sbiw	r28, 0x07	; 7
    27b2:	0f b6       	in	r0, 0x3f	; 63
    27b4:	f8 94       	cli
    27b6:	de bf       	out	0x3e, r29	; 62
    27b8:	0f be       	out	0x3f, r0	; 63
    27ba:	cd bf       	out	0x3d, r28	; 61
    27bc:	9d 83       	std	Y+5, r25	; 0x05
    27be:	8c 83       	std	Y+4, r24	; 0x04
    27c0:	6e 83       	std	Y+6, r22	; 0x06
    27c2:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    27c4:	8a e1       	ldi	r24, 0x1A	; 26
    27c6:	90 e0       	ldi	r25, 0x00	; 0
    27c8:	0e 94 cc 16 	call	0x2d98	; 0x2d98 <pvPortMalloc>
    27cc:	9b 83       	std	Y+3, r25	; 0x03
    27ce:	8a 83       	std	Y+2, r24	; 0x02
	if( pxCoRoutine )
    27d0:	8a 81       	ldd	r24, Y+2	; 0x02
    27d2:	9b 81       	ldd	r25, Y+3	; 0x03
    27d4:	00 97       	sbiw	r24, 0x00	; 0
    27d6:	09 f4       	brne	.+2      	; 0x27da <xCoRoutineCreate+0x32>
    27d8:	77 c0       	rjmp	.+238    	; 0x28c8 <xCoRoutineCreate+0x120>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    27da:	80 91 89 02 	lds	r24, 0x0289
    27de:	90 91 8a 02 	lds	r25, 0x028A
    27e2:	00 97       	sbiw	r24, 0x00	; 0
    27e4:	41 f4       	brne	.+16     	; 0x27f6 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    27e6:	8a 81       	ldd	r24, Y+2	; 0x02
    27e8:	9b 81       	ldd	r25, Y+3	; 0x03
    27ea:	90 93 8a 02 	sts	0x028A, r25
    27ee:	80 93 89 02 	sts	0x0289, r24
			prvInitialiseCoRoutineLists();
    27f2:	0e 94 5a 16 	call	0x2cb4	; 0x2cb4 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    27f6:	8e 81       	ldd	r24, Y+6	; 0x06
    27f8:	82 30       	cpi	r24, 0x02	; 2
    27fa:	10 f0       	brcs	.+4      	; 0x2800 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    27fc:	81 e0       	ldi	r24, 0x01	; 1
    27fe:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    2800:	8a 81       	ldd	r24, Y+2	; 0x02
    2802:	9b 81       	ldd	r25, Y+3	; 0x03
    2804:	fc 01       	movw	r30, r24
    2806:	11 8e       	std	Z+25, r1	; 0x19
    2808:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    280a:	8a 81       	ldd	r24, Y+2	; 0x02
    280c:	9b 81       	ldd	r25, Y+3	; 0x03
    280e:	2e 81       	ldd	r18, Y+6	; 0x06
    2810:	fc 01       	movw	r30, r24
    2812:	26 8b       	std	Z+22, r18	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    2814:	8a 81       	ldd	r24, Y+2	; 0x02
    2816:	9b 81       	ldd	r25, Y+3	; 0x03
    2818:	2f 81       	ldd	r18, Y+7	; 0x07
    281a:	fc 01       	movw	r30, r24
    281c:	27 8b       	std	Z+23, r18	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    281e:	8a 81       	ldd	r24, Y+2	; 0x02
    2820:	9b 81       	ldd	r25, Y+3	; 0x03
    2822:	2c 81       	ldd	r18, Y+4	; 0x04
    2824:	3d 81       	ldd	r19, Y+5	; 0x05
    2826:	fc 01       	movw	r30, r24
    2828:	31 83       	std	Z+1, r19	; 0x01
    282a:	20 83       	st	Z, r18

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    282c:	8a 81       	ldd	r24, Y+2	; 0x02
    282e:	9b 81       	ldd	r25, Y+3	; 0x03
    2830:	02 96       	adiw	r24, 0x02	; 2
    2832:	0e 94 9b 12 	call	0x2536	; 0x2536 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    2836:	8a 81       	ldd	r24, Y+2	; 0x02
    2838:	9b 81       	ldd	r25, Y+3	; 0x03
    283a:	0c 96       	adiw	r24, 0x0c	; 12
    283c:	0e 94 9b 12 	call	0x2536	; 0x2536 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    2840:	8a 81       	ldd	r24, Y+2	; 0x02
    2842:	9b 81       	ldd	r25, Y+3	; 0x03
    2844:	2a 81       	ldd	r18, Y+2	; 0x02
    2846:	3b 81       	ldd	r19, Y+3	; 0x03
    2848:	fc 01       	movw	r30, r24
    284a:	31 87       	std	Z+9, r19	; 0x09
    284c:	20 87       	std	Z+8, r18	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    284e:	8a 81       	ldd	r24, Y+2	; 0x02
    2850:	9b 81       	ldd	r25, Y+3	; 0x03
    2852:	2a 81       	ldd	r18, Y+2	; 0x02
    2854:	3b 81       	ldd	r19, Y+3	; 0x03
    2856:	fc 01       	movw	r30, r24
    2858:	33 8b       	std	Z+19, r19	; 0x13
    285a:	22 8b       	std	Z+18, r18	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    285c:	8e 81       	ldd	r24, Y+6	; 0x06
    285e:	88 2f       	mov	r24, r24
    2860:	90 e0       	ldi	r25, 0x00	; 0
    2862:	24 e0       	ldi	r18, 0x04	; 4
    2864:	30 e0       	ldi	r19, 0x00	; 0
    2866:	28 1b       	sub	r18, r24
    2868:	39 0b       	sbc	r19, r25
    286a:	8a 81       	ldd	r24, Y+2	; 0x02
    286c:	9b 81       	ldd	r25, Y+3	; 0x03
    286e:	fc 01       	movw	r30, r24
    2870:	35 87       	std	Z+13, r19	; 0x0d
    2872:	24 87       	std	Z+12, r18	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    2874:	8a 81       	ldd	r24, Y+2	; 0x02
    2876:	9b 81       	ldd	r25, Y+3	; 0x03
    2878:	fc 01       	movw	r30, r24
    287a:	96 89       	ldd	r25, Z+22	; 0x16
    287c:	80 91 bc 02 	lds	r24, 0x02BC
    2880:	89 17       	cp	r24, r25
    2882:	30 f4       	brcc	.+12     	; 0x2890 <xCoRoutineCreate+0xe8>
    2884:	8a 81       	ldd	r24, Y+2	; 0x02
    2886:	9b 81       	ldd	r25, Y+3	; 0x03
    2888:	fc 01       	movw	r30, r24
    288a:	86 89       	ldd	r24, Z+22	; 0x16
    288c:	80 93 bc 02 	sts	0x02BC, r24
    2890:	8a 81       	ldd	r24, Y+2	; 0x02
    2892:	9b 81       	ldd	r25, Y+3	; 0x03
    2894:	ac 01       	movw	r20, r24
    2896:	4e 5f       	subi	r20, 0xFE	; 254
    2898:	5f 4f       	sbci	r21, 0xFF	; 255
    289a:	8a 81       	ldd	r24, Y+2	; 0x02
    289c:	9b 81       	ldd	r25, Y+3	; 0x03
    289e:	fc 01       	movw	r30, r24
    28a0:	86 89       	ldd	r24, Z+22	; 0x16
    28a2:	28 2f       	mov	r18, r24
    28a4:	30 e0       	ldi	r19, 0x00	; 0
    28a6:	c9 01       	movw	r24, r18
    28a8:	88 0f       	add	r24, r24
    28aa:	99 1f       	adc	r25, r25
    28ac:	88 0f       	add	r24, r24
    28ae:	99 1f       	adc	r25, r25
    28b0:	88 0f       	add	r24, r24
    28b2:	99 1f       	adc	r25, r25
    28b4:	82 0f       	add	r24, r18
    28b6:	93 1f       	adc	r25, r19
    28b8:	85 57       	subi	r24, 0x75	; 117
    28ba:	9d 4f       	sbci	r25, 0xFD	; 253
    28bc:	ba 01       	movw	r22, r20
    28be:	0e 94 ad 12 	call	0x255a	; 0x255a <vListInsertEnd>

		xReturn = pdPASS;
    28c2:	81 e0       	ldi	r24, 0x01	; 1
    28c4:	89 83       	std	Y+1, r24	; 0x01
    28c6:	02 c0       	rjmp	.+4      	; 0x28cc <xCoRoutineCreate+0x124>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    28c8:	8f ef       	ldi	r24, 0xFF	; 255
    28ca:	89 83       	std	Y+1, r24	; 0x01
	}
	
	return xReturn;	
    28cc:	89 81       	ldd	r24, Y+1	; 0x01
}
    28ce:	27 96       	adiw	r28, 0x07	; 7
    28d0:	0f b6       	in	r0, 0x3f	; 63
    28d2:	f8 94       	cli
    28d4:	de bf       	out	0x3e, r29	; 62
    28d6:	0f be       	out	0x3f, r0	; 63
    28d8:	cd bf       	out	0x3d, r28	; 61
    28da:	df 91       	pop	r29
    28dc:	cf 91       	pop	r28
    28de:	08 95       	ret

000028e0 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    28e0:	cf 93       	push	r28
    28e2:	df 93       	push	r29
    28e4:	00 d0       	rcall	.+0      	; 0x28e6 <vCoRoutineAddToDelayedList+0x6>
    28e6:	00 d0       	rcall	.+0      	; 0x28e8 <vCoRoutineAddToDelayedList+0x8>
    28e8:	cd b7       	in	r28, 0x3d	; 61
    28ea:	de b7       	in	r29, 0x3e	; 62
    28ec:	9c 83       	std	Y+4, r25	; 0x04
    28ee:	8b 83       	std	Y+3, r24	; 0x03
    28f0:	7e 83       	std	Y+6, r23	; 0x06
    28f2:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    28f4:	20 91 bd 02 	lds	r18, 0x02BD
    28f8:	30 91 be 02 	lds	r19, 0x02BE
    28fc:	8b 81       	ldd	r24, Y+3	; 0x03
    28fe:	9c 81       	ldd	r25, Y+4	; 0x04
    2900:	82 0f       	add	r24, r18
    2902:	93 1f       	adc	r25, r19
    2904:	9a 83       	std	Y+2, r25	; 0x02
    2906:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2908:	80 91 89 02 	lds	r24, 0x0289
    290c:	90 91 8a 02 	lds	r25, 0x028A
    2910:	02 96       	adiw	r24, 0x02	; 2
    2912:	0e 94 7d 13 	call	0x26fa	; 0x26fa <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    2916:	80 91 89 02 	lds	r24, 0x0289
    291a:	90 91 8a 02 	lds	r25, 0x028A
    291e:	29 81       	ldd	r18, Y+1	; 0x01
    2920:	3a 81       	ldd	r19, Y+2	; 0x02
    2922:	fc 01       	movw	r30, r24
    2924:	33 83       	std	Z+3, r19	; 0x03
    2926:	22 83       	std	Z+2, r18	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    2928:	80 91 bd 02 	lds	r24, 0x02BD
    292c:	90 91 be 02 	lds	r25, 0x02BE
    2930:	29 81       	ldd	r18, Y+1	; 0x01
    2932:	3a 81       	ldd	r19, Y+2	; 0x02
    2934:	28 17       	cp	r18, r24
    2936:	39 07       	cpc	r19, r25
    2938:	78 f4       	brcc	.+30     	; 0x2958 <vCoRoutineAddToDelayedList+0x78>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    293a:	80 91 89 02 	lds	r24, 0x0289
    293e:	90 91 8a 02 	lds	r25, 0x028A
    2942:	9c 01       	movw	r18, r24
    2944:	2e 5f       	subi	r18, 0xFE	; 254
    2946:	3f 4f       	sbci	r19, 0xFF	; 255
    2948:	80 91 b1 02 	lds	r24, 0x02B1
    294c:	90 91 b2 02 	lds	r25, 0x02B2
    2950:	b9 01       	movw	r22, r18
    2952:	0e 94 04 13 	call	0x2608	; 0x2608 <vListInsert>
    2956:	0e c0       	rjmp	.+28     	; 0x2974 <vCoRoutineAddToDelayedList+0x94>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2958:	80 91 89 02 	lds	r24, 0x0289
    295c:	90 91 8a 02 	lds	r25, 0x028A
    2960:	9c 01       	movw	r18, r24
    2962:	2e 5f       	subi	r18, 0xFE	; 254
    2964:	3f 4f       	sbci	r19, 0xFF	; 255
    2966:	80 91 af 02 	lds	r24, 0x02AF
    296a:	90 91 b0 02 	lds	r25, 0x02B0
    296e:	b9 01       	movw	r22, r18
    2970:	0e 94 04 13 	call	0x2608	; 0x2608 <vListInsert>
	}

	if( pxEventList )
    2974:	8d 81       	ldd	r24, Y+5	; 0x05
    2976:	9e 81       	ldd	r25, Y+6	; 0x06
    2978:	00 97       	sbiw	r24, 0x00	; 0
    297a:	61 f0       	breq	.+24     	; 0x2994 <vCoRoutineAddToDelayedList+0xb4>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    297c:	80 91 89 02 	lds	r24, 0x0289
    2980:	90 91 8a 02 	lds	r25, 0x028A
    2984:	9c 01       	movw	r18, r24
    2986:	24 5f       	subi	r18, 0xF4	; 244
    2988:	3f 4f       	sbci	r19, 0xFF	; 255
    298a:	8d 81       	ldd	r24, Y+5	; 0x05
    298c:	9e 81       	ldd	r25, Y+6	; 0x06
    298e:	b9 01       	movw	r22, r18
    2990:	0e 94 04 13 	call	0x2608	; 0x2608 <vListInsert>
	}
}
    2994:	26 96       	adiw	r28, 0x06	; 6
    2996:	0f b6       	in	r0, 0x3f	; 63
    2998:	f8 94       	cli
    299a:	de bf       	out	0x3e, r29	; 62
    299c:	0f be       	out	0x3f, r0	; 63
    299e:	cd bf       	out	0x3d, r28	; 61
    29a0:	df 91       	pop	r29
    29a2:	cf 91       	pop	r28
    29a4:	08 95       	ret

000029a6 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    29a6:	cf 93       	push	r28
    29a8:	df 93       	push	r29
    29aa:	1f 92       	push	r1
    29ac:	1f 92       	push	r1
    29ae:	cd b7       	in	r28, 0x3d	; 61
    29b0:	de b7       	in	r29, 0x3e	; 62
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    29b2:	3c c0       	rjmp	.+120    	; 0x2a2c <prvCheckPendingReadyList+0x86>
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    29b4:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    29b6:	80 91 b8 02 	lds	r24, 0x02B8
    29ba:	90 91 b9 02 	lds	r25, 0x02B9
    29be:	fc 01       	movw	r30, r24
    29c0:	86 81       	ldd	r24, Z+6	; 0x06
    29c2:	97 81       	ldd	r25, Z+7	; 0x07
    29c4:	9a 83       	std	Y+2, r25	; 0x02
    29c6:	89 83       	std	Y+1, r24	; 0x01
			uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    29c8:	89 81       	ldd	r24, Y+1	; 0x01
    29ca:	9a 81       	ldd	r25, Y+2	; 0x02
    29cc:	0c 96       	adiw	r24, 0x0c	; 12
    29ce:	0e 94 7d 13 	call	0x26fa	; 0x26fa <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    29d2:	78 94       	sei

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    29d4:	89 81       	ldd	r24, Y+1	; 0x01
    29d6:	9a 81       	ldd	r25, Y+2	; 0x02
    29d8:	02 96       	adiw	r24, 0x02	; 2
    29da:	0e 94 7d 13 	call	0x26fa	; 0x26fa <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    29de:	89 81       	ldd	r24, Y+1	; 0x01
    29e0:	9a 81       	ldd	r25, Y+2	; 0x02
    29e2:	fc 01       	movw	r30, r24
    29e4:	96 89       	ldd	r25, Z+22	; 0x16
    29e6:	80 91 bc 02 	lds	r24, 0x02BC
    29ea:	89 17       	cp	r24, r25
    29ec:	30 f4       	brcc	.+12     	; 0x29fa <prvCheckPendingReadyList+0x54>
    29ee:	89 81       	ldd	r24, Y+1	; 0x01
    29f0:	9a 81       	ldd	r25, Y+2	; 0x02
    29f2:	fc 01       	movw	r30, r24
    29f4:	86 89       	ldd	r24, Z+22	; 0x16
    29f6:	80 93 bc 02 	sts	0x02BC, r24
    29fa:	89 81       	ldd	r24, Y+1	; 0x01
    29fc:	9a 81       	ldd	r25, Y+2	; 0x02
    29fe:	ac 01       	movw	r20, r24
    2a00:	4e 5f       	subi	r20, 0xFE	; 254
    2a02:	5f 4f       	sbci	r21, 0xFF	; 255
    2a04:	89 81       	ldd	r24, Y+1	; 0x01
    2a06:	9a 81       	ldd	r25, Y+2	; 0x02
    2a08:	fc 01       	movw	r30, r24
    2a0a:	86 89       	ldd	r24, Z+22	; 0x16
    2a0c:	28 2f       	mov	r18, r24
    2a0e:	30 e0       	ldi	r19, 0x00	; 0
    2a10:	c9 01       	movw	r24, r18
    2a12:	88 0f       	add	r24, r24
    2a14:	99 1f       	adc	r25, r25
    2a16:	88 0f       	add	r24, r24
    2a18:	99 1f       	adc	r25, r25
    2a1a:	88 0f       	add	r24, r24
    2a1c:	99 1f       	adc	r25, r25
    2a1e:	82 0f       	add	r24, r18
    2a20:	93 1f       	adc	r25, r19
    2a22:	85 57       	subi	r24, 0x75	; 117
    2a24:	9d 4f       	sbci	r25, 0xFD	; 253
    2a26:	ba 01       	movw	r22, r20
    2a28:	0e 94 ad 12 	call	0x255a	; 0x255a <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    2a2c:	80 91 b3 02 	lds	r24, 0x02B3
    2a30:	88 23       	and	r24, r24
    2a32:	09 f0       	breq	.+2      	; 0x2a36 <prvCheckPendingReadyList+0x90>
    2a34:	bf cf       	rjmp	.-130    	; 0x29b4 <prvCheckPendingReadyList+0xe>
		portENABLE_INTERRUPTS();

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    2a36:	0f 90       	pop	r0
    2a38:	0f 90       	pop	r0
    2a3a:	df 91       	pop	r29
    2a3c:	cf 91       	pop	r28
    2a3e:	08 95       	ret

00002a40 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    2a40:	cf 93       	push	r28
    2a42:	df 93       	push	r29
    2a44:	00 d0       	rcall	.+0      	; 0x2a46 <prvCheckDelayedList+0x6>
    2a46:	1f 92       	push	r1
    2a48:	cd b7       	in	r28, 0x3d	; 61
    2a4a:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    2a4c:	0e 94 2e 07 	call	0xe5c	; 0xe5c <xTaskGetTickCount>
    2a50:	9c 01       	movw	r18, r24
    2a52:	80 91 bf 02 	lds	r24, 0x02BF
    2a56:	90 91 c0 02 	lds	r25, 0x02C0
    2a5a:	a9 01       	movw	r20, r18
    2a5c:	48 1b       	sub	r20, r24
    2a5e:	59 0b       	sbc	r21, r25
    2a60:	ca 01       	movw	r24, r20
    2a62:	90 93 c2 02 	sts	0x02C2, r25
    2a66:	80 93 c1 02 	sts	0x02C1, r24
	while( xPassedTicks )
    2a6a:	8a c0       	rjmp	.+276    	; 0x2b80 <prvCheckDelayedList+0x140>
	{
		xCoRoutineTickCount++;
    2a6c:	80 91 bd 02 	lds	r24, 0x02BD
    2a70:	90 91 be 02 	lds	r25, 0x02BE
    2a74:	01 96       	adiw	r24, 0x01	; 1
    2a76:	90 93 be 02 	sts	0x02BE, r25
    2a7a:	80 93 bd 02 	sts	0x02BD, r24
		xPassedTicks--;
    2a7e:	80 91 c1 02 	lds	r24, 0x02C1
    2a82:	90 91 c2 02 	lds	r25, 0x02C2
    2a86:	01 97       	sbiw	r24, 0x01	; 1
    2a88:	90 93 c2 02 	sts	0x02C2, r25
    2a8c:	80 93 c1 02 	sts	0x02C1, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    2a90:	80 91 bd 02 	lds	r24, 0x02BD
    2a94:	90 91 be 02 	lds	r25, 0x02BE
    2a98:	00 97       	sbiw	r24, 0x00	; 0
    2a9a:	a9 f4       	brne	.+42     	; 0x2ac6 <prvCheckDelayedList+0x86>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    2a9c:	80 91 af 02 	lds	r24, 0x02AF
    2aa0:	90 91 b0 02 	lds	r25, 0x02B0
    2aa4:	9a 83       	std	Y+2, r25	; 0x02
    2aa6:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    2aa8:	80 91 b1 02 	lds	r24, 0x02B1
    2aac:	90 91 b2 02 	lds	r25, 0x02B2
    2ab0:	90 93 b0 02 	sts	0x02B0, r25
    2ab4:	80 93 af 02 	sts	0x02AF, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    2ab8:	89 81       	ldd	r24, Y+1	; 0x01
    2aba:	9a 81       	ldd	r25, Y+2	; 0x02
    2abc:	90 93 b2 02 	sts	0x02B2, r25
    2ac0:	80 93 b1 02 	sts	0x02B1, r24
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    2ac4:	54 c0       	rjmp	.+168    	; 0x2b6e <prvCheckDelayedList+0x12e>
    2ac6:	53 c0       	rjmp	.+166    	; 0x2b6e <prvCheckDelayedList+0x12e>
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    2ac8:	80 91 af 02 	lds	r24, 0x02AF
    2acc:	90 91 b0 02 	lds	r25, 0x02B0
    2ad0:	fc 01       	movw	r30, r24
    2ad2:	85 81       	ldd	r24, Z+5	; 0x05
    2ad4:	96 81       	ldd	r25, Z+6	; 0x06
    2ad6:	fc 01       	movw	r30, r24
    2ad8:	86 81       	ldd	r24, Z+6	; 0x06
    2ada:	97 81       	ldd	r25, Z+7	; 0x07
    2adc:	9c 83       	std	Y+4, r25	; 0x04
    2ade:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    2ae0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ae2:	9c 81       	ldd	r25, Y+4	; 0x04
    2ae4:	fc 01       	movw	r30, r24
    2ae6:	22 81       	ldd	r18, Z+2	; 0x02
    2ae8:	33 81       	ldd	r19, Z+3	; 0x03
    2aea:	80 91 bd 02 	lds	r24, 0x02BD
    2aee:	90 91 be 02 	lds	r25, 0x02BE
    2af2:	82 17       	cp	r24, r18
    2af4:	93 07       	cpc	r25, r19
    2af6:	08 f4       	brcc	.+2      	; 0x2afa <prvCheckDelayedList+0xba>
			{			
				/* Timeout not yet expired. */																			
				break;																				
    2af8:	43 c0       	rjmp	.+134    	; 0x2b80 <prvCheckDelayedList+0x140>
			}																						

			portDISABLE_INTERRUPTS();
    2afa:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				uxListRemove( &( pxCRCB->xGenericListItem ) );											
    2afc:	8b 81       	ldd	r24, Y+3	; 0x03
    2afe:	9c 81       	ldd	r25, Y+4	; 0x04
    2b00:	02 96       	adiw	r24, 0x02	; 2
    2b02:	0e 94 7d 13 	call	0x26fa	; 0x26fa <uxListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    2b06:	8b 81       	ldd	r24, Y+3	; 0x03
    2b08:	9c 81       	ldd	r25, Y+4	; 0x04
    2b0a:	fc 01       	movw	r30, r24
    2b0c:	84 89       	ldd	r24, Z+20	; 0x14
    2b0e:	95 89       	ldd	r25, Z+21	; 0x15
    2b10:	00 97       	sbiw	r24, 0x00	; 0
    2b12:	29 f0       	breq	.+10     	; 0x2b1e <prvCheckDelayedList+0xde>
				{															
					uxListRemove( &( pxCRCB->xEventListItem ) );											
    2b14:	8b 81       	ldd	r24, Y+3	; 0x03
    2b16:	9c 81       	ldd	r25, Y+4	; 0x04
    2b18:	0c 96       	adiw	r24, 0x0c	; 12
    2b1a:	0e 94 7d 13 	call	0x26fa	; 0x26fa <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    2b1e:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    2b20:	8b 81       	ldd	r24, Y+3	; 0x03
    2b22:	9c 81       	ldd	r25, Y+4	; 0x04
    2b24:	fc 01       	movw	r30, r24
    2b26:	96 89       	ldd	r25, Z+22	; 0x16
    2b28:	80 91 bc 02 	lds	r24, 0x02BC
    2b2c:	89 17       	cp	r24, r25
    2b2e:	30 f4       	brcc	.+12     	; 0x2b3c <prvCheckDelayedList+0xfc>
    2b30:	8b 81       	ldd	r24, Y+3	; 0x03
    2b32:	9c 81       	ldd	r25, Y+4	; 0x04
    2b34:	fc 01       	movw	r30, r24
    2b36:	86 89       	ldd	r24, Z+22	; 0x16
    2b38:	80 93 bc 02 	sts	0x02BC, r24
    2b3c:	8b 81       	ldd	r24, Y+3	; 0x03
    2b3e:	9c 81       	ldd	r25, Y+4	; 0x04
    2b40:	ac 01       	movw	r20, r24
    2b42:	4e 5f       	subi	r20, 0xFE	; 254
    2b44:	5f 4f       	sbci	r21, 0xFF	; 255
    2b46:	8b 81       	ldd	r24, Y+3	; 0x03
    2b48:	9c 81       	ldd	r25, Y+4	; 0x04
    2b4a:	fc 01       	movw	r30, r24
    2b4c:	86 89       	ldd	r24, Z+22	; 0x16
    2b4e:	28 2f       	mov	r18, r24
    2b50:	30 e0       	ldi	r19, 0x00	; 0
    2b52:	c9 01       	movw	r24, r18
    2b54:	88 0f       	add	r24, r24
    2b56:	99 1f       	adc	r25, r25
    2b58:	88 0f       	add	r24, r24
    2b5a:	99 1f       	adc	r25, r25
    2b5c:	88 0f       	add	r24, r24
    2b5e:	99 1f       	adc	r25, r25
    2b60:	82 0f       	add	r24, r18
    2b62:	93 1f       	adc	r25, r19
    2b64:	85 57       	subi	r24, 0x75	; 117
    2b66:	9d 4f       	sbci	r25, 0xFD	; 253
    2b68:	ba 01       	movw	r22, r20
    2b6a:	0e 94 ad 12 	call	0x255a	; 0x255a <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    2b6e:	80 91 af 02 	lds	r24, 0x02AF
    2b72:	90 91 b0 02 	lds	r25, 0x02B0
    2b76:	fc 01       	movw	r30, r24
    2b78:	80 81       	ld	r24, Z
    2b7a:	88 23       	and	r24, r24
    2b7c:	09 f0       	breq	.+2      	; 0x2b80 <prvCheckDelayedList+0x140>
    2b7e:	a4 cf       	rjmp	.-184    	; 0x2ac8 <prvCheckDelayedList+0x88>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    2b80:	80 91 c1 02 	lds	r24, 0x02C1
    2b84:	90 91 c2 02 	lds	r25, 0x02C2
    2b88:	00 97       	sbiw	r24, 0x00	; 0
    2b8a:	09 f0       	breq	.+2      	; 0x2b8e <prvCheckDelayedList+0x14e>
    2b8c:	6f cf       	rjmp	.-290    	; 0x2a6c <prvCheckDelayedList+0x2c>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    2b8e:	80 91 bd 02 	lds	r24, 0x02BD
    2b92:	90 91 be 02 	lds	r25, 0x02BE
    2b96:	90 93 c0 02 	sts	0x02C0, r25
    2b9a:	80 93 bf 02 	sts	0x02BF, r24
}
    2b9e:	0f 90       	pop	r0
    2ba0:	0f 90       	pop	r0
    2ba2:	0f 90       	pop	r0
    2ba4:	0f 90       	pop	r0
    2ba6:	df 91       	pop	r29
    2ba8:	cf 91       	pop	r28
    2baa:	08 95       	ret

00002bac <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    2bac:	cf 93       	push	r28
    2bae:	df 93       	push	r29
    2bb0:	1f 92       	push	r1
    2bb2:	1f 92       	push	r1
    2bb4:	cd b7       	in	r28, 0x3d	; 61
    2bb6:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    2bb8:	0e 94 d3 14 	call	0x29a6	; 0x29a6 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    2bbc:	0e 94 20 15 	call	0x2a40	; 0x2a40 <prvCheckDelayedList>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2bc0:	0a c0       	rjmp	.+20     	; 0x2bd6 <vCoRoutineSchedule+0x2a>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    2bc2:	80 91 bc 02 	lds	r24, 0x02BC
    2bc6:	88 23       	and	r24, r24
    2bc8:	09 f4       	brne	.+2      	; 0x2bcc <vCoRoutineSchedule+0x20>
		{
			/* No more co-routines to check. */
			return;
    2bca:	6f c0       	rjmp	.+222    	; 0x2caa <vCoRoutineSchedule+0xfe>
		}
		--uxTopCoRoutineReadyPriority;
    2bcc:	80 91 bc 02 	lds	r24, 0x02BC
    2bd0:	81 50       	subi	r24, 0x01	; 1
    2bd2:	80 93 bc 02 	sts	0x02BC, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2bd6:	80 91 bc 02 	lds	r24, 0x02BC
    2bda:	28 2f       	mov	r18, r24
    2bdc:	30 e0       	ldi	r19, 0x00	; 0
    2bde:	c9 01       	movw	r24, r18
    2be0:	88 0f       	add	r24, r24
    2be2:	99 1f       	adc	r25, r25
    2be4:	88 0f       	add	r24, r24
    2be6:	99 1f       	adc	r25, r25
    2be8:	88 0f       	add	r24, r24
    2bea:	99 1f       	adc	r25, r25
    2bec:	82 0f       	add	r24, r18
    2bee:	93 1f       	adc	r25, r19
    2bf0:	85 57       	subi	r24, 0x75	; 117
    2bf2:	9d 4f       	sbci	r25, 0xFD	; 253
    2bf4:	fc 01       	movw	r30, r24
    2bf6:	80 81       	ld	r24, Z
    2bf8:	88 23       	and	r24, r24
    2bfa:	19 f3       	breq	.-58     	; 0x2bc2 <vCoRoutineSchedule+0x16>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    2bfc:	80 91 bc 02 	lds	r24, 0x02BC
    2c00:	28 2f       	mov	r18, r24
    2c02:	30 e0       	ldi	r19, 0x00	; 0
    2c04:	c9 01       	movw	r24, r18
    2c06:	88 0f       	add	r24, r24
    2c08:	99 1f       	adc	r25, r25
    2c0a:	88 0f       	add	r24, r24
    2c0c:	99 1f       	adc	r25, r25
    2c0e:	88 0f       	add	r24, r24
    2c10:	99 1f       	adc	r25, r25
    2c12:	82 0f       	add	r24, r18
    2c14:	93 1f       	adc	r25, r19
    2c16:	85 57       	subi	r24, 0x75	; 117
    2c18:	9d 4f       	sbci	r25, 0xFD	; 253
    2c1a:	9a 83       	std	Y+2, r25	; 0x02
    2c1c:	89 83       	std	Y+1, r24	; 0x01
    2c1e:	89 81       	ldd	r24, Y+1	; 0x01
    2c20:	9a 81       	ldd	r25, Y+2	; 0x02
    2c22:	fc 01       	movw	r30, r24
    2c24:	81 81       	ldd	r24, Z+1	; 0x01
    2c26:	92 81       	ldd	r25, Z+2	; 0x02
    2c28:	fc 01       	movw	r30, r24
    2c2a:	22 81       	ldd	r18, Z+2	; 0x02
    2c2c:	33 81       	ldd	r19, Z+3	; 0x03
    2c2e:	89 81       	ldd	r24, Y+1	; 0x01
    2c30:	9a 81       	ldd	r25, Y+2	; 0x02
    2c32:	fc 01       	movw	r30, r24
    2c34:	32 83       	std	Z+2, r19	; 0x02
    2c36:	21 83       	std	Z+1, r18	; 0x01
    2c38:	89 81       	ldd	r24, Y+1	; 0x01
    2c3a:	9a 81       	ldd	r25, Y+2	; 0x02
    2c3c:	fc 01       	movw	r30, r24
    2c3e:	21 81       	ldd	r18, Z+1	; 0x01
    2c40:	32 81       	ldd	r19, Z+2	; 0x02
    2c42:	89 81       	ldd	r24, Y+1	; 0x01
    2c44:	9a 81       	ldd	r25, Y+2	; 0x02
    2c46:	03 96       	adiw	r24, 0x03	; 3
    2c48:	28 17       	cp	r18, r24
    2c4a:	39 07       	cpc	r19, r25
    2c4c:	69 f4       	brne	.+26     	; 0x2c68 <vCoRoutineSchedule+0xbc>
    2c4e:	89 81       	ldd	r24, Y+1	; 0x01
    2c50:	9a 81       	ldd	r25, Y+2	; 0x02
    2c52:	fc 01       	movw	r30, r24
    2c54:	81 81       	ldd	r24, Z+1	; 0x01
    2c56:	92 81       	ldd	r25, Z+2	; 0x02
    2c58:	fc 01       	movw	r30, r24
    2c5a:	22 81       	ldd	r18, Z+2	; 0x02
    2c5c:	33 81       	ldd	r19, Z+3	; 0x03
    2c5e:	89 81       	ldd	r24, Y+1	; 0x01
    2c60:	9a 81       	ldd	r25, Y+2	; 0x02
    2c62:	fc 01       	movw	r30, r24
    2c64:	32 83       	std	Z+2, r19	; 0x02
    2c66:	21 83       	std	Z+1, r18	; 0x01
    2c68:	89 81       	ldd	r24, Y+1	; 0x01
    2c6a:	9a 81       	ldd	r25, Y+2	; 0x02
    2c6c:	fc 01       	movw	r30, r24
    2c6e:	81 81       	ldd	r24, Z+1	; 0x01
    2c70:	92 81       	ldd	r25, Z+2	; 0x02
    2c72:	fc 01       	movw	r30, r24
    2c74:	86 81       	ldd	r24, Z+6	; 0x06
    2c76:	97 81       	ldd	r25, Z+7	; 0x07
    2c78:	90 93 8a 02 	sts	0x028A, r25
    2c7c:	80 93 89 02 	sts	0x0289, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2c80:	80 91 89 02 	lds	r24, 0x0289
    2c84:	90 91 8a 02 	lds	r25, 0x028A
    2c88:	fc 01       	movw	r30, r24
    2c8a:	20 81       	ld	r18, Z
    2c8c:	31 81       	ldd	r19, Z+1	; 0x01
    2c8e:	80 91 89 02 	lds	r24, 0x0289
    2c92:	90 91 8a 02 	lds	r25, 0x028A
    2c96:	fc 01       	movw	r30, r24
    2c98:	47 89       	ldd	r20, Z+23	; 0x17
    2c9a:	80 91 89 02 	lds	r24, 0x0289
    2c9e:	90 91 8a 02 	lds	r25, 0x028A
    2ca2:	64 2f       	mov	r22, r20
    2ca4:	f9 01       	movw	r30, r18
    2ca6:	19 95       	eicall

	return;
    2ca8:	00 00       	nop
}
    2caa:	0f 90       	pop	r0
    2cac:	0f 90       	pop	r0
    2cae:	df 91       	pop	r29
    2cb0:	cf 91       	pop	r28
    2cb2:	08 95       	ret

00002cb4 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    2cb4:	cf 93       	push	r28
    2cb6:	df 93       	push	r29
    2cb8:	1f 92       	push	r1
    2cba:	cd b7       	in	r28, 0x3d	; 61
    2cbc:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2cbe:	19 82       	std	Y+1, r1	; 0x01
    2cc0:	13 c0       	rjmp	.+38     	; 0x2ce8 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    2cc2:	89 81       	ldd	r24, Y+1	; 0x01
    2cc4:	28 2f       	mov	r18, r24
    2cc6:	30 e0       	ldi	r19, 0x00	; 0
    2cc8:	c9 01       	movw	r24, r18
    2cca:	88 0f       	add	r24, r24
    2ccc:	99 1f       	adc	r25, r25
    2cce:	88 0f       	add	r24, r24
    2cd0:	99 1f       	adc	r25, r25
    2cd2:	88 0f       	add	r24, r24
    2cd4:	99 1f       	adc	r25, r25
    2cd6:	82 0f       	add	r24, r18
    2cd8:	93 1f       	adc	r25, r19
    2cda:	85 57       	subi	r24, 0x75	; 117
    2cdc:	9d 4f       	sbci	r25, 0xFD	; 253
    2cde:	0e 94 65 12 	call	0x24ca	; 0x24ca <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2ce2:	89 81       	ldd	r24, Y+1	; 0x01
    2ce4:	8f 5f       	subi	r24, 0xFF	; 255
    2ce6:	89 83       	std	Y+1, r24	; 0x01
    2ce8:	89 81       	ldd	r24, Y+1	; 0x01
    2cea:	82 30       	cpi	r24, 0x02	; 2
    2cec:	50 f3       	brcs	.-44     	; 0x2cc2 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    2cee:	8d e9       	ldi	r24, 0x9D	; 157
    2cf0:	92 e0       	ldi	r25, 0x02	; 2
    2cf2:	0e 94 65 12 	call	0x24ca	; 0x24ca <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    2cf6:	86 ea       	ldi	r24, 0xA6	; 166
    2cf8:	92 e0       	ldi	r25, 0x02	; 2
    2cfa:	0e 94 65 12 	call	0x24ca	; 0x24ca <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    2cfe:	83 eb       	ldi	r24, 0xB3	; 179
    2d00:	92 e0       	ldi	r25, 0x02	; 2
    2d02:	0e 94 65 12 	call	0x24ca	; 0x24ca <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    2d06:	8d e9       	ldi	r24, 0x9D	; 157
    2d08:	92 e0       	ldi	r25, 0x02	; 2
    2d0a:	90 93 b0 02 	sts	0x02B0, r25
    2d0e:	80 93 af 02 	sts	0x02AF, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    2d12:	86 ea       	ldi	r24, 0xA6	; 166
    2d14:	92 e0       	ldi	r25, 0x02	; 2
    2d16:	90 93 b2 02 	sts	0x02B2, r25
    2d1a:	80 93 b1 02 	sts	0x02B1, r24
}
    2d1e:	0f 90       	pop	r0
    2d20:	df 91       	pop	r29
    2d22:	cf 91       	pop	r28
    2d24:	08 95       	ret

00002d26 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    2d26:	cf 93       	push	r28
    2d28:	df 93       	push	r29
    2d2a:	00 d0       	rcall	.+0      	; 0x2d2c <xCoRoutineRemoveFromEventList+0x6>
    2d2c:	1f 92       	push	r1
    2d2e:	1f 92       	push	r1
    2d30:	cd b7       	in	r28, 0x3d	; 61
    2d32:	de b7       	in	r29, 0x3e	; 62
    2d34:	9d 83       	std	Y+5, r25	; 0x05
    2d36:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2d38:	8c 81       	ldd	r24, Y+4	; 0x04
    2d3a:	9d 81       	ldd	r25, Y+5	; 0x05
    2d3c:	fc 01       	movw	r30, r24
    2d3e:	85 81       	ldd	r24, Z+5	; 0x05
    2d40:	96 81       	ldd	r25, Z+6	; 0x06
    2d42:	fc 01       	movw	r30, r24
    2d44:	86 81       	ldd	r24, Z+6	; 0x06
    2d46:	97 81       	ldd	r25, Z+7	; 0x07
    2d48:	9b 83       	std	Y+3, r25	; 0x03
    2d4a:	8a 83       	std	Y+2, r24	; 0x02
	uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2d4c:	8a 81       	ldd	r24, Y+2	; 0x02
    2d4e:	9b 81       	ldd	r25, Y+3	; 0x03
    2d50:	0c 96       	adiw	r24, 0x0c	; 12
    2d52:	0e 94 7d 13 	call	0x26fa	; 0x26fa <uxListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    2d56:	8a 81       	ldd	r24, Y+2	; 0x02
    2d58:	9b 81       	ldd	r25, Y+3	; 0x03
    2d5a:	0c 96       	adiw	r24, 0x0c	; 12
    2d5c:	bc 01       	movw	r22, r24
    2d5e:	83 eb       	ldi	r24, 0xB3	; 179
    2d60:	92 e0       	ldi	r25, 0x02	; 2
    2d62:	0e 94 ad 12 	call	0x255a	; 0x255a <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    2d66:	8a 81       	ldd	r24, Y+2	; 0x02
    2d68:	9b 81       	ldd	r25, Y+3	; 0x03
    2d6a:	fc 01       	movw	r30, r24
    2d6c:	26 89       	ldd	r18, Z+22	; 0x16
    2d6e:	80 91 89 02 	lds	r24, 0x0289
    2d72:	90 91 8a 02 	lds	r25, 0x028A
    2d76:	fc 01       	movw	r30, r24
    2d78:	86 89       	ldd	r24, Z+22	; 0x16
    2d7a:	28 17       	cp	r18, r24
    2d7c:	18 f0       	brcs	.+6      	; 0x2d84 <xCoRoutineRemoveFromEventList+0x5e>
	{
		xReturn = pdTRUE;
    2d7e:	81 e0       	ldi	r24, 0x01	; 1
    2d80:	89 83       	std	Y+1, r24	; 0x01
    2d82:	01 c0       	rjmp	.+2      	; 0x2d86 <xCoRoutineRemoveFromEventList+0x60>
	}
	else
	{
		xReturn = pdFALSE;
    2d84:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2d86:	89 81       	ldd	r24, Y+1	; 0x01
}
    2d88:	0f 90       	pop	r0
    2d8a:	0f 90       	pop	r0
    2d8c:	0f 90       	pop	r0
    2d8e:	0f 90       	pop	r0
    2d90:	0f 90       	pop	r0
    2d92:	df 91       	pop	r29
    2d94:	cf 91       	pop	r28
    2d96:	08 95       	ret

00002d98 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2d98:	cf 93       	push	r28
    2d9a:	df 93       	push	r29
    2d9c:	00 d0       	rcall	.+0      	; 0x2d9e <pvPortMalloc+0x6>
    2d9e:	1f 92       	push	r1
    2da0:	cd b7       	in	r28, 0x3d	; 61
    2da2:	de b7       	in	r29, 0x3e	; 62
    2da4:	9c 83       	std	Y+4, r25	; 0x04
    2da6:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    2da8:	1a 82       	std	Y+2, r1	; 0x02
    2daa:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    2dac:	0e 94 9e 06 	call	0xd3c	; 0xd3c <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    2db0:	20 91 c3 1a 	lds	r18, 0x1AC3
    2db4:	30 91 c4 1a 	lds	r19, 0x1AC4
    2db8:	8b 81       	ldd	r24, Y+3	; 0x03
    2dba:	9c 81       	ldd	r25, Y+4	; 0x04
    2dbc:	82 0f       	add	r24, r18
    2dbe:	93 1f       	adc	r25, r19
    2dc0:	81 15       	cp	r24, r1
    2dc2:	28 e1       	ldi	r18, 0x18	; 24
    2dc4:	92 07       	cpc	r25, r18
    2dc6:	18 f5       	brcc	.+70     	; 0x2e0e <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
    2dc8:	20 91 c3 1a 	lds	r18, 0x1AC3
    2dcc:	30 91 c4 1a 	lds	r19, 0x1AC4
    2dd0:	8b 81       	ldd	r24, Y+3	; 0x03
    2dd2:	9c 81       	ldd	r25, Y+4	; 0x04
    2dd4:	28 0f       	add	r18, r24
    2dd6:	39 1f       	adc	r19, r25
    2dd8:	80 91 c3 1a 	lds	r24, 0x1AC3
    2ddc:	90 91 c4 1a 	lds	r25, 0x1AC4
	#endif

	vTaskSuspendAll();
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    2de0:	82 17       	cp	r24, r18
    2de2:	93 07       	cpc	r25, r19
    2de4:	a0 f4       	brcc	.+40     	; 0x2e0e <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    2de6:	80 91 c3 1a 	lds	r24, 0x1AC3
    2dea:	90 91 c4 1a 	lds	r25, 0x1AC4
    2dee:	8d 53       	subi	r24, 0x3D	; 61
    2df0:	9d 4f       	sbci	r25, 0xFD	; 253
    2df2:	9a 83       	std	Y+2, r25	; 0x02
    2df4:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    2df6:	20 91 c3 1a 	lds	r18, 0x1AC3
    2dfa:	30 91 c4 1a 	lds	r19, 0x1AC4
    2dfe:	8b 81       	ldd	r24, Y+3	; 0x03
    2e00:	9c 81       	ldd	r25, Y+4	; 0x04
    2e02:	82 0f       	add	r24, r18
    2e04:	93 1f       	adc	r25, r19
    2e06:	90 93 c4 1a 	sts	0x1AC4, r25
    2e0a:	80 93 c3 1a 	sts	0x1AC3, r24
		}
	}
	xTaskResumeAll();
    2e0e:	0e 94 aa 06 	call	0xd54	; 0xd54 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    2e12:	89 81       	ldd	r24, Y+1	; 0x01
    2e14:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2e16:	0f 90       	pop	r0
    2e18:	0f 90       	pop	r0
    2e1a:	0f 90       	pop	r0
    2e1c:	0f 90       	pop	r0
    2e1e:	df 91       	pop	r29
    2e20:	cf 91       	pop	r28
    2e22:	08 95       	ret

00002e24 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2e24:	cf 93       	push	r28
    2e26:	df 93       	push	r29
    2e28:	1f 92       	push	r1
    2e2a:	1f 92       	push	r1
    2e2c:	cd b7       	in	r28, 0x3d	; 61
    2e2e:	de b7       	in	r29, 0x3e	; 62
    2e30:	9a 83       	std	Y+2, r25	; 0x02
    2e32:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    2e34:	0f 90       	pop	r0
    2e36:	0f 90       	pop	r0
    2e38:	df 91       	pop	r29
    2e3a:	cf 91       	pop	r28
    2e3c:	08 95       	ret

00002e3e <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    2e3e:	cf 93       	push	r28
    2e40:	df 93       	push	r29
    2e42:	cd b7       	in	r28, 0x3d	; 61
    2e44:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    2e46:	10 92 c4 1a 	sts	0x1AC4, r1
    2e4a:	10 92 c3 1a 	sts	0x1AC3, r1
}
    2e4e:	df 91       	pop	r29
    2e50:	cf 91       	pop	r28
    2e52:	08 95       	ret

00002e54 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    2e54:	cf 93       	push	r28
    2e56:	df 93       	push	r29
    2e58:	cd b7       	in	r28, 0x3d	; 61
    2e5a:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    2e5c:	80 91 c3 1a 	lds	r24, 0x1AC3
    2e60:	90 91 c4 1a 	lds	r25, 0x1AC4
    2e64:	20 e0       	ldi	r18, 0x00	; 0
    2e66:	38 e1       	ldi	r19, 0x18	; 24
    2e68:	a9 01       	movw	r20, r18
    2e6a:	48 1b       	sub	r20, r24
    2e6c:	59 0b       	sbc	r21, r25
    2e6e:	ca 01       	movw	r24, r20
}
    2e70:	df 91       	pop	r29
    2e72:	cf 91       	pop	r28
    2e74:	08 95       	ret

00002e76 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    2e76:	cf 93       	push	r28
    2e78:	df 93       	push	r29
    2e7a:	cd b7       	in	r28, 0x3d	; 61
    2e7c:	de b7       	in	r29, 0x3e	; 62
    2e7e:	28 97       	sbiw	r28, 0x08	; 8
    2e80:	0f b6       	in	r0, 0x3f	; 63
    2e82:	f8 94       	cli
    2e84:	de bf       	out	0x3e, r29	; 62
    2e86:	0f be       	out	0x3f, r0	; 63
    2e88:	cd bf       	out	0x3d, r28	; 61
    2e8a:	9c 83       	std	Y+4, r25	; 0x04
    2e8c:	8b 83       	std	Y+3, r24	; 0x03
    2e8e:	7e 83       	std	Y+6, r23	; 0x06
    2e90:	6d 83       	std	Y+5, r22	; 0x05
    2e92:	58 87       	std	Y+8, r21	; 0x08
    2e94:	4f 83       	std	Y+7, r20	; 0x07
#endif

	/* Place a few bytes of known values on the bottom of the stack.
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2e96:	8b 81       	ldd	r24, Y+3	; 0x03
    2e98:	9c 81       	ldd	r25, Y+4	; 0x04
    2e9a:	21 e1       	ldi	r18, 0x11	; 17
    2e9c:	fc 01       	movw	r30, r24
    2e9e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ea0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ea2:	9c 81       	ldd	r25, Y+4	; 0x04
    2ea4:	01 97       	sbiw	r24, 0x01	; 1
    2ea6:	9c 83       	std	Y+4, r25	; 0x04
    2ea8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    2eaa:	8b 81       	ldd	r24, Y+3	; 0x03
    2eac:	9c 81       	ldd	r25, Y+4	; 0x04
    2eae:	22 e2       	ldi	r18, 0x22	; 34
    2eb0:	fc 01       	movw	r30, r24
    2eb2:	20 83       	st	Z, r18
	pxTopOfStack--;
    2eb4:	8b 81       	ldd	r24, Y+3	; 0x03
    2eb6:	9c 81       	ldd	r25, Y+4	; 0x04
    2eb8:	01 97       	sbiw	r24, 0x01	; 1
    2eba:	9c 83       	std	Y+4, r25	; 0x04
    2ebc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    2ebe:	8b 81       	ldd	r24, Y+3	; 0x03
    2ec0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ec2:	23 e3       	ldi	r18, 0x33	; 51
    2ec4:	fc 01       	movw	r30, r24
    2ec6:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ec8:	8b 81       	ldd	r24, Y+3	; 0x03
    2eca:	9c 81       	ldd	r25, Y+4	; 0x04
    2ecc:	01 97       	sbiw	r24, 0x01	; 1
    2ece:	9c 83       	std	Y+4, r25	; 0x04
    2ed0:	8b 83       	std	Y+3, r24	; 0x03
	 * of flash. We do this by adding the .task label in the linker script.
	 *
	 * In order to do this properly, we would need to get a full 3-byte pointer to
	 * pxCode.  That requires a change to GCC.  Not likely to happen any time soon.
	 */
	usAddress = ( unsigned portSHORT ) pxCode;
    2ed2:	8d 81       	ldd	r24, Y+5	; 0x05
    2ed4:	9e 81       	ldd	r25, Y+6	; 0x06
    2ed6:	9a 83       	std	Y+2, r25	; 0x02
    2ed8:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    2eda:	29 81       	ldd	r18, Y+1	; 0x01
    2edc:	8b 81       	ldd	r24, Y+3	; 0x03
    2ede:	9c 81       	ldd	r25, Y+4	; 0x04
    2ee0:	fc 01       	movw	r30, r24
    2ee2:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ee4:	8b 81       	ldd	r24, Y+3	; 0x03
    2ee6:	9c 81       	ldd	r25, Y+4	; 0x04
    2ee8:	01 97       	sbiw	r24, 0x01	; 1
    2eea:	9c 83       	std	Y+4, r25	; 0x04
    2eec:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2eee:	89 81       	ldd	r24, Y+1	; 0x01
    2ef0:	9a 81       	ldd	r25, Y+2	; 0x02
    2ef2:	89 2f       	mov	r24, r25
    2ef4:	99 27       	eor	r25, r25
    2ef6:	9a 83       	std	Y+2, r25	; 0x02
    2ef8:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    2efa:	29 81       	ldd	r18, Y+1	; 0x01
    2efc:	8b 81       	ldd	r24, Y+3	; 0x03
    2efe:	9c 81       	ldd	r25, Y+4	; 0x04
    2f00:	fc 01       	movw	r30, r24
    2f02:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f04:	8b 81       	ldd	r24, Y+3	; 0x03
    2f06:	9c 81       	ldd	r25, Y+4	; 0x04
    2f08:	01 97       	sbiw	r24, 0x01	; 1
    2f0a:	9c 83       	std	Y+4, r25	; 0x04
    2f0c:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = 0;
    2f0e:	8b 81       	ldd	r24, Y+3	; 0x03
    2f10:	9c 81       	ldd	r25, Y+4	; 0x04
    2f12:	fc 01       	movw	r30, r24
    2f14:	10 82       	st	Z, r1
	pxTopOfStack--;
    2f16:	8b 81       	ldd	r24, Y+3	; 0x03
    2f18:	9c 81       	ldd	r25, Y+4	; 0x04
    2f1a:	01 97       	sbiw	r24, 0x01	; 1
    2f1c:	9c 83       	std	Y+4, r25	; 0x04
    2f1e:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    2f20:	8b 81       	ldd	r24, Y+3	; 0x03
    2f22:	9c 81       	ldd	r25, Y+4	; 0x04
    2f24:	fc 01       	movw	r30, r24
    2f26:	10 82       	st	Z, r1
	pxTopOfStack--;
    2f28:	8b 81       	ldd	r24, Y+3	; 0x03
    2f2a:	9c 81       	ldd	r25, Y+4	; 0x04
    2f2c:	01 97       	sbiw	r24, 0x01	; 1
    2f2e:	9c 83       	std	Y+4, r25	; 0x04
    2f30:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2f32:	8b 81       	ldd	r24, Y+3	; 0x03
    2f34:	9c 81       	ldd	r25, Y+4	; 0x04
    2f36:	20 e8       	ldi	r18, 0x80	; 128
    2f38:	fc 01       	movw	r30, r24
    2f3a:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f3c:	8b 81       	ldd	r24, Y+3	; 0x03
    2f3e:	9c 81       	ldd	r25, Y+4	; 0x04
    2f40:	01 97       	sbiw	r24, 0x01	; 1
    2f42:	9c 83       	std	Y+4, r25	; 0x04
    2f44:	8b 83       	std	Y+3, r24	; 0x03
#if defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

	/* If we have an ATmega256x, we are also saving the RAMPZ and EIND registers.
	 * We should default those to 0.
	 */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* EIND */
    2f46:	8b 81       	ldd	r24, Y+3	; 0x03
    2f48:	9c 81       	ldd	r25, Y+4	; 0x04
    2f4a:	fc 01       	movw	r30, r24
    2f4c:	10 82       	st	Z, r1
	pxTopOfStack--;
    2f4e:	8b 81       	ldd	r24, Y+3	; 0x03
    2f50:	9c 81       	ldd	r25, Y+4	; 0x04
    2f52:	01 97       	sbiw	r24, 0x01	; 1
    2f54:	9c 83       	std	Y+4, r25	; 0x04
    2f56:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* RAMPZ */
    2f58:	8b 81       	ldd	r24, Y+3	; 0x03
    2f5a:	9c 81       	ldd	r25, Y+4	; 0x04
    2f5c:	fc 01       	movw	r30, r24
    2f5e:	10 82       	st	Z, r1
	pxTopOfStack--;
    2f60:	8b 81       	ldd	r24, Y+3	; 0x03
    2f62:	9c 81       	ldd	r25, Y+4	; 0x04
    2f64:	01 97       	sbiw	r24, 0x01	; 1
    2f66:	9c 83       	std	Y+4, r25	; 0x04
    2f68:	8b 83       	std	Y+3, r24	; 0x03

#endif

	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    2f6a:	8b 81       	ldd	r24, Y+3	; 0x03
    2f6c:	9c 81       	ldd	r25, Y+4	; 0x04
    2f6e:	fc 01       	movw	r30, r24
    2f70:	10 82       	st	Z, r1
	pxTopOfStack--;
    2f72:	8b 81       	ldd	r24, Y+3	; 0x03
    2f74:	9c 81       	ldd	r25, Y+4	; 0x04
    2f76:	01 97       	sbiw	r24, 0x01	; 1
    2f78:	9c 83       	std	Y+4, r25	; 0x04
    2f7a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    2f7c:	8b 81       	ldd	r24, Y+3	; 0x03
    2f7e:	9c 81       	ldd	r25, Y+4	; 0x04
    2f80:	22 e0       	ldi	r18, 0x02	; 2
    2f82:	fc 01       	movw	r30, r24
    2f84:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f86:	8b 81       	ldd	r24, Y+3	; 0x03
    2f88:	9c 81       	ldd	r25, Y+4	; 0x04
    2f8a:	01 97       	sbiw	r24, 0x01	; 1
    2f8c:	9c 83       	std	Y+4, r25	; 0x04
    2f8e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    2f90:	8b 81       	ldd	r24, Y+3	; 0x03
    2f92:	9c 81       	ldd	r25, Y+4	; 0x04
    2f94:	23 e0       	ldi	r18, 0x03	; 3
    2f96:	fc 01       	movw	r30, r24
    2f98:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f9a:	8b 81       	ldd	r24, Y+3	; 0x03
    2f9c:	9c 81       	ldd	r25, Y+4	; 0x04
    2f9e:	01 97       	sbiw	r24, 0x01	; 1
    2fa0:	9c 83       	std	Y+4, r25	; 0x04
    2fa2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    2fa4:	8b 81       	ldd	r24, Y+3	; 0x03
    2fa6:	9c 81       	ldd	r25, Y+4	; 0x04
    2fa8:	24 e0       	ldi	r18, 0x04	; 4
    2faa:	fc 01       	movw	r30, r24
    2fac:	20 83       	st	Z, r18
	pxTopOfStack--;
    2fae:	8b 81       	ldd	r24, Y+3	; 0x03
    2fb0:	9c 81       	ldd	r25, Y+4	; 0x04
    2fb2:	01 97       	sbiw	r24, 0x01	; 1
    2fb4:	9c 83       	std	Y+4, r25	; 0x04
    2fb6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    2fb8:	8b 81       	ldd	r24, Y+3	; 0x03
    2fba:	9c 81       	ldd	r25, Y+4	; 0x04
    2fbc:	25 e0       	ldi	r18, 0x05	; 5
    2fbe:	fc 01       	movw	r30, r24
    2fc0:	20 83       	st	Z, r18
	pxTopOfStack--;
    2fc2:	8b 81       	ldd	r24, Y+3	; 0x03
    2fc4:	9c 81       	ldd	r25, Y+4	; 0x04
    2fc6:	01 97       	sbiw	r24, 0x01	; 1
    2fc8:	9c 83       	std	Y+4, r25	; 0x04
    2fca:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    2fcc:	8b 81       	ldd	r24, Y+3	; 0x03
    2fce:	9c 81       	ldd	r25, Y+4	; 0x04
    2fd0:	26 e0       	ldi	r18, 0x06	; 6
    2fd2:	fc 01       	movw	r30, r24
    2fd4:	20 83       	st	Z, r18
	pxTopOfStack--;
    2fd6:	8b 81       	ldd	r24, Y+3	; 0x03
    2fd8:	9c 81       	ldd	r25, Y+4	; 0x04
    2fda:	01 97       	sbiw	r24, 0x01	; 1
    2fdc:	9c 83       	std	Y+4, r25	; 0x04
    2fde:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    2fe0:	8b 81       	ldd	r24, Y+3	; 0x03
    2fe2:	9c 81       	ldd	r25, Y+4	; 0x04
    2fe4:	27 e0       	ldi	r18, 0x07	; 7
    2fe6:	fc 01       	movw	r30, r24
    2fe8:	20 83       	st	Z, r18
	pxTopOfStack--;
    2fea:	8b 81       	ldd	r24, Y+3	; 0x03
    2fec:	9c 81       	ldd	r25, Y+4	; 0x04
    2fee:	01 97       	sbiw	r24, 0x01	; 1
    2ff0:	9c 83       	std	Y+4, r25	; 0x04
    2ff2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    2ff4:	8b 81       	ldd	r24, Y+3	; 0x03
    2ff6:	9c 81       	ldd	r25, Y+4	; 0x04
    2ff8:	28 e0       	ldi	r18, 0x08	; 8
    2ffa:	fc 01       	movw	r30, r24
    2ffc:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ffe:	8b 81       	ldd	r24, Y+3	; 0x03
    3000:	9c 81       	ldd	r25, Y+4	; 0x04
    3002:	01 97       	sbiw	r24, 0x01	; 1
    3004:	9c 83       	std	Y+4, r25	; 0x04
    3006:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    3008:	8b 81       	ldd	r24, Y+3	; 0x03
    300a:	9c 81       	ldd	r25, Y+4	; 0x04
    300c:	29 e0       	ldi	r18, 0x09	; 9
    300e:	fc 01       	movw	r30, r24
    3010:	20 83       	st	Z, r18
	pxTopOfStack--;
    3012:	8b 81       	ldd	r24, Y+3	; 0x03
    3014:	9c 81       	ldd	r25, Y+4	; 0x04
    3016:	01 97       	sbiw	r24, 0x01	; 1
    3018:	9c 83       	std	Y+4, r25	; 0x04
    301a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    301c:	8b 81       	ldd	r24, Y+3	; 0x03
    301e:	9c 81       	ldd	r25, Y+4	; 0x04
    3020:	20 e1       	ldi	r18, 0x10	; 16
    3022:	fc 01       	movw	r30, r24
    3024:	20 83       	st	Z, r18
	pxTopOfStack--;
    3026:	8b 81       	ldd	r24, Y+3	; 0x03
    3028:	9c 81       	ldd	r25, Y+4	; 0x04
    302a:	01 97       	sbiw	r24, 0x01	; 1
    302c:	9c 83       	std	Y+4, r25	; 0x04
    302e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    3030:	8b 81       	ldd	r24, Y+3	; 0x03
    3032:	9c 81       	ldd	r25, Y+4	; 0x04
    3034:	21 e1       	ldi	r18, 0x11	; 17
    3036:	fc 01       	movw	r30, r24
    3038:	20 83       	st	Z, r18
	pxTopOfStack--;
    303a:	8b 81       	ldd	r24, Y+3	; 0x03
    303c:	9c 81       	ldd	r25, Y+4	; 0x04
    303e:	01 97       	sbiw	r24, 0x01	; 1
    3040:	9c 83       	std	Y+4, r25	; 0x04
    3042:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    3044:	8b 81       	ldd	r24, Y+3	; 0x03
    3046:	9c 81       	ldd	r25, Y+4	; 0x04
    3048:	22 e1       	ldi	r18, 0x12	; 18
    304a:	fc 01       	movw	r30, r24
    304c:	20 83       	st	Z, r18
	pxTopOfStack--;
    304e:	8b 81       	ldd	r24, Y+3	; 0x03
    3050:	9c 81       	ldd	r25, Y+4	; 0x04
    3052:	01 97       	sbiw	r24, 0x01	; 1
    3054:	9c 83       	std	Y+4, r25	; 0x04
    3056:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    3058:	8b 81       	ldd	r24, Y+3	; 0x03
    305a:	9c 81       	ldd	r25, Y+4	; 0x04
    305c:	23 e1       	ldi	r18, 0x13	; 19
    305e:	fc 01       	movw	r30, r24
    3060:	20 83       	st	Z, r18
	pxTopOfStack--;
    3062:	8b 81       	ldd	r24, Y+3	; 0x03
    3064:	9c 81       	ldd	r25, Y+4	; 0x04
    3066:	01 97       	sbiw	r24, 0x01	; 1
    3068:	9c 83       	std	Y+4, r25	; 0x04
    306a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    306c:	8b 81       	ldd	r24, Y+3	; 0x03
    306e:	9c 81       	ldd	r25, Y+4	; 0x04
    3070:	24 e1       	ldi	r18, 0x14	; 20
    3072:	fc 01       	movw	r30, r24
    3074:	20 83       	st	Z, r18
	pxTopOfStack--;
    3076:	8b 81       	ldd	r24, Y+3	; 0x03
    3078:	9c 81       	ldd	r25, Y+4	; 0x04
    307a:	01 97       	sbiw	r24, 0x01	; 1
    307c:	9c 83       	std	Y+4, r25	; 0x04
    307e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    3080:	8b 81       	ldd	r24, Y+3	; 0x03
    3082:	9c 81       	ldd	r25, Y+4	; 0x04
    3084:	25 e1       	ldi	r18, 0x15	; 21
    3086:	fc 01       	movw	r30, r24
    3088:	20 83       	st	Z, r18
	pxTopOfStack--;
    308a:	8b 81       	ldd	r24, Y+3	; 0x03
    308c:	9c 81       	ldd	r25, Y+4	; 0x04
    308e:	01 97       	sbiw	r24, 0x01	; 1
    3090:	9c 83       	std	Y+4, r25	; 0x04
    3092:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    3094:	8b 81       	ldd	r24, Y+3	; 0x03
    3096:	9c 81       	ldd	r25, Y+4	; 0x04
    3098:	26 e1       	ldi	r18, 0x16	; 22
    309a:	fc 01       	movw	r30, r24
    309c:	20 83       	st	Z, r18
	pxTopOfStack--;
    309e:	8b 81       	ldd	r24, Y+3	; 0x03
    30a0:	9c 81       	ldd	r25, Y+4	; 0x04
    30a2:	01 97       	sbiw	r24, 0x01	; 1
    30a4:	9c 83       	std	Y+4, r25	; 0x04
    30a6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    30a8:	8b 81       	ldd	r24, Y+3	; 0x03
    30aa:	9c 81       	ldd	r25, Y+4	; 0x04
    30ac:	27 e1       	ldi	r18, 0x17	; 23
    30ae:	fc 01       	movw	r30, r24
    30b0:	20 83       	st	Z, r18
	pxTopOfStack--;
    30b2:	8b 81       	ldd	r24, Y+3	; 0x03
    30b4:	9c 81       	ldd	r25, Y+4	; 0x04
    30b6:	01 97       	sbiw	r24, 0x01	; 1
    30b8:	9c 83       	std	Y+4, r25	; 0x04
    30ba:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    30bc:	8b 81       	ldd	r24, Y+3	; 0x03
    30be:	9c 81       	ldd	r25, Y+4	; 0x04
    30c0:	28 e1       	ldi	r18, 0x18	; 24
    30c2:	fc 01       	movw	r30, r24
    30c4:	20 83       	st	Z, r18
	pxTopOfStack--;
    30c6:	8b 81       	ldd	r24, Y+3	; 0x03
    30c8:	9c 81       	ldd	r25, Y+4	; 0x04
    30ca:	01 97       	sbiw	r24, 0x01	; 1
    30cc:	9c 83       	std	Y+4, r25	; 0x04
    30ce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    30d0:	8b 81       	ldd	r24, Y+3	; 0x03
    30d2:	9c 81       	ldd	r25, Y+4	; 0x04
    30d4:	29 e1       	ldi	r18, 0x19	; 25
    30d6:	fc 01       	movw	r30, r24
    30d8:	20 83       	st	Z, r18
	pxTopOfStack--;
    30da:	8b 81       	ldd	r24, Y+3	; 0x03
    30dc:	9c 81       	ldd	r25, Y+4	; 0x04
    30de:	01 97       	sbiw	r24, 0x01	; 1
    30e0:	9c 83       	std	Y+4, r25	; 0x04
    30e2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    30e4:	8b 81       	ldd	r24, Y+3	; 0x03
    30e6:	9c 81       	ldd	r25, Y+4	; 0x04
    30e8:	20 e2       	ldi	r18, 0x20	; 32
    30ea:	fc 01       	movw	r30, r24
    30ec:	20 83       	st	Z, r18
	pxTopOfStack--;
    30ee:	8b 81       	ldd	r24, Y+3	; 0x03
    30f0:	9c 81       	ldd	r25, Y+4	; 0x04
    30f2:	01 97       	sbiw	r24, 0x01	; 1
    30f4:	9c 83       	std	Y+4, r25	; 0x04
    30f6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    30f8:	8b 81       	ldd	r24, Y+3	; 0x03
    30fa:	9c 81       	ldd	r25, Y+4	; 0x04
    30fc:	21 e2       	ldi	r18, 0x21	; 33
    30fe:	fc 01       	movw	r30, r24
    3100:	20 83       	st	Z, r18
	pxTopOfStack--;
    3102:	8b 81       	ldd	r24, Y+3	; 0x03
    3104:	9c 81       	ldd	r25, Y+4	; 0x04
    3106:	01 97       	sbiw	r24, 0x01	; 1
    3108:	9c 83       	std	Y+4, r25	; 0x04
    310a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    310c:	8b 81       	ldd	r24, Y+3	; 0x03
    310e:	9c 81       	ldd	r25, Y+4	; 0x04
    3110:	22 e2       	ldi	r18, 0x22	; 34
    3112:	fc 01       	movw	r30, r24
    3114:	20 83       	st	Z, r18
	pxTopOfStack--;
    3116:	8b 81       	ldd	r24, Y+3	; 0x03
    3118:	9c 81       	ldd	r25, Y+4	; 0x04
    311a:	01 97       	sbiw	r24, 0x01	; 1
    311c:	9c 83       	std	Y+4, r25	; 0x04
    311e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    3120:	8b 81       	ldd	r24, Y+3	; 0x03
    3122:	9c 81       	ldd	r25, Y+4	; 0x04
    3124:	23 e2       	ldi	r18, 0x23	; 35
    3126:	fc 01       	movw	r30, r24
    3128:	20 83       	st	Z, r18
	pxTopOfStack--;
    312a:	8b 81       	ldd	r24, Y+3	; 0x03
    312c:	9c 81       	ldd	r25, Y+4	; 0x04
    312e:	01 97       	sbiw	r24, 0x01	; 1
    3130:	9c 83       	std	Y+4, r25	; 0x04
    3132:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    3134:	8f 81       	ldd	r24, Y+7	; 0x07
    3136:	98 85       	ldd	r25, Y+8	; 0x08
    3138:	9a 83       	std	Y+2, r25	; 0x02
    313a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    313c:	29 81       	ldd	r18, Y+1	; 0x01
    313e:	8b 81       	ldd	r24, Y+3	; 0x03
    3140:	9c 81       	ldd	r25, Y+4	; 0x04
    3142:	fc 01       	movw	r30, r24
    3144:	20 83       	st	Z, r18
	pxTopOfStack--;
    3146:	8b 81       	ldd	r24, Y+3	; 0x03
    3148:	9c 81       	ldd	r25, Y+4	; 0x04
    314a:	01 97       	sbiw	r24, 0x01	; 1
    314c:	9c 83       	std	Y+4, r25	; 0x04
    314e:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    3150:	89 81       	ldd	r24, Y+1	; 0x01
    3152:	9a 81       	ldd	r25, Y+2	; 0x02
    3154:	89 2f       	mov	r24, r25
    3156:	99 27       	eor	r25, r25
    3158:	9a 83       	std	Y+2, r25	; 0x02
    315a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    315c:	29 81       	ldd	r18, Y+1	; 0x01
    315e:	8b 81       	ldd	r24, Y+3	; 0x03
    3160:	9c 81       	ldd	r25, Y+4	; 0x04
    3162:	fc 01       	movw	r30, r24
    3164:	20 83       	st	Z, r18
	pxTopOfStack--;
    3166:	8b 81       	ldd	r24, Y+3	; 0x03
    3168:	9c 81       	ldd	r25, Y+4	; 0x04
    316a:	01 97       	sbiw	r24, 0x01	; 1
    316c:	9c 83       	std	Y+4, r25	; 0x04
    316e:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    3170:	8b 81       	ldd	r24, Y+3	; 0x03
    3172:	9c 81       	ldd	r25, Y+4	; 0x04
    3174:	26 e2       	ldi	r18, 0x26	; 38
    3176:	fc 01       	movw	r30, r24
    3178:	20 83       	st	Z, r18
	pxTopOfStack--;
    317a:	8b 81       	ldd	r24, Y+3	; 0x03
    317c:	9c 81       	ldd	r25, Y+4	; 0x04
    317e:	01 97       	sbiw	r24, 0x01	; 1
    3180:	9c 83       	std	Y+4, r25	; 0x04
    3182:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    3184:	8b 81       	ldd	r24, Y+3	; 0x03
    3186:	9c 81       	ldd	r25, Y+4	; 0x04
    3188:	27 e2       	ldi	r18, 0x27	; 39
    318a:	fc 01       	movw	r30, r24
    318c:	20 83       	st	Z, r18
	pxTopOfStack--;
    318e:	8b 81       	ldd	r24, Y+3	; 0x03
    3190:	9c 81       	ldd	r25, Y+4	; 0x04
    3192:	01 97       	sbiw	r24, 0x01	; 1
    3194:	9c 83       	std	Y+4, r25	; 0x04
    3196:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    3198:	8b 81       	ldd	r24, Y+3	; 0x03
    319a:	9c 81       	ldd	r25, Y+4	; 0x04
    319c:	28 e2       	ldi	r18, 0x28	; 40
    319e:	fc 01       	movw	r30, r24
    31a0:	20 83       	st	Z, r18
	pxTopOfStack--;
    31a2:	8b 81       	ldd	r24, Y+3	; 0x03
    31a4:	9c 81       	ldd	r25, Y+4	; 0x04
    31a6:	01 97       	sbiw	r24, 0x01	; 1
    31a8:	9c 83       	std	Y+4, r25	; 0x04
    31aa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    31ac:	8b 81       	ldd	r24, Y+3	; 0x03
    31ae:	9c 81       	ldd	r25, Y+4	; 0x04
    31b0:	29 e2       	ldi	r18, 0x29	; 41
    31b2:	fc 01       	movw	r30, r24
    31b4:	20 83       	st	Z, r18
	pxTopOfStack--;
    31b6:	8b 81       	ldd	r24, Y+3	; 0x03
    31b8:	9c 81       	ldd	r25, Y+4	; 0x04
    31ba:	01 97       	sbiw	r24, 0x01	; 1
    31bc:	9c 83       	std	Y+4, r25	; 0x04
    31be:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    31c0:	8b 81       	ldd	r24, Y+3	; 0x03
    31c2:	9c 81       	ldd	r25, Y+4	; 0x04
    31c4:	20 e3       	ldi	r18, 0x30	; 48
    31c6:	fc 01       	movw	r30, r24
    31c8:	20 83       	st	Z, r18
	pxTopOfStack--;
    31ca:	8b 81       	ldd	r24, Y+3	; 0x03
    31cc:	9c 81       	ldd	r25, Y+4	; 0x04
    31ce:	01 97       	sbiw	r24, 0x01	; 1
    31d0:	9c 83       	std	Y+4, r25	; 0x04
    31d2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    31d4:	8b 81       	ldd	r24, Y+3	; 0x03
    31d6:	9c 81       	ldd	r25, Y+4	; 0x04
    31d8:	21 e3       	ldi	r18, 0x31	; 49
    31da:	fc 01       	movw	r30, r24
    31dc:	20 83       	st	Z, r18
	pxTopOfStack--;
    31de:	8b 81       	ldd	r24, Y+3	; 0x03
    31e0:	9c 81       	ldd	r25, Y+4	; 0x04
    31e2:	01 97       	sbiw	r24, 0x01	; 1
    31e4:	9c 83       	std	Y+4, r25	; 0x04
    31e6:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    31e8:	8b 81       	ldd	r24, Y+3	; 0x03
    31ea:	9c 81       	ldd	r25, Y+4	; 0x04
}
    31ec:	28 96       	adiw	r28, 0x08	; 8
    31ee:	0f b6       	in	r0, 0x3f	; 63
    31f0:	f8 94       	cli
    31f2:	de bf       	out	0x3e, r29	; 62
    31f4:	0f be       	out	0x3f, r0	; 63
    31f6:	cd bf       	out	0x3d, r28	; 61
    31f8:	df 91       	pop	r29
    31fa:	cf 91       	pop	r28
    31fc:	08 95       	ret

000031fe <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    31fe:	cf 93       	push	r28
    3200:	df 93       	push	r29
    3202:	cd b7       	in	r28, 0x3d	; 61
    3204:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    3206:	0e 94 03 1a 	call	0x3406	; 0x3406 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    320a:	a0 91 30 02 	lds	r26, 0x0230
    320e:	b0 91 31 02 	lds	r27, 0x0231
    3212:	cd 91       	ld	r28, X+
    3214:	cd bf       	out	0x3d, r28	; 61
    3216:	dd 91       	ld	r29, X+
    3218:	de bf       	out	0x3e, r29	; 62
    321a:	ff 91       	pop	r31
    321c:	ef 91       	pop	r30
    321e:	df 91       	pop	r29
    3220:	cf 91       	pop	r28
    3222:	bf 91       	pop	r27
    3224:	af 91       	pop	r26
    3226:	9f 91       	pop	r25
    3228:	8f 91       	pop	r24
    322a:	7f 91       	pop	r23
    322c:	6f 91       	pop	r22
    322e:	5f 91       	pop	r21
    3230:	4f 91       	pop	r20
    3232:	3f 91       	pop	r19
    3234:	2f 91       	pop	r18
    3236:	1f 91       	pop	r17
    3238:	0f 91       	pop	r16
    323a:	ff 90       	pop	r15
    323c:	ef 90       	pop	r14
    323e:	df 90       	pop	r13
    3240:	cf 90       	pop	r12
    3242:	bf 90       	pop	r11
    3244:	af 90       	pop	r10
    3246:	9f 90       	pop	r9
    3248:	8f 90       	pop	r8
    324a:	7f 90       	pop	r7
    324c:	6f 90       	pop	r6
    324e:	5f 90       	pop	r5
    3250:	4f 90       	pop	r4
    3252:	3f 90       	pop	r3
    3254:	2f 90       	pop	r2
    3256:	1f 90       	pop	r1
    3258:	0f 90       	pop	r0
    325a:	0c be       	out	0x3c, r0	; 60
    325c:	0f 90       	pop	r0
    325e:	0b be       	out	0x3b, r0	; 59
    3260:	0f 90       	pop	r0
    3262:	0f be       	out	0x3f, r0	; 63
    3264:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    3266:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    3268:	81 e0       	ldi	r24, 0x01	; 1
}
    326a:	df 91       	pop	r29
    326c:	cf 91       	pop	r28
    326e:	08 95       	ret

00003270 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    3270:	cf 93       	push	r28
    3272:	df 93       	push	r29
    3274:	cd b7       	in	r28, 0x3d	; 61
    3276:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    3278:	df 91       	pop	r29
    327a:	cf 91       	pop	r28
    327c:	08 95       	ret

0000327e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    327e:	0f 92       	push	r0
    3280:	0f b6       	in	r0, 0x3f	; 63
    3282:	f8 94       	cli
    3284:	0f 92       	push	r0
    3286:	0b b6       	in	r0, 0x3b	; 59
    3288:	0f 92       	push	r0
    328a:	0c b6       	in	r0, 0x3c	; 60
    328c:	0f 92       	push	r0
    328e:	1f 92       	push	r1
    3290:	11 24       	eor	r1, r1
    3292:	2f 92       	push	r2
    3294:	3f 92       	push	r3
    3296:	4f 92       	push	r4
    3298:	5f 92       	push	r5
    329a:	6f 92       	push	r6
    329c:	7f 92       	push	r7
    329e:	8f 92       	push	r8
    32a0:	9f 92       	push	r9
    32a2:	af 92       	push	r10
    32a4:	bf 92       	push	r11
    32a6:	cf 92       	push	r12
    32a8:	df 92       	push	r13
    32aa:	ef 92       	push	r14
    32ac:	ff 92       	push	r15
    32ae:	0f 93       	push	r16
    32b0:	1f 93       	push	r17
    32b2:	2f 93       	push	r18
    32b4:	3f 93       	push	r19
    32b6:	4f 93       	push	r20
    32b8:	5f 93       	push	r21
    32ba:	6f 93       	push	r22
    32bc:	7f 93       	push	r23
    32be:	8f 93       	push	r24
    32c0:	9f 93       	push	r25
    32c2:	af 93       	push	r26
    32c4:	bf 93       	push	r27
    32c6:	cf 93       	push	r28
    32c8:	df 93       	push	r29
    32ca:	ef 93       	push	r30
    32cc:	ff 93       	push	r31
    32ce:	a0 91 30 02 	lds	r26, 0x0230
    32d2:	b0 91 31 02 	lds	r27, 0x0231
    32d6:	0d b6       	in	r0, 0x3d	; 61
    32d8:	0d 92       	st	X+, r0
    32da:	0e b6       	in	r0, 0x3e	; 62
    32dc:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    32de:	0e 94 40 08 	call	0x1080	; 0x1080 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    32e2:	a0 91 30 02 	lds	r26, 0x0230
    32e6:	b0 91 31 02 	lds	r27, 0x0231
    32ea:	cd 91       	ld	r28, X+
    32ec:	cd bf       	out	0x3d, r28	; 61
    32ee:	dd 91       	ld	r29, X+
    32f0:	de bf       	out	0x3e, r29	; 62
    32f2:	ff 91       	pop	r31
    32f4:	ef 91       	pop	r30
    32f6:	df 91       	pop	r29
    32f8:	cf 91       	pop	r28
    32fa:	bf 91       	pop	r27
    32fc:	af 91       	pop	r26
    32fe:	9f 91       	pop	r25
    3300:	8f 91       	pop	r24
    3302:	7f 91       	pop	r23
    3304:	6f 91       	pop	r22
    3306:	5f 91       	pop	r21
    3308:	4f 91       	pop	r20
    330a:	3f 91       	pop	r19
    330c:	2f 91       	pop	r18
    330e:	1f 91       	pop	r17
    3310:	0f 91       	pop	r16
    3312:	ff 90       	pop	r15
    3314:	ef 90       	pop	r14
    3316:	df 90       	pop	r13
    3318:	cf 90       	pop	r12
    331a:	bf 90       	pop	r11
    331c:	af 90       	pop	r10
    331e:	9f 90       	pop	r9
    3320:	8f 90       	pop	r8
    3322:	7f 90       	pop	r7
    3324:	6f 90       	pop	r6
    3326:	5f 90       	pop	r5
    3328:	4f 90       	pop	r4
    332a:	3f 90       	pop	r3
    332c:	2f 90       	pop	r2
    332e:	1f 90       	pop	r1
    3330:	0f 90       	pop	r0
    3332:	0c be       	out	0x3c, r0	; 60
    3334:	0f 90       	pop	r0
    3336:	0b be       	out	0x3b, r0	; 59
    3338:	0f 90       	pop	r0
    333a:	0f be       	out	0x3f, r0	; 63
    333c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    333e:	08 95       	ret

00003340 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    3340:	0f 92       	push	r0
    3342:	0f b6       	in	r0, 0x3f	; 63
    3344:	f8 94       	cli
    3346:	0f 92       	push	r0
    3348:	0b b6       	in	r0, 0x3b	; 59
    334a:	0f 92       	push	r0
    334c:	0c b6       	in	r0, 0x3c	; 60
    334e:	0f 92       	push	r0
    3350:	1f 92       	push	r1
    3352:	11 24       	eor	r1, r1
    3354:	2f 92       	push	r2
    3356:	3f 92       	push	r3
    3358:	4f 92       	push	r4
    335a:	5f 92       	push	r5
    335c:	6f 92       	push	r6
    335e:	7f 92       	push	r7
    3360:	8f 92       	push	r8
    3362:	9f 92       	push	r9
    3364:	af 92       	push	r10
    3366:	bf 92       	push	r11
    3368:	cf 92       	push	r12
    336a:	df 92       	push	r13
    336c:	ef 92       	push	r14
    336e:	ff 92       	push	r15
    3370:	0f 93       	push	r16
    3372:	1f 93       	push	r17
    3374:	2f 93       	push	r18
    3376:	3f 93       	push	r19
    3378:	4f 93       	push	r20
    337a:	5f 93       	push	r21
    337c:	6f 93       	push	r22
    337e:	7f 93       	push	r23
    3380:	8f 93       	push	r24
    3382:	9f 93       	push	r25
    3384:	af 93       	push	r26
    3386:	bf 93       	push	r27
    3388:	cf 93       	push	r28
    338a:	df 93       	push	r29
    338c:	ef 93       	push	r30
    338e:	ff 93       	push	r31
    3390:	a0 91 30 02 	lds	r26, 0x0230
    3394:	b0 91 31 02 	lds	r27, 0x0231
    3398:	0d b6       	in	r0, 0x3d	; 61
    339a:	0d 92       	st	X+, r0
    339c:	0e b6       	in	r0, 0x3e	; 62
    339e:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    33a0:	0e 94 63 07 	call	0xec6	; 0xec6 <vTaskIncrementTick>
	vTaskSwitchContext();
    33a4:	0e 94 40 08 	call	0x1080	; 0x1080 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    33a8:	a0 91 30 02 	lds	r26, 0x0230
    33ac:	b0 91 31 02 	lds	r27, 0x0231
    33b0:	cd 91       	ld	r28, X+
    33b2:	cd bf       	out	0x3d, r28	; 61
    33b4:	dd 91       	ld	r29, X+
    33b6:	de bf       	out	0x3e, r29	; 62
    33b8:	ff 91       	pop	r31
    33ba:	ef 91       	pop	r30
    33bc:	df 91       	pop	r29
    33be:	cf 91       	pop	r28
    33c0:	bf 91       	pop	r27
    33c2:	af 91       	pop	r26
    33c4:	9f 91       	pop	r25
    33c6:	8f 91       	pop	r24
    33c8:	7f 91       	pop	r23
    33ca:	6f 91       	pop	r22
    33cc:	5f 91       	pop	r21
    33ce:	4f 91       	pop	r20
    33d0:	3f 91       	pop	r19
    33d2:	2f 91       	pop	r18
    33d4:	1f 91       	pop	r17
    33d6:	0f 91       	pop	r16
    33d8:	ff 90       	pop	r15
    33da:	ef 90       	pop	r14
    33dc:	df 90       	pop	r13
    33de:	cf 90       	pop	r12
    33e0:	bf 90       	pop	r11
    33e2:	af 90       	pop	r10
    33e4:	9f 90       	pop	r9
    33e6:	8f 90       	pop	r8
    33e8:	7f 90       	pop	r7
    33ea:	6f 90       	pop	r6
    33ec:	5f 90       	pop	r5
    33ee:	4f 90       	pop	r4
    33f0:	3f 90       	pop	r3
    33f2:	2f 90       	pop	r2
    33f4:	1f 90       	pop	r1
    33f6:	0f 90       	pop	r0
    33f8:	0c be       	out	0x3c, r0	; 60
    33fa:	0f 90       	pop	r0
    33fc:	0b be       	out	0x3b, r0	; 59
    33fe:	0f 90       	pop	r0
    3400:	0f be       	out	0x3f, r0	; 63
    3402:	0f 90       	pop	r0

	asm volatile ( "ret" );
    3404:	08 95       	ret

00003406 <prvSetupTimerInterrupt>:

/*
 * Setup timer 0 or 3 or 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    3406:	cf 93       	push	r28
    3408:	df 93       	push	r29
    340a:	00 d0       	rcall	.+0      	; 0x340c <prvSetupTimerInterrupt+0x6>
    340c:	00 d0       	rcall	.+0      	; 0x340e <prvSetupTimerInterrupt+0x8>
    340e:	cd b7       	in	r28, 0x3d	; 61
    3410:	de b7       	in	r29, 0x3e	; 62

    /* Using 8bit Timer0 or 16bit Timer1 or Timer3 to generate the tick. */

    // ulCompareMatch 40,000 = 20,000,000 / 500; 20MHz
    // ulCompareMatch 110,592 = 22,118,400 / 200; 22.1184 MHz
    ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    3412:	80 e0       	ldi	r24, 0x00	; 0
    3414:	9d e7       	ldi	r25, 0x7D	; 125
    3416:	a0 e0       	ldi	r26, 0x00	; 0
    3418:	b0 e0       	ldi	r27, 0x00	; 0
    341a:	89 83       	std	Y+1, r24	; 0x01
    341c:	9a 83       	std	Y+2, r25	; 0x02
    341e:	ab 83       	std	Y+3, r26	; 0x03
    3420:	bc 83       	std	Y+4, r27	; 0x04

    /* We only have 8 or 16 bits so have to scale 64 or 256 to get our required tick rate. */
    //ulCompareMatch = 625 /= portCLOCK_PRESCALER; 20MHz with 64 prescale
    //ulCompareMatch = 108 /= portCLOCK_PRESCALER; 22.1184 MHz with 1024 prescale
    ulCompareMatch /= portCLOCK_PRESCALER;
    3422:	89 81       	ldd	r24, Y+1	; 0x01
    3424:	9a 81       	ldd	r25, Y+2	; 0x02
    3426:	ab 81       	ldd	r26, Y+3	; 0x03
    3428:	bc 81       	ldd	r27, Y+4	; 0x04
    342a:	68 94       	set
    342c:	15 f8       	bld	r1, 5
    342e:	b6 95       	lsr	r27
    3430:	a7 95       	ror	r26
    3432:	97 95       	ror	r25
    3434:	87 95       	ror	r24
    3436:	16 94       	lsr	r1
    3438:	d1 f7       	brne	.-12     	; 0x342e <prvSetupTimerInterrupt+0x28>
    343a:	89 83       	std	Y+1, r24	; 0x01
    343c:	9a 83       	std	Y+2, r25	; 0x02
    343e:	ab 83       	std	Y+3, r26	; 0x03
    3440:	bc 83       	std	Y+4, r27	; 0x04

    /* Adjust for correct value. */
    ulCompareMatch -= ( unsigned portLONG ) 1;
    3442:	89 81       	ldd	r24, Y+1	; 0x01
    3444:	9a 81       	ldd	r25, Y+2	; 0x02
    3446:	ab 81       	ldd	r26, Y+3	; 0x03
    3448:	bc 81       	ldd	r27, Y+4	; 0x04
    344a:	01 97       	sbiw	r24, 0x01	; 1
    344c:	a1 09       	sbc	r26, r1
    344e:	b1 09       	sbc	r27, r1
    3450:	89 83       	std	Y+1, r24	; 0x01
    3452:	9a 83       	std	Y+2, r25	; 0x02
    3454:	ab 83       	std	Y+3, r26	; 0x03
    3456:	bc 83       	std	Y+4, r27	; 0x04

    /* Setup compare match value for compare match A.  Interrupts are disabled
    before this is called so we need not worry here. */
    ucLowByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
    3458:	89 81       	ldd	r24, Y+1	; 0x01
    345a:	8d 83       	std	Y+5, r24	; 0x05
    //  OCR3AL = ucLowByte;

    // the HiByte is only needed, if a 16 Bit counter is being utilized
#ifdef portOCRH

    ulCompareMatch >>= 8;
    345c:	89 81       	ldd	r24, Y+1	; 0x01
    345e:	9a 81       	ldd	r25, Y+2	; 0x02
    3460:	ab 81       	ldd	r26, Y+3	; 0x03
    3462:	bc 81       	ldd	r27, Y+4	; 0x04
    3464:	89 2f       	mov	r24, r25
    3466:	9a 2f       	mov	r25, r26
    3468:	ab 2f       	mov	r26, r27
    346a:	bb 27       	eor	r27, r27
    346c:	89 83       	std	Y+1, r24	; 0x01
    346e:	9a 83       	std	Y+2, r25	; 0x02
    3470:	ab 83       	std	Y+3, r26	; 0x03
    3472:	bc 83       	std	Y+4, r27	; 0x04
    ucHighByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
    3474:	89 81       	ldd	r24, Y+1	; 0x01
    3476:	8e 83       	std	Y+6, r24	; 0x06
    portOCRH = ucHighByte;
    3478:	89 e9       	ldi	r24, 0x99	; 153
    347a:	90 e0       	ldi	r25, 0x00	; 0
    347c:	2e 81       	ldd	r18, Y+6	; 0x06
    347e:	fc 01       	movw	r30, r24
    3480:	20 83       	st	Z, r18

#endif

    portOCRL = ucLowByte;
    3482:	88 e9       	ldi	r24, 0x98	; 152
    3484:	90 e0       	ldi	r25, 0x00	; 0
    3486:	2d 81       	ldd	r18, Y+5	; 0x05
    3488:	fc 01       	movw	r30, r24
    348a:	20 83       	st	Z, r18
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	portTCCRb = ucLowByte;

#elif defined( portUSE_TIMER3 )
	/* Setup clock source and compare match behaviour. Assuming  640 / 1280 /1281 / 1284p / 2560 / 2561 (with Timer3) */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    348c:	8b e0       	ldi	r24, 0x0B	; 11
    348e:	8d 83       	std	Y+5, r24	; 0x05
	portTCCRb = ucLowByte;
    3490:	81 e9       	ldi	r24, 0x91	; 145
    3492:	90 e0       	ldi	r25, 0x00	; 0
    3494:	2d 81       	ldd	r18, Y+5	; 0x05
    3496:	fc 01       	movw	r30, r24
    3498:	20 83       	st	Z, r18
#endif

    /* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
    ucLowByte = portTIMSK;
    349a:	81 e7       	ldi	r24, 0x71	; 113
    349c:	90 e0       	ldi	r25, 0x00	; 0
    349e:	fc 01       	movw	r30, r24
    34a0:	80 81       	ld	r24, Z
    34a2:	8d 83       	std	Y+5, r24	; 0x05
    ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    34a4:	8d 81       	ldd	r24, Y+5	; 0x05
    34a6:	82 60       	ori	r24, 0x02	; 2
    34a8:	8d 83       	std	Y+5, r24	; 0x05
    portTIMSK = ucLowByte;
    34aa:	81 e7       	ldi	r24, 0x71	; 113
    34ac:	90 e0       	ldi	r25, 0x00	; 0
    34ae:	2d 81       	ldd	r18, Y+5	; 0x05
    34b0:	fc 01       	movw	r30, r24
    34b2:	20 83       	st	Z, r18

}
    34b4:	26 96       	adiw	r28, 0x06	; 6
    34b6:	0f b6       	in	r0, 0x3f	; 63
    34b8:	f8 94       	cli
    34ba:	de bf       	out	0x3e, r29	; 62
    34bc:	0f be       	out	0x3f, r0	; 63
    34be:	cd bf       	out	0x3d, r28	; 61
    34c0:	df 91       	pop	r29
    34c2:	cf 91       	pop	r28
    34c4:	08 95       	ret

000034c6 <__vector_32>:

	#elif defined( portUSE_TIMER3 )
		#warning "Timer3 used for PRE-EMPTIVE scheduler."
		ISR(TIMER3_COMPA_vect, ISR_NAKED)
		{
			vPortYieldFromTick();
    34c6:	0e 94 a0 19 	call	0x3340	; 0x3340 <vPortYieldFromTick>
			asm volatile ( "reti" );
    34ca:	18 95       	reti

000034cc <USART_Init>:
*  the specified baud rate and clk speed.
*
* Param buadin: The desired Baud rate.
* Param clk_seedin: The clk speed of the ATmega328p
************************************/
void USART_Init(uint16_t baudin, uint32_t clk_speedin) {
    34cc:	cf 93       	push	r28
    34ce:	df 93       	push	r29
    34d0:	00 d0       	rcall	.+0      	; 0x34d2 <USART_Init+0x6>
    34d2:	00 d0       	rcall	.+0      	; 0x34d4 <USART_Init+0x8>
    34d4:	cd b7       	in	r28, 0x3d	; 61
    34d6:	de b7       	in	r29, 0x3e	; 62
    34d8:	9a 83       	std	Y+2, r25	; 0x02
    34da:	89 83       	std	Y+1, r24	; 0x01
    34dc:	4b 83       	std	Y+3, r20	; 0x03
    34de:	5c 83       	std	Y+4, r21	; 0x04
    34e0:	6d 83       	std	Y+5, r22	; 0x05
    34e2:	7e 83       	std	Y+6, r23	; 0x06
    USART_WriteQueue = xQueueCreate(64,sizeof(uint8_t));
    34e4:	40 e0       	ldi	r20, 0x00	; 0
    34e6:	61 e0       	ldi	r22, 0x01	; 1
    34e8:	80 e4       	ldi	r24, 0x40	; 64
    34ea:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <xQueueGenericCreate>
    34ee:	90 93 5c 1b 	sts	0x1B5C, r25
    34f2:	80 93 5b 1b 	sts	0x1B5B, r24
    USART_ReadQueue = xQueueCreate(8,sizeof(uint8_t));
    34f6:	40 e0       	ldi	r20, 0x00	; 0
    34f8:	61 e0       	ldi	r22, 0x01	; 1
    34fa:	88 e0       	ldi	r24, 0x08	; 8
    34fc:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <xQueueGenericCreate>
    3500:	90 93 58 1b 	sts	0x1B58, r25
    3504:	80 93 57 1b 	sts	0x1B57, r24

    //uint32_t ubrr = clk_speedin/(16UL)/baudin-1;
    //UBRR1H = (unsigned char)(ubrr>>8) ;// & 0x7F;
    //UBRR1L = (unsigned char)ubrr;
    
    UBRR0H = 0; //115200
    3508:	85 ec       	ldi	r24, 0xC5	; 197
    350a:	90 e0       	ldi	r25, 0x00	; 0
    350c:	fc 01       	movw	r30, r24
    350e:	10 82       	st	Z, r1
    UBRR0L = 8;
    3510:	84 ec       	ldi	r24, 0xC4	; 196
    3512:	90 e0       	ldi	r25, 0x00	; 0
    3514:	28 e0       	ldi	r18, 0x08	; 8
    3516:	fc 01       	movw	r30, r24
    3518:	20 83       	st	Z, r18

    /* Enable receiver and transmitter */
    UCSR0B = (1<<RXEN0)|(1<<TXEN0);//|(1<<RXCIE1);
    351a:	81 ec       	ldi	r24, 0xC1	; 193
    351c:	90 e0       	ldi	r25, 0x00	; 0
    351e:	28 e1       	ldi	r18, 0x18	; 24
    3520:	fc 01       	movw	r30, r24
    3522:	20 83       	st	Z, r18
    /* Set frame format: 8data, 1stop bit */
    UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);
    3524:	82 ec       	ldi	r24, 0xC2	; 194
    3526:	90 e0       	ldi	r25, 0x00	; 0
    3528:	26 e0       	ldi	r18, 0x06	; 6
    352a:	fc 01       	movw	r30, r24
    352c:	20 83       	st	Z, r18
	 // clear U2X0 for Synchronous operation
    UCSR0A &= ~(1<<U2X0);
    352e:	80 ec       	ldi	r24, 0xC0	; 192
    3530:	90 e0       	ldi	r25, 0x00	; 0
    3532:	20 ec       	ldi	r18, 0xC0	; 192
    3534:	30 e0       	ldi	r19, 0x00	; 0
    3536:	f9 01       	movw	r30, r18
    3538:	20 81       	ld	r18, Z
    353a:	2d 7f       	andi	r18, 0xFD	; 253
    353c:	fc 01       	movw	r30, r24
    353e:	20 83       	st	Z, r18
    /* Set frame format: 8data, 1stop bit */
    //UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);
    // clear U2X0 for Synchronous operation
    //UCSR0A &= ~(1<<U2X0);*/

}
    3540:	26 96       	adiw	r28, 0x06	; 6
    3542:	0f b6       	in	r0, 0x3f	; 63
    3544:	f8 94       	cli
    3546:	de bf       	out	0x3e, r29	; 62
    3548:	0f be       	out	0x3f, r0	; 63
    354a:	cd bf       	out	0x3d, r28	; 61
    354c:	df 91       	pop	r29
    354e:	cf 91       	pop	r28
    3550:	08 95       	ret

00003552 <USART_Write>:

/*the send function will put 8bits on the trans line. */
void USART_Write(uint8_t data) {
    3552:	cf 93       	push	r28
    3554:	df 93       	push	r29
    3556:	1f 92       	push	r1
    3558:	cd b7       	in	r28, 0x3d	; 61
    355a:	de b7       	in	r29, 0x3e	; 62
    355c:	89 83       	std	Y+1, r24	; 0x01
		/* Wait for empty transmit buffer */
		while ( !( UCSR0A & (1<<UDRE0)) )
    355e:	00 00       	nop
    3560:	80 ec       	ldi	r24, 0xC0	; 192
    3562:	90 e0       	ldi	r25, 0x00	; 0
    3564:	fc 01       	movw	r30, r24
    3566:	80 81       	ld	r24, Z
    3568:	88 2f       	mov	r24, r24
    356a:	90 e0       	ldi	r25, 0x00	; 0
    356c:	80 72       	andi	r24, 0x20	; 32
    356e:	99 27       	eor	r25, r25
    3570:	00 97       	sbiw	r24, 0x00	; 0
    3572:	b1 f3       	breq	.-20     	; 0x3560 <USART_Write+0xe>
		;
		/* Put data into buffer, sends the data */
		UDR0 = data;
    3574:	86 ec       	ldi	r24, 0xC6	; 198
    3576:	90 e0       	ldi	r25, 0x00	; 0
    3578:	29 81       	ldd	r18, Y+1	; 0x01
    357a:	fc 01       	movw	r30, r24
    357c:	20 83       	st	Z, r18
}
    357e:	0f 90       	pop	r0
    3580:	df 91       	pop	r29
    3582:	cf 91       	pop	r28
    3584:	08 95       	ret

00003586 <USART_Write_Unprotected>:

/*the send function will put 8bits on the trans line. */
void USART_Write_Unprotected(uint8_t data) {
    3586:	cf 93       	push	r28
    3588:	df 93       	push	r29
    358a:	1f 92       	push	r1
    358c:	cd b7       	in	r28, 0x3d	; 61
    358e:	de b7       	in	r29, 0x3e	; 62
    3590:	89 83       	std	Y+1, r24	; 0x01
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)) )
    3592:	00 00       	nop
    3594:	80 ec       	ldi	r24, 0xC0	; 192
    3596:	90 e0       	ldi	r25, 0x00	; 0
    3598:	fc 01       	movw	r30, r24
    359a:	80 81       	ld	r24, Z
    359c:	88 2f       	mov	r24, r24
    359e:	90 e0       	ldi	r25, 0x00	; 0
    35a0:	80 72       	andi	r24, 0x20	; 32
    35a2:	99 27       	eor	r25, r25
    35a4:	00 97       	sbiw	r24, 0x00	; 0
    35a6:	b1 f3       	breq	.-20     	; 0x3594 <USART_Write_Unprotected+0xe>
	;
	/* Put data into buffer, sends the data */
	UDR0 = data;
    35a8:	86 ec       	ldi	r24, 0xC6	; 198
    35aa:	90 e0       	ldi	r25, 0x00	; 0
    35ac:	29 81       	ldd	r18, Y+1	; 0x01
    35ae:	fc 01       	movw	r30, r24
    35b0:	20 83       	st	Z, r18
}
    35b2:	0f 90       	pop	r0
    35b4:	df 91       	pop	r29
    35b6:	cf 91       	pop	r28
    35b8:	08 95       	ret

000035ba <USART_Read>:
Therefore you may not get control back after this is called 
until a much later time. It may be helpful to use the 
istheredata() function to check before calling this function
        @return 8bit data packet from sender
*/
uint8_t USART_Read(void) {
    35ba:	cf 93       	push	r28
    35bc:	df 93       	push	r29
    35be:	cd b7       	in	r28, 0x3d	; 61
    35c0:	de b7       	in	r29, 0x3e	; 62
    /* Wait for data to be received */
    while ( !(UCSR2A & (1<<RXC2)) )
    35c2:	00 00       	nop
    35c4:	80 ed       	ldi	r24, 0xD0	; 208
    35c6:	90 e0       	ldi	r25, 0x00	; 0
    35c8:	fc 01       	movw	r30, r24
    35ca:	80 81       	ld	r24, Z
    35cc:	88 23       	and	r24, r24
    35ce:	d4 f7       	brge	.-12     	; 0x35c4 <USART_Read+0xa>
        ;
    /* Get and return received data from buffer */
    return UDR2;
    35d0:	86 ed       	ldi	r24, 0xD6	; 214
    35d2:	90 e0       	ldi	r25, 0x00	; 0
    35d4:	fc 01       	movw	r30, r24
    35d6:	80 81       	ld	r24, Z
}
    35d8:	df 91       	pop	r29
    35da:	cf 91       	pop	r28
    35dc:	08 95       	ret

000035de <__vector_36>:


ISR(USART1_RX_vect){
    35de:	1f 92       	push	r1
    35e0:	0f 92       	push	r0
    35e2:	00 90 5f 00 	lds	r0, 0x005F
    35e6:	0f 92       	push	r0
    35e8:	11 24       	eor	r1, r1
    35ea:	00 90 5b 00 	lds	r0, 0x005B
    35ee:	0f 92       	push	r0
    35f0:	8f 93       	push	r24
    35f2:	9f 93       	push	r25
    35f4:	ef 93       	push	r30
    35f6:	ff 93       	push	r31
    35f8:	cf 93       	push	r28
    35fa:	df 93       	push	r29
    35fc:	1f 92       	push	r1
    35fe:	cd b7       	in	r28, 0x3d	; 61
    3600:	de b7       	in	r29, 0x3e	; 62
    uint8_t data;
    data = UDR1;
    3602:	8e ec       	ldi	r24, 0xCE	; 206
    3604:	90 e0       	ldi	r25, 0x00	; 0
    3606:	fc 01       	movw	r30, r24
    3608:	80 81       	ld	r24, Z
    360a:	89 83       	std	Y+1, r24	; 0x01
    //UDR1 = data;
    

  //  USART_AddToQueue(data);
    //xQueueSendToBackFromISR(USART_ReadQueue,&data,NULL);
}
    360c:	0f 90       	pop	r0
    360e:	df 91       	pop	r29
    3610:	cf 91       	pop	r28
    3612:	ff 91       	pop	r31
    3614:	ef 91       	pop	r30
    3616:	9f 91       	pop	r25
    3618:	8f 91       	pop	r24
    361a:	0f 90       	pop	r0
    361c:	00 92 5b 00 	sts	0x005B, r0
    3620:	0f 90       	pop	r0
    3622:	00 92 5f 00 	sts	0x005F, r0
    3626:	0f 90       	pop	r0
    3628:	1f 90       	pop	r1
    362a:	18 95       	reti

0000362c <USART_AddToQueue>:

void USART_AddToQueue(uint8_t data){
    362c:	cf 93       	push	r28
    362e:	df 93       	push	r29
    3630:	1f 92       	push	r1
    3632:	cd b7       	in	r28, 0x3d	; 61
    3634:	de b7       	in	r29, 0x3e	; 62
    3636:	89 83       	std	Y+1, r24	; 0x01
    
    xQueueSendToBack(USART_WriteQueue,&data,portMAX_DELAY);
    3638:	80 91 5b 1b 	lds	r24, 0x1B5B
    363c:	90 91 5c 1b 	lds	r25, 0x1B5C
    3640:	20 e0       	ldi	r18, 0x00	; 0
    3642:	4f ef       	ldi	r20, 0xFF	; 255
    3644:	5f ef       	ldi	r21, 0xFF	; 255
    3646:	be 01       	movw	r22, r28
    3648:	6f 5f       	subi	r22, 0xFF	; 255
    364a:	7f 4f       	sbci	r23, 0xFF	; 255
    364c:	0e 94 f9 0d 	call	0x1bf2	; 0x1bf2 <xQueueGenericSend>

}
    3650:	0f 90       	pop	r0
    3652:	df 91       	pop	r29
    3654:	cf 91       	pop	r28
    3656:	08 95       	ret

00003658 <USART_TransmitString>:

void USART_TransmitString(char* str){
    3658:	cf 93       	push	r28
    365a:	df 93       	push	r29
    365c:	1f 92       	push	r1
    365e:	1f 92       	push	r1
    3660:	cd b7       	in	r28, 0x3d	; 61
    3662:	de b7       	in	r29, 0x3e	; 62
    3664:	9a 83       	std	Y+2, r25	; 0x02
    3666:	89 83       	std	Y+1, r24	; 0x01
    while(*str) {
    3668:	0b c0       	rjmp	.+22     	; 0x3680 <USART_TransmitString+0x28>
        USART_AddToQueue(*str);
    366a:	89 81       	ldd	r24, Y+1	; 0x01
    366c:	9a 81       	ldd	r25, Y+2	; 0x02
    366e:	fc 01       	movw	r30, r24
    3670:	80 81       	ld	r24, Z
    3672:	0e 94 16 1b 	call	0x362c	; 0x362c <USART_AddToQueue>
        str++;
    3676:	89 81       	ldd	r24, Y+1	; 0x01
    3678:	9a 81       	ldd	r25, Y+2	; 0x02
    367a:	01 96       	adiw	r24, 0x01	; 1
    367c:	9a 83       	std	Y+2, r25	; 0x02
    367e:	89 83       	std	Y+1, r24	; 0x01
    xQueueSendToBack(USART_WriteQueue,&data,portMAX_DELAY);

}

void USART_TransmitString(char* str){
    while(*str) {
    3680:	89 81       	ldd	r24, Y+1	; 0x01
    3682:	9a 81       	ldd	r25, Y+2	; 0x02
    3684:	fc 01       	movw	r30, r24
    3686:	80 81       	ld	r24, Z
    3688:	88 23       	and	r24, r24
    368a:	79 f7       	brne	.-34     	; 0x366a <USART_TransmitString+0x12>
        USART_AddToQueue(*str);
        str++;
    }
}
    368c:	0f 90       	pop	r0
    368e:	0f 90       	pop	r0
    3690:	df 91       	pop	r29
    3692:	cf 91       	pop	r28
    3694:	08 95       	ret

00003696 <vTaskUSARTWrite>:

void vTaskUSARTWrite(void *pvParameters){
    3696:	cf 93       	push	r28
    3698:	df 93       	push	r29
    369a:	00 d0       	rcall	.+0      	; 0x369c <vTaskUSARTWrite+0x6>
    369c:	cd b7       	in	r28, 0x3d	; 61
    369e:	de b7       	in	r29, 0x3e	; 62
    36a0:	9b 83       	std	Y+3, r25	; 0x03
    36a2:	8a 83       	std	Y+2, r24	; 0x02
    uint8_t data;
    while(1){
    xQueueReceive(USART_WriteQueue,&data,portMAX_DELAY);
    36a4:	80 91 5b 1b 	lds	r24, 0x1B5B
    36a8:	90 91 5c 1b 	lds	r25, 0x1B5C
    36ac:	20 e0       	ldi	r18, 0x00	; 0
    36ae:	4f ef       	ldi	r20, 0xFF	; 255
    36b0:	5f ef       	ldi	r21, 0xFF	; 255
    36b2:	be 01       	movw	r22, r28
    36b4:	6f 5f       	subi	r22, 0xFF	; 255
    36b6:	7f 4f       	sbci	r23, 0xFF	; 255
    36b8:	0e 94 f6 0e 	call	0x1dec	; 0x1dec <xQueueGenericReceive>

        while(!(UCSR1A & (1<<UDRE1)));
    36bc:	00 00       	nop
    36be:	88 ec       	ldi	r24, 0xC8	; 200
    36c0:	90 e0       	ldi	r25, 0x00	; 0
    36c2:	fc 01       	movw	r30, r24
    36c4:	80 81       	ld	r24, Z
    36c6:	88 2f       	mov	r24, r24
    36c8:	90 e0       	ldi	r25, 0x00	; 0
    36ca:	80 72       	andi	r24, 0x20	; 32
    36cc:	99 27       	eor	r25, r25
    36ce:	00 97       	sbiw	r24, 0x00	; 0
    36d0:	b1 f3       	breq	.-20     	; 0x36be <vTaskUSARTWrite+0x28>
        UDR1 = data;
    36d2:	8e ec       	ldi	r24, 0xCE	; 206
    36d4:	90 e0       	ldi	r25, 0x00	; 0
    36d6:	29 81       	ldd	r18, Y+1	; 0x01
    36d8:	fc 01       	movw	r30, r24
    36da:	20 83       	st	Z, r18

    }
    36dc:	e3 cf       	rjmp	.-58     	; 0x36a4 <vTaskUSARTWrite+0xe>

000036de <USART_LogChar>:
}

void USART_LogChar(uint8_t data){
    36de:	cf 93       	push	r28
    36e0:	df 93       	push	r29
    36e2:	1f 92       	push	r1
    36e4:	cd b7       	in	r28, 0x3d	; 61
    36e6:	de b7       	in	r29, 0x3e	; 62
    36e8:	89 83       	std	Y+1, r24	; 0x01
    xQueueSendToBack(USART_WriteQueueLog,&data,portMAX_DELAY);
    36ea:	80 91 59 1b 	lds	r24, 0x1B59
    36ee:	90 91 5a 1b 	lds	r25, 0x1B5A
    36f2:	20 e0       	ldi	r18, 0x00	; 0
    36f4:	4f ef       	ldi	r20, 0xFF	; 255
    36f6:	5f ef       	ldi	r21, 0xFF	; 255
    36f8:	be 01       	movw	r22, r28
    36fa:	6f 5f       	subi	r22, 0xFF	; 255
    36fc:	7f 4f       	sbci	r23, 0xFF	; 255
    36fe:	0e 94 f9 0d 	call	0x1bf2	; 0x1bf2 <xQueueGenericSend>
}
    3702:	0f 90       	pop	r0
    3704:	df 91       	pop	r29
    3706:	cf 91       	pop	r28
    3708:	08 95       	ret

0000370a <USART_LogString>:

void USART_LogString(char* str){
    370a:	cf 93       	push	r28
    370c:	df 93       	push	r29
    370e:	1f 92       	push	r1
    3710:	1f 92       	push	r1
    3712:	cd b7       	in	r28, 0x3d	; 61
    3714:	de b7       	in	r29, 0x3e	; 62
    3716:	9a 83       	std	Y+2, r25	; 0x02
    3718:	89 83       	std	Y+1, r24	; 0x01
    while(*str){
    371a:	0b c0       	rjmp	.+22     	; 0x3732 <USART_LogString+0x28>
        USART_LogChar(*str);
    371c:	89 81       	ldd	r24, Y+1	; 0x01
    371e:	9a 81       	ldd	r25, Y+2	; 0x02
    3720:	fc 01       	movw	r30, r24
    3722:	80 81       	ld	r24, Z
    3724:	0e 94 6f 1b 	call	0x36de	; 0x36de <USART_LogChar>
        str++;
    3728:	89 81       	ldd	r24, Y+1	; 0x01
    372a:	9a 81       	ldd	r25, Y+2	; 0x02
    372c:	01 96       	adiw	r24, 0x01	; 1
    372e:	9a 83       	std	Y+2, r25	; 0x02
    3730:	89 83       	std	Y+1, r24	; 0x01
void USART_LogChar(uint8_t data){
    xQueueSendToBack(USART_WriteQueueLog,&data,portMAX_DELAY);
}

void USART_LogString(char* str){
    while(*str){
    3732:	89 81       	ldd	r24, Y+1	; 0x01
    3734:	9a 81       	ldd	r25, Y+2	; 0x02
    3736:	fc 01       	movw	r30, r24
    3738:	80 81       	ld	r24, Z
    373a:	88 23       	and	r24, r24
    373c:	79 f7       	brne	.-34     	; 0x371c <USART_LogString+0x12>
        USART_LogChar(*str);
        str++;
    }
}
    373e:	0f 90       	pop	r0
    3740:	0f 90       	pop	r0
    3742:	df 91       	pop	r29
    3744:	cf 91       	pop	r28
    3746:	08 95       	ret

00003748 <vTaskUSARTLog>:

void vTaskUSARTLog(void *pvParameters){
    3748:	cf 93       	push	r28
    374a:	df 93       	push	r29
    374c:	00 d0       	rcall	.+0      	; 0x374e <vTaskUSARTLog+0x6>
    374e:	cd b7       	in	r28, 0x3d	; 61
    3750:	de b7       	in	r29, 0x3e	; 62
    3752:	9b 83       	std	Y+3, r25	; 0x03
    3754:	8a 83       	std	Y+2, r24	; 0x02
    uint8_t data;
    while(1){
        xQueueReceive(USART_WriteQueueLog,&data,portMAX_DELAY);
    3756:	80 91 59 1b 	lds	r24, 0x1B59
    375a:	90 91 5a 1b 	lds	r25, 0x1B5A
    375e:	20 e0       	ldi	r18, 0x00	; 0
    3760:	4f ef       	ldi	r20, 0xFF	; 255
    3762:	5f ef       	ldi	r21, 0xFF	; 255
    3764:	be 01       	movw	r22, r28
    3766:	6f 5f       	subi	r22, 0xFF	; 255
    3768:	7f 4f       	sbci	r23, 0xFF	; 255
    376a:	0e 94 f6 0e 	call	0x1dec	; 0x1dec <xQueueGenericReceive>

        while(!(UCSR0A & (1<<UDRE0)));
    376e:	00 00       	nop
    3770:	80 ec       	ldi	r24, 0xC0	; 192
    3772:	90 e0       	ldi	r25, 0x00	; 0
    3774:	fc 01       	movw	r30, r24
    3776:	80 81       	ld	r24, Z
    3778:	88 2f       	mov	r24, r24
    377a:	90 e0       	ldi	r25, 0x00	; 0
    377c:	80 72       	andi	r24, 0x20	; 32
    377e:	99 27       	eor	r25, r25
    3780:	00 97       	sbiw	r24, 0x00	; 0
    3782:	b1 f3       	breq	.-20     	; 0x3770 <vTaskUSARTLog+0x28>
        UDR0 = data;
    3784:	86 ec       	ldi	r24, 0xC6	; 198
    3786:	90 e0       	ldi	r25, 0x00	; 0
    3788:	29 81       	ldd	r18, Y+1	; 0x01
    378a:	fc 01       	movw	r30, r24
    378c:	20 83       	st	Z, r18

    }
    378e:	e3 cf       	rjmp	.-58     	; 0x3756 <vTaskUSARTLog+0xe>

00003790 <USART_GetChar>:

}

uint8_t USART_GetChar(){
    3790:	cf 93       	push	r28
    3792:	df 93       	push	r29
    3794:	1f 92       	push	r1
    3796:	cd b7       	in	r28, 0x3d	; 61
    3798:	de b7       	in	r29, 0x3e	; 62
    uint8_t data;
    if(xQueueReceive(USART_ReadQueue,&data,1) == pdTRUE){
    379a:	80 91 57 1b 	lds	r24, 0x1B57
    379e:	90 91 58 1b 	lds	r25, 0x1B58
    37a2:	20 e0       	ldi	r18, 0x00	; 0
    37a4:	41 e0       	ldi	r20, 0x01	; 1
    37a6:	50 e0       	ldi	r21, 0x00	; 0
    37a8:	be 01       	movw	r22, r28
    37aa:	6f 5f       	subi	r22, 0xFF	; 255
    37ac:	7f 4f       	sbci	r23, 0xFF	; 255
    37ae:	0e 94 f6 0e 	call	0x1dec	; 0x1dec <xQueueGenericReceive>
    37b2:	81 30       	cpi	r24, 0x01	; 1
    37b4:	11 f4       	brne	.+4      	; 0x37ba <USART_GetChar+0x2a>
        //USART_AddToQueue('~');
        return data;
    37b6:	89 81       	ldd	r24, Y+1	; 0x01
    37b8:	01 c0       	rjmp	.+2      	; 0x37bc <USART_GetChar+0x2c>
    } else {
        return 255;
    37ba:	8f ef       	ldi	r24, 0xFF	; 255
    }
}
    37bc:	0f 90       	pop	r0
    37be:	df 91       	pop	r29
    37c0:	cf 91       	pop	r28
    37c2:	08 95       	ret

000037c4 <delay>:

void delay(int a){
    37c4:	cf 93       	push	r28
    37c6:	df 93       	push	r29
    37c8:	00 d0       	rcall	.+0      	; 0x37ca <delay+0x6>
    37ca:	1f 92       	push	r1
    37cc:	cd b7       	in	r28, 0x3d	; 61
    37ce:	de b7       	in	r29, 0x3e	; 62
    37d0:	9c 83       	std	Y+4, r25	; 0x04
    37d2:	8b 83       	std	Y+3, r24	; 0x03
	int i;
	for(i = 0;i < a;i++);
    37d4:	1a 82       	std	Y+2, r1	; 0x02
    37d6:	19 82       	std	Y+1, r1	; 0x01
    37d8:	05 c0       	rjmp	.+10     	; 0x37e4 <delay+0x20>
    37da:	89 81       	ldd	r24, Y+1	; 0x01
    37dc:	9a 81       	ldd	r25, Y+2	; 0x02
    37de:	01 96       	adiw	r24, 0x01	; 1
    37e0:	9a 83       	std	Y+2, r25	; 0x02
    37e2:	89 83       	std	Y+1, r24	; 0x01
    37e4:	29 81       	ldd	r18, Y+1	; 0x01
    37e6:	3a 81       	ldd	r19, Y+2	; 0x02
    37e8:	8b 81       	ldd	r24, Y+3	; 0x03
    37ea:	9c 81       	ldd	r25, Y+4	; 0x04
    37ec:	28 17       	cp	r18, r24
    37ee:	39 07       	cpc	r19, r25
    37f0:	a4 f3       	brlt	.-24     	; 0x37da <delay+0x16>
}
    37f2:	0f 90       	pop	r0
    37f4:	0f 90       	pop	r0
    37f6:	0f 90       	pop	r0
    37f8:	0f 90       	pop	r0
    37fa:	df 91       	pop	r29
    37fc:	cf 91       	pop	r28
    37fe:	08 95       	ret

00003800 <sendACK>:

void sendACK(){
    3800:	cf 93       	push	r28
    3802:	df 93       	push	r29
    3804:	cd b7       	in	r28, 0x3d	; 61
    3806:	de b7       	in	r29, 0x3e	; 62
    USART_Write(ACK_BYTE);
    3808:	80 e8       	ldi	r24, 0x80	; 128
    380a:	0e 94 a9 1a 	call	0x3552	; 0x3552 <USART_Write>
}
    380e:	df 91       	pop	r29
    3810:	cf 91       	pop	r28
    3812:	08 95       	ret

00003814 <sendNACK>:

void sendNACK(){
    3814:	cf 93       	push	r28
    3816:	df 93       	push	r29
    3818:	cd b7       	in	r28, 0x3d	; 61
    381a:	de b7       	in	r29, 0x3e	; 62
    USART_Write(NACK_BYTE);
    381c:	80 e0       	ldi	r24, 0x00	; 0
    381e:	0e 94 a9 1a 	call	0x3552	; 0x3552 <USART_Write>
}
    3822:	df 91       	pop	r29
    3824:	cf 91       	pop	r28
    3826:	08 95       	ret

00003828 <recievePayload>:

int recievePayload(int size,unsigned char *buffer){
    3828:	cf 93       	push	r28
    382a:	df 93       	push	r29
    382c:	cd b7       	in	r28, 0x3d	; 61
    382e:	de b7       	in	r29, 0x3e	; 62
    3830:	2d 97       	sbiw	r28, 0x0d	; 13
    3832:	0f b6       	in	r0, 0x3f	; 63
    3834:	f8 94       	cli
    3836:	de bf       	out	0x3e, r29	; 62
    3838:	0f be       	out	0x3f, r0	; 63
    383a:	cd bf       	out	0x3d, r28	; 61
    383c:	9b 87       	std	Y+11, r25	; 0x0b
    383e:	8a 87       	std	Y+10, r24	; 0x0a
    3840:	7d 87       	std	Y+13, r23	; 0x0d
    3842:	6c 87       	std	Y+12, r22	; 0x0c

	int bytesRecieved = 0;
    3844:	1a 82       	std	Y+2, r1	; 0x02
    3846:	19 82       	std	Y+1, r1	; 0x01
	int numTries = 0;
    3848:	1c 82       	std	Y+4, r1	; 0x04
    384a:	1b 82       	std	Y+3, r1	; 0x03
	const int maxNumTries = 3;
    384c:	83 e0       	ldi	r24, 0x03	; 3
    384e:	90 e0       	ldi	r25, 0x00	; 0
    3850:	98 87       	std	Y+8, r25	; 0x08
    3852:	8f 83       	std	Y+7, r24	; 0x07
	unsigned char data;
	int timeout;

	while(numTries < maxNumTries){
    3854:	6d c0       	rjmp	.+218    	; 0x3930 <recievePayload+0x108>
		while(bytesRecieved < size){
    3856:	2e c0       	rjmp	.+92     	; 0x38b4 <recievePayload+0x8c>
			timeout = 50;
    3858:	82 e3       	ldi	r24, 0x32	; 50
    385a:	90 e0       	ldi	r25, 0x00	; 0
    385c:	9e 83       	std	Y+6, r25	; 0x06
    385e:	8d 83       	std	Y+5, r24	; 0x05
			while ( !(UCSR0A & (1<<RXC0)) ){
    3860:	10 c0       	rjmp	.+32     	; 0x3882 <recievePayload+0x5a>
  				timeout--;
    3862:	8d 81       	ldd	r24, Y+5	; 0x05
    3864:	9e 81       	ldd	r25, Y+6	; 0x06
    3866:	01 97       	sbiw	r24, 0x01	; 1
    3868:	9e 83       	std	Y+6, r25	; 0x06
    386a:	8d 83       	std	Y+5, r24	; 0x05
     			if(timeout == 0){
    386c:	8d 81       	ldd	r24, Y+5	; 0x05
    386e:	9e 81       	ldd	r25, Y+6	; 0x06
    3870:	00 97       	sbiw	r24, 0x00	; 0
    3872:	19 f4       	brne	.+6      	; 0x387a <recievePayload+0x52>
					return -1;
    3874:	8f ef       	ldi	r24, 0xFF	; 255
    3876:	9f ef       	ldi	r25, 0xFF	; 255
    3878:	65 c0       	rjmp	.+202    	; 0x3944 <recievePayload+0x11c>
     			}
     			vTaskDelay(1);
    387a:	81 e0       	ldi	r24, 0x01	; 1
    387c:	90 e0       	ldi	r25, 0x00	; 0
    387e:	0e 94 ca 04 	call	0x994	; 0x994 <vTaskDelay>
	int timeout;

	while(numTries < maxNumTries){
		while(bytesRecieved < size){
			timeout = 50;
			while ( !(UCSR0A & (1<<RXC0)) ){
    3882:	80 ec       	ldi	r24, 0xC0	; 192
    3884:	90 e0       	ldi	r25, 0x00	; 0
    3886:	fc 01       	movw	r30, r24
    3888:	80 81       	ld	r24, Z
    388a:	88 23       	and	r24, r24
    388c:	54 f7       	brge	.-44     	; 0x3862 <recievePayload+0x3a>
     			if(timeout == 0){
					return -1;
     			}
     			vTaskDelay(1);
   		}
			data = UDR0;
    388e:	86 ec       	ldi	r24, 0xC6	; 198
    3890:	90 e0       	ldi	r25, 0x00	; 0
    3892:	fc 01       	movw	r30, r24
    3894:	80 81       	ld	r24, Z
    3896:	89 87       	std	Y+9, r24	; 0x09
			buffer[bytesRecieved] = data;
    3898:	89 81       	ldd	r24, Y+1	; 0x01
    389a:	9a 81       	ldd	r25, Y+2	; 0x02
    389c:	2c 85       	ldd	r18, Y+12	; 0x0c
    389e:	3d 85       	ldd	r19, Y+13	; 0x0d
    38a0:	82 0f       	add	r24, r18
    38a2:	93 1f       	adc	r25, r19
    38a4:	29 85       	ldd	r18, Y+9	; 0x09
    38a6:	fc 01       	movw	r30, r24
    38a8:	20 83       	st	Z, r18
			bytesRecieved++;
    38aa:	89 81       	ldd	r24, Y+1	; 0x01
    38ac:	9a 81       	ldd	r25, Y+2	; 0x02
    38ae:	01 96       	adiw	r24, 0x01	; 1
    38b0:	9a 83       	std	Y+2, r25	; 0x02
    38b2:	89 83       	std	Y+1, r24	; 0x01
	const int maxNumTries = 3;
	unsigned char data;
	int timeout;

	while(numTries < maxNumTries){
		while(bytesRecieved < size){
    38b4:	29 81       	ldd	r18, Y+1	; 0x01
    38b6:	3a 81       	ldd	r19, Y+2	; 0x02
    38b8:	8a 85       	ldd	r24, Y+10	; 0x0a
    38ba:	9b 85       	ldd	r25, Y+11	; 0x0b
    38bc:	28 17       	cp	r18, r24
    38be:	39 07       	cpc	r19, r25
    38c0:	5c f2       	brlt	.-106    	; 0x3858 <recievePayload+0x30>
			data = UDR0;
			buffer[bytesRecieved] = data;
			bytesRecieved++;
		}
		
		timeout = 50;
    38c2:	82 e3       	ldi	r24, 0x32	; 50
    38c4:	90 e0       	ldi	r25, 0x00	; 0
    38c6:	9e 83       	std	Y+6, r25	; 0x06
    38c8:	8d 83       	std	Y+5, r24	; 0x05
		while ( !(UCSR0A & (1<<RXC0)) ){
    38ca:	10 c0       	rjmp	.+32     	; 0x38ec <recievePayload+0xc4>
  			timeout--;
    38cc:	8d 81       	ldd	r24, Y+5	; 0x05
    38ce:	9e 81       	ldd	r25, Y+6	; 0x06
    38d0:	01 97       	sbiw	r24, 0x01	; 1
    38d2:	9e 83       	std	Y+6, r25	; 0x06
    38d4:	8d 83       	std	Y+5, r24	; 0x05
     		if(timeout == 0){
    38d6:	8d 81       	ldd	r24, Y+5	; 0x05
    38d8:	9e 81       	ldd	r25, Y+6	; 0x06
    38da:	00 97       	sbiw	r24, 0x00	; 0
    38dc:	19 f4       	brne	.+6      	; 0x38e4 <recievePayload+0xbc>
				return -1;
    38de:	8f ef       	ldi	r24, 0xFF	; 255
    38e0:	9f ef       	ldi	r25, 0xFF	; 255
    38e2:	30 c0       	rjmp	.+96     	; 0x3944 <recievePayload+0x11c>
     		}
     		vTaskDelay(1);
    38e4:	81 e0       	ldi	r24, 0x01	; 1
    38e6:	90 e0       	ldi	r25, 0x00	; 0
    38e8:	0e 94 ca 04 	call	0x994	; 0x994 <vTaskDelay>
			buffer[bytesRecieved] = data;
			bytesRecieved++;
		}
		
		timeout = 50;
		while ( !(UCSR0A & (1<<RXC0)) ){
    38ec:	80 ec       	ldi	r24, 0xC0	; 192
    38ee:	90 e0       	ldi	r25, 0x00	; 0
    38f0:	fc 01       	movw	r30, r24
    38f2:	80 81       	ld	r24, Z
    38f4:	88 23       	and	r24, r24
    38f6:	54 f7       	brge	.-44     	; 0x38cc <recievePayload+0xa4>
     		if(timeout == 0){
				return -1;
     		}
     		vTaskDelay(1);
   	}	
		data = UDR0;
    38f8:	86 ec       	ldi	r24, 0xC6	; 198
    38fa:	90 e0       	ldi	r25, 0x00	; 0
    38fc:	fc 01       	movw	r30, r24
    38fe:	80 81       	ld	r24, Z
    3900:	89 87       	std	Y+9, r24	; 0x09
		if(data != calcChecksum(buffer,size)){
    3902:	2a 85       	ldd	r18, Y+10	; 0x0a
    3904:	8c 85       	ldd	r24, Y+12	; 0x0c
    3906:	9d 85       	ldd	r25, Y+13	; 0x0d
    3908:	62 2f       	mov	r22, r18
    390a:	0e 94 eb 1d 	call	0x3bd6	; 0x3bd6 <calcChecksum>
    390e:	98 2f       	mov	r25, r24
    3910:	89 85       	ldd	r24, Y+9	; 0x09
    3912:	98 17       	cp	r25, r24
    3914:	41 f0       	breq	.+16     	; 0x3926 <recievePayload+0xfe>
			sendNACK();
    3916:	0e 94 0a 1c 	call	0x3814	; 0x3814 <sendNACK>
			numTries++;
    391a:	8b 81       	ldd	r24, Y+3	; 0x03
    391c:	9c 81       	ldd	r25, Y+4	; 0x04
    391e:	01 96       	adiw	r24, 0x01	; 1
    3920:	9c 83       	std	Y+4, r25	; 0x04
    3922:	8b 83       	std	Y+3, r24	; 0x03
    3924:	05 c0       	rjmp	.+10     	; 0x3930 <recievePayload+0x108>
		} else {
			sendACK();
    3926:	0e 94 00 1c 	call	0x3800	; 0x3800 <sendACK>
			return 0;
    392a:	80 e0       	ldi	r24, 0x00	; 0
    392c:	90 e0       	ldi	r25, 0x00	; 0
    392e:	0a c0       	rjmp	.+20     	; 0x3944 <recievePayload+0x11c>
	int numTries = 0;
	const int maxNumTries = 3;
	unsigned char data;
	int timeout;

	while(numTries < maxNumTries){
    3930:	2b 81       	ldd	r18, Y+3	; 0x03
    3932:	3c 81       	ldd	r19, Y+4	; 0x04
    3934:	8f 81       	ldd	r24, Y+7	; 0x07
    3936:	98 85       	ldd	r25, Y+8	; 0x08
    3938:	28 17       	cp	r18, r24
    393a:	39 07       	cpc	r19, r25
    393c:	0c f4       	brge	.+2      	; 0x3940 <recievePayload+0x118>
    393e:	8b cf       	rjmp	.-234    	; 0x3856 <recievePayload+0x2e>
		} else {
			sendACK();
			return 0;
		}
	}
	return -1;
    3940:	8f ef       	ldi	r24, 0xFF	; 255
    3942:	9f ef       	ldi	r25, 0xFF	; 255
}
    3944:	2d 96       	adiw	r28, 0x0d	; 13
    3946:	0f b6       	in	r0, 0x3f	; 63
    3948:	f8 94       	cli
    394a:	de bf       	out	0x3e, r29	; 62
    394c:	0f be       	out	0x3f, r0	; 63
    394e:	cd bf       	out	0x3d, r28	; 61
    3950:	df 91       	pop	r29
    3952:	cf 91       	pop	r28
    3954:	08 95       	ret

00003956 <vTaskUSARTRead>:

void vTaskUSARTRead(void *pvParameters){
    3956:	cf 93       	push	r28
    3958:	df 93       	push	r29
    395a:	cd b7       	in	r28, 0x3d	; 61
    395c:	de b7       	in	r29, 0x3e	; 62
    395e:	cc 55       	subi	r28, 0x5C	; 92
    3960:	d1 09       	sbc	r29, r1
    3962:	0f b6       	in	r0, 0x3f	; 63
    3964:	f8 94       	cli
    3966:	de bf       	out	0x3e, r29	; 62
    3968:	0f be       	out	0x3f, r0	; 63
    396a:	cd bf       	out	0x3d, r28	; 61
    396c:	9e 01       	movw	r18, r28
    396e:	25 5a       	subi	r18, 0xA5	; 165
    3970:	3f 4f       	sbci	r19, 0xFF	; 255
    3972:	f9 01       	movw	r30, r18
    3974:	91 83       	std	Z+1, r25	; 0x01
    3976:	80 83       	st	Z, r24
    unsigned char size;
    char groupID;
    char cmd;
    unsigned int timeout;

	DDRB = 0xFF;
    3978:	84 e2       	ldi	r24, 0x24	; 36
    397a:	90 e0       	ldi	r25, 0x00	; 0
    397c:	2f ef       	ldi	r18, 0xFF	; 255
    397e:	fc 01       	movw	r30, r24
    3980:	20 83       	st	Z, r18

    Command command;
    Response response;
    while(1){
        bytesRecieved = 0;
    3982:	19 82       	std	Y+1, r1	; 0x01
        int timeout = 30;
    3984:	8e e1       	ldi	r24, 0x1E	; 30
    3986:	90 e0       	ldi	r25, 0x00	; 0
    3988:	9b 83       	std	Y+3, r25	; 0x03
    398a:	8a 83       	std	Y+2, r24	; 0x02
        while(bytesRecieved < 4){
    398c:	2d c0       	rjmp	.+90     	; 0x39e8 <vTaskUSARTRead+0x92>
            
            while ( !(UCSR0A & (1<<RXC0)) ){
    398e:	12 c0       	rjmp	.+36     	; 0x39b4 <vTaskUSARTRead+0x5e>
                timeout--;
    3990:	8a 81       	ldd	r24, Y+2	; 0x02
    3992:	9b 81       	ldd	r25, Y+3	; 0x03
    3994:	01 97       	sbiw	r24, 0x01	; 1
    3996:	9b 83       	std	Y+3, r25	; 0x03
    3998:	8a 83       	std	Y+2, r24	; 0x02
                if(timeout == 0){
    399a:	8a 81       	ldd	r24, Y+2	; 0x02
    399c:	9b 81       	ldd	r25, Y+3	; 0x03
    399e:	00 97       	sbiw	r24, 0x00	; 0
    39a0:	29 f4       	brne	.+10     	; 0x39ac <vTaskUSARTRead+0x56>
                    bytesRecieved = 0;
    39a2:	19 82       	std	Y+1, r1	; 0x01
                    timeout = 30;
    39a4:	8e e1       	ldi	r24, 0x1E	; 30
    39a6:	90 e0       	ldi	r25, 0x00	; 0
    39a8:	9b 83       	std	Y+3, r25	; 0x03
    39aa:	8a 83       	std	Y+2, r24	; 0x02
                }
                vTaskDelay(1);
    39ac:	81 e0       	ldi	r24, 0x01	; 1
    39ae:	90 e0       	ldi	r25, 0x00	; 0
    39b0:	0e 94 ca 04 	call	0x994	; 0x994 <vTaskDelay>
    while(1){
        bytesRecieved = 0;
        int timeout = 30;
        while(bytesRecieved < 4){
            
            while ( !(UCSR0A & (1<<RXC0)) ){
    39b4:	80 ec       	ldi	r24, 0xC0	; 192
    39b6:	90 e0       	ldi	r25, 0x00	; 0
    39b8:	fc 01       	movw	r30, r24
    39ba:	80 81       	ld	r24, Z
    39bc:	88 23       	and	r24, r24
    39be:	44 f7       	brge	.-48     	; 0x3990 <vTaskUSARTRead+0x3a>
                    bytesRecieved = 0;
                    timeout = 30;
                }
                vTaskDelay(1);
            }
            data = UDR0;
    39c0:	86 ec       	ldi	r24, 0xC6	; 198
    39c2:	90 e0       	ldi	r25, 0x00	; 0
    39c4:	fc 01       	movw	r30, r24
    39c6:	80 81       	ld	r24, Z
    39c8:	8c 83       	std	Y+4, r24	; 0x04
            buffer[bytesRecieved] = data;
    39ca:	89 81       	ldd	r24, Y+1	; 0x01
    39cc:	99 27       	eor	r25, r25
    39ce:	87 fd       	sbrc	r24, 7
    39d0:	90 95       	com	r25
    39d2:	9e 01       	movw	r18, r28
    39d4:	2a 5f       	subi	r18, 0xFA	; 250
    39d6:	3f 4f       	sbci	r19, 0xFF	; 255
    39d8:	82 0f       	add	r24, r18
    39da:	93 1f       	adc	r25, r19
    39dc:	2c 81       	ldd	r18, Y+4	; 0x04
    39de:	fc 01       	movw	r30, r24
    39e0:	20 83       	st	Z, r18
            bytesRecieved++;        
    39e2:	89 81       	ldd	r24, Y+1	; 0x01
    39e4:	8f 5f       	subi	r24, 0xFF	; 255
    39e6:	89 83       	std	Y+1, r24	; 0x01
    Command command;
    Response response;
    while(1){
        bytesRecieved = 0;
        int timeout = 30;
        while(bytesRecieved < 4){
    39e8:	89 81       	ldd	r24, Y+1	; 0x01
    39ea:	84 30       	cpi	r24, 0x04	; 4
    39ec:	84 f2       	brlt	.-96     	; 0x398e <vTaskUSARTRead+0x38>
            data = UDR0;
            buffer[bytesRecieved] = data;
            bytesRecieved++;        
        }

        if(calcChecksum(buffer,3) != buffer[3]){
    39ee:	ce 01       	movw	r24, r28
    39f0:	06 96       	adiw	r24, 0x06	; 6
    39f2:	63 e0       	ldi	r22, 0x03	; 3
    39f4:	0e 94 eb 1d 	call	0x3bd6	; 0x3bd6 <calcChecksum>
    39f8:	98 2f       	mov	r25, r24
    39fa:	89 85       	ldd	r24, Y+9	; 0x09
    39fc:	98 17       	cp	r25, r24
    39fe:	21 f0       	breq	.+8      	; 0x3a08 <vTaskUSARTRead+0xb2>
            sendNACK();
    3a00:	0e 94 0a 1c 	call	0x3814	; 0x3814 <sendNACK>
            bytesRecieved = 0;
    3a04:	19 82       	std	Y+1, r1	; 0x01
    3a06:	29 c0       	rjmp	.+82     	; 0x3a5a <vTaskUSARTRead+0x104>
        } else {
            sendACK();
    3a08:	0e 94 00 1c 	call	0x3800	; 0x3800 <sendACK>
            bytesRecieved = 0;
    3a0c:	19 82       	std	Y+1, r1	; 0x01
				command.groupID = buffer[0];
    3a0e:	8e 81       	ldd	r24, Y+6	; 0x06
    3a10:	8e 8b       	std	Y+22, r24	; 0x16
				command.cmd = buffer[1];
    3a12:	8f 81       	ldd	r24, Y+7	; 0x07
    3a14:	8f 8b       	std	Y+23, r24	; 0x17
				size = buffer[2];
    3a16:	88 85       	ldd	r24, Y+8	; 0x08
    3a18:	8d 83       	std	Y+5, r24	; 0x05

				if(size > 0){ //No dynamic memory allocations. 16 is the size of the buffer
    3a1a:	8d 81       	ldd	r24, Y+5	; 0x05
    3a1c:	88 23       	and	r24, r24
    3a1e:	81 f0       	breq	.+32     	; 0x3a40 <vTaskUSARTRead+0xea>
					if(recievePayload(size,command.payload) == -1){
    3a20:	8d 81       	ldd	r24, Y+5	; 0x05
    3a22:	88 2f       	mov	r24, r24
    3a24:	90 e0       	ldi	r25, 0x00	; 0
    3a26:	9e 01       	movw	r18, r28
    3a28:	2a 5e       	subi	r18, 0xEA	; 234
    3a2a:	3f 4f       	sbci	r19, 0xFF	; 255
    3a2c:	2d 5f       	subi	r18, 0xFD	; 253
    3a2e:	3f 4f       	sbci	r19, 0xFF	; 255
    3a30:	b9 01       	movw	r22, r18
    3a32:	0e 94 14 1c 	call	0x3828	; 0x3828 <recievePayload>
    3a36:	8f 3f       	cpi	r24, 0xFF	; 255
    3a38:	ff ef       	ldi	r31, 0xFF	; 255
    3a3a:	9f 07       	cpc	r25, r31
    3a3c:	09 f4       	brne	.+2      	; 0x3a40 <vTaskUSARTRead+0xea>
						continue;	//Restart comms
    3a3e:	0d c0       	rjmp	.+26     	; 0x3a5a <vTaskUSARTRead+0x104>
					}
				}
				
 
            processCommand(&command,&response);
    3a40:	9e 01       	movw	r18, r28
    3a42:	27 5c       	subi	r18, 0xC7	; 199
    3a44:	3f 4f       	sbci	r19, 0xFF	; 255
    3a46:	ce 01       	movw	r24, r28
    3a48:	46 96       	adiw	r24, 0x16	; 22
    3a4a:	b9 01       	movw	r22, r18
    3a4c:	0e 94 c2 1f 	call	0x3f84	; 0x3f84 <processCommand>
            sendResponse(&response);
    3a50:	ce 01       	movw	r24, r28
    3a52:	c9 96       	adiw	r24, 0x39	; 57
    3a54:	0e 94 2e 1d 	call	0x3a5c	; 0x3a5c <sendResponse>

        }

    }
    3a58:	94 cf       	rjmp	.-216    	; 0x3982 <vTaskUSARTRead+0x2c>
    3a5a:	93 cf       	rjmp	.-218    	; 0x3982 <vTaskUSARTRead+0x2c>

00003a5c <sendResponse>:

}

int sendResponse(Response* response){
    3a5c:	cf 93       	push	r28
    3a5e:	df 93       	push	r29
    3a60:	cd b7       	in	r28, 0x3d	; 61
    3a62:	de b7       	in	r29, 0x3e	; 62
    3a64:	28 97       	sbiw	r28, 0x08	; 8
    3a66:	0f b6       	in	r0, 0x3f	; 63
    3a68:	f8 94       	cli
    3a6a:	de bf       	out	0x3e, r29	; 62
    3a6c:	0f be       	out	0x3f, r0	; 63
    3a6e:	cd bf       	out	0x3d, r28	; 61
    3a70:	98 87       	std	Y+8, r25	; 0x08
    3a72:	8f 83       	std	Y+7, r24	; 0x07
    char checksumBuffer[2];
    int i;
    int timeout = 50;
    3a74:	82 e3       	ldi	r24, 0x32	; 50
    3a76:	90 e0       	ldi	r25, 0x00	; 0
    3a78:	9c 83       	std	Y+4, r25	; 0x04
    3a7a:	8b 83       	std	Y+3, r24	; 0x03
    while(1){
        	USART_Write(response->commandBack);
    3a7c:	8f 81       	ldd	r24, Y+7	; 0x07
    3a7e:	98 85       	ldd	r25, Y+8	; 0x08
    3a80:	fc 01       	movw	r30, r24
    3a82:	80 81       	ld	r24, Z
    3a84:	0e 94 a9 1a 	call	0x3552	; 0x3552 <USART_Write>
			vTaskDelay(1);
    3a88:	81 e0       	ldi	r24, 0x01	; 1
    3a8a:	90 e0       	ldi	r25, 0x00	; 0
    3a8c:	0e 94 ca 04 	call	0x994	; 0x994 <vTaskDelay>
        	USART_Write(response->size);
    3a90:	8f 81       	ldd	r24, Y+7	; 0x07
    3a92:	98 85       	ldd	r25, Y+8	; 0x08
    3a94:	fc 01       	movw	r30, r24
    3a96:	81 81       	ldd	r24, Z+1	; 0x01
    3a98:	0e 94 a9 1a 	call	0x3552	; 0x3552 <USART_Write>
			vTaskDelay(1);
    3a9c:	81 e0       	ldi	r24, 0x01	; 1
    3a9e:	90 e0       	ldi	r25, 0x00	; 0
    3aa0:	0e 94 ca 04 	call	0x994	; 0x994 <vTaskDelay>
        	checksumBuffer[0] = response->commandBack;
    3aa4:	8f 81       	ldd	r24, Y+7	; 0x07
    3aa6:	98 85       	ldd	r25, Y+8	; 0x08
    3aa8:	fc 01       	movw	r30, r24
    3aaa:	80 81       	ld	r24, Z
    3aac:	8d 83       	std	Y+5, r24	; 0x05
        	checksumBuffer[1] = response->size;
    3aae:	8f 81       	ldd	r24, Y+7	; 0x07
    3ab0:	98 85       	ldd	r25, Y+8	; 0x08
    3ab2:	fc 01       	movw	r30, r24
    3ab4:	81 81       	ldd	r24, Z+1	; 0x01
    3ab6:	8e 83       	std	Y+6, r24	; 0x06
        	USART_Write(calcChecksum(checksumBuffer,2));
    3ab8:	ce 01       	movw	r24, r28
    3aba:	05 96       	adiw	r24, 0x05	; 5
    3abc:	62 e0       	ldi	r22, 0x02	; 2
    3abe:	0e 94 eb 1d 	call	0x3bd6	; 0x3bd6 <calcChecksum>
    3ac2:	0e 94 a9 1a 	call	0x3552	; 0x3552 <USART_Write>
        	switch(waitForAck()){
    3ac6:	0e 94 c1 1d 	call	0x3b82	; 0x3b82 <waitForAck>
    3aca:	99 27       	eor	r25, r25
    3acc:	87 fd       	sbrc	r24, 7
    3ace:	90 95       	com	r25
    3ad0:	00 97       	sbiw	r24, 0x00	; 0
    3ad2:	59 f0       	breq	.+22     	; 0x3aea <sendResponse+0x8e>
    3ad4:	81 30       	cpi	r24, 0x01	; 1
    3ad6:	91 05       	cpc	r25, r1
    3ad8:	a9 f0       	breq	.+42     	; 0x3b04 <sendResponse+0xa8>
    3ada:	8f 3f       	cpi	r24, 0xFF	; 255
    3adc:	ff ef       	ldi	r31, 0xFF	; 255
    3ade:	9f 07       	cpc	r25, r31
    3ae0:	09 f0       	breq	.+2      	; 0x3ae4 <sendResponse+0x88>
           	timeout--;
           	if(!timeout){
              	return -1;
           	}
        	}
    }
    3ae2:	cc cf       	rjmp	.-104    	; 0x3a7c <sendResponse+0x20>
        	USART_Write(calcChecksum(checksumBuffer,2));
        	switch(waitForAck()){
        	case 1:
           	goto outOfWhile;
        	case -1:
           	return -1;
    3ae4:	8f ef       	ldi	r24, 0xFF	; 255
    3ae6:	9f ef       	ldi	r25, 0xFF	; 255
    3ae8:	43 c0       	rjmp	.+134    	; 0x3b70 <sendResponse+0x114>
        	case 0:
           	timeout--;
    3aea:	8b 81       	ldd	r24, Y+3	; 0x03
    3aec:	9c 81       	ldd	r25, Y+4	; 0x04
    3aee:	01 97       	sbiw	r24, 0x01	; 1
    3af0:	9c 83       	std	Y+4, r25	; 0x04
    3af2:	8b 83       	std	Y+3, r24	; 0x03
           	if(!timeout){
    3af4:	8b 81       	ldd	r24, Y+3	; 0x03
    3af6:	9c 81       	ldd	r25, Y+4	; 0x04
    3af8:	00 97       	sbiw	r24, 0x00	; 0
    3afa:	19 f4       	brne	.+6      	; 0x3b02 <sendResponse+0xa6>
              	return -1;
    3afc:	8f ef       	ldi	r24, 0xFF	; 255
    3afe:	9f ef       	ldi	r25, 0xFF	; 255
    3b00:	37 c0       	rjmp	.+110    	; 0x3b70 <sendResponse+0x114>
           	}
        	}
    }
    3b02:	bc cf       	rjmp	.-136    	; 0x3a7c <sendResponse+0x20>
        	checksumBuffer[0] = response->commandBack;
        	checksumBuffer[1] = response->size;
        	USART_Write(calcChecksum(checksumBuffer,2));
        	switch(waitForAck()){
        	case 1:
           	goto outOfWhile;
    3b04:	00 00       	nop
    }

    outOfWhile:


    for(i=0;i<response->size;i++){
    3b06:	1a 82       	std	Y+2, r1	; 0x02
    3b08:	19 82       	std	Y+1, r1	; 0x01
    3b0a:	14 c0       	rjmp	.+40     	; 0x3b34 <sendResponse+0xd8>
        USART_Write(response->payload[i]);
    3b0c:	2f 81       	ldd	r18, Y+7	; 0x07
    3b0e:	38 85       	ldd	r19, Y+8	; 0x08
    3b10:	89 81       	ldd	r24, Y+1	; 0x01
    3b12:	9a 81       	ldd	r25, Y+2	; 0x02
    3b14:	82 0f       	add	r24, r18
    3b16:	93 1f       	adc	r25, r19
    3b18:	02 96       	adiw	r24, 0x02	; 2
    3b1a:	fc 01       	movw	r30, r24
    3b1c:	80 81       	ld	r24, Z
    3b1e:	0e 94 a9 1a 	call	0x3552	; 0x3552 <USART_Write>
			vTaskDelay(1);
    3b22:	81 e0       	ldi	r24, 0x01	; 1
    3b24:	90 e0       	ldi	r25, 0x00	; 0
    3b26:	0e 94 ca 04 	call	0x994	; 0x994 <vTaskDelay>
    }

    outOfWhile:


    for(i=0;i<response->size;i++){
    3b2a:	89 81       	ldd	r24, Y+1	; 0x01
    3b2c:	9a 81       	ldd	r25, Y+2	; 0x02
    3b2e:	01 96       	adiw	r24, 0x01	; 1
    3b30:	9a 83       	std	Y+2, r25	; 0x02
    3b32:	89 83       	std	Y+1, r24	; 0x01
    3b34:	8f 81       	ldd	r24, Y+7	; 0x07
    3b36:	98 85       	ldd	r25, Y+8	; 0x08
    3b38:	fc 01       	movw	r30, r24
    3b3a:	81 81       	ldd	r24, Z+1	; 0x01
    3b3c:	28 2f       	mov	r18, r24
    3b3e:	33 27       	eor	r19, r19
    3b40:	27 fd       	sbrc	r18, 7
    3b42:	30 95       	com	r19
    3b44:	89 81       	ldd	r24, Y+1	; 0x01
    3b46:	9a 81       	ldd	r25, Y+2	; 0x02
    3b48:	82 17       	cp	r24, r18
    3b4a:	93 07       	cpc	r25, r19
    3b4c:	fc f2       	brlt	.-66     	; 0x3b0c <sendResponse+0xb0>
        USART_Write(response->payload[i]);
			vTaskDelay(1);
		  //USART_AddToQueue(0x30 | (i + 2));
        //USART_AddToQueue()
    }
    USART_Write(calcChecksum((uint8_t*)response->payload,response->size));
    3b4e:	8f 81       	ldd	r24, Y+7	; 0x07
    3b50:	98 85       	ldd	r25, Y+8	; 0x08
    3b52:	fc 01       	movw	r30, r24
    3b54:	81 81       	ldd	r24, Z+1	; 0x01
    3b56:	28 2f       	mov	r18, r24
    3b58:	8f 81       	ldd	r24, Y+7	; 0x07
    3b5a:	98 85       	ldd	r25, Y+8	; 0x08
    3b5c:	02 96       	adiw	r24, 0x02	; 2
    3b5e:	62 2f       	mov	r22, r18
    3b60:	0e 94 eb 1d 	call	0x3bd6	; 0x3bd6 <calcChecksum>
    3b64:	0e 94 a9 1a 	call	0x3552	; 0x3552 <USART_Write>
	 

    waitForAck();
    3b68:	0e 94 c1 1d 	call	0x3b82	; 0x3b82 <waitForAck>

    return 0;
    3b6c:	80 e0       	ldi	r24, 0x00	; 0
    3b6e:	90 e0       	ldi	r25, 0x00	; 0

}
    3b70:	28 96       	adiw	r28, 0x08	; 8
    3b72:	0f b6       	in	r0, 0x3f	; 63
    3b74:	f8 94       	cli
    3b76:	de bf       	out	0x3e, r29	; 62
    3b78:	0f be       	out	0x3f, r0	; 63
    3b7a:	cd bf       	out	0x3d, r28	; 61
    3b7c:	df 91       	pop	r29
    3b7e:	cf 91       	pop	r28
    3b80:	08 95       	ret

00003b82 <waitForAck>:

char waitForAck(){
    3b82:	cf 93       	push	r28
    3b84:	df 93       	push	r29
    3b86:	1f 92       	push	r1
    3b88:	1f 92       	push	r1
    3b8a:	cd b7       	in	r28, 0x3d	; 61
    3b8c:	de b7       	in	r29, 0x3e	; 62
    int timeout = 5000;
    3b8e:	88 e8       	ldi	r24, 0x88	; 136
    3b90:	93 e1       	ldi	r25, 0x13	; 19
    3b92:	9a 83       	std	Y+2, r25	; 0x02
    3b94:	89 83       	std	Y+1, r24	; 0x01
    while ( !(UCSR2A & (1<<RXC2)) ){
    3b96:	0b c0       	rjmp	.+22     	; 0x3bae <waitForAck+0x2c>
        timeout--;
    3b98:	89 81       	ldd	r24, Y+1	; 0x01
    3b9a:	9a 81       	ldd	r25, Y+2	; 0x02
    3b9c:	01 97       	sbiw	r24, 0x01	; 1
    3b9e:	9a 83       	std	Y+2, r25	; 0x02
    3ba0:	89 83       	std	Y+1, r24	; 0x01
        if(!timeout){
    3ba2:	89 81       	ldd	r24, Y+1	; 0x01
    3ba4:	9a 81       	ldd	r25, Y+2	; 0x02
    3ba6:	00 97       	sbiw	r24, 0x00	; 0
    3ba8:	11 f4       	brne	.+4      	; 0x3bae <waitForAck+0x2c>
            return -1;
    3baa:	8f ef       	ldi	r24, 0xFF	; 255
    3bac:	0f c0       	rjmp	.+30     	; 0x3bcc <waitForAck+0x4a>

}

char waitForAck(){
    int timeout = 5000;
    while ( !(UCSR2A & (1<<RXC2)) ){
    3bae:	80 ed       	ldi	r24, 0xD0	; 208
    3bb0:	90 e0       	ldi	r25, 0x00	; 0
    3bb2:	fc 01       	movw	r30, r24
    3bb4:	80 81       	ld	r24, Z
    3bb6:	88 23       	and	r24, r24
    3bb8:	7c f7       	brge	.-34     	; 0x3b98 <waitForAck+0x16>
        timeout--;
        if(!timeout){
            return -1;
        }
    }
    if(UDR2 == ACK_BYTE){
    3bba:	86 ed       	ldi	r24, 0xD6	; 214
    3bbc:	90 e0       	ldi	r25, 0x00	; 0
    3bbe:	fc 01       	movw	r30, r24
    3bc0:	80 81       	ld	r24, Z
    3bc2:	80 38       	cpi	r24, 0x80	; 128
    3bc4:	11 f4       	brne	.+4      	; 0x3bca <waitForAck+0x48>
        return 1;
    3bc6:	81 e0       	ldi	r24, 0x01	; 1
    3bc8:	01 c0       	rjmp	.+2      	; 0x3bcc <waitForAck+0x4a>
    } else {
        return 0;
    3bca:	80 e0       	ldi	r24, 0x00	; 0
    }
}
    3bcc:	0f 90       	pop	r0
    3bce:	0f 90       	pop	r0
    3bd0:	df 91       	pop	r29
    3bd2:	cf 91       	pop	r28
    3bd4:	08 95       	ret

00003bd6 <calcChecksum>:

uint8_t calcChecksum(uint8_t* buffer,uint8_t size){
    3bd6:	cf 93       	push	r28
    3bd8:	df 93       	push	r29
    3bda:	00 d0       	rcall	.+0      	; 0x3bdc <calcChecksum+0x6>
    3bdc:	00 d0       	rcall	.+0      	; 0x3bde <calcChecksum+0x8>
    3bde:	cd b7       	in	r28, 0x3d	; 61
    3be0:	de b7       	in	r29, 0x3e	; 62
    3be2:	9d 83       	std	Y+5, r25	; 0x05
    3be4:	8c 83       	std	Y+4, r24	; 0x04
    3be6:	6e 83       	std	Y+6, r22	; 0x06
    uint8_t checksum = 0;
    3be8:	19 82       	std	Y+1, r1	; 0x01
    for(int i = 0; i < size; i++) {
    3bea:	1b 82       	std	Y+3, r1	; 0x03
    3bec:	1a 82       	std	Y+2, r1	; 0x02
    3bee:	11 c0       	rjmp	.+34     	; 0x3c12 <calcChecksum+0x3c>
        checksum += *(buffer++);
    3bf0:	8c 81       	ldd	r24, Y+4	; 0x04
    3bf2:	9d 81       	ldd	r25, Y+5	; 0x05
    3bf4:	9c 01       	movw	r18, r24
    3bf6:	2f 5f       	subi	r18, 0xFF	; 255
    3bf8:	3f 4f       	sbci	r19, 0xFF	; 255
    3bfa:	3d 83       	std	Y+5, r19	; 0x05
    3bfc:	2c 83       	std	Y+4, r18	; 0x04
    3bfe:	fc 01       	movw	r30, r24
    3c00:	80 81       	ld	r24, Z
    3c02:	99 81       	ldd	r25, Y+1	; 0x01
    3c04:	89 0f       	add	r24, r25
    3c06:	89 83       	std	Y+1, r24	; 0x01
    }
}

uint8_t calcChecksum(uint8_t* buffer,uint8_t size){
    uint8_t checksum = 0;
    for(int i = 0; i < size; i++) {
    3c08:	8a 81       	ldd	r24, Y+2	; 0x02
    3c0a:	9b 81       	ldd	r25, Y+3	; 0x03
    3c0c:	01 96       	adiw	r24, 0x01	; 1
    3c0e:	9b 83       	std	Y+3, r25	; 0x03
    3c10:	8a 83       	std	Y+2, r24	; 0x02
    3c12:	8e 81       	ldd	r24, Y+6	; 0x06
    3c14:	28 2f       	mov	r18, r24
    3c16:	30 e0       	ldi	r19, 0x00	; 0
    3c18:	8a 81       	ldd	r24, Y+2	; 0x02
    3c1a:	9b 81       	ldd	r25, Y+3	; 0x03
    3c1c:	82 17       	cp	r24, r18
    3c1e:	93 07       	cpc	r25, r19
    3c20:	3c f3       	brlt	.-50     	; 0x3bf0 <calcChecksum+0x1a>
        checksum += *(buffer++);
    }
    return checksum;
    3c22:	89 81       	ldd	r24, Y+1	; 0x01
}
    3c24:	26 96       	adiw	r28, 0x06	; 6
    3c26:	0f b6       	in	r0, 0x3f	; 63
    3c28:	f8 94       	cli
    3c2a:	de bf       	out	0x3e, r29	; 62
    3c2c:	0f be       	out	0x3f, r0	; 63
    3c2e:	cd bf       	out	0x3d, r28	; 61
    3c30:	df 91       	pop	r29
    3c32:	cf 91       	pop	r28
    3c34:	08 95       	ret

00003c36 <commandIntegCheck>:
#include "protocol.h"
#include "Components/Sonar/Sonar.h"


//function to CRC the command structure
char commandIntegCheck(Command *command) {
    3c36:	cf 93       	push	r28
    3c38:	df 93       	push	r29
    3c3a:	1f 92       	push	r1
    3c3c:	1f 92       	push	r1
    3c3e:	cd b7       	in	r28, 0x3d	; 61
    3c40:	de b7       	in	r29, 0x3e	; 62
    3c42:	9a 83       	std	Y+2, r25	; 0x02
    3c44:	89 83       	std	Y+1, r24	; 0x01
   //CRC the command with 0x00 in place of the CRC
   //return success for now
   return 1;
    3c46:	81 e0       	ldi	r24, 0x01	; 1
}
    3c48:	0f 90       	pop	r0
    3c4a:	0f 90       	pop	r0
    3c4c:	df 91       	pop	r29
    3c4e:	cf 91       	pop	r28
    3c50:	08 95       	ret

00003c52 <processUltrasonicCommand>:

char processUltrasonicCommand(char commandCode, void* commandData,char* size, void* responseData) {
    3c52:	cf 93       	push	r28
    3c54:	df 93       	push	r29
    3c56:	cd b7       	in	r28, 0x3d	; 61
    3c58:	de b7       	in	r29, 0x3e	; 62
    3c5a:	27 97       	sbiw	r28, 0x07	; 7
    3c5c:	0f b6       	in	r0, 0x3f	; 63
    3c5e:	f8 94       	cli
    3c60:	de bf       	out	0x3e, r29	; 62
    3c62:	0f be       	out	0x3f, r0	; 63
    3c64:	cd bf       	out	0x3d, r28	; 61
    3c66:	89 83       	std	Y+1, r24	; 0x01
    3c68:	7b 83       	std	Y+3, r23	; 0x03
    3c6a:	6a 83       	std	Y+2, r22	; 0x02
    3c6c:	5d 83       	std	Y+5, r21	; 0x05
    3c6e:	4c 83       	std	Y+4, r20	; 0x04
    3c70:	3f 83       	std	Y+7, r19	; 0x07
    3c72:	2e 83       	std	Y+6, r18	; 0x06
   switch(commandCode) {
    3c74:	89 81       	ldd	r24, Y+1	; 0x01
    3c76:	99 27       	eor	r25, r25
    3c78:	87 fd       	sbrc	r24, 7
    3c7a:	90 95       	com	r25
    3c7c:	82 30       	cpi	r24, 0x02	; 2
    3c7e:	91 05       	cpc	r25, r1
    3c80:	81 f0       	breq	.+32     	; 0x3ca2 <processUltrasonicCommand+0x50>
    3c82:	83 30       	cpi	r24, 0x03	; 3
    3c84:	91 05       	cpc	r25, r1
    3c86:	c1 f0       	breq	.+48     	; 0x3cb8 <processUltrasonicCommand+0x66>
    3c88:	81 30       	cpi	r24, 0x01	; 1
    3c8a:	91 05       	cpc	r25, r1
    3c8c:	01 f5       	brne	.+64     	; 0x3cce <processUltrasonicCommand+0x7c>
      case GET_ALL_SENSORS:
         getAllSensors((int*) responseData);
    3c8e:	8e 81       	ldd	r24, Y+6	; 0x06
    3c90:	9f 81       	ldd	r25, Y+7	; 0x07
    3c92:	0e 94 51 22 	call	0x44a2	; 0x44a2 <getAllSensors>
         *size = 12;
    3c96:	8c 81       	ldd	r24, Y+4	; 0x04
    3c98:	9d 81       	ldd	r25, Y+5	; 0x05
    3c9a:	2c e0       	ldi	r18, 0x0C	; 12
    3c9c:	fc 01       	movw	r30, r24
    3c9e:	20 83       	st	Z, r18
         break;
    3ca0:	16 c0       	rjmp	.+44     	; 0x3cce <processUltrasonicCommand+0x7c>
      case GET_CERTAIN_SENSORS:
         getCertainSensor(((char*)commandData)[0], (int*) responseData);
    3ca2:	8a 81       	ldd	r24, Y+2	; 0x02
    3ca4:	9b 81       	ldd	r25, Y+3	; 0x03
    3ca6:	fc 01       	movw	r30, r24
    3ca8:	20 81       	ld	r18, Z
    3caa:	8e 81       	ldd	r24, Y+6	; 0x06
    3cac:	9f 81       	ldd	r25, Y+7	; 0x07
    3cae:	bc 01       	movw	r22, r24
    3cb0:	82 2f       	mov	r24, r18
    3cb2:	0e 94 7c 22 	call	0x44f8	; 0x44f8 <getCertainSensor>
         break;
    3cb6:	0b c0       	rjmp	.+22     	; 0x3cce <processUltrasonicCommand+0x7c>
      case GET_SENSOR_GROUP:
         getSensorGroup(((char*)commandData)[0], (int*) responseData);
    3cb8:	8a 81       	ldd	r24, Y+2	; 0x02
    3cba:	9b 81       	ldd	r25, Y+3	; 0x03
    3cbc:	fc 01       	movw	r30, r24
    3cbe:	20 81       	ld	r18, Z
    3cc0:	8e 81       	ldd	r24, Y+6	; 0x06
    3cc2:	9f 81       	ldd	r25, Y+7	; 0x07
    3cc4:	bc 01       	movw	r22, r24
    3cc6:	82 2f       	mov	r24, r18
    3cc8:	0e 94 a7 22 	call	0x454e	; 0x454e <getSensorGroup>
         break;
    3ccc:	00 00       	nop
   }
   //return success for now...
   return 1;
    3cce:	81 e0       	ldi	r24, 0x01	; 1
}
    3cd0:	27 96       	adiw	r28, 0x07	; 7
    3cd2:	0f b6       	in	r0, 0x3f	; 63
    3cd4:	f8 94       	cli
    3cd6:	de bf       	out	0x3e, r29	; 62
    3cd8:	0f be       	out	0x3f, r0	; 63
    3cda:	cd bf       	out	0x3d, r28	; 61
    3cdc:	df 91       	pop	r29
    3cde:	cf 91       	pop	r28
    3ce0:	08 95       	ret

00003ce2 <processSpeedCommand>:

char processSpeedCommand(char commandCode, void* commandData, Response* responseData) {
    3ce2:	cf 93       	push	r28
    3ce4:	df 93       	push	r29
    3ce6:	00 d0       	rcall	.+0      	; 0x3ce8 <processSpeedCommand+0x6>
    3ce8:	1f 92       	push	r1
    3cea:	1f 92       	push	r1
    3cec:	cd b7       	in	r28, 0x3d	; 61
    3cee:	de b7       	in	r29, 0x3e	; 62
    3cf0:	89 83       	std	Y+1, r24	; 0x01
    3cf2:	7b 83       	std	Y+3, r23	; 0x03
    3cf4:	6a 83       	std	Y+2, r22	; 0x02
    3cf6:	5d 83       	std	Y+5, r21	; 0x05
    3cf8:	4c 83       	std	Y+4, r20	; 0x04
   switch(commandCode) {
    3cfa:	89 81       	ldd	r24, Y+1	; 0x01
    3cfc:	99 27       	eor	r25, r25
    3cfe:	87 fd       	sbrc	r24, 7
    3d00:	90 95       	com	r25
    3d02:	00 97       	sbiw	r24, 0x00	; 0
    3d04:	21 f0       	breq	.+8      	; 0x3d0e <processSpeedCommand+0x2c>
    3d06:	81 30       	cpi	r24, 0x01	; 1
    3d08:	91 05       	cpc	r25, r1
    3d0a:	31 f0       	breq	.+12     	; 0x3d18 <processSpeedCommand+0x36>
    3d0c:	13 c0       	rjmp	.+38     	; 0x3d34 <processSpeedCommand+0x52>
      case GET_SPEED:
         getSpeed((char*) responseData);
    3d0e:	8c 81       	ldd	r24, Y+4	; 0x04
    3d10:	9d 81       	ldd	r25, Y+5	; 0x05
    3d12:	0e 94 4f 23 	call	0x469e	; 0x469e <getSpeed>
         break;
    3d16:	0e c0       	rjmp	.+28     	; 0x3d34 <processSpeedCommand+0x52>
      case SET_SPEED:
			responseData->size = 0;
    3d18:	8c 81       	ldd	r24, Y+4	; 0x04
    3d1a:	9d 81       	ldd	r25, Y+5	; 0x05
    3d1c:	fc 01       	movw	r30, r24
    3d1e:	11 82       	std	Z+1, r1	; 0x01
         setSpeed(((char*)commandData)[0]);
    3d20:	8a 81       	ldd	r24, Y+2	; 0x02
    3d22:	9b 81       	ldd	r25, Y+3	; 0x03
    3d24:	fc 01       	movw	r30, r24
    3d26:	80 81       	ld	r24, Z
    3d28:	99 27       	eor	r25, r25
    3d2a:	87 fd       	sbrc	r24, 7
    3d2c:	90 95       	com	r25
    3d2e:	0e 94 61 23 	call	0x46c2	; 0x46c2 <setSpeed>
         break;
    3d32:	00 00       	nop
   }
   //return success for now
   return 1;
    3d34:	81 e0       	ldi	r24, 0x01	; 1
}
    3d36:	0f 90       	pop	r0
    3d38:	0f 90       	pop	r0
    3d3a:	0f 90       	pop	r0
    3d3c:	0f 90       	pop	r0
    3d3e:	0f 90       	pop	r0
    3d40:	df 91       	pop	r29
    3d42:	cf 91       	pop	r28
    3d44:	08 95       	ret

00003d46 <processSteeringCommand>:

char processSteeringCommand(char commandCode, void* commandData, void* responseData) {
    3d46:	cf 93       	push	r28
    3d48:	df 93       	push	r29
    3d4a:	00 d0       	rcall	.+0      	; 0x3d4c <processSteeringCommand+0x6>
    3d4c:	1f 92       	push	r1
    3d4e:	1f 92       	push	r1
    3d50:	cd b7       	in	r28, 0x3d	; 61
    3d52:	de b7       	in	r29, 0x3e	; 62
    3d54:	89 83       	std	Y+1, r24	; 0x01
    3d56:	7b 83       	std	Y+3, r23	; 0x03
    3d58:	6a 83       	std	Y+2, r22	; 0x02
    3d5a:	5d 83       	std	Y+5, r21	; 0x05
    3d5c:	4c 83       	std	Y+4, r20	; 0x04
   switch(commandCode) {
    3d5e:	89 81       	ldd	r24, Y+1	; 0x01
    3d60:	99 27       	eor	r25, r25
    3d62:	87 fd       	sbrc	r24, 7
    3d64:	90 95       	com	r25
    3d66:	82 30       	cpi	r24, 0x02	; 2
    3d68:	91 05       	cpc	r25, r1
    3d6a:	f9 f0       	breq	.+62     	; 0x3daa <processSteeringCommand+0x64>
    3d6c:	83 30       	cpi	r24, 0x03	; 3
    3d6e:	91 05       	cpc	r25, r1
    3d70:	34 f4       	brge	.+12     	; 0x3d7e <processSteeringCommand+0x38>
    3d72:	00 97       	sbiw	r24, 0x00	; 0
    3d74:	59 f0       	breq	.+22     	; 0x3d8c <processSteeringCommand+0x46>
    3d76:	81 30       	cpi	r24, 0x01	; 1
    3d78:	91 05       	cpc	r25, r1
    3d7a:	91 f0       	breq	.+36     	; 0x3da0 <processSteeringCommand+0x5a>
    3d7c:	4c c0       	rjmp	.+152    	; 0x3e16 <processSteeringCommand+0xd0>
    3d7e:	83 30       	cpi	r24, 0x03	; 3
    3d80:	91 05       	cpc	r25, r1
    3d82:	c1 f0       	breq	.+48     	; 0x3db4 <processSteeringCommand+0x6e>
    3d84:	84 30       	cpi	r24, 0x04	; 4
    3d86:	91 05       	cpc	r25, r1
    3d88:	91 f1       	breq	.+100    	; 0x3dee <processSteeringCommand+0xa8>
    3d8a:	45 c0       	rjmp	.+138    	; 0x3e16 <processSteeringCommand+0xd0>
      case SET_ANGLE:
         setAngle(*((char*)commandData));
    3d8c:	8a 81       	ldd	r24, Y+2	; 0x02
    3d8e:	9b 81       	ldd	r25, Y+3	; 0x03
    3d90:	fc 01       	movw	r30, r24
    3d92:	80 81       	ld	r24, Z
    3d94:	99 27       	eor	r25, r25
    3d96:	87 fd       	sbrc	r24, 7
    3d98:	90 95       	com	r25
    3d9a:	0e 94 87 23 	call	0x470e	; 0x470e <setAngle>
         break;
    3d9e:	3b c0       	rjmp	.+118    	; 0x3e16 <processSteeringCommand+0xd0>
      case GET_ANGLE:
         getAngle((char*) responseData);
    3da0:	8c 81       	ldd	r24, Y+4	; 0x04
    3da2:	9d 81       	ldd	r25, Y+5	; 0x05
    3da4:	0e 94 92 23 	call	0x4724	; 0x4724 <getAngle>
         break;
    3da8:	36 c0       	rjmp	.+108    	; 0x3e16 <processSteeringCommand+0xd0>
      case GET_DESIRED_ANGLE:
         getDesiredAngle((char*) responseData);
    3daa:	8c 81       	ldd	r24, Y+4	; 0x04
    3dac:	9d 81       	ldd	r25, Y+5	; 0x05
    3dae:	0e 94 a4 23 	call	0x4748	; 0x4748 <getDesiredAngle>
         break;
    3db2:	31 c0       	rjmp	.+98     	; 0x3e16 <processSteeringCommand+0xd0>
      case CHANGE_PID:
         changePID(((char*)commandData)[0], ((char*)commandData)[1], ((char*)commandData)[2]);
    3db4:	8a 81       	ldd	r24, Y+2	; 0x02
    3db6:	9b 81       	ldd	r25, Y+3	; 0x03
    3db8:	02 96       	adiw	r24, 0x02	; 2
    3dba:	fc 01       	movw	r30, r24
    3dbc:	80 81       	ld	r24, Z
    3dbe:	48 2f       	mov	r20, r24
    3dc0:	55 27       	eor	r21, r21
    3dc2:	47 fd       	sbrc	r20, 7
    3dc4:	50 95       	com	r21
    3dc6:	8a 81       	ldd	r24, Y+2	; 0x02
    3dc8:	9b 81       	ldd	r25, Y+3	; 0x03
    3dca:	01 96       	adiw	r24, 0x01	; 1
    3dcc:	fc 01       	movw	r30, r24
    3dce:	80 81       	ld	r24, Z
    3dd0:	28 2f       	mov	r18, r24
    3dd2:	33 27       	eor	r19, r19
    3dd4:	27 fd       	sbrc	r18, 7
    3dd6:	30 95       	com	r19
    3dd8:	8a 81       	ldd	r24, Y+2	; 0x02
    3dda:	9b 81       	ldd	r25, Y+3	; 0x03
    3ddc:	fc 01       	movw	r30, r24
    3dde:	80 81       	ld	r24, Z
    3de0:	99 27       	eor	r25, r25
    3de2:	87 fd       	sbrc	r24, 7
    3de4:	90 95       	com	r25
    3de6:	b9 01       	movw	r22, r18
    3de8:	0e 94 b6 23 	call	0x476c	; 0x476c <changePID>
         break;
    3dec:	14 c0       	rjmp	.+40     	; 0x3e16 <processSteeringCommand+0xd0>
      case SET_LIMITS:
         setLimits(((char*)commandData)[0], ((char*)commandData)[1]);
    3dee:	8a 81       	ldd	r24, Y+2	; 0x02
    3df0:	9b 81       	ldd	r25, Y+3	; 0x03
    3df2:	01 96       	adiw	r24, 0x01	; 1
    3df4:	fc 01       	movw	r30, r24
    3df6:	80 81       	ld	r24, Z
    3df8:	28 2f       	mov	r18, r24
    3dfa:	33 27       	eor	r19, r19
    3dfc:	27 fd       	sbrc	r18, 7
    3dfe:	30 95       	com	r19
    3e00:	8a 81       	ldd	r24, Y+2	; 0x02
    3e02:	9b 81       	ldd	r25, Y+3	; 0x03
    3e04:	fc 01       	movw	r30, r24
    3e06:	80 81       	ld	r24, Z
    3e08:	99 27       	eor	r25, r25
    3e0a:	87 fd       	sbrc	r24, 7
    3e0c:	90 95       	com	r25
    3e0e:	b9 01       	movw	r22, r18
    3e10:	0e 94 c5 23 	call	0x478a	; 0x478a <setLimits>
         break;
    3e14:	00 00       	nop
   }
   //return success for now
   return 1;
    3e16:	81 e0       	ldi	r24, 0x01	; 1
}
    3e18:	0f 90       	pop	r0
    3e1a:	0f 90       	pop	r0
    3e1c:	0f 90       	pop	r0
    3e1e:	0f 90       	pop	r0
    3e20:	0f 90       	pop	r0
    3e22:	df 91       	pop	r29
    3e24:	cf 91       	pop	r28
    3e26:	08 95       	ret

00003e28 <processFNRCommand>:

char processFNRCommand(char commandCode, void* commandData, Response* responseData) {
    3e28:	cf 93       	push	r28
    3e2a:	df 93       	push	r29
    3e2c:	00 d0       	rcall	.+0      	; 0x3e2e <processFNRCommand+0x6>
    3e2e:	1f 92       	push	r1
    3e30:	1f 92       	push	r1
    3e32:	cd b7       	in	r28, 0x3d	; 61
    3e34:	de b7       	in	r29, 0x3e	; 62
    3e36:	89 83       	std	Y+1, r24	; 0x01
    3e38:	7b 83       	std	Y+3, r23	; 0x03
    3e3a:	6a 83       	std	Y+2, r22	; 0x02
    3e3c:	5d 83       	std	Y+5, r21	; 0x05
    3e3e:	4c 83       	std	Y+4, r20	; 0x04
	responseData->size = 0;	
    3e40:	8c 81       	ldd	r24, Y+4	; 0x04
    3e42:	9d 81       	ldd	r25, Y+5	; 0x05
    3e44:	fc 01       	movw	r30, r24
    3e46:	11 82       	std	Z+1, r1	; 0x01
   switch(commandCode) {
    3e48:	89 81       	ldd	r24, Y+1	; 0x01
    3e4a:	99 27       	eor	r25, r25
    3e4c:	87 fd       	sbrc	r24, 7
    3e4e:	90 95       	com	r25
    3e50:	00 97       	sbiw	r24, 0x00	; 0
    3e52:	21 f0       	breq	.+8      	; 0x3e5c <processFNRCommand+0x34>
    3e54:	81 30       	cpi	r24, 0x01	; 1
    3e56:	91 05       	cpc	r25, r1
    3e58:	59 f0       	breq	.+22     	; 0x3e70 <processFNRCommand+0x48>
    3e5a:	0f c0       	rjmp	.+30     	; 0x3e7a <processFNRCommand+0x52>
      case SET_FNR:
         setFNR(*((char*)commandData));
    3e5c:	8a 81       	ldd	r24, Y+2	; 0x02
    3e5e:	9b 81       	ldd	r25, Y+3	; 0x03
    3e60:	fc 01       	movw	r30, r24
    3e62:	80 81       	ld	r24, Z
    3e64:	99 27       	eor	r25, r25
    3e66:	87 fd       	sbrc	r24, 7
    3e68:	90 95       	com	r25
    3e6a:	0e 94 1c 21 	call	0x4238	; 0x4238 <setFNR>
         break;
    3e6e:	05 c0       	rjmp	.+10     	; 0x3e7a <processFNRCommand+0x52>
      case GET_FNR:
         getFNR((char*) responseData);
    3e70:	8c 81       	ldd	r24, Y+4	; 0x04
    3e72:	9d 81       	ldd	r25, Y+5	; 0x05
    3e74:	0e 94 38 21 	call	0x4270	; 0x4270 <getFNR>
         break;
    3e78:	00 00       	nop
   }
}
    3e7a:	0f 90       	pop	r0
    3e7c:	0f 90       	pop	r0
    3e7e:	0f 90       	pop	r0
    3e80:	0f 90       	pop	r0
    3e82:	0f 90       	pop	r0
    3e84:	df 91       	pop	r29
    3e86:	cf 91       	pop	r28
    3e88:	08 95       	ret

00003e8a <processBrakeCommand>:

char processBrakeCommand(char commandCode, void* commandData, void* responseData) {
    3e8a:	cf 93       	push	r28
    3e8c:	df 93       	push	r29
    3e8e:	00 d0       	rcall	.+0      	; 0x3e90 <processBrakeCommand+0x6>
    3e90:	1f 92       	push	r1
    3e92:	1f 92       	push	r1
    3e94:	cd b7       	in	r28, 0x3d	; 61
    3e96:	de b7       	in	r29, 0x3e	; 62
    3e98:	89 83       	std	Y+1, r24	; 0x01
    3e9a:	7b 83       	std	Y+3, r23	; 0x03
    3e9c:	6a 83       	std	Y+2, r22	; 0x02
    3e9e:	5d 83       	std	Y+5, r21	; 0x05
    3ea0:	4c 83       	std	Y+4, r20	; 0x04
   switch(commandCode) {
    3ea2:	89 81       	ldd	r24, Y+1	; 0x01
    3ea4:	99 27       	eor	r25, r25
    3ea6:	87 fd       	sbrc	r24, 7
    3ea8:	90 95       	com	r25
    3eaa:	00 97       	sbiw	r24, 0x00	; 0
    3eac:	21 f0       	breq	.+8      	; 0x3eb6 <processBrakeCommand+0x2c>
    3eae:	81 30       	cpi	r24, 0x01	; 1
    3eb0:	91 05       	cpc	r25, r1
    3eb2:	59 f0       	breq	.+22     	; 0x3eca <processBrakeCommand+0x40>
    3eb4:	0f c0       	rjmp	.+30     	; 0x3ed4 <processBrakeCommand+0x4a>
      case SET_BRAKE:
	 setBrake(*((char*)commandData));
    3eb6:	8a 81       	ldd	r24, Y+2	; 0x02
    3eb8:	9b 81       	ldd	r25, Y+3	; 0x03
    3eba:	fc 01       	movw	r30, r24
    3ebc:	80 81       	ld	r24, Z
    3ebe:	99 27       	eor	r25, r25
    3ec0:	87 fd       	sbrc	r24, 7
    3ec2:	90 95       	com	r25
    3ec4:	0e 94 63 20 	call	0x40c6	; 0x40c6 <setBrake>
	 break;
    3ec8:	05 c0       	rjmp	.+10     	; 0x3ed4 <processBrakeCommand+0x4a>
      case GET_BRAKE:
	 getBrake((char*) responseData);
    3eca:	8c 81       	ldd	r24, Y+4	; 0x04
    3ecc:	9d 81       	ldd	r25, Y+5	; 0x05
    3ece:	0e 94 6e 20 	call	0x40dc	; 0x40dc <getBrake>
	 break; 
    3ed2:	00 00       	nop
   }
}
    3ed4:	0f 90       	pop	r0
    3ed6:	0f 90       	pop	r0
    3ed8:	0f 90       	pop	r0
    3eda:	0f 90       	pop	r0
    3edc:	0f 90       	pop	r0
    3ede:	df 91       	pop	r29
    3ee0:	cf 91       	pop	r28
    3ee2:	08 95       	ret

00003ee4 <processBatteryCommand>:

char processBatteryCommand(char commandCode, void* commandData, void* responseData) {
    3ee4:	cf 93       	push	r28
    3ee6:	df 93       	push	r29
    3ee8:	00 d0       	rcall	.+0      	; 0x3eea <processBatteryCommand+0x6>
    3eea:	1f 92       	push	r1
    3eec:	1f 92       	push	r1
    3eee:	cd b7       	in	r28, 0x3d	; 61
    3ef0:	de b7       	in	r29, 0x3e	; 62
    3ef2:	89 83       	std	Y+1, r24	; 0x01
    3ef4:	7b 83       	std	Y+3, r23	; 0x03
    3ef6:	6a 83       	std	Y+2, r22	; 0x02
    3ef8:	5d 83       	std	Y+5, r21	; 0x05
    3efa:	4c 83       	std	Y+4, r20	; 0x04
   switch(commandCode) {
    3efc:	89 81       	ldd	r24, Y+1	; 0x01
    3efe:	99 27       	eor	r25, r25
    3f00:	87 fd       	sbrc	r24, 7
    3f02:	90 95       	com	r25
    3f04:	00 97       	sbiw	r24, 0x00	; 0
    3f06:	21 f0       	breq	.+8      	; 0x3f10 <processBatteryCommand+0x2c>
    3f08:	81 30       	cpi	r24, 0x01	; 1
    3f0a:	91 05       	cpc	r25, r1
    3f0c:	31 f0       	breq	.+12     	; 0x3f1a <processBatteryCommand+0x36>
    3f0e:	0a c0       	rjmp	.+20     	; 0x3f24 <processBatteryCommand+0x40>
      case GET_BATTERY_VOLTAGE:
         getBatteryVoltage((char*) responseData);
    3f10:	8c 81       	ldd	r24, Y+4	; 0x04
    3f12:	9d 81       	ldd	r25, Y+5	; 0x05
    3f14:	0e 94 3f 20 	call	0x407e	; 0x407e <getBatteryVoltage>
         break;
    3f18:	05 c0       	rjmp	.+10     	; 0x3f24 <processBatteryCommand+0x40>
      case GET_STEERING_VOLTAGE:
         getSteeringVoltage((char*) responseData);
    3f1a:	8c 81       	ldd	r24, Y+4	; 0x04
    3f1c:	9d 81       	ldd	r25, Y+5	; 0x05
    3f1e:	0e 94 51 20 	call	0x40a2	; 0x40a2 <getSteeringVoltage>
         break;
    3f22:	00 00       	nop
   }
}
    3f24:	0f 90       	pop	r0
    3f26:	0f 90       	pop	r0
    3f28:	0f 90       	pop	r0
    3f2a:	0f 90       	pop	r0
    3f2c:	0f 90       	pop	r0
    3f2e:	df 91       	pop	r29
    3f30:	cf 91       	pop	r28
    3f32:	08 95       	ret

00003f34 <processLightCommand>:

char processLightCommand(char commandCode, void* commandData, Response* responseData) {
    3f34:	cf 93       	push	r28
    3f36:	df 93       	push	r29
    3f38:	00 d0       	rcall	.+0      	; 0x3f3a <processLightCommand+0x6>
    3f3a:	1f 92       	push	r1
    3f3c:	1f 92       	push	r1
    3f3e:	cd b7       	in	r28, 0x3d	; 61
    3f40:	de b7       	in	r29, 0x3e	; 62
    3f42:	89 83       	std	Y+1, r24	; 0x01
    3f44:	7b 83       	std	Y+3, r23	; 0x03
    3f46:	6a 83       	std	Y+2, r22	; 0x02
    3f48:	5d 83       	std	Y+5, r21	; 0x05
    3f4a:	4c 83       	std	Y+4, r20	; 0x04
	responseData->size = 0;
    3f4c:	8c 81       	ldd	r24, Y+4	; 0x04
    3f4e:	9d 81       	ldd	r25, Y+5	; 0x05
    3f50:	fc 01       	movw	r30, r24
    3f52:	11 82       	std	Z+1, r1	; 0x01
   switch(commandCode) {
    3f54:	89 81       	ldd	r24, Y+1	; 0x01
    3f56:	99 27       	eor	r25, r25
    3f58:	87 fd       	sbrc	r24, 7
    3f5a:	90 95       	com	r25
    3f5c:	00 97       	sbiw	r24, 0x00	; 0
    3f5e:	51 f4       	brne	.+20     	; 0x3f74 <processLightCommand+0x40>
   case SET_LIGHT:
	 	setLight(*((char*)commandData));
    3f60:	8a 81       	ldd	r24, Y+2	; 0x02
    3f62:	9b 81       	ldd	r25, Y+3	; 0x03
    3f64:	fc 01       	movw	r30, r24
    3f66:	80 81       	ld	r24, Z
    3f68:	99 27       	eor	r25, r25
    3f6a:	87 fd       	sbrc	r24, 7
    3f6c:	90 95       	com	r25
    3f6e:	0e 94 4a 21 	call	0x4294	; 0x4294 <setLight>
      break;
    3f72:	00 00       	nop
   }
}
    3f74:	0f 90       	pop	r0
    3f76:	0f 90       	pop	r0
    3f78:	0f 90       	pop	r0
    3f7a:	0f 90       	pop	r0
    3f7c:	0f 90       	pop	r0
    3f7e:	df 91       	pop	r29
    3f80:	cf 91       	pop	r28
    3f82:	08 95       	ret

00003f84 <processCommand>:



//Function that will take in a command (as char array) and process it into a
//correct response to be stored into response
char processCommand(Command *command, Response *response) {
    3f84:	cf 93       	push	r28
    3f86:	df 93       	push	r29
    3f88:	00 d0       	rcall	.+0      	; 0x3f8a <processCommand+0x6>
    3f8a:	1f 92       	push	r1
    3f8c:	cd b7       	in	r28, 0x3d	; 61
    3f8e:	de b7       	in	r29, 0x3e	; 62
    3f90:	9a 83       	std	Y+2, r25	; 0x02
    3f92:	89 83       	std	Y+1, r24	; 0x01
    3f94:	7c 83       	std	Y+4, r23	; 0x04
    3f96:	6b 83       	std	Y+3, r22	; 0x03
	response->commandBack = command->cmd;
    3f98:	89 81       	ldd	r24, Y+1	; 0x01
    3f9a:	9a 81       	ldd	r25, Y+2	; 0x02
    3f9c:	dc 01       	movw	r26, r24
    3f9e:	11 96       	adiw	r26, 0x01	; 1
    3fa0:	2c 91       	ld	r18, X
    3fa2:	8b 81       	ldd	r24, Y+3	; 0x03
    3fa4:	9c 81       	ldd	r25, Y+4	; 0x04
    3fa6:	fc 01       	movw	r30, r24
    3fa8:	20 83       	st	Z, r18
   switch(command->groupID) {
    3faa:	89 81       	ldd	r24, Y+1	; 0x01
    3fac:	9a 81       	ldd	r25, Y+2	; 0x02
    3fae:	dc 01       	movw	r26, r24
    3fb0:	8c 91       	ld	r24, X
    3fb2:	99 27       	eor	r25, r25
    3fb4:	87 fd       	sbrc	r24, 7
    3fb6:	90 95       	com	r25
    3fb8:	aa 27       	eor	r26, r26
    3fba:	97 fd       	sbrc	r25, 7
    3fbc:	a0 95       	com	r26
    3fbe:	ba 2f       	mov	r27, r26
    3fc0:	41 e0       	ldi	r20, 0x01	; 1
    3fc2:	50 e0       	ldi	r21, 0x00	; 0
    3fc4:	27 e0       	ldi	r18, 0x07	; 7
    3fc6:	30 e0       	ldi	r19, 0x00	; 0
    3fc8:	84 1b       	sub	r24, r20
    3fca:	95 0b       	sbc	r25, r21
    3fcc:	28 17       	cp	r18, r24
    3fce:	39 07       	cpc	r19, r25
    3fd0:	08 f4       	brcc	.+2      	; 0x3fd4 <processCommand+0x50>
    3fd2:	4d c0       	rjmp	.+154    	; 0x406e <processCommand+0xea>
    3fd4:	8e 58       	subi	r24, 0x8E	; 142
    3fd6:	9f 4f       	sbci	r25, 0xFF	; 255
    3fd8:	fc 01       	movw	r30, r24
    3fda:	0c 94 82 27 	jmp	0x4f04	; 0x4f04 <__tablejump2__>
      case ULTRASONIC_GROUP:
         processUltrasonicCommand(command->cmd, command->payload,&response->size, response->payload);
    3fde:	8b 81       	ldd	r24, Y+3	; 0x03
    3fe0:	9c 81       	ldd	r25, Y+4	; 0x04
    3fe2:	9c 01       	movw	r18, r24
    3fe4:	2e 5f       	subi	r18, 0xFE	; 254
    3fe6:	3f 4f       	sbci	r19, 0xFF	; 255
    3fe8:	8b 81       	ldd	r24, Y+3	; 0x03
    3fea:	9c 81       	ldd	r25, Y+4	; 0x04
    3fec:	ac 01       	movw	r20, r24
    3fee:	4f 5f       	subi	r20, 0xFF	; 255
    3ff0:	5f 4f       	sbci	r21, 0xFF	; 255
    3ff2:	89 81       	ldd	r24, Y+1	; 0x01
    3ff4:	9a 81       	ldd	r25, Y+2	; 0x02
    3ff6:	03 96       	adiw	r24, 0x03	; 3
    3ff8:	69 81       	ldd	r22, Y+1	; 0x01
    3ffa:	7a 81       	ldd	r23, Y+2	; 0x02
    3ffc:	db 01       	movw	r26, r22
    3ffe:	11 96       	adiw	r26, 0x01	; 1
    4000:	ec 91       	ld	r30, X
    4002:	bc 01       	movw	r22, r24
    4004:	8e 2f       	mov	r24, r30
    4006:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <processUltrasonicCommand>
         break;
    400a:	31 c0       	rjmp	.+98     	; 0x406e <processCommand+0xea>
      case SPEED_GROUP:
			processSpeedCommand(command->cmd,command->payload,response);
    400c:	89 81       	ldd	r24, Y+1	; 0x01
    400e:	9a 81       	ldd	r25, Y+2	; 0x02
    4010:	03 96       	adiw	r24, 0x03	; 3
    4012:	29 81       	ldd	r18, Y+1	; 0x01
    4014:	3a 81       	ldd	r19, Y+2	; 0x02
    4016:	d9 01       	movw	r26, r18
    4018:	11 96       	adiw	r26, 0x01	; 1
    401a:	ec 91       	ld	r30, X
    401c:	2b 81       	ldd	r18, Y+3	; 0x03
    401e:	3c 81       	ldd	r19, Y+4	; 0x04
    4020:	a9 01       	movw	r20, r18
    4022:	bc 01       	movw	r22, r24
    4024:	8e 2f       	mov	r24, r30
    4026:	0e 94 71 1e 	call	0x3ce2	; 0x3ce2 <processSpeedCommand>
         break;
    402a:	21 c0       	rjmp	.+66     	; 0x406e <processCommand+0xea>
      case STEERING_GROUP:
         /*do steering things*/
         break;
      case FNR_GROUP:
			processFNRCommand(command->cmd,command->payload,response);
    402c:	89 81       	ldd	r24, Y+1	; 0x01
    402e:	9a 81       	ldd	r25, Y+2	; 0x02
    4030:	03 96       	adiw	r24, 0x03	; 3
    4032:	29 81       	ldd	r18, Y+1	; 0x01
    4034:	3a 81       	ldd	r19, Y+2	; 0x02
    4036:	d9 01       	movw	r26, r18
    4038:	11 96       	adiw	r26, 0x01	; 1
    403a:	ec 91       	ld	r30, X
    403c:	2b 81       	ldd	r18, Y+3	; 0x03
    403e:	3c 81       	ldd	r19, Y+4	; 0x04
    4040:	a9 01       	movw	r20, r18
    4042:	bc 01       	movw	r22, r24
    4044:	8e 2f       	mov	r24, r30
    4046:	0e 94 14 1f 	call	0x3e28	; 0x3e28 <processFNRCommand>
         break;
    404a:	11 c0       	rjmp	.+34     	; 0x406e <processCommand+0xea>
         break;
      case BATTERY_GROUP:
         /*do battery things*/
         break;
      case LIGHTS_GROUP:
	      processLightCommand(command->cmd,command->payload,response);
    404c:	89 81       	ldd	r24, Y+1	; 0x01
    404e:	9a 81       	ldd	r25, Y+2	; 0x02
    4050:	03 96       	adiw	r24, 0x03	; 3
    4052:	29 81       	ldd	r18, Y+1	; 0x01
    4054:	3a 81       	ldd	r19, Y+2	; 0x02
    4056:	d9 01       	movw	r26, r18
    4058:	11 96       	adiw	r26, 0x01	; 1
    405a:	ec 91       	ld	r30, X
    405c:	2b 81       	ldd	r18, Y+3	; 0x03
    405e:	3c 81       	ldd	r19, Y+4	; 0x04
    4060:	a9 01       	movw	r20, r18
    4062:	bc 01       	movw	r22, r24
    4064:	8e 2f       	mov	r24, r30
    4066:	0e 94 9a 1f 	call	0x3f34	; 0x3f34 <processLightCommand>
         break;
    406a:	01 c0       	rjmp	.+2      	; 0x406e <processCommand+0xea>
      case ERROR_GROUP:
         /*do error things*/
         break;
    406c:	00 00       	nop
   }
   //return a dummy success for now
   return 1;
    406e:	81 e0       	ldi	r24, 0x01	; 1
}
    4070:	0f 90       	pop	r0
    4072:	0f 90       	pop	r0
    4074:	0f 90       	pop	r0
    4076:	0f 90       	pop	r0
    4078:	df 91       	pop	r29
    407a:	cf 91       	pop	r28
    407c:	08 95       	ret

0000407e <getBatteryVoltage>:

//battery controller functions

//read battery strength in a char. Might need to be unsigned, specs don't say
//anything regarding that.
char getBatteryVoltage(char *sensorResponse) {
    407e:	cf 93       	push	r28
    4080:	df 93       	push	r29
    4082:	1f 92       	push	r1
    4084:	1f 92       	push	r1
    4086:	cd b7       	in	r28, 0x3d	; 61
    4088:	de b7       	in	r29, 0x3e	; 62
    408a:	9a 83       	std	Y+2, r25	; 0x02
    408c:	89 83       	std	Y+1, r24	; 0x01
   //fake battery reading
   *sensorResponse = 0;
    408e:	89 81       	ldd	r24, Y+1	; 0x01
    4090:	9a 81       	ldd	r25, Y+2	; 0x02
    4092:	fc 01       	movw	r30, r24
    4094:	10 82       	st	Z, r1
   //return success
   return 1;
    4096:	81 e0       	ldi	r24, 0x01	; 1
}
    4098:	0f 90       	pop	r0
    409a:	0f 90       	pop	r0
    409c:	df 91       	pop	r29
    409e:	cf 91       	pop	r28
    40a0:	08 95       	ret

000040a2 <getSteeringVoltage>:

//gets voltage from steering?
char getSteeringVoltage(char *sensorResponse) {
    40a2:	cf 93       	push	r28
    40a4:	df 93       	push	r29
    40a6:	1f 92       	push	r1
    40a8:	1f 92       	push	r1
    40aa:	cd b7       	in	r28, 0x3d	; 61
    40ac:	de b7       	in	r29, 0x3e	; 62
    40ae:	9a 83       	std	Y+2, r25	; 0x02
    40b0:	89 83       	std	Y+1, r24	; 0x01
   //fake steering voltage reading
   *sensorResponse = 0;
    40b2:	89 81       	ldd	r24, Y+1	; 0x01
    40b4:	9a 81       	ldd	r25, Y+2	; 0x02
    40b6:	fc 01       	movw	r30, r24
    40b8:	10 82       	st	Z, r1
   //return success
   return 1;
    40ba:	81 e0       	ldi	r24, 0x01	; 1
}
    40bc:	0f 90       	pop	r0
    40be:	0f 90       	pop	r0
    40c0:	df 91       	pop	r29
    40c2:	cf 91       	pop	r28
    40c4:	08 95       	ret

000040c6 <setBrake>:
//Brake controller functions. THERE IS CURRENTLY NO WAY TO GET THE DESIRED
//BRAKE TARGET IN THE SPECS

//set brake target
char setBrake(char gainTarget) {
    40c6:	cf 93       	push	r28
    40c8:	df 93       	push	r29
    40ca:	1f 92       	push	r1
    40cc:	cd b7       	in	r28, 0x3d	; 61
    40ce:	de b7       	in	r29, 0x3e	; 62
    40d0:	89 83       	std	Y+1, r24	; 0x01
   //dummy function, nothing happens
   //return success
   return 1;
    40d2:	81 e0       	ldi	r24, 0x01	; 1
}
    40d4:	0f 90       	pop	r0
    40d6:	df 91       	pop	r29
    40d8:	cf 91       	pop	r28
    40da:	08 95       	ret

000040dc <getBrake>:

//get what is assumed to be the current brake value?
char getBrake(char* sensorResponse) {
    40dc:	cf 93       	push	r28
    40de:	df 93       	push	r29
    40e0:	1f 92       	push	r1
    40e2:	1f 92       	push	r1
    40e4:	cd b7       	in	r28, 0x3d	; 61
    40e6:	de b7       	in	r29, 0x3e	; 62
    40e8:	9a 83       	std	Y+2, r25	; 0x02
    40ea:	89 83       	std	Y+1, r24	; 0x01
   //fake brake reading
   *sensorResponse = 0;
    40ec:	89 81       	ldd	r24, Y+1	; 0x01
    40ee:	9a 81       	ldd	r25, Y+2	; 0x02
    40f0:	fc 01       	movw	r30, r24
    40f2:	10 82       	st	Z, r1
   //return success
   return 1;
    40f4:	81 e0       	ldi	r24, 0x01	; 1
}
    40f6:	0f 90       	pop	r0
    40f8:	0f 90       	pop	r0
    40fa:	df 91       	pop	r29
    40fc:	cf 91       	pop	r28
    40fe:	08 95       	ret

00004100 <FNRForward>:

#define clearABit(x) \
PORTA &= ~(1 << (x));


void FNRForward(){
    4100:	cf 93       	push	r28
    4102:	df 93       	push	r29
    4104:	cd b7       	in	r28, 0x3d	; 61
    4106:	de b7       	in	r29, 0x3e	; 62
	clearABit(1);
    4108:	82 e2       	ldi	r24, 0x22	; 34
    410a:	90 e0       	ldi	r25, 0x00	; 0
    410c:	22 e2       	ldi	r18, 0x22	; 34
    410e:	30 e0       	ldi	r19, 0x00	; 0
    4110:	f9 01       	movw	r30, r18
    4112:	20 81       	ld	r18, Z
    4114:	2d 7f       	andi	r18, 0xFD	; 253
    4116:	fc 01       	movw	r30, r24
    4118:	20 83       	st	Z, r18
	while((PORTA & 0x2) != 0){
    411a:	0d c0       	rjmp	.+26     	; 0x4136 <FNRForward+0x36>
		clearABit(1);
    411c:	82 e2       	ldi	r24, 0x22	; 34
    411e:	90 e0       	ldi	r25, 0x00	; 0
    4120:	22 e2       	ldi	r18, 0x22	; 34
    4122:	30 e0       	ldi	r19, 0x00	; 0
    4124:	f9 01       	movw	r30, r18
    4126:	20 81       	ld	r18, Z
    4128:	2d 7f       	andi	r18, 0xFD	; 253
    412a:	fc 01       	movw	r30, r24
    412c:	20 83       	st	Z, r18
		vTaskDelay(1);
    412e:	81 e0       	ldi	r24, 0x01	; 1
    4130:	90 e0       	ldi	r25, 0x00	; 0
    4132:	0e 94 ca 04 	call	0x994	; 0x994 <vTaskDelay>
PORTA &= ~(1 << (x));


void FNRForward(){
	clearABit(1);
	while((PORTA & 0x2) != 0){
    4136:	82 e2       	ldi	r24, 0x22	; 34
    4138:	90 e0       	ldi	r25, 0x00	; 0
    413a:	fc 01       	movw	r30, r24
    413c:	80 81       	ld	r24, Z
    413e:	88 2f       	mov	r24, r24
    4140:	90 e0       	ldi	r25, 0x00	; 0
    4142:	82 70       	andi	r24, 0x02	; 2
    4144:	99 27       	eor	r25, r25
    4146:	00 97       	sbiw	r24, 0x00	; 0
    4148:	49 f7       	brne	.-46     	; 0x411c <FNRForward+0x1c>
		clearABit(1);
		vTaskDelay(1);
	}
	setABit(0);
    414a:	82 e2       	ldi	r24, 0x22	; 34
    414c:	90 e0       	ldi	r25, 0x00	; 0
    414e:	22 e2       	ldi	r18, 0x22	; 34
    4150:	30 e0       	ldi	r19, 0x00	; 0
    4152:	f9 01       	movw	r30, r18
    4154:	20 81       	ld	r18, Z
    4156:	21 60       	ori	r18, 0x01	; 1
    4158:	fc 01       	movw	r30, r24
    415a:	20 83       	st	Z, r18

	//PORTL &= ~0x30;
}
    415c:	df 91       	pop	r29
    415e:	cf 91       	pop	r28
    4160:	08 95       	ret

00004162 <FNRReverse>:

void FNRReverse(){
    4162:	cf 93       	push	r28
    4164:	df 93       	push	r29
    4166:	cd b7       	in	r28, 0x3d	; 61
    4168:	de b7       	in	r29, 0x3e	; 62
	clearABit(0);
    416a:	82 e2       	ldi	r24, 0x22	; 34
    416c:	90 e0       	ldi	r25, 0x00	; 0
    416e:	22 e2       	ldi	r18, 0x22	; 34
    4170:	30 e0       	ldi	r19, 0x00	; 0
    4172:	f9 01       	movw	r30, r18
    4174:	20 81       	ld	r18, Z
    4176:	2e 7f       	andi	r18, 0xFE	; 254
    4178:	fc 01       	movw	r30, r24
    417a:	20 83       	st	Z, r18
	while((PORTA & 0x1) != 0){
    417c:	0d c0       	rjmp	.+26     	; 0x4198 <FNRReverse+0x36>
		clearABit(0);
    417e:	82 e2       	ldi	r24, 0x22	; 34
    4180:	90 e0       	ldi	r25, 0x00	; 0
    4182:	22 e2       	ldi	r18, 0x22	; 34
    4184:	30 e0       	ldi	r19, 0x00	; 0
    4186:	f9 01       	movw	r30, r18
    4188:	20 81       	ld	r18, Z
    418a:	2e 7f       	andi	r18, 0xFE	; 254
    418c:	fc 01       	movw	r30, r24
    418e:	20 83       	st	Z, r18
		vTaskDelay(1);
    4190:	81 e0       	ldi	r24, 0x01	; 1
    4192:	90 e0       	ldi	r25, 0x00	; 0
    4194:	0e 94 ca 04 	call	0x994	; 0x994 <vTaskDelay>
	//PORTL &= ~0x30;
}

void FNRReverse(){
	clearABit(0);
	while((PORTA & 0x1) != 0){
    4198:	82 e2       	ldi	r24, 0x22	; 34
    419a:	90 e0       	ldi	r25, 0x00	; 0
    419c:	fc 01       	movw	r30, r24
    419e:	80 81       	ld	r24, Z
    41a0:	88 2f       	mov	r24, r24
    41a2:	90 e0       	ldi	r25, 0x00	; 0
    41a4:	81 70       	andi	r24, 0x01	; 1
    41a6:	99 27       	eor	r25, r25
    41a8:	00 97       	sbiw	r24, 0x00	; 0
    41aa:	49 f7       	brne	.-46     	; 0x417e <FNRReverse+0x1c>
		clearABit(0);
		vTaskDelay(1);
	}
	setABit(1);
    41ac:	82 e2       	ldi	r24, 0x22	; 34
    41ae:	90 e0       	ldi	r25, 0x00	; 0
    41b0:	22 e2       	ldi	r18, 0x22	; 34
    41b2:	30 e0       	ldi	r19, 0x00	; 0
    41b4:	f9 01       	movw	r30, r18
    41b6:	20 81       	ld	r18, Z
    41b8:	22 60       	ori	r18, 0x02	; 2
    41ba:	fc 01       	movw	r30, r24
    41bc:	20 83       	st	Z, r18

	//PORTL |= 0x30;
}
    41be:	df 91       	pop	r29
    41c0:	cf 91       	pop	r28
    41c2:	08 95       	ret

000041c4 <FNRNeutral>:

void FNRNeutral(){
    41c4:	cf 93       	push	r28
    41c6:	df 93       	push	r29
    41c8:	cd b7       	in	r28, 0x3d	; 61
    41ca:	de b7       	in	r29, 0x3e	; 62
	clearABit(0);
    41cc:	82 e2       	ldi	r24, 0x22	; 34
    41ce:	90 e0       	ldi	r25, 0x00	; 0
    41d0:	22 e2       	ldi	r18, 0x22	; 34
    41d2:	30 e0       	ldi	r19, 0x00	; 0
    41d4:	f9 01       	movw	r30, r18
    41d6:	20 81       	ld	r18, Z
    41d8:	2e 7f       	andi	r18, 0xFE	; 254
    41da:	fc 01       	movw	r30, r24
    41dc:	20 83       	st	Z, r18
	clearABit(1);
    41de:	82 e2       	ldi	r24, 0x22	; 34
    41e0:	90 e0       	ldi	r25, 0x00	; 0
    41e2:	22 e2       	ldi	r18, 0x22	; 34
    41e4:	30 e0       	ldi	r19, 0x00	; 0
    41e6:	f9 01       	movw	r30, r18
    41e8:	20 81       	ld	r18, Z
    41ea:	2d 7f       	andi	r18, 0xFD	; 253
    41ec:	fc 01       	movw	r30, r24
    41ee:	20 83       	st	Z, r18
	while((PORTA & 0x3) != 0){
    41f0:	16 c0       	rjmp	.+44     	; 0x421e <FNRNeutral+0x5a>
		clearABit(0);
    41f2:	82 e2       	ldi	r24, 0x22	; 34
    41f4:	90 e0       	ldi	r25, 0x00	; 0
    41f6:	22 e2       	ldi	r18, 0x22	; 34
    41f8:	30 e0       	ldi	r19, 0x00	; 0
    41fa:	f9 01       	movw	r30, r18
    41fc:	20 81       	ld	r18, Z
    41fe:	2e 7f       	andi	r18, 0xFE	; 254
    4200:	fc 01       	movw	r30, r24
    4202:	20 83       	st	Z, r18
		clearABit(1);
    4204:	82 e2       	ldi	r24, 0x22	; 34
    4206:	90 e0       	ldi	r25, 0x00	; 0
    4208:	22 e2       	ldi	r18, 0x22	; 34
    420a:	30 e0       	ldi	r19, 0x00	; 0
    420c:	f9 01       	movw	r30, r18
    420e:	20 81       	ld	r18, Z
    4210:	2d 7f       	andi	r18, 0xFD	; 253
    4212:	fc 01       	movw	r30, r24
    4214:	20 83       	st	Z, r18
		vTaskDelay(1);
    4216:	81 e0       	ldi	r24, 0x01	; 1
    4218:	90 e0       	ldi	r25, 0x00	; 0
    421a:	0e 94 ca 04 	call	0x994	; 0x994 <vTaskDelay>
}

void FNRNeutral(){
	clearABit(0);
	clearABit(1);
	while((PORTA & 0x3) != 0){
    421e:	82 e2       	ldi	r24, 0x22	; 34
    4220:	90 e0       	ldi	r25, 0x00	; 0
    4222:	fc 01       	movw	r30, r24
    4224:	80 81       	ld	r24, Z
    4226:	88 2f       	mov	r24, r24
    4228:	90 e0       	ldi	r25, 0x00	; 0
    422a:	83 70       	andi	r24, 0x03	; 3
    422c:	99 27       	eor	r25, r25
    422e:	00 97       	sbiw	r24, 0x00	; 0
    4230:	01 f7       	brne	.-64     	; 0x41f2 <FNRNeutral+0x2e>
		clearABit(0);
		clearABit(1);
		vTaskDelay(1);
	}
	//PORTL &= ~0x30;
}
    4232:	df 91       	pop	r29
    4234:	cf 91       	pop	r28
    4236:	08 95       	ret

00004238 <setFNR>:

//set the FNR controller, inputs are either -1, 0, or 1.
char setFNR(char FNR) {
    4238:	cf 93       	push	r28
    423a:	df 93       	push	r29
    423c:	1f 92       	push	r1
    423e:	cd b7       	in	r28, 0x3d	; 61
    4240:	de b7       	in	r29, 0x3e	; 62
    4242:	89 83       	std	Y+1, r24	; 0x01
   //dummy function, nothing happens
   //return success
	if(FNR == 0){
    4244:	89 81       	ldd	r24, Y+1	; 0x01
    4246:	88 23       	and	r24, r24
    4248:	19 f4       	brne	.+6      	; 0x4250 <setFNR+0x18>
		FNRNeutral();
    424a:	0e 94 e2 20 	call	0x41c4	; 0x41c4 <FNRNeutral>
    424e:	0b c0       	rjmp	.+22     	; 0x4266 <setFNR+0x2e>
	} else if(FNR == 1){
    4250:	89 81       	ldd	r24, Y+1	; 0x01
    4252:	81 30       	cpi	r24, 0x01	; 1
    4254:	19 f4       	brne	.+6      	; 0x425c <setFNR+0x24>
		FNRForward();
    4256:	0e 94 80 20 	call	0x4100	; 0x4100 <FNRForward>
    425a:	05 c0       	rjmp	.+10     	; 0x4266 <setFNR+0x2e>
	} else if(FNR == -1){
    425c:	89 81       	ldd	r24, Y+1	; 0x01
    425e:	8f 3f       	cpi	r24, 0xFF	; 255
    4260:	11 f4       	brne	.+4      	; 0x4266 <setFNR+0x2e>
		FNRReverse();
    4262:	0e 94 b1 20 	call	0x4162	; 0x4162 <FNRReverse>
	}

   return 1;
    4266:	81 e0       	ldi	r24, 0x01	; 1
}
    4268:	0f 90       	pop	r0
    426a:	df 91       	pop	r29
    426c:	cf 91       	pop	r28
    426e:	08 95       	ret

00004270 <getFNR>:

//get the current FNR state. Function follows same format for consistancy
char getFNR(char *sensorResponse) {
    4270:	cf 93       	push	r28
    4272:	df 93       	push	r29
    4274:	1f 92       	push	r1
    4276:	1f 92       	push	r1
    4278:	cd b7       	in	r28, 0x3d	; 61
    427a:	de b7       	in	r29, 0x3e	; 62
    427c:	9a 83       	std	Y+2, r25	; 0x02
    427e:	89 83       	std	Y+1, r24	; 0x01
   //fake reading
   *sensorResponse = 0;
    4280:	89 81       	ldd	r24, Y+1	; 0x01
    4282:	9a 81       	ldd	r25, Y+2	; 0x02
    4284:	fc 01       	movw	r30, r24
    4286:	10 82       	st	Z, r1
   //return success
   return 1;
    4288:	81 e0       	ldi	r24, 0x01	; 1
}
    428a:	0f 90       	pop	r0
    428c:	0f 90       	pop	r0
    428e:	df 91       	pop	r29
    4290:	cf 91       	pop	r28
    4292:	08 95       	ret

00004294 <setLight>:
//light controller functions
#include <avr/io.h>

//turn lights on and off
char setLight(unsigned char lightTarget) {
    4294:	cf 93       	push	r28
    4296:	df 93       	push	r29
    4298:	1f 92       	push	r1
    429a:	cd b7       	in	r28, 0x3d	; 61
    429c:	de b7       	in	r29, 0x3e	; 62
    429e:	89 83       	std	Y+1, r24	; 0x01
   //dummy function, nothing happens
	//PORTB ^= 0x80;
	if(lightTarget == 1){
    42a0:	89 81       	ldd	r24, Y+1	; 0x01
    42a2:	81 30       	cpi	r24, 0x01	; 1
    42a4:	51 f4       	brne	.+20     	; 0x42ba <setLight+0x26>
		PORTB |= 0x80;
    42a6:	85 e2       	ldi	r24, 0x25	; 37
    42a8:	90 e0       	ldi	r25, 0x00	; 0
    42aa:	25 e2       	ldi	r18, 0x25	; 37
    42ac:	30 e0       	ldi	r19, 0x00	; 0
    42ae:	f9 01       	movw	r30, r18
    42b0:	20 81       	ld	r18, Z
    42b2:	20 68       	ori	r18, 0x80	; 128
    42b4:	fc 01       	movw	r30, r24
    42b6:	20 83       	st	Z, r18
    42b8:	09 c0       	rjmp	.+18     	; 0x42cc <setLight+0x38>
	} else {
		PORTB &= ~0x80;
    42ba:	85 e2       	ldi	r24, 0x25	; 37
    42bc:	90 e0       	ldi	r25, 0x00	; 0
    42be:	25 e2       	ldi	r18, 0x25	; 37
    42c0:	30 e0       	ldi	r19, 0x00	; 0
    42c2:	f9 01       	movw	r30, r18
    42c4:	20 81       	ld	r18, Z
    42c6:	2f 77       	andi	r18, 0x7F	; 127
    42c8:	fc 01       	movw	r30, r24
    42ca:	20 83       	st	Z, r18
	}
   return 1;
    42cc:	81 e0       	ldi	r24, 0x01	; 1
}
    42ce:	0f 90       	pop	r0
    42d0:	df 91       	pop	r29
    42d2:	cf 91       	pop	r28
    42d4:	08 95       	ret

000042d6 <setSonarData>:
	USART_Write(hex[(i&0xF0) >> 4]);
	USART_Write(hex[i&0xF]);

}   */

void setSonarData(int i,unsigned char data){
    42d6:	cf 93       	push	r28
    42d8:	df 93       	push	r29
    42da:	00 d0       	rcall	.+0      	; 0x42dc <setSonarData+0x6>
    42dc:	cd b7       	in	r28, 0x3d	; 61
    42de:	de b7       	in	r29, 0x3e	; 62
    42e0:	9a 83       	std	Y+2, r25	; 0x02
    42e2:	89 83       	std	Y+1, r24	; 0x01
    42e4:	6b 83       	std	Y+3, r22	; 0x03
// xSemaphoreTake(sonarDataMutex[i],portMAX_DELAY);
   sonarData[i] = data;
    42e6:	89 81       	ldd	r24, Y+1	; 0x01
    42e8:	9a 81       	ldd	r25, Y+2	; 0x02
    42ea:	8b 53       	subi	r24, 0x3B	; 59
    42ec:	95 4e       	sbci	r25, 0xE5	; 229
    42ee:	2b 81       	ldd	r18, Y+3	; 0x03
    42f0:	fc 01       	movw	r30, r24
    42f2:	20 83       	st	Z, r18
   //xSemaphoreGive(sonarDataMutex[i]);
}
    42f4:	0f 90       	pop	r0
    42f6:	0f 90       	pop	r0
    42f8:	0f 90       	pop	r0
    42fa:	df 91       	pop	r29
    42fc:	cf 91       	pop	r28
    42fe:	08 95       	ret

00004300 <getSonarData>:

unsigned char getSonarData(int i){
    4300:	cf 93       	push	r28
    4302:	df 93       	push	r29
    4304:	1f 92       	push	r1
    4306:	1f 92       	push	r1
    4308:	cd b7       	in	r28, 0x3d	; 61
    430a:	de b7       	in	r29, 0x3e	; 62
    430c:	9a 83       	std	Y+2, r25	; 0x02
    430e:	89 83       	std	Y+1, r24	; 0x01
   //xSemaphoreTake(sonarDataMutex[i],portMAX_DELAY);
   return sonarData[i];
    4310:	89 81       	ldd	r24, Y+1	; 0x01
    4312:	9a 81       	ldd	r25, Y+2	; 0x02
    4314:	8b 53       	subi	r24, 0x3B	; 59
    4316:	95 4e       	sbci	r25, 0xE5	; 229
    4318:	fc 01       	movw	r30, r24
    431a:	80 81       	ld	r24, Z
   //xSemaphoreGive(sonarDataMutex[i]);
}
    431c:	0f 90       	pop	r0
    431e:	0f 90       	pop	r0
    4320:	df 91       	pop	r29
    4322:	cf 91       	pop	r28
    4324:	08 95       	ret

00004326 <getTimerCount>:

unsigned char getTimerCount(){
    4326:	cf 93       	push	r28
    4328:	df 93       	push	r29
    432a:	cd b7       	in	r28, 0x3d	; 61
    432c:	de b7       	in	r29, 0x3e	; 62
   return TCNT0;
    432e:	86 e4       	ldi	r24, 0x46	; 70
    4330:	90 e0       	ldi	r25, 0x00	; 0
    4332:	fc 01       	movw	r30, r24
    4334:	80 81       	ld	r24, Z
}
    4336:	df 91       	pop	r29
    4338:	cf 91       	pop	r28
    433a:	08 95       	ret

0000433c <__vector_11>:

inline void setTimerCount(unsigned char i){
   TCNT0 = i;
}

ISR(PCINT2_vect) {
    433c:	1f 92       	push	r1
    433e:	0f 92       	push	r0
    4340:	00 90 5f 00 	lds	r0, 0x005F
    4344:	0f 92       	push	r0
    4346:	11 24       	eor	r1, r1
    4348:	00 90 5b 00 	lds	r0, 0x005B
    434c:	0f 92       	push	r0
    434e:	2f 93       	push	r18
    4350:	3f 93       	push	r19
    4352:	4f 93       	push	r20
    4354:	5f 93       	push	r21
    4356:	6f 93       	push	r22
    4358:	7f 93       	push	r23
    435a:	8f 93       	push	r24
    435c:	9f 93       	push	r25
    435e:	af 93       	push	r26
    4360:	bf 93       	push	r27
    4362:	ef 93       	push	r30
    4364:	ff 93       	push	r31
    4366:	cf 93       	push	r28
    4368:	df 93       	push	r29
    436a:	00 d0       	rcall	.+0      	; 0x436c <__vector_11+0x30>
    436c:	cd b7       	in	r28, 0x3d	; 61
    436e:	de b7       	in	r29, 0x3e	; 62

   unsigned char beginCount;
   unsigned char currCount;
   char i=0;   
    4370:	19 82       	std	Y+1, r1	; 0x01

   if(PINK&(1<<currSonar)){
    4372:	86 e0       	ldi	r24, 0x06	; 6
    4374:	91 e0       	ldi	r25, 0x01	; 1
    4376:	fc 01       	movw	r30, r24
    4378:	80 81       	ld	r24, Z
    437a:	88 2f       	mov	r24, r24
    437c:	90 e0       	ldi	r25, 0x00	; 0
    437e:	20 91 cd 1a 	lds	r18, 0x1ACD
    4382:	22 2f       	mov	r18, r18
    4384:	30 e0       	ldi	r19, 0x00	; 0
    4386:	02 2e       	mov	r0, r18
    4388:	02 c0       	rjmp	.+4      	; 0x438e <__vector_11+0x52>
    438a:	95 95       	asr	r25
    438c:	87 95       	ror	r24
    438e:	0a 94       	dec	r0
    4390:	e2 f7       	brpl	.-8      	; 0x438a <__vector_11+0x4e>
    4392:	81 70       	andi	r24, 0x01	; 1
    4394:	99 27       	eor	r25, r25
    4396:	00 97       	sbiw	r24, 0x00	; 0
    4398:	49 f0       	breq	.+18     	; 0x43ac <__vector_11+0x70>
      //USART_AddToQueue('U');
      beginCount = getTimerCount();
    439a:	0e 94 93 21 	call	0x4326	; 0x4326 <getTimerCount>
    439e:	8a 83       	std	Y+2, r24	; 0x02
      PORTE = 0xFF;
    43a0:	8e e2       	ldi	r24, 0x2E	; 46
    43a2:	90 e0       	ldi	r25, 0x00	; 0
    43a4:	2f ef       	ldi	r18, 0xFF	; 255
    43a6:	fc 01       	movw	r30, r24
    43a8:	20 83       	st	Z, r18
    43aa:	1d c0       	rjmp	.+58     	; 0x43e6 <__vector_11+0xaa>
   } else {
      //USART_AddToQueue('D');
      currCount = getTimerCount();
    43ac:	0e 94 93 21 	call	0x4326	; 0x4326 <getTimerCount>
    43b0:	8b 83       	std	Y+3, r24	; 0x03
      if(currCount > beginCount){
    43b2:	9b 81       	ldd	r25, Y+3	; 0x03
    43b4:	8a 81       	ldd	r24, Y+2	; 0x02
    43b6:	89 17       	cp	r24, r25
    43b8:	38 f4       	brcc	.+14     	; 0x43c8 <__vector_11+0x8c>
         lastSonarData = currCount - beginCount;
    43ba:	9b 81       	ldd	r25, Y+3	; 0x03
    43bc:	8a 81       	ldd	r24, Y+2	; 0x02
    43be:	f9 2f       	mov	r31, r25
    43c0:	f8 1b       	sub	r31, r24
    43c2:	8f 2f       	mov	r24, r31
    43c4:	80 93 ce 1a 	sts	0x1ACE, r24
      }
      PORTE = 0;
    43c8:	8e e2       	ldi	r24, 0x2E	; 46
    43ca:	90 e0       	ldi	r25, 0x00	; 0
    43cc:	fc 01       	movw	r30, r24
    43ce:	10 82       	st	Z, r1
      xSemaphoreGiveFromISR(sonarSemaphore,0);
    43d0:	80 91 5d 1b 	lds	r24, 0x1B5D
    43d4:	90 91 5e 1b 	lds	r25, 0x1B5E
    43d8:	20 e0       	ldi	r18, 0x00	; 0
    43da:	40 e0       	ldi	r20, 0x00	; 0
    43dc:	50 e0       	ldi	r21, 0x00	; 0
    43de:	60 e0       	ldi	r22, 0x00	; 0
    43e0:	70 e0       	ldi	r23, 0x00	; 0
    43e2:	0e 94 9d 0e 	call	0x1d3a	; 0x1d3a <xQueueGenericSendFromISR>
   }

}
    43e6:	0f 90       	pop	r0
    43e8:	0f 90       	pop	r0
    43ea:	0f 90       	pop	r0
    43ec:	df 91       	pop	r29
    43ee:	cf 91       	pop	r28
    43f0:	ff 91       	pop	r31
    43f2:	ef 91       	pop	r30
    43f4:	bf 91       	pop	r27
    43f6:	af 91       	pop	r26
    43f8:	9f 91       	pop	r25
    43fa:	8f 91       	pop	r24
    43fc:	7f 91       	pop	r23
    43fe:	6f 91       	pop	r22
    4400:	5f 91       	pop	r21
    4402:	4f 91       	pop	r20
    4404:	3f 91       	pop	r19
    4406:	2f 91       	pop	r18
    4408:	0f 90       	pop	r0
    440a:	00 92 5b 00 	sts	0x005B, r0
    440e:	0f 90       	pop	r0
    4410:	00 92 5f 00 	sts	0x005F, r0
    4414:	0f 90       	pop	r0
    4416:	1f 90       	pop	r1
    4418:	18 95       	reti

0000441a <sonarADCHandler>:

void sonarADCHandler(int result,void *sonarNum){
    441a:	cf 93       	push	r28
    441c:	df 93       	push	r29
    441e:	00 d0       	rcall	.+0      	; 0x4420 <sonarADCHandler+0x6>
    4420:	1f 92       	push	r1
    4422:	cd b7       	in	r28, 0x3d	; 61
    4424:	de b7       	in	r29, 0x3e	; 62
    4426:	9a 83       	std	Y+2, r25	; 0x02
    4428:	89 83       	std	Y+1, r24	; 0x01
    442a:	7c 83       	std	Y+4, r23	; 0x04
    442c:	6b 83       	std	Y+3, r22	; 0x03

	/*printHex(*((int *)sonarNum));
	USART_Write('\n');
	USART_Write('\r');*/

	setSonarData(*((int *)sonarNum),result);
    442e:	29 81       	ldd	r18, Y+1	; 0x01
    4430:	8b 81       	ldd	r24, Y+3	; 0x03
    4432:	9c 81       	ldd	r25, Y+4	; 0x04
    4434:	fc 01       	movw	r30, r24
    4436:	80 81       	ld	r24, Z
    4438:	91 81       	ldd	r25, Z+1	; 0x01
    443a:	62 2f       	mov	r22, r18
    443c:	0e 94 6b 21 	call	0x42d6	; 0x42d6 <setSonarData>

}
    4440:	0f 90       	pop	r0
    4442:	0f 90       	pop	r0
    4444:	0f 90       	pop	r0
    4446:	0f 90       	pop	r0
    4448:	df 91       	pop	r29
    444a:	cf 91       	pop	r28
    444c:	08 95       	ret

0000444e <initializeSonarSensors>:

void initializeSonarSensors(){
    444e:	cf 93       	push	r28
    4450:	df 93       	push	r29
    4452:	cd b7       	in	r28, 0x3d	; 61
    4454:	de b7       	in	r29, 0x3e	; 62
   PCICR = 0x7;

   TCCR0A = 0;
   TCCR0B = 5;*/

	addADCDevice(0,ADC_OPT_PRECISION_MED_HIGH,sonarADCHandler,&sonarNum0);			
    4456:	2b ec       	ldi	r18, 0xCB	; 203
    4458:	3a e1       	ldi	r19, 0x1A	; 26
    445a:	4d e0       	ldi	r20, 0x0D	; 13
    445c:	52 e2       	ldi	r21, 0x22	; 34
    445e:	61 e0       	ldi	r22, 0x01	; 1
    4460:	70 e0       	ldi	r23, 0x00	; 0
    4462:	80 e0       	ldi	r24, 0x00	; 0
    4464:	90 e0       	ldi	r25, 0x00	; 0
    4466:	0e 94 c0 26 	call	0x4d80	; 0x4d80 <addADCDevice>
	addADCDevice(7,ADC_OPT_PRECISION_HIGH,sonarADCHandler,&sonarNum1);			
    446a:	22 e0       	ldi	r18, 0x02	; 2
    446c:	32 e0       	ldi	r19, 0x02	; 2
    446e:	4d e0       	ldi	r20, 0x0D	; 13
    4470:	52 e2       	ldi	r21, 0x22	; 34
    4472:	60 e0       	ldi	r22, 0x00	; 0
    4474:	70 e0       	ldi	r23, 0x00	; 0
    4476:	87 e0       	ldi	r24, 0x07	; 7
    4478:	90 e0       	ldi	r25, 0x00	; 0
    447a:	0e 94 c0 26 	call	0x4d80	; 0x4d80 <addADCDevice>

}
    447e:	df 91       	pop	r29
    4480:	cf 91       	pop	r28
    4482:	08 95       	ret

00004484 <vTaskSonar>:

void vTaskSonar(void* parameter){
    4484:	cf 93       	push	r28
    4486:	df 93       	push	r29
    4488:	1f 92       	push	r1
    448a:	1f 92       	push	r1
    448c:	cd b7       	in	r28, 0x3d	; 61
    448e:	de b7       	in	r29, 0x3e	; 62
    4490:	9a 83       	std	Y+2, r25	; 0x02
    4492:	89 83       	std	Y+1, r24	; 0x01

   int i;
   initializeSonarSensors();
    4494:	0e 94 27 22 	call	0x444e	; 0x444e <initializeSonarSensors>
	for(;;){
		vTaskDelay(300);
    4498:	8c e2       	ldi	r24, 0x2C	; 44
    449a:	91 e0       	ldi	r25, 0x01	; 1
    449c:	0e 94 ca 04 	call	0x994	; 0x994 <vTaskDelay>
	}
    44a0:	fb cf       	rjmp	.-10     	; 0x4498 <vTaskSonar+0x14>

000044a2 <getAllSensors>:
      }
   }
            
} 

char getAllSensors(unsigned short* responseData){
    44a2:	cf 93       	push	r28
    44a4:	df 93       	push	r29
    44a6:	00 d0       	rcall	.+0      	; 0x44a8 <getAllSensors+0x6>
    44a8:	1f 92       	push	r1
    44aa:	cd b7       	in	r28, 0x3d	; 61
    44ac:	de b7       	in	r29, 0x3e	; 62
    44ae:	9c 83       	std	Y+4, r25	; 0x04
    44b0:	8b 83       	std	Y+3, r24	; 0x03
   unsigned short i;
   for(i=0;i<6;i++){
    44b2:	1a 82       	std	Y+2, r1	; 0x02
    44b4:	19 82       	std	Y+1, r1	; 0x01
    44b6:	14 c0       	rjmp	.+40     	; 0x44e0 <getAllSensors+0x3e>
      //responseData[i] = getSonarData(i);
      responseData[i] = i+1;
    44b8:	89 81       	ldd	r24, Y+1	; 0x01
    44ba:	9a 81       	ldd	r25, Y+2	; 0x02
    44bc:	88 0f       	add	r24, r24
    44be:	99 1f       	adc	r25, r25
    44c0:	2b 81       	ldd	r18, Y+3	; 0x03
    44c2:	3c 81       	ldd	r19, Y+4	; 0x04
    44c4:	82 0f       	add	r24, r18
    44c6:	93 1f       	adc	r25, r19
    44c8:	29 81       	ldd	r18, Y+1	; 0x01
    44ca:	3a 81       	ldd	r19, Y+2	; 0x02
    44cc:	2f 5f       	subi	r18, 0xFF	; 255
    44ce:	3f 4f       	sbci	r19, 0xFF	; 255
    44d0:	fc 01       	movw	r30, r24
    44d2:	31 83       	std	Z+1, r19	; 0x01
    44d4:	20 83       	st	Z, r18
            
} 

char getAllSensors(unsigned short* responseData){
   unsigned short i;
   for(i=0;i<6;i++){
    44d6:	89 81       	ldd	r24, Y+1	; 0x01
    44d8:	9a 81       	ldd	r25, Y+2	; 0x02
    44da:	01 96       	adiw	r24, 0x01	; 1
    44dc:	9a 83       	std	Y+2, r25	; 0x02
    44de:	89 83       	std	Y+1, r24	; 0x01
    44e0:	89 81       	ldd	r24, Y+1	; 0x01
    44e2:	9a 81       	ldd	r25, Y+2	; 0x02
    44e4:	86 30       	cpi	r24, 0x06	; 6
    44e6:	91 05       	cpc	r25, r1
    44e8:	38 f3       	brcs	.-50     	; 0x44b8 <getAllSensors+0x16>
      //responseData[i] = getSonarData(i);
      responseData[i] = i+1;
   }
}
    44ea:	0f 90       	pop	r0
    44ec:	0f 90       	pop	r0
    44ee:	0f 90       	pop	r0
    44f0:	0f 90       	pop	r0
    44f2:	df 91       	pop	r29
    44f4:	cf 91       	pop	r28
    44f6:	08 95       	ret

000044f8 <getCertainSensor>:

char getCertainSensor(char commandData,int* responseData){
    44f8:	0f 93       	push	r16
    44fa:	1f 93       	push	r17
    44fc:	cf 93       	push	r28
    44fe:	df 93       	push	r29
    4500:	00 d0       	rcall	.+0      	; 0x4502 <getCertainSensor+0xa>
    4502:	cd b7       	in	r28, 0x3d	; 61
    4504:	de b7       	in	r29, 0x3e	; 62
    4506:	89 83       	std	Y+1, r24	; 0x01
    4508:	7b 83       	std	Y+3, r23	; 0x03
    450a:	6a 83       	std	Y+2, r22	; 0x02
   if(commandData < 6){
    450c:	89 81       	ldd	r24, Y+1	; 0x01
    450e:	86 30       	cpi	r24, 0x06	; 6
    4510:	b4 f4       	brge	.+44     	; 0x453e <getCertainSensor+0x46>
      responseData[commandData] = getSonarData(commandData);
    4512:	89 81       	ldd	r24, Y+1	; 0x01
    4514:	99 27       	eor	r25, r25
    4516:	87 fd       	sbrc	r24, 7
    4518:	90 95       	com	r25
    451a:	88 0f       	add	r24, r24
    451c:	99 1f       	adc	r25, r25
    451e:	2a 81       	ldd	r18, Y+2	; 0x02
    4520:	3b 81       	ldd	r19, Y+3	; 0x03
    4522:	89 01       	movw	r16, r18
    4524:	08 0f       	add	r16, r24
    4526:	19 1f       	adc	r17, r25
    4528:	89 81       	ldd	r24, Y+1	; 0x01
    452a:	99 27       	eor	r25, r25
    452c:	87 fd       	sbrc	r24, 7
    452e:	90 95       	com	r25
    4530:	0e 94 80 21 	call	0x4300	; 0x4300 <getSonarData>
    4534:	88 2f       	mov	r24, r24
    4536:	90 e0       	ldi	r25, 0x00	; 0
    4538:	f8 01       	movw	r30, r16
    453a:	91 83       	std	Z+1, r25	; 0x01
    453c:	80 83       	st	Z, r24
   }
}
    453e:	0f 90       	pop	r0
    4540:	0f 90       	pop	r0
    4542:	0f 90       	pop	r0
    4544:	df 91       	pop	r29
    4546:	cf 91       	pop	r28
    4548:	1f 91       	pop	r17
    454a:	0f 91       	pop	r16
    454c:	08 95       	ret

0000454e <getSensorGroup>:

char getSensorGroup(char commandData,int* responseData){
    454e:	0f 93       	push	r16
    4550:	1f 93       	push	r17
    4552:	cf 93       	push	r28
    4554:	df 93       	push	r29
    4556:	00 d0       	rcall	.+0      	; 0x4558 <getSensorGroup+0xa>
    4558:	cd b7       	in	r28, 0x3d	; 61
    455a:	de b7       	in	r29, 0x3e	; 62
    455c:	89 83       	std	Y+1, r24	; 0x01
    455e:	7b 83       	std	Y+3, r23	; 0x03
    4560:	6a 83       	std	Y+2, r22	; 0x02

   switch(commandData){
    4562:	89 81       	ldd	r24, Y+1	; 0x01
    4564:	99 27       	eor	r25, r25
    4566:	87 fd       	sbrc	r24, 7
    4568:	90 95       	com	r25
    456a:	81 30       	cpi	r24, 0x01	; 1
    456c:	91 05       	cpc	r25, r1
    456e:	01 f1       	breq	.+64     	; 0x45b0 <getSensorGroup+0x62>
    4570:	82 30       	cpi	r24, 0x02	; 2
    4572:	91 05       	cpc	r25, r1
    4574:	b9 f1       	breq	.+110    	; 0x45e4 <getSensorGroup+0x96>
    4576:	00 97       	sbiw	r24, 0x00	; 0
    4578:	09 f0       	breq	.+2      	; 0x457c <getSensorGroup+0x2e>
    457a:	4e c0       	rjmp	.+156    	; 0x4618 <getSensorGroup+0xca>
      case SONAR_GROUP_LEFT:
         responseData[0] = getSonarData(0);
    457c:	80 e0       	ldi	r24, 0x00	; 0
    457e:	90 e0       	ldi	r25, 0x00	; 0
    4580:	0e 94 80 21 	call	0x4300	; 0x4300 <getSonarData>
    4584:	28 2f       	mov	r18, r24
    4586:	30 e0       	ldi	r19, 0x00	; 0
    4588:	8a 81       	ldd	r24, Y+2	; 0x02
    458a:	9b 81       	ldd	r25, Y+3	; 0x03
    458c:	fc 01       	movw	r30, r24
    458e:	31 83       	std	Z+1, r19	; 0x01
    4590:	20 83       	st	Z, r18
         responseData[1] = getSonarData(1);
    4592:	8a 81       	ldd	r24, Y+2	; 0x02
    4594:	9b 81       	ldd	r25, Y+3	; 0x03
    4596:	8c 01       	movw	r16, r24
    4598:	0e 5f       	subi	r16, 0xFE	; 254
    459a:	1f 4f       	sbci	r17, 0xFF	; 255
    459c:	81 e0       	ldi	r24, 0x01	; 1
    459e:	90 e0       	ldi	r25, 0x00	; 0
    45a0:	0e 94 80 21 	call	0x4300	; 0x4300 <getSonarData>
    45a4:	88 2f       	mov	r24, r24
    45a6:	90 e0       	ldi	r25, 0x00	; 0
    45a8:	f8 01       	movw	r30, r16
    45aa:	91 83       	std	Z+1, r25	; 0x01
    45ac:	80 83       	st	Z, r24
         break;
    45ae:	34 c0       	rjmp	.+104    	; 0x4618 <getSensorGroup+0xca>
      case SONAR_GROUP_FRONT:
         responseData[0] = getSonarData(2);
    45b0:	82 e0       	ldi	r24, 0x02	; 2
    45b2:	90 e0       	ldi	r25, 0x00	; 0
    45b4:	0e 94 80 21 	call	0x4300	; 0x4300 <getSonarData>
    45b8:	28 2f       	mov	r18, r24
    45ba:	30 e0       	ldi	r19, 0x00	; 0
    45bc:	8a 81       	ldd	r24, Y+2	; 0x02
    45be:	9b 81       	ldd	r25, Y+3	; 0x03
    45c0:	fc 01       	movw	r30, r24
    45c2:	31 83       	std	Z+1, r19	; 0x01
    45c4:	20 83       	st	Z, r18
         responseData[1] = getSonarData(3);
    45c6:	8a 81       	ldd	r24, Y+2	; 0x02
    45c8:	9b 81       	ldd	r25, Y+3	; 0x03
    45ca:	8c 01       	movw	r16, r24
    45cc:	0e 5f       	subi	r16, 0xFE	; 254
    45ce:	1f 4f       	sbci	r17, 0xFF	; 255
    45d0:	83 e0       	ldi	r24, 0x03	; 3
    45d2:	90 e0       	ldi	r25, 0x00	; 0
    45d4:	0e 94 80 21 	call	0x4300	; 0x4300 <getSonarData>
    45d8:	88 2f       	mov	r24, r24
    45da:	90 e0       	ldi	r25, 0x00	; 0
    45dc:	f8 01       	movw	r30, r16
    45de:	91 83       	std	Z+1, r25	; 0x01
    45e0:	80 83       	st	Z, r24
         break;
    45e2:	1a c0       	rjmp	.+52     	; 0x4618 <getSensorGroup+0xca>
      case SONAR_GROUP_RIGHT:
         responseData[0] = getSonarData(4);
    45e4:	84 e0       	ldi	r24, 0x04	; 4
    45e6:	90 e0       	ldi	r25, 0x00	; 0
    45e8:	0e 94 80 21 	call	0x4300	; 0x4300 <getSonarData>
    45ec:	28 2f       	mov	r18, r24
    45ee:	30 e0       	ldi	r19, 0x00	; 0
    45f0:	8a 81       	ldd	r24, Y+2	; 0x02
    45f2:	9b 81       	ldd	r25, Y+3	; 0x03
    45f4:	fc 01       	movw	r30, r24
    45f6:	31 83       	std	Z+1, r19	; 0x01
    45f8:	20 83       	st	Z, r18
         responseData[1] = getSonarData(5);
    45fa:	8a 81       	ldd	r24, Y+2	; 0x02
    45fc:	9b 81       	ldd	r25, Y+3	; 0x03
    45fe:	8c 01       	movw	r16, r24
    4600:	0e 5f       	subi	r16, 0xFE	; 254
    4602:	1f 4f       	sbci	r17, 0xFF	; 255
    4604:	85 e0       	ldi	r24, 0x05	; 5
    4606:	90 e0       	ldi	r25, 0x00	; 0
    4608:	0e 94 80 21 	call	0x4300	; 0x4300 <getSonarData>
    460c:	88 2f       	mov	r24, r24
    460e:	90 e0       	ldi	r25, 0x00	; 0
    4610:	f8 01       	movw	r30, r16
    4612:	91 83       	std	Z+1, r25	; 0x01
    4614:	80 83       	st	Z, r24
         break;
    4616:	00 00       	nop
   }

}
    4618:	0f 90       	pop	r0
    461a:	0f 90       	pop	r0
    461c:	0f 90       	pop	r0
    461e:	df 91       	pop	r29
    4620:	cf 91       	pop	r28
    4622:	1f 91       	pop	r17
    4624:	0f 91       	pop	r16
    4626:	08 95       	ret

00004628 <initSpeedController>:
//Speed Sensor group
#include <avr/io.h>
#include "spi.h"

void initSpeedController(){
    4628:	cf 93       	push	r28
    462a:	df 93       	push	r29
    462c:	cd b7       	in	r28, 0x3d	; 61
    462e:	de b7       	in	r29, 0x3e	; 62
	SPIsendShort(0x400F);
    4630:	8f e0       	ldi	r24, 0x0F	; 15
    4632:	90 e4       	ldi	r25, 0x40	; 64
    4634:	0e 94 89 24 	call	0x4912	; 0x4912 <SPIsendShort>
}
    4638:	df 91       	pop	r29
    463a:	cf 91       	pop	r28
    463c:	08 95       	ret

0000463e <setPot>:

void setPot(int value){
    463e:	cf 93       	push	r28
    4640:	df 93       	push	r29
    4642:	00 d0       	rcall	.+0      	; 0x4644 <setPot+0x6>
    4644:	1f 92       	push	r1
    4646:	cd b7       	in	r28, 0x3d	; 61
    4648:	de b7       	in	r29, 0x3e	; 62
    464a:	9c 83       	std	Y+4, r25	; 0x04
    464c:	8b 83       	std	Y+3, r24	; 0x03
	unsigned short data = 0;
    464e:	1a 82       	std	Y+2, r1	; 0x02
    4650:	19 82       	std	Y+1, r1	; 0x01
	data = value & 0xFF;
    4652:	8b 81       	ldd	r24, Y+3	; 0x03
    4654:	9c 81       	ldd	r25, Y+4	; 0x04
    4656:	99 27       	eor	r25, r25
    4658:	9a 83       	std	Y+2, r25	; 0x02
    465a:	89 83       	std	Y+1, r24	; 0x01

	SPIsendShort(data);
    465c:	89 81       	ldd	r24, Y+1	; 0x01
    465e:	9a 81       	ldd	r25, Y+2	; 0x02
    4660:	0e 94 89 24 	call	0x4912	; 0x4912 <SPIsendShort>
}
    4664:	0f 90       	pop	r0
    4666:	0f 90       	pop	r0
    4668:	0f 90       	pop	r0
    466a:	0f 90       	pop	r0
    466c:	df 91       	pop	r29
    466e:	cf 91       	pop	r28
    4670:	08 95       	ret

00004672 <decrementPot>:

void decrementPot(){
    4672:	cf 93       	push	r28
    4674:	df 93       	push	r29
    4676:	cd b7       	in	r28, 0x3d	; 61
    4678:	de b7       	in	r29, 0x3e	; 62
	SPIsendByte(0x06);
    467a:	86 e0       	ldi	r24, 0x06	; 6
    467c:	90 e0       	ldi	r25, 0x00	; 0
    467e:	0e 94 43 24 	call	0x4886	; 0x4886 <SPIsendByte>
}
    4682:	df 91       	pop	r29
    4684:	cf 91       	pop	r28
    4686:	08 95       	ret

00004688 <incrementPot>:

void incrementPot(){
    4688:	cf 93       	push	r28
    468a:	df 93       	push	r29
    468c:	cd b7       	in	r28, 0x3d	; 61
    468e:	de b7       	in	r29, 0x3e	; 62
	SPIsendByte(0x0A);
    4690:	8a e0       	ldi	r24, 0x0A	; 10
    4692:	90 e0       	ldi	r25, 0x00	; 0
    4694:	0e 94 43 24 	call	0x4886	; 0x4886 <SPIsendByte>
}
    4698:	df 91       	pop	r29
    469a:	cf 91       	pop	r28
    469c:	08 95       	ret

0000469e <getSpeed>:

//get the speed of the vehicle
char getSpeed(char* sensorResponse) {
    469e:	cf 93       	push	r28
    46a0:	df 93       	push	r29
    46a2:	1f 92       	push	r1
    46a4:	1f 92       	push	r1
    46a6:	cd b7       	in	r28, 0x3d	; 61
    46a8:	de b7       	in	r29, 0x3e	; 62
    46aa:	9a 83       	std	Y+2, r25	; 0x02
    46ac:	89 83       	std	Y+1, r24	; 0x01
   //store dummy speed value
   *sensorResponse = 0;
    46ae:	89 81       	ldd	r24, Y+1	; 0x01
    46b0:	9a 81       	ldd	r25, Y+2	; 0x02
    46b2:	fc 01       	movw	r30, r24
    46b4:	10 82       	st	Z, r1
   //return success
   return 1;
    46b6:	81 e0       	ldi	r24, 0x01	; 1
}
    46b8:	0f 90       	pop	r0
    46ba:	0f 90       	pop	r0
    46bc:	df 91       	pop	r29
    46be:	cf 91       	pop	r28
    46c0:	08 95       	ret

000046c2 <setSpeed>:

//will set just the speed of the wheels of the car
char setSpeed(unsigned char speedTarget) {
    46c2:	cf 93       	push	r28
    46c4:	df 93       	push	r29
    46c6:	1f 92       	push	r1
    46c8:	cd b7       	in	r28, 0x3d	; 61
    46ca:	de b7       	in	r29, 0x3e	; 62
    46cc:	89 83       	std	Y+1, r24	; 0x01
   //nothing done down here
   //return success
	if(speedTarget == 0){
    46ce:	89 81       	ldd	r24, Y+1	; 0x01
    46d0:	88 23       	and	r24, r24
    46d2:	51 f4       	brne	.+20     	; 0x46e8 <setSpeed+0x26>
		PORTA &= ~4;
    46d4:	82 e2       	ldi	r24, 0x22	; 34
    46d6:	90 e0       	ldi	r25, 0x00	; 0
    46d8:	22 e2       	ldi	r18, 0x22	; 34
    46da:	30 e0       	ldi	r19, 0x00	; 0
    46dc:	f9 01       	movw	r30, r18
    46de:	20 81       	ld	r18, Z
    46e0:	2b 7f       	andi	r18, 0xFB	; 251
    46e2:	fc 01       	movw	r30, r24
    46e4:	20 83       	st	Z, r18
    46e6:	09 c0       	rjmp	.+18     	; 0x46fa <setSpeed+0x38>
	} else {
		PORTA |= 4;
    46e8:	82 e2       	ldi	r24, 0x22	; 34
    46ea:	90 e0       	ldi	r25, 0x00	; 0
    46ec:	22 e2       	ldi	r18, 0x22	; 34
    46ee:	30 e0       	ldi	r19, 0x00	; 0
    46f0:	f9 01       	movw	r30, r18
    46f2:	20 81       	ld	r18, Z
    46f4:	24 60       	ori	r18, 0x04	; 4
    46f6:	fc 01       	movw	r30, r24
    46f8:	20 83       	st	Z, r18
	}
	setPot(speedTarget);
    46fa:	89 81       	ldd	r24, Y+1	; 0x01
    46fc:	88 2f       	mov	r24, r24
    46fe:	90 e0       	ldi	r25, 0x00	; 0
    4700:	0e 94 1f 23 	call	0x463e	; 0x463e <setPot>
   return 1;
    4704:	81 e0       	ldi	r24, 0x01	; 1
}
    4706:	0f 90       	pop	r0
    4708:	df 91       	pop	r29
    470a:	cf 91       	pop	r28
    470c:	08 95       	ret

0000470e <setAngle>:

//Steering group

//JUST SETS ANGLE TARGET. Actual angle changing is lower level
char setAngle(char angleTarget) {
    470e:	cf 93       	push	r28
    4710:	df 93       	push	r29
    4712:	1f 92       	push	r1
    4714:	cd b7       	in	r28, 0x3d	; 61
    4716:	de b7       	in	r29, 0x3e	; 62
    4718:	89 83       	std	Y+1, r24	; 0x01
   //dummy function, nothing will happen for now...
   //return success
   return 1;
    471a:	81 e0       	ldi	r24, 0x01	; 1
}
    471c:	0f 90       	pop	r0
    471e:	df 91       	pop	r29
    4720:	cf 91       	pop	r28
    4722:	08 95       	ret

00004724 <getAngle>:

//get the current angle of the steering system
char getAngle(char* sensorResponse) {
    4724:	cf 93       	push	r28
    4726:	df 93       	push	r29
    4728:	1f 92       	push	r1
    472a:	1f 92       	push	r1
    472c:	cd b7       	in	r28, 0x3d	; 61
    472e:	de b7       	in	r29, 0x3e	; 62
    4730:	9a 83       	std	Y+2, r25	; 0x02
    4732:	89 83       	std	Y+1, r24	; 0x01
   //store fake angle reading
   *sensorResponse = 0;
    4734:	89 81       	ldd	r24, Y+1	; 0x01
    4736:	9a 81       	ldd	r25, Y+2	; 0x02
    4738:	fc 01       	movw	r30, r24
    473a:	10 82       	st	Z, r1
   //return success
   return 1;
    473c:	81 e0       	ldi	r24, 0x01	; 1
}
    473e:	0f 90       	pop	r0
    4740:	0f 90       	pop	r0
    4742:	df 91       	pop	r29
    4744:	cf 91       	pop	r28
    4746:	08 95       	ret

00004748 <getDesiredAngle>:

//get the angle target. argument name is sensorResponse for the sake of consistancy
char getDesiredAngle(char* sensorResponse) {
    4748:	cf 93       	push	r28
    474a:	df 93       	push	r29
    474c:	1f 92       	push	r1
    474e:	1f 92       	push	r1
    4750:	cd b7       	in	r28, 0x3d	; 61
    4752:	de b7       	in	r29, 0x3e	; 62
    4754:	9a 83       	std	Y+2, r25	; 0x02
    4756:	89 83       	std	Y+1, r24	; 0x01
   //fake response
   *sensorResponse = 0;
    4758:	89 81       	ldd	r24, Y+1	; 0x01
    475a:	9a 81       	ldd	r25, Y+2	; 0x02
    475c:	fc 01       	movw	r30, r24
    475e:	10 82       	st	Z, r1
   //return success
   return 1;
    4760:	81 e0       	ldi	r24, 0x01	; 1
}
    4762:	0f 90       	pop	r0
    4764:	0f 90       	pop	r0
    4766:	df 91       	pop	r29
    4768:	cf 91       	pop	r28
    476a:	08 95       	ret

0000476c <changePID>:

//change the PID controller
char changePID(char P, char I, char D) {
    476c:	cf 93       	push	r28
    476e:	df 93       	push	r29
    4770:	00 d0       	rcall	.+0      	; 0x4772 <changePID+0x6>
    4772:	cd b7       	in	r28, 0x3d	; 61
    4774:	de b7       	in	r29, 0x3e	; 62
    4776:	89 83       	std	Y+1, r24	; 0x01
    4778:	6a 83       	std	Y+2, r22	; 0x02
    477a:	4b 83       	std	Y+3, r20	; 0x03
   //dummy function, nothing happens
   //return success
   return 1;
    477c:	81 e0       	ldi	r24, 0x01	; 1
}
    477e:	0f 90       	pop	r0
    4780:	0f 90       	pop	r0
    4782:	0f 90       	pop	r0
    4784:	df 91       	pop	r29
    4786:	cf 91       	pop	r28
    4788:	08 95       	ret

0000478a <setLimits>:

//not sure what this does. Also not sure why upper and lower are separated
//but its in the specs so...
char setLimits(char upper, char lower) {
    478a:	cf 93       	push	r28
    478c:	df 93       	push	r29
    478e:	1f 92       	push	r1
    4790:	1f 92       	push	r1
    4792:	cd b7       	in	r28, 0x3d	; 61
    4794:	de b7       	in	r29, 0x3e	; 62
    4796:	89 83       	std	Y+1, r24	; 0x01
    4798:	6a 83       	std	Y+2, r22	; 0x02
   //dummy function, nothing happens
   //return success
   return 1;
    479a:	81 e0       	ldi	r24, 0x01	; 1
}
    479c:	0f 90       	pop	r0
    479e:	0f 90       	pop	r0
    47a0:	df 91       	pop	r29
    47a2:	cf 91       	pop	r28
    47a4:	08 95       	ret

000047a6 <initializeSPI>:
const static int mosi_pin = 2;
const static int miso_pin = 3;
const static int sck_pin = 1;
const static int ss_pin = 0; 

void initializeSPI(){
    47a6:	cf 93       	push	r28
    47a8:	df 93       	push	r29
    47aa:	cd b7       	in	r28, 0x3d	; 61
    47ac:	de b7       	in	r29, 0x3e	; 62
	SPCR = (1 << SPE)|(1 << MSTR)|(1 << SPR1)|(1 << SPR0);
    47ae:	8c e4       	ldi	r24, 0x4C	; 76
    47b0:	90 e0       	ldi	r25, 0x00	; 0
    47b2:	23 e5       	ldi	r18, 0x53	; 83
    47b4:	fc 01       	movw	r30, r24
    47b6:	20 83       	st	Z, r18
	DDRB |= (1 << ss_pin)|(1 << sck_pin)|(1 << mosi_pin);
    47b8:	84 e2       	ldi	r24, 0x24	; 36
    47ba:	90 e0       	ldi	r25, 0x00	; 0
    47bc:	24 e2       	ldi	r18, 0x24	; 36
    47be:	30 e0       	ldi	r19, 0x00	; 0
    47c0:	f9 01       	movw	r30, r18
    47c2:	20 81       	ld	r18, Z
    47c4:	62 2f       	mov	r22, r18
    47c6:	40 e0       	ldi	r20, 0x00	; 0
    47c8:	50 e0       	ldi	r21, 0x00	; 0
    47ca:	21 e0       	ldi	r18, 0x01	; 1
    47cc:	30 e0       	ldi	r19, 0x00	; 0
    47ce:	02 c0       	rjmp	.+4      	; 0x47d4 <initializeSPI+0x2e>
    47d0:	22 0f       	add	r18, r18
    47d2:	33 1f       	adc	r19, r19
    47d4:	4a 95       	dec	r20
    47d6:	e2 f7       	brpl	.-8      	; 0x47d0 <initializeSPI+0x2a>
    47d8:	72 2f       	mov	r23, r18
    47da:	41 e0       	ldi	r20, 0x01	; 1
    47dc:	50 e0       	ldi	r21, 0x00	; 0
    47de:	21 e0       	ldi	r18, 0x01	; 1
    47e0:	30 e0       	ldi	r19, 0x00	; 0
    47e2:	02 c0       	rjmp	.+4      	; 0x47e8 <initializeSPI+0x42>
    47e4:	22 0f       	add	r18, r18
    47e6:	33 1f       	adc	r19, r19
    47e8:	4a 95       	dec	r20
    47ea:	e2 f7       	brpl	.-8      	; 0x47e4 <initializeSPI+0x3e>
    47ec:	72 2b       	or	r23, r18
    47ee:	42 e0       	ldi	r20, 0x02	; 2
    47f0:	50 e0       	ldi	r21, 0x00	; 0
    47f2:	21 e0       	ldi	r18, 0x01	; 1
    47f4:	30 e0       	ldi	r19, 0x00	; 0
    47f6:	02 c0       	rjmp	.+4      	; 0x47fc <initializeSPI+0x56>
    47f8:	22 0f       	add	r18, r18
    47fa:	33 1f       	adc	r19, r19
    47fc:	4a 95       	dec	r20
    47fe:	e2 f7       	brpl	.-8      	; 0x47f8 <initializeSPI+0x52>
    4800:	27 2b       	or	r18, r23
    4802:	26 2b       	or	r18, r22
    4804:	fc 01       	movw	r30, r24
    4806:	20 83       	st	Z, r18
	DDRB &= ~(1 << miso_pin);
    4808:	84 e2       	ldi	r24, 0x24	; 36
    480a:	90 e0       	ldi	r25, 0x00	; 0
    480c:	24 e2       	ldi	r18, 0x24	; 36
    480e:	30 e0       	ldi	r19, 0x00	; 0
    4810:	f9 01       	movw	r30, r18
    4812:	20 81       	ld	r18, Z
    4814:	62 2f       	mov	r22, r18
    4816:	43 e0       	ldi	r20, 0x03	; 3
    4818:	50 e0       	ldi	r21, 0x00	; 0
    481a:	21 e0       	ldi	r18, 0x01	; 1
    481c:	30 e0       	ldi	r19, 0x00	; 0
    481e:	02 c0       	rjmp	.+4      	; 0x4824 <initializeSPI+0x7e>
    4820:	22 0f       	add	r18, r18
    4822:	33 1f       	adc	r19, r19
    4824:	4a 95       	dec	r20
    4826:	e2 f7       	brpl	.-8      	; 0x4820 <initializeSPI+0x7a>
    4828:	20 95       	com	r18
    482a:	26 23       	and	r18, r22
    482c:	fc 01       	movw	r30, r24
    482e:	20 83       	st	Z, r18
	PORTB |= 1 << ss_pin;
    4830:	85 e2       	ldi	r24, 0x25	; 37
    4832:	90 e0       	ldi	r25, 0x00	; 0
    4834:	25 e2       	ldi	r18, 0x25	; 37
    4836:	30 e0       	ldi	r19, 0x00	; 0
    4838:	f9 01       	movw	r30, r18
    483a:	20 81       	ld	r18, Z
    483c:	62 2f       	mov	r22, r18
    483e:	40 e0       	ldi	r20, 0x00	; 0
    4840:	50 e0       	ldi	r21, 0x00	; 0
    4842:	21 e0       	ldi	r18, 0x01	; 1
    4844:	30 e0       	ldi	r19, 0x00	; 0
    4846:	02 c0       	rjmp	.+4      	; 0x484c <initializeSPI+0xa6>
    4848:	22 0f       	add	r18, r18
    484a:	33 1f       	adc	r19, r19
    484c:	4a 95       	dec	r20
    484e:	e2 f7       	brpl	.-8      	; 0x4848 <initializeSPI+0xa2>
    4850:	26 2b       	or	r18, r22
    4852:	fc 01       	movw	r30, r24
    4854:	20 83       	st	Z, r18
	PORTB &= ~(1 << sck_pin);
    4856:	85 e2       	ldi	r24, 0x25	; 37
    4858:	90 e0       	ldi	r25, 0x00	; 0
    485a:	25 e2       	ldi	r18, 0x25	; 37
    485c:	30 e0       	ldi	r19, 0x00	; 0
    485e:	f9 01       	movw	r30, r18
    4860:	20 81       	ld	r18, Z
    4862:	62 2f       	mov	r22, r18
    4864:	41 e0       	ldi	r20, 0x01	; 1
    4866:	50 e0       	ldi	r21, 0x00	; 0
    4868:	21 e0       	ldi	r18, 0x01	; 1
    486a:	30 e0       	ldi	r19, 0x00	; 0
    486c:	04 2e       	mov	r0, r20
    486e:	02 c0       	rjmp	.+4      	; 0x4874 <initializeSPI+0xce>
    4870:	22 0f       	add	r18, r18
    4872:	33 1f       	adc	r19, r19
    4874:	0a 94       	dec	r0
    4876:	e2 f7       	brpl	.-8      	; 0x4870 <initializeSPI+0xca>
    4878:	20 95       	com	r18
    487a:	26 23       	and	r18, r22
    487c:	fc 01       	movw	r30, r24
    487e:	20 83       	st	Z, r18
}
    4880:	df 91       	pop	r29
    4882:	cf 91       	pop	r28
    4884:	08 95       	ret

00004886 <SPIsendByte>:

void SPIsendByte(unsigned char byte){
    4886:	cf 93       	push	r28
    4888:	df 93       	push	r29
    488a:	1f 92       	push	r1
    488c:	cd b7       	in	r28, 0x3d	; 61
    488e:	de b7       	in	r29, 0x3e	; 62
    4890:	89 83       	std	Y+1, r24	; 0x01
	PORTB &= ~(1 << ss_pin);
    4892:	85 e2       	ldi	r24, 0x25	; 37
    4894:	90 e0       	ldi	r25, 0x00	; 0
    4896:	25 e2       	ldi	r18, 0x25	; 37
    4898:	30 e0       	ldi	r19, 0x00	; 0
    489a:	f9 01       	movw	r30, r18
    489c:	20 81       	ld	r18, Z
    489e:	62 2f       	mov	r22, r18
    48a0:	40 e0       	ldi	r20, 0x00	; 0
    48a2:	50 e0       	ldi	r21, 0x00	; 0
    48a4:	21 e0       	ldi	r18, 0x01	; 1
    48a6:	30 e0       	ldi	r19, 0x00	; 0
    48a8:	02 c0       	rjmp	.+4      	; 0x48ae <SPIsendByte+0x28>
    48aa:	22 0f       	add	r18, r18
    48ac:	33 1f       	adc	r19, r19
    48ae:	4a 95       	dec	r20
    48b0:	e2 f7       	brpl	.-8      	; 0x48aa <SPIsendByte+0x24>
    48b2:	20 95       	com	r18
    48b4:	26 23       	and	r18, r22
    48b6:	fc 01       	movw	r30, r24
    48b8:	20 83       	st	Z, r18
	vTaskDelay(1);
    48ba:	81 e0       	ldi	r24, 0x01	; 1
    48bc:	90 e0       	ldi	r25, 0x00	; 0
    48be:	0e 94 ca 04 	call	0x994	; 0x994 <vTaskDelay>
	SPDR = byte;
    48c2:	8e e4       	ldi	r24, 0x4E	; 78
    48c4:	90 e0       	ldi	r25, 0x00	; 0
    48c6:	29 81       	ldd	r18, Y+1	; 0x01
    48c8:	fc 01       	movw	r30, r24
    48ca:	20 83       	st	Z, r18
	while((SPSR & (1 << SPIF)) == 0)
    48cc:	00 00       	nop
    48ce:	8d e4       	ldi	r24, 0x4D	; 77
    48d0:	90 e0       	ldi	r25, 0x00	; 0
    48d2:	fc 01       	movw	r30, r24
    48d4:	80 81       	ld	r24, Z
    48d6:	88 23       	and	r24, r24
    48d8:	d4 f7       	brge	.-12     	; 0x48ce <SPIsendByte+0x48>
	;
	vTaskDelay(1);
    48da:	81 e0       	ldi	r24, 0x01	; 1
    48dc:	90 e0       	ldi	r25, 0x00	; 0
    48de:	0e 94 ca 04 	call	0x994	; 0x994 <vTaskDelay>
	PORTB |= (1 << ss_pin);
    48e2:	85 e2       	ldi	r24, 0x25	; 37
    48e4:	90 e0       	ldi	r25, 0x00	; 0
    48e6:	25 e2       	ldi	r18, 0x25	; 37
    48e8:	30 e0       	ldi	r19, 0x00	; 0
    48ea:	f9 01       	movw	r30, r18
    48ec:	20 81       	ld	r18, Z
    48ee:	62 2f       	mov	r22, r18
    48f0:	40 e0       	ldi	r20, 0x00	; 0
    48f2:	50 e0       	ldi	r21, 0x00	; 0
    48f4:	21 e0       	ldi	r18, 0x01	; 1
    48f6:	30 e0       	ldi	r19, 0x00	; 0
    48f8:	04 2e       	mov	r0, r20
    48fa:	02 c0       	rjmp	.+4      	; 0x4900 <SPIsendByte+0x7a>
    48fc:	22 0f       	add	r18, r18
    48fe:	33 1f       	adc	r19, r19
    4900:	0a 94       	dec	r0
    4902:	e2 f7       	brpl	.-8      	; 0x48fc <SPIsendByte+0x76>
    4904:	26 2b       	or	r18, r22
    4906:	fc 01       	movw	r30, r24
    4908:	20 83       	st	Z, r18

}
    490a:	0f 90       	pop	r0
    490c:	df 91       	pop	r29
    490e:	cf 91       	pop	r28
    4910:	08 95       	ret

00004912 <SPIsendShort>:

void SPIsendShort(unsigned short data){
    4912:	cf 93       	push	r28
    4914:	df 93       	push	r29
    4916:	1f 92       	push	r1
    4918:	1f 92       	push	r1
    491a:	cd b7       	in	r28, 0x3d	; 61
    491c:	de b7       	in	r29, 0x3e	; 62
    491e:	9a 83       	std	Y+2, r25	; 0x02
    4920:	89 83       	std	Y+1, r24	; 0x01
	PORTB &= ~(1 << ss_pin);
    4922:	85 e2       	ldi	r24, 0x25	; 37
    4924:	90 e0       	ldi	r25, 0x00	; 0
    4926:	25 e2       	ldi	r18, 0x25	; 37
    4928:	30 e0       	ldi	r19, 0x00	; 0
    492a:	f9 01       	movw	r30, r18
    492c:	20 81       	ld	r18, Z
    492e:	62 2f       	mov	r22, r18
    4930:	40 e0       	ldi	r20, 0x00	; 0
    4932:	50 e0       	ldi	r21, 0x00	; 0
    4934:	21 e0       	ldi	r18, 0x01	; 1
    4936:	30 e0       	ldi	r19, 0x00	; 0
    4938:	02 c0       	rjmp	.+4      	; 0x493e <SPIsendShort+0x2c>
    493a:	22 0f       	add	r18, r18
    493c:	33 1f       	adc	r19, r19
    493e:	4a 95       	dec	r20
    4940:	e2 f7       	brpl	.-8      	; 0x493a <SPIsendShort+0x28>
    4942:	20 95       	com	r18
    4944:	26 23       	and	r18, r22
    4946:	fc 01       	movw	r30, r24
    4948:	20 83       	st	Z, r18
	vTaskDelay(2);
    494a:	82 e0       	ldi	r24, 0x02	; 2
    494c:	90 e0       	ldi	r25, 0x00	; 0
    494e:	0e 94 ca 04 	call	0x994	; 0x994 <vTaskDelay>
	SPDR = (data >> 8);
    4952:	8e e4       	ldi	r24, 0x4E	; 78
    4954:	90 e0       	ldi	r25, 0x00	; 0
    4956:	29 81       	ldd	r18, Y+1	; 0x01
    4958:	3a 81       	ldd	r19, Y+2	; 0x02
    495a:	23 2f       	mov	r18, r19
    495c:	33 27       	eor	r19, r19
    495e:	fc 01       	movw	r30, r24
    4960:	20 83       	st	Z, r18
	while((SPSR & (1 << SPIF)) == 0)
    4962:	00 00       	nop
    4964:	8d e4       	ldi	r24, 0x4D	; 77
    4966:	90 e0       	ldi	r25, 0x00	; 0
    4968:	fc 01       	movw	r30, r24
    496a:	80 81       	ld	r24, Z
    496c:	88 23       	and	r24, r24
    496e:	d4 f7       	brge	.-12     	; 0x4964 <SPIsendShort+0x52>
	;
	SPDR = data & 0xFF;
    4970:	8e e4       	ldi	r24, 0x4E	; 78
    4972:	90 e0       	ldi	r25, 0x00	; 0
    4974:	29 81       	ldd	r18, Y+1	; 0x01
    4976:	fc 01       	movw	r30, r24
    4978:	20 83       	st	Z, r18
	while((SPSR & (1 << SPIF)) == 0)
    497a:	00 00       	nop
    497c:	8d e4       	ldi	r24, 0x4D	; 77
    497e:	90 e0       	ldi	r25, 0x00	; 0
    4980:	fc 01       	movw	r30, r24
    4982:	80 81       	ld	r24, Z
    4984:	88 23       	and	r24, r24
    4986:	d4 f7       	brge	.-12     	; 0x497c <SPIsendShort+0x6a>
	;
	vTaskDelay(2);
    4988:	82 e0       	ldi	r24, 0x02	; 2
    498a:	90 e0       	ldi	r25, 0x00	; 0
    498c:	0e 94 ca 04 	call	0x994	; 0x994 <vTaskDelay>
	PORTB |= (1 << ss_pin);
    4990:	85 e2       	ldi	r24, 0x25	; 37
    4992:	90 e0       	ldi	r25, 0x00	; 0
    4994:	25 e2       	ldi	r18, 0x25	; 37
    4996:	30 e0       	ldi	r19, 0x00	; 0
    4998:	f9 01       	movw	r30, r18
    499a:	20 81       	ld	r18, Z
    499c:	62 2f       	mov	r22, r18
    499e:	40 e0       	ldi	r20, 0x00	; 0
    49a0:	50 e0       	ldi	r21, 0x00	; 0
    49a2:	21 e0       	ldi	r18, 0x01	; 1
    49a4:	30 e0       	ldi	r19, 0x00	; 0
    49a6:	04 2e       	mov	r0, r20
    49a8:	02 c0       	rjmp	.+4      	; 0x49ae <SPIsendShort+0x9c>
    49aa:	22 0f       	add	r18, r18
    49ac:	33 1f       	adc	r19, r19
    49ae:	0a 94       	dec	r0
    49b0:	e2 f7       	brpl	.-8      	; 0x49aa <SPIsendShort+0x98>
    49b2:	26 2b       	or	r18, r22
    49b4:	fc 01       	movw	r30, r24
    49b6:	20 83       	st	Z, r18
}
    49b8:	0f 90       	pop	r0
    49ba:	0f 90       	pop	r0
    49bc:	df 91       	pop	r29
    49be:	cf 91       	pop	r28
    49c0:	08 95       	ret

000049c2 <initADC>:
static ADCDevice devices[16];
static int currDevice = 0;
static int ADCinitialized = 0;

//Initialize ADC registers
void initADC(){
    49c2:	cf 93       	push	r28
    49c4:	df 93       	push	r29
    49c6:	cd b7       	in	r28, 0x3d	; 61
    49c8:	de b7       	in	r29, 0x3e	; 62
	ADCSRA = _BV(ADEN);
    49ca:	8a e7       	ldi	r24, 0x7A	; 122
    49cc:	90 e0       	ldi	r25, 0x00	; 0
    49ce:	20 e8       	ldi	r18, 0x80	; 128
    49d0:	fc 01       	movw	r30, r24
    49d2:	20 83       	st	Z, r18
	ADMUX = _BV(REFS0)|(1);
    49d4:	8c e7       	ldi	r24, 0x7C	; 124
    49d6:	90 e0       	ldi	r25, 0x00	; 0
    49d8:	21 e4       	ldi	r18, 0x41	; 65
    49da:	fc 01       	movw	r30, r24
    49dc:	20 83       	st	Z, r18

	ADCSRB = (1 << MUX5);
    49de:	8b e7       	ldi	r24, 0x7B	; 123
    49e0:	90 e0       	ldi	r25, 0x00	; 0
    49e2:	28 e0       	ldi	r18, 0x08	; 8
    49e4:	fc 01       	movw	r30, r24
    49e6:	20 83       	st	Z, r18
	
	//DIDR2 = 0xFF;
}
    49e8:	df 91       	pop	r29
    49ea:	cf 91       	pop	r28
    49ec:	08 95       	ret

000049ee <ADCStart>:

//If the ADC isn't running, start it
void ADCStart(ADCDevice* nextDevice) {
    49ee:	cf 93       	push	r28
    49f0:	df 93       	push	r29
    49f2:	1f 92       	push	r1
    49f4:	1f 92       	push	r1
    49f6:	cd b7       	in	r28, 0x3d	; 61
    49f8:	de b7       	in	r29, 0x3e	; 62
    49fa:	9a 83       	std	Y+2, r25	; 0x02
    49fc:	89 83       	std	Y+1, r24	; 0x01

		
	if(!(ADCSRA & _BV(ADSC))){
    49fe:	8a e7       	ldi	r24, 0x7A	; 122
    4a00:	90 e0       	ldi	r25, 0x00	; 0
    4a02:	fc 01       	movw	r30, r24
    4a04:	80 81       	ld	r24, Z
    4a06:	88 2f       	mov	r24, r24
    4a08:	90 e0       	ldi	r25, 0x00	; 0
    4a0a:	80 74       	andi	r24, 0x40	; 64
    4a0c:	99 27       	eor	r25, r25
    4a0e:	00 97       	sbiw	r24, 0x00	; 0
    4a10:	09 f0       	breq	.+2      	; 0x4a14 <ADCStart+0x26>
    4a12:	90 c0       	rjmp	.+288    	; 0x4b34 <ADCStart+0x146>
		ADCSRA &= ~((1 << ADPS2)|(1 << ADPS1)|(1 << ADPS0));
    4a14:	8a e7       	ldi	r24, 0x7A	; 122
    4a16:	90 e0       	ldi	r25, 0x00	; 0
    4a18:	2a e7       	ldi	r18, 0x7A	; 122
    4a1a:	30 e0       	ldi	r19, 0x00	; 0
    4a1c:	f9 01       	movw	r30, r18
    4a1e:	20 81       	ld	r18, Z
    4a20:	28 7f       	andi	r18, 0xF8	; 248
    4a22:	fc 01       	movw	r30, r24
    4a24:	20 83       	st	Z, r18
		switch(nextDevice->options & ADC_OPT_PRECISION_MASK){
    4a26:	89 81       	ldd	r24, Y+1	; 0x01
    4a28:	9a 81       	ldd	r25, Y+2	; 0x02
    4a2a:	fc 01       	movw	r30, r24
    4a2c:	82 81       	ldd	r24, Z+2	; 0x02
    4a2e:	93 81       	ldd	r25, Z+3	; 0x03
    4a30:	83 70       	andi	r24, 0x03	; 3
    4a32:	99 27       	eor	r25, r25
    4a34:	81 30       	cpi	r24, 0x01	; 1
    4a36:	91 05       	cpc	r25, r1
    4a38:	a1 f0       	breq	.+40     	; 0x4a62 <ADCStart+0x74>
    4a3a:	82 30       	cpi	r24, 0x02	; 2
    4a3c:	91 05       	cpc	r25, r1
    4a3e:	1c f4       	brge	.+6      	; 0x4a46 <ADCStart+0x58>
    4a40:	00 97       	sbiw	r24, 0x00	; 0
    4a42:	29 f0       	breq	.+10     	; 0x4a4e <ADCStart+0x60>
    4a44:	22 c0       	rjmp	.+68     	; 0x4a8a <ADCStart+0x9c>
    4a46:	82 30       	cpi	r24, 0x02	; 2
    4a48:	91 05       	cpc	r25, r1
    4a4a:	a9 f0       	breq	.+42     	; 0x4a76 <ADCStart+0x88>
			break;
		case ADC_OPT_PRECISION_MED:
			ADCSRA |= (1 << ADPS1)|(1 << ADPS0);
			break;
		case ADC_OPT_PRECISION_LOW:
			break;
    4a4c:	1e c0       	rjmp	.+60     	; 0x4a8a <ADCStart+0x9c>
		
	if(!(ADCSRA & _BV(ADSC))){
		ADCSRA &= ~((1 << ADPS2)|(1 << ADPS1)|(1 << ADPS0));
		switch(nextDevice->options & ADC_OPT_PRECISION_MASK){
		case ADC_OPT_PRECISION_HIGH:
			ADCSRA |= (1 << ADPS2)|(1 << ADPS1)|(1 << ADPS0);
    4a4e:	8a e7       	ldi	r24, 0x7A	; 122
    4a50:	90 e0       	ldi	r25, 0x00	; 0
    4a52:	2a e7       	ldi	r18, 0x7A	; 122
    4a54:	30 e0       	ldi	r19, 0x00	; 0
    4a56:	f9 01       	movw	r30, r18
    4a58:	20 81       	ld	r18, Z
    4a5a:	27 60       	ori	r18, 0x07	; 7
    4a5c:	fc 01       	movw	r30, r24
    4a5e:	20 83       	st	Z, r18
			break;
    4a60:	14 c0       	rjmp	.+40     	; 0x4a8a <ADCStart+0x9c>
		case ADC_OPT_PRECISION_MED_HIGH:
			ADCSRA |= (1 << ADPS2)|(1 << ADPS0);
    4a62:	8a e7       	ldi	r24, 0x7A	; 122
    4a64:	90 e0       	ldi	r25, 0x00	; 0
    4a66:	2a e7       	ldi	r18, 0x7A	; 122
    4a68:	30 e0       	ldi	r19, 0x00	; 0
    4a6a:	f9 01       	movw	r30, r18
    4a6c:	20 81       	ld	r18, Z
    4a6e:	25 60       	ori	r18, 0x05	; 5
    4a70:	fc 01       	movw	r30, r24
    4a72:	20 83       	st	Z, r18
			break;
    4a74:	0a c0       	rjmp	.+20     	; 0x4a8a <ADCStart+0x9c>
		case ADC_OPT_PRECISION_MED:
			ADCSRA |= (1 << ADPS1)|(1 << ADPS0);
    4a76:	8a e7       	ldi	r24, 0x7A	; 122
    4a78:	90 e0       	ldi	r25, 0x00	; 0
    4a7a:	2a e7       	ldi	r18, 0x7A	; 122
    4a7c:	30 e0       	ldi	r19, 0x00	; 0
    4a7e:	f9 01       	movw	r30, r18
    4a80:	20 81       	ld	r18, Z
    4a82:	23 60       	ori	r18, 0x03	; 3
    4a84:	fc 01       	movw	r30, r24
    4a86:	20 83       	st	Z, r18
			break;
    4a88:	00 00       	nop
		case ADC_OPT_PRECISION_LOW:
			break;
		}
		ADMUX &= ~((1 << MUX0)|(1 << MUX1)|(1 << MUX2)|(1 << MUX3));
    4a8a:	8c e7       	ldi	r24, 0x7C	; 124
    4a8c:	90 e0       	ldi	r25, 0x00	; 0
    4a8e:	2c e7       	ldi	r18, 0x7C	; 124
    4a90:	30 e0       	ldi	r19, 0x00	; 0
    4a92:	f9 01       	movw	r30, r18
    4a94:	20 81       	ld	r18, Z
    4a96:	20 7f       	andi	r18, 0xF0	; 240
    4a98:	fc 01       	movw	r30, r24
    4a9a:	20 83       	st	Z, r18
		if(nextDevice->port < 8){
    4a9c:	89 81       	ldd	r24, Y+1	; 0x01
    4a9e:	9a 81       	ldd	r25, Y+2	; 0x02
    4aa0:	fc 01       	movw	r30, r24
    4aa2:	80 81       	ld	r24, Z
    4aa4:	91 81       	ldd	r25, Z+1	; 0x01
    4aa6:	88 30       	cpi	r24, 0x08	; 8
    4aa8:	91 05       	cpc	r25, r1
    4aaa:	cc f4       	brge	.+50     	; 0x4ade <ADCStart+0xf0>
			ADCSRB &= ~(1 << MUX5);
    4aac:	8b e7       	ldi	r24, 0x7B	; 123
    4aae:	90 e0       	ldi	r25, 0x00	; 0
    4ab0:	2b e7       	ldi	r18, 0x7B	; 123
    4ab2:	30 e0       	ldi	r19, 0x00	; 0
    4ab4:	f9 01       	movw	r30, r18
    4ab6:	20 81       	ld	r18, Z
    4ab8:	27 7f       	andi	r18, 0xF7	; 247
    4aba:	fc 01       	movw	r30, r24
    4abc:	20 83       	st	Z, r18
			ADMUX |= nextDevice->port;
    4abe:	8c e7       	ldi	r24, 0x7C	; 124
    4ac0:	90 e0       	ldi	r25, 0x00	; 0
    4ac2:	2c e7       	ldi	r18, 0x7C	; 124
    4ac4:	30 e0       	ldi	r19, 0x00	; 0
    4ac6:	f9 01       	movw	r30, r18
    4ac8:	20 81       	ld	r18, Z
    4aca:	42 2f       	mov	r20, r18
    4acc:	29 81       	ldd	r18, Y+1	; 0x01
    4ace:	3a 81       	ldd	r19, Y+2	; 0x02
    4ad0:	f9 01       	movw	r30, r18
    4ad2:	20 81       	ld	r18, Z
    4ad4:	31 81       	ldd	r19, Z+1	; 0x01
    4ad6:	24 2b       	or	r18, r20
    4ad8:	fc 01       	movw	r30, r24
    4ada:	20 83       	st	Z, r18
    4adc:	19 c0       	rjmp	.+50     	; 0x4b10 <ADCStart+0x122>
		} else {
			ADCSRB |= (1 << MUX5);
    4ade:	8b e7       	ldi	r24, 0x7B	; 123
    4ae0:	90 e0       	ldi	r25, 0x00	; 0
    4ae2:	2b e7       	ldi	r18, 0x7B	; 123
    4ae4:	30 e0       	ldi	r19, 0x00	; 0
    4ae6:	f9 01       	movw	r30, r18
    4ae8:	20 81       	ld	r18, Z
    4aea:	28 60       	ori	r18, 0x08	; 8
    4aec:	fc 01       	movw	r30, r24
    4aee:	20 83       	st	Z, r18
			ADMUX |= nextDevice->port - 8;
    4af0:	8c e7       	ldi	r24, 0x7C	; 124
    4af2:	90 e0       	ldi	r25, 0x00	; 0
    4af4:	2c e7       	ldi	r18, 0x7C	; 124
    4af6:	30 e0       	ldi	r19, 0x00	; 0
    4af8:	f9 01       	movw	r30, r18
    4afa:	20 81       	ld	r18, Z
    4afc:	42 2f       	mov	r20, r18
    4afe:	29 81       	ldd	r18, Y+1	; 0x01
    4b00:	3a 81       	ldd	r19, Y+2	; 0x02
    4b02:	f9 01       	movw	r30, r18
    4b04:	20 81       	ld	r18, Z
    4b06:	31 81       	ldd	r19, Z+1	; 0x01
    4b08:	28 50       	subi	r18, 0x08	; 8
    4b0a:	24 2b       	or	r18, r20
    4b0c:	fc 01       	movw	r30, r24
    4b0e:	20 83       	st	Z, r18
		}
		
		ADCSRA |= _BV(ADIE);
    4b10:	8a e7       	ldi	r24, 0x7A	; 122
    4b12:	90 e0       	ldi	r25, 0x00	; 0
    4b14:	2a e7       	ldi	r18, 0x7A	; 122
    4b16:	30 e0       	ldi	r19, 0x00	; 0
    4b18:	f9 01       	movw	r30, r18
    4b1a:	20 81       	ld	r18, Z
    4b1c:	28 60       	ori	r18, 0x08	; 8
    4b1e:	fc 01       	movw	r30, r24
    4b20:	20 83       	st	Z, r18
		ADCSRA |= _BV(ADSC);
    4b22:	8a e7       	ldi	r24, 0x7A	; 122
    4b24:	90 e0       	ldi	r25, 0x00	; 0
    4b26:	2a e7       	ldi	r18, 0x7A	; 122
    4b28:	30 e0       	ldi	r19, 0x00	; 0
    4b2a:	f9 01       	movw	r30, r18
    4b2c:	20 81       	ld	r18, Z
    4b2e:	20 64       	ori	r18, 0x40	; 64
    4b30:	fc 01       	movw	r30, r24
    4b32:	20 83       	st	Z, r18
	}
}
    4b34:	0f 90       	pop	r0
    4b36:	0f 90       	pop	r0
    4b38:	df 91       	pop	r29
    4b3a:	cf 91       	pop	r28
    4b3c:	08 95       	ret

00004b3e <__vector_29>:

//Read the finished value of the ADC and store it
ISR(ADC_vect) {
    4b3e:	1f 92       	push	r1
    4b40:	0f 92       	push	r0
    4b42:	00 90 5f 00 	lds	r0, 0x005F
    4b46:	0f 92       	push	r0
    4b48:	11 24       	eor	r1, r1
    4b4a:	00 90 5b 00 	lds	r0, 0x005B
    4b4e:	0f 92       	push	r0
    4b50:	2f 93       	push	r18
    4b52:	3f 93       	push	r19
    4b54:	4f 93       	push	r20
    4b56:	5f 93       	push	r21
    4b58:	6f 93       	push	r22
    4b5a:	7f 93       	push	r23
    4b5c:	8f 93       	push	r24
    4b5e:	9f 93       	push	r25
    4b60:	af 93       	push	r26
    4b62:	bf 93       	push	r27
    4b64:	ef 93       	push	r30
    4b66:	ff 93       	push	r31
    4b68:	cf 93       	push	r28
    4b6a:	df 93       	push	r29
    4b6c:	00 d0       	rcall	.+0      	; 0x4b6e <__vector_29+0x30>
    4b6e:	00 d0       	rcall	.+0      	; 0x4b70 <__vector_29+0x32>
    4b70:	cd b7       	in	r28, 0x3d	; 61
    4b72:	de b7       	in	r29, 0x3e	; 62
	int result = ADCL;
    4b74:	88 e7       	ldi	r24, 0x78	; 120
    4b76:	90 e0       	ldi	r25, 0x00	; 0
    4b78:	fc 01       	movw	r30, r24
    4b7a:	80 81       	ld	r24, Z
    4b7c:	88 2f       	mov	r24, r24
    4b7e:	90 e0       	ldi	r25, 0x00	; 0
    4b80:	9a 83       	std	Y+2, r25	; 0x02
    4b82:	89 83       	std	Y+1, r24	; 0x01
	result |= (ADCH << 8);
    4b84:	89 e7       	ldi	r24, 0x79	; 121
    4b86:	90 e0       	ldi	r25, 0x00	; 0
    4b88:	fc 01       	movw	r30, r24
    4b8a:	80 81       	ld	r24, Z
    4b8c:	88 2f       	mov	r24, r24
    4b8e:	90 e0       	ldi	r25, 0x00	; 0
    4b90:	98 2f       	mov	r25, r24
    4b92:	88 27       	eor	r24, r24
    4b94:	29 81       	ldd	r18, Y+1	; 0x01
    4b96:	3a 81       	ldd	r19, Y+2	; 0x02
    4b98:	82 2b       	or	r24, r18
    4b9a:	93 2b       	or	r25, r19
    4b9c:	9a 83       	std	Y+2, r25	; 0x02
    4b9e:	89 83       	std	Y+1, r24	; 0x01
	
	ADCHandler handler = devices[currDevice].handler;
    4ba0:	80 91 51 1b 	lds	r24, 0x1B51
    4ba4:	90 91 52 1b 	lds	r25, 0x1B52
    4ba8:	88 0f       	add	r24, r24
    4baa:	99 1f       	adc	r25, r25
    4bac:	88 0f       	add	r24, r24
    4bae:	99 1f       	adc	r25, r25
    4bb0:	88 0f       	add	r24, r24
    4bb2:	99 1f       	adc	r25, r25
    4bb4:	89 52       	subi	r24, 0x29	; 41
    4bb6:	95 4e       	sbci	r25, 0xE5	; 229
    4bb8:	fc 01       	movw	r30, r24
    4bba:	80 81       	ld	r24, Z
    4bbc:	91 81       	ldd	r25, Z+1	; 0x01
    4bbe:	9c 83       	std	Y+4, r25	; 0x04
    4bc0:	8b 83       	std	Y+3, r24	; 0x03
	void *parameters = devices[currDevice].parameters;
    4bc2:	80 91 51 1b 	lds	r24, 0x1B51
    4bc6:	90 91 52 1b 	lds	r25, 0x1B52
    4bca:	88 0f       	add	r24, r24
    4bcc:	99 1f       	adc	r25, r25
    4bce:	88 0f       	add	r24, r24
    4bd0:	99 1f       	adc	r25, r25
    4bd2:	88 0f       	add	r24, r24
    4bd4:	99 1f       	adc	r25, r25
    4bd6:	8b 52       	subi	r24, 0x2B	; 43
    4bd8:	95 4e       	sbci	r25, 0xE5	; 229
    4bda:	fc 01       	movw	r30, r24
    4bdc:	80 81       	ld	r24, Z
    4bde:	91 81       	ldd	r25, Z+1	; 0x01
    4be0:	9e 83       	std	Y+6, r25	; 0x06
    4be2:	8d 83       	std	Y+5, r24	; 0x05
	
	handler(result,parameters);
    4be4:	4d 81       	ldd	r20, Y+5	; 0x05
    4be6:	5e 81       	ldd	r21, Y+6	; 0x06
    4be8:	89 81       	ldd	r24, Y+1	; 0x01
    4bea:	9a 81       	ldd	r25, Y+2	; 0x02
    4bec:	2b 81       	ldd	r18, Y+3	; 0x03
    4bee:	3c 81       	ldd	r19, Y+4	; 0x04
    4bf0:	ba 01       	movw	r22, r20
    4bf2:	f9 01       	movw	r30, r18
    4bf4:	19 95       	eicall
	
	ADCSRA &= ~(_BV(ADIE));
    4bf6:	8a e7       	ldi	r24, 0x7A	; 122
    4bf8:	90 e0       	ldi	r25, 0x00	; 0
    4bfa:	2a e7       	ldi	r18, 0x7A	; 122
    4bfc:	30 e0       	ldi	r19, 0x00	; 0
    4bfe:	f9 01       	movw	r30, r18
    4c00:	20 81       	ld	r18, Z
    4c02:	27 7f       	andi	r18, 0xF7	; 247
    4c04:	fc 01       	movw	r30, r24
    4c06:	20 83       	st	Z, r18
	
	xSemaphoreGiveFromISR(adcSemaphore,0);
    4c08:	80 91 cf 1a 	lds	r24, 0x1ACF
    4c0c:	90 91 d0 1a 	lds	r25, 0x1AD0
    4c10:	20 e0       	ldi	r18, 0x00	; 0
    4c12:	40 e0       	ldi	r20, 0x00	; 0
    4c14:	50 e0       	ldi	r21, 0x00	; 0
    4c16:	60 e0       	ldi	r22, 0x00	; 0
    4c18:	70 e0       	ldi	r23, 0x00	; 0
    4c1a:	0e 94 9d 0e 	call	0x1d3a	; 0x1d3a <xQueueGenericSendFromISR>
}
    4c1e:	26 96       	adiw	r28, 0x06	; 6
    4c20:	0f b6       	in	r0, 0x3f	; 63
    4c22:	f8 94       	cli
    4c24:	de bf       	out	0x3e, r29	; 62
    4c26:	0f be       	out	0x3f, r0	; 63
    4c28:	cd bf       	out	0x3d, r28	; 61
    4c2a:	df 91       	pop	r29
    4c2c:	cf 91       	pop	r28
    4c2e:	ff 91       	pop	r31
    4c30:	ef 91       	pop	r30
    4c32:	bf 91       	pop	r27
    4c34:	af 91       	pop	r26
    4c36:	9f 91       	pop	r25
    4c38:	8f 91       	pop	r24
    4c3a:	7f 91       	pop	r23
    4c3c:	6f 91       	pop	r22
    4c3e:	5f 91       	pop	r21
    4c40:	4f 91       	pop	r20
    4c42:	3f 91       	pop	r19
    4c44:	2f 91       	pop	r18
    4c46:	0f 90       	pop	r0
    4c48:	00 92 5b 00 	sts	0x005B, r0
    4c4c:	0f 90       	pop	r0
    4c4e:	00 92 5f 00 	sts	0x005F, r0
    4c52:	0f 90       	pop	r0
    4c54:	1f 90       	pop	r1
    4c56:	18 95       	reti

00004c58 <vTaskADC>:

void vTaskADC(void *parameters){
    4c58:	cf 93       	push	r28
    4c5a:	df 93       	push	r29
    4c5c:	00 d0       	rcall	.+0      	; 0x4c5e <vTaskADC+0x6>
    4c5e:	1f 92       	push	r1
    4c60:	cd b7       	in	r28, 0x3d	; 61
    4c62:	de b7       	in	r29, 0x3e	; 62
    4c64:	9c 83       	std	Y+4, r25	; 0x04
    4c66:	8b 83       	std	Y+3, r24	; 0x03
	
	int i;

	for(i = 0;i < 16; i++){
    4c68:	1a 82       	std	Y+2, r1	; 0x02
    4c6a:	19 82       	std	Y+1, r1	; 0x01
    4c6c:	14 c0       	rjmp	.+40     	; 0x4c96 <vTaskADC+0x3e>
		devices[i].port = -1;
    4c6e:	89 81       	ldd	r24, Y+1	; 0x01
    4c70:	9a 81       	ldd	r25, Y+2	; 0x02
    4c72:	88 0f       	add	r24, r24
    4c74:	99 1f       	adc	r25, r25
    4c76:	88 0f       	add	r24, r24
    4c78:	99 1f       	adc	r25, r25
    4c7a:	88 0f       	add	r24, r24
    4c7c:	99 1f       	adc	r25, r25
    4c7e:	8f 52       	subi	r24, 0x2F	; 47
    4c80:	95 4e       	sbci	r25, 0xE5	; 229
    4c82:	2f ef       	ldi	r18, 0xFF	; 255
    4c84:	3f ef       	ldi	r19, 0xFF	; 255
    4c86:	fc 01       	movw	r30, r24
    4c88:	31 83       	std	Z+1, r19	; 0x01
    4c8a:	20 83       	st	Z, r18

void vTaskADC(void *parameters){
	
	int i;

	for(i = 0;i < 16; i++){
    4c8c:	89 81       	ldd	r24, Y+1	; 0x01
    4c8e:	9a 81       	ldd	r25, Y+2	; 0x02
    4c90:	01 96       	adiw	r24, 0x01	; 1
    4c92:	9a 83       	std	Y+2, r25	; 0x02
    4c94:	89 83       	std	Y+1, r24	; 0x01
    4c96:	89 81       	ldd	r24, Y+1	; 0x01
    4c98:	9a 81       	ldd	r25, Y+2	; 0x02
    4c9a:	80 31       	cpi	r24, 0x10	; 16
    4c9c:	91 05       	cpc	r25, r1
    4c9e:	3c f3       	brlt	.-50     	; 0x4c6e <vTaskADC+0x16>
		devices[i].port = -1;
	}

	initADC();
    4ca0:	0e 94 e1 24 	call	0x49c2	; 0x49c2 <initADC>

	vSemaphoreCreateBinary(adcSemaphore);
    4ca4:	43 e0       	ldi	r20, 0x03	; 3
    4ca6:	60 e0       	ldi	r22, 0x00	; 0
    4ca8:	81 e0       	ldi	r24, 0x01	; 1
    4caa:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <xQueueGenericCreate>
    4cae:	90 93 d0 1a 	sts	0x1AD0, r25
    4cb2:	80 93 cf 1a 	sts	0x1ACF, r24
    4cb6:	80 91 cf 1a 	lds	r24, 0x1ACF
    4cba:	90 91 d0 1a 	lds	r25, 0x1AD0
    4cbe:	00 97       	sbiw	r24, 0x00	; 0
    4cc0:	59 f0       	breq	.+22     	; 0x4cd8 <vTaskADC+0x80>
    4cc2:	80 91 cf 1a 	lds	r24, 0x1ACF
    4cc6:	90 91 d0 1a 	lds	r25, 0x1AD0
    4cca:	20 e0       	ldi	r18, 0x00	; 0
    4ccc:	40 e0       	ldi	r20, 0x00	; 0
    4cce:	50 e0       	ldi	r21, 0x00	; 0
    4cd0:	60 e0       	ldi	r22, 0x00	; 0
    4cd2:	70 e0       	ldi	r23, 0x00	; 0
    4cd4:	0e 94 f9 0d 	call	0x1bf2	; 0x1bf2 <xQueueGenericSend>
	
	ADCinitialized = 1;
    4cd8:	81 e0       	ldi	r24, 0x01	; 1
    4cda:	90 e0       	ldi	r25, 0x00	; 0
    4cdc:	90 93 54 1b 	sts	0x1B54, r25
    4ce0:	80 93 53 1b 	sts	0x1B53, r24
	while(devices[0].port == -1){
    4ce4:	04 c0       	rjmp	.+8      	; 0x4cee <vTaskADC+0x96>
		vTaskDelay(10);
    4ce6:	8a e0       	ldi	r24, 0x0A	; 10
    4ce8:	90 e0       	ldi	r25, 0x00	; 0
    4cea:	0e 94 ca 04 	call	0x994	; 0x994 <vTaskDelay>
	initADC();

	vSemaphoreCreateBinary(adcSemaphore);
	
	ADCinitialized = 1;
	while(devices[0].port == -1){
    4cee:	80 91 d1 1a 	lds	r24, 0x1AD1
    4cf2:	90 91 d2 1a 	lds	r25, 0x1AD2
    4cf6:	8f 3f       	cpi	r24, 0xFF	; 255
    4cf8:	ff ef       	ldi	r31, 0xFF	; 255
    4cfa:	9f 07       	cpc	r25, r31
    4cfc:	a1 f3       	breq	.-24     	; 0x4ce6 <vTaskADC+0x8e>
		vTaskDelay(10);
	}
	
	while(1){
		ADCStart(&devices[currDevice]);
    4cfe:	80 91 51 1b 	lds	r24, 0x1B51
    4d02:	90 91 52 1b 	lds	r25, 0x1B52
    4d06:	88 0f       	add	r24, r24
    4d08:	99 1f       	adc	r25, r25
    4d0a:	88 0f       	add	r24, r24
    4d0c:	99 1f       	adc	r25, r25
    4d0e:	88 0f       	add	r24, r24
    4d10:	99 1f       	adc	r25, r25
    4d12:	8f 52       	subi	r24, 0x2F	; 47
    4d14:	95 4e       	sbci	r25, 0xE5	; 229
    4d16:	0e 94 f7 24 	call	0x49ee	; 0x49ee <ADCStart>
		currDevice++;
    4d1a:	80 91 51 1b 	lds	r24, 0x1B51
    4d1e:	90 91 52 1b 	lds	r25, 0x1B52
    4d22:	01 96       	adiw	r24, 0x01	; 1
    4d24:	90 93 52 1b 	sts	0x1B52, r25
    4d28:	80 93 51 1b 	sts	0x1B51, r24
		if(currDevice >= 16 || devices[currDevice].port == -1){
    4d2c:	80 91 51 1b 	lds	r24, 0x1B51
    4d30:	90 91 52 1b 	lds	r25, 0x1B52
    4d34:	80 31       	cpi	r24, 0x10	; 16
    4d36:	91 05       	cpc	r25, r1
    4d38:	9c f4       	brge	.+38     	; 0x4d60 <vTaskADC+0x108>
    4d3a:	80 91 51 1b 	lds	r24, 0x1B51
    4d3e:	90 91 52 1b 	lds	r25, 0x1B52
    4d42:	88 0f       	add	r24, r24
    4d44:	99 1f       	adc	r25, r25
    4d46:	88 0f       	add	r24, r24
    4d48:	99 1f       	adc	r25, r25
    4d4a:	88 0f       	add	r24, r24
    4d4c:	99 1f       	adc	r25, r25
    4d4e:	8f 52       	subi	r24, 0x2F	; 47
    4d50:	95 4e       	sbci	r25, 0xE5	; 229
    4d52:	fc 01       	movw	r30, r24
    4d54:	80 81       	ld	r24, Z
    4d56:	91 81       	ldd	r25, Z+1	; 0x01
    4d58:	8f 3f       	cpi	r24, 0xFF	; 255
    4d5a:	ff ef       	ldi	r31, 0xFF	; 255
    4d5c:	9f 07       	cpc	r25, r31
    4d5e:	21 f4       	brne	.+8      	; 0x4d68 <vTaskADC+0x110>
			currDevice = 0;
    4d60:	10 92 52 1b 	sts	0x1B52, r1
    4d64:	10 92 51 1b 	sts	0x1B51, r1
		}
		xSemaphoreTake(adcSemaphore,portMAX_DELAY);
    4d68:	80 91 cf 1a 	lds	r24, 0x1ACF
    4d6c:	90 91 d0 1a 	lds	r25, 0x1AD0
    4d70:	20 e0       	ldi	r18, 0x00	; 0
    4d72:	4f ef       	ldi	r20, 0xFF	; 255
    4d74:	5f ef       	ldi	r21, 0xFF	; 255
    4d76:	60 e0       	ldi	r22, 0x00	; 0
    4d78:	70 e0       	ldi	r23, 0x00	; 0
    4d7a:	0e 94 f6 0e 	call	0x1dec	; 0x1dec <xQueueGenericReceive>
	}
    4d7e:	bf cf       	rjmp	.-130    	; 0x4cfe <vTaskADC+0xa6>

00004d80 <addADCDevice>:
}

void addADCDevice(int port,int options,ADCHandler handler,void* parameters){
    4d80:	cf 93       	push	r28
    4d82:	df 93       	push	r29
    4d84:	cd b7       	in	r28, 0x3d	; 61
    4d86:	de b7       	in	r29, 0x3e	; 62
    4d88:	2a 97       	sbiw	r28, 0x0a	; 10
    4d8a:	0f b6       	in	r0, 0x3f	; 63
    4d8c:	f8 94       	cli
    4d8e:	de bf       	out	0x3e, r29	; 62
    4d90:	0f be       	out	0x3f, r0	; 63
    4d92:	cd bf       	out	0x3d, r28	; 61
    4d94:	9c 83       	std	Y+4, r25	; 0x04
    4d96:	8b 83       	std	Y+3, r24	; 0x03
    4d98:	7e 83       	std	Y+6, r23	; 0x06
    4d9a:	6d 83       	std	Y+5, r22	; 0x05
    4d9c:	58 87       	std	Y+8, r21	; 0x08
    4d9e:	4f 83       	std	Y+7, r20	; 0x07
    4da0:	3a 87       	std	Y+10, r19	; 0x0a
    4da2:	29 87       	std	Y+9, r18	; 0x09
	int i;
	
	//Creating a device before all the structures are initialized
	//could lead to race conditions.
	while(ADCinitialized == 0) vTaskDelay(3);
    4da4:	04 c0       	rjmp	.+8      	; 0x4dae <addADCDevice+0x2e>
    4da6:	83 e0       	ldi	r24, 0x03	; 3
    4da8:	90 e0       	ldi	r25, 0x00	; 0
    4daa:	0e 94 ca 04 	call	0x994	; 0x994 <vTaskDelay>
    4dae:	80 91 53 1b 	lds	r24, 0x1B53
    4db2:	90 91 54 1b 	lds	r25, 0x1B54
    4db6:	00 97       	sbiw	r24, 0x00	; 0
    4db8:	b1 f3       	breq	.-20     	; 0x4da6 <addADCDevice+0x26>

	for(i = 0; i < 16 && devices[i].port != -1; i++)
    4dba:	1a 82       	std	Y+2, r1	; 0x02
    4dbc:	19 82       	std	Y+1, r1	; 0x01
    4dbe:	05 c0       	rjmp	.+10     	; 0x4dca <addADCDevice+0x4a>
    4dc0:	89 81       	ldd	r24, Y+1	; 0x01
    4dc2:	9a 81       	ldd	r25, Y+2	; 0x02
    4dc4:	01 96       	adiw	r24, 0x01	; 1
    4dc6:	9a 83       	std	Y+2, r25	; 0x02
    4dc8:	89 83       	std	Y+1, r24	; 0x01
    4dca:	89 81       	ldd	r24, Y+1	; 0x01
    4dcc:	9a 81       	ldd	r25, Y+2	; 0x02
    4dce:	80 31       	cpi	r24, 0x10	; 16
    4dd0:	91 05       	cpc	r25, r1
    4dd2:	8c f4       	brge	.+34     	; 0x4df6 <addADCDevice+0x76>
    4dd4:	89 81       	ldd	r24, Y+1	; 0x01
    4dd6:	9a 81       	ldd	r25, Y+2	; 0x02
    4dd8:	88 0f       	add	r24, r24
    4dda:	99 1f       	adc	r25, r25
    4ddc:	88 0f       	add	r24, r24
    4dde:	99 1f       	adc	r25, r25
    4de0:	88 0f       	add	r24, r24
    4de2:	99 1f       	adc	r25, r25
    4de4:	8f 52       	subi	r24, 0x2F	; 47
    4de6:	95 4e       	sbci	r25, 0xE5	; 229
    4de8:	fc 01       	movw	r30, r24
    4dea:	80 81       	ld	r24, Z
    4dec:	91 81       	ldd	r25, Z+1	; 0x01
    4dee:	8f 3f       	cpi	r24, 0xFF	; 255
    4df0:	ff ef       	ldi	r31, 0xFF	; 255
    4df2:	9f 07       	cpc	r25, r31
    4df4:	29 f7       	brne	.-54     	; 0x4dc0 <addADCDevice+0x40>
	;
	
	if(port < 8){
    4df6:	8b 81       	ldd	r24, Y+3	; 0x03
    4df8:	9c 81       	ldd	r25, Y+4	; 0x04
    4dfa:	88 30       	cpi	r24, 0x08	; 8
    4dfc:	91 05       	cpc	r25, r1
    4dfe:	a4 f4       	brge	.+40     	; 0x4e28 <addADCDevice+0xa8>
		DIDR0 &= ~(1 << port);
    4e00:	8e e7       	ldi	r24, 0x7E	; 126
    4e02:	90 e0       	ldi	r25, 0x00	; 0
    4e04:	2e e7       	ldi	r18, 0x7E	; 126
    4e06:	30 e0       	ldi	r19, 0x00	; 0
    4e08:	f9 01       	movw	r30, r18
    4e0a:	20 81       	ld	r18, Z
    4e0c:	42 2f       	mov	r20, r18
    4e0e:	21 e0       	ldi	r18, 0x01	; 1
    4e10:	30 e0       	ldi	r19, 0x00	; 0
    4e12:	0b 80       	ldd	r0, Y+3	; 0x03
    4e14:	02 c0       	rjmp	.+4      	; 0x4e1a <addADCDevice+0x9a>
    4e16:	22 0f       	add	r18, r18
    4e18:	33 1f       	adc	r19, r19
    4e1a:	0a 94       	dec	r0
    4e1c:	e2 f7       	brpl	.-8      	; 0x4e16 <addADCDevice+0x96>
    4e1e:	20 95       	com	r18
    4e20:	24 23       	and	r18, r20
    4e22:	fc 01       	movw	r30, r24
    4e24:	20 83       	st	Z, r18
    4e26:	18 c0       	rjmp	.+48     	; 0x4e58 <addADCDevice+0xd8>
	} else {
		DIDR2 &= ~(1 << (port - 8));
    4e28:	8d e7       	ldi	r24, 0x7D	; 125
    4e2a:	90 e0       	ldi	r25, 0x00	; 0
    4e2c:	2d e7       	ldi	r18, 0x7D	; 125
    4e2e:	30 e0       	ldi	r19, 0x00	; 0
    4e30:	f9 01       	movw	r30, r18
    4e32:	20 81       	ld	r18, Z
    4e34:	62 2f       	mov	r22, r18
    4e36:	2b 81       	ldd	r18, Y+3	; 0x03
    4e38:	3c 81       	ldd	r19, Y+4	; 0x04
    4e3a:	a9 01       	movw	r20, r18
    4e3c:	48 50       	subi	r20, 0x08	; 8
    4e3e:	51 09       	sbc	r21, r1
    4e40:	21 e0       	ldi	r18, 0x01	; 1
    4e42:	30 e0       	ldi	r19, 0x00	; 0
    4e44:	04 2e       	mov	r0, r20
    4e46:	02 c0       	rjmp	.+4      	; 0x4e4c <addADCDevice+0xcc>
    4e48:	22 0f       	add	r18, r18
    4e4a:	33 1f       	adc	r19, r19
    4e4c:	0a 94       	dec	r0
    4e4e:	e2 f7       	brpl	.-8      	; 0x4e48 <addADCDevice+0xc8>
    4e50:	20 95       	com	r18
    4e52:	26 23       	and	r18, r22
    4e54:	fc 01       	movw	r30, r24
    4e56:	20 83       	st	Z, r18
	}

	if(devices[i].port == -1){
    4e58:	89 81       	ldd	r24, Y+1	; 0x01
    4e5a:	9a 81       	ldd	r25, Y+2	; 0x02
    4e5c:	88 0f       	add	r24, r24
    4e5e:	99 1f       	adc	r25, r25
    4e60:	88 0f       	add	r24, r24
    4e62:	99 1f       	adc	r25, r25
    4e64:	88 0f       	add	r24, r24
    4e66:	99 1f       	adc	r25, r25
    4e68:	8f 52       	subi	r24, 0x2F	; 47
    4e6a:	95 4e       	sbci	r25, 0xE5	; 229
    4e6c:	fc 01       	movw	r30, r24
    4e6e:	80 81       	ld	r24, Z
    4e70:	91 81       	ldd	r25, Z+1	; 0x01
    4e72:	8f 3f       	cpi	r24, 0xFF	; 255
    4e74:	ff ef       	ldi	r31, 0xFF	; 255
    4e76:	9f 07       	cpc	r25, r31
    4e78:	e1 f5       	brne	.+120    	; 0x4ef2 <addADCDevice+0x172>
		devices[i].port = port;
    4e7a:	89 81       	ldd	r24, Y+1	; 0x01
    4e7c:	9a 81       	ldd	r25, Y+2	; 0x02
    4e7e:	88 0f       	add	r24, r24
    4e80:	99 1f       	adc	r25, r25
    4e82:	88 0f       	add	r24, r24
    4e84:	99 1f       	adc	r25, r25
    4e86:	88 0f       	add	r24, r24
    4e88:	99 1f       	adc	r25, r25
    4e8a:	8f 52       	subi	r24, 0x2F	; 47
    4e8c:	95 4e       	sbci	r25, 0xE5	; 229
    4e8e:	2b 81       	ldd	r18, Y+3	; 0x03
    4e90:	3c 81       	ldd	r19, Y+4	; 0x04
    4e92:	fc 01       	movw	r30, r24
    4e94:	31 83       	std	Z+1, r19	; 0x01
    4e96:	20 83       	st	Z, r18
		devices[i].options = options;
    4e98:	89 81       	ldd	r24, Y+1	; 0x01
    4e9a:	9a 81       	ldd	r25, Y+2	; 0x02
    4e9c:	88 0f       	add	r24, r24
    4e9e:	99 1f       	adc	r25, r25
    4ea0:	88 0f       	add	r24, r24
    4ea2:	99 1f       	adc	r25, r25
    4ea4:	88 0f       	add	r24, r24
    4ea6:	99 1f       	adc	r25, r25
    4ea8:	8d 52       	subi	r24, 0x2D	; 45
    4eaa:	95 4e       	sbci	r25, 0xE5	; 229
    4eac:	2d 81       	ldd	r18, Y+5	; 0x05
    4eae:	3e 81       	ldd	r19, Y+6	; 0x06
    4eb0:	fc 01       	movw	r30, r24
    4eb2:	31 83       	std	Z+1, r19	; 0x01
    4eb4:	20 83       	st	Z, r18
		devices[i].handler = handler;
    4eb6:	89 81       	ldd	r24, Y+1	; 0x01
    4eb8:	9a 81       	ldd	r25, Y+2	; 0x02
    4eba:	88 0f       	add	r24, r24
    4ebc:	99 1f       	adc	r25, r25
    4ebe:	88 0f       	add	r24, r24
    4ec0:	99 1f       	adc	r25, r25
    4ec2:	88 0f       	add	r24, r24
    4ec4:	99 1f       	adc	r25, r25
    4ec6:	89 52       	subi	r24, 0x29	; 41
    4ec8:	95 4e       	sbci	r25, 0xE5	; 229
    4eca:	2f 81       	ldd	r18, Y+7	; 0x07
    4ecc:	38 85       	ldd	r19, Y+8	; 0x08
    4ece:	fc 01       	movw	r30, r24
    4ed0:	31 83       	std	Z+1, r19	; 0x01
    4ed2:	20 83       	st	Z, r18
		devices[i].parameters = parameters;
    4ed4:	89 81       	ldd	r24, Y+1	; 0x01
    4ed6:	9a 81       	ldd	r25, Y+2	; 0x02
    4ed8:	88 0f       	add	r24, r24
    4eda:	99 1f       	adc	r25, r25
    4edc:	88 0f       	add	r24, r24
    4ede:	99 1f       	adc	r25, r25
    4ee0:	88 0f       	add	r24, r24
    4ee2:	99 1f       	adc	r25, r25
    4ee4:	8b 52       	subi	r24, 0x2B	; 43
    4ee6:	95 4e       	sbci	r25, 0xE5	; 229
    4ee8:	29 85       	ldd	r18, Y+9	; 0x09
    4eea:	3a 85       	ldd	r19, Y+10	; 0x0a
    4eec:	fc 01       	movw	r30, r24
    4eee:	31 83       	std	Z+1, r19	; 0x01
    4ef0:	20 83       	st	Z, r18
	}
}
    4ef2:	2a 96       	adiw	r28, 0x0a	; 10
    4ef4:	0f b6       	in	r0, 0x3f	; 63
    4ef6:	f8 94       	cli
    4ef8:	de bf       	out	0x3e, r29	; 62
    4efa:	0f be       	out	0x3f, r0	; 63
    4efc:	cd bf       	out	0x3d, r28	; 61
    4efe:	df 91       	pop	r29
    4f00:	cf 91       	pop	r28
    4f02:	08 95       	ret

00004f04 <__tablejump2__>:
    4f04:	ee 0f       	add	r30, r30
    4f06:	ff 1f       	adc	r31, r31

00004f08 <__tablejump__>:
    4f08:	05 90       	lpm	r0, Z+
    4f0a:	f4 91       	lpm	r31, Z
    4f0c:	e0 2d       	mov	r30, r0
    4f0e:	19 94       	eijmp

00004f10 <memcpy>:
    4f10:	fb 01       	movw	r30, r22
    4f12:	dc 01       	movw	r26, r24
    4f14:	02 c0       	rjmp	.+4      	; 0x4f1a <memcpy+0xa>
    4f16:	01 90       	ld	r0, Z+
    4f18:	0d 92       	st	X+, r0
    4f1a:	41 50       	subi	r20, 0x01	; 1
    4f1c:	50 40       	sbci	r21, 0x00	; 0
    4f1e:	d8 f7       	brcc	.-10     	; 0x4f16 <memcpy+0x6>
    4f20:	08 95       	ret

00004f22 <memset>:
    4f22:	dc 01       	movw	r26, r24
    4f24:	01 c0       	rjmp	.+2      	; 0x4f28 <memset+0x6>
    4f26:	6d 93       	st	X+, r22
    4f28:	41 50       	subi	r20, 0x01	; 1
    4f2a:	50 40       	sbci	r21, 0x00	; 0
    4f2c:	e0 f7       	brcc	.-8      	; 0x4f26 <memset+0x4>
    4f2e:	08 95       	ret

00004f30 <strncpy>:
    4f30:	fb 01       	movw	r30, r22
    4f32:	dc 01       	movw	r26, r24
    4f34:	41 50       	subi	r20, 0x01	; 1
    4f36:	50 40       	sbci	r21, 0x00	; 0
    4f38:	48 f0       	brcs	.+18     	; 0x4f4c <strncpy+0x1c>
    4f3a:	01 90       	ld	r0, Z+
    4f3c:	0d 92       	st	X+, r0
    4f3e:	00 20       	and	r0, r0
    4f40:	c9 f7       	brne	.-14     	; 0x4f34 <strncpy+0x4>
    4f42:	01 c0       	rjmp	.+2      	; 0x4f46 <strncpy+0x16>
    4f44:	1d 92       	st	X+, r1
    4f46:	41 50       	subi	r20, 0x01	; 1
    4f48:	50 40       	sbci	r21, 0x00	; 0
    4f4a:	e0 f7       	brcc	.-8      	; 0x4f44 <strncpy+0x14>
    4f4c:	08 95       	ret

00004f4e <itoa>:
    4f4e:	fb 01       	movw	r30, r22
    4f50:	9f 01       	movw	r18, r30
    4f52:	e8 94       	clt
    4f54:	42 30       	cpi	r20, 0x02	; 2
    4f56:	c4 f0       	brlt	.+48     	; 0x4f88 <itoa+0x3a>
    4f58:	45 32       	cpi	r20, 0x25	; 37
    4f5a:	b4 f4       	brge	.+44     	; 0x4f88 <itoa+0x3a>
    4f5c:	4a 30       	cpi	r20, 0x0A	; 10
    4f5e:	29 f4       	brne	.+10     	; 0x4f6a <itoa+0x1c>
    4f60:	97 fb       	bst	r25, 7
    4f62:	1e f4       	brtc	.+6      	; 0x4f6a <itoa+0x1c>
    4f64:	90 95       	com	r25
    4f66:	81 95       	neg	r24
    4f68:	9f 4f       	sbci	r25, 0xFF	; 255
    4f6a:	64 2f       	mov	r22, r20
    4f6c:	77 27       	eor	r23, r23
    4f6e:	0e 94 d8 27 	call	0x4fb0	; 0x4fb0 <__udivmodhi4>
    4f72:	80 5d       	subi	r24, 0xD0	; 208
    4f74:	8a 33       	cpi	r24, 0x3A	; 58
    4f76:	0c f0       	brlt	.+2      	; 0x4f7a <itoa+0x2c>
    4f78:	89 5d       	subi	r24, 0xD9	; 217
    4f7a:	81 93       	st	Z+, r24
    4f7c:	cb 01       	movw	r24, r22
    4f7e:	00 97       	sbiw	r24, 0x00	; 0
    4f80:	a1 f7       	brne	.-24     	; 0x4f6a <itoa+0x1c>
    4f82:	16 f4       	brtc	.+4      	; 0x4f88 <itoa+0x3a>
    4f84:	5d e2       	ldi	r21, 0x2D	; 45
    4f86:	51 93       	st	Z+, r21
    4f88:	10 82       	st	Z, r1
    4f8a:	c9 01       	movw	r24, r18
    4f8c:	0c 94 c8 27 	jmp	0x4f90	; 0x4f90 <strrev>

00004f90 <strrev>:
    4f90:	dc 01       	movw	r26, r24
    4f92:	fc 01       	movw	r30, r24
    4f94:	67 2f       	mov	r22, r23
    4f96:	71 91       	ld	r23, Z+
    4f98:	77 23       	and	r23, r23
    4f9a:	e1 f7       	brne	.-8      	; 0x4f94 <strrev+0x4>
    4f9c:	32 97       	sbiw	r30, 0x02	; 2
    4f9e:	04 c0       	rjmp	.+8      	; 0x4fa8 <strrev+0x18>
    4fa0:	7c 91       	ld	r23, X
    4fa2:	6d 93       	st	X+, r22
    4fa4:	70 83       	st	Z, r23
    4fa6:	62 91       	ld	r22, -Z
    4fa8:	ae 17       	cp	r26, r30
    4faa:	bf 07       	cpc	r27, r31
    4fac:	c8 f3       	brcs	.-14     	; 0x4fa0 <strrev+0x10>
    4fae:	08 95       	ret

00004fb0 <__udivmodhi4>:
    4fb0:	aa 1b       	sub	r26, r26
    4fb2:	bb 1b       	sub	r27, r27
    4fb4:	51 e1       	ldi	r21, 0x11	; 17
    4fb6:	07 c0       	rjmp	.+14     	; 0x4fc6 <__udivmodhi4_ep>

00004fb8 <__udivmodhi4_loop>:
    4fb8:	aa 1f       	adc	r26, r26
    4fba:	bb 1f       	adc	r27, r27
    4fbc:	a6 17       	cp	r26, r22
    4fbe:	b7 07       	cpc	r27, r23
    4fc0:	10 f0       	brcs	.+4      	; 0x4fc6 <__udivmodhi4_ep>
    4fc2:	a6 1b       	sub	r26, r22
    4fc4:	b7 0b       	sbc	r27, r23

00004fc6 <__udivmodhi4_ep>:
    4fc6:	88 1f       	adc	r24, r24
    4fc8:	99 1f       	adc	r25, r25
    4fca:	5a 95       	dec	r21
    4fcc:	a9 f7       	brne	.-22     	; 0x4fb8 <__udivmodhi4_loop>
    4fce:	80 95       	com	r24
    4fd0:	90 95       	com	r25
    4fd2:	bc 01       	movw	r22, r24
    4fd4:	cd 01       	movw	r24, r26
    4fd6:	08 95       	ret

00004fd8 <_exit>:
    4fd8:	f8 94       	cli

00004fda <__stop_program>:
    4fda:	ff cf       	rjmp	.-2      	; 0x4fda <__stop_program>
