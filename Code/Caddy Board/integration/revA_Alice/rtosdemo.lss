
rtosdemo.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000028  00800200  00004d0e  00004da2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00004d0e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000018c1  00800228  00800228  00004dca  2**0
                  ALLOC
  3 .stab         0000c0d8  00000000  00000000  00004dcc  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000045a6  00000000  00000000  00010ea4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  0001544a  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 90 00 	jmp	0x120	; 0x120 <__ctors_end>
       4:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
       8:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
       c:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      10:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      14:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      18:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      1c:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      20:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      24:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      28:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      2c:	0c 94 7b 21 	jmp	0x42f6	; 0x42f6 <__vector_11>
      30:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      34:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      38:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      3c:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      40:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      44:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      48:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      4c:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      50:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      54:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      58:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      5c:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      60:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      64:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      68:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      6c:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      70:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      74:	0c 94 87 25 	jmp	0x4b0e	; 0x4b0e <__vector_29>
      78:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      7c:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      80:	0c 94 44 1a 	jmp	0x3488	; 0x3488 <__vector_32>
      84:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      88:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      8c:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      90:	0c 94 d0 1a 	jmp	0x35a0	; 0x35a0 <__vector_36>
      94:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      98:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      9c:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      a0:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      a4:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      a8:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      ac:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      b0:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      b4:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      b8:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      bc:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      c0:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      c4:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      c8:	0c 94 1b 02 	jmp	0x436	; 0x436 <__vector_50>
      cc:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      d0:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      d4:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      d8:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      dc:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      e0:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      e4:	d0 1f       	adc	r29, r16
      e6:	e7 1f       	adc	r30, r23
      e8:	17 20       	and	r1, r7
      ea:	f7 1f       	adc	r31, r23
      ec:	17 20       	and	r1, r7
      ee:	17 20       	and	r1, r7
      f0:	07 20       	and	r0, r7
      f2:	17 20       	and	r1, r7

000000f4 <__trampolines_start>:
      f4:	0c 94 d6 02 	jmp	0x5ac	; 0x5ac <vTaskFunction_2>
      f8:	0c 94 d0 1f 	jmp	0x3fa0	; 0x3fa0 <processCommand+0x5a>
      fc:	0c 94 17 20 	jmp	0x402e	; 0x402e <processCommand+0xe8>
     100:	0c 94 e7 1f 	jmp	0x3fce	; 0x3fce <processCommand+0x88>
     104:	0c 94 e9 25 	jmp	0x4bd2	; 0x4bd2 <vTaskADC>
     108:	0c 94 f2 09 	jmp	0x13e4	; 0x13e4 <prvIdleTask>
     10c:	0c 94 2c 1b 	jmp	0x3658	; 0x3658 <vTaskUSARTWrite>
     110:	0c 94 a5 02 	jmp	0x54a	; 0x54a <vTaskFunction_1>
     114:	0c 94 8c 1c 	jmp	0x3918	; 0x3918 <vTaskUSARTRead>
     118:	0c 94 07 20 	jmp	0x400e	; 0x400e <processCommand+0xc8>
     11c:	0c 94 f7 1f 	jmp	0x3fee	; 0x3fee <processCommand+0xa8>

00000120 <__ctors_end>:
     120:	11 24       	eor	r1, r1
     122:	1f be       	out	0x3f, r1	; 63
     124:	cf ef       	ldi	r28, 0xFF	; 255
     126:	d1 e2       	ldi	r29, 0x21	; 33
     128:	de bf       	out	0x3e, r29	; 62
     12a:	cd bf       	out	0x3d, r28	; 61
     12c:	00 e0       	ldi	r16, 0x00	; 0
     12e:	0c bf       	out	0x3c, r16	; 60

00000130 <__do_copy_data>:
     130:	12 e0       	ldi	r17, 0x02	; 2
     132:	a0 e0       	ldi	r26, 0x00	; 0
     134:	b2 e0       	ldi	r27, 0x02	; 2
     136:	ee e0       	ldi	r30, 0x0E	; 14
     138:	fd e4       	ldi	r31, 0x4D	; 77
     13a:	00 e0       	ldi	r16, 0x00	; 0
     13c:	0b bf       	out	0x3b, r16	; 59
     13e:	02 c0       	rjmp	.+4      	; 0x144 <__do_copy_data+0x14>
     140:	07 90       	elpm	r0, Z+
     142:	0d 92       	st	X+, r0
     144:	a8 32       	cpi	r26, 0x28	; 40
     146:	b1 07       	cpc	r27, r17
     148:	d9 f7       	brne	.-10     	; 0x140 <__do_copy_data+0x10>

0000014a <__do_clear_bss>:
     14a:	1a e1       	ldi	r17, 0x1A	; 26
     14c:	a8 e2       	ldi	r26, 0x28	; 40
     14e:	b2 e0       	ldi	r27, 0x02	; 2
     150:	01 c0       	rjmp	.+2      	; 0x154 <.do_clear_bss_start>

00000152 <.do_clear_bss_loop>:
     152:	1d 92       	st	X+, r1

00000154 <.do_clear_bss_start>:
     154:	a9 3e       	cpi	r26, 0xE9	; 233
     156:	b1 07       	cpc	r27, r17
     158:	e1 f7       	brne	.-8      	; 0x152 <.do_clear_bss_loop>
     15a:	0e 94 cb 00 	call	0x196	; 0x196 <main>
     15e:	0c 94 85 26 	jmp	0x4d0a	; 0x4d0a <_exit>

00000162 <__bad_interrupt>:
     162:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000166 <vApplicationTickHook>:
int count = 0;

int sonarTime;

void vApplicationTickHook()
{
     166:	cf 93       	push	r28
     168:	df 93       	push	r29
     16a:	cd b7       	in	r28, 0x3d	; 61
     16c:	de b7       	in	r29, 0x3e	; 62
    count++;
     16e:	80 91 28 02 	lds	r24, 0x0228
     172:	90 91 29 02 	lds	r25, 0x0229
     176:	01 96       	adiw	r24, 0x01	; 1
     178:	90 93 29 02 	sts	0x0229, r25
     17c:	80 93 28 02 	sts	0x0228, r24
}
     180:	df 91       	pop	r29
     182:	cf 91       	pop	r28
     184:	08 95       	ret

00000186 <vApplicationStackOverflowHook>:

void vApplicationStackOverflowHook(){
     186:	cf 93       	push	r28
     188:	df 93       	push	r29
     18a:	cd b7       	in	r28, 0x3d	; 61
     18c:	de b7       	in	r29, 0x3e	; 62
	return;
     18e:	00 00       	nop
}
     190:	df 91       	pop	r29
     192:	cf 91       	pop	r28
     194:	08 95       	ret

00000196 <main>:
/*-----------------------------------------------------------*/

int main( void )
{
     196:	af 92       	push	r10
     198:	bf 92       	push	r11
     19a:	cf 92       	push	r12
     19c:	df 92       	push	r13
     19e:	ef 92       	push	r14
     1a0:	ff 92       	push	r15
     1a2:	0f 93       	push	r16
     1a4:	cf 93       	push	r28
     1a6:	df 93       	push	r29
     1a8:	00 d0       	rcall	.+0      	; 0x1aa <main+0x14>
     1aa:	00 d0       	rcall	.+0      	; 0x1ac <main+0x16>
     1ac:	cd b7       	in	r28, 0x3d	; 61
     1ae:	de b7       	in	r29, 0x3e	; 62
    
    //- wimpy variable defs
	uint8_t val[2] = {0x3F, 0xFE};
     1b0:	8f e3       	ldi	r24, 0x3F	; 63
     1b2:	8d 83       	std	Y+5, r24	; 0x05
     1b4:	8e ef       	ldi	r24, 0xFE	; 254
     1b6:	8e 83       	std	Y+6, r24	; 0x06
    uint8_t *val0, *val1;
    
	//- avoid pesky warnings...
	val0 = val + 0;
     1b8:	ce 01       	movw	r24, r28
     1ba:	05 96       	adiw	r24, 0x05	; 5
     1bc:	9a 83       	std	Y+2, r25	; 0x02
     1be:	89 83       	std	Y+1, r24	; 0x01
	val1 = val + 1;
     1c0:	ce 01       	movw	r24, r28
     1c2:	05 96       	adiw	r24, 0x05	; 5
     1c4:	01 96       	adiw	r24, 0x01	; 1
     1c6:	9c 83       	std	Y+4, r25	; 0x04
     1c8:	8b 83       	std	Y+3, r24	; 0x03
    
	DDRA = 0xF7;
     1ca:	81 e2       	ldi	r24, 0x21	; 33
     1cc:	90 e0       	ldi	r25, 0x00	; 0
     1ce:	27 ef       	ldi	r18, 0xF7	; 247
     1d0:	fc 01       	movw	r30, r24
     1d2:	20 83       	st	Z, r18
	PORTA = 0;
     1d4:	82 e2       	ldi	r24, 0x22	; 34
     1d6:	90 e0       	ldi	r25, 0x00	; 0
     1d8:	fc 01       	movw	r30, r24
     1da:	10 82       	st	Z, r1
	DDRD = 0xFF;
     1dc:	8a e2       	ldi	r24, 0x2A	; 42
     1de:	90 e0       	ldi	r25, 0x00	; 0
     1e0:	2f ef       	ldi	r18, 0xFF	; 255
     1e2:	fc 01       	movw	r30, r24
     1e4:	20 83       	st	Z, r18
	DDRE = 0xFF;
     1e6:	8d e2       	ldi	r24, 0x2D	; 45
     1e8:	90 e0       	ldi	r25, 0x00	; 0
     1ea:	2f ef       	ldi	r18, 0xFF	; 255
     1ec:	fc 01       	movw	r30, r24
     1ee:	20 83       	st	Z, r18
	DDRB = 0xFF; 
     1f0:	84 e2       	ldi	r24, 0x24	; 36
     1f2:	90 e0       	ldi	r25, 0x00	; 0
     1f4:	2f ef       	ldi	r18, 0xFF	; 255
     1f6:	fc 01       	movw	r30, r24
     1f8:	20 83       	st	Z, r18
	DDRK = 0;
     1fa:	87 e0       	ldi	r24, 0x07	; 7
     1fc:	91 e0       	ldi	r25, 0x01	; 1
     1fe:	fc 01       	movw	r30, r24
     200:	10 82       	st	Z, r1

	PORTD = 0;
     202:	8b e2       	ldi	r24, 0x2B	; 43
     204:	90 e0       	ldi	r25, 0x00	; 0
     206:	fc 01       	movw	r30, r24
     208:	10 82       	st	Z, r1
	PORTE = 0;
     20a:	8e e2       	ldi	r24, 0x2E	; 46
     20c:	90 e0       	ldi	r25, 0x00	; 0
     20e:	fc 01       	movw	r30, r24
     210:	10 82       	st	Z, r1
	PORTK = 2;
     212:	88 e0       	ldi	r24, 0x08	; 8
     214:	91 e0       	ldi	r25, 0x01	; 1
     216:	22 e0       	ldi	r18, 0x02	; 2
     218:	fc 01       	movw	r30, r24
     21a:	20 83       	st	Z, r18

    //- init IO with goodness
	vIO_init();
     21c:	0e 94 2e 03 	call	0x65c	; 0x65c <vIO_init>

	//- Create a 
	xTaskCreate( (pdTASK_CODE) vTaskFunction_1, (signed char *) "T0", configMINIMAL_STACK_SIZE+1000,
     220:	8b 81       	ldd	r24, Y+3	; 0x03
     222:	9c 81       	ldd	r25, Y+4	; 0x04
     224:	a1 2c       	mov	r10, r1
     226:	b1 2c       	mov	r11, r1
     228:	c1 2c       	mov	r12, r1
     22a:	d1 2c       	mov	r13, r1
     22c:	e1 2c       	mov	r14, r1
     22e:	f1 2c       	mov	r15, r1
     230:	01 e0       	ldi	r16, 0x01	; 1
     232:	9c 01       	movw	r18, r24
     234:	4d e3       	ldi	r20, 0x3D	; 61
     236:	54 e0       	ldi	r21, 0x04	; 4
     238:	62 e0       	ldi	r22, 0x02	; 2
     23a:	72 e0       	ldi	r23, 0x02	; 2
     23c:	85 ea       	ldi	r24, 0xA5	; 165
     23e:	92 e0       	ldi	r25, 0x02	; 2
     240:	0e 94 3e 03 	call	0x67c	; 0x67c <xTaskGenericCreate>
                (void *) val1, 1, NULL );
   xTaskCreate( (pdTASK_CODE) vTaskFunction_2, (signed char *) "T0", configMINIMAL_STACK_SIZE+1000,
     244:	8b 81       	ldd	r24, Y+3	; 0x03
     246:	9c 81       	ldd	r25, Y+4	; 0x04
     248:	a1 2c       	mov	r10, r1
     24a:	b1 2c       	mov	r11, r1
     24c:	c1 2c       	mov	r12, r1
     24e:	d1 2c       	mov	r13, r1
     250:	e1 2c       	mov	r14, r1
     252:	f1 2c       	mov	r15, r1
     254:	01 e0       	ldi	r16, 0x01	; 1
     256:	9c 01       	movw	r18, r24
     258:	4d e3       	ldi	r20, 0x3D	; 61
     25a:	54 e0       	ldi	r21, 0x04	; 4
     25c:	62 e0       	ldi	r22, 0x02	; 2
     25e:	72 e0       	ldi	r23, 0x02	; 2
     260:	86 ed       	ldi	r24, 0xD6	; 214
     262:	92 e0       	ldi	r25, 0x02	; 2
     264:	0e 94 3e 03 	call	0x67c	; 0x67c <xTaskGenericCreate>

 
   /*xTaskCreate( (pdTASK_CODE) vTaskSonar, (signed char *) "T1", configMINIMAL_STACK_SIZE+1000,
                (void *) val1, 1, NULL );*/

   xTaskCreate( (pdTASK_CODE) vTaskUSARTWrite, (signed char *) "T2", configMINIMAL_STACK_SIZE+1000,
     268:	8b 81       	ldd	r24, Y+3	; 0x03
     26a:	9c 81       	ldd	r25, Y+4	; 0x04
     26c:	a1 2c       	mov	r10, r1
     26e:	b1 2c       	mov	r11, r1
     270:	c1 2c       	mov	r12, r1
     272:	d1 2c       	mov	r13, r1
     274:	e1 2c       	mov	r14, r1
     276:	f1 2c       	mov	r15, r1
     278:	01 e0       	ldi	r16, 0x01	; 1
     27a:	9c 01       	movw	r18, r24
     27c:	4d e3       	ldi	r20, 0x3D	; 61
     27e:	54 e0       	ldi	r21, 0x04	; 4
     280:	65 e0       	ldi	r22, 0x05	; 5
     282:	72 e0       	ldi	r23, 0x02	; 2
     284:	8c e2       	ldi	r24, 0x2C	; 44
     286:	9b e1       	ldi	r25, 0x1B	; 27
     288:	0e 94 3e 03 	call	0x67c	; 0x67c <xTaskGenericCreate>
   				(void *) val1, 1, NULL);

   xTaskCreate( (pdTASK_CODE) vTaskUSARTRead, (signed char *) "T3", configMINIMAL_STACK_SIZE+1000,
     28c:	8b 81       	ldd	r24, Y+3	; 0x03
     28e:	9c 81       	ldd	r25, Y+4	; 0x04
     290:	a1 2c       	mov	r10, r1
     292:	b1 2c       	mov	r11, r1
     294:	c1 2c       	mov	r12, r1
     296:	d1 2c       	mov	r13, r1
     298:	e1 2c       	mov	r14, r1
     29a:	f1 2c       	mov	r15, r1
     29c:	01 e0       	ldi	r16, 0x01	; 1
     29e:	9c 01       	movw	r18, r24
     2a0:	4d e3       	ldi	r20, 0x3D	; 61
     2a2:	54 e0       	ldi	r21, 0x04	; 4
     2a4:	68 e0       	ldi	r22, 0x08	; 8
     2a6:	72 e0       	ldi	r23, 0x02	; 2
     2a8:	8c e8       	ldi	r24, 0x8C	; 140
     2aa:	9c e1       	ldi	r25, 0x1C	; 28
     2ac:	0e 94 3e 03 	call	0x67c	; 0x67c <xTaskGenericCreate>
   				(void *) val1, 1, NULL);

	
	xTaskCreate( (pdTASK_CODE) vTaskADC, (signed char *) "T3", configMINIMAL_STACK_SIZE+1000,
     2b0:	8b 81       	ldd	r24, Y+3	; 0x03
     2b2:	9c 81       	ldd	r25, Y+4	; 0x04
     2b4:	a1 2c       	mov	r10, r1
     2b6:	b1 2c       	mov	r11, r1
     2b8:	c1 2c       	mov	r12, r1
     2ba:	d1 2c       	mov	r13, r1
     2bc:	e1 2c       	mov	r14, r1
     2be:	f1 2c       	mov	r15, r1
     2c0:	01 e0       	ldi	r16, 0x01	; 1
     2c2:	9c 01       	movw	r18, r24
     2c4:	4d e3       	ldi	r20, 0x3D	; 61
     2c6:	54 e0       	ldi	r21, 0x04	; 4
     2c8:	68 e0       	ldi	r22, 0x08	; 8
     2ca:	72 e0       	ldi	r23, 0x02	; 2
     2cc:	89 ee       	ldi	r24, 0xE9	; 233
     2ce:	95 e2       	ldi	r25, 0x25	; 37
     2d0:	0e 94 3e 03 	call	0x67c	; 0x67c <xTaskGenericCreate>

//   xTaskCreate( (pdTASK_CODE) vTaskUSARTLog, (signed char *) "T4", configMINIMAL_STACK_SIZE+1000,
//   				(void *) val1, 1, NULL);
    
    //- kick off the scheduler
	vTaskStartScheduler();
     2d4:	0e 94 3d 06 	call	0xc7a	; 0xc7a <vTaskStartScheduler>
    
	return 0;
     2d8:	80 e0       	ldi	r24, 0x00	; 0
     2da:	90 e0       	ldi	r25, 0x00	; 0
}
     2dc:	26 96       	adiw	r28, 0x06	; 6
     2de:	0f b6       	in	r0, 0x3f	; 63
     2e0:	f8 94       	cli
     2e2:	de bf       	out	0x3e, r29	; 62
     2e4:	0f be       	out	0x3f, r0	; 63
     2e6:	cd bf       	out	0x3d, r28	; 61
     2e8:	df 91       	pop	r29
     2ea:	cf 91       	pop	r28
     2ec:	0f 91       	pop	r16
     2ee:	ff 90       	pop	r15
     2f0:	ef 90       	pop	r14
     2f2:	df 90       	pop	r13
     2f4:	cf 90       	pop	r12
     2f6:	bf 90       	pop	r11
     2f8:	af 90       	pop	r10
     2fa:	08 95       	ret

000002fc <printHex>:
/*-----------------------------------------------------------*/

void printHex(int i){
     2fc:	cf 93       	push	r28
     2fe:	df 93       	push	r29
     300:	cd b7       	in	r28, 0x3d	; 61
     302:	de b7       	in	r29, 0x3e	; 62
     304:	62 97       	sbiw	r28, 0x12	; 18
     306:	0f b6       	in	r0, 0x3f	; 63
     308:	f8 94       	cli
     30a:	de bf       	out	0x3e, r29	; 62
     30c:	0f be       	out	0x3f, r0	; 63
     30e:	cd bf       	out	0x3d, r28	; 61
     310:	9a 8b       	std	Y+18, r25	; 0x12
     312:	89 8b       	std	Y+17, r24	; 0x11
	char hex[] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
     314:	20 e1       	ldi	r18, 0x10	; 16
     316:	eb e0       	ldi	r30, 0x0B	; 11
     318:	f2 e0       	ldi	r31, 0x02	; 2
     31a:	ce 01       	movw	r24, r28
     31c:	01 96       	adiw	r24, 0x01	; 1
     31e:	dc 01       	movw	r26, r24
     320:	01 90       	ld	r0, Z+
     322:	0d 92       	st	X+, r0
     324:	2a 95       	dec	r18
     326:	e1 f7       	brne	.-8      	; 0x320 <printHex+0x24>

	USART_Write(hex[(i&0xF000) >> 12]);
     328:	89 89       	ldd	r24, Y+17	; 0x11
     32a:	9a 89       	ldd	r25, Y+18	; 0x12
     32c:	89 2f       	mov	r24, r25
     32e:	99 27       	eor	r25, r25
     330:	82 95       	swap	r24
     332:	8f 70       	andi	r24, 0x0F	; 15
     334:	9e 01       	movw	r18, r28
     336:	2f 5f       	subi	r18, 0xFF	; 255
     338:	3f 4f       	sbci	r19, 0xFF	; 255
     33a:	82 0f       	add	r24, r18
     33c:	93 1f       	adc	r25, r19
     33e:	fc 01       	movw	r30, r24
     340:	80 81       	ld	r24, Z
     342:	0e 94 8a 1a 	call	0x3514	; 0x3514 <USART_Write>
	USART_Write(hex[(i&0xF00) >> 8]);
     346:	89 89       	ldd	r24, Y+17	; 0x11
     348:	9a 89       	ldd	r25, Y+18	; 0x12
     34a:	88 27       	eor	r24, r24
     34c:	9f 70       	andi	r25, 0x0F	; 15
     34e:	89 2f       	mov	r24, r25
     350:	99 0f       	add	r25, r25
     352:	99 0b       	sbc	r25, r25
     354:	9e 01       	movw	r18, r28
     356:	2f 5f       	subi	r18, 0xFF	; 255
     358:	3f 4f       	sbci	r19, 0xFF	; 255
     35a:	82 0f       	add	r24, r18
     35c:	93 1f       	adc	r25, r19
     35e:	fc 01       	movw	r30, r24
     360:	80 81       	ld	r24, Z
     362:	0e 94 8a 1a 	call	0x3514	; 0x3514 <USART_Write>
	USART_Write(hex[(i&0xF0) >> 4]);
     366:	89 89       	ldd	r24, Y+17	; 0x11
     368:	9a 89       	ldd	r25, Y+18	; 0x12
     36a:	80 7f       	andi	r24, 0xF0	; 240
     36c:	99 27       	eor	r25, r25
     36e:	95 95       	asr	r25
     370:	87 95       	ror	r24
     372:	95 95       	asr	r25
     374:	87 95       	ror	r24
     376:	95 95       	asr	r25
     378:	87 95       	ror	r24
     37a:	95 95       	asr	r25
     37c:	87 95       	ror	r24
     37e:	9e 01       	movw	r18, r28
     380:	2f 5f       	subi	r18, 0xFF	; 255
     382:	3f 4f       	sbci	r19, 0xFF	; 255
     384:	82 0f       	add	r24, r18
     386:	93 1f       	adc	r25, r19
     388:	fc 01       	movw	r30, r24
     38a:	80 81       	ld	r24, Z
     38c:	0e 94 8a 1a 	call	0x3514	; 0x3514 <USART_Write>
	USART_Write(hex[i&0xF]);
     390:	89 89       	ldd	r24, Y+17	; 0x11
     392:	9a 89       	ldd	r25, Y+18	; 0x12
     394:	8f 70       	andi	r24, 0x0F	; 15
     396:	99 27       	eor	r25, r25
     398:	9e 01       	movw	r18, r28
     39a:	2f 5f       	subi	r18, 0xFF	; 255
     39c:	3f 4f       	sbci	r19, 0xFF	; 255
     39e:	82 0f       	add	r24, r18
     3a0:	93 1f       	adc	r25, r19
     3a2:	fc 01       	movw	r30, r24
     3a4:	80 81       	ld	r24, Z
     3a6:	0e 94 8a 1a 	call	0x3514	; 0x3514 <USART_Write>

}
     3aa:	62 96       	adiw	r28, 0x12	; 18
     3ac:	0f b6       	in	r0, 0x3f	; 63
     3ae:	f8 94       	cli
     3b0:	de bf       	out	0x3e, r29	; 62
     3b2:	0f be       	out	0x3f, r0	; 63
     3b4:	cd bf       	out	0x3d, r28	; 61
     3b6:	df 91       	pop	r29
     3b8:	cf 91       	pop	r28
     3ba:	08 95       	ret

000003bc <printNum>:

void printNum(unsigned char i){
     3bc:	cf 93       	push	r28
     3be:	df 93       	push	r29
     3c0:	cd b7       	in	r28, 0x3d	; 61
     3c2:	de b7       	in	r29, 0x3e	; 62
     3c4:	2d 97       	sbiw	r28, 0x0d	; 13
     3c6:	0f b6       	in	r0, 0x3f	; 63
     3c8:	f8 94       	cli
     3ca:	de bf       	out	0x3e, r29	; 62
     3cc:	0f be       	out	0x3f, r0	; 63
     3ce:	cd bf       	out	0x3d, r28	; 61
     3d0:	8d 87       	std	Y+13, r24	; 0x0d
    
    char str[10];
    memset(str,0,10);
     3d2:	ce 01       	movw	r24, r28
     3d4:	03 96       	adiw	r24, 0x03	; 3
     3d6:	4a e0       	ldi	r20, 0x0A	; 10
     3d8:	50 e0       	ldi	r21, 0x00	; 0
     3da:	60 e0       	ldi	r22, 0x00	; 0
     3dc:	70 e0       	ldi	r23, 0x00	; 0
     3de:	0e 94 2a 26 	call	0x4c54	; 0x4c54 <memset>
    itoa(i,str,10);
     3e2:	8d 85       	ldd	r24, Y+13	; 0x0d
     3e4:	88 2f       	mov	r24, r24
     3e6:	90 e0       	ldi	r25, 0x00	; 0
     3e8:	9e 01       	movw	r18, r28
     3ea:	2d 5f       	subi	r18, 0xFD	; 253
     3ec:	3f 4f       	sbci	r19, 0xFF	; 255
     3ee:	4a e0       	ldi	r20, 0x0A	; 10
     3f0:	50 e0       	ldi	r21, 0x00	; 0
     3f2:	b9 01       	movw	r22, r18
     3f4:	0e 94 40 26 	call	0x4c80	; 0x4c80 <itoa>
    char * irr = str;
     3f8:	ce 01       	movw	r24, r28
     3fa:	03 96       	adiw	r24, 0x03	; 3
     3fc:	9a 83       	std	Y+2, r25	; 0x02
     3fe:	89 83       	std	Y+1, r24	; 0x01
    while(*irr){
     400:	0b c0       	rjmp	.+22     	; 0x418 <printNum+0x5c>
        USART_AddToQueue((unsigned char )*irr);
     402:	89 81       	ldd	r24, Y+1	; 0x01
     404:	9a 81       	ldd	r25, Y+2	; 0x02
     406:	fc 01       	movw	r30, r24
     408:	80 81       	ld	r24, Z
     40a:	0e 94 f7 1a 	call	0x35ee	; 0x35ee <USART_AddToQueue>
        irr++;
     40e:	89 81       	ldd	r24, Y+1	; 0x01
     410:	9a 81       	ldd	r25, Y+2	; 0x02
     412:	01 96       	adiw	r24, 0x01	; 1
     414:	9a 83       	std	Y+2, r25	; 0x02
     416:	89 83       	std	Y+1, r24	; 0x01
    
    char str[10];
    memset(str,0,10);
    itoa(i,str,10);
    char * irr = str;
    while(*irr){
     418:	89 81       	ldd	r24, Y+1	; 0x01
     41a:	9a 81       	ldd	r25, Y+2	; 0x02
     41c:	fc 01       	movw	r30, r24
     41e:	80 81       	ld	r24, Z
     420:	88 23       	and	r24, r24
     422:	79 f7       	brne	.-34     	; 0x402 <printNum+0x46>
        USART_AddToQueue((unsigned char )*irr);
        irr++;
    }
    
}
     424:	2d 96       	adiw	r28, 0x0d	; 13
     426:	0f b6       	in	r0, 0x3f	; 63
     428:	f8 94       	cli
     42a:	de bf       	out	0x3e, r29	; 62
     42c:	0f be       	out	0x3f, r0	; 63
     42e:	cd bf       	out	0x3d, r28	; 61
     430:	df 91       	pop	r29
     432:	cf 91       	pop	r28
     434:	08 95       	ret

00000436 <__vector_50>:

ISR(TIMER5_OVF_vect){
     436:	1f 92       	push	r1
     438:	0f 92       	push	r0
     43a:	00 90 5f 00 	lds	r0, 0x005F
     43e:	0f 92       	push	r0
     440:	11 24       	eor	r1, r1
     442:	00 90 5b 00 	lds	r0, 0x005B
     446:	0f 92       	push	r0
     448:	2f 93       	push	r18
     44a:	3f 93       	push	r19
     44c:	8f 93       	push	r24
     44e:	9f 93       	push	r25
     450:	ef 93       	push	r30
     452:	ff 93       	push	r31
     454:	cf 93       	push	r28
     456:	df 93       	push	r29
     458:	cd b7       	in	r28, 0x3d	; 61
     45a:	de b7       	in	r29, 0x3e	; 62

	PORTB ^= 0xFF;
     45c:	85 e2       	ldi	r24, 0x25	; 37
     45e:	90 e0       	ldi	r25, 0x00	; 0
     460:	25 e2       	ldi	r18, 0x25	; 37
     462:	30 e0       	ldi	r19, 0x00	; 0
     464:	f9 01       	movw	r30, r18
     466:	20 81       	ld	r18, Z
     468:	20 95       	com	r18
     46a:	fc 01       	movw	r30, r24
     46c:	20 83       	st	Z, r18
	TCNT3L = 0;
     46e:	84 e9       	ldi	r24, 0x94	; 148
     470:	90 e0       	ldi	r25, 0x00	; 0
     472:	fc 01       	movw	r30, r24
     474:	10 82       	st	Z, r1
	TCNT3H = 0;
     476:	85 e9       	ldi	r24, 0x95	; 149
     478:	90 e0       	ldi	r25, 0x00	; 0
     47a:	fc 01       	movw	r30, r24
     47c:	10 82       	st	Z, r1

}
     47e:	df 91       	pop	r29
     480:	cf 91       	pop	r28
     482:	ff 91       	pop	r31
     484:	ef 91       	pop	r30
     486:	9f 91       	pop	r25
     488:	8f 91       	pop	r24
     48a:	3f 91       	pop	r19
     48c:	2f 91       	pop	r18
     48e:	0f 90       	pop	r0
     490:	00 92 5b 00 	sts	0x005B, r0
     494:	0f 90       	pop	r0
     496:	00 92 5f 00 	sts	0x005F, r0
     49a:	0f 90       	pop	r0
     49c:	1f 90       	pop	r1
     49e:	18 95       	reti

000004a0 <getTimerCount2>:

unsigned int getTimerCount2(){
     4a0:	cf 93       	push	r28
     4a2:	df 93       	push	r29
     4a4:	cd b7       	in	r28, 0x3d	; 61
     4a6:	de b7       	in	r29, 0x3e	; 62

	//volatile char timerLow = TCNT3L;

	return TCNT0;
     4a8:	86 e4       	ldi	r24, 0x46	; 70
     4aa:	90 e0       	ldi	r25, 0x00	; 0
     4ac:	fc 01       	movw	r30, r24
     4ae:	80 81       	ld	r24, Z
     4b0:	88 2f       	mov	r24, r24
     4b2:	90 e0       	ldi	r25, 0x00	; 0

}
     4b4:	df 91       	pop	r29
     4b6:	cf 91       	pop	r28
     4b8:	08 95       	ret

000004ba <potValue>:


int potValue(int sonarMax,int sonarMin,int potMax,int potMin,int x){
     4ba:	0f 93       	push	r16
     4bc:	1f 93       	push	r17
     4be:	cf 93       	push	r28
     4c0:	df 93       	push	r29
     4c2:	cd b7       	in	r28, 0x3d	; 61
     4c4:	de b7       	in	r29, 0x3e	; 62
     4c6:	2c 97       	sbiw	r28, 0x0c	; 12
     4c8:	0f b6       	in	r0, 0x3f	; 63
     4ca:	f8 94       	cli
     4cc:	de bf       	out	0x3e, r29	; 62
     4ce:	0f be       	out	0x3f, r0	; 63
     4d0:	cd bf       	out	0x3d, r28	; 61
     4d2:	9c 83       	std	Y+4, r25	; 0x04
     4d4:	8b 83       	std	Y+3, r24	; 0x03
     4d6:	7e 83       	std	Y+6, r23	; 0x06
     4d8:	6d 83       	std	Y+5, r22	; 0x05
     4da:	58 87       	std	Y+8, r21	; 0x08
     4dc:	4f 83       	std	Y+7, r20	; 0x07
     4de:	3a 87       	std	Y+10, r19	; 0x0a
     4e0:	29 87       	std	Y+9, r18	; 0x09
     4e2:	1c 87       	std	Y+12, r17	; 0x0c
     4e4:	0b 87       	std	Y+11, r16	; 0x0b
	int value;	
	if(x < sonarMin){
     4e6:	2b 85       	ldd	r18, Y+11	; 0x0b
     4e8:	3c 85       	ldd	r19, Y+12	; 0x0c
     4ea:	8d 81       	ldd	r24, Y+5	; 0x05
     4ec:	9e 81       	ldd	r25, Y+6	; 0x06
     4ee:	28 17       	cp	r18, r24
     4f0:	39 07       	cpc	r19, r25
     4f2:	1c f4       	brge	.+6      	; 0x4fa <potValue+0x40>
		return 0;
     4f4:	80 e0       	ldi	r24, 0x00	; 0
     4f6:	90 e0       	ldi	r25, 0x00	; 0
     4f8:	1d c0       	rjmp	.+58     	; 0x534 <potValue+0x7a>
	} else if (x > sonarMax){
     4fa:	2b 85       	ldd	r18, Y+11	; 0x0b
     4fc:	3c 85       	ldd	r19, Y+12	; 0x0c
     4fe:	8b 81       	ldd	r24, Y+3	; 0x03
     500:	9c 81       	ldd	r25, Y+4	; 0x04
     502:	82 17       	cp	r24, r18
     504:	93 07       	cpc	r25, r19
     506:	1c f4       	brge	.+6      	; 0x50e <potValue+0x54>
		return 0x7F;
     508:	8f e7       	ldi	r24, 0x7F	; 127
     50a:	90 e0       	ldi	r25, 0x00	; 0
     50c:	13 c0       	rjmp	.+38     	; 0x534 <potValue+0x7a>
	} else {
		value = x / 4;
     50e:	8b 85       	ldd	r24, Y+11	; 0x0b
     510:	9c 85       	ldd	r25, Y+12	; 0x0c
     512:	99 23       	and	r25, r25
     514:	0c f4       	brge	.+2      	; 0x518 <potValue+0x5e>
     516:	03 96       	adiw	r24, 0x03	; 3
     518:	95 95       	asr	r25
     51a:	87 95       	ror	r24
     51c:	95 95       	asr	r25
     51e:	87 95       	ror	r24
     520:	9a 83       	std	Y+2, r25	; 0x02
     522:	89 83       	std	Y+1, r24	; 0x01
		return value > potMax?potMax:value;
     524:	2f 81       	ldd	r18, Y+7	; 0x07
     526:	38 85       	ldd	r19, Y+8	; 0x08
     528:	89 81       	ldd	r24, Y+1	; 0x01
     52a:	9a 81       	ldd	r25, Y+2	; 0x02
     52c:	28 17       	cp	r18, r24
     52e:	39 07       	cpc	r19, r25
     530:	0c f4       	brge	.+2      	; 0x534 <potValue+0x7a>
     532:	c9 01       	movw	r24, r18
	}
} 
     534:	2c 96       	adiw	r28, 0x0c	; 12
     536:	0f b6       	in	r0, 0x3f	; 63
     538:	f8 94       	cli
     53a:	de bf       	out	0x3e, r29	; 62
     53c:	0f be       	out	0x3f, r0	; 63
     53e:	cd bf       	out	0x3d, r28	; 61
     540:	df 91       	pop	r29
     542:	cf 91       	pop	r28
     544:	1f 91       	pop	r17
     546:	0f 91       	pop	r16
     548:	08 95       	ret

0000054a <vTaskFunction_1>:

void vTaskFunction_1(void *pvParameters)
{	
     54a:	cf 93       	push	r28
     54c:	df 93       	push	r29
     54e:	cd b7       	in	r28, 0x3d	; 61
     550:	de b7       	in	r29, 0x3e	; 62
     552:	60 97       	sbiw	r28, 0x10	; 16
     554:	0f b6       	in	r0, 0x3f	; 63
     556:	f8 94       	cli
     558:	de bf       	out	0x3e, r29	; 62
     55a:	0f be       	out	0x3f, r0	; 63
     55c:	cd bf       	out	0x3d, r28	; 61
     55e:	98 8b       	std	Y+16, r25	; 0x10
     560:	8f 87       	std	Y+15, r24	; 0x0f
	int sonarResult;
	int movingForward = 1;
     562:	81 e0       	ldi	r24, 0x01	; 1
     564:	90 e0       	ldi	r25, 0x00	; 0
     566:	9a 83       	std	Y+2, r25	; 0x02
     568:	89 83       	std	Y+1, r24	; 0x01

	int sonarMax = 0x31C;
     56a:	8c e1       	ldi	r24, 0x1C	; 28
     56c:	93 e0       	ldi	r25, 0x03	; 3
     56e:	9c 83       	std	Y+4, r25	; 0x04
     570:	8b 83       	std	Y+3, r24	; 0x03
	int sonarMin = 0xE0;
     572:	80 ee       	ldi	r24, 0xE0	; 224
     574:	90 e0       	ldi	r25, 0x00	; 0
     576:	9e 83       	std	Y+6, r25	; 0x06
     578:	8d 83       	std	Y+5, r24	; 0x05
	int potMin = 0x18;
     57a:	88 e1       	ldi	r24, 0x18	; 24
     57c:	90 e0       	ldi	r25, 0x00	; 0
     57e:	98 87       	std	Y+8, r25	; 0x08
     580:	8f 83       	std	Y+7, r24	; 0x07
	int potMax = 0x7F;
     582:	8f e7       	ldi	r24, 0x7F	; 127
     584:	90 e0       	ldi	r25, 0x00	; 0
     586:	9a 87       	std	Y+10, r25	; 0x0a
     588:	89 87       	std	Y+9, r24	; 0x09
	int backwardSwitch = 0xE1;
     58a:	81 ee       	ldi	r24, 0xE1	; 225
     58c:	90 e0       	ldi	r25, 0x00	; 0
     58e:	9c 87       	std	Y+12, r25	; 0x0c
     590:	8b 87       	std	Y+11, r24	; 0x0b
	int forwardSwitch = 0x160;
     592:	80 e6       	ldi	r24, 0x60	; 96
     594:	91 e0       	ldi	r25, 0x01	; 1
     596:	9e 87       	std	Y+14, r25	; 0x0e
     598:	8d 87       	std	Y+13, r24	; 0x0d

	

   USART_Init(9600, 16000000);
     59a:	40 e0       	ldi	r20, 0x00	; 0
     59c:	54 e2       	ldi	r21, 0x24	; 36
     59e:	64 ef       	ldi	r22, 0xF4	; 244
     5a0:	70 e0       	ldi	r23, 0x00	; 0
     5a2:	80 e8       	ldi	r24, 0x80	; 128
     5a4:	95 e2       	ldi	r25, 0x25	; 37
     5a6:	0e 94 47 1a 	call	0x348e	; 0x348e <USART_Init>

	for(;;);
     5aa:	ff cf       	rjmp	.-2      	; 0x5aa <vTaskFunction_1+0x60>

000005ac <vTaskFunction_2>:
		PORTL = 0x80;
		vTaskDelay(200);
	}
}

void vTaskFunction_2(void *pvParameters){
     5ac:	cf 93       	push	r28
     5ae:	df 93       	push	r29
     5b0:	1f 92       	push	r1
     5b2:	1f 92       	push	r1
     5b4:	cd b7       	in	r28, 0x3d	; 61
     5b6:	de b7       	in	r29, 0x3e	; 62
     5b8:	9a 83       	std	Y+2, r25	; 0x02
     5ba:	89 83       	std	Y+1, r24	; 0x01
	DDRL = 0xC0;
     5bc:	8a e0       	ldi	r24, 0x0A	; 10
     5be:	91 e0       	ldi	r25, 0x01	; 1
     5c0:	20 ec       	ldi	r18, 0xC0	; 192
     5c2:	fc 01       	movw	r30, r24
     5c4:	20 83       	st	Z, r18
	for(;;){
		PORTL ^= 0xC0;
     5c6:	8b e0       	ldi	r24, 0x0B	; 11
     5c8:	91 e0       	ldi	r25, 0x01	; 1
     5ca:	2b e0       	ldi	r18, 0x0B	; 11
     5cc:	31 e0       	ldi	r19, 0x01	; 1
     5ce:	f9 01       	movw	r30, r18
     5d0:	30 81       	ld	r19, Z
     5d2:	20 ec       	ldi	r18, 0xC0	; 192
     5d4:	23 27       	eor	r18, r19
     5d6:	fc 01       	movw	r30, r24
     5d8:	20 83       	st	Z, r18
		vTaskDelay(300);
     5da:	8c e2       	ldi	r24, 0x2C	; 44
     5dc:	91 e0       	ldi	r25, 0x01	; 1
     5de:	0e 94 ab 04 	call	0x956	; 0x956 <vTaskDelay>
	}	
     5e2:	f1 cf       	rjmp	.-30     	; 0x5c6 <vTaskFunction_2+0x1a>

000005e4 <vTaskFunction_3>:
}

void vTaskFunction_3(void *pvParameters){
     5e4:	cf 93       	push	r28
     5e6:	df 93       	push	r29
     5e8:	1f 92       	push	r1
     5ea:	1f 92       	push	r1
     5ec:	cd b7       	in	r28, 0x3d	; 61
     5ee:	de b7       	in	r29, 0x3e	; 62
     5f0:	9a 83       	std	Y+2, r25	; 0x02
     5f2:	89 83       	std	Y+1, r24	; 0x01
			PORTA &= ~0x84;
		}
		vTaskDelay(5);
	}*/

}
     5f4:	0f 90       	pop	r0
     5f6:	0f 90       	pop	r0
     5f8:	df 91       	pop	r29
     5fa:	cf 91       	pop	r28
     5fc:	08 95       	ret

000005fe <vTaskPot>:

void vTaskPot(void *pvParameters){
     5fe:	cf 93       	push	r28
     600:	df 93       	push	r29
     602:	00 d0       	rcall	.+0      	; 0x604 <vTaskPot+0x6>
     604:	1f 92       	push	r1
     606:	cd b7       	in	r28, 0x3d	; 61
     608:	de b7       	in	r29, 0x3e	; 62
     60a:	9c 83       	std	Y+4, r25	; 0x04
     60c:	8b 83       	std	Y+3, r24	; 0x03
	initializeSPI();
     60e:	0e 94 d6 23 	call	0x47ac	; 0x47ac <initializeSPI>
	int a = 0;
     612:	1a 82       	std	Y+2, r1	; 0x02
     614:	19 82       	std	Y+1, r1	; 0x01
	initSpeedController();
     616:	0e 94 2c 23 	call	0x4658	; 0x4658 <initSpeedController>
		setPot(a);
		vTaskDelay(80);
		a++;
	}*/
	for(;;){
		setPot(1);
     61a:	81 e0       	ldi	r24, 0x01	; 1
     61c:	90 e0       	ldi	r25, 0x00	; 0
     61e:	0e 94 37 23 	call	0x466e	; 0x466e <setPot>
		vTaskDelay(500);
     622:	84 ef       	ldi	r24, 0xF4	; 244
     624:	91 e0       	ldi	r25, 0x01	; 1
     626:	0e 94 ab 04 	call	0x956	; 0x956 <vTaskDelay>
		setPot(0x40);
     62a:	80 e4       	ldi	r24, 0x40	; 64
     62c:	90 e0       	ldi	r25, 0x00	; 0
     62e:	0e 94 37 23 	call	0x466e	; 0x466e <setPot>
		vTaskDelay(500);
     632:	84 ef       	ldi	r24, 0xF4	; 244
     634:	91 e0       	ldi	r25, 0x01	; 1
     636:	0e 94 ab 04 	call	0x956	; 0x956 <vTaskDelay>
		setPot(0x7F);
     63a:	8f e7       	ldi	r24, 0x7F	; 127
     63c:	90 e0       	ldi	r25, 0x00	; 0
     63e:	0e 94 37 23 	call	0x466e	; 0x466e <setPot>
		vTaskDelay(500);
     642:	84 ef       	ldi	r24, 0xF4	; 244
     644:	91 e0       	ldi	r25, 0x01	; 1
     646:	0e 94 ab 04 	call	0x956	; 0x956 <vTaskDelay>
		setPot(0x40);
     64a:	80 e4       	ldi	r24, 0x40	; 64
     64c:	90 e0       	ldi	r25, 0x00	; 0
     64e:	0e 94 37 23 	call	0x466e	; 0x466e <setPot>
		vTaskDelay(500);
     652:	84 ef       	ldi	r24, 0xF4	; 244
     654:	91 e0       	ldi	r25, 0x01	; 1
     656:	0e 94 ab 04 	call	0x956	; 0x956 <vTaskDelay>
	}
     65a:	df cf       	rjmp	.-66     	; 0x61a <vTaskPot+0x1c>

0000065c <vIO_init>:
}


void vIO_init(void)
{
     65c:	cf 93       	push	r28
     65e:	df 93       	push	r29
     660:	cd b7       	in	r28, 0x3d	; 61
     662:	de b7       	in	r29, 0x3e	; 62
    //- set PortB as output
	DDRB = 0xFF; 
     664:	84 e2       	ldi	r24, 0x24	; 36
     666:	90 e0       	ldi	r25, 0x00	; 0
     668:	2f ef       	ldi	r18, 0xFF	; 255
     66a:	fc 01       	movw	r30, r24
     66c:	20 83       	st	Z, r18
    PORTB = 0; 
     66e:	85 e2       	ldi	r24, 0x25	; 37
     670:	90 e0       	ldi	r25, 0x00	; 0
     672:	fc 01       	movw	r30, r24
     674:	10 82       	st	Z, r1
}
     676:	df 91       	pop	r29
     678:	cf 91       	pop	r28
     67a:	08 95       	ret

0000067c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
     67c:	af 92       	push	r10
     67e:	bf 92       	push	r11
     680:	cf 92       	push	r12
     682:	df 92       	push	r13
     684:	ef 92       	push	r14
     686:	ff 92       	push	r15
     688:	0f 93       	push	r16
     68a:	1f 93       	push	r17
     68c:	cf 93       	push	r28
     68e:	df 93       	push	r29
     690:	cd b7       	in	r28, 0x3d	; 61
     692:	de b7       	in	r29, 0x3e	; 62
     694:	64 97       	sbiw	r28, 0x14	; 20
     696:	0f b6       	in	r0, 0x3f	; 63
     698:	f8 94       	cli
     69a:	de bf       	out	0x3e, r29	; 62
     69c:	0f be       	out	0x3f, r0	; 63
     69e:	cd bf       	out	0x3d, r28	; 61
     6a0:	9f 83       	std	Y+7, r25	; 0x07
     6a2:	8e 83       	std	Y+6, r24	; 0x06
     6a4:	79 87       	std	Y+9, r23	; 0x09
     6a6:	68 87       	std	Y+8, r22	; 0x08
     6a8:	5b 87       	std	Y+11, r21	; 0x0b
     6aa:	4a 87       	std	Y+10, r20	; 0x0a
     6ac:	3d 87       	std	Y+13, r19	; 0x0d
     6ae:	2c 87       	std	Y+12, r18	; 0x0c
     6b0:	0e 87       	std	Y+14, r16	; 0x0e
     6b2:	f8 8a       	std	Y+16, r15	; 0x10
     6b4:	ef 86       	std	Y+15, r14	; 0x0f
     6b6:	da 8a       	std	Y+18, r13	; 0x12
     6b8:	c9 8a       	std	Y+17, r12	; 0x11
     6ba:	bc 8a       	std	Y+20, r11	; 0x14
     6bc:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
     6be:	29 89       	ldd	r18, Y+17	; 0x11
     6c0:	3a 89       	ldd	r19, Y+18	; 0x12
     6c2:	8a 85       	ldd	r24, Y+10	; 0x0a
     6c4:	9b 85       	ldd	r25, Y+11	; 0x0b
     6c6:	b9 01       	movw	r22, r18
     6c8:	0e 94 f4 0a 	call	0x15e8	; 0x15e8 <prvAllocateTCBAndStack>
     6cc:	9b 83       	std	Y+3, r25	; 0x03
     6ce:	8a 83       	std	Y+2, r24	; 0x02

	if( pxNewTCB != NULL )
     6d0:	8a 81       	ldd	r24, Y+2	; 0x02
     6d2:	9b 81       	ldd	r25, Y+3	; 0x03
     6d4:	00 97       	sbiw	r24, 0x00	; 0
     6d6:	09 f4       	brne	.+2      	; 0x6da <xTaskGenericCreate+0x5e>
     6d8:	9f c0       	rjmp	.+318    	; 0x818 <xTaskGenericCreate+0x19c>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
     6da:	8a 81       	ldd	r24, Y+2	; 0x02
     6dc:	9b 81       	ldd	r25, Y+3	; 0x03
     6de:	fc 01       	movw	r30, r24
     6e0:	27 89       	ldd	r18, Z+23	; 0x17
     6e2:	30 8d       	ldd	r19, Z+24	; 0x18
     6e4:	8a 85       	ldd	r24, Y+10	; 0x0a
     6e6:	9b 85       	ldd	r25, Y+11	; 0x0b
     6e8:	01 97       	sbiw	r24, 0x01	; 1
     6ea:	82 0f       	add	r24, r18
     6ec:	93 1f       	adc	r25, r19
     6ee:	9d 83       	std	Y+5, r25	; 0x05
     6f0:	8c 83       	std	Y+4, r24	; 0x04
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
     6f2:	4a 85       	ldd	r20, Y+10	; 0x0a
     6f4:	5b 85       	ldd	r21, Y+11	; 0x0b
     6f6:	2b 89       	ldd	r18, Y+19	; 0x13
     6f8:	3c 89       	ldd	r19, Y+20	; 0x14
     6fa:	68 85       	ldd	r22, Y+8	; 0x08
     6fc:	79 85       	ldd	r23, Y+9	; 0x09
     6fe:	8a 81       	ldd	r24, Y+2	; 0x02
     700:	9b 81       	ldd	r25, Y+3	; 0x03
     702:	8a 01       	movw	r16, r20
     704:	4e 85       	ldd	r20, Y+14	; 0x0e
     706:	0e 94 04 0a 	call	0x1408	; 0x1408 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     70a:	4c 85       	ldd	r20, Y+12	; 0x0c
     70c:	5d 85       	ldd	r21, Y+13	; 0x0d
     70e:	2e 81       	ldd	r18, Y+6	; 0x06
     710:	3f 81       	ldd	r19, Y+7	; 0x07
     712:	8c 81       	ldd	r24, Y+4	; 0x04
     714:	9d 81       	ldd	r25, Y+5	; 0x05
     716:	b9 01       	movw	r22, r18
     718:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <pxPortInitialiseStack>
     71c:	9c 01       	movw	r18, r24
     71e:	8a 81       	ldd	r24, Y+2	; 0x02
     720:	9b 81       	ldd	r25, Y+3	; 0x03
     722:	fc 01       	movw	r30, r24
     724:	31 83       	std	Z+1, r19	; 0x01
     726:	20 83       	st	Z, r18
		#endif

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
     728:	8f 85       	ldd	r24, Y+15	; 0x0f
     72a:	98 89       	ldd	r25, Y+16	; 0x10
     72c:	00 97       	sbiw	r24, 0x00	; 0
     72e:	39 f0       	breq	.+14     	; 0x73e <xTaskGenericCreate+0xc2>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
     730:	8f 85       	ldd	r24, Y+15	; 0x0f
     732:	98 89       	ldd	r25, Y+16	; 0x10
     734:	2a 81       	ldd	r18, Y+2	; 0x02
     736:	3b 81       	ldd	r19, Y+3	; 0x03
     738:	fc 01       	movw	r30, r24
     73a:	31 83       	std	Z+1, r19	; 0x01
     73c:	20 83       	st	Z, r18
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
     73e:	0f b6       	in	r0, 0x3f	; 63
     740:	f8 94       	cli
     742:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
     744:	80 91 78 02 	lds	r24, 0x0278
     748:	8f 5f       	subi	r24, 0xFF	; 255
     74a:	80 93 78 02 	sts	0x0278, r24
			if( pxCurrentTCB == NULL )
     74e:	80 91 2a 02 	lds	r24, 0x022A
     752:	90 91 2b 02 	lds	r25, 0x022B
     756:	00 97       	sbiw	r24, 0x00	; 0
     758:	69 f4       	brne	.+26     	; 0x774 <xTaskGenericCreate+0xf8>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
     75a:	8a 81       	ldd	r24, Y+2	; 0x02
     75c:	9b 81       	ldd	r25, Y+3	; 0x03
     75e:	90 93 2b 02 	sts	0x022B, r25
     762:	80 93 2a 02 	sts	0x022A, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
     766:	80 91 78 02 	lds	r24, 0x0278
     76a:	81 30       	cpi	r24, 0x01	; 1
     76c:	b1 f4       	brne	.+44     	; 0x79a <xTaskGenericCreate+0x11e>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
     76e:	0e 94 65 0a 	call	0x14ca	; 0x14ca <prvInitialiseTaskLists>
     772:	13 c0       	rjmp	.+38     	; 0x79a <xTaskGenericCreate+0x11e>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
     774:	80 91 7d 02 	lds	r24, 0x027D
     778:	88 23       	and	r24, r24
     77a:	79 f4       	brne	.+30     	; 0x79a <xTaskGenericCreate+0x11e>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
     77c:	80 91 2a 02 	lds	r24, 0x022A
     780:	90 91 2b 02 	lds	r25, 0x022B
     784:	fc 01       	movw	r30, r24
     786:	96 89       	ldd	r25, Z+22	; 0x16
     788:	8e 85       	ldd	r24, Y+14	; 0x0e
     78a:	89 17       	cp	r24, r25
     78c:	30 f0       	brcs	.+12     	; 0x79a <xTaskGenericCreate+0x11e>
					{
						pxCurrentTCB = pxNewTCB;
     78e:	8a 81       	ldd	r24, Y+2	; 0x02
     790:	9b 81       	ldd	r25, Y+3	; 0x03
     792:	90 93 2b 02 	sts	0x022B, r25
     796:	80 93 2a 02 	sts	0x022A, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
     79a:	8a 81       	ldd	r24, Y+2	; 0x02
     79c:	9b 81       	ldd	r25, Y+3	; 0x03
     79e:	fc 01       	movw	r30, r24
     7a0:	96 89       	ldd	r25, Z+22	; 0x16
     7a2:	80 91 7b 02 	lds	r24, 0x027B
     7a6:	89 17       	cp	r24, r25
     7a8:	30 f4       	brcc	.+12     	; 0x7b6 <xTaskGenericCreate+0x13a>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
     7aa:	8a 81       	ldd	r24, Y+2	; 0x02
     7ac:	9b 81       	ldd	r25, Y+3	; 0x03
     7ae:	fc 01       	movw	r30, r24
     7b0:	86 89       	ldd	r24, Z+22	; 0x16
     7b2:	80 93 7b 02 	sts	0x027B, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
     7b6:	80 91 82 02 	lds	r24, 0x0282
     7ba:	8f 5f       	subi	r24, 0xFF	; 255
     7bc:	80 93 82 02 	sts	0x0282, r24

			prvAddTaskToReadyQueue( pxNewTCB );
     7c0:	8a 81       	ldd	r24, Y+2	; 0x02
     7c2:	9b 81       	ldd	r25, Y+3	; 0x03
     7c4:	fc 01       	movw	r30, r24
     7c6:	96 89       	ldd	r25, Z+22	; 0x16
     7c8:	80 91 7c 02 	lds	r24, 0x027C
     7cc:	89 17       	cp	r24, r25
     7ce:	30 f4       	brcc	.+12     	; 0x7dc <xTaskGenericCreate+0x160>
     7d0:	8a 81       	ldd	r24, Y+2	; 0x02
     7d2:	9b 81       	ldd	r25, Y+3	; 0x03
     7d4:	fc 01       	movw	r30, r24
     7d6:	86 89       	ldd	r24, Z+22	; 0x16
     7d8:	80 93 7c 02 	sts	0x027C, r24
     7dc:	8a 81       	ldd	r24, Y+2	; 0x02
     7de:	9b 81       	ldd	r25, Y+3	; 0x03
     7e0:	ac 01       	movw	r20, r24
     7e2:	4e 5f       	subi	r20, 0xFE	; 254
     7e4:	5f 4f       	sbci	r21, 0xFF	; 255
     7e6:	8a 81       	ldd	r24, Y+2	; 0x02
     7e8:	9b 81       	ldd	r25, Y+3	; 0x03
     7ea:	fc 01       	movw	r30, r24
     7ec:	86 89       	ldd	r24, Z+22	; 0x16
     7ee:	28 2f       	mov	r18, r24
     7f0:	30 e0       	ldi	r19, 0x00	; 0
     7f2:	c9 01       	movw	r24, r18
     7f4:	88 0f       	add	r24, r24
     7f6:	99 1f       	adc	r25, r25
     7f8:	88 0f       	add	r24, r24
     7fa:	99 1f       	adc	r25, r25
     7fc:	88 0f       	add	r24, r24
     7fe:	99 1f       	adc	r25, r25
     800:	82 0f       	add	r24, r18
     802:	93 1f       	adc	r25, r19
     804:	84 5d       	subi	r24, 0xD4	; 212
     806:	9d 4f       	sbci	r25, 0xFD	; 253
     808:	ba 01       	movw	r22, r20
     80a:	0e 94 8e 12 	call	0x251c	; 0x251c <vListInsertEnd>

			xReturn = pdPASS;
     80e:	81 e0       	ldi	r24, 0x01	; 1
     810:	89 83       	std	Y+1, r24	; 0x01
			portSETUP_TCB( pxNewTCB );
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
     812:	0f 90       	pop	r0
     814:	0f be       	out	0x3f, r0	; 63
     816:	02 c0       	rjmp	.+4      	; 0x81c <xTaskGenericCreate+0x1a0>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     818:	8f ef       	ldi	r24, 0xFF	; 255
     81a:	89 83       	std	Y+1, r24	; 0x01
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
     81c:	89 81       	ldd	r24, Y+1	; 0x01
     81e:	81 30       	cpi	r24, 0x01	; 1
     820:	79 f4       	brne	.+30     	; 0x840 <xTaskGenericCreate+0x1c4>
	{
		if( xSchedulerRunning != pdFALSE )
     822:	80 91 7d 02 	lds	r24, 0x027D
     826:	88 23       	and	r24, r24
     828:	59 f0       	breq	.+22     	; 0x840 <xTaskGenericCreate+0x1c4>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
     82a:	80 91 2a 02 	lds	r24, 0x022A
     82e:	90 91 2b 02 	lds	r25, 0x022B
     832:	fc 01       	movw	r30, r24
     834:	96 89       	ldd	r25, Z+22	; 0x16
     836:	8e 85       	ldd	r24, Y+14	; 0x0e
     838:	98 17       	cp	r25, r24
     83a:	10 f4       	brcc	.+4      	; 0x840 <xTaskGenericCreate+0x1c4>
			{
				portYIELD_WITHIN_API();
     83c:	0e 94 20 19 	call	0x3240	; 0x3240 <vPortYield>
			}
		}
	}

	return xReturn;
     840:	89 81       	ldd	r24, Y+1	; 0x01
}
     842:	64 96       	adiw	r28, 0x14	; 20
     844:	0f b6       	in	r0, 0x3f	; 63
     846:	f8 94       	cli
     848:	de bf       	out	0x3e, r29	; 62
     84a:	0f be       	out	0x3f, r0	; 63
     84c:	cd bf       	out	0x3d, r28	; 61
     84e:	df 91       	pop	r29
     850:	cf 91       	pop	r28
     852:	1f 91       	pop	r17
     854:	0f 91       	pop	r16
     856:	ff 90       	pop	r15
     858:	ef 90       	pop	r14
     85a:	df 90       	pop	r13
     85c:	cf 90       	pop	r12
     85e:	bf 90       	pop	r11
     860:	af 90       	pop	r10
     862:	08 95       	ret

00000864 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
     864:	cf 93       	push	r28
     866:	df 93       	push	r29
     868:	cd b7       	in	r28, 0x3d	; 61
     86a:	de b7       	in	r29, 0x3e	; 62
     86c:	28 97       	sbiw	r28, 0x08	; 8
     86e:	0f b6       	in	r0, 0x3f	; 63
     870:	f8 94       	cli
     872:	de bf       	out	0x3e, r29	; 62
     874:	0f be       	out	0x3f, r0	; 63
     876:	cd bf       	out	0x3d, r28	; 61
     878:	9e 83       	std	Y+6, r25	; 0x06
     87a:	8d 83       	std	Y+5, r24	; 0x05
     87c:	78 87       	std	Y+8, r23	; 0x08
     87e:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
     880:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
     882:	0e 94 7f 06 	call	0xcfe	; 0xcfe <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     886:	8d 81       	ldd	r24, Y+5	; 0x05
     888:	9e 81       	ldd	r25, Y+6	; 0x06
     88a:	fc 01       	movw	r30, r24
     88c:	20 81       	ld	r18, Z
     88e:	31 81       	ldd	r19, Z+1	; 0x01
     890:	8f 81       	ldd	r24, Y+7	; 0x07
     892:	98 85       	ldd	r25, Y+8	; 0x08
     894:	82 0f       	add	r24, r18
     896:	93 1f       	adc	r25, r19
     898:	9b 83       	std	Y+3, r25	; 0x03
     89a:	8a 83       	std	Y+2, r24	; 0x02

			if( xTickCount < *pxPreviousWakeTime )
     89c:	8d 81       	ldd	r24, Y+5	; 0x05
     89e:	9e 81       	ldd	r25, Y+6	; 0x06
     8a0:	fc 01       	movw	r30, r24
     8a2:	20 81       	ld	r18, Z
     8a4:	31 81       	ldd	r19, Z+1	; 0x01
     8a6:	80 91 79 02 	lds	r24, 0x0279
     8aa:	90 91 7a 02 	lds	r25, 0x027A
     8ae:	82 17       	cp	r24, r18
     8b0:	93 07       	cpc	r25, r19
     8b2:	b0 f4       	brcc	.+44     	; 0x8e0 <vTaskDelayUntil+0x7c>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
     8b4:	8d 81       	ldd	r24, Y+5	; 0x05
     8b6:	9e 81       	ldd	r25, Y+6	; 0x06
     8b8:	fc 01       	movw	r30, r24
     8ba:	20 81       	ld	r18, Z
     8bc:	31 81       	ldd	r19, Z+1	; 0x01
     8be:	8a 81       	ldd	r24, Y+2	; 0x02
     8c0:	9b 81       	ldd	r25, Y+3	; 0x03
     8c2:	82 17       	cp	r24, r18
     8c4:	93 07       	cpc	r25, r19
     8c6:	08 f5       	brcc	.+66     	; 0x90a <vTaskDelayUntil+0xa6>
     8c8:	80 91 79 02 	lds	r24, 0x0279
     8cc:	90 91 7a 02 	lds	r25, 0x027A
     8d0:	2a 81       	ldd	r18, Y+2	; 0x02
     8d2:	3b 81       	ldd	r19, Y+3	; 0x03
     8d4:	82 17       	cp	r24, r18
     8d6:	93 07       	cpc	r25, r19
     8d8:	c0 f4       	brcc	.+48     	; 0x90a <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
     8da:	81 e0       	ldi	r24, 0x01	; 1
     8dc:	89 83       	std	Y+1, r24	; 0x01
     8de:	15 c0       	rjmp	.+42     	; 0x90a <vTaskDelayUntil+0xa6>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
     8e0:	8d 81       	ldd	r24, Y+5	; 0x05
     8e2:	9e 81       	ldd	r25, Y+6	; 0x06
     8e4:	fc 01       	movw	r30, r24
     8e6:	20 81       	ld	r18, Z
     8e8:	31 81       	ldd	r19, Z+1	; 0x01
     8ea:	8a 81       	ldd	r24, Y+2	; 0x02
     8ec:	9b 81       	ldd	r25, Y+3	; 0x03
     8ee:	82 17       	cp	r24, r18
     8f0:	93 07       	cpc	r25, r19
     8f2:	48 f0       	brcs	.+18     	; 0x906 <vTaskDelayUntil+0xa2>
     8f4:	80 91 79 02 	lds	r24, 0x0279
     8f8:	90 91 7a 02 	lds	r25, 0x027A
     8fc:	2a 81       	ldd	r18, Y+2	; 0x02
     8fe:	3b 81       	ldd	r19, Y+3	; 0x03
     900:	82 17       	cp	r24, r18
     902:	93 07       	cpc	r25, r19
     904:	10 f4       	brcc	.+4      	; 0x90a <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
     906:	81 e0       	ldi	r24, 0x01	; 1
     908:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     90a:	8d 81       	ldd	r24, Y+5	; 0x05
     90c:	9e 81       	ldd	r25, Y+6	; 0x06
     90e:	2a 81       	ldd	r18, Y+2	; 0x02
     910:	3b 81       	ldd	r19, Y+3	; 0x03
     912:	fc 01       	movw	r30, r24
     914:	31 83       	std	Z+1, r19	; 0x01
     916:	20 83       	st	Z, r18

			if( xShouldDelay != pdFALSE )
     918:	89 81       	ldd	r24, Y+1	; 0x01
     91a:	88 23       	and	r24, r24
     91c:	59 f0       	breq	.+22     	; 0x934 <vTaskDelayUntil+0xd0>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
     91e:	80 91 2a 02 	lds	r24, 0x022A
     922:	90 91 2b 02 	lds	r25, 0x022B
     926:	02 96       	adiw	r24, 0x02	; 2
     928:	0e 94 5e 13 	call	0x26bc	; 0x26bc <uxListRemove>
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
     92c:	8a 81       	ldd	r24, Y+2	; 0x02
     92e:	9b 81       	ldd	r25, Y+3	; 0x03
     930:	0e 94 a9 0a 	call	0x1552	; 0x1552 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     934:	0e 94 8b 06 	call	0xd16	; 0xd16 <xTaskResumeAll>
     938:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     93a:	8c 81       	ldd	r24, Y+4	; 0x04
     93c:	88 23       	and	r24, r24
     93e:	11 f4       	brne	.+4      	; 0x944 <vTaskDelayUntil+0xe0>
		{
			portYIELD_WITHIN_API();
     940:	0e 94 20 19 	call	0x3240	; 0x3240 <vPortYield>
		}
	}
     944:	28 96       	adiw	r28, 0x08	; 8
     946:	0f b6       	in	r0, 0x3f	; 63
     948:	f8 94       	cli
     94a:	de bf       	out	0x3e, r29	; 62
     94c:	0f be       	out	0x3f, r0	; 63
     94e:	cd bf       	out	0x3d, r28	; 61
     950:	df 91       	pop	r29
     952:	cf 91       	pop	r28
     954:	08 95       	ret

00000956 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
     956:	cf 93       	push	r28
     958:	df 93       	push	r29
     95a:	00 d0       	rcall	.+0      	; 0x95c <vTaskDelay+0x6>
     95c:	1f 92       	push	r1
     95e:	1f 92       	push	r1
     960:	cd b7       	in	r28, 0x3d	; 61
     962:	de b7       	in	r29, 0x3e	; 62
     964:	9d 83       	std	Y+5, r25	; 0x05
     966:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
     968:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
     96a:	8c 81       	ldd	r24, Y+4	; 0x04
     96c:	9d 81       	ldd	r25, Y+5	; 0x05
     96e:	00 97       	sbiw	r24, 0x00	; 0
     970:	d1 f0       	breq	.+52     	; 0x9a6 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
     972:	0e 94 7f 06 	call	0xcfe	; 0xcfe <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
     976:	20 91 79 02 	lds	r18, 0x0279
     97a:	30 91 7a 02 	lds	r19, 0x027A
     97e:	8c 81       	ldd	r24, Y+4	; 0x04
     980:	9d 81       	ldd	r25, Y+5	; 0x05
     982:	82 0f       	add	r24, r18
     984:	93 1f       	adc	r25, r19
     986:	9b 83       	std	Y+3, r25	; 0x03
     988:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
     98a:	80 91 2a 02 	lds	r24, 0x022A
     98e:	90 91 2b 02 	lds	r25, 0x022B
     992:	02 96       	adiw	r24, 0x02	; 2
     994:	0e 94 5e 13 	call	0x26bc	; 0x26bc <uxListRemove>
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
     998:	8a 81       	ldd	r24, Y+2	; 0x02
     99a:	9b 81       	ldd	r25, Y+3	; 0x03
     99c:	0e 94 a9 0a 	call	0x1552	; 0x1552 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     9a0:	0e 94 8b 06 	call	0xd16	; 0xd16 <xTaskResumeAll>
     9a4:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     9a6:	89 81       	ldd	r24, Y+1	; 0x01
     9a8:	88 23       	and	r24, r24
     9aa:	11 f4       	brne	.+4      	; 0x9b0 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
     9ac:	0e 94 20 19 	call	0x3240	; 0x3240 <vPortYield>
		}
	}
     9b0:	0f 90       	pop	r0
     9b2:	0f 90       	pop	r0
     9b4:	0f 90       	pop	r0
     9b6:	0f 90       	pop	r0
     9b8:	0f 90       	pop	r0
     9ba:	df 91       	pop	r29
     9bc:	cf 91       	pop	r28
     9be:	08 95       	ret

000009c0 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
     9c0:	cf 93       	push	r28
     9c2:	df 93       	push	r29
     9c4:	00 d0       	rcall	.+0      	; 0x9c6 <vTaskSuspend+0x6>
     9c6:	1f 92       	push	r1
     9c8:	cd b7       	in	r28, 0x3d	; 61
     9ca:	de b7       	in	r29, 0x3e	; 62
     9cc:	9c 83       	std	Y+4, r25	; 0x04
     9ce:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
     9d0:	0f b6       	in	r0, 0x3f	; 63
     9d2:	f8 94       	cli
     9d4:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
     9d6:	80 91 2a 02 	lds	r24, 0x022A
     9da:	90 91 2b 02 	lds	r25, 0x022B
     9de:	2b 81       	ldd	r18, Y+3	; 0x03
     9e0:	3c 81       	ldd	r19, Y+4	; 0x04
     9e2:	28 17       	cp	r18, r24
     9e4:	39 07       	cpc	r19, r25
     9e6:	11 f4       	brne	.+4      	; 0x9ec <vTaskSuspend+0x2c>
			{
				pxTaskToSuspend = NULL;
     9e8:	1c 82       	std	Y+4, r1	; 0x04
     9ea:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
     9ec:	8b 81       	ldd	r24, Y+3	; 0x03
     9ee:	9c 81       	ldd	r25, Y+4	; 0x04
     9f0:	00 97       	sbiw	r24, 0x00	; 0
     9f2:	29 f4       	brne	.+10     	; 0x9fe <vTaskSuspend+0x3e>
     9f4:	80 91 2a 02 	lds	r24, 0x022A
     9f8:	90 91 2b 02 	lds	r25, 0x022B
     9fc:	02 c0       	rjmp	.+4      	; 0xa02 <vTaskSuspend+0x42>
     9fe:	8b 81       	ldd	r24, Y+3	; 0x03
     a00:	9c 81       	ldd	r25, Y+4	; 0x04
     a02:	9a 83       	std	Y+2, r25	; 0x02
     a04:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
     a06:	89 81       	ldd	r24, Y+1	; 0x01
     a08:	9a 81       	ldd	r25, Y+2	; 0x02
     a0a:	02 96       	adiw	r24, 0x02	; 2
     a0c:	0e 94 5e 13 	call	0x26bc	; 0x26bc <uxListRemove>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
			}

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
     a10:	89 81       	ldd	r24, Y+1	; 0x01
     a12:	9a 81       	ldd	r25, Y+2	; 0x02
     a14:	fc 01       	movw	r30, r24
     a16:	84 89       	ldd	r24, Z+20	; 0x14
     a18:	95 89       	ldd	r25, Z+21	; 0x15
     a1a:	00 97       	sbiw	r24, 0x00	; 0
     a1c:	29 f0       	breq	.+10     	; 0xa28 <vTaskSuspend+0x68>
			{
				uxListRemove( &( pxTCB->xEventListItem ) );
     a1e:	89 81       	ldd	r24, Y+1	; 0x01
     a20:	9a 81       	ldd	r25, Y+2	; 0x02
     a22:	0c 96       	adiw	r24, 0x0c	; 12
     a24:	0e 94 5e 13 	call	0x26bc	; 0x26bc <uxListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
     a28:	89 81       	ldd	r24, Y+1	; 0x01
     a2a:	9a 81       	ldd	r25, Y+2	; 0x02
     a2c:	02 96       	adiw	r24, 0x02	; 2
     a2e:	bc 01       	movw	r22, r24
     a30:	8f e6       	ldi	r24, 0x6F	; 111
     a32:	92 e0       	ldi	r25, 0x02	; 2
     a34:	0e 94 8e 12 	call	0x251c	; 0x251c <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
     a38:	0f 90       	pop	r0
     a3a:	0f be       	out	0x3f, r0	; 63

		if( ( void * ) pxTaskToSuspend == NULL )
     a3c:	8b 81       	ldd	r24, Y+3	; 0x03
     a3e:	9c 81       	ldd	r25, Y+4	; 0x04
     a40:	00 97       	sbiw	r24, 0x00	; 0
     a42:	a1 f4       	brne	.+40     	; 0xa6c <vTaskSuspend+0xac>
		{
			if( xSchedulerRunning != pdFALSE )
     a44:	80 91 7d 02 	lds	r24, 0x027D
     a48:	88 23       	and	r24, r24
     a4a:	19 f0       	breq	.+6      	; 0xa52 <vTaskSuspend+0x92>
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
     a4c:	0e 94 20 19 	call	0x3240	; 0x3240 <vPortYield>
     a50:	0d c0       	rjmp	.+26     	; 0xa6c <vTaskSuspend+0xac>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
     a52:	90 91 6f 02 	lds	r25, 0x026F
     a56:	80 91 78 02 	lds	r24, 0x0278
     a5a:	98 17       	cp	r25, r24
     a5c:	29 f4       	brne	.+10     	; 0xa68 <vTaskSuspend+0xa8>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
     a5e:	10 92 2b 02 	sts	0x022B, r1
     a62:	10 92 2a 02 	sts	0x022A, r1
     a66:	02 c0       	rjmp	.+4      	; 0xa6c <vTaskSuspend+0xac>
				}
				else
				{
					vTaskSwitchContext();
     a68:	0e 94 21 08 	call	0x1042	; 0x1042 <vTaskSwitchContext>
				}
			}
		}
	}
     a6c:	0f 90       	pop	r0
     a6e:	0f 90       	pop	r0
     a70:	0f 90       	pop	r0
     a72:	0f 90       	pop	r0
     a74:	df 91       	pop	r29
     a76:	cf 91       	pop	r28
     a78:	08 95       	ret

00000a7a <xTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
     a7a:	cf 93       	push	r28
     a7c:	df 93       	push	r29
     a7e:	00 d0       	rcall	.+0      	; 0xa80 <xTaskIsTaskSuspended+0x6>
     a80:	1f 92       	push	r1
     a82:	1f 92       	push	r1
     a84:	cd b7       	in	r28, 0x3d	; 61
     a86:	de b7       	in	r29, 0x3e	; 62
     a88:	9d 83       	std	Y+5, r25	; 0x05
     a8a:	8c 83       	std	Y+4, r24	; 0x04
	portBASE_TYPE xReturn = pdFALSE;
     a8c:	19 82       	std	Y+1, r1	; 0x01
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
     a8e:	8c 81       	ldd	r24, Y+4	; 0x04
     a90:	9d 81       	ldd	r25, Y+5	; 0x05
     a92:	9b 83       	std	Y+3, r25	; 0x03
     a94:	8a 83       	std	Y+2, r24	; 0x02
		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
     a96:	8a 81       	ldd	r24, Y+2	; 0x02
     a98:	9b 81       	ldd	r25, Y+3	; 0x03
     a9a:	fc 01       	movw	r30, r24
     a9c:	82 85       	ldd	r24, Z+10	; 0x0a
     a9e:	93 85       	ldd	r25, Z+11	; 0x0b
     aa0:	f2 e0       	ldi	r31, 0x02	; 2
     aa2:	8f 36       	cpi	r24, 0x6F	; 111
     aa4:	9f 07       	cpc	r25, r31
     aa6:	91 f4       	brne	.+36     	; 0xacc <xTaskIsTaskSuspended+0x52>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
     aa8:	8a 81       	ldd	r24, Y+2	; 0x02
     aaa:	9b 81       	ldd	r25, Y+3	; 0x03
     aac:	fc 01       	movw	r30, r24
     aae:	84 89       	ldd	r24, Z+20	; 0x14
     ab0:	95 89       	ldd	r25, Z+21	; 0x15
     ab2:	f2 e0       	ldi	r31, 0x02	; 2
     ab4:	86 36       	cpi	r24, 0x66	; 102
     ab6:	9f 07       	cpc	r25, r31
     ab8:	49 f0       	breq	.+18     	; 0xacc <xTaskIsTaskSuspended+0x52>
			{
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
     aba:	8a 81       	ldd	r24, Y+2	; 0x02
     abc:	9b 81       	ldd	r25, Y+3	; 0x03
     abe:	fc 01       	movw	r30, r24
     ac0:	84 89       	ldd	r24, Z+20	; 0x14
     ac2:	95 89       	ldd	r25, Z+21	; 0x15
     ac4:	00 97       	sbiw	r24, 0x00	; 0
     ac6:	11 f4       	brne	.+4      	; 0xacc <xTaskIsTaskSuspended+0x52>
				{
					xReturn = pdTRUE;
     ac8:	81 e0       	ldi	r24, 0x01	; 1
     aca:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}

		return xReturn;
     acc:	89 81       	ldd	r24, Y+1	; 0x01
	}
     ace:	0f 90       	pop	r0
     ad0:	0f 90       	pop	r0
     ad2:	0f 90       	pop	r0
     ad4:	0f 90       	pop	r0
     ad6:	0f 90       	pop	r0
     ad8:	df 91       	pop	r29
     ada:	cf 91       	pop	r28
     adc:	08 95       	ret

00000ade <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
     ade:	cf 93       	push	r28
     ae0:	df 93       	push	r29
     ae2:	00 d0       	rcall	.+0      	; 0xae4 <vTaskResume+0x6>
     ae4:	1f 92       	push	r1
     ae6:	cd b7       	in	r28, 0x3d	; 61
     ae8:	de b7       	in	r29, 0x3e	; 62
     aea:	9c 83       	std	Y+4, r25	; 0x04
     aec:	8b 83       	std	Y+3, r24	; 0x03
		/* It does not make sense to resume the calling task. */
		configASSERT( pxTaskToResume );

		/* Remove the task from whichever list it is currently in, and place
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;
     aee:	8b 81       	ldd	r24, Y+3	; 0x03
     af0:	9c 81       	ldd	r25, Y+4	; 0x04
     af2:	9a 83       	std	Y+2, r25	; 0x02
     af4:	89 83       	std	Y+1, r24	; 0x01

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
     af6:	89 81       	ldd	r24, Y+1	; 0x01
     af8:	9a 81       	ldd	r25, Y+2	; 0x02
     afa:	00 97       	sbiw	r24, 0x00	; 0
     afc:	09 f4       	brne	.+2      	; 0xb00 <vTaskResume+0x22>
     afe:	4f c0       	rjmp	.+158    	; 0xb9e <vTaskResume+0xc0>
     b00:	80 91 2a 02 	lds	r24, 0x022A
     b04:	90 91 2b 02 	lds	r25, 0x022B
     b08:	29 81       	ldd	r18, Y+1	; 0x01
     b0a:	3a 81       	ldd	r19, Y+2	; 0x02
     b0c:	28 17       	cp	r18, r24
     b0e:	39 07       	cpc	r19, r25
     b10:	09 f4       	brne	.+2      	; 0xb14 <vTaskResume+0x36>
     b12:	45 c0       	rjmp	.+138    	; 0xb9e <vTaskResume+0xc0>
		{
			taskENTER_CRITICAL();
     b14:	0f b6       	in	r0, 0x3f	; 63
     b16:	f8 94       	cli
     b18:	0f 92       	push	r0
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
     b1a:	89 81       	ldd	r24, Y+1	; 0x01
     b1c:	9a 81       	ldd	r25, Y+2	; 0x02
     b1e:	0e 94 3d 05 	call	0xa7a	; 0xa7a <xTaskIsTaskSuspended>
     b22:	81 30       	cpi	r24, 0x01	; 1
     b24:	d1 f5       	brne	.+116    	; 0xb9a <vTaskResume+0xbc>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					uxListRemove(  &( pxTCB->xGenericListItem ) );
     b26:	89 81       	ldd	r24, Y+1	; 0x01
     b28:	9a 81       	ldd	r25, Y+2	; 0x02
     b2a:	02 96       	adiw	r24, 0x02	; 2
     b2c:	0e 94 5e 13 	call	0x26bc	; 0x26bc <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
     b30:	89 81       	ldd	r24, Y+1	; 0x01
     b32:	9a 81       	ldd	r25, Y+2	; 0x02
     b34:	fc 01       	movw	r30, r24
     b36:	96 89       	ldd	r25, Z+22	; 0x16
     b38:	80 91 7c 02 	lds	r24, 0x027C
     b3c:	89 17       	cp	r24, r25
     b3e:	30 f4       	brcc	.+12     	; 0xb4c <vTaskResume+0x6e>
     b40:	89 81       	ldd	r24, Y+1	; 0x01
     b42:	9a 81       	ldd	r25, Y+2	; 0x02
     b44:	fc 01       	movw	r30, r24
     b46:	86 89       	ldd	r24, Z+22	; 0x16
     b48:	80 93 7c 02 	sts	0x027C, r24
     b4c:	89 81       	ldd	r24, Y+1	; 0x01
     b4e:	9a 81       	ldd	r25, Y+2	; 0x02
     b50:	ac 01       	movw	r20, r24
     b52:	4e 5f       	subi	r20, 0xFE	; 254
     b54:	5f 4f       	sbci	r21, 0xFF	; 255
     b56:	89 81       	ldd	r24, Y+1	; 0x01
     b58:	9a 81       	ldd	r25, Y+2	; 0x02
     b5a:	fc 01       	movw	r30, r24
     b5c:	86 89       	ldd	r24, Z+22	; 0x16
     b5e:	28 2f       	mov	r18, r24
     b60:	30 e0       	ldi	r19, 0x00	; 0
     b62:	c9 01       	movw	r24, r18
     b64:	88 0f       	add	r24, r24
     b66:	99 1f       	adc	r25, r25
     b68:	88 0f       	add	r24, r24
     b6a:	99 1f       	adc	r25, r25
     b6c:	88 0f       	add	r24, r24
     b6e:	99 1f       	adc	r25, r25
     b70:	82 0f       	add	r24, r18
     b72:	93 1f       	adc	r25, r19
     b74:	84 5d       	subi	r24, 0xD4	; 212
     b76:	9d 4f       	sbci	r25, 0xFD	; 253
     b78:	ba 01       	movw	r22, r20
     b7a:	0e 94 8e 12 	call	0x251c	; 0x251c <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     b7e:	89 81       	ldd	r24, Y+1	; 0x01
     b80:	9a 81       	ldd	r25, Y+2	; 0x02
     b82:	fc 01       	movw	r30, r24
     b84:	26 89       	ldd	r18, Z+22	; 0x16
     b86:	80 91 2a 02 	lds	r24, 0x022A
     b8a:	90 91 2b 02 	lds	r25, 0x022B
     b8e:	fc 01       	movw	r30, r24
     b90:	86 89       	ldd	r24, Z+22	; 0x16
     b92:	28 17       	cp	r18, r24
     b94:	10 f0       	brcs	.+4      	; 0xb9a <vTaskResume+0xbc>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
     b96:	0e 94 20 19 	call	0x3240	; 0x3240 <vPortYield>
					}
				}
			}
			taskEXIT_CRITICAL();
     b9a:	0f 90       	pop	r0
     b9c:	0f be       	out	0x3f, r0	; 63
		}
	}
     b9e:	0f 90       	pop	r0
     ba0:	0f 90       	pop	r0
     ba2:	0f 90       	pop	r0
     ba4:	0f 90       	pop	r0
     ba6:	df 91       	pop	r29
     ba8:	cf 91       	pop	r28
     baa:	08 95       	ret

00000bac <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
     bac:	cf 93       	push	r28
     bae:	df 93       	push	r29
     bb0:	00 d0       	rcall	.+0      	; 0xbb2 <xTaskResumeFromISR+0x6>
     bb2:	00 d0       	rcall	.+0      	; 0xbb4 <xTaskResumeFromISR+0x8>
     bb4:	cd b7       	in	r28, 0x3d	; 61
     bb6:	de b7       	in	r29, 0x3e	; 62
     bb8:	9e 83       	std	Y+6, r25	; 0x06
     bba:	8d 83       	std	Y+5, r24	; 0x05
	portBASE_TYPE xYieldRequired = pdFALSE;
     bbc:	19 82       	std	Y+1, r1	; 0x01
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxSavedInterruptStatus;

		configASSERT( pxTaskToResume );

		pxTCB = ( tskTCB * ) pxTaskToResume;
     bbe:	8d 81       	ldd	r24, Y+5	; 0x05
     bc0:	9e 81       	ldd	r25, Y+6	; 0x06
     bc2:	9b 83       	std	Y+3, r25	; 0x03
     bc4:	8a 83       	std	Y+2, r24	; 0x02

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     bc6:	1c 82       	std	Y+4, r1	; 0x04
		{
			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
     bc8:	8a 81       	ldd	r24, Y+2	; 0x02
     bca:	9b 81       	ldd	r25, Y+3	; 0x03
     bcc:	0e 94 3d 05 	call	0xa7a	; 0xa7a <xTaskIsTaskSuspended>
     bd0:	81 30       	cpi	r24, 0x01	; 1
     bd2:	09 f0       	breq	.+2      	; 0xbd6 <xTaskResumeFromISR+0x2a>
     bd4:	48 c0       	rjmp	.+144    	; 0xc66 <xTaskResumeFromISR+0xba>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     bd6:	80 91 7e 02 	lds	r24, 0x027E
     bda:	88 23       	and	r24, r24
     bdc:	e1 f5       	brne	.+120    	; 0xc56 <xTaskResumeFromISR+0xaa>
				{
					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
     bde:	8a 81       	ldd	r24, Y+2	; 0x02
     be0:	9b 81       	ldd	r25, Y+3	; 0x03
     be2:	fc 01       	movw	r30, r24
     be4:	26 89       	ldd	r18, Z+22	; 0x16
     be6:	80 91 2a 02 	lds	r24, 0x022A
     bea:	90 91 2b 02 	lds	r25, 0x022B
     bee:	fc 01       	movw	r30, r24
     bf0:	96 89       	ldd	r25, Z+22	; 0x16
     bf2:	81 e0       	ldi	r24, 0x01	; 1
     bf4:	29 17       	cp	r18, r25
     bf6:	08 f4       	brcc	.+2      	; 0xbfa <xTaskResumeFromISR+0x4e>
     bf8:	80 e0       	ldi	r24, 0x00	; 0
     bfa:	89 83       	std	Y+1, r24	; 0x01
					uxListRemove(  &( pxTCB->xGenericListItem ) );
     bfc:	8a 81       	ldd	r24, Y+2	; 0x02
     bfe:	9b 81       	ldd	r25, Y+3	; 0x03
     c00:	02 96       	adiw	r24, 0x02	; 2
     c02:	0e 94 5e 13 	call	0x26bc	; 0x26bc <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
     c06:	8a 81       	ldd	r24, Y+2	; 0x02
     c08:	9b 81       	ldd	r25, Y+3	; 0x03
     c0a:	fc 01       	movw	r30, r24
     c0c:	96 89       	ldd	r25, Z+22	; 0x16
     c0e:	80 91 7c 02 	lds	r24, 0x027C
     c12:	89 17       	cp	r24, r25
     c14:	30 f4       	brcc	.+12     	; 0xc22 <xTaskResumeFromISR+0x76>
     c16:	8a 81       	ldd	r24, Y+2	; 0x02
     c18:	9b 81       	ldd	r25, Y+3	; 0x03
     c1a:	fc 01       	movw	r30, r24
     c1c:	86 89       	ldd	r24, Z+22	; 0x16
     c1e:	80 93 7c 02 	sts	0x027C, r24
     c22:	8a 81       	ldd	r24, Y+2	; 0x02
     c24:	9b 81       	ldd	r25, Y+3	; 0x03
     c26:	ac 01       	movw	r20, r24
     c28:	4e 5f       	subi	r20, 0xFE	; 254
     c2a:	5f 4f       	sbci	r21, 0xFF	; 255
     c2c:	8a 81       	ldd	r24, Y+2	; 0x02
     c2e:	9b 81       	ldd	r25, Y+3	; 0x03
     c30:	fc 01       	movw	r30, r24
     c32:	86 89       	ldd	r24, Z+22	; 0x16
     c34:	28 2f       	mov	r18, r24
     c36:	30 e0       	ldi	r19, 0x00	; 0
     c38:	c9 01       	movw	r24, r18
     c3a:	88 0f       	add	r24, r24
     c3c:	99 1f       	adc	r25, r25
     c3e:	88 0f       	add	r24, r24
     c40:	99 1f       	adc	r25, r25
     c42:	88 0f       	add	r24, r24
     c44:	99 1f       	adc	r25, r25
     c46:	82 0f       	add	r24, r18
     c48:	93 1f       	adc	r25, r19
     c4a:	84 5d       	subi	r24, 0xD4	; 212
     c4c:	9d 4f       	sbci	r25, 0xFD	; 253
     c4e:	ba 01       	movw	r22, r20
     c50:	0e 94 8e 12 	call	0x251c	; 0x251c <vListInsertEnd>
     c54:	08 c0       	rjmp	.+16     	; 0xc66 <xTaskResumeFromISR+0xba>
				else
				{
					/* We cannot access the delayed or ready lists, so will hold this
					task pending until the scheduler is resumed, at which point a
					yield will be performed if necessary. */
					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
     c56:	8a 81       	ldd	r24, Y+2	; 0x02
     c58:	9b 81       	ldd	r25, Y+3	; 0x03
     c5a:	0c 96       	adiw	r24, 0x0c	; 12
     c5c:	bc 01       	movw	r22, r24
     c5e:	86 e6       	ldi	r24, 0x66	; 102
     c60:	92 e0       	ldi	r25, 0x02	; 2
     c62:	0e 94 8e 12 	call	0x251c	; 0x251c <vListInsertEnd>
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
     c66:	89 81       	ldd	r24, Y+1	; 0x01
	}
     c68:	26 96       	adiw	r28, 0x06	; 6
     c6a:	0f b6       	in	r0, 0x3f	; 63
     c6c:	f8 94       	cli
     c6e:	de bf       	out	0x3e, r29	; 62
     c70:	0f be       	out	0x3f, r0	; 63
     c72:	cd bf       	out	0x3d, r28	; 61
     c74:	df 91       	pop	r29
     c76:	cf 91       	pop	r28
     c78:	08 95       	ret

00000c7a <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
     c7a:	af 92       	push	r10
     c7c:	bf 92       	push	r11
     c7e:	cf 92       	push	r12
     c80:	df 92       	push	r13
     c82:	ef 92       	push	r14
     c84:	ff 92       	push	r15
     c86:	0f 93       	push	r16
     c88:	cf 93       	push	r28
     c8a:	df 93       	push	r29
     c8c:	1f 92       	push	r1
     c8e:	cd b7       	in	r28, 0x3d	; 61
     c90:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
     c92:	a1 2c       	mov	r10, r1
     c94:	b1 2c       	mov	r11, r1
     c96:	c1 2c       	mov	r12, r1
     c98:	d1 2c       	mov	r13, r1
     c9a:	e1 2c       	mov	r14, r1
     c9c:	f1 2c       	mov	r15, r1
     c9e:	00 e0       	ldi	r16, 0x00	; 0
     ca0:	20 e0       	ldi	r18, 0x00	; 0
     ca2:	30 e0       	ldi	r19, 0x00	; 0
     ca4:	45 e5       	ldi	r20, 0x55	; 85
     ca6:	50 e0       	ldi	r21, 0x00	; 0
     ca8:	6b e1       	ldi	r22, 0x1B	; 27
     caa:	72 e0       	ldi	r23, 0x02	; 2
     cac:	82 ef       	ldi	r24, 0xF2	; 242
     cae:	99 e0       	ldi	r25, 0x09	; 9
     cb0:	0e 94 3e 03 	call	0x67c	; 0x67c <xTaskGenericCreate>
     cb4:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
     cb6:	89 81       	ldd	r24, Y+1	; 0x01
     cb8:	81 30       	cpi	r24, 0x01	; 1
     cba:	51 f4       	brne	.+20     	; 0xcd0 <vTaskStartScheduler+0x56>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
     cbc:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
     cbe:	81 e0       	ldi	r24, 0x01	; 1
     cc0:	80 93 7d 02 	sts	0x027D, r24
		xTickCount = ( portTickType ) 0U;
     cc4:	10 92 7a 02 	sts	0x027A, r1
     cc8:	10 92 79 02 	sts	0x0279, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     ccc:	0e 94 e0 18 	call	0x31c0	; 0x31c0 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
     cd0:	0f 90       	pop	r0
     cd2:	df 91       	pop	r29
     cd4:	cf 91       	pop	r28
     cd6:	0f 91       	pop	r16
     cd8:	ff 90       	pop	r15
     cda:	ef 90       	pop	r14
     cdc:	df 90       	pop	r13
     cde:	cf 90       	pop	r12
     ce0:	bf 90       	pop	r11
     ce2:	af 90       	pop	r10
     ce4:	08 95       	ret

00000ce6 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
     ce6:	cf 93       	push	r28
     ce8:	df 93       	push	r29
     cea:	cd b7       	in	r28, 0x3d	; 61
     cec:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
     cee:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
     cf0:	10 92 7d 02 	sts	0x027D, r1
	vPortEndScheduler();
     cf4:	0e 94 19 19 	call	0x3232	; 0x3232 <vPortEndScheduler>
}
     cf8:	df 91       	pop	r29
     cfa:	cf 91       	pop	r28
     cfc:	08 95       	ret

00000cfe <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
     cfe:	cf 93       	push	r28
     d00:	df 93       	push	r29
     d02:	cd b7       	in	r28, 0x3d	; 61
     d04:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
     d06:	80 91 7e 02 	lds	r24, 0x027E
     d0a:	8f 5f       	subi	r24, 0xFF	; 255
     d0c:	80 93 7e 02 	sts	0x027E, r24
}
     d10:	df 91       	pop	r29
     d12:	cf 91       	pop	r28
     d14:	08 95       	ret

00000d16 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE != 0  */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
     d16:	0f 93       	push	r16
     d18:	1f 93       	push	r17
     d1a:	cf 93       	push	r28
     d1c:	df 93       	push	r29
     d1e:	1f 92       	push	r1
     d20:	1f 92       	push	r1
     d22:	cd b7       	in	r28, 0x3d	; 61
     d24:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
     d26:	19 82       	std	Y+1, r1	; 0x01
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     d28:	0f b6       	in	r0, 0x3f	; 63
     d2a:	f8 94       	cli
     d2c:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     d2e:	80 91 7e 02 	lds	r24, 0x027E
     d32:	81 50       	subi	r24, 0x01	; 1
     d34:	80 93 7e 02 	sts	0x027E, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     d38:	80 91 7e 02 	lds	r24, 0x027E
     d3c:	88 23       	and	r24, r24
     d3e:	09 f0       	breq	.+2      	; 0xd42 <xTaskResumeAll+0x2c>
     d40:	64 c0       	rjmp	.+200    	; 0xe0a <xTaskResumeAll+0xf4>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
     d42:	80 91 78 02 	lds	r24, 0x0278
     d46:	88 23       	and	r24, r24
     d48:	09 f4       	brne	.+2      	; 0xd4c <xTaskResumeAll+0x36>
     d4a:	5f c0       	rjmp	.+190    	; 0xe0a <xTaskResumeAll+0xf4>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
     d4c:	1a 82       	std	Y+2, r1	; 0x02

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
     d4e:	3a c0       	rjmp	.+116    	; 0xdc4 <xTaskResumeAll+0xae>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
     d50:	80 91 6b 02 	lds	r24, 0x026B
     d54:	90 91 6c 02 	lds	r25, 0x026C
     d58:	fc 01       	movw	r30, r24
     d5a:	06 81       	ldd	r16, Z+6	; 0x06
     d5c:	17 81       	ldd	r17, Z+7	; 0x07
					uxListRemove( &( pxTCB->xEventListItem ) );
     d5e:	c8 01       	movw	r24, r16
     d60:	0c 96       	adiw	r24, 0x0c	; 12
     d62:	0e 94 5e 13 	call	0x26bc	; 0x26bc <uxListRemove>
					uxListRemove( &( pxTCB->xGenericListItem ) );
     d66:	c8 01       	movw	r24, r16
     d68:	02 96       	adiw	r24, 0x02	; 2
     d6a:	0e 94 5e 13 	call	0x26bc	; 0x26bc <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
     d6e:	f8 01       	movw	r30, r16
     d70:	96 89       	ldd	r25, Z+22	; 0x16
     d72:	80 91 7c 02 	lds	r24, 0x027C
     d76:	89 17       	cp	r24, r25
     d78:	20 f4       	brcc	.+8      	; 0xd82 <xTaskResumeAll+0x6c>
     d7a:	f8 01       	movw	r30, r16
     d7c:	86 89       	ldd	r24, Z+22	; 0x16
     d7e:	80 93 7c 02 	sts	0x027C, r24
     d82:	a8 01       	movw	r20, r16
     d84:	4e 5f       	subi	r20, 0xFE	; 254
     d86:	5f 4f       	sbci	r21, 0xFF	; 255
     d88:	f8 01       	movw	r30, r16
     d8a:	86 89       	ldd	r24, Z+22	; 0x16
     d8c:	28 2f       	mov	r18, r24
     d8e:	30 e0       	ldi	r19, 0x00	; 0
     d90:	c9 01       	movw	r24, r18
     d92:	88 0f       	add	r24, r24
     d94:	99 1f       	adc	r25, r25
     d96:	88 0f       	add	r24, r24
     d98:	99 1f       	adc	r25, r25
     d9a:	88 0f       	add	r24, r24
     d9c:	99 1f       	adc	r25, r25
     d9e:	82 0f       	add	r24, r18
     da0:	93 1f       	adc	r25, r19
     da2:	84 5d       	subi	r24, 0xD4	; 212
     da4:	9d 4f       	sbci	r25, 0xFD	; 253
     da6:	ba 01       	movw	r22, r20
     da8:	0e 94 8e 12 	call	0x251c	; 0x251c <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     dac:	f8 01       	movw	r30, r16
     dae:	26 89       	ldd	r18, Z+22	; 0x16
     db0:	80 91 2a 02 	lds	r24, 0x022A
     db4:	90 91 2b 02 	lds	r25, 0x022B
     db8:	fc 01       	movw	r30, r24
     dba:	86 89       	ldd	r24, Z+22	; 0x16
     dbc:	28 17       	cp	r18, r24
     dbe:	10 f0       	brcs	.+4      	; 0xdc4 <xTaskResumeAll+0xae>
					{
						xYieldRequired = pdTRUE;
     dc0:	81 e0       	ldi	r24, 0x01	; 1
     dc2:	8a 83       	std	Y+2, r24	; 0x02
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
     dc4:	80 91 66 02 	lds	r24, 0x0266
     dc8:	88 23       	and	r24, r24
     dca:	11 f6       	brne	.-124    	; 0xd50 <xTaskResumeAll+0x3a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
     dcc:	80 91 7f 02 	lds	r24, 0x027F
     dd0:	88 23       	and	r24, r24
     dd2:	71 f0       	breq	.+28     	; 0xdf0 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
     dd4:	07 c0       	rjmp	.+14     	; 0xde4 <xTaskResumeAll+0xce>
					{
						vTaskIncrementTick();
     dd6:	0e 94 44 07 	call	0xe88	; 0xe88 <vTaskIncrementTick>
						--uxMissedTicks;
     dda:	80 91 7f 02 	lds	r24, 0x027F
     dde:	81 50       	subi	r24, 0x01	; 1
     de0:	80 93 7f 02 	sts	0x027F, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
     de4:	80 91 7f 02 	lds	r24, 0x027F
     de8:	88 23       	and	r24, r24
     dea:	a9 f7       	brne	.-22     	; 0xdd6 <xTaskResumeAll+0xc0>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
     dec:	81 e0       	ldi	r24, 0x01	; 1
     dee:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
     df0:	8a 81       	ldd	r24, Y+2	; 0x02
     df2:	81 30       	cpi	r24, 0x01	; 1
     df4:	21 f0       	breq	.+8      	; 0xdfe <xTaskResumeAll+0xe8>
     df6:	80 91 80 02 	lds	r24, 0x0280
     dfa:	81 30       	cpi	r24, 0x01	; 1
     dfc:	31 f4       	brne	.+12     	; 0xe0a <xTaskResumeAll+0xf4>
				{
					xAlreadyYielded = pdTRUE;
     dfe:	81 e0       	ldi	r24, 0x01	; 1
     e00:	89 83       	std	Y+1, r24	; 0x01
					xMissedYield = pdFALSE;
     e02:	10 92 80 02 	sts	0x0280, r1
					portYIELD_WITHIN_API();
     e06:	0e 94 20 19 	call	0x3240	; 0x3240 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
     e0a:	0f 90       	pop	r0
     e0c:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
     e0e:	89 81       	ldd	r24, Y+1	; 0x01
}
     e10:	0f 90       	pop	r0
     e12:	0f 90       	pop	r0
     e14:	df 91       	pop	r29
     e16:	cf 91       	pop	r28
     e18:	1f 91       	pop	r17
     e1a:	0f 91       	pop	r16
     e1c:	08 95       	ret

00000e1e <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
     e1e:	cf 93       	push	r28
     e20:	df 93       	push	r29
     e22:	1f 92       	push	r1
     e24:	1f 92       	push	r1
     e26:	cd b7       	in	r28, 0x3d	; 61
     e28:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
     e2a:	0f b6       	in	r0, 0x3f	; 63
     e2c:	f8 94       	cli
     e2e:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     e30:	80 91 79 02 	lds	r24, 0x0279
     e34:	90 91 7a 02 	lds	r25, 0x027A
     e38:	9a 83       	std	Y+2, r25	; 0x02
     e3a:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
     e3c:	0f 90       	pop	r0
     e3e:	0f be       	out	0x3f, r0	; 63

	return xTicks;
     e40:	89 81       	ldd	r24, Y+1	; 0x01
     e42:	9a 81       	ldd	r25, Y+2	; 0x02
}
     e44:	0f 90       	pop	r0
     e46:	0f 90       	pop	r0
     e48:	df 91       	pop	r29
     e4a:	cf 91       	pop	r28
     e4c:	08 95       	ret

00000e4e <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
     e4e:	cf 93       	push	r28
     e50:	df 93       	push	r29
     e52:	00 d0       	rcall	.+0      	; 0xe54 <xTaskGetTickCountFromISR+0x6>
     e54:	cd b7       	in	r28, 0x3d	; 61
     e56:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     e58:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
     e5a:	80 91 79 02 	lds	r24, 0x0279
     e5e:	90 91 7a 02 	lds	r25, 0x027A
     e62:	9b 83       	std	Y+3, r25	; 0x03
     e64:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
     e66:	8a 81       	ldd	r24, Y+2	; 0x02
     e68:	9b 81       	ldd	r25, Y+3	; 0x03
}
     e6a:	0f 90       	pop	r0
     e6c:	0f 90       	pop	r0
     e6e:	0f 90       	pop	r0
     e70:	df 91       	pop	r29
     e72:	cf 91       	pop	r28
     e74:	08 95       	ret

00000e76 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
     e76:	cf 93       	push	r28
     e78:	df 93       	push	r29
     e7a:	cd b7       	in	r28, 0x3d	; 61
     e7c:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
     e7e:	80 91 78 02 	lds	r24, 0x0278
}
     e82:	df 91       	pop	r29
     e84:	cf 91       	pop	r28
     e86:	08 95       	ret

00000e88 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
     e88:	cf 93       	push	r28
     e8a:	df 93       	push	r29
     e8c:	00 d0       	rcall	.+0      	; 0xe8e <vTaskIncrementTick+0x6>
     e8e:	00 d0       	rcall	.+0      	; 0xe90 <vTaskIncrementTick+0x8>
     e90:	cd b7       	in	r28, 0x3d	; 61
     e92:	de b7       	in	r29, 0x3e	; 62

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     e94:	80 91 7e 02 	lds	r24, 0x027E
     e98:	88 23       	and	r24, r24
     e9a:	09 f0       	breq	.+2      	; 0xe9e <vTaskIncrementTick+0x16>
     e9c:	c4 c0       	rjmp	.+392    	; 0x1026 <vTaskIncrementTick+0x19e>
	{
		++xTickCount;
     e9e:	80 91 79 02 	lds	r24, 0x0279
     ea2:	90 91 7a 02 	lds	r25, 0x027A
     ea6:	01 96       	adiw	r24, 0x01	; 1
     ea8:	90 93 7a 02 	sts	0x027A, r25
     eac:	80 93 79 02 	sts	0x0279, r24
		if( xTickCount == ( portTickType ) 0U )
     eb0:	80 91 79 02 	lds	r24, 0x0279
     eb4:	90 91 7a 02 	lds	r25, 0x027A
     eb8:	00 97       	sbiw	r24, 0x00	; 0
     eba:	e9 f5       	brne	.+122    	; 0xf36 <vTaskIncrementTick+0xae>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
     ebc:	80 91 62 02 	lds	r24, 0x0262
     ec0:	90 91 63 02 	lds	r25, 0x0263
     ec4:	9a 83       	std	Y+2, r25	; 0x02
     ec6:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedTaskList = pxOverflowDelayedTaskList;
     ec8:	80 91 64 02 	lds	r24, 0x0264
     ecc:	90 91 65 02 	lds	r25, 0x0265
     ed0:	90 93 63 02 	sts	0x0263, r25
     ed4:	80 93 62 02 	sts	0x0262, r24
			pxOverflowDelayedTaskList = pxTemp;
     ed8:	89 81       	ldd	r24, Y+1	; 0x01
     eda:	9a 81       	ldd	r25, Y+2	; 0x02
     edc:	90 93 65 02 	sts	0x0265, r25
     ee0:	80 93 64 02 	sts	0x0264, r24
			xNumOfOverflows++;
     ee4:	80 91 81 02 	lds	r24, 0x0281
     ee8:	8f 5f       	subi	r24, 0xFF	; 255
     eea:	80 93 81 02 	sts	0x0281, r24

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     eee:	80 91 62 02 	lds	r24, 0x0262
     ef2:	90 91 63 02 	lds	r25, 0x0263
     ef6:	fc 01       	movw	r30, r24
     ef8:	80 81       	ld	r24, Z
     efa:	88 23       	and	r24, r24
     efc:	39 f4       	brne	.+14     	; 0xf0c <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
     efe:	8f ef       	ldi	r24, 0xFF	; 255
     f00:	9f ef       	ldi	r25, 0xFF	; 255
     f02:	90 93 01 02 	sts	0x0201, r25
     f06:	80 93 00 02 	sts	0x0200, r24
     f0a:	15 c0       	rjmp	.+42     	; 0xf36 <vTaskIncrementTick+0xae>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     f0c:	80 91 62 02 	lds	r24, 0x0262
     f10:	90 91 63 02 	lds	r25, 0x0263
     f14:	fc 01       	movw	r30, r24
     f16:	85 81       	ldd	r24, Z+5	; 0x05
     f18:	96 81       	ldd	r25, Z+6	; 0x06
     f1a:	fc 01       	movw	r30, r24
     f1c:	86 81       	ldd	r24, Z+6	; 0x06
     f1e:	97 81       	ldd	r25, Z+7	; 0x07
     f20:	9c 83       	std	Y+4, r25	; 0x04
     f22:	8b 83       	std	Y+3, r24	; 0x03
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
     f24:	8b 81       	ldd	r24, Y+3	; 0x03
     f26:	9c 81       	ldd	r25, Y+4	; 0x04
     f28:	fc 01       	movw	r30, r24
     f2a:	82 81       	ldd	r24, Z+2	; 0x02
     f2c:	93 81       	ldd	r25, Z+3	; 0x03
     f2e:	90 93 01 02 	sts	0x0201, r25
     f32:	80 93 00 02 	sts	0x0200, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
     f36:	20 91 79 02 	lds	r18, 0x0279
     f3a:	30 91 7a 02 	lds	r19, 0x027A
     f3e:	80 91 00 02 	lds	r24, 0x0200
     f42:	90 91 01 02 	lds	r25, 0x0201
     f46:	28 17       	cp	r18, r24
     f48:	39 07       	cpc	r19, r25
     f4a:	08 f4       	brcc	.+2      	; 0xf4e <vTaskIncrementTick+0xc6>
     f4c:	6b c0       	rjmp	.+214    	; 0x1024 <vTaskIncrementTick+0x19c>
     f4e:	80 91 62 02 	lds	r24, 0x0262
     f52:	90 91 63 02 	lds	r25, 0x0263
     f56:	fc 01       	movw	r30, r24
     f58:	80 81       	ld	r24, Z
     f5a:	88 23       	and	r24, r24
     f5c:	39 f4       	brne	.+14     	; 0xf6c <vTaskIncrementTick+0xe4>
     f5e:	8f ef       	ldi	r24, 0xFF	; 255
     f60:	9f ef       	ldi	r25, 0xFF	; 255
     f62:	90 93 01 02 	sts	0x0201, r25
     f66:	80 93 00 02 	sts	0x0200, r24
     f6a:	5c c0       	rjmp	.+184    	; 0x1024 <vTaskIncrementTick+0x19c>
     f6c:	80 91 62 02 	lds	r24, 0x0262
     f70:	90 91 63 02 	lds	r25, 0x0263
     f74:	fc 01       	movw	r30, r24
     f76:	85 81       	ldd	r24, Z+5	; 0x05
     f78:	96 81       	ldd	r25, Z+6	; 0x06
     f7a:	fc 01       	movw	r30, r24
     f7c:	86 81       	ldd	r24, Z+6	; 0x06
     f7e:	97 81       	ldd	r25, Z+7	; 0x07
     f80:	9c 83       	std	Y+4, r25	; 0x04
     f82:	8b 83       	std	Y+3, r24	; 0x03
     f84:	8b 81       	ldd	r24, Y+3	; 0x03
     f86:	9c 81       	ldd	r25, Y+4	; 0x04
     f88:	fc 01       	movw	r30, r24
     f8a:	82 81       	ldd	r24, Z+2	; 0x02
     f8c:	93 81       	ldd	r25, Z+3	; 0x03
     f8e:	9e 83       	std	Y+6, r25	; 0x06
     f90:	8d 83       	std	Y+5, r24	; 0x05
     f92:	20 91 79 02 	lds	r18, 0x0279
     f96:	30 91 7a 02 	lds	r19, 0x027A
     f9a:	8d 81       	ldd	r24, Y+5	; 0x05
     f9c:	9e 81       	ldd	r25, Y+6	; 0x06
     f9e:	28 17       	cp	r18, r24
     fa0:	39 07       	cpc	r19, r25
     fa2:	38 f4       	brcc	.+14     	; 0xfb2 <vTaskIncrementTick+0x12a>
     fa4:	8d 81       	ldd	r24, Y+5	; 0x05
     fa6:	9e 81       	ldd	r25, Y+6	; 0x06
     fa8:	90 93 01 02 	sts	0x0201, r25
     fac:	80 93 00 02 	sts	0x0200, r24
     fb0:	39 c0       	rjmp	.+114    	; 0x1024 <vTaskIncrementTick+0x19c>
     fb2:	8b 81       	ldd	r24, Y+3	; 0x03
     fb4:	9c 81       	ldd	r25, Y+4	; 0x04
     fb6:	02 96       	adiw	r24, 0x02	; 2
     fb8:	0e 94 5e 13 	call	0x26bc	; 0x26bc <uxListRemove>
     fbc:	8b 81       	ldd	r24, Y+3	; 0x03
     fbe:	9c 81       	ldd	r25, Y+4	; 0x04
     fc0:	fc 01       	movw	r30, r24
     fc2:	84 89       	ldd	r24, Z+20	; 0x14
     fc4:	95 89       	ldd	r25, Z+21	; 0x15
     fc6:	00 97       	sbiw	r24, 0x00	; 0
     fc8:	29 f0       	breq	.+10     	; 0xfd4 <vTaskIncrementTick+0x14c>
     fca:	8b 81       	ldd	r24, Y+3	; 0x03
     fcc:	9c 81       	ldd	r25, Y+4	; 0x04
     fce:	0c 96       	adiw	r24, 0x0c	; 12
     fd0:	0e 94 5e 13 	call	0x26bc	; 0x26bc <uxListRemove>
     fd4:	8b 81       	ldd	r24, Y+3	; 0x03
     fd6:	9c 81       	ldd	r25, Y+4	; 0x04
     fd8:	fc 01       	movw	r30, r24
     fda:	96 89       	ldd	r25, Z+22	; 0x16
     fdc:	80 91 7c 02 	lds	r24, 0x027C
     fe0:	89 17       	cp	r24, r25
     fe2:	30 f4       	brcc	.+12     	; 0xff0 <vTaskIncrementTick+0x168>
     fe4:	8b 81       	ldd	r24, Y+3	; 0x03
     fe6:	9c 81       	ldd	r25, Y+4	; 0x04
     fe8:	fc 01       	movw	r30, r24
     fea:	86 89       	ldd	r24, Z+22	; 0x16
     fec:	80 93 7c 02 	sts	0x027C, r24
     ff0:	8b 81       	ldd	r24, Y+3	; 0x03
     ff2:	9c 81       	ldd	r25, Y+4	; 0x04
     ff4:	ac 01       	movw	r20, r24
     ff6:	4e 5f       	subi	r20, 0xFE	; 254
     ff8:	5f 4f       	sbci	r21, 0xFF	; 255
     ffa:	8b 81       	ldd	r24, Y+3	; 0x03
     ffc:	9c 81       	ldd	r25, Y+4	; 0x04
     ffe:	fc 01       	movw	r30, r24
    1000:	86 89       	ldd	r24, Z+22	; 0x16
    1002:	28 2f       	mov	r18, r24
    1004:	30 e0       	ldi	r19, 0x00	; 0
    1006:	c9 01       	movw	r24, r18
    1008:	88 0f       	add	r24, r24
    100a:	99 1f       	adc	r25, r25
    100c:	88 0f       	add	r24, r24
    100e:	99 1f       	adc	r25, r25
    1010:	88 0f       	add	r24, r24
    1012:	99 1f       	adc	r25, r25
    1014:	82 0f       	add	r24, r18
    1016:	93 1f       	adc	r25, r19
    1018:	84 5d       	subi	r24, 0xD4	; 212
    101a:	9d 4f       	sbci	r25, 0xFD	; 253
    101c:	ba 01       	movw	r22, r20
    101e:	0e 94 8e 12 	call	0x251c	; 0x251c <vListInsertEnd>
    1022:	95 cf       	rjmp	.-214    	; 0xf4e <vTaskIncrementTick+0xc6>
    1024:	05 c0       	rjmp	.+10     	; 0x1030 <vTaskIncrementTick+0x1a8>
	}
	else
	{
		++uxMissedTicks;
    1026:	80 91 7f 02 	lds	r24, 0x027F
    102a:	8f 5f       	subi	r24, 0xFF	; 255
    102c:	80 93 7f 02 	sts	0x027F, r24
		{
			vApplicationTickHook();
		}
	}
	#endif
}
    1030:	26 96       	adiw	r28, 0x06	; 6
    1032:	0f b6       	in	r0, 0x3f	; 63
    1034:	f8 94       	cli
    1036:	de bf       	out	0x3e, r29	; 62
    1038:	0f be       	out	0x3f, r0	; 63
    103a:	cd bf       	out	0x3d, r28	; 61
    103c:	df 91       	pop	r29
    103e:	cf 91       	pop	r28
    1040:	08 95       	ret

00001042 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    1042:	cf 93       	push	r28
    1044:	df 93       	push	r29
    1046:	1f 92       	push	r1
    1048:	1f 92       	push	r1
    104a:	cd b7       	in	r28, 0x3d	; 61
    104c:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    104e:	80 91 7e 02 	lds	r24, 0x027E
    1052:	88 23       	and	r24, r24
    1054:	21 f0       	breq	.+8      	; 0x105e <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    1056:	81 e0       	ldi	r24, 0x01	; 1
    1058:	80 93 80 02 	sts	0x0280, r24
    105c:	7a c0       	rjmp	.+244    	; 0x1152 <vTaskSwitchContext+0x110>
				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
				ulTaskSwitchedInTime = ulTempCounter;
		}
		#endif

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
    105e:	80 91 2a 02 	lds	r24, 0x022A
    1062:	90 91 2b 02 	lds	r25, 0x022B
    1066:	fc 01       	movw	r30, r24
    1068:	20 81       	ld	r18, Z
    106a:	31 81       	ldd	r19, Z+1	; 0x01
    106c:	80 91 2a 02 	lds	r24, 0x022A
    1070:	90 91 2b 02 	lds	r25, 0x022B
    1074:	fc 01       	movw	r30, r24
    1076:	87 89       	ldd	r24, Z+23	; 0x17
    1078:	90 8d       	ldd	r25, Z+24	; 0x18
    107a:	82 17       	cp	r24, r18
    107c:	93 07       	cpc	r25, r19
    107e:	70 f0       	brcs	.+28     	; 0x109c <vTaskSwitchContext+0x5a>
    1080:	80 91 2a 02 	lds	r24, 0x022A
    1084:	90 91 2b 02 	lds	r25, 0x022B
    1088:	9c 01       	movw	r18, r24
    108a:	27 5e       	subi	r18, 0xE7	; 231
    108c:	3f 4f       	sbci	r19, 0xFF	; 255
    108e:	80 91 2a 02 	lds	r24, 0x022A
    1092:	90 91 2b 02 	lds	r25, 0x022B
    1096:	b9 01       	movw	r22, r18
    1098:	0e 94 c3 00 	call	0x186	; 0x186 <vApplicationStackOverflowHook>
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
    109c:	05 c0       	rjmp	.+10     	; 0x10a8 <vTaskSwitchContext+0x66>
    109e:	80 91 7c 02 	lds	r24, 0x027C
    10a2:	81 50       	subi	r24, 0x01	; 1
    10a4:	80 93 7c 02 	sts	0x027C, r24
    10a8:	80 91 7c 02 	lds	r24, 0x027C
    10ac:	28 2f       	mov	r18, r24
    10ae:	30 e0       	ldi	r19, 0x00	; 0
    10b0:	c9 01       	movw	r24, r18
    10b2:	88 0f       	add	r24, r24
    10b4:	99 1f       	adc	r25, r25
    10b6:	88 0f       	add	r24, r24
    10b8:	99 1f       	adc	r25, r25
    10ba:	88 0f       	add	r24, r24
    10bc:	99 1f       	adc	r25, r25
    10be:	82 0f       	add	r24, r18
    10c0:	93 1f       	adc	r25, r19
    10c2:	84 5d       	subi	r24, 0xD4	; 212
    10c4:	9d 4f       	sbci	r25, 0xFD	; 253
    10c6:	fc 01       	movw	r30, r24
    10c8:	80 81       	ld	r24, Z
    10ca:	88 23       	and	r24, r24
    10cc:	41 f3       	breq	.-48     	; 0x109e <vTaskSwitchContext+0x5c>
    10ce:	80 91 7c 02 	lds	r24, 0x027C
    10d2:	28 2f       	mov	r18, r24
    10d4:	30 e0       	ldi	r19, 0x00	; 0
    10d6:	c9 01       	movw	r24, r18
    10d8:	88 0f       	add	r24, r24
    10da:	99 1f       	adc	r25, r25
    10dc:	88 0f       	add	r24, r24
    10de:	99 1f       	adc	r25, r25
    10e0:	88 0f       	add	r24, r24
    10e2:	99 1f       	adc	r25, r25
    10e4:	82 0f       	add	r24, r18
    10e6:	93 1f       	adc	r25, r19
    10e8:	84 5d       	subi	r24, 0xD4	; 212
    10ea:	9d 4f       	sbci	r25, 0xFD	; 253
    10ec:	9a 83       	std	Y+2, r25	; 0x02
    10ee:	89 83       	std	Y+1, r24	; 0x01
    10f0:	89 81       	ldd	r24, Y+1	; 0x01
    10f2:	9a 81       	ldd	r25, Y+2	; 0x02
    10f4:	fc 01       	movw	r30, r24
    10f6:	81 81       	ldd	r24, Z+1	; 0x01
    10f8:	92 81       	ldd	r25, Z+2	; 0x02
    10fa:	fc 01       	movw	r30, r24
    10fc:	22 81       	ldd	r18, Z+2	; 0x02
    10fe:	33 81       	ldd	r19, Z+3	; 0x03
    1100:	89 81       	ldd	r24, Y+1	; 0x01
    1102:	9a 81       	ldd	r25, Y+2	; 0x02
    1104:	fc 01       	movw	r30, r24
    1106:	32 83       	std	Z+2, r19	; 0x02
    1108:	21 83       	std	Z+1, r18	; 0x01
    110a:	89 81       	ldd	r24, Y+1	; 0x01
    110c:	9a 81       	ldd	r25, Y+2	; 0x02
    110e:	fc 01       	movw	r30, r24
    1110:	21 81       	ldd	r18, Z+1	; 0x01
    1112:	32 81       	ldd	r19, Z+2	; 0x02
    1114:	89 81       	ldd	r24, Y+1	; 0x01
    1116:	9a 81       	ldd	r25, Y+2	; 0x02
    1118:	03 96       	adiw	r24, 0x03	; 3
    111a:	28 17       	cp	r18, r24
    111c:	39 07       	cpc	r19, r25
    111e:	69 f4       	brne	.+26     	; 0x113a <vTaskSwitchContext+0xf8>
    1120:	89 81       	ldd	r24, Y+1	; 0x01
    1122:	9a 81       	ldd	r25, Y+2	; 0x02
    1124:	fc 01       	movw	r30, r24
    1126:	81 81       	ldd	r24, Z+1	; 0x01
    1128:	92 81       	ldd	r25, Z+2	; 0x02
    112a:	fc 01       	movw	r30, r24
    112c:	22 81       	ldd	r18, Z+2	; 0x02
    112e:	33 81       	ldd	r19, Z+3	; 0x03
    1130:	89 81       	ldd	r24, Y+1	; 0x01
    1132:	9a 81       	ldd	r25, Y+2	; 0x02
    1134:	fc 01       	movw	r30, r24
    1136:	32 83       	std	Z+2, r19	; 0x02
    1138:	21 83       	std	Z+1, r18	; 0x01
    113a:	89 81       	ldd	r24, Y+1	; 0x01
    113c:	9a 81       	ldd	r25, Y+2	; 0x02
    113e:	fc 01       	movw	r30, r24
    1140:	81 81       	ldd	r24, Z+1	; 0x01
    1142:	92 81       	ldd	r25, Z+2	; 0x02
    1144:	fc 01       	movw	r30, r24
    1146:	86 81       	ldd	r24, Z+6	; 0x06
    1148:	97 81       	ldd	r25, Z+7	; 0x07
    114a:	90 93 2b 02 	sts	0x022B, r25
    114e:	80 93 2a 02 	sts	0x022A, r24

		traceTASK_SWITCHED_IN();
	}
}
    1152:	0f 90       	pop	r0
    1154:	0f 90       	pop	r0
    1156:	df 91       	pop	r29
    1158:	cf 91       	pop	r28
    115a:	08 95       	ret

0000115c <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    115c:	cf 93       	push	r28
    115e:	df 93       	push	r29
    1160:	00 d0       	rcall	.+0      	; 0x1162 <vTaskPlaceOnEventList+0x6>
    1162:	00 d0       	rcall	.+0      	; 0x1164 <vTaskPlaceOnEventList+0x8>
    1164:	cd b7       	in	r28, 0x3d	; 61
    1166:	de b7       	in	r29, 0x3e	; 62
    1168:	9c 83       	std	Y+4, r25	; 0x04
    116a:	8b 83       	std	Y+3, r24	; 0x03
    116c:	7e 83       	std	Y+6, r23	; 0x06
    116e:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    1170:	80 91 2a 02 	lds	r24, 0x022A
    1174:	90 91 2b 02 	lds	r25, 0x022B
    1178:	9c 01       	movw	r18, r24
    117a:	24 5f       	subi	r18, 0xF4	; 244
    117c:	3f 4f       	sbci	r19, 0xFF	; 255
    117e:	8b 81       	ldd	r24, Y+3	; 0x03
    1180:	9c 81       	ldd	r25, Y+4	; 0x04
    1182:	b9 01       	movw	r22, r18
    1184:	0e 94 e5 12 	call	0x25ca	; 0x25ca <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    1188:	80 91 2a 02 	lds	r24, 0x022A
    118c:	90 91 2b 02 	lds	r25, 0x022B
    1190:	02 96       	adiw	r24, 0x02	; 2
    1192:	0e 94 5e 13 	call	0x26bc	; 0x26bc <uxListRemove>
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    1196:	8d 81       	ldd	r24, Y+5	; 0x05
    1198:	9e 81       	ldd	r25, Y+6	; 0x06
    119a:	8f 3f       	cpi	r24, 0xFF	; 255
    119c:	2f ef       	ldi	r18, 0xFF	; 255
    119e:	92 07       	cpc	r25, r18
    11a0:	59 f4       	brne	.+22     	; 0x11b8 <vTaskPlaceOnEventList+0x5c>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    11a2:	80 91 2a 02 	lds	r24, 0x022A
    11a6:	90 91 2b 02 	lds	r25, 0x022B
    11aa:	02 96       	adiw	r24, 0x02	; 2
    11ac:	bc 01       	movw	r22, r24
    11ae:	8f e6       	ldi	r24, 0x6F	; 111
    11b0:	92 e0       	ldi	r25, 0x02	; 2
    11b2:	0e 94 8e 12 	call	0x251c	; 0x251c <vListInsertEnd>
    11b6:	0e c0       	rjmp	.+28     	; 0x11d4 <vTaskPlaceOnEventList+0x78>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    11b8:	20 91 79 02 	lds	r18, 0x0279
    11bc:	30 91 7a 02 	lds	r19, 0x027A
    11c0:	8d 81       	ldd	r24, Y+5	; 0x05
    11c2:	9e 81       	ldd	r25, Y+6	; 0x06
    11c4:	82 0f       	add	r24, r18
    11c6:	93 1f       	adc	r25, r19
    11c8:	9a 83       	std	Y+2, r25	; 0x02
    11ca:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    11cc:	89 81       	ldd	r24, Y+1	; 0x01
    11ce:	9a 81       	ldd	r25, Y+2	; 0x02
    11d0:	0e 94 a9 0a 	call	0x1552	; 0x1552 <prvAddCurrentTaskToDelayedList>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
    11d4:	26 96       	adiw	r28, 0x06	; 6
    11d6:	0f b6       	in	r0, 0x3f	; 63
    11d8:	f8 94       	cli
    11da:	de bf       	out	0x3e, r29	; 62
    11dc:	0f be       	out	0x3f, r0	; 63
    11de:	cd bf       	out	0x3d, r28	; 61
    11e0:	df 91       	pop	r29
    11e2:	cf 91       	pop	r28
    11e4:	08 95       	ret

000011e6 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    11e6:	cf 93       	push	r28
    11e8:	df 93       	push	r29
    11ea:	00 d0       	rcall	.+0      	; 0x11ec <xTaskRemoveFromEventList+0x6>
    11ec:	1f 92       	push	r1
    11ee:	1f 92       	push	r1
    11f0:	cd b7       	in	r28, 0x3d	; 61
    11f2:	de b7       	in	r29, 0x3e	; 62
    11f4:	9d 83       	std	Y+5, r25	; 0x05
    11f6:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    11f8:	8c 81       	ldd	r24, Y+4	; 0x04
    11fa:	9d 81       	ldd	r25, Y+5	; 0x05
    11fc:	fc 01       	movw	r30, r24
    11fe:	85 81       	ldd	r24, Z+5	; 0x05
    1200:	96 81       	ldd	r25, Z+6	; 0x06
    1202:	fc 01       	movw	r30, r24
    1204:	86 81       	ldd	r24, Z+6	; 0x06
    1206:	97 81       	ldd	r25, Z+7	; 0x07
    1208:	9b 83       	std	Y+3, r25	; 0x03
    120a:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    120c:	8a 81       	ldd	r24, Y+2	; 0x02
    120e:	9b 81       	ldd	r25, Y+3	; 0x03
    1210:	0c 96       	adiw	r24, 0x0c	; 12
    1212:	0e 94 5e 13 	call	0x26bc	; 0x26bc <uxListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1216:	80 91 7e 02 	lds	r24, 0x027E
    121a:	88 23       	and	r24, r24
    121c:	69 f5       	brne	.+90     	; 0x1278 <xTaskRemoveFromEventList+0x92>
	{
		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    121e:	8a 81       	ldd	r24, Y+2	; 0x02
    1220:	9b 81       	ldd	r25, Y+3	; 0x03
    1222:	02 96       	adiw	r24, 0x02	; 2
    1224:	0e 94 5e 13 	call	0x26bc	; 0x26bc <uxListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    1228:	8a 81       	ldd	r24, Y+2	; 0x02
    122a:	9b 81       	ldd	r25, Y+3	; 0x03
    122c:	fc 01       	movw	r30, r24
    122e:	96 89       	ldd	r25, Z+22	; 0x16
    1230:	80 91 7c 02 	lds	r24, 0x027C
    1234:	89 17       	cp	r24, r25
    1236:	30 f4       	brcc	.+12     	; 0x1244 <xTaskRemoveFromEventList+0x5e>
    1238:	8a 81       	ldd	r24, Y+2	; 0x02
    123a:	9b 81       	ldd	r25, Y+3	; 0x03
    123c:	fc 01       	movw	r30, r24
    123e:	86 89       	ldd	r24, Z+22	; 0x16
    1240:	80 93 7c 02 	sts	0x027C, r24
    1244:	8a 81       	ldd	r24, Y+2	; 0x02
    1246:	9b 81       	ldd	r25, Y+3	; 0x03
    1248:	ac 01       	movw	r20, r24
    124a:	4e 5f       	subi	r20, 0xFE	; 254
    124c:	5f 4f       	sbci	r21, 0xFF	; 255
    124e:	8a 81       	ldd	r24, Y+2	; 0x02
    1250:	9b 81       	ldd	r25, Y+3	; 0x03
    1252:	fc 01       	movw	r30, r24
    1254:	86 89       	ldd	r24, Z+22	; 0x16
    1256:	28 2f       	mov	r18, r24
    1258:	30 e0       	ldi	r19, 0x00	; 0
    125a:	c9 01       	movw	r24, r18
    125c:	88 0f       	add	r24, r24
    125e:	99 1f       	adc	r25, r25
    1260:	88 0f       	add	r24, r24
    1262:	99 1f       	adc	r25, r25
    1264:	88 0f       	add	r24, r24
    1266:	99 1f       	adc	r25, r25
    1268:	82 0f       	add	r24, r18
    126a:	93 1f       	adc	r25, r19
    126c:	84 5d       	subi	r24, 0xD4	; 212
    126e:	9d 4f       	sbci	r25, 0xFD	; 253
    1270:	ba 01       	movw	r22, r20
    1272:	0e 94 8e 12 	call	0x251c	; 0x251c <vListInsertEnd>
    1276:	08 c0       	rjmp	.+16     	; 0x1288 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1278:	8a 81       	ldd	r24, Y+2	; 0x02
    127a:	9b 81       	ldd	r25, Y+3	; 0x03
    127c:	0c 96       	adiw	r24, 0x0c	; 12
    127e:	bc 01       	movw	r22, r24
    1280:	86 e6       	ldi	r24, 0x66	; 102
    1282:	92 e0       	ldi	r25, 0x02	; 2
    1284:	0e 94 8e 12 	call	0x251c	; 0x251c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1288:	8a 81       	ldd	r24, Y+2	; 0x02
    128a:	9b 81       	ldd	r25, Y+3	; 0x03
    128c:	fc 01       	movw	r30, r24
    128e:	26 89       	ldd	r18, Z+22	; 0x16
    1290:	80 91 2a 02 	lds	r24, 0x022A
    1294:	90 91 2b 02 	lds	r25, 0x022B
    1298:	fc 01       	movw	r30, r24
    129a:	86 89       	ldd	r24, Z+22	; 0x16
    129c:	28 17       	cp	r18, r24
    129e:	18 f0       	brcs	.+6      	; 0x12a6 <xTaskRemoveFromEventList+0xc0>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    12a0:	81 e0       	ldi	r24, 0x01	; 1
    12a2:	89 83       	std	Y+1, r24	; 0x01
    12a4:	01 c0       	rjmp	.+2      	; 0x12a8 <xTaskRemoveFromEventList+0xc2>
	}
	else
	{
		xReturn = pdFALSE;
    12a6:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    12a8:	89 81       	ldd	r24, Y+1	; 0x01
}
    12aa:	0f 90       	pop	r0
    12ac:	0f 90       	pop	r0
    12ae:	0f 90       	pop	r0
    12b0:	0f 90       	pop	r0
    12b2:	0f 90       	pop	r0
    12b4:	df 91       	pop	r29
    12b6:	cf 91       	pop	r28
    12b8:	08 95       	ret

000012ba <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    12ba:	cf 93       	push	r28
    12bc:	df 93       	push	r29
    12be:	1f 92       	push	r1
    12c0:	1f 92       	push	r1
    12c2:	cd b7       	in	r28, 0x3d	; 61
    12c4:	de b7       	in	r29, 0x3e	; 62
    12c6:	9a 83       	std	Y+2, r25	; 0x02
    12c8:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    12ca:	20 91 81 02 	lds	r18, 0x0281
    12ce:	89 81       	ldd	r24, Y+1	; 0x01
    12d0:	9a 81       	ldd	r25, Y+2	; 0x02
    12d2:	fc 01       	movw	r30, r24
    12d4:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    12d6:	20 91 79 02 	lds	r18, 0x0279
    12da:	30 91 7a 02 	lds	r19, 0x027A
    12de:	89 81       	ldd	r24, Y+1	; 0x01
    12e0:	9a 81       	ldd	r25, Y+2	; 0x02
    12e2:	fc 01       	movw	r30, r24
    12e4:	32 83       	std	Z+2, r19	; 0x02
    12e6:	21 83       	std	Z+1, r18	; 0x01
}
    12e8:	0f 90       	pop	r0
    12ea:	0f 90       	pop	r0
    12ec:	df 91       	pop	r29
    12ee:	cf 91       	pop	r28
    12f0:	08 95       	ret

000012f2 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    12f2:	cf 93       	push	r28
    12f4:	df 93       	push	r29
    12f6:	00 d0       	rcall	.+0      	; 0x12f8 <xTaskCheckForTimeOut+0x6>
    12f8:	1f 92       	push	r1
    12fa:	1f 92       	push	r1
    12fc:	cd b7       	in	r28, 0x3d	; 61
    12fe:	de b7       	in	r29, 0x3e	; 62
    1300:	9b 83       	std	Y+3, r25	; 0x03
    1302:	8a 83       	std	Y+2, r24	; 0x02
    1304:	7d 83       	std	Y+5, r23	; 0x05
    1306:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1308:	0f b6       	in	r0, 0x3f	; 63
    130a:	f8 94       	cli
    130c:	0f 92       	push	r0
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    130e:	8c 81       	ldd	r24, Y+4	; 0x04
    1310:	9d 81       	ldd	r25, Y+5	; 0x05
    1312:	fc 01       	movw	r30, r24
    1314:	80 81       	ld	r24, Z
    1316:	91 81       	ldd	r25, Z+1	; 0x01
    1318:	8f 3f       	cpi	r24, 0xFF	; 255
    131a:	ff ef       	ldi	r31, 0xFF	; 255
    131c:	9f 07       	cpc	r25, r31
    131e:	11 f4       	brne	.+4      	; 0x1324 <xTaskCheckForTimeOut+0x32>
			{
				xReturn = pdFALSE;
    1320:	19 82       	std	Y+1, r1	; 0x01
    1322:	4b c0       	rjmp	.+150    	; 0x13ba <xTaskCheckForTimeOut+0xc8>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    1324:	8a 81       	ldd	r24, Y+2	; 0x02
    1326:	9b 81       	ldd	r25, Y+3	; 0x03
    1328:	fc 01       	movw	r30, r24
    132a:	90 81       	ld	r25, Z
    132c:	80 91 81 02 	lds	r24, 0x0281
    1330:	98 17       	cp	r25, r24
    1332:	79 f0       	breq	.+30     	; 0x1352 <xTaskCheckForTimeOut+0x60>
    1334:	8a 81       	ldd	r24, Y+2	; 0x02
    1336:	9b 81       	ldd	r25, Y+3	; 0x03
    1338:	fc 01       	movw	r30, r24
    133a:	21 81       	ldd	r18, Z+1	; 0x01
    133c:	32 81       	ldd	r19, Z+2	; 0x02
    133e:	80 91 79 02 	lds	r24, 0x0279
    1342:	90 91 7a 02 	lds	r25, 0x027A
    1346:	82 17       	cp	r24, r18
    1348:	93 07       	cpc	r25, r19
    134a:	18 f0       	brcs	.+6      	; 0x1352 <xTaskCheckForTimeOut+0x60>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    134c:	81 e0       	ldi	r24, 0x01	; 1
    134e:	89 83       	std	Y+1, r24	; 0x01
    1350:	34 c0       	rjmp	.+104    	; 0x13ba <xTaskCheckForTimeOut+0xc8>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    1352:	20 91 79 02 	lds	r18, 0x0279
    1356:	30 91 7a 02 	lds	r19, 0x027A
    135a:	8a 81       	ldd	r24, Y+2	; 0x02
    135c:	9b 81       	ldd	r25, Y+3	; 0x03
    135e:	fc 01       	movw	r30, r24
    1360:	81 81       	ldd	r24, Z+1	; 0x01
    1362:	92 81       	ldd	r25, Z+2	; 0x02
    1364:	28 1b       	sub	r18, r24
    1366:	39 0b       	sbc	r19, r25
    1368:	8c 81       	ldd	r24, Y+4	; 0x04
    136a:	9d 81       	ldd	r25, Y+5	; 0x05
    136c:	fc 01       	movw	r30, r24
    136e:	80 81       	ld	r24, Z
    1370:	91 81       	ldd	r25, Z+1	; 0x01
    1372:	28 17       	cp	r18, r24
    1374:	39 07       	cpc	r19, r25
    1376:	f8 f4       	brcc	.+62     	; 0x13b6 <xTaskCheckForTimeOut+0xc4>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    1378:	8c 81       	ldd	r24, Y+4	; 0x04
    137a:	9d 81       	ldd	r25, Y+5	; 0x05
    137c:	fc 01       	movw	r30, r24
    137e:	20 81       	ld	r18, Z
    1380:	31 81       	ldd	r19, Z+1	; 0x01
    1382:	8a 81       	ldd	r24, Y+2	; 0x02
    1384:	9b 81       	ldd	r25, Y+3	; 0x03
    1386:	fc 01       	movw	r30, r24
    1388:	41 81       	ldd	r20, Z+1	; 0x01
    138a:	52 81       	ldd	r21, Z+2	; 0x02
    138c:	80 91 79 02 	lds	r24, 0x0279
    1390:	90 91 7a 02 	lds	r25, 0x027A
    1394:	ba 01       	movw	r22, r20
    1396:	68 1b       	sub	r22, r24
    1398:	79 0b       	sbc	r23, r25
    139a:	cb 01       	movw	r24, r22
    139c:	28 0f       	add	r18, r24
    139e:	39 1f       	adc	r19, r25
    13a0:	8c 81       	ldd	r24, Y+4	; 0x04
    13a2:	9d 81       	ldd	r25, Y+5	; 0x05
    13a4:	fc 01       	movw	r30, r24
    13a6:	31 83       	std	Z+1, r19	; 0x01
    13a8:	20 83       	st	Z, r18
			vTaskSetTimeOutState( pxTimeOut );
    13aa:	8a 81       	ldd	r24, Y+2	; 0x02
    13ac:	9b 81       	ldd	r25, Y+3	; 0x03
    13ae:	0e 94 5d 09 	call	0x12ba	; 0x12ba <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    13b2:	19 82       	std	Y+1, r1	; 0x01
    13b4:	02 c0       	rjmp	.+4      	; 0x13ba <xTaskCheckForTimeOut+0xc8>
		}
		else
		{
			xReturn = pdTRUE;
    13b6:	81 e0       	ldi	r24, 0x01	; 1
    13b8:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    13ba:	0f 90       	pop	r0
    13bc:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    13be:	89 81       	ldd	r24, Y+1	; 0x01
}
    13c0:	0f 90       	pop	r0
    13c2:	0f 90       	pop	r0
    13c4:	0f 90       	pop	r0
    13c6:	0f 90       	pop	r0
    13c8:	0f 90       	pop	r0
    13ca:	df 91       	pop	r29
    13cc:	cf 91       	pop	r28
    13ce:	08 95       	ret

000013d0 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    13d0:	cf 93       	push	r28
    13d2:	df 93       	push	r29
    13d4:	cd b7       	in	r28, 0x3d	; 61
    13d6:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    13d8:	81 e0       	ldi	r24, 0x01	; 1
    13da:	80 93 80 02 	sts	0x0280, r24
}
    13de:	df 91       	pop	r29
    13e0:	cf 91       	pop	r28
    13e2:	08 95       	ret

000013e4 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    13e4:	cf 93       	push	r28
    13e6:	df 93       	push	r29
    13e8:	1f 92       	push	r1
    13ea:	1f 92       	push	r1
    13ec:	cd b7       	in	r28, 0x3d	; 61
    13ee:	de b7       	in	r29, 0x3e	; 62
    13f0:	9a 83       	std	Y+2, r25	; 0x02
    13f2:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    13f4:	0e 94 a2 0a 	call	0x1544	; 0x1544 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    13f8:	80 91 2c 02 	lds	r24, 0x022C
    13fc:	82 30       	cpi	r24, 0x02	; 2
    13fe:	18 f0       	brcs	.+6      	; 0x1406 <prvIdleTask+0x22>
			{
				taskYIELD();
    1400:	0e 94 20 19 	call	0x3240	; 0x3240 <vPortYield>
				}
				xTaskResumeAll();
			}
		}
		#endif
	}
    1404:	f7 cf       	rjmp	.-18     	; 0x13f4 <prvIdleTask+0x10>
    1406:	f6 cf       	rjmp	.-20     	; 0x13f4 <prvIdleTask+0x10>

00001408 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    1408:	0f 93       	push	r16
    140a:	1f 93       	push	r17
    140c:	cf 93       	push	r28
    140e:	df 93       	push	r29
    1410:	cd b7       	in	r28, 0x3d	; 61
    1412:	de b7       	in	r29, 0x3e	; 62
    1414:	29 97       	sbiw	r28, 0x09	; 9
    1416:	0f b6       	in	r0, 0x3f	; 63
    1418:	f8 94       	cli
    141a:	de bf       	out	0x3e, r29	; 62
    141c:	0f be       	out	0x3f, r0	; 63
    141e:	cd bf       	out	0x3d, r28	; 61
    1420:	9a 83       	std	Y+2, r25	; 0x02
    1422:	89 83       	std	Y+1, r24	; 0x01
    1424:	7c 83       	std	Y+4, r23	; 0x04
    1426:	6b 83       	std	Y+3, r22	; 0x03
    1428:	4d 83       	std	Y+5, r20	; 0x05
    142a:	3f 83       	std	Y+7, r19	; 0x07
    142c:	2e 83       	std	Y+6, r18	; 0x06
    142e:	19 87       	std	Y+9, r17	; 0x09
    1430:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    1432:	89 81       	ldd	r24, Y+1	; 0x01
    1434:	9a 81       	ldd	r25, Y+2	; 0x02
    1436:	49 96       	adiw	r24, 0x19	; 25
    1438:	2b 81       	ldd	r18, Y+3	; 0x03
    143a:	3c 81       	ldd	r19, Y+4	; 0x04
    143c:	40 e1       	ldi	r20, 0x10	; 16
    143e:	50 e0       	ldi	r21, 0x00	; 0
    1440:	b9 01       	movw	r22, r18
    1442:	0e 94 31 26 	call	0x4c62	; 0x4c62 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    1446:	89 81       	ldd	r24, Y+1	; 0x01
    1448:	9a 81       	ldd	r25, Y+2	; 0x02
    144a:	fc 01       	movw	r30, r24
    144c:	10 a6       	std	Z+40, r1	; 0x28

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    144e:	8d 81       	ldd	r24, Y+5	; 0x05
    1450:	84 30       	cpi	r24, 0x04	; 4
    1452:	10 f0       	brcs	.+4      	; 0x1458 <prvInitialiseTCBVariables+0x50>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    1454:	83 e0       	ldi	r24, 0x03	; 3
    1456:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    1458:	89 81       	ldd	r24, Y+1	; 0x01
    145a:	9a 81       	ldd	r25, Y+2	; 0x02
    145c:	2d 81       	ldd	r18, Y+5	; 0x05
    145e:	fc 01       	movw	r30, r24
    1460:	26 8b       	std	Z+22, r18	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    1462:	89 81       	ldd	r24, Y+1	; 0x01
    1464:	9a 81       	ldd	r25, Y+2	; 0x02
    1466:	2d 81       	ldd	r18, Y+5	; 0x05
    1468:	fc 01       	movw	r30, r24
    146a:	21 a7       	std	Z+41, r18	; 0x29
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    146c:	89 81       	ldd	r24, Y+1	; 0x01
    146e:	9a 81       	ldd	r25, Y+2	; 0x02
    1470:	02 96       	adiw	r24, 0x02	; 2
    1472:	0e 94 7c 12 	call	0x24f8	; 0x24f8 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    1476:	89 81       	ldd	r24, Y+1	; 0x01
    1478:	9a 81       	ldd	r25, Y+2	; 0x02
    147a:	0c 96       	adiw	r24, 0x0c	; 12
    147c:	0e 94 7c 12 	call	0x24f8	; 0x24f8 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    1480:	89 81       	ldd	r24, Y+1	; 0x01
    1482:	9a 81       	ldd	r25, Y+2	; 0x02
    1484:	29 81       	ldd	r18, Y+1	; 0x01
    1486:	3a 81       	ldd	r19, Y+2	; 0x02
    1488:	fc 01       	movw	r30, r24
    148a:	31 87       	std	Z+9, r19	; 0x09
    148c:	20 87       	std	Z+8, r18	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    148e:	8d 81       	ldd	r24, Y+5	; 0x05
    1490:	88 2f       	mov	r24, r24
    1492:	90 e0       	ldi	r25, 0x00	; 0
    1494:	24 e0       	ldi	r18, 0x04	; 4
    1496:	30 e0       	ldi	r19, 0x00	; 0
    1498:	28 1b       	sub	r18, r24
    149a:	39 0b       	sbc	r19, r25
    149c:	89 81       	ldd	r24, Y+1	; 0x01
    149e:	9a 81       	ldd	r25, Y+2	; 0x02
    14a0:	fc 01       	movw	r30, r24
    14a2:	35 87       	std	Z+13, r19	; 0x0d
    14a4:	24 87       	std	Z+12, r18	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    14a6:	89 81       	ldd	r24, Y+1	; 0x01
    14a8:	9a 81       	ldd	r25, Y+2	; 0x02
    14aa:	29 81       	ldd	r18, Y+1	; 0x01
    14ac:	3a 81       	ldd	r19, Y+2	; 0x02
    14ae:	fc 01       	movw	r30, r24
    14b0:	33 8b       	std	Z+19, r19	; 0x13
    14b2:	22 8b       	std	Z+18, r18	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    14b4:	29 96       	adiw	r28, 0x09	; 9
    14b6:	0f b6       	in	r0, 0x3f	; 63
    14b8:	f8 94       	cli
    14ba:	de bf       	out	0x3e, r29	; 62
    14bc:	0f be       	out	0x3f, r0	; 63
    14be:	cd bf       	out	0x3d, r28	; 61
    14c0:	df 91       	pop	r29
    14c2:	cf 91       	pop	r28
    14c4:	1f 91       	pop	r17
    14c6:	0f 91       	pop	r16
    14c8:	08 95       	ret

000014ca <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    14ca:	cf 93       	push	r28
    14cc:	df 93       	push	r29
    14ce:	1f 92       	push	r1
    14d0:	cd b7       	in	r28, 0x3d	; 61
    14d2:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    14d4:	19 82       	std	Y+1, r1	; 0x01
    14d6:	13 c0       	rjmp	.+38     	; 0x14fe <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    14d8:	89 81       	ldd	r24, Y+1	; 0x01
    14da:	28 2f       	mov	r18, r24
    14dc:	30 e0       	ldi	r19, 0x00	; 0
    14de:	c9 01       	movw	r24, r18
    14e0:	88 0f       	add	r24, r24
    14e2:	99 1f       	adc	r25, r25
    14e4:	88 0f       	add	r24, r24
    14e6:	99 1f       	adc	r25, r25
    14e8:	88 0f       	add	r24, r24
    14ea:	99 1f       	adc	r25, r25
    14ec:	82 0f       	add	r24, r18
    14ee:	93 1f       	adc	r25, r19
    14f0:	84 5d       	subi	r24, 0xD4	; 212
    14f2:	9d 4f       	sbci	r25, 0xFD	; 253
    14f4:	0e 94 46 12 	call	0x248c	; 0x248c <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    14f8:	89 81       	ldd	r24, Y+1	; 0x01
    14fa:	8f 5f       	subi	r24, 0xFF	; 255
    14fc:	89 83       	std	Y+1, r24	; 0x01
    14fe:	89 81       	ldd	r24, Y+1	; 0x01
    1500:	84 30       	cpi	r24, 0x04	; 4
    1502:	50 f3       	brcs	.-44     	; 0x14d8 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    1504:	80 e5       	ldi	r24, 0x50	; 80
    1506:	92 e0       	ldi	r25, 0x02	; 2
    1508:	0e 94 46 12 	call	0x248c	; 0x248c <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    150c:	89 e5       	ldi	r24, 0x59	; 89
    150e:	92 e0       	ldi	r25, 0x02	; 2
    1510:	0e 94 46 12 	call	0x248c	; 0x248c <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    1514:	86 e6       	ldi	r24, 0x66	; 102
    1516:	92 e0       	ldi	r25, 0x02	; 2
    1518:	0e 94 46 12 	call	0x248c	; 0x248c <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
    151c:	8f e6       	ldi	r24, 0x6F	; 111
    151e:	92 e0       	ldi	r25, 0x02	; 2
    1520:	0e 94 46 12 	call	0x248c	; 0x248c <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1524:	80 e5       	ldi	r24, 0x50	; 80
    1526:	92 e0       	ldi	r25, 0x02	; 2
    1528:	90 93 63 02 	sts	0x0263, r25
    152c:	80 93 62 02 	sts	0x0262, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1530:	89 e5       	ldi	r24, 0x59	; 89
    1532:	92 e0       	ldi	r25, 0x02	; 2
    1534:	90 93 65 02 	sts	0x0265, r25
    1538:	80 93 64 02 	sts	0x0264, r24
}
    153c:	0f 90       	pop	r0
    153e:	df 91       	pop	r29
    1540:	cf 91       	pop	r28
    1542:	08 95       	ret

00001544 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    1544:	cf 93       	push	r28
    1546:	df 93       	push	r29
    1548:	cd b7       	in	r28, 0x3d	; 61
    154a:	de b7       	in	r29, 0x3e	; 62
				prvDeleteTCB( pxTCB );
			}
		}
	}
	#endif
}
    154c:	df 91       	pop	r29
    154e:	cf 91       	pop	r28
    1550:	08 95       	ret

00001552 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    1552:	cf 93       	push	r28
    1554:	df 93       	push	r29
    1556:	1f 92       	push	r1
    1558:	1f 92       	push	r1
    155a:	cd b7       	in	r28, 0x3d	; 61
    155c:	de b7       	in	r29, 0x3e	; 62
    155e:	9a 83       	std	Y+2, r25	; 0x02
    1560:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1562:	80 91 2a 02 	lds	r24, 0x022A
    1566:	90 91 2b 02 	lds	r25, 0x022B
    156a:	29 81       	ldd	r18, Y+1	; 0x01
    156c:	3a 81       	ldd	r19, Y+2	; 0x02
    156e:	fc 01       	movw	r30, r24
    1570:	33 83       	std	Z+3, r19	; 0x03
    1572:	22 83       	std	Z+2, r18	; 0x02

	if( xTimeToWake < xTickCount )
    1574:	80 91 79 02 	lds	r24, 0x0279
    1578:	90 91 7a 02 	lds	r25, 0x027A
    157c:	29 81       	ldd	r18, Y+1	; 0x01
    157e:	3a 81       	ldd	r19, Y+2	; 0x02
    1580:	28 17       	cp	r18, r24
    1582:	39 07       	cpc	r19, r25
    1584:	78 f4       	brcc	.+30     	; 0x15a4 <prvAddCurrentTaskToDelayedList+0x52>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1586:	80 91 2a 02 	lds	r24, 0x022A
    158a:	90 91 2b 02 	lds	r25, 0x022B
    158e:	9c 01       	movw	r18, r24
    1590:	2e 5f       	subi	r18, 0xFE	; 254
    1592:	3f 4f       	sbci	r19, 0xFF	; 255
    1594:	80 91 64 02 	lds	r24, 0x0264
    1598:	90 91 65 02 	lds	r25, 0x0265
    159c:	b9 01       	movw	r22, r18
    159e:	0e 94 e5 12 	call	0x25ca	; 0x25ca <vListInsert>
    15a2:	1d c0       	rjmp	.+58     	; 0x15de <prvAddCurrentTaskToDelayedList+0x8c>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    15a4:	80 91 2a 02 	lds	r24, 0x022A
    15a8:	90 91 2b 02 	lds	r25, 0x022B
    15ac:	9c 01       	movw	r18, r24
    15ae:	2e 5f       	subi	r18, 0xFE	; 254
    15b0:	3f 4f       	sbci	r19, 0xFF	; 255
    15b2:	80 91 62 02 	lds	r24, 0x0262
    15b6:	90 91 63 02 	lds	r25, 0x0263
    15ba:	b9 01       	movw	r22, r18
    15bc:	0e 94 e5 12 	call	0x25ca	; 0x25ca <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    15c0:	80 91 00 02 	lds	r24, 0x0200
    15c4:	90 91 01 02 	lds	r25, 0x0201
    15c8:	29 81       	ldd	r18, Y+1	; 0x01
    15ca:	3a 81       	ldd	r19, Y+2	; 0x02
    15cc:	28 17       	cp	r18, r24
    15ce:	39 07       	cpc	r19, r25
    15d0:	30 f4       	brcc	.+12     	; 0x15de <prvAddCurrentTaskToDelayedList+0x8c>
		{
			xNextTaskUnblockTime = xTimeToWake;
    15d2:	89 81       	ldd	r24, Y+1	; 0x01
    15d4:	9a 81       	ldd	r25, Y+2	; 0x02
    15d6:	90 93 01 02 	sts	0x0201, r25
    15da:	80 93 00 02 	sts	0x0200, r24
		}
	}
}
    15de:	0f 90       	pop	r0
    15e0:	0f 90       	pop	r0
    15e2:	df 91       	pop	r29
    15e4:	cf 91       	pop	r28
    15e6:	08 95       	ret

000015e8 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    15e8:	cf 93       	push	r28
    15ea:	df 93       	push	r29
    15ec:	00 d0       	rcall	.+0      	; 0x15ee <prvAllocateTCBAndStack+0x6>
    15ee:	00 d0       	rcall	.+0      	; 0x15f0 <prvAllocateTCBAndStack+0x8>
    15f0:	cd b7       	in	r28, 0x3d	; 61
    15f2:	de b7       	in	r29, 0x3e	; 62
    15f4:	9c 83       	std	Y+4, r25	; 0x04
    15f6:	8b 83       	std	Y+3, r24	; 0x03
    15f8:	7e 83       	std	Y+6, r23	; 0x06
    15fa:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    15fc:	8a e2       	ldi	r24, 0x2A	; 42
    15fe:	90 e0       	ldi	r25, 0x00	; 0
    1600:	0e 94 ad 16 	call	0x2d5a	; 0x2d5a <pvPortMalloc>
    1604:	9a 83       	std	Y+2, r25	; 0x02
    1606:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    1608:	89 81       	ldd	r24, Y+1	; 0x01
    160a:	9a 81       	ldd	r25, Y+2	; 0x02
    160c:	00 97       	sbiw	r24, 0x00	; 0
    160e:	51 f1       	breq	.+84     	; 0x1664 <prvAllocateTCBAndStack+0x7c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    1610:	8d 81       	ldd	r24, Y+5	; 0x05
    1612:	9e 81       	ldd	r25, Y+6	; 0x06
    1614:	00 97       	sbiw	r24, 0x00	; 0
    1616:	29 f4       	brne	.+10     	; 0x1622 <prvAllocateTCBAndStack+0x3a>
    1618:	8b 81       	ldd	r24, Y+3	; 0x03
    161a:	9c 81       	ldd	r25, Y+4	; 0x04
    161c:	0e 94 ad 16 	call	0x2d5a	; 0x2d5a <pvPortMalloc>
    1620:	02 c0       	rjmp	.+4      	; 0x1626 <prvAllocateTCBAndStack+0x3e>
    1622:	8d 81       	ldd	r24, Y+5	; 0x05
    1624:	9e 81       	ldd	r25, Y+6	; 0x06
    1626:	29 81       	ldd	r18, Y+1	; 0x01
    1628:	3a 81       	ldd	r19, Y+2	; 0x02
    162a:	f9 01       	movw	r30, r18
    162c:	90 8f       	std	Z+24, r25	; 0x18
    162e:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    1630:	89 81       	ldd	r24, Y+1	; 0x01
    1632:	9a 81       	ldd	r25, Y+2	; 0x02
    1634:	fc 01       	movw	r30, r24
    1636:	87 89       	ldd	r24, Z+23	; 0x17
    1638:	90 8d       	ldd	r25, Z+24	; 0x18
    163a:	00 97       	sbiw	r24, 0x00	; 0
    163c:	39 f4       	brne	.+14     	; 0x164c <prvAllocateTCBAndStack+0x64>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    163e:	89 81       	ldd	r24, Y+1	; 0x01
    1640:	9a 81       	ldd	r25, Y+2	; 0x02
    1642:	0e 94 f3 16 	call	0x2de6	; 0x2de6 <vPortFree>
			pxNewTCB = NULL;
    1646:	1a 82       	std	Y+2, r1	; 0x02
    1648:	19 82       	std	Y+1, r1	; 0x01
    164a:	0c c0       	rjmp	.+24     	; 0x1664 <prvAllocateTCBAndStack+0x7c>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    164c:	89 81       	ldd	r24, Y+1	; 0x01
    164e:	9a 81       	ldd	r25, Y+2	; 0x02
    1650:	fc 01       	movw	r30, r24
    1652:	87 89       	ldd	r24, Z+23	; 0x17
    1654:	90 8d       	ldd	r25, Z+24	; 0x18
    1656:	2b 81       	ldd	r18, Y+3	; 0x03
    1658:	3c 81       	ldd	r19, Y+4	; 0x04
    165a:	a9 01       	movw	r20, r18
    165c:	65 ea       	ldi	r22, 0xA5	; 165
    165e:	70 e0       	ldi	r23, 0x00	; 0
    1660:	0e 94 2a 26 	call	0x4c54	; 0x4c54 <memset>
		}
	}

	return pxNewTCB;
    1664:	89 81       	ldd	r24, Y+1	; 0x01
    1666:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1668:	26 96       	adiw	r28, 0x06	; 6
    166a:	0f b6       	in	r0, 0x3f	; 63
    166c:	f8 94       	cli
    166e:	de bf       	out	0x3e, r29	; 62
    1670:	0f be       	out	0x3f, r0	; 63
    1672:	cd bf       	out	0x3d, r28	; 61
    1674:	df 91       	pop	r29
    1676:	cf 91       	pop	r28
    1678:	08 95       	ret

0000167a <usTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
    167a:	0f 93       	push	r16
    167c:	1f 93       	push	r17
    167e:	cf 93       	push	r28
    1680:	df 93       	push	r29
    1682:	1f 92       	push	r1
    1684:	1f 92       	push	r1
    1686:	cd b7       	in	r28, 0x3d	; 61
    1688:	de b7       	in	r29, 0x3e	; 62
    168a:	9a 83       	std	Y+2, r25	; 0x02
    168c:	89 83       	std	Y+1, r24	; 0x01
	register unsigned short usCount = 0U;
    168e:	00 e0       	ldi	r16, 0x00	; 0
    1690:	10 e0       	ldi	r17, 0x00	; 0

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    1692:	09 c0       	rjmp	.+18     	; 0x16a6 <usTaskCheckFreeStackSpace+0x2c>
		{
			pucStackByte -= portSTACK_GROWTH;
    1694:	89 81       	ldd	r24, Y+1	; 0x01
    1696:	9a 81       	ldd	r25, Y+2	; 0x02
    1698:	01 96       	adiw	r24, 0x01	; 1
    169a:	9a 83       	std	Y+2, r25	; 0x02
    169c:	89 83       	std	Y+1, r24	; 0x01
			usCount++;
    169e:	c8 01       	movw	r24, r16
    16a0:	8c 01       	movw	r16, r24
    16a2:	0f 5f       	subi	r16, 0xFF	; 255
    16a4:	1f 4f       	sbci	r17, 0xFF	; 255

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    16a6:	89 81       	ldd	r24, Y+1	; 0x01
    16a8:	9a 81       	ldd	r25, Y+2	; 0x02
    16aa:	fc 01       	movw	r30, r24
    16ac:	80 81       	ld	r24, Z
    16ae:	85 3a       	cpi	r24, 0xA5	; 165
    16b0:	89 f3       	breq	.-30     	; 0x1694 <usTaskCheckFreeStackSpace+0x1a>
			usCount++;
		}

		usCount /= sizeof( portSTACK_TYPE );

		return usCount;
    16b2:	c8 01       	movw	r24, r16
	}
    16b4:	0f 90       	pop	r0
    16b6:	0f 90       	pop	r0
    16b8:	df 91       	pop	r29
    16ba:	cf 91       	pop	r28
    16bc:	1f 91       	pop	r17
    16be:	0f 91       	pop	r16
    16c0:	08 95       	ret

000016c2 <uxTaskGetStackHighWaterMark>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
	{
    16c2:	cf 93       	push	r28
    16c4:	df 93       	push	r29
    16c6:	cd b7       	in	r28, 0x3d	; 61
    16c8:	de b7       	in	r29, 0x3e	; 62
    16ca:	27 97       	sbiw	r28, 0x07	; 7
    16cc:	0f b6       	in	r0, 0x3f	; 63
    16ce:	f8 94       	cli
    16d0:	de bf       	out	0x3e, r29	; 62
    16d2:	0f be       	out	0x3f, r0	; 63
    16d4:	cd bf       	out	0x3d, r28	; 61
    16d6:	9f 83       	std	Y+7, r25	; 0x07
    16d8:	8e 83       	std	Y+6, r24	; 0x06
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    16da:	8e 81       	ldd	r24, Y+6	; 0x06
    16dc:	9f 81       	ldd	r25, Y+7	; 0x07
    16de:	00 97       	sbiw	r24, 0x00	; 0
    16e0:	29 f4       	brne	.+10     	; 0x16ec <uxTaskGetStackHighWaterMark+0x2a>
    16e2:	80 91 2a 02 	lds	r24, 0x022A
    16e6:	90 91 2b 02 	lds	r25, 0x022B
    16ea:	02 c0       	rjmp	.+4      	; 0x16f0 <uxTaskGetStackHighWaterMark+0x2e>
    16ec:	8e 81       	ldd	r24, Y+6	; 0x06
    16ee:	9f 81       	ldd	r25, Y+7	; 0x07
    16f0:	9a 83       	std	Y+2, r25	; 0x02
    16f2:	89 83       	std	Y+1, r24	; 0x01

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    16f4:	89 81       	ldd	r24, Y+1	; 0x01
    16f6:	9a 81       	ldd	r25, Y+2	; 0x02
    16f8:	fc 01       	movw	r30, r24
    16fa:	87 89       	ldd	r24, Z+23	; 0x17
    16fc:	90 8d       	ldd	r25, Z+24	; 0x18
    16fe:	9c 83       	std	Y+4, r25	; 0x04
    1700:	8b 83       	std	Y+3, r24	; 0x03
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
		}
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
    1702:	8b 81       	ldd	r24, Y+3	; 0x03
    1704:	9c 81       	ldd	r25, Y+4	; 0x04
    1706:	0e 94 3d 0b 	call	0x167a	; 0x167a <usTaskCheckFreeStackSpace>
    170a:	8d 83       	std	Y+5, r24	; 0x05

		return uxReturn;
    170c:	8d 81       	ldd	r24, Y+5	; 0x05
	}
    170e:	27 96       	adiw	r28, 0x07	; 7
    1710:	0f b6       	in	r0, 0x3f	; 63
    1712:	f8 94       	cli
    1714:	de bf       	out	0x3e, r29	; 62
    1716:	0f be       	out	0x3f, r0	; 63
    1718:	cd bf       	out	0x3d, r28	; 61
    171a:	df 91       	pop	r29
    171c:	cf 91       	pop	r28
    171e:	08 95       	ret

00001720 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	xTaskHandle xTaskGetCurrentTaskHandle( void )
	{
    1720:	cf 93       	push	r28
    1722:	df 93       	push	r29
    1724:	1f 92       	push	r1
    1726:	1f 92       	push	r1
    1728:	cd b7       	in	r28, 0x3d	; 61
    172a:	de b7       	in	r29, 0x3e	; 62
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    172c:	80 91 2a 02 	lds	r24, 0x022A
    1730:	90 91 2b 02 	lds	r25, 0x022B
    1734:	9a 83       	std	Y+2, r25	; 0x02
    1736:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    1738:	89 81       	ldd	r24, Y+1	; 0x01
    173a:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    173c:	0f 90       	pop	r0
    173e:	0f 90       	pop	r0
    1740:	df 91       	pop	r29
    1742:	cf 91       	pop	r28
    1744:	08 95       	ret

00001746 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    1746:	cf 93       	push	r28
    1748:	df 93       	push	r29
    174a:	00 d0       	rcall	.+0      	; 0x174c <vTaskPriorityInherit+0x6>
    174c:	1f 92       	push	r1
    174e:	cd b7       	in	r28, 0x3d	; 61
    1750:	de b7       	in	r29, 0x3e	; 62
    1752:	9c 83       	std	Y+4, r25	; 0x04
    1754:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
    1756:	8b 81       	ldd	r24, Y+3	; 0x03
    1758:	9c 81       	ldd	r25, Y+4	; 0x04
    175a:	9a 83       	std	Y+2, r25	; 0x02
    175c:	89 83       	std	Y+1, r24	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    175e:	8b 81       	ldd	r24, Y+3	; 0x03
    1760:	9c 81       	ldd	r25, Y+4	; 0x04
    1762:	00 97       	sbiw	r24, 0x00	; 0
    1764:	09 f4       	brne	.+2      	; 0x1768 <vTaskPriorityInherit+0x22>
    1766:	78 c0       	rjmp	.+240    	; 0x1858 <vTaskPriorityInherit+0x112>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    1768:	89 81       	ldd	r24, Y+1	; 0x01
    176a:	9a 81       	ldd	r25, Y+2	; 0x02
    176c:	fc 01       	movw	r30, r24
    176e:	26 89       	ldd	r18, Z+22	; 0x16
    1770:	80 91 2a 02 	lds	r24, 0x022A
    1774:	90 91 2b 02 	lds	r25, 0x022B
    1778:	fc 01       	movw	r30, r24
    177a:	86 89       	ldd	r24, Z+22	; 0x16
    177c:	28 17       	cp	r18, r24
    177e:	08 f0       	brcs	.+2      	; 0x1782 <vTaskPriorityInherit+0x3c>
    1780:	6b c0       	rjmp	.+214    	; 0x1858 <vTaskPriorityInherit+0x112>
			{
				/* Adjust the mutex holder state to account for its new priority. */
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    1782:	80 91 2a 02 	lds	r24, 0x022A
    1786:	90 91 2b 02 	lds	r25, 0x022B
    178a:	fc 01       	movw	r30, r24
    178c:	86 89       	ldd	r24, Z+22	; 0x16
    178e:	88 2f       	mov	r24, r24
    1790:	90 e0       	ldi	r25, 0x00	; 0
    1792:	24 e0       	ldi	r18, 0x04	; 4
    1794:	30 e0       	ldi	r19, 0x00	; 0
    1796:	28 1b       	sub	r18, r24
    1798:	39 0b       	sbc	r19, r25
    179a:	89 81       	ldd	r24, Y+1	; 0x01
    179c:	9a 81       	ldd	r25, Y+2	; 0x02
    179e:	fc 01       	movw	r30, r24
    17a0:	35 87       	std	Z+13, r19	; 0x0d
    17a2:	24 87       	std	Z+12, r18	; 0x0c

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    17a4:	89 81       	ldd	r24, Y+1	; 0x01
    17a6:	9a 81       	ldd	r25, Y+2	; 0x02
    17a8:	fc 01       	movw	r30, r24
    17aa:	42 85       	ldd	r20, Z+10	; 0x0a
    17ac:	53 85       	ldd	r21, Z+11	; 0x0b
    17ae:	89 81       	ldd	r24, Y+1	; 0x01
    17b0:	9a 81       	ldd	r25, Y+2	; 0x02
    17b2:	fc 01       	movw	r30, r24
    17b4:	86 89       	ldd	r24, Z+22	; 0x16
    17b6:	28 2f       	mov	r18, r24
    17b8:	30 e0       	ldi	r19, 0x00	; 0
    17ba:	c9 01       	movw	r24, r18
    17bc:	88 0f       	add	r24, r24
    17be:	99 1f       	adc	r25, r25
    17c0:	88 0f       	add	r24, r24
    17c2:	99 1f       	adc	r25, r25
    17c4:	88 0f       	add	r24, r24
    17c6:	99 1f       	adc	r25, r25
    17c8:	82 0f       	add	r24, r18
    17ca:	93 1f       	adc	r25, r19
    17cc:	84 5d       	subi	r24, 0xD4	; 212
    17ce:	9d 4f       	sbci	r25, 0xFD	; 253
    17d0:	48 17       	cp	r20, r24
    17d2:	59 07       	cpc	r21, r25
    17d4:	b9 f5       	brne	.+110    	; 0x1844 <vTaskPriorityInherit+0xfe>
				{
					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    17d6:	89 81       	ldd	r24, Y+1	; 0x01
    17d8:	9a 81       	ldd	r25, Y+2	; 0x02
    17da:	02 96       	adiw	r24, 0x02	; 2
    17dc:	0e 94 5e 13 	call	0x26bc	; 0x26bc <uxListRemove>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    17e0:	80 91 2a 02 	lds	r24, 0x022A
    17e4:	90 91 2b 02 	lds	r25, 0x022B
    17e8:	fc 01       	movw	r30, r24
    17ea:	26 89       	ldd	r18, Z+22	; 0x16
    17ec:	89 81       	ldd	r24, Y+1	; 0x01
    17ee:	9a 81       	ldd	r25, Y+2	; 0x02
    17f0:	fc 01       	movw	r30, r24
    17f2:	26 8b       	std	Z+22, r18	; 0x16
					prvAddTaskToReadyQueue( pxTCB );
    17f4:	89 81       	ldd	r24, Y+1	; 0x01
    17f6:	9a 81       	ldd	r25, Y+2	; 0x02
    17f8:	fc 01       	movw	r30, r24
    17fa:	96 89       	ldd	r25, Z+22	; 0x16
    17fc:	80 91 7c 02 	lds	r24, 0x027C
    1800:	89 17       	cp	r24, r25
    1802:	30 f4       	brcc	.+12     	; 0x1810 <vTaskPriorityInherit+0xca>
    1804:	89 81       	ldd	r24, Y+1	; 0x01
    1806:	9a 81       	ldd	r25, Y+2	; 0x02
    1808:	fc 01       	movw	r30, r24
    180a:	86 89       	ldd	r24, Z+22	; 0x16
    180c:	80 93 7c 02 	sts	0x027C, r24
    1810:	89 81       	ldd	r24, Y+1	; 0x01
    1812:	9a 81       	ldd	r25, Y+2	; 0x02
    1814:	ac 01       	movw	r20, r24
    1816:	4e 5f       	subi	r20, 0xFE	; 254
    1818:	5f 4f       	sbci	r21, 0xFF	; 255
    181a:	89 81       	ldd	r24, Y+1	; 0x01
    181c:	9a 81       	ldd	r25, Y+2	; 0x02
    181e:	fc 01       	movw	r30, r24
    1820:	86 89       	ldd	r24, Z+22	; 0x16
    1822:	28 2f       	mov	r18, r24
    1824:	30 e0       	ldi	r19, 0x00	; 0
    1826:	c9 01       	movw	r24, r18
    1828:	88 0f       	add	r24, r24
    182a:	99 1f       	adc	r25, r25
    182c:	88 0f       	add	r24, r24
    182e:	99 1f       	adc	r25, r25
    1830:	88 0f       	add	r24, r24
    1832:	99 1f       	adc	r25, r25
    1834:	82 0f       	add	r24, r18
    1836:	93 1f       	adc	r25, r19
    1838:	84 5d       	subi	r24, 0xD4	; 212
    183a:	9d 4f       	sbci	r25, 0xFD	; 253
    183c:	ba 01       	movw	r22, r20
    183e:	0e 94 8e 12 	call	0x251c	; 0x251c <vListInsertEnd>
    1842:	0a c0       	rjmp	.+20     	; 0x1858 <vTaskPriorityInherit+0x112>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    1844:	80 91 2a 02 	lds	r24, 0x022A
    1848:	90 91 2b 02 	lds	r25, 0x022B
    184c:	fc 01       	movw	r30, r24
    184e:	26 89       	ldd	r18, Z+22	; 0x16
    1850:	89 81       	ldd	r24, Y+1	; 0x01
    1852:	9a 81       	ldd	r25, Y+2	; 0x02
    1854:	fc 01       	movw	r30, r24
    1856:	26 8b       	std	Z+22, r18	; 0x16
				}

				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
			}
		}
	}
    1858:	0f 90       	pop	r0
    185a:	0f 90       	pop	r0
    185c:	0f 90       	pop	r0
    185e:	0f 90       	pop	r0
    1860:	df 91       	pop	r29
    1862:	cf 91       	pop	r28
    1864:	08 95       	ret

00001866 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    1866:	cf 93       	push	r28
    1868:	df 93       	push	r29
    186a:	00 d0       	rcall	.+0      	; 0x186c <vTaskPriorityDisinherit+0x6>
    186c:	1f 92       	push	r1
    186e:	cd b7       	in	r28, 0x3d	; 61
    1870:	de b7       	in	r29, 0x3e	; 62
    1872:	9c 83       	std	Y+4, r25	; 0x04
    1874:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
    1876:	8b 81       	ldd	r24, Y+3	; 0x03
    1878:	9c 81       	ldd	r25, Y+4	; 0x04
    187a:	9a 83       	std	Y+2, r25	; 0x02
    187c:	89 83       	std	Y+1, r24	; 0x01

		if( pxMutexHolder != NULL )
    187e:	8b 81       	ldd	r24, Y+3	; 0x03
    1880:	9c 81       	ldd	r25, Y+4	; 0x04
    1882:	00 97       	sbiw	r24, 0x00	; 0
    1884:	09 f4       	brne	.+2      	; 0x1888 <vTaskPriorityDisinherit+0x22>
    1886:	4e c0       	rjmp	.+156    	; 0x1924 <vTaskPriorityDisinherit+0xbe>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    1888:	89 81       	ldd	r24, Y+1	; 0x01
    188a:	9a 81       	ldd	r25, Y+2	; 0x02
    188c:	fc 01       	movw	r30, r24
    188e:	26 89       	ldd	r18, Z+22	; 0x16
    1890:	89 81       	ldd	r24, Y+1	; 0x01
    1892:	9a 81       	ldd	r25, Y+2	; 0x02
    1894:	fc 01       	movw	r30, r24
    1896:	81 a5       	ldd	r24, Z+41	; 0x29
    1898:	28 17       	cp	r18, r24
    189a:	09 f4       	brne	.+2      	; 0x189e <vTaskPriorityDisinherit+0x38>
    189c:	43 c0       	rjmp	.+134    	; 0x1924 <vTaskPriorityDisinherit+0xbe>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    189e:	89 81       	ldd	r24, Y+1	; 0x01
    18a0:	9a 81       	ldd	r25, Y+2	; 0x02
    18a2:	02 96       	adiw	r24, 0x02	; 2
    18a4:	0e 94 5e 13 	call	0x26bc	; 0x26bc <uxListRemove>
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    18a8:	89 81       	ldd	r24, Y+1	; 0x01
    18aa:	9a 81       	ldd	r25, Y+2	; 0x02
    18ac:	fc 01       	movw	r30, r24
    18ae:	21 a5       	ldd	r18, Z+41	; 0x29
    18b0:	89 81       	ldd	r24, Y+1	; 0x01
    18b2:	9a 81       	ldd	r25, Y+2	; 0x02
    18b4:	fc 01       	movw	r30, r24
    18b6:	26 8b       	std	Z+22, r18	; 0x16
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    18b8:	89 81       	ldd	r24, Y+1	; 0x01
    18ba:	9a 81       	ldd	r25, Y+2	; 0x02
    18bc:	fc 01       	movw	r30, r24
    18be:	86 89       	ldd	r24, Z+22	; 0x16
    18c0:	88 2f       	mov	r24, r24
    18c2:	90 e0       	ldi	r25, 0x00	; 0
    18c4:	24 e0       	ldi	r18, 0x04	; 4
    18c6:	30 e0       	ldi	r19, 0x00	; 0
    18c8:	28 1b       	sub	r18, r24
    18ca:	39 0b       	sbc	r19, r25
    18cc:	89 81       	ldd	r24, Y+1	; 0x01
    18ce:	9a 81       	ldd	r25, Y+2	; 0x02
    18d0:	fc 01       	movw	r30, r24
    18d2:	35 87       	std	Z+13, r19	; 0x0d
    18d4:	24 87       	std	Z+12, r18	; 0x0c
				prvAddTaskToReadyQueue( pxTCB );
    18d6:	89 81       	ldd	r24, Y+1	; 0x01
    18d8:	9a 81       	ldd	r25, Y+2	; 0x02
    18da:	fc 01       	movw	r30, r24
    18dc:	96 89       	ldd	r25, Z+22	; 0x16
    18de:	80 91 7c 02 	lds	r24, 0x027C
    18e2:	89 17       	cp	r24, r25
    18e4:	30 f4       	brcc	.+12     	; 0x18f2 <vTaskPriorityDisinherit+0x8c>
    18e6:	89 81       	ldd	r24, Y+1	; 0x01
    18e8:	9a 81       	ldd	r25, Y+2	; 0x02
    18ea:	fc 01       	movw	r30, r24
    18ec:	86 89       	ldd	r24, Z+22	; 0x16
    18ee:	80 93 7c 02 	sts	0x027C, r24
    18f2:	89 81       	ldd	r24, Y+1	; 0x01
    18f4:	9a 81       	ldd	r25, Y+2	; 0x02
    18f6:	ac 01       	movw	r20, r24
    18f8:	4e 5f       	subi	r20, 0xFE	; 254
    18fa:	5f 4f       	sbci	r21, 0xFF	; 255
    18fc:	89 81       	ldd	r24, Y+1	; 0x01
    18fe:	9a 81       	ldd	r25, Y+2	; 0x02
    1900:	fc 01       	movw	r30, r24
    1902:	86 89       	ldd	r24, Z+22	; 0x16
    1904:	28 2f       	mov	r18, r24
    1906:	30 e0       	ldi	r19, 0x00	; 0
    1908:	c9 01       	movw	r24, r18
    190a:	88 0f       	add	r24, r24
    190c:	99 1f       	adc	r25, r25
    190e:	88 0f       	add	r24, r24
    1910:	99 1f       	adc	r25, r25
    1912:	88 0f       	add	r24, r24
    1914:	99 1f       	adc	r25, r25
    1916:	82 0f       	add	r24, r18
    1918:	93 1f       	adc	r25, r19
    191a:	84 5d       	subi	r24, 0xD4	; 212
    191c:	9d 4f       	sbci	r25, 0xFD	; 253
    191e:	ba 01       	movw	r22, r20
    1920:	0e 94 8e 12 	call	0x251c	; 0x251c <vListInsertEnd>
			}
		}
	}
    1924:	0f 90       	pop	r0
    1926:	0f 90       	pop	r0
    1928:	0f 90       	pop	r0
    192a:	0f 90       	pop	r0
    192c:	df 91       	pop	r29
    192e:	cf 91       	pop	r28
    1930:	08 95       	ret

00001932 <xQueueGenericReset>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle pxQueue, portBASE_TYPE xNewQueue )
{
    1932:	cf 93       	push	r28
    1934:	df 93       	push	r29
    1936:	00 d0       	rcall	.+0      	; 0x1938 <xQueueGenericReset+0x6>
    1938:	cd b7       	in	r28, 0x3d	; 61
    193a:	de b7       	in	r29, 0x3e	; 62
    193c:	9a 83       	std	Y+2, r25	; 0x02
    193e:	89 83       	std	Y+1, r24	; 0x01
    1940:	6b 83       	std	Y+3, r22	; 0x03
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1942:	0f b6       	in	r0, 0x3f	; 63
    1944:	f8 94       	cli
    1946:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1948:	89 81       	ldd	r24, Y+1	; 0x01
    194a:	9a 81       	ldd	r25, Y+2	; 0x02
    194c:	fc 01       	movw	r30, r24
    194e:	20 81       	ld	r18, Z
    1950:	31 81       	ldd	r19, Z+1	; 0x01
    1952:	89 81       	ldd	r24, Y+1	; 0x01
    1954:	9a 81       	ldd	r25, Y+2	; 0x02
    1956:	fc 01       	movw	r30, r24
    1958:	83 8d       	ldd	r24, Z+27	; 0x1b
    195a:	68 2f       	mov	r22, r24
    195c:	70 e0       	ldi	r23, 0x00	; 0
    195e:	89 81       	ldd	r24, Y+1	; 0x01
    1960:	9a 81       	ldd	r25, Y+2	; 0x02
    1962:	fc 01       	movw	r30, r24
    1964:	84 8d       	ldd	r24, Z+28	; 0x1c
    1966:	48 2f       	mov	r20, r24
    1968:	50 e0       	ldi	r21, 0x00	; 0
    196a:	64 9f       	mul	r22, r20
    196c:	c0 01       	movw	r24, r0
    196e:	65 9f       	mul	r22, r21
    1970:	90 0d       	add	r25, r0
    1972:	74 9f       	mul	r23, r20
    1974:	90 0d       	add	r25, r0
    1976:	11 24       	eor	r1, r1
    1978:	28 0f       	add	r18, r24
    197a:	39 1f       	adc	r19, r25
    197c:	89 81       	ldd	r24, Y+1	; 0x01
    197e:	9a 81       	ldd	r25, Y+2	; 0x02
    1980:	fc 01       	movw	r30, r24
    1982:	33 83       	std	Z+3, r19	; 0x03
    1984:	22 83       	std	Z+2, r18	; 0x02
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1986:	89 81       	ldd	r24, Y+1	; 0x01
    1988:	9a 81       	ldd	r25, Y+2	; 0x02
    198a:	fc 01       	movw	r30, r24
    198c:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    198e:	89 81       	ldd	r24, Y+1	; 0x01
    1990:	9a 81       	ldd	r25, Y+2	; 0x02
    1992:	fc 01       	movw	r30, r24
    1994:	20 81       	ld	r18, Z
    1996:	31 81       	ldd	r19, Z+1	; 0x01
    1998:	89 81       	ldd	r24, Y+1	; 0x01
    199a:	9a 81       	ldd	r25, Y+2	; 0x02
    199c:	fc 01       	movw	r30, r24
    199e:	35 83       	std	Z+5, r19	; 0x05
    19a0:	24 83       	std	Z+4, r18	; 0x04
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
    19a2:	89 81       	ldd	r24, Y+1	; 0x01
    19a4:	9a 81       	ldd	r25, Y+2	; 0x02
    19a6:	fc 01       	movw	r30, r24
    19a8:	20 81       	ld	r18, Z
    19aa:	31 81       	ldd	r19, Z+1	; 0x01
    19ac:	89 81       	ldd	r24, Y+1	; 0x01
    19ae:	9a 81       	ldd	r25, Y+2	; 0x02
    19b0:	fc 01       	movw	r30, r24
    19b2:	83 8d       	ldd	r24, Z+27	; 0x1b
    19b4:	88 2f       	mov	r24, r24
    19b6:	90 e0       	ldi	r25, 0x00	; 0
    19b8:	bc 01       	movw	r22, r24
    19ba:	61 50       	subi	r22, 0x01	; 1
    19bc:	71 09       	sbc	r23, r1
    19be:	89 81       	ldd	r24, Y+1	; 0x01
    19c0:	9a 81       	ldd	r25, Y+2	; 0x02
    19c2:	fc 01       	movw	r30, r24
    19c4:	84 8d       	ldd	r24, Z+28	; 0x1c
    19c6:	48 2f       	mov	r20, r24
    19c8:	50 e0       	ldi	r21, 0x00	; 0
    19ca:	64 9f       	mul	r22, r20
    19cc:	c0 01       	movw	r24, r0
    19ce:	65 9f       	mul	r22, r21
    19d0:	90 0d       	add	r25, r0
    19d2:	74 9f       	mul	r23, r20
    19d4:	90 0d       	add	r25, r0
    19d6:	11 24       	eor	r1, r1
    19d8:	28 0f       	add	r18, r24
    19da:	39 1f       	adc	r19, r25
    19dc:	89 81       	ldd	r24, Y+1	; 0x01
    19de:	9a 81       	ldd	r25, Y+2	; 0x02
    19e0:	fc 01       	movw	r30, r24
    19e2:	37 83       	std	Z+7, r19	; 0x07
    19e4:	26 83       	std	Z+6, r18	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    19e6:	89 81       	ldd	r24, Y+1	; 0x01
    19e8:	9a 81       	ldd	r25, Y+2	; 0x02
    19ea:	2f ef       	ldi	r18, 0xFF	; 255
    19ec:	fc 01       	movw	r30, r24
    19ee:	25 8f       	std	Z+29, r18	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    19f0:	89 81       	ldd	r24, Y+1	; 0x01
    19f2:	9a 81       	ldd	r25, Y+2	; 0x02
    19f4:	2f ef       	ldi	r18, 0xFF	; 255
    19f6:	fc 01       	movw	r30, r24
    19f8:	26 8f       	std	Z+30, r18	; 0x1e

		if( xNewQueue == pdFALSE )
    19fa:	8b 81       	ldd	r24, Y+3	; 0x03
    19fc:	88 23       	and	r24, r24
    19fe:	81 f4       	brne	.+32     	; 0x1a20 <xQueueGenericReset+0xee>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to	write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1a00:	89 81       	ldd	r24, Y+1	; 0x01
    1a02:	9a 81       	ldd	r25, Y+2	; 0x02
    1a04:	fc 01       	movw	r30, r24
    1a06:	80 85       	ldd	r24, Z+8	; 0x08
    1a08:	88 23       	and	r24, r24
    1a0a:	a1 f0       	breq	.+40     	; 0x1a34 <xQueueGenericReset+0x102>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1a0c:	89 81       	ldd	r24, Y+1	; 0x01
    1a0e:	9a 81       	ldd	r25, Y+2	; 0x02
    1a10:	08 96       	adiw	r24, 0x08	; 8
    1a12:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <xTaskRemoveFromEventList>
    1a16:	81 30       	cpi	r24, 0x01	; 1
    1a18:	69 f4       	brne	.+26     	; 0x1a34 <xQueueGenericReset+0x102>
				{
					portYIELD_WITHIN_API();
    1a1a:	0e 94 20 19 	call	0x3240	; 0x3240 <vPortYield>
    1a1e:	0a c0       	rjmp	.+20     	; 0x1a34 <xQueueGenericReset+0x102>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1a20:	89 81       	ldd	r24, Y+1	; 0x01
    1a22:	9a 81       	ldd	r25, Y+2	; 0x02
    1a24:	08 96       	adiw	r24, 0x08	; 8
    1a26:	0e 94 46 12 	call	0x248c	; 0x248c <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1a2a:	89 81       	ldd	r24, Y+1	; 0x01
    1a2c:	9a 81       	ldd	r25, Y+2	; 0x02
    1a2e:	41 96       	adiw	r24, 0x11	; 17
    1a30:	0e 94 46 12 	call	0x248c	; 0x248c <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1a34:	0f 90       	pop	r0
    1a36:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    1a38:	81 e0       	ldi	r24, 0x01	; 1
}
    1a3a:	0f 90       	pop	r0
    1a3c:	0f 90       	pop	r0
    1a3e:	0f 90       	pop	r0
    1a40:	df 91       	pop	r29
    1a42:	cf 91       	pop	r28
    1a44:	08 95       	ret

00001a46 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
    1a46:	cf 93       	push	r28
    1a48:	df 93       	push	r29
    1a4a:	cd b7       	in	r28, 0x3d	; 61
    1a4c:	de b7       	in	r29, 0x3e	; 62
    1a4e:	29 97       	sbiw	r28, 0x09	; 9
    1a50:	0f b6       	in	r0, 0x3f	; 63
    1a52:	f8 94       	cli
    1a54:	de bf       	out	0x3e, r29	; 62
    1a56:	0f be       	out	0x3f, r0	; 63
    1a58:	cd bf       	out	0x3d, r28	; 61
    1a5a:	8f 83       	std	Y+7, r24	; 0x07
    1a5c:	68 87       	std	Y+8, r22	; 0x08
    1a5e:	49 87       	std	Y+9, r20	; 0x09
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    1a60:	1a 82       	std	Y+2, r1	; 0x02
    1a62:	19 82       	std	Y+1, r1	; 0x01
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    1a64:	8f 81       	ldd	r24, Y+7	; 0x07
    1a66:	88 23       	and	r24, r24
    1a68:	09 f4       	brne	.+2      	; 0x1a6c <xQueueGenericCreate+0x26>
    1a6a:	43 c0       	rjmp	.+134    	; 0x1af2 <xQueueGenericCreate+0xac>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    1a6c:	8f e1       	ldi	r24, 0x1F	; 31
    1a6e:	90 e0       	ldi	r25, 0x00	; 0
    1a70:	0e 94 ad 16 	call	0x2d5a	; 0x2d5a <pvPortMalloc>
    1a74:	9c 83       	std	Y+4, r25	; 0x04
    1a76:	8b 83       	std	Y+3, r24	; 0x03
		if( pxNewQueue != NULL )
    1a78:	8b 81       	ldd	r24, Y+3	; 0x03
    1a7a:	9c 81       	ldd	r25, Y+4	; 0x04
    1a7c:	00 97       	sbiw	r24, 0x00	; 0
    1a7e:	c9 f1       	breq	.+114    	; 0x1af2 <xQueueGenericCreate+0xac>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    1a80:	8f 81       	ldd	r24, Y+7	; 0x07
    1a82:	48 2f       	mov	r20, r24
    1a84:	50 e0       	ldi	r21, 0x00	; 0
    1a86:	88 85       	ldd	r24, Y+8	; 0x08
    1a88:	28 2f       	mov	r18, r24
    1a8a:	30 e0       	ldi	r19, 0x00	; 0
    1a8c:	42 9f       	mul	r20, r18
    1a8e:	c0 01       	movw	r24, r0
    1a90:	43 9f       	mul	r20, r19
    1a92:	90 0d       	add	r25, r0
    1a94:	52 9f       	mul	r21, r18
    1a96:	90 0d       	add	r25, r0
    1a98:	11 24       	eor	r1, r1
    1a9a:	01 96       	adiw	r24, 0x01	; 1
    1a9c:	9e 83       	std	Y+6, r25	; 0x06
    1a9e:	8d 83       	std	Y+5, r24	; 0x05

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    1aa0:	8d 81       	ldd	r24, Y+5	; 0x05
    1aa2:	9e 81       	ldd	r25, Y+6	; 0x06
    1aa4:	0e 94 ad 16 	call	0x2d5a	; 0x2d5a <pvPortMalloc>
    1aa8:	9c 01       	movw	r18, r24
    1aaa:	8b 81       	ldd	r24, Y+3	; 0x03
    1aac:	9c 81       	ldd	r25, Y+4	; 0x04
    1aae:	fc 01       	movw	r30, r24
    1ab0:	31 83       	std	Z+1, r19	; 0x01
    1ab2:	20 83       	st	Z, r18
			if( pxNewQueue->pcHead != NULL )
    1ab4:	8b 81       	ldd	r24, Y+3	; 0x03
    1ab6:	9c 81       	ldd	r25, Y+4	; 0x04
    1ab8:	fc 01       	movw	r30, r24
    1aba:	80 81       	ld	r24, Z
    1abc:	91 81       	ldd	r25, Z+1	; 0x01
    1abe:	00 97       	sbiw	r24, 0x00	; 0
    1ac0:	a1 f0       	breq	.+40     	; 0x1aea <xQueueGenericCreate+0xa4>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    1ac2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ac4:	9c 81       	ldd	r25, Y+4	; 0x04
    1ac6:	2f 81       	ldd	r18, Y+7	; 0x07
    1ac8:	fc 01       	movw	r30, r24
    1aca:	23 8f       	std	Z+27, r18	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1acc:	8b 81       	ldd	r24, Y+3	; 0x03
    1ace:	9c 81       	ldd	r25, Y+4	; 0x04
    1ad0:	28 85       	ldd	r18, Y+8	; 0x08
    1ad2:	fc 01       	movw	r30, r24
    1ad4:	24 8f       	std	Z+28, r18	; 0x1c
				xQueueGenericReset( pxNewQueue, pdTRUE );
    1ad6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ad8:	9c 81       	ldd	r25, Y+4	; 0x04
    1ada:	61 e0       	ldi	r22, 0x01	; 1
    1adc:	0e 94 99 0c 	call	0x1932	; 0x1932 <xQueueGenericReset>
					pxNewQueue->ucQueueType = ucQueueType;
				}
				#endif /* configUSE_TRACE_FACILITY */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    1ae0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ae2:	9c 81       	ldd	r25, Y+4	; 0x04
    1ae4:	9a 83       	std	Y+2, r25	; 0x02
    1ae6:	89 83       	std	Y+1, r24	; 0x01
    1ae8:	04 c0       	rjmp	.+8      	; 0x1af2 <xQueueGenericCreate+0xac>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    1aea:	8b 81       	ldd	r24, Y+3	; 0x03
    1aec:	9c 81       	ldd	r25, Y+4	; 0x04
    1aee:	0e 94 f3 16 	call	0x2de6	; 0x2de6 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    1af2:	89 81       	ldd	r24, Y+1	; 0x01
    1af4:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1af6:	29 96       	adiw	r28, 0x09	; 9
    1af8:	0f b6       	in	r0, 0x3f	; 63
    1afa:	f8 94       	cli
    1afc:	de bf       	out	0x3e, r29	; 62
    1afe:	0f be       	out	0x3f, r0	; 63
    1b00:	cd bf       	out	0x3d, r28	; 61
    1b02:	df 91       	pop	r29
    1b04:	cf 91       	pop	r28
    1b06:	08 95       	ret

00001b08 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
	{
    1b08:	cf 93       	push	r28
    1b0a:	df 93       	push	r29
    1b0c:	00 d0       	rcall	.+0      	; 0x1b0e <xQueueCreateMutex+0x6>
    1b0e:	cd b7       	in	r28, 0x3d	; 61
    1b10:	de b7       	in	r29, 0x3e	; 62
    1b12:	8b 83       	std	Y+3, r24	; 0x03
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    1b14:	8f e1       	ldi	r24, 0x1F	; 31
    1b16:	90 e0       	ldi	r25, 0x00	; 0
    1b18:	0e 94 ad 16 	call	0x2d5a	; 0x2d5a <pvPortMalloc>
    1b1c:	9a 83       	std	Y+2, r25	; 0x02
    1b1e:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    1b20:	89 81       	ldd	r24, Y+1	; 0x01
    1b22:	9a 81       	ldd	r25, Y+2	; 0x02
    1b24:	00 97       	sbiw	r24, 0x00	; 0
    1b26:	f1 f1       	breq	.+124    	; 0x1ba4 <xQueueCreateMutex+0x9c>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    1b28:	89 81       	ldd	r24, Y+1	; 0x01
    1b2a:	9a 81       	ldd	r25, Y+2	; 0x02
    1b2c:	fc 01       	movw	r30, r24
    1b2e:	13 82       	std	Z+3, r1	; 0x03
    1b30:	12 82       	std	Z+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    1b32:	89 81       	ldd	r24, Y+1	; 0x01
    1b34:	9a 81       	ldd	r25, Y+2	; 0x02
    1b36:	fc 01       	movw	r30, r24
    1b38:	11 82       	std	Z+1, r1	; 0x01
    1b3a:	10 82       	st	Z, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    1b3c:	89 81       	ldd	r24, Y+1	; 0x01
    1b3e:	9a 81       	ldd	r25, Y+2	; 0x02
    1b40:	fc 01       	movw	r30, r24
    1b42:	15 82       	std	Z+5, r1	; 0x05
    1b44:	14 82       	std	Z+4, r1	; 0x04
			pxNewQueue->pcReadFrom = NULL;
    1b46:	89 81       	ldd	r24, Y+1	; 0x01
    1b48:	9a 81       	ldd	r25, Y+2	; 0x02
    1b4a:	fc 01       	movw	r30, r24
    1b4c:	17 82       	std	Z+7, r1	; 0x07
    1b4e:	16 82       	std	Z+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1b50:	89 81       	ldd	r24, Y+1	; 0x01
    1b52:	9a 81       	ldd	r25, Y+2	; 0x02
    1b54:	fc 01       	movw	r30, r24
    1b56:	12 8e       	std	Z+26, r1	; 0x1a
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
    1b58:	89 81       	ldd	r24, Y+1	; 0x01
    1b5a:	9a 81       	ldd	r25, Y+2	; 0x02
    1b5c:	21 e0       	ldi	r18, 0x01	; 1
    1b5e:	fc 01       	movw	r30, r24
    1b60:	23 8f       	std	Z+27, r18	; 0x1b
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
    1b62:	89 81       	ldd	r24, Y+1	; 0x01
    1b64:	9a 81       	ldd	r25, Y+2	; 0x02
    1b66:	fc 01       	movw	r30, r24
    1b68:	14 8e       	std	Z+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    1b6a:	89 81       	ldd	r24, Y+1	; 0x01
    1b6c:	9a 81       	ldd	r25, Y+2	; 0x02
    1b6e:	2f ef       	ldi	r18, 0xFF	; 255
    1b70:	fc 01       	movw	r30, r24
    1b72:	25 8f       	std	Z+29, r18	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    1b74:	89 81       	ldd	r24, Y+1	; 0x01
    1b76:	9a 81       	ldd	r25, Y+2	; 0x02
    1b78:	2f ef       	ldi	r18, 0xFF	; 255
    1b7a:	fc 01       	movw	r30, r24
    1b7c:	26 8f       	std	Z+30, r18	; 0x1e
				pxNewQueue->ucQueueType = ucQueueType;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1b7e:	89 81       	ldd	r24, Y+1	; 0x01
    1b80:	9a 81       	ldd	r25, Y+2	; 0x02
    1b82:	08 96       	adiw	r24, 0x08	; 8
    1b84:	0e 94 46 12 	call	0x248c	; 0x248c <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1b88:	89 81       	ldd	r24, Y+1	; 0x01
    1b8a:	9a 81       	ldd	r25, Y+2	; 0x02
    1b8c:	41 96       	adiw	r24, 0x11	; 17
    1b8e:	0e 94 46 12 	call	0x248c	; 0x248c <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
    1b92:	89 81       	ldd	r24, Y+1	; 0x01
    1b94:	9a 81       	ldd	r25, Y+2	; 0x02
    1b96:	20 e0       	ldi	r18, 0x00	; 0
    1b98:	40 e0       	ldi	r20, 0x00	; 0
    1b9a:	50 e0       	ldi	r21, 0x00	; 0
    1b9c:	60 e0       	ldi	r22, 0x00	; 0
    1b9e:	70 e0       	ldi	r23, 0x00	; 0
    1ba0:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <xQueueGenericSend>
		{
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
    1ba4:	89 81       	ldd	r24, Y+1	; 0x01
    1ba6:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    1ba8:	0f 90       	pop	r0
    1baa:	0f 90       	pop	r0
    1bac:	0f 90       	pop	r0
    1bae:	df 91       	pop	r29
    1bb0:	cf 91       	pop	r28
    1bb2:	08 95       	ret

00001bb4 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    1bb4:	cf 93       	push	r28
    1bb6:	df 93       	push	r29
    1bb8:	cd b7       	in	r28, 0x3d	; 61
    1bba:	de b7       	in	r29, 0x3e	; 62
    1bbc:	2b 97       	sbiw	r28, 0x0b	; 11
    1bbe:	0f b6       	in	r0, 0x3f	; 63
    1bc0:	f8 94       	cli
    1bc2:	de bf       	out	0x3e, r29	; 62
    1bc4:	0f be       	out	0x3f, r0	; 63
    1bc6:	cd bf       	out	0x3d, r28	; 61
    1bc8:	9e 83       	std	Y+6, r25	; 0x06
    1bca:	8d 83       	std	Y+5, r24	; 0x05
    1bcc:	78 87       	std	Y+8, r23	; 0x08
    1bce:	6f 83       	std	Y+7, r22	; 0x07
    1bd0:	5a 87       	std	Y+10, r21	; 0x0a
    1bd2:	49 87       	std	Y+9, r20	; 0x09
    1bd4:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1bd6:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1bd8:	0f b6       	in	r0, 0x3f	; 63
    1bda:	f8 94       	cli
    1bdc:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1bde:	8d 81       	ldd	r24, Y+5	; 0x05
    1be0:	9e 81       	ldd	r25, Y+6	; 0x06
    1be2:	fc 01       	movw	r30, r24
    1be4:	22 8d       	ldd	r18, Z+26	; 0x1a
    1be6:	8d 81       	ldd	r24, Y+5	; 0x05
    1be8:	9e 81       	ldd	r25, Y+6	; 0x06
    1bea:	fc 01       	movw	r30, r24
    1bec:	83 8d       	ldd	r24, Z+27	; 0x1b
    1bee:	28 17       	cp	r18, r24
    1bf0:	d8 f4       	brcc	.+54     	; 0x1c28 <xQueueGenericSend+0x74>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1bf2:	2f 81       	ldd	r18, Y+7	; 0x07
    1bf4:	38 85       	ldd	r19, Y+8	; 0x08
    1bf6:	8d 81       	ldd	r24, Y+5	; 0x05
    1bf8:	9e 81       	ldd	r25, Y+6	; 0x06
    1bfa:	4b 85       	ldd	r20, Y+11	; 0x0b
    1bfc:	b9 01       	movw	r22, r18
    1bfe:	0e 94 64 10 	call	0x20c8	; 0x20c8 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1c02:	8d 81       	ldd	r24, Y+5	; 0x05
    1c04:	9e 81       	ldd	r25, Y+6	; 0x06
    1c06:	fc 01       	movw	r30, r24
    1c08:	81 89       	ldd	r24, Z+17	; 0x11
    1c0a:	88 23       	and	r24, r24
    1c0c:	49 f0       	breq	.+18     	; 0x1c20 <xQueueGenericSend+0x6c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1c0e:	8d 81       	ldd	r24, Y+5	; 0x05
    1c10:	9e 81       	ldd	r25, Y+6	; 0x06
    1c12:	41 96       	adiw	r24, 0x11	; 17
    1c14:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <xTaskRemoveFromEventList>
    1c18:	81 30       	cpi	r24, 0x01	; 1
    1c1a:	11 f4       	brne	.+4      	; 0x1c20 <xQueueGenericSend+0x6c>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    1c1c:	0e 94 20 19 	call	0x3240	; 0x3240 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    1c20:	0f 90       	pop	r0
    1c22:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    1c24:	81 e0       	ldi	r24, 0x01	; 1
    1c26:	61 c0       	rjmp	.+194    	; 0x1cea <xQueueGenericSend+0x136>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1c28:	89 85       	ldd	r24, Y+9	; 0x09
    1c2a:	9a 85       	ldd	r25, Y+10	; 0x0a
    1c2c:	00 97       	sbiw	r24, 0x00	; 0
    1c2e:	21 f4       	brne	.+8      	; 0x1c38 <xQueueGenericSend+0x84>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1c30:	0f 90       	pop	r0
    1c32:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1c34:	80 e0       	ldi	r24, 0x00	; 0
    1c36:	59 c0       	rjmp	.+178    	; 0x1cea <xQueueGenericSend+0x136>
				}
				else if( xEntryTimeSet == pdFALSE )
    1c38:	89 81       	ldd	r24, Y+1	; 0x01
    1c3a:	88 23       	and	r24, r24
    1c3c:	31 f4       	brne	.+12     	; 0x1c4a <xQueueGenericSend+0x96>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1c3e:	ce 01       	movw	r24, r28
    1c40:	02 96       	adiw	r24, 0x02	; 2
    1c42:	0e 94 5d 09 	call	0x12ba	; 0x12ba <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1c46:	81 e0       	ldi	r24, 0x01	; 1
    1c48:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    1c4a:	0f 90       	pop	r0
    1c4c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1c4e:	0e 94 7f 06 	call	0xcfe	; 0xcfe <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1c52:	0f b6       	in	r0, 0x3f	; 63
    1c54:	f8 94       	cli
    1c56:	0f 92       	push	r0
    1c58:	8d 81       	ldd	r24, Y+5	; 0x05
    1c5a:	9e 81       	ldd	r25, Y+6	; 0x06
    1c5c:	fc 01       	movw	r30, r24
    1c5e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c60:	8f 3f       	cpi	r24, 0xFF	; 255
    1c62:	21 f4       	brne	.+8      	; 0x1c6c <xQueueGenericSend+0xb8>
    1c64:	8d 81       	ldd	r24, Y+5	; 0x05
    1c66:	9e 81       	ldd	r25, Y+6	; 0x06
    1c68:	fc 01       	movw	r30, r24
    1c6a:	15 8e       	std	Z+29, r1	; 0x1d
    1c6c:	8d 81       	ldd	r24, Y+5	; 0x05
    1c6e:	9e 81       	ldd	r25, Y+6	; 0x06
    1c70:	fc 01       	movw	r30, r24
    1c72:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c74:	8f 3f       	cpi	r24, 0xFF	; 255
    1c76:	21 f4       	brne	.+8      	; 0x1c80 <xQueueGenericSend+0xcc>
    1c78:	8d 81       	ldd	r24, Y+5	; 0x05
    1c7a:	9e 81       	ldd	r25, Y+6	; 0x06
    1c7c:	fc 01       	movw	r30, r24
    1c7e:	16 8e       	std	Z+30, r1	; 0x1e
    1c80:	0f 90       	pop	r0
    1c82:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1c84:	9e 01       	movw	r18, r28
    1c86:	27 5f       	subi	r18, 0xF7	; 247
    1c88:	3f 4f       	sbci	r19, 0xFF	; 255
    1c8a:	ce 01       	movw	r24, r28
    1c8c:	02 96       	adiw	r24, 0x02	; 2
    1c8e:	b9 01       	movw	r22, r18
    1c90:	0e 94 79 09 	call	0x12f2	; 0x12f2 <xTaskCheckForTimeOut>
    1c94:	88 23       	and	r24, r24
    1c96:	01 f5       	brne	.+64     	; 0x1cd8 <xQueueGenericSend+0x124>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1c98:	8d 81       	ldd	r24, Y+5	; 0x05
    1c9a:	9e 81       	ldd	r25, Y+6	; 0x06
    1c9c:	0e 94 0b 12 	call	0x2416	; 0x2416 <prvIsQueueFull>
    1ca0:	88 23       	and	r24, r24
    1ca2:	99 f0       	breq	.+38     	; 0x1cca <xQueueGenericSend+0x116>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1ca4:	29 85       	ldd	r18, Y+9	; 0x09
    1ca6:	3a 85       	ldd	r19, Y+10	; 0x0a
    1ca8:	8d 81       	ldd	r24, Y+5	; 0x05
    1caa:	9e 81       	ldd	r25, Y+6	; 0x06
    1cac:	08 96       	adiw	r24, 0x08	; 8
    1cae:	b9 01       	movw	r22, r18
    1cb0:	0e 94 ae 08 	call	0x115c	; 0x115c <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1cb4:	8d 81       	ldd	r24, Y+5	; 0x05
    1cb6:	9e 81       	ldd	r25, Y+6	; 0x06
    1cb8:	0e 94 73 11 	call	0x22e6	; 0x22e6 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1cbc:	0e 94 8b 06 	call	0xd16	; 0xd16 <xTaskResumeAll>
    1cc0:	88 23       	and	r24, r24
    1cc2:	91 f4       	brne	.+36     	; 0x1ce8 <xQueueGenericSend+0x134>
				{
					portYIELD_WITHIN_API();
    1cc4:	0e 94 20 19 	call	0x3240	; 0x3240 <vPortYield>
    1cc8:	0f c0       	rjmp	.+30     	; 0x1ce8 <xQueueGenericSend+0x134>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1cca:	8d 81       	ldd	r24, Y+5	; 0x05
    1ccc:	9e 81       	ldd	r25, Y+6	; 0x06
    1cce:	0e 94 73 11 	call	0x22e6	; 0x22e6 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1cd2:	0e 94 8b 06 	call	0xd16	; 0xd16 <xTaskResumeAll>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
    1cd6:	80 cf       	rjmp	.-256    	; 0x1bd8 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1cd8:	8d 81       	ldd	r24, Y+5	; 0x05
    1cda:	9e 81       	ldd	r25, Y+6	; 0x06
    1cdc:	0e 94 73 11 	call	0x22e6	; 0x22e6 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1ce0:	0e 94 8b 06 	call	0xd16	; 0xd16 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1ce4:	80 e0       	ldi	r24, 0x00	; 0
    1ce6:	01 c0       	rjmp	.+2      	; 0x1cea <xQueueGenericSend+0x136>
		}
	}
    1ce8:	77 cf       	rjmp	.-274    	; 0x1bd8 <xQueueGenericSend+0x24>
}
    1cea:	2b 96       	adiw	r28, 0x0b	; 11
    1cec:	0f b6       	in	r0, 0x3f	; 63
    1cee:	f8 94       	cli
    1cf0:	de bf       	out	0x3e, r29	; 62
    1cf2:	0f be       	out	0x3f, r0	; 63
    1cf4:	cd bf       	out	0x3d, r28	; 61
    1cf6:	df 91       	pop	r29
    1cf8:	cf 91       	pop	r28
    1cfa:	08 95       	ret

00001cfc <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1cfc:	cf 93       	push	r28
    1cfe:	df 93       	push	r29
    1d00:	cd b7       	in	r28, 0x3d	; 61
    1d02:	de b7       	in	r29, 0x3e	; 62
    1d04:	29 97       	sbiw	r28, 0x09	; 9
    1d06:	0f b6       	in	r0, 0x3f	; 63
    1d08:	f8 94       	cli
    1d0a:	de bf       	out	0x3e, r29	; 62
    1d0c:	0f be       	out	0x3f, r0	; 63
    1d0e:	cd bf       	out	0x3d, r28	; 61
    1d10:	9c 83       	std	Y+4, r25	; 0x04
    1d12:	8b 83       	std	Y+3, r24	; 0x03
    1d14:	7e 83       	std	Y+6, r23	; 0x06
    1d16:	6d 83       	std	Y+5, r22	; 0x05
    1d18:	58 87       	std	Y+8, r21	; 0x08
    1d1a:	4f 83       	std	Y+7, r20	; 0x07
    1d1c:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1d1e:	1a 82       	std	Y+2, r1	; 0x02
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1d20:	8b 81       	ldd	r24, Y+3	; 0x03
    1d22:	9c 81       	ldd	r25, Y+4	; 0x04
    1d24:	fc 01       	movw	r30, r24
    1d26:	22 8d       	ldd	r18, Z+26	; 0x1a
    1d28:	8b 81       	ldd	r24, Y+3	; 0x03
    1d2a:	9c 81       	ldd	r25, Y+4	; 0x04
    1d2c:	fc 01       	movw	r30, r24
    1d2e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1d30:	28 17       	cp	r18, r24
    1d32:	90 f5       	brcc	.+100    	; 0x1d98 <xQueueGenericSendFromISR+0x9c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1d34:	2d 81       	ldd	r18, Y+5	; 0x05
    1d36:	3e 81       	ldd	r19, Y+6	; 0x06
    1d38:	8b 81       	ldd	r24, Y+3	; 0x03
    1d3a:	9c 81       	ldd	r25, Y+4	; 0x04
    1d3c:	49 85       	ldd	r20, Y+9	; 0x09
    1d3e:	b9 01       	movw	r22, r18
    1d40:	0e 94 64 10 	call	0x20c8	; 0x20c8 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1d44:	8b 81       	ldd	r24, Y+3	; 0x03
    1d46:	9c 81       	ldd	r25, Y+4	; 0x04
    1d48:	fc 01       	movw	r30, r24
    1d4a:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d4c:	8f 3f       	cpi	r24, 0xFF	; 255
    1d4e:	b9 f4       	brne	.+46     	; 0x1d7e <xQueueGenericSendFromISR+0x82>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1d50:	8b 81       	ldd	r24, Y+3	; 0x03
    1d52:	9c 81       	ldd	r25, Y+4	; 0x04
    1d54:	fc 01       	movw	r30, r24
    1d56:	81 89       	ldd	r24, Z+17	; 0x11
    1d58:	88 23       	and	r24, r24
    1d5a:	d9 f0       	breq	.+54     	; 0x1d92 <xQueueGenericSendFromISR+0x96>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1d5c:	8b 81       	ldd	r24, Y+3	; 0x03
    1d5e:	9c 81       	ldd	r25, Y+4	; 0x04
    1d60:	41 96       	adiw	r24, 0x11	; 17
    1d62:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <xTaskRemoveFromEventList>
    1d66:	88 23       	and	r24, r24
    1d68:	a1 f0       	breq	.+40     	; 0x1d92 <xQueueGenericSendFromISR+0x96>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						if( pxHigherPriorityTaskWoken != NULL )
    1d6a:	8f 81       	ldd	r24, Y+7	; 0x07
    1d6c:	98 85       	ldd	r25, Y+8	; 0x08
    1d6e:	00 97       	sbiw	r24, 0x00	; 0
    1d70:	81 f0       	breq	.+32     	; 0x1d92 <xQueueGenericSendFromISR+0x96>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1d72:	8f 81       	ldd	r24, Y+7	; 0x07
    1d74:	98 85       	ldd	r25, Y+8	; 0x08
    1d76:	21 e0       	ldi	r18, 0x01	; 1
    1d78:	fc 01       	movw	r30, r24
    1d7a:	20 83       	st	Z, r18
    1d7c:	0a c0       	rjmp	.+20     	; 0x1d92 <xQueueGenericSendFromISR+0x96>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1d7e:	8b 81       	ldd	r24, Y+3	; 0x03
    1d80:	9c 81       	ldd	r25, Y+4	; 0x04
    1d82:	fc 01       	movw	r30, r24
    1d84:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d86:	21 e0       	ldi	r18, 0x01	; 1
    1d88:	28 0f       	add	r18, r24
    1d8a:	8b 81       	ldd	r24, Y+3	; 0x03
    1d8c:	9c 81       	ldd	r25, Y+4	; 0x04
    1d8e:	fc 01       	movw	r30, r24
    1d90:	26 8f       	std	Z+30, r18	; 0x1e
			}

			xReturn = pdPASS;
    1d92:	81 e0       	ldi	r24, 0x01	; 1
    1d94:	89 83       	std	Y+1, r24	; 0x01
    1d96:	01 c0       	rjmp	.+2      	; 0x1d9a <xQueueGenericSendFromISR+0x9e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1d98:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1d9a:	89 81       	ldd	r24, Y+1	; 0x01
}
    1d9c:	29 96       	adiw	r28, 0x09	; 9
    1d9e:	0f b6       	in	r0, 0x3f	; 63
    1da0:	f8 94       	cli
    1da2:	de bf       	out	0x3e, r29	; 62
    1da4:	0f be       	out	0x3f, r0	; 63
    1da6:	cd bf       	out	0x3d, r28	; 61
    1da8:	df 91       	pop	r29
    1daa:	cf 91       	pop	r28
    1dac:	08 95       	ret

00001dae <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1dae:	cf 93       	push	r28
    1db0:	df 93       	push	r29
    1db2:	cd b7       	in	r28, 0x3d	; 61
    1db4:	de b7       	in	r29, 0x3e	; 62
    1db6:	2d 97       	sbiw	r28, 0x0d	; 13
    1db8:	0f b6       	in	r0, 0x3f	; 63
    1dba:	f8 94       	cli
    1dbc:	de bf       	out	0x3e, r29	; 62
    1dbe:	0f be       	out	0x3f, r0	; 63
    1dc0:	cd bf       	out	0x3d, r28	; 61
    1dc2:	98 87       	std	Y+8, r25	; 0x08
    1dc4:	8f 83       	std	Y+7, r24	; 0x07
    1dc6:	7a 87       	std	Y+10, r23	; 0x0a
    1dc8:	69 87       	std	Y+9, r22	; 0x09
    1dca:	5c 87       	std	Y+12, r21	; 0x0c
    1dcc:	4b 87       	std	Y+11, r20	; 0x0b
    1dce:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1dd0:	19 82       	std	Y+1, r1	; 0x01
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1dd2:	0f b6       	in	r0, 0x3f	; 63
    1dd4:	f8 94       	cli
    1dd6:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1dd8:	8f 81       	ldd	r24, Y+7	; 0x07
    1dda:	98 85       	ldd	r25, Y+8	; 0x08
    1ddc:	fc 01       	movw	r30, r24
    1dde:	82 8d       	ldd	r24, Z+26	; 0x1a
    1de0:	88 23       	and	r24, r24
    1de2:	09 f4       	brne	.+2      	; 0x1de6 <xQueueGenericReceive+0x38>
    1de4:	54 c0       	rjmp	.+168    	; 0x1e8e <xQueueGenericReceive+0xe0>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1de6:	8f 81       	ldd	r24, Y+7	; 0x07
    1de8:	98 85       	ldd	r25, Y+8	; 0x08
    1dea:	fc 01       	movw	r30, r24
    1dec:	86 81       	ldd	r24, Z+6	; 0x06
    1dee:	97 81       	ldd	r25, Z+7	; 0x07
    1df0:	9b 83       	std	Y+3, r25	; 0x03
    1df2:	8a 83       	std	Y+2, r24	; 0x02

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1df4:	29 85       	ldd	r18, Y+9	; 0x09
    1df6:	3a 85       	ldd	r19, Y+10	; 0x0a
    1df8:	8f 81       	ldd	r24, Y+7	; 0x07
    1dfa:	98 85       	ldd	r25, Y+8	; 0x08
    1dfc:	b9 01       	movw	r22, r18
    1dfe:	0e 94 22 11 	call	0x2244	; 0x2244 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1e02:	8d 85       	ldd	r24, Y+13	; 0x0d
    1e04:	88 23       	and	r24, r24
    1e06:	49 f5       	brne	.+82     	; 0x1e5a <xQueueGenericReceive+0xac>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1e08:	8f 81       	ldd	r24, Y+7	; 0x07
    1e0a:	98 85       	ldd	r25, Y+8	; 0x08
    1e0c:	fc 01       	movw	r30, r24
    1e0e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e10:	2f ef       	ldi	r18, 0xFF	; 255
    1e12:	28 0f       	add	r18, r24
    1e14:	8f 81       	ldd	r24, Y+7	; 0x07
    1e16:	98 85       	ldd	r25, Y+8	; 0x08
    1e18:	fc 01       	movw	r30, r24
    1e1a:	22 8f       	std	Z+26, r18	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1e1c:	8f 81       	ldd	r24, Y+7	; 0x07
    1e1e:	98 85       	ldd	r25, Y+8	; 0x08
    1e20:	fc 01       	movw	r30, r24
    1e22:	80 81       	ld	r24, Z
    1e24:	91 81       	ldd	r25, Z+1	; 0x01
    1e26:	00 97       	sbiw	r24, 0x00	; 0
    1e28:	41 f4       	brne	.+16     	; 0x1e3a <xQueueGenericReceive+0x8c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    1e2a:	0e 94 90 0b 	call	0x1720	; 0x1720 <xTaskGetCurrentTaskHandle>
    1e2e:	9c 01       	movw	r18, r24
    1e30:	8f 81       	ldd	r24, Y+7	; 0x07
    1e32:	98 85       	ldd	r25, Y+8	; 0x08
    1e34:	fc 01       	movw	r30, r24
    1e36:	33 83       	std	Z+3, r19	; 0x03
    1e38:	22 83       	std	Z+2, r18	; 0x02
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1e3a:	8f 81       	ldd	r24, Y+7	; 0x07
    1e3c:	98 85       	ldd	r25, Y+8	; 0x08
    1e3e:	fc 01       	movw	r30, r24
    1e40:	80 85       	ldd	r24, Z+8	; 0x08
    1e42:	88 23       	and	r24, r24
    1e44:	01 f1       	breq	.+64     	; 0x1e86 <xQueueGenericReceive+0xd8>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1e46:	8f 81       	ldd	r24, Y+7	; 0x07
    1e48:	98 85       	ldd	r25, Y+8	; 0x08
    1e4a:	08 96       	adiw	r24, 0x08	; 8
    1e4c:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <xTaskRemoveFromEventList>
    1e50:	81 30       	cpi	r24, 0x01	; 1
    1e52:	c9 f4       	brne	.+50     	; 0x1e86 <xQueueGenericReceive+0xd8>
						{
							portYIELD_WITHIN_API();
    1e54:	0e 94 20 19 	call	0x3240	; 0x3240 <vPortYield>
    1e58:	16 c0       	rjmp	.+44     	; 0x1e86 <xQueueGenericReceive+0xd8>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1e5a:	8f 81       	ldd	r24, Y+7	; 0x07
    1e5c:	98 85       	ldd	r25, Y+8	; 0x08
    1e5e:	2a 81       	ldd	r18, Y+2	; 0x02
    1e60:	3b 81       	ldd	r19, Y+3	; 0x03
    1e62:	fc 01       	movw	r30, r24
    1e64:	37 83       	std	Z+7, r19	; 0x07
    1e66:	26 83       	std	Z+6, r18	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1e68:	8f 81       	ldd	r24, Y+7	; 0x07
    1e6a:	98 85       	ldd	r25, Y+8	; 0x08
    1e6c:	fc 01       	movw	r30, r24
    1e6e:	81 89       	ldd	r24, Z+17	; 0x11
    1e70:	88 23       	and	r24, r24
    1e72:	49 f0       	breq	.+18     	; 0x1e86 <xQueueGenericReceive+0xd8>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1e74:	8f 81       	ldd	r24, Y+7	; 0x07
    1e76:	98 85       	ldd	r25, Y+8	; 0x08
    1e78:	41 96       	adiw	r24, 0x11	; 17
    1e7a:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <xTaskRemoveFromEventList>
    1e7e:	88 23       	and	r24, r24
    1e80:	11 f0       	breq	.+4      	; 0x1e86 <xQueueGenericReceive+0xd8>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1e82:	0e 94 20 19 	call	0x3240	; 0x3240 <vPortYield>
						}
					}
				}

				taskEXIT_CRITICAL();
    1e86:	0f 90       	pop	r0
    1e88:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1e8a:	81 e0       	ldi	r24, 0x01	; 1
    1e8c:	74 c0       	rjmp	.+232    	; 0x1f76 <xQueueGenericReceive+0x1c8>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1e8e:	8b 85       	ldd	r24, Y+11	; 0x0b
    1e90:	9c 85       	ldd	r25, Y+12	; 0x0c
    1e92:	00 97       	sbiw	r24, 0x00	; 0
    1e94:	21 f4       	brne	.+8      	; 0x1e9e <xQueueGenericReceive+0xf0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1e96:	0f 90       	pop	r0
    1e98:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1e9a:	80 e0       	ldi	r24, 0x00	; 0
    1e9c:	6c c0       	rjmp	.+216    	; 0x1f76 <xQueueGenericReceive+0x1c8>
				}
				else if( xEntryTimeSet == pdFALSE )
    1e9e:	89 81       	ldd	r24, Y+1	; 0x01
    1ea0:	88 23       	and	r24, r24
    1ea2:	31 f4       	brne	.+12     	; 0x1eb0 <xQueueGenericReceive+0x102>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1ea4:	ce 01       	movw	r24, r28
    1ea6:	04 96       	adiw	r24, 0x04	; 4
    1ea8:	0e 94 5d 09 	call	0x12ba	; 0x12ba <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1eac:	81 e0       	ldi	r24, 0x01	; 1
    1eae:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    1eb0:	0f 90       	pop	r0
    1eb2:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1eb4:	0e 94 7f 06 	call	0xcfe	; 0xcfe <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1eb8:	0f b6       	in	r0, 0x3f	; 63
    1eba:	f8 94       	cli
    1ebc:	0f 92       	push	r0
    1ebe:	8f 81       	ldd	r24, Y+7	; 0x07
    1ec0:	98 85       	ldd	r25, Y+8	; 0x08
    1ec2:	fc 01       	movw	r30, r24
    1ec4:	85 8d       	ldd	r24, Z+29	; 0x1d
    1ec6:	8f 3f       	cpi	r24, 0xFF	; 255
    1ec8:	21 f4       	brne	.+8      	; 0x1ed2 <xQueueGenericReceive+0x124>
    1eca:	8f 81       	ldd	r24, Y+7	; 0x07
    1ecc:	98 85       	ldd	r25, Y+8	; 0x08
    1ece:	fc 01       	movw	r30, r24
    1ed0:	15 8e       	std	Z+29, r1	; 0x1d
    1ed2:	8f 81       	ldd	r24, Y+7	; 0x07
    1ed4:	98 85       	ldd	r25, Y+8	; 0x08
    1ed6:	fc 01       	movw	r30, r24
    1ed8:	86 8d       	ldd	r24, Z+30	; 0x1e
    1eda:	8f 3f       	cpi	r24, 0xFF	; 255
    1edc:	21 f4       	brne	.+8      	; 0x1ee6 <xQueueGenericReceive+0x138>
    1ede:	8f 81       	ldd	r24, Y+7	; 0x07
    1ee0:	98 85       	ldd	r25, Y+8	; 0x08
    1ee2:	fc 01       	movw	r30, r24
    1ee4:	16 8e       	std	Z+30, r1	; 0x1e
    1ee6:	0f 90       	pop	r0
    1ee8:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1eea:	9e 01       	movw	r18, r28
    1eec:	25 5f       	subi	r18, 0xF5	; 245
    1eee:	3f 4f       	sbci	r19, 0xFF	; 255
    1ef0:	ce 01       	movw	r24, r28
    1ef2:	04 96       	adiw	r24, 0x04	; 4
    1ef4:	b9 01       	movw	r22, r18
    1ef6:	0e 94 79 09 	call	0x12f2	; 0x12f2 <xTaskCheckForTimeOut>
    1efa:	88 23       	and	r24, r24
    1efc:	99 f5       	brne	.+102    	; 0x1f64 <xQueueGenericReceive+0x1b6>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1efe:	8f 81       	ldd	r24, Y+7	; 0x07
    1f00:	98 85       	ldd	r25, Y+8	; 0x08
    1f02:	0e 94 d8 11 	call	0x23b0	; 0x23b0 <prvIsQueueEmpty>
    1f06:	88 23       	and	r24, r24
    1f08:	31 f1       	breq	.+76     	; 0x1f56 <xQueueGenericReceive+0x1a8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1f0a:	8f 81       	ldd	r24, Y+7	; 0x07
    1f0c:	98 85       	ldd	r25, Y+8	; 0x08
    1f0e:	fc 01       	movw	r30, r24
    1f10:	80 81       	ld	r24, Z
    1f12:	91 81       	ldd	r25, Z+1	; 0x01
    1f14:	00 97       	sbiw	r24, 0x00	; 0
    1f16:	61 f4       	brne	.+24     	; 0x1f30 <xQueueGenericReceive+0x182>
					{
						portENTER_CRITICAL();
    1f18:	0f b6       	in	r0, 0x3f	; 63
    1f1a:	f8 94       	cli
    1f1c:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1f1e:	8f 81       	ldd	r24, Y+7	; 0x07
    1f20:	98 85       	ldd	r25, Y+8	; 0x08
    1f22:	fc 01       	movw	r30, r24
    1f24:	82 81       	ldd	r24, Z+2	; 0x02
    1f26:	93 81       	ldd	r25, Z+3	; 0x03
    1f28:	0e 94 a3 0b 	call	0x1746	; 0x1746 <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    1f2c:	0f 90       	pop	r0
    1f2e:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1f30:	2b 85       	ldd	r18, Y+11	; 0x0b
    1f32:	3c 85       	ldd	r19, Y+12	; 0x0c
    1f34:	8f 81       	ldd	r24, Y+7	; 0x07
    1f36:	98 85       	ldd	r25, Y+8	; 0x08
    1f38:	41 96       	adiw	r24, 0x11	; 17
    1f3a:	b9 01       	movw	r22, r18
    1f3c:	0e 94 ae 08 	call	0x115c	; 0x115c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1f40:	8f 81       	ldd	r24, Y+7	; 0x07
    1f42:	98 85       	ldd	r25, Y+8	; 0x08
    1f44:	0e 94 73 11 	call	0x22e6	; 0x22e6 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1f48:	0e 94 8b 06 	call	0xd16	; 0xd16 <xTaskResumeAll>
    1f4c:	88 23       	and	r24, r24
    1f4e:	91 f4       	brne	.+36     	; 0x1f74 <xQueueGenericReceive+0x1c6>
				{
					portYIELD_WITHIN_API();
    1f50:	0e 94 20 19 	call	0x3240	; 0x3240 <vPortYield>
    1f54:	0f c0       	rjmp	.+30     	; 0x1f74 <xQueueGenericReceive+0x1c6>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1f56:	8f 81       	ldd	r24, Y+7	; 0x07
    1f58:	98 85       	ldd	r25, Y+8	; 0x08
    1f5a:	0e 94 73 11 	call	0x22e6	; 0x22e6 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1f5e:	0e 94 8b 06 	call	0xd16	; 0xd16 <xTaskResumeAll>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
    1f62:	37 cf       	rjmp	.-402    	; 0x1dd2 <xQueueGenericReceive+0x24>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1f64:	8f 81       	ldd	r24, Y+7	; 0x07
    1f66:	98 85       	ldd	r25, Y+8	; 0x08
    1f68:	0e 94 73 11 	call	0x22e6	; 0x22e6 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1f6c:	0e 94 8b 06 	call	0xd16	; 0xd16 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1f70:	80 e0       	ldi	r24, 0x00	; 0
    1f72:	01 c0       	rjmp	.+2      	; 0x1f76 <xQueueGenericReceive+0x1c8>
		}
	}
    1f74:	2e cf       	rjmp	.-420    	; 0x1dd2 <xQueueGenericReceive+0x24>
}
    1f76:	2d 96       	adiw	r28, 0x0d	; 13
    1f78:	0f b6       	in	r0, 0x3f	; 63
    1f7a:	f8 94       	cli
    1f7c:	de bf       	out	0x3e, r29	; 62
    1f7e:	0f be       	out	0x3f, r0	; 63
    1f80:	cd bf       	out	0x3d, r28	; 61
    1f82:	df 91       	pop	r29
    1f84:	cf 91       	pop	r28
    1f86:	08 95       	ret

00001f88 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
{
    1f88:	cf 93       	push	r28
    1f8a:	df 93       	push	r29
    1f8c:	cd b7       	in	r28, 0x3d	; 61
    1f8e:	de b7       	in	r29, 0x3e	; 62
    1f90:	28 97       	sbiw	r28, 0x08	; 8
    1f92:	0f b6       	in	r0, 0x3f	; 63
    1f94:	f8 94       	cli
    1f96:	de bf       	out	0x3e, r29	; 62
    1f98:	0f be       	out	0x3f, r0	; 63
    1f9a:	cd bf       	out	0x3d, r28	; 61
    1f9c:	9c 83       	std	Y+4, r25	; 0x04
    1f9e:	8b 83       	std	Y+3, r24	; 0x03
    1fa0:	7e 83       	std	Y+6, r23	; 0x06
    1fa2:	6d 83       	std	Y+5, r22	; 0x05
    1fa4:	58 87       	std	Y+8, r21	; 0x08
    1fa6:	4f 83       	std	Y+7, r20	; 0x07
unsigned portBASE_TYPE uxSavedInterruptStatus;

	configASSERT( pxQueue );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1fa8:	1a 82       	std	Y+2, r1	; 0x02
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1faa:	8b 81       	ldd	r24, Y+3	; 0x03
    1fac:	9c 81       	ldd	r25, Y+4	; 0x04
    1fae:	fc 01       	movw	r30, r24
    1fb0:	82 8d       	ldd	r24, Z+26	; 0x1a
    1fb2:	88 23       	and	r24, r24
    1fb4:	d9 f1       	breq	.+118    	; 0x202c <xQueueReceiveFromISR+0xa4>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1fb6:	2d 81       	ldd	r18, Y+5	; 0x05
    1fb8:	3e 81       	ldd	r19, Y+6	; 0x06
    1fba:	8b 81       	ldd	r24, Y+3	; 0x03
    1fbc:	9c 81       	ldd	r25, Y+4	; 0x04
    1fbe:	b9 01       	movw	r22, r18
    1fc0:	0e 94 22 11 	call	0x2244	; 0x2244 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1fc4:	8b 81       	ldd	r24, Y+3	; 0x03
    1fc6:	9c 81       	ldd	r25, Y+4	; 0x04
    1fc8:	fc 01       	movw	r30, r24
    1fca:	82 8d       	ldd	r24, Z+26	; 0x1a
    1fcc:	2f ef       	ldi	r18, 0xFF	; 255
    1fce:	28 0f       	add	r18, r24
    1fd0:	8b 81       	ldd	r24, Y+3	; 0x03
    1fd2:	9c 81       	ldd	r25, Y+4	; 0x04
    1fd4:	fc 01       	movw	r30, r24
    1fd6:	22 8f       	std	Z+26, r18	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1fd8:	8b 81       	ldd	r24, Y+3	; 0x03
    1fda:	9c 81       	ldd	r25, Y+4	; 0x04
    1fdc:	fc 01       	movw	r30, r24
    1fde:	85 8d       	ldd	r24, Z+29	; 0x1d
    1fe0:	8f 3f       	cpi	r24, 0xFF	; 255
    1fe2:	b9 f4       	brne	.+46     	; 0x2012 <xQueueReceiveFromISR+0x8a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1fe4:	8b 81       	ldd	r24, Y+3	; 0x03
    1fe6:	9c 81       	ldd	r25, Y+4	; 0x04
    1fe8:	fc 01       	movw	r30, r24
    1fea:	80 85       	ldd	r24, Z+8	; 0x08
    1fec:	88 23       	and	r24, r24
    1fee:	d9 f0       	breq	.+54     	; 0x2026 <xQueueReceiveFromISR+0x9e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1ff0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ff2:	9c 81       	ldd	r25, Y+4	; 0x04
    1ff4:	08 96       	adiw	r24, 0x08	; 8
    1ff6:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <xTaskRemoveFromEventList>
    1ffa:	88 23       	and	r24, r24
    1ffc:	a1 f0       	breq	.+40     	; 0x2026 <xQueueReceiveFromISR+0x9e>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1ffe:	8f 81       	ldd	r24, Y+7	; 0x07
    2000:	98 85       	ldd	r25, Y+8	; 0x08
    2002:	00 97       	sbiw	r24, 0x00	; 0
    2004:	81 f0       	breq	.+32     	; 0x2026 <xQueueReceiveFromISR+0x9e>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    2006:	8f 81       	ldd	r24, Y+7	; 0x07
    2008:	98 85       	ldd	r25, Y+8	; 0x08
    200a:	21 e0       	ldi	r18, 0x01	; 1
    200c:	fc 01       	movw	r30, r24
    200e:	20 83       	st	Z, r18
    2010:	0a c0       	rjmp	.+20     	; 0x2026 <xQueueReceiveFromISR+0x9e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    2012:	8b 81       	ldd	r24, Y+3	; 0x03
    2014:	9c 81       	ldd	r25, Y+4	; 0x04
    2016:	fc 01       	movw	r30, r24
    2018:	85 8d       	ldd	r24, Z+29	; 0x1d
    201a:	21 e0       	ldi	r18, 0x01	; 1
    201c:	28 0f       	add	r18, r24
    201e:	8b 81       	ldd	r24, Y+3	; 0x03
    2020:	9c 81       	ldd	r25, Y+4	; 0x04
    2022:	fc 01       	movw	r30, r24
    2024:	25 8f       	std	Z+29, r18	; 0x1d
			}

			xReturn = pdPASS;
    2026:	81 e0       	ldi	r24, 0x01	; 1
    2028:	89 83       	std	Y+1, r24	; 0x01
    202a:	01 c0       	rjmp	.+2      	; 0x202e <xQueueReceiveFromISR+0xa6>
		}
		else
		{
			xReturn = pdFAIL;
    202c:	19 82       	std	Y+1, r1	; 0x01
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    202e:	89 81       	ldd	r24, Y+1	; 0x01
}
    2030:	28 96       	adiw	r28, 0x08	; 8
    2032:	0f b6       	in	r0, 0x3f	; 63
    2034:	f8 94       	cli
    2036:	de bf       	out	0x3e, r29	; 62
    2038:	0f be       	out	0x3f, r0	; 63
    203a:	cd bf       	out	0x3d, r28	; 61
    203c:	df 91       	pop	r29
    203e:	cf 91       	pop	r28
    2040:	08 95       	ret

00002042 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    2042:	cf 93       	push	r28
    2044:	df 93       	push	r29
    2046:	00 d0       	rcall	.+0      	; 0x2048 <uxQueueMessagesWaiting+0x6>
    2048:	cd b7       	in	r28, 0x3d	; 61
    204a:	de b7       	in	r29, 0x3e	; 62
    204c:	9b 83       	std	Y+3, r25	; 0x03
    204e:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2050:	0f b6       	in	r0, 0x3f	; 63
    2052:	f8 94       	cli
    2054:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    2056:	8a 81       	ldd	r24, Y+2	; 0x02
    2058:	9b 81       	ldd	r25, Y+3	; 0x03
    205a:	fc 01       	movw	r30, r24
    205c:	82 8d       	ldd	r24, Z+26	; 0x1a
    205e:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    2060:	0f 90       	pop	r0
    2062:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2064:	89 81       	ldd	r24, Y+1	; 0x01
}
    2066:	0f 90       	pop	r0
    2068:	0f 90       	pop	r0
    206a:	0f 90       	pop	r0
    206c:	df 91       	pop	r29
    206e:	cf 91       	pop	r28
    2070:	08 95       	ret

00002072 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    2072:	cf 93       	push	r28
    2074:	df 93       	push	r29
    2076:	00 d0       	rcall	.+0      	; 0x2078 <uxQueueMessagesWaitingFromISR+0x6>
    2078:	cd b7       	in	r28, 0x3d	; 61
    207a:	de b7       	in	r29, 0x3e	; 62
    207c:	9b 83       	std	Y+3, r25	; 0x03
    207e:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    2080:	8a 81       	ldd	r24, Y+2	; 0x02
    2082:	9b 81       	ldd	r25, Y+3	; 0x03
    2084:	fc 01       	movw	r30, r24
    2086:	82 8d       	ldd	r24, Z+26	; 0x1a
    2088:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    208a:	89 81       	ldd	r24, Y+1	; 0x01
}
    208c:	0f 90       	pop	r0
    208e:	0f 90       	pop	r0
    2090:	0f 90       	pop	r0
    2092:	df 91       	pop	r29
    2094:	cf 91       	pop	r28
    2096:	08 95       	ret

00002098 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    2098:	cf 93       	push	r28
    209a:	df 93       	push	r29
    209c:	1f 92       	push	r1
    209e:	1f 92       	push	r1
    20a0:	cd b7       	in	r28, 0x3d	; 61
    20a2:	de b7       	in	r29, 0x3e	; 62
    20a4:	9a 83       	std	Y+2, r25	; 0x02
    20a6:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    20a8:	89 81       	ldd	r24, Y+1	; 0x01
    20aa:	9a 81       	ldd	r25, Y+2	; 0x02
    20ac:	fc 01       	movw	r30, r24
    20ae:	80 81       	ld	r24, Z
    20b0:	91 81       	ldd	r25, Z+1	; 0x01
    20b2:	0e 94 f3 16 	call	0x2de6	; 0x2de6 <vPortFree>
	vPortFree( pxQueue );
    20b6:	89 81       	ldd	r24, Y+1	; 0x01
    20b8:	9a 81       	ldd	r25, Y+2	; 0x02
    20ba:	0e 94 f3 16 	call	0x2de6	; 0x2de6 <vPortFree>
}
    20be:	0f 90       	pop	r0
    20c0:	0f 90       	pop	r0
    20c2:	df 91       	pop	r29
    20c4:	cf 91       	pop	r28
    20c6:	08 95       	ret

000020c8 <prvCopyDataToQueue>:

#endif
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    20c8:	cf 93       	push	r28
    20ca:	df 93       	push	r29
    20cc:	00 d0       	rcall	.+0      	; 0x20ce <prvCopyDataToQueue+0x6>
    20ce:	1f 92       	push	r1
    20d0:	1f 92       	push	r1
    20d2:	cd b7       	in	r28, 0x3d	; 61
    20d4:	de b7       	in	r29, 0x3e	; 62
    20d6:	9a 83       	std	Y+2, r25	; 0x02
    20d8:	89 83       	std	Y+1, r24	; 0x01
    20da:	7c 83       	std	Y+4, r23	; 0x04
    20dc:	6b 83       	std	Y+3, r22	; 0x03
    20de:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    20e0:	89 81       	ldd	r24, Y+1	; 0x01
    20e2:	9a 81       	ldd	r25, Y+2	; 0x02
    20e4:	fc 01       	movw	r30, r24
    20e6:	84 8d       	ldd	r24, Z+28	; 0x1c
    20e8:	88 23       	and	r24, r24
    20ea:	a9 f4       	brne	.+42     	; 0x2116 <prvCopyDataToQueue+0x4e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    20ec:	89 81       	ldd	r24, Y+1	; 0x01
    20ee:	9a 81       	ldd	r25, Y+2	; 0x02
    20f0:	fc 01       	movw	r30, r24
    20f2:	80 81       	ld	r24, Z
    20f4:	91 81       	ldd	r25, Z+1	; 0x01
    20f6:	00 97       	sbiw	r24, 0x00	; 0
    20f8:	09 f0       	breq	.+2      	; 0x20fc <prvCopyDataToQueue+0x34>
    20fa:	92 c0       	rjmp	.+292    	; 0x2220 <__stack+0x21>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    20fc:	89 81       	ldd	r24, Y+1	; 0x01
    20fe:	9a 81       	ldd	r25, Y+2	; 0x02
    2100:	fc 01       	movw	r30, r24
    2102:	82 81       	ldd	r24, Z+2	; 0x02
    2104:	93 81       	ldd	r25, Z+3	; 0x03
    2106:	0e 94 33 0c 	call	0x1866	; 0x1866 <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    210a:	89 81       	ldd	r24, Y+1	; 0x01
    210c:	9a 81       	ldd	r25, Y+2	; 0x02
    210e:	fc 01       	movw	r30, r24
    2110:	13 82       	std	Z+3, r1	; 0x03
    2112:	12 82       	std	Z+2, r1	; 0x02
    2114:	85 c0       	rjmp	.+266    	; 0x2220 <__stack+0x21>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    2116:	8d 81       	ldd	r24, Y+5	; 0x05
    2118:	88 23       	and	r24, r24
    211a:	d9 f5       	brne	.+118    	; 0x2192 <prvCopyDataToQueue+0xca>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    211c:	89 81       	ldd	r24, Y+1	; 0x01
    211e:	9a 81       	ldd	r25, Y+2	; 0x02
    2120:	fc 01       	movw	r30, r24
    2122:	84 8d       	ldd	r24, Z+28	; 0x1c
    2124:	48 2f       	mov	r20, r24
    2126:	50 e0       	ldi	r21, 0x00	; 0
    2128:	89 81       	ldd	r24, Y+1	; 0x01
    212a:	9a 81       	ldd	r25, Y+2	; 0x02
    212c:	fc 01       	movw	r30, r24
    212e:	84 81       	ldd	r24, Z+4	; 0x04
    2130:	95 81       	ldd	r25, Z+5	; 0x05
    2132:	2b 81       	ldd	r18, Y+3	; 0x03
    2134:	3c 81       	ldd	r19, Y+4	; 0x04
    2136:	b9 01       	movw	r22, r18
    2138:	0e 94 21 26 	call	0x4c42	; 0x4c42 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    213c:	89 81       	ldd	r24, Y+1	; 0x01
    213e:	9a 81       	ldd	r25, Y+2	; 0x02
    2140:	fc 01       	movw	r30, r24
    2142:	24 81       	ldd	r18, Z+4	; 0x04
    2144:	35 81       	ldd	r19, Z+5	; 0x05
    2146:	89 81       	ldd	r24, Y+1	; 0x01
    2148:	9a 81       	ldd	r25, Y+2	; 0x02
    214a:	fc 01       	movw	r30, r24
    214c:	84 8d       	ldd	r24, Z+28	; 0x1c
    214e:	88 2f       	mov	r24, r24
    2150:	90 e0       	ldi	r25, 0x00	; 0
    2152:	28 0f       	add	r18, r24
    2154:	39 1f       	adc	r19, r25
    2156:	89 81       	ldd	r24, Y+1	; 0x01
    2158:	9a 81       	ldd	r25, Y+2	; 0x02
    215a:	fc 01       	movw	r30, r24
    215c:	35 83       	std	Z+5, r19	; 0x05
    215e:	24 83       	std	Z+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    2160:	89 81       	ldd	r24, Y+1	; 0x01
    2162:	9a 81       	ldd	r25, Y+2	; 0x02
    2164:	fc 01       	movw	r30, r24
    2166:	24 81       	ldd	r18, Z+4	; 0x04
    2168:	35 81       	ldd	r19, Z+5	; 0x05
    216a:	89 81       	ldd	r24, Y+1	; 0x01
    216c:	9a 81       	ldd	r25, Y+2	; 0x02
    216e:	fc 01       	movw	r30, r24
    2170:	82 81       	ldd	r24, Z+2	; 0x02
    2172:	93 81       	ldd	r25, Z+3	; 0x03
    2174:	28 17       	cp	r18, r24
    2176:	39 07       	cpc	r19, r25
    2178:	08 f4       	brcc	.+2      	; 0x217c <prvCopyDataToQueue+0xb4>
    217a:	52 c0       	rjmp	.+164    	; 0x2220 <__stack+0x21>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    217c:	89 81       	ldd	r24, Y+1	; 0x01
    217e:	9a 81       	ldd	r25, Y+2	; 0x02
    2180:	fc 01       	movw	r30, r24
    2182:	20 81       	ld	r18, Z
    2184:	31 81       	ldd	r19, Z+1	; 0x01
    2186:	89 81       	ldd	r24, Y+1	; 0x01
    2188:	9a 81       	ldd	r25, Y+2	; 0x02
    218a:	fc 01       	movw	r30, r24
    218c:	35 83       	std	Z+5, r19	; 0x05
    218e:	24 83       	std	Z+4, r18	; 0x04
    2190:	47 c0       	rjmp	.+142    	; 0x2220 <__stack+0x21>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    2192:	89 81       	ldd	r24, Y+1	; 0x01
    2194:	9a 81       	ldd	r25, Y+2	; 0x02
    2196:	fc 01       	movw	r30, r24
    2198:	84 8d       	ldd	r24, Z+28	; 0x1c
    219a:	48 2f       	mov	r20, r24
    219c:	50 e0       	ldi	r21, 0x00	; 0
    219e:	89 81       	ldd	r24, Y+1	; 0x01
    21a0:	9a 81       	ldd	r25, Y+2	; 0x02
    21a2:	fc 01       	movw	r30, r24
    21a4:	86 81       	ldd	r24, Z+6	; 0x06
    21a6:	97 81       	ldd	r25, Z+7	; 0x07
    21a8:	2b 81       	ldd	r18, Y+3	; 0x03
    21aa:	3c 81       	ldd	r19, Y+4	; 0x04
    21ac:	b9 01       	movw	r22, r18
    21ae:	0e 94 21 26 	call	0x4c42	; 0x4c42 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    21b2:	89 81       	ldd	r24, Y+1	; 0x01
    21b4:	9a 81       	ldd	r25, Y+2	; 0x02
    21b6:	fc 01       	movw	r30, r24
    21b8:	26 81       	ldd	r18, Z+6	; 0x06
    21ba:	37 81       	ldd	r19, Z+7	; 0x07
    21bc:	89 81       	ldd	r24, Y+1	; 0x01
    21be:	9a 81       	ldd	r25, Y+2	; 0x02
    21c0:	fc 01       	movw	r30, r24
    21c2:	84 8d       	ldd	r24, Z+28	; 0x1c
    21c4:	88 2f       	mov	r24, r24
    21c6:	90 e0       	ldi	r25, 0x00	; 0
    21c8:	91 95       	neg	r25
    21ca:	81 95       	neg	r24
    21cc:	91 09       	sbc	r25, r1
    21ce:	28 0f       	add	r18, r24
    21d0:	39 1f       	adc	r19, r25
    21d2:	89 81       	ldd	r24, Y+1	; 0x01
    21d4:	9a 81       	ldd	r25, Y+2	; 0x02
    21d6:	fc 01       	movw	r30, r24
    21d8:	37 83       	std	Z+7, r19	; 0x07
    21da:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    21dc:	89 81       	ldd	r24, Y+1	; 0x01
    21de:	9a 81       	ldd	r25, Y+2	; 0x02
    21e0:	fc 01       	movw	r30, r24
    21e2:	26 81       	ldd	r18, Z+6	; 0x06
    21e4:	37 81       	ldd	r19, Z+7	; 0x07
    21e6:	89 81       	ldd	r24, Y+1	; 0x01
    21e8:	9a 81       	ldd	r25, Y+2	; 0x02
    21ea:	fc 01       	movw	r30, r24
    21ec:	80 81       	ld	r24, Z
    21ee:	91 81       	ldd	r25, Z+1	; 0x01
    21f0:	28 17       	cp	r18, r24
    21f2:	39 07       	cpc	r19, r25
    21f4:	a8 f4       	brcc	.+42     	; 0x2220 <__stack+0x21>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    21f6:	89 81       	ldd	r24, Y+1	; 0x01
    21f8:	9a 81       	ldd	r25, Y+2	; 0x02
    21fa:	fc 01       	movw	r30, r24
    21fc:	22 81       	ldd	r18, Z+2	; 0x02
    21fe:	33 81       	ldd	r19, Z+3	; 0x03
    2200:	89 81       	ldd	r24, Y+1	; 0x01
    2202:	9a 81       	ldd	r25, Y+2	; 0x02
    2204:	fc 01       	movw	r30, r24
    2206:	84 8d       	ldd	r24, Z+28	; 0x1c
    2208:	88 2f       	mov	r24, r24
    220a:	90 e0       	ldi	r25, 0x00	; 0
    220c:	91 95       	neg	r25
    220e:	81 95       	neg	r24
    2210:	91 09       	sbc	r25, r1
    2212:	28 0f       	add	r18, r24
    2214:	39 1f       	adc	r19, r25
    2216:	89 81       	ldd	r24, Y+1	; 0x01
    2218:	9a 81       	ldd	r25, Y+2	; 0x02
    221a:	fc 01       	movw	r30, r24
    221c:	37 83       	std	Z+7, r19	; 0x07
    221e:	26 83       	std	Z+6, r18	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    2220:	89 81       	ldd	r24, Y+1	; 0x01
    2222:	9a 81       	ldd	r25, Y+2	; 0x02
    2224:	fc 01       	movw	r30, r24
    2226:	82 8d       	ldd	r24, Z+26	; 0x1a
    2228:	21 e0       	ldi	r18, 0x01	; 1
    222a:	28 0f       	add	r18, r24
    222c:	89 81       	ldd	r24, Y+1	; 0x01
    222e:	9a 81       	ldd	r25, Y+2	; 0x02
    2230:	fc 01       	movw	r30, r24
    2232:	22 8f       	std	Z+26, r18	; 0x1a
}
    2234:	0f 90       	pop	r0
    2236:	0f 90       	pop	r0
    2238:	0f 90       	pop	r0
    223a:	0f 90       	pop	r0
    223c:	0f 90       	pop	r0
    223e:	df 91       	pop	r29
    2240:	cf 91       	pop	r28
    2242:	08 95       	ret

00002244 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    2244:	cf 93       	push	r28
    2246:	df 93       	push	r29
    2248:	00 d0       	rcall	.+0      	; 0x224a <prvCopyDataFromQueue+0x6>
    224a:	1f 92       	push	r1
    224c:	cd b7       	in	r28, 0x3d	; 61
    224e:	de b7       	in	r29, 0x3e	; 62
    2250:	9a 83       	std	Y+2, r25	; 0x02
    2252:	89 83       	std	Y+1, r24	; 0x01
    2254:	7c 83       	std	Y+4, r23	; 0x04
    2256:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    2258:	89 81       	ldd	r24, Y+1	; 0x01
    225a:	9a 81       	ldd	r25, Y+2	; 0x02
    225c:	fc 01       	movw	r30, r24
    225e:	80 81       	ld	r24, Z
    2260:	91 81       	ldd	r25, Z+1	; 0x01
    2262:	00 97       	sbiw	r24, 0x00	; 0
    2264:	c9 f1       	breq	.+114    	; 0x22d8 <prvCopyDataFromQueue+0x94>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    2266:	89 81       	ldd	r24, Y+1	; 0x01
    2268:	9a 81       	ldd	r25, Y+2	; 0x02
    226a:	fc 01       	movw	r30, r24
    226c:	26 81       	ldd	r18, Z+6	; 0x06
    226e:	37 81       	ldd	r19, Z+7	; 0x07
    2270:	89 81       	ldd	r24, Y+1	; 0x01
    2272:	9a 81       	ldd	r25, Y+2	; 0x02
    2274:	fc 01       	movw	r30, r24
    2276:	84 8d       	ldd	r24, Z+28	; 0x1c
    2278:	88 2f       	mov	r24, r24
    227a:	90 e0       	ldi	r25, 0x00	; 0
    227c:	28 0f       	add	r18, r24
    227e:	39 1f       	adc	r19, r25
    2280:	89 81       	ldd	r24, Y+1	; 0x01
    2282:	9a 81       	ldd	r25, Y+2	; 0x02
    2284:	fc 01       	movw	r30, r24
    2286:	37 83       	std	Z+7, r19	; 0x07
    2288:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    228a:	89 81       	ldd	r24, Y+1	; 0x01
    228c:	9a 81       	ldd	r25, Y+2	; 0x02
    228e:	fc 01       	movw	r30, r24
    2290:	26 81       	ldd	r18, Z+6	; 0x06
    2292:	37 81       	ldd	r19, Z+7	; 0x07
    2294:	89 81       	ldd	r24, Y+1	; 0x01
    2296:	9a 81       	ldd	r25, Y+2	; 0x02
    2298:	fc 01       	movw	r30, r24
    229a:	82 81       	ldd	r24, Z+2	; 0x02
    229c:	93 81       	ldd	r25, Z+3	; 0x03
    229e:	28 17       	cp	r18, r24
    22a0:	39 07       	cpc	r19, r25
    22a2:	50 f0       	brcs	.+20     	; 0x22b8 <prvCopyDataFromQueue+0x74>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    22a4:	89 81       	ldd	r24, Y+1	; 0x01
    22a6:	9a 81       	ldd	r25, Y+2	; 0x02
    22a8:	fc 01       	movw	r30, r24
    22aa:	20 81       	ld	r18, Z
    22ac:	31 81       	ldd	r19, Z+1	; 0x01
    22ae:	89 81       	ldd	r24, Y+1	; 0x01
    22b0:	9a 81       	ldd	r25, Y+2	; 0x02
    22b2:	fc 01       	movw	r30, r24
    22b4:	37 83       	std	Z+7, r19	; 0x07
    22b6:	26 83       	std	Z+6, r18	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    22b8:	89 81       	ldd	r24, Y+1	; 0x01
    22ba:	9a 81       	ldd	r25, Y+2	; 0x02
    22bc:	fc 01       	movw	r30, r24
    22be:	84 8d       	ldd	r24, Z+28	; 0x1c
    22c0:	48 2f       	mov	r20, r24
    22c2:	50 e0       	ldi	r21, 0x00	; 0
    22c4:	89 81       	ldd	r24, Y+1	; 0x01
    22c6:	9a 81       	ldd	r25, Y+2	; 0x02
    22c8:	fc 01       	movw	r30, r24
    22ca:	26 81       	ldd	r18, Z+6	; 0x06
    22cc:	37 81       	ldd	r19, Z+7	; 0x07
    22ce:	8b 81       	ldd	r24, Y+3	; 0x03
    22d0:	9c 81       	ldd	r25, Y+4	; 0x04
    22d2:	b9 01       	movw	r22, r18
    22d4:	0e 94 21 26 	call	0x4c42	; 0x4c42 <memcpy>
	}
}
    22d8:	0f 90       	pop	r0
    22da:	0f 90       	pop	r0
    22dc:	0f 90       	pop	r0
    22de:	0f 90       	pop	r0
    22e0:	df 91       	pop	r29
    22e2:	cf 91       	pop	r28
    22e4:	08 95       	ret

000022e6 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    22e6:	cf 93       	push	r28
    22e8:	df 93       	push	r29
    22ea:	1f 92       	push	r1
    22ec:	1f 92       	push	r1
    22ee:	cd b7       	in	r28, 0x3d	; 61
    22f0:	de b7       	in	r29, 0x3e	; 62
    22f2:	9a 83       	std	Y+2, r25	; 0x02
    22f4:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    22f6:	0f b6       	in	r0, 0x3f	; 63
    22f8:	f8 94       	cli
    22fa:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    22fc:	1b c0       	rjmp	.+54     	; 0x2334 <prvUnlockQueue+0x4e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    22fe:	89 81       	ldd	r24, Y+1	; 0x01
    2300:	9a 81       	ldd	r25, Y+2	; 0x02
    2302:	fc 01       	movw	r30, r24
    2304:	81 89       	ldd	r24, Z+17	; 0x11
    2306:	88 23       	and	r24, r24
    2308:	a1 f0       	breq	.+40     	; 0x2332 <prvUnlockQueue+0x4c>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    230a:	89 81       	ldd	r24, Y+1	; 0x01
    230c:	9a 81       	ldd	r25, Y+2	; 0x02
    230e:	41 96       	adiw	r24, 0x11	; 17
    2310:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <xTaskRemoveFromEventList>
    2314:	88 23       	and	r24, r24
    2316:	11 f0       	breq	.+4      	; 0x231c <prvUnlockQueue+0x36>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    2318:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    231c:	89 81       	ldd	r24, Y+1	; 0x01
    231e:	9a 81       	ldd	r25, Y+2	; 0x02
    2320:	fc 01       	movw	r30, r24
    2322:	86 8d       	ldd	r24, Z+30	; 0x1e
    2324:	2f ef       	ldi	r18, 0xFF	; 255
    2326:	28 0f       	add	r18, r24
    2328:	89 81       	ldd	r24, Y+1	; 0x01
    232a:	9a 81       	ldd	r25, Y+2	; 0x02
    232c:	fc 01       	movw	r30, r24
    232e:	26 8f       	std	Z+30, r18	; 0x1e
    2330:	01 c0       	rjmp	.+2      	; 0x2334 <prvUnlockQueue+0x4e>
			}
			else
			{
				break;
    2332:	06 c0       	rjmp	.+12     	; 0x2340 <prvUnlockQueue+0x5a>
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2334:	89 81       	ldd	r24, Y+1	; 0x01
    2336:	9a 81       	ldd	r25, Y+2	; 0x02
    2338:	fc 01       	movw	r30, r24
    233a:	86 8d       	ldd	r24, Z+30	; 0x1e
    233c:	18 16       	cp	r1, r24
    233e:	fc f2       	brlt	.-66     	; 0x22fe <prvUnlockQueue+0x18>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    2340:	89 81       	ldd	r24, Y+1	; 0x01
    2342:	9a 81       	ldd	r25, Y+2	; 0x02
    2344:	2f ef       	ldi	r18, 0xFF	; 255
    2346:	fc 01       	movw	r30, r24
    2348:	26 8f       	std	Z+30, r18	; 0x1e
	}
	taskEXIT_CRITICAL();
    234a:	0f 90       	pop	r0
    234c:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    234e:	0f b6       	in	r0, 0x3f	; 63
    2350:	f8 94       	cli
    2352:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2354:	1b c0       	rjmp	.+54     	; 0x238c <prvUnlockQueue+0xa6>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2356:	89 81       	ldd	r24, Y+1	; 0x01
    2358:	9a 81       	ldd	r25, Y+2	; 0x02
    235a:	fc 01       	movw	r30, r24
    235c:	80 85       	ldd	r24, Z+8	; 0x08
    235e:	88 23       	and	r24, r24
    2360:	a1 f0       	breq	.+40     	; 0x238a <prvUnlockQueue+0xa4>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2362:	89 81       	ldd	r24, Y+1	; 0x01
    2364:	9a 81       	ldd	r25, Y+2	; 0x02
    2366:	08 96       	adiw	r24, 0x08	; 8
    2368:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <xTaskRemoveFromEventList>
    236c:	88 23       	and	r24, r24
    236e:	11 f0       	breq	.+4      	; 0x2374 <prvUnlockQueue+0x8e>
				{
					vTaskMissedYield();
    2370:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    2374:	89 81       	ldd	r24, Y+1	; 0x01
    2376:	9a 81       	ldd	r25, Y+2	; 0x02
    2378:	fc 01       	movw	r30, r24
    237a:	85 8d       	ldd	r24, Z+29	; 0x1d
    237c:	2f ef       	ldi	r18, 0xFF	; 255
    237e:	28 0f       	add	r18, r24
    2380:	89 81       	ldd	r24, Y+1	; 0x01
    2382:	9a 81       	ldd	r25, Y+2	; 0x02
    2384:	fc 01       	movw	r30, r24
    2386:	25 8f       	std	Z+29, r18	; 0x1d
    2388:	01 c0       	rjmp	.+2      	; 0x238c <prvUnlockQueue+0xa6>
			}
			else
			{
				break;
    238a:	06 c0       	rjmp	.+12     	; 0x2398 <prvUnlockQueue+0xb2>
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    238c:	89 81       	ldd	r24, Y+1	; 0x01
    238e:	9a 81       	ldd	r25, Y+2	; 0x02
    2390:	fc 01       	movw	r30, r24
    2392:	85 8d       	ldd	r24, Z+29	; 0x1d
    2394:	18 16       	cp	r1, r24
    2396:	fc f2       	brlt	.-66     	; 0x2356 <prvUnlockQueue+0x70>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    2398:	89 81       	ldd	r24, Y+1	; 0x01
    239a:	9a 81       	ldd	r25, Y+2	; 0x02
    239c:	2f ef       	ldi	r18, 0xFF	; 255
    239e:	fc 01       	movw	r30, r24
    23a0:	25 8f       	std	Z+29, r18	; 0x1d
	}
	taskEXIT_CRITICAL();
    23a2:	0f 90       	pop	r0
    23a4:	0f be       	out	0x3f, r0	; 63
}
    23a6:	0f 90       	pop	r0
    23a8:	0f 90       	pop	r0
    23aa:	df 91       	pop	r29
    23ac:	cf 91       	pop	r28
    23ae:	08 95       	ret

000023b0 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    23b0:	cf 93       	push	r28
    23b2:	df 93       	push	r29
    23b4:	00 d0       	rcall	.+0      	; 0x23b6 <prvIsQueueEmpty+0x6>
    23b6:	cd b7       	in	r28, 0x3d	; 61
    23b8:	de b7       	in	r29, 0x3e	; 62
    23ba:	9b 83       	std	Y+3, r25	; 0x03
    23bc:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    23be:	0f b6       	in	r0, 0x3f	; 63
    23c0:	f8 94       	cli
    23c2:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    23c4:	8a 81       	ldd	r24, Y+2	; 0x02
    23c6:	9b 81       	ldd	r25, Y+3	; 0x03
    23c8:	fc 01       	movw	r30, r24
    23ca:	92 8d       	ldd	r25, Z+26	; 0x1a
    23cc:	81 e0       	ldi	r24, 0x01	; 1
    23ce:	99 23       	and	r25, r25
    23d0:	09 f0       	breq	.+2      	; 0x23d4 <prvIsQueueEmpty+0x24>
    23d2:	80 e0       	ldi	r24, 0x00	; 0
    23d4:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    23d6:	0f 90       	pop	r0
    23d8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    23da:	89 81       	ldd	r24, Y+1	; 0x01
}
    23dc:	0f 90       	pop	r0
    23de:	0f 90       	pop	r0
    23e0:	0f 90       	pop	r0
    23e2:	df 91       	pop	r29
    23e4:	cf 91       	pop	r28
    23e6:	08 95       	ret

000023e8 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    23e8:	cf 93       	push	r28
    23ea:	df 93       	push	r29
    23ec:	00 d0       	rcall	.+0      	; 0x23ee <xQueueIsQueueEmptyFromISR+0x6>
    23ee:	cd b7       	in	r28, 0x3d	; 61
    23f0:	de b7       	in	r29, 0x3e	; 62
    23f2:	9b 83       	std	Y+3, r25	; 0x03
    23f4:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    23f6:	8a 81       	ldd	r24, Y+2	; 0x02
    23f8:	9b 81       	ldd	r25, Y+3	; 0x03
    23fa:	fc 01       	movw	r30, r24
    23fc:	92 8d       	ldd	r25, Z+26	; 0x1a
    23fe:	81 e0       	ldi	r24, 0x01	; 1
    2400:	99 23       	and	r25, r25
    2402:	09 f0       	breq	.+2      	; 0x2406 <xQueueIsQueueEmptyFromISR+0x1e>
    2404:	80 e0       	ldi	r24, 0x00	; 0
    2406:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    2408:	89 81       	ldd	r24, Y+1	; 0x01
}
    240a:	0f 90       	pop	r0
    240c:	0f 90       	pop	r0
    240e:	0f 90       	pop	r0
    2410:	df 91       	pop	r29
    2412:	cf 91       	pop	r28
    2414:	08 95       	ret

00002416 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    2416:	cf 93       	push	r28
    2418:	df 93       	push	r29
    241a:	00 d0       	rcall	.+0      	; 0x241c <prvIsQueueFull+0x6>
    241c:	cd b7       	in	r28, 0x3d	; 61
    241e:	de b7       	in	r29, 0x3e	; 62
    2420:	9b 83       	std	Y+3, r25	; 0x03
    2422:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    2424:	0f b6       	in	r0, 0x3f	; 63
    2426:	f8 94       	cli
    2428:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    242a:	8a 81       	ldd	r24, Y+2	; 0x02
    242c:	9b 81       	ldd	r25, Y+3	; 0x03
    242e:	fc 01       	movw	r30, r24
    2430:	22 8d       	ldd	r18, Z+26	; 0x1a
    2432:	8a 81       	ldd	r24, Y+2	; 0x02
    2434:	9b 81       	ldd	r25, Y+3	; 0x03
    2436:	fc 01       	movw	r30, r24
    2438:	93 8d       	ldd	r25, Z+27	; 0x1b
    243a:	81 e0       	ldi	r24, 0x01	; 1
    243c:	29 17       	cp	r18, r25
    243e:	09 f0       	breq	.+2      	; 0x2442 <prvIsQueueFull+0x2c>
    2440:	80 e0       	ldi	r24, 0x00	; 0
    2442:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    2444:	0f 90       	pop	r0
    2446:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2448:	89 81       	ldd	r24, Y+1	; 0x01
}
    244a:	0f 90       	pop	r0
    244c:	0f 90       	pop	r0
    244e:	0f 90       	pop	r0
    2450:	df 91       	pop	r29
    2452:	cf 91       	pop	r28
    2454:	08 95       	ret

00002456 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    2456:	cf 93       	push	r28
    2458:	df 93       	push	r29
    245a:	00 d0       	rcall	.+0      	; 0x245c <xQueueIsQueueFullFromISR+0x6>
    245c:	cd b7       	in	r28, 0x3d	; 61
    245e:	de b7       	in	r29, 0x3e	; 62
    2460:	9b 83       	std	Y+3, r25	; 0x03
    2462:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    2464:	8a 81       	ldd	r24, Y+2	; 0x02
    2466:	9b 81       	ldd	r25, Y+3	; 0x03
    2468:	fc 01       	movw	r30, r24
    246a:	22 8d       	ldd	r18, Z+26	; 0x1a
    246c:	8a 81       	ldd	r24, Y+2	; 0x02
    246e:	9b 81       	ldd	r25, Y+3	; 0x03
    2470:	fc 01       	movw	r30, r24
    2472:	93 8d       	ldd	r25, Z+27	; 0x1b
    2474:	81 e0       	ldi	r24, 0x01	; 1
    2476:	29 17       	cp	r18, r25
    2478:	09 f0       	breq	.+2      	; 0x247c <xQueueIsQueueFullFromISR+0x26>
    247a:	80 e0       	ldi	r24, 0x00	; 0
    247c:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    247e:	89 81       	ldd	r24, Y+1	; 0x01
}
    2480:	0f 90       	pop	r0
    2482:	0f 90       	pop	r0
    2484:	0f 90       	pop	r0
    2486:	df 91       	pop	r29
    2488:	cf 91       	pop	r28
    248a:	08 95       	ret

0000248c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    248c:	cf 93       	push	r28
    248e:	df 93       	push	r29
    2490:	1f 92       	push	r1
    2492:	1f 92       	push	r1
    2494:	cd b7       	in	r28, 0x3d	; 61
    2496:	de b7       	in	r29, 0x3e	; 62
    2498:	9a 83       	std	Y+2, r25	; 0x02
    249a:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    249c:	89 81       	ldd	r24, Y+1	; 0x01
    249e:	9a 81       	ldd	r25, Y+2	; 0x02
    24a0:	9c 01       	movw	r18, r24
    24a2:	2d 5f       	subi	r18, 0xFD	; 253
    24a4:	3f 4f       	sbci	r19, 0xFF	; 255
    24a6:	89 81       	ldd	r24, Y+1	; 0x01
    24a8:	9a 81       	ldd	r25, Y+2	; 0x02
    24aa:	fc 01       	movw	r30, r24
    24ac:	32 83       	std	Z+2, r19	; 0x02
    24ae:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    24b0:	89 81       	ldd	r24, Y+1	; 0x01
    24b2:	9a 81       	ldd	r25, Y+2	; 0x02
    24b4:	2f ef       	ldi	r18, 0xFF	; 255
    24b6:	3f ef       	ldi	r19, 0xFF	; 255
    24b8:	fc 01       	movw	r30, r24
    24ba:	34 83       	std	Z+4, r19	; 0x04
    24bc:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    24be:	89 81       	ldd	r24, Y+1	; 0x01
    24c0:	9a 81       	ldd	r25, Y+2	; 0x02
    24c2:	9c 01       	movw	r18, r24
    24c4:	2d 5f       	subi	r18, 0xFD	; 253
    24c6:	3f 4f       	sbci	r19, 0xFF	; 255
    24c8:	89 81       	ldd	r24, Y+1	; 0x01
    24ca:	9a 81       	ldd	r25, Y+2	; 0x02
    24cc:	fc 01       	movw	r30, r24
    24ce:	36 83       	std	Z+6, r19	; 0x06
    24d0:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    24d2:	89 81       	ldd	r24, Y+1	; 0x01
    24d4:	9a 81       	ldd	r25, Y+2	; 0x02
    24d6:	9c 01       	movw	r18, r24
    24d8:	2d 5f       	subi	r18, 0xFD	; 253
    24da:	3f 4f       	sbci	r19, 0xFF	; 255
    24dc:	89 81       	ldd	r24, Y+1	; 0x01
    24de:	9a 81       	ldd	r25, Y+2	; 0x02
    24e0:	fc 01       	movw	r30, r24
    24e2:	30 87       	std	Z+8, r19	; 0x08
    24e4:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    24e6:	89 81       	ldd	r24, Y+1	; 0x01
    24e8:	9a 81       	ldd	r25, Y+2	; 0x02
    24ea:	fc 01       	movw	r30, r24
    24ec:	10 82       	st	Z, r1
}
    24ee:	0f 90       	pop	r0
    24f0:	0f 90       	pop	r0
    24f2:	df 91       	pop	r29
    24f4:	cf 91       	pop	r28
    24f6:	08 95       	ret

000024f8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    24f8:	cf 93       	push	r28
    24fa:	df 93       	push	r29
    24fc:	1f 92       	push	r1
    24fe:	1f 92       	push	r1
    2500:	cd b7       	in	r28, 0x3d	; 61
    2502:	de b7       	in	r29, 0x3e	; 62
    2504:	9a 83       	std	Y+2, r25	; 0x02
    2506:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    2508:	89 81       	ldd	r24, Y+1	; 0x01
    250a:	9a 81       	ldd	r25, Y+2	; 0x02
    250c:	fc 01       	movw	r30, r24
    250e:	11 86       	std	Z+9, r1	; 0x09
    2510:	10 86       	std	Z+8, r1	; 0x08
}
    2512:	0f 90       	pop	r0
    2514:	0f 90       	pop	r0
    2516:	df 91       	pop	r29
    2518:	cf 91       	pop	r28
    251a:	08 95       	ret

0000251c <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    251c:	cf 93       	push	r28
    251e:	df 93       	push	r29
    2520:	00 d0       	rcall	.+0      	; 0x2522 <vListInsertEnd+0x6>
    2522:	00 d0       	rcall	.+0      	; 0x2524 <vListInsertEnd+0x8>
    2524:	cd b7       	in	r28, 0x3d	; 61
    2526:	de b7       	in	r29, 0x3e	; 62
    2528:	9c 83       	std	Y+4, r25	; 0x04
    252a:	8b 83       	std	Y+3, r24	; 0x03
    252c:	7e 83       	std	Y+6, r23	; 0x06
    252e:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    2530:	8b 81       	ldd	r24, Y+3	; 0x03
    2532:	9c 81       	ldd	r25, Y+4	; 0x04
    2534:	fc 01       	movw	r30, r24
    2536:	81 81       	ldd	r24, Z+1	; 0x01
    2538:	92 81       	ldd	r25, Z+2	; 0x02
    253a:	9a 83       	std	Y+2, r25	; 0x02
    253c:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    253e:	89 81       	ldd	r24, Y+1	; 0x01
    2540:	9a 81       	ldd	r25, Y+2	; 0x02
    2542:	fc 01       	movw	r30, r24
    2544:	22 81       	ldd	r18, Z+2	; 0x02
    2546:	33 81       	ldd	r19, Z+3	; 0x03
    2548:	8d 81       	ldd	r24, Y+5	; 0x05
    254a:	9e 81       	ldd	r25, Y+6	; 0x06
    254c:	fc 01       	movw	r30, r24
    254e:	33 83       	std	Z+3, r19	; 0x03
    2550:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    2552:	8b 81       	ldd	r24, Y+3	; 0x03
    2554:	9c 81       	ldd	r25, Y+4	; 0x04
    2556:	fc 01       	movw	r30, r24
    2558:	21 81       	ldd	r18, Z+1	; 0x01
    255a:	32 81       	ldd	r19, Z+2	; 0x02
    255c:	8d 81       	ldd	r24, Y+5	; 0x05
    255e:	9e 81       	ldd	r25, Y+6	; 0x06
    2560:	fc 01       	movw	r30, r24
    2562:	35 83       	std	Z+5, r19	; 0x05
    2564:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2566:	89 81       	ldd	r24, Y+1	; 0x01
    2568:	9a 81       	ldd	r25, Y+2	; 0x02
    256a:	fc 01       	movw	r30, r24
    256c:	82 81       	ldd	r24, Z+2	; 0x02
    256e:	93 81       	ldd	r25, Z+3	; 0x03
    2570:	2d 81       	ldd	r18, Y+5	; 0x05
    2572:	3e 81       	ldd	r19, Y+6	; 0x06
    2574:	fc 01       	movw	r30, r24
    2576:	35 83       	std	Z+5, r19	; 0x05
    2578:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    257a:	89 81       	ldd	r24, Y+1	; 0x01
    257c:	9a 81       	ldd	r25, Y+2	; 0x02
    257e:	2d 81       	ldd	r18, Y+5	; 0x05
    2580:	3e 81       	ldd	r19, Y+6	; 0x06
    2582:	fc 01       	movw	r30, r24
    2584:	33 83       	std	Z+3, r19	; 0x03
    2586:	22 83       	std	Z+2, r18	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    2588:	8b 81       	ldd	r24, Y+3	; 0x03
    258a:	9c 81       	ldd	r25, Y+4	; 0x04
    258c:	2d 81       	ldd	r18, Y+5	; 0x05
    258e:	3e 81       	ldd	r19, Y+6	; 0x06
    2590:	fc 01       	movw	r30, r24
    2592:	32 83       	std	Z+2, r19	; 0x02
    2594:	21 83       	std	Z+1, r18	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2596:	8d 81       	ldd	r24, Y+5	; 0x05
    2598:	9e 81       	ldd	r25, Y+6	; 0x06
    259a:	2b 81       	ldd	r18, Y+3	; 0x03
    259c:	3c 81       	ldd	r19, Y+4	; 0x04
    259e:	fc 01       	movw	r30, r24
    25a0:	31 87       	std	Z+9, r19	; 0x09
    25a2:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    25a4:	8b 81       	ldd	r24, Y+3	; 0x03
    25a6:	9c 81       	ldd	r25, Y+4	; 0x04
    25a8:	fc 01       	movw	r30, r24
    25aa:	80 81       	ld	r24, Z
    25ac:	21 e0       	ldi	r18, 0x01	; 1
    25ae:	28 0f       	add	r18, r24
    25b0:	8b 81       	ldd	r24, Y+3	; 0x03
    25b2:	9c 81       	ldd	r25, Y+4	; 0x04
    25b4:	fc 01       	movw	r30, r24
    25b6:	20 83       	st	Z, r18
}
    25b8:	26 96       	adiw	r28, 0x06	; 6
    25ba:	0f b6       	in	r0, 0x3f	; 63
    25bc:	f8 94       	cli
    25be:	de bf       	out	0x3e, r29	; 62
    25c0:	0f be       	out	0x3f, r0	; 63
    25c2:	cd bf       	out	0x3d, r28	; 61
    25c4:	df 91       	pop	r29
    25c6:	cf 91       	pop	r28
    25c8:	08 95       	ret

000025ca <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    25ca:	cf 93       	push	r28
    25cc:	df 93       	push	r29
    25ce:	cd b7       	in	r28, 0x3d	; 61
    25d0:	de b7       	in	r29, 0x3e	; 62
    25d2:	28 97       	sbiw	r28, 0x08	; 8
    25d4:	0f b6       	in	r0, 0x3f	; 63
    25d6:	f8 94       	cli
    25d8:	de bf       	out	0x3e, r29	; 62
    25da:	0f be       	out	0x3f, r0	; 63
    25dc:	cd bf       	out	0x3d, r28	; 61
    25de:	9e 83       	std	Y+6, r25	; 0x06
    25e0:	8d 83       	std	Y+5, r24	; 0x05
    25e2:	78 87       	std	Y+8, r23	; 0x08
    25e4:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    25e6:	8f 81       	ldd	r24, Y+7	; 0x07
    25e8:	98 85       	ldd	r25, Y+8	; 0x08
    25ea:	fc 01       	movw	r30, r24
    25ec:	80 81       	ld	r24, Z
    25ee:	91 81       	ldd	r25, Z+1	; 0x01
    25f0:	9c 83       	std	Y+4, r25	; 0x04
    25f2:	8b 83       	std	Y+3, r24	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    25f4:	8b 81       	ldd	r24, Y+3	; 0x03
    25f6:	9c 81       	ldd	r25, Y+4	; 0x04
    25f8:	8f 3f       	cpi	r24, 0xFF	; 255
    25fa:	ff ef       	ldi	r31, 0xFF	; 255
    25fc:	9f 07       	cpc	r25, r31
    25fe:	41 f4       	brne	.+16     	; 0x2610 <vListInsert+0x46>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    2600:	8d 81       	ldd	r24, Y+5	; 0x05
    2602:	9e 81       	ldd	r25, Y+6	; 0x06
    2604:	fc 01       	movw	r30, r24
    2606:	87 81       	ldd	r24, Z+7	; 0x07
    2608:	90 85       	ldd	r25, Z+8	; 0x08
    260a:	9a 83       	std	Y+2, r25	; 0x02
    260c:	89 83       	std	Y+1, r24	; 0x01
    260e:	1a c0       	rjmp	.+52     	; 0x2644 <vListInsert+0x7a>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    2610:	8d 81       	ldd	r24, Y+5	; 0x05
    2612:	9e 81       	ldd	r25, Y+6	; 0x06
    2614:	03 96       	adiw	r24, 0x03	; 3
    2616:	9a 83       	std	Y+2, r25	; 0x02
    2618:	89 83       	std	Y+1, r24	; 0x01
    261a:	07 c0       	rjmp	.+14     	; 0x262a <vListInsert+0x60>
    261c:	89 81       	ldd	r24, Y+1	; 0x01
    261e:	9a 81       	ldd	r25, Y+2	; 0x02
    2620:	fc 01       	movw	r30, r24
    2622:	82 81       	ldd	r24, Z+2	; 0x02
    2624:	93 81       	ldd	r25, Z+3	; 0x03
    2626:	9a 83       	std	Y+2, r25	; 0x02
    2628:	89 83       	std	Y+1, r24	; 0x01
    262a:	89 81       	ldd	r24, Y+1	; 0x01
    262c:	9a 81       	ldd	r25, Y+2	; 0x02
    262e:	fc 01       	movw	r30, r24
    2630:	82 81       	ldd	r24, Z+2	; 0x02
    2632:	93 81       	ldd	r25, Z+3	; 0x03
    2634:	fc 01       	movw	r30, r24
    2636:	20 81       	ld	r18, Z
    2638:	31 81       	ldd	r19, Z+1	; 0x01
    263a:	8b 81       	ldd	r24, Y+3	; 0x03
    263c:	9c 81       	ldd	r25, Y+4	; 0x04
    263e:	82 17       	cp	r24, r18
    2640:	93 07       	cpc	r25, r19
    2642:	60 f7       	brcc	.-40     	; 0x261c <vListInsert+0x52>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2644:	89 81       	ldd	r24, Y+1	; 0x01
    2646:	9a 81       	ldd	r25, Y+2	; 0x02
    2648:	fc 01       	movw	r30, r24
    264a:	22 81       	ldd	r18, Z+2	; 0x02
    264c:	33 81       	ldd	r19, Z+3	; 0x03
    264e:	8f 81       	ldd	r24, Y+7	; 0x07
    2650:	98 85       	ldd	r25, Y+8	; 0x08
    2652:	fc 01       	movw	r30, r24
    2654:	33 83       	std	Z+3, r19	; 0x03
    2656:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2658:	8f 81       	ldd	r24, Y+7	; 0x07
    265a:	98 85       	ldd	r25, Y+8	; 0x08
    265c:	fc 01       	movw	r30, r24
    265e:	82 81       	ldd	r24, Z+2	; 0x02
    2660:	93 81       	ldd	r25, Z+3	; 0x03
    2662:	2f 81       	ldd	r18, Y+7	; 0x07
    2664:	38 85       	ldd	r19, Y+8	; 0x08
    2666:	fc 01       	movw	r30, r24
    2668:	35 83       	std	Z+5, r19	; 0x05
    266a:	24 83       	std	Z+4, r18	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    266c:	8f 81       	ldd	r24, Y+7	; 0x07
    266e:	98 85       	ldd	r25, Y+8	; 0x08
    2670:	29 81       	ldd	r18, Y+1	; 0x01
    2672:	3a 81       	ldd	r19, Y+2	; 0x02
    2674:	fc 01       	movw	r30, r24
    2676:	35 83       	std	Z+5, r19	; 0x05
    2678:	24 83       	std	Z+4, r18	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    267a:	89 81       	ldd	r24, Y+1	; 0x01
    267c:	9a 81       	ldd	r25, Y+2	; 0x02
    267e:	2f 81       	ldd	r18, Y+7	; 0x07
    2680:	38 85       	ldd	r19, Y+8	; 0x08
    2682:	fc 01       	movw	r30, r24
    2684:	33 83       	std	Z+3, r19	; 0x03
    2686:	22 83       	std	Z+2, r18	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2688:	8f 81       	ldd	r24, Y+7	; 0x07
    268a:	98 85       	ldd	r25, Y+8	; 0x08
    268c:	2d 81       	ldd	r18, Y+5	; 0x05
    268e:	3e 81       	ldd	r19, Y+6	; 0x06
    2690:	fc 01       	movw	r30, r24
    2692:	31 87       	std	Z+9, r19	; 0x09
    2694:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    2696:	8d 81       	ldd	r24, Y+5	; 0x05
    2698:	9e 81       	ldd	r25, Y+6	; 0x06
    269a:	fc 01       	movw	r30, r24
    269c:	80 81       	ld	r24, Z
    269e:	21 e0       	ldi	r18, 0x01	; 1
    26a0:	28 0f       	add	r18, r24
    26a2:	8d 81       	ldd	r24, Y+5	; 0x05
    26a4:	9e 81       	ldd	r25, Y+6	; 0x06
    26a6:	fc 01       	movw	r30, r24
    26a8:	20 83       	st	Z, r18
}
    26aa:	28 96       	adiw	r28, 0x08	; 8
    26ac:	0f b6       	in	r0, 0x3f	; 63
    26ae:	f8 94       	cli
    26b0:	de bf       	out	0x3e, r29	; 62
    26b2:	0f be       	out	0x3f, r0	; 63
    26b4:	cd bf       	out	0x3d, r28	; 61
    26b6:	df 91       	pop	r29
    26b8:	cf 91       	pop	r28
    26ba:	08 95       	ret

000026bc <uxListRemove>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
{
    26bc:	cf 93       	push	r28
    26be:	df 93       	push	r29
    26c0:	00 d0       	rcall	.+0      	; 0x26c2 <uxListRemove+0x6>
    26c2:	1f 92       	push	r1
    26c4:	cd b7       	in	r28, 0x3d	; 61
    26c6:	de b7       	in	r29, 0x3e	; 62
    26c8:	9c 83       	std	Y+4, r25	; 0x04
    26ca:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    26cc:	8b 81       	ldd	r24, Y+3	; 0x03
    26ce:	9c 81       	ldd	r25, Y+4	; 0x04
    26d0:	fc 01       	movw	r30, r24
    26d2:	82 81       	ldd	r24, Z+2	; 0x02
    26d4:	93 81       	ldd	r25, Z+3	; 0x03
    26d6:	2b 81       	ldd	r18, Y+3	; 0x03
    26d8:	3c 81       	ldd	r19, Y+4	; 0x04
    26da:	f9 01       	movw	r30, r18
    26dc:	24 81       	ldd	r18, Z+4	; 0x04
    26de:	35 81       	ldd	r19, Z+5	; 0x05
    26e0:	fc 01       	movw	r30, r24
    26e2:	35 83       	std	Z+5, r19	; 0x05
    26e4:	24 83       	std	Z+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    26e6:	8b 81       	ldd	r24, Y+3	; 0x03
    26e8:	9c 81       	ldd	r25, Y+4	; 0x04
    26ea:	fc 01       	movw	r30, r24
    26ec:	84 81       	ldd	r24, Z+4	; 0x04
    26ee:	95 81       	ldd	r25, Z+5	; 0x05
    26f0:	2b 81       	ldd	r18, Y+3	; 0x03
    26f2:	3c 81       	ldd	r19, Y+4	; 0x04
    26f4:	f9 01       	movw	r30, r18
    26f6:	22 81       	ldd	r18, Z+2	; 0x02
    26f8:	33 81       	ldd	r19, Z+3	; 0x03
    26fa:	fc 01       	movw	r30, r24
    26fc:	33 83       	std	Z+3, r19	; 0x03
    26fe:	22 83       	std	Z+2, r18	; 0x02

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    2700:	8b 81       	ldd	r24, Y+3	; 0x03
    2702:	9c 81       	ldd	r25, Y+4	; 0x04
    2704:	fc 01       	movw	r30, r24
    2706:	80 85       	ldd	r24, Z+8	; 0x08
    2708:	91 85       	ldd	r25, Z+9	; 0x09
    270a:	9a 83       	std	Y+2, r25	; 0x02
    270c:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    270e:	89 81       	ldd	r24, Y+1	; 0x01
    2710:	9a 81       	ldd	r25, Y+2	; 0x02
    2712:	fc 01       	movw	r30, r24
    2714:	21 81       	ldd	r18, Z+1	; 0x01
    2716:	32 81       	ldd	r19, Z+2	; 0x02
    2718:	8b 81       	ldd	r24, Y+3	; 0x03
    271a:	9c 81       	ldd	r25, Y+4	; 0x04
    271c:	28 17       	cp	r18, r24
    271e:	39 07       	cpc	r19, r25
    2720:	51 f4       	brne	.+20     	; 0x2736 <uxListRemove+0x7a>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2722:	8b 81       	ldd	r24, Y+3	; 0x03
    2724:	9c 81       	ldd	r25, Y+4	; 0x04
    2726:	fc 01       	movw	r30, r24
    2728:	24 81       	ldd	r18, Z+4	; 0x04
    272a:	35 81       	ldd	r19, Z+5	; 0x05
    272c:	89 81       	ldd	r24, Y+1	; 0x01
    272e:	9a 81       	ldd	r25, Y+2	; 0x02
    2730:	fc 01       	movw	r30, r24
    2732:	32 83       	std	Z+2, r19	; 0x02
    2734:	21 83       	std	Z+1, r18	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    2736:	8b 81       	ldd	r24, Y+3	; 0x03
    2738:	9c 81       	ldd	r25, Y+4	; 0x04
    273a:	fc 01       	movw	r30, r24
    273c:	11 86       	std	Z+9, r1	; 0x09
    273e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    2740:	89 81       	ldd	r24, Y+1	; 0x01
    2742:	9a 81       	ldd	r25, Y+2	; 0x02
    2744:	fc 01       	movw	r30, r24
    2746:	80 81       	ld	r24, Z
    2748:	2f ef       	ldi	r18, 0xFF	; 255
    274a:	28 0f       	add	r18, r24
    274c:	89 81       	ldd	r24, Y+1	; 0x01
    274e:	9a 81       	ldd	r25, Y+2	; 0x02
    2750:	fc 01       	movw	r30, r24
    2752:	20 83       	st	Z, r18

	return pxList->uxNumberOfItems;
    2754:	89 81       	ldd	r24, Y+1	; 0x01
    2756:	9a 81       	ldd	r25, Y+2	; 0x02
    2758:	fc 01       	movw	r30, r24
    275a:	80 81       	ld	r24, Z
}
    275c:	0f 90       	pop	r0
    275e:	0f 90       	pop	r0
    2760:	0f 90       	pop	r0
    2762:	0f 90       	pop	r0
    2764:	df 91       	pop	r29
    2766:	cf 91       	pop	r28
    2768:	08 95       	ret

0000276a <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    276a:	cf 93       	push	r28
    276c:	df 93       	push	r29
    276e:	cd b7       	in	r28, 0x3d	; 61
    2770:	de b7       	in	r29, 0x3e	; 62
    2772:	27 97       	sbiw	r28, 0x07	; 7
    2774:	0f b6       	in	r0, 0x3f	; 63
    2776:	f8 94       	cli
    2778:	de bf       	out	0x3e, r29	; 62
    277a:	0f be       	out	0x3f, r0	; 63
    277c:	cd bf       	out	0x3d, r28	; 61
    277e:	9d 83       	std	Y+5, r25	; 0x05
    2780:	8c 83       	std	Y+4, r24	; 0x04
    2782:	6e 83       	std	Y+6, r22	; 0x06
    2784:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    2786:	8a e1       	ldi	r24, 0x1A	; 26
    2788:	90 e0       	ldi	r25, 0x00	; 0
    278a:	0e 94 ad 16 	call	0x2d5a	; 0x2d5a <pvPortMalloc>
    278e:	9b 83       	std	Y+3, r25	; 0x03
    2790:	8a 83       	std	Y+2, r24	; 0x02
	if( pxCoRoutine )
    2792:	8a 81       	ldd	r24, Y+2	; 0x02
    2794:	9b 81       	ldd	r25, Y+3	; 0x03
    2796:	00 97       	sbiw	r24, 0x00	; 0
    2798:	09 f4       	brne	.+2      	; 0x279c <xCoRoutineCreate+0x32>
    279a:	77 c0       	rjmp	.+238    	; 0x288a <xCoRoutineCreate+0x120>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    279c:	80 91 83 02 	lds	r24, 0x0283
    27a0:	90 91 84 02 	lds	r25, 0x0284
    27a4:	00 97       	sbiw	r24, 0x00	; 0
    27a6:	41 f4       	brne	.+16     	; 0x27b8 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    27a8:	8a 81       	ldd	r24, Y+2	; 0x02
    27aa:	9b 81       	ldd	r25, Y+3	; 0x03
    27ac:	90 93 84 02 	sts	0x0284, r25
    27b0:	80 93 83 02 	sts	0x0283, r24
			prvInitialiseCoRoutineLists();
    27b4:	0e 94 3b 16 	call	0x2c76	; 0x2c76 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    27b8:	8e 81       	ldd	r24, Y+6	; 0x06
    27ba:	82 30       	cpi	r24, 0x02	; 2
    27bc:	10 f0       	brcs	.+4      	; 0x27c2 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    27be:	81 e0       	ldi	r24, 0x01	; 1
    27c0:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    27c2:	8a 81       	ldd	r24, Y+2	; 0x02
    27c4:	9b 81       	ldd	r25, Y+3	; 0x03
    27c6:	fc 01       	movw	r30, r24
    27c8:	11 8e       	std	Z+25, r1	; 0x19
    27ca:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    27cc:	8a 81       	ldd	r24, Y+2	; 0x02
    27ce:	9b 81       	ldd	r25, Y+3	; 0x03
    27d0:	2e 81       	ldd	r18, Y+6	; 0x06
    27d2:	fc 01       	movw	r30, r24
    27d4:	26 8b       	std	Z+22, r18	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    27d6:	8a 81       	ldd	r24, Y+2	; 0x02
    27d8:	9b 81       	ldd	r25, Y+3	; 0x03
    27da:	2f 81       	ldd	r18, Y+7	; 0x07
    27dc:	fc 01       	movw	r30, r24
    27de:	27 8b       	std	Z+23, r18	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    27e0:	8a 81       	ldd	r24, Y+2	; 0x02
    27e2:	9b 81       	ldd	r25, Y+3	; 0x03
    27e4:	2c 81       	ldd	r18, Y+4	; 0x04
    27e6:	3d 81       	ldd	r19, Y+5	; 0x05
    27e8:	fc 01       	movw	r30, r24
    27ea:	31 83       	std	Z+1, r19	; 0x01
    27ec:	20 83       	st	Z, r18

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    27ee:	8a 81       	ldd	r24, Y+2	; 0x02
    27f0:	9b 81       	ldd	r25, Y+3	; 0x03
    27f2:	02 96       	adiw	r24, 0x02	; 2
    27f4:	0e 94 7c 12 	call	0x24f8	; 0x24f8 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    27f8:	8a 81       	ldd	r24, Y+2	; 0x02
    27fa:	9b 81       	ldd	r25, Y+3	; 0x03
    27fc:	0c 96       	adiw	r24, 0x0c	; 12
    27fe:	0e 94 7c 12 	call	0x24f8	; 0x24f8 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    2802:	8a 81       	ldd	r24, Y+2	; 0x02
    2804:	9b 81       	ldd	r25, Y+3	; 0x03
    2806:	2a 81       	ldd	r18, Y+2	; 0x02
    2808:	3b 81       	ldd	r19, Y+3	; 0x03
    280a:	fc 01       	movw	r30, r24
    280c:	31 87       	std	Z+9, r19	; 0x09
    280e:	20 87       	std	Z+8, r18	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    2810:	8a 81       	ldd	r24, Y+2	; 0x02
    2812:	9b 81       	ldd	r25, Y+3	; 0x03
    2814:	2a 81       	ldd	r18, Y+2	; 0x02
    2816:	3b 81       	ldd	r19, Y+3	; 0x03
    2818:	fc 01       	movw	r30, r24
    281a:	33 8b       	std	Z+19, r19	; 0x13
    281c:	22 8b       	std	Z+18, r18	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    281e:	8e 81       	ldd	r24, Y+6	; 0x06
    2820:	88 2f       	mov	r24, r24
    2822:	90 e0       	ldi	r25, 0x00	; 0
    2824:	24 e0       	ldi	r18, 0x04	; 4
    2826:	30 e0       	ldi	r19, 0x00	; 0
    2828:	28 1b       	sub	r18, r24
    282a:	39 0b       	sbc	r19, r25
    282c:	8a 81       	ldd	r24, Y+2	; 0x02
    282e:	9b 81       	ldd	r25, Y+3	; 0x03
    2830:	fc 01       	movw	r30, r24
    2832:	35 87       	std	Z+13, r19	; 0x0d
    2834:	24 87       	std	Z+12, r18	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    2836:	8a 81       	ldd	r24, Y+2	; 0x02
    2838:	9b 81       	ldd	r25, Y+3	; 0x03
    283a:	fc 01       	movw	r30, r24
    283c:	96 89       	ldd	r25, Z+22	; 0x16
    283e:	80 91 b6 02 	lds	r24, 0x02B6
    2842:	89 17       	cp	r24, r25
    2844:	30 f4       	brcc	.+12     	; 0x2852 <xCoRoutineCreate+0xe8>
    2846:	8a 81       	ldd	r24, Y+2	; 0x02
    2848:	9b 81       	ldd	r25, Y+3	; 0x03
    284a:	fc 01       	movw	r30, r24
    284c:	86 89       	ldd	r24, Z+22	; 0x16
    284e:	80 93 b6 02 	sts	0x02B6, r24
    2852:	8a 81       	ldd	r24, Y+2	; 0x02
    2854:	9b 81       	ldd	r25, Y+3	; 0x03
    2856:	ac 01       	movw	r20, r24
    2858:	4e 5f       	subi	r20, 0xFE	; 254
    285a:	5f 4f       	sbci	r21, 0xFF	; 255
    285c:	8a 81       	ldd	r24, Y+2	; 0x02
    285e:	9b 81       	ldd	r25, Y+3	; 0x03
    2860:	fc 01       	movw	r30, r24
    2862:	86 89       	ldd	r24, Z+22	; 0x16
    2864:	28 2f       	mov	r18, r24
    2866:	30 e0       	ldi	r19, 0x00	; 0
    2868:	c9 01       	movw	r24, r18
    286a:	88 0f       	add	r24, r24
    286c:	99 1f       	adc	r25, r25
    286e:	88 0f       	add	r24, r24
    2870:	99 1f       	adc	r25, r25
    2872:	88 0f       	add	r24, r24
    2874:	99 1f       	adc	r25, r25
    2876:	82 0f       	add	r24, r18
    2878:	93 1f       	adc	r25, r19
    287a:	8b 57       	subi	r24, 0x7B	; 123
    287c:	9d 4f       	sbci	r25, 0xFD	; 253
    287e:	ba 01       	movw	r22, r20
    2880:	0e 94 8e 12 	call	0x251c	; 0x251c <vListInsertEnd>

		xReturn = pdPASS;
    2884:	81 e0       	ldi	r24, 0x01	; 1
    2886:	89 83       	std	Y+1, r24	; 0x01
    2888:	02 c0       	rjmp	.+4      	; 0x288e <xCoRoutineCreate+0x124>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    288a:	8f ef       	ldi	r24, 0xFF	; 255
    288c:	89 83       	std	Y+1, r24	; 0x01
	}
	
	return xReturn;	
    288e:	89 81       	ldd	r24, Y+1	; 0x01
}
    2890:	27 96       	adiw	r28, 0x07	; 7
    2892:	0f b6       	in	r0, 0x3f	; 63
    2894:	f8 94       	cli
    2896:	de bf       	out	0x3e, r29	; 62
    2898:	0f be       	out	0x3f, r0	; 63
    289a:	cd bf       	out	0x3d, r28	; 61
    289c:	df 91       	pop	r29
    289e:	cf 91       	pop	r28
    28a0:	08 95       	ret

000028a2 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    28a2:	cf 93       	push	r28
    28a4:	df 93       	push	r29
    28a6:	00 d0       	rcall	.+0      	; 0x28a8 <vCoRoutineAddToDelayedList+0x6>
    28a8:	00 d0       	rcall	.+0      	; 0x28aa <vCoRoutineAddToDelayedList+0x8>
    28aa:	cd b7       	in	r28, 0x3d	; 61
    28ac:	de b7       	in	r29, 0x3e	; 62
    28ae:	9c 83       	std	Y+4, r25	; 0x04
    28b0:	8b 83       	std	Y+3, r24	; 0x03
    28b2:	7e 83       	std	Y+6, r23	; 0x06
    28b4:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    28b6:	20 91 b7 02 	lds	r18, 0x02B7
    28ba:	30 91 b8 02 	lds	r19, 0x02B8
    28be:	8b 81       	ldd	r24, Y+3	; 0x03
    28c0:	9c 81       	ldd	r25, Y+4	; 0x04
    28c2:	82 0f       	add	r24, r18
    28c4:	93 1f       	adc	r25, r19
    28c6:	9a 83       	std	Y+2, r25	; 0x02
    28c8:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    28ca:	80 91 83 02 	lds	r24, 0x0283
    28ce:	90 91 84 02 	lds	r25, 0x0284
    28d2:	02 96       	adiw	r24, 0x02	; 2
    28d4:	0e 94 5e 13 	call	0x26bc	; 0x26bc <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    28d8:	80 91 83 02 	lds	r24, 0x0283
    28dc:	90 91 84 02 	lds	r25, 0x0284
    28e0:	29 81       	ldd	r18, Y+1	; 0x01
    28e2:	3a 81       	ldd	r19, Y+2	; 0x02
    28e4:	fc 01       	movw	r30, r24
    28e6:	33 83       	std	Z+3, r19	; 0x03
    28e8:	22 83       	std	Z+2, r18	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    28ea:	80 91 b7 02 	lds	r24, 0x02B7
    28ee:	90 91 b8 02 	lds	r25, 0x02B8
    28f2:	29 81       	ldd	r18, Y+1	; 0x01
    28f4:	3a 81       	ldd	r19, Y+2	; 0x02
    28f6:	28 17       	cp	r18, r24
    28f8:	39 07       	cpc	r19, r25
    28fa:	78 f4       	brcc	.+30     	; 0x291a <vCoRoutineAddToDelayedList+0x78>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    28fc:	80 91 83 02 	lds	r24, 0x0283
    2900:	90 91 84 02 	lds	r25, 0x0284
    2904:	9c 01       	movw	r18, r24
    2906:	2e 5f       	subi	r18, 0xFE	; 254
    2908:	3f 4f       	sbci	r19, 0xFF	; 255
    290a:	80 91 ab 02 	lds	r24, 0x02AB
    290e:	90 91 ac 02 	lds	r25, 0x02AC
    2912:	b9 01       	movw	r22, r18
    2914:	0e 94 e5 12 	call	0x25ca	; 0x25ca <vListInsert>
    2918:	0e c0       	rjmp	.+28     	; 0x2936 <vCoRoutineAddToDelayedList+0x94>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    291a:	80 91 83 02 	lds	r24, 0x0283
    291e:	90 91 84 02 	lds	r25, 0x0284
    2922:	9c 01       	movw	r18, r24
    2924:	2e 5f       	subi	r18, 0xFE	; 254
    2926:	3f 4f       	sbci	r19, 0xFF	; 255
    2928:	80 91 a9 02 	lds	r24, 0x02A9
    292c:	90 91 aa 02 	lds	r25, 0x02AA
    2930:	b9 01       	movw	r22, r18
    2932:	0e 94 e5 12 	call	0x25ca	; 0x25ca <vListInsert>
	}

	if( pxEventList )
    2936:	8d 81       	ldd	r24, Y+5	; 0x05
    2938:	9e 81       	ldd	r25, Y+6	; 0x06
    293a:	00 97       	sbiw	r24, 0x00	; 0
    293c:	61 f0       	breq	.+24     	; 0x2956 <vCoRoutineAddToDelayedList+0xb4>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    293e:	80 91 83 02 	lds	r24, 0x0283
    2942:	90 91 84 02 	lds	r25, 0x0284
    2946:	9c 01       	movw	r18, r24
    2948:	24 5f       	subi	r18, 0xF4	; 244
    294a:	3f 4f       	sbci	r19, 0xFF	; 255
    294c:	8d 81       	ldd	r24, Y+5	; 0x05
    294e:	9e 81       	ldd	r25, Y+6	; 0x06
    2950:	b9 01       	movw	r22, r18
    2952:	0e 94 e5 12 	call	0x25ca	; 0x25ca <vListInsert>
	}
}
    2956:	26 96       	adiw	r28, 0x06	; 6
    2958:	0f b6       	in	r0, 0x3f	; 63
    295a:	f8 94       	cli
    295c:	de bf       	out	0x3e, r29	; 62
    295e:	0f be       	out	0x3f, r0	; 63
    2960:	cd bf       	out	0x3d, r28	; 61
    2962:	df 91       	pop	r29
    2964:	cf 91       	pop	r28
    2966:	08 95       	ret

00002968 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    2968:	cf 93       	push	r28
    296a:	df 93       	push	r29
    296c:	1f 92       	push	r1
    296e:	1f 92       	push	r1
    2970:	cd b7       	in	r28, 0x3d	; 61
    2972:	de b7       	in	r29, 0x3e	; 62
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    2974:	3c c0       	rjmp	.+120    	; 0x29ee <prvCheckPendingReadyList+0x86>
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    2976:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    2978:	80 91 b2 02 	lds	r24, 0x02B2
    297c:	90 91 b3 02 	lds	r25, 0x02B3
    2980:	fc 01       	movw	r30, r24
    2982:	86 81       	ldd	r24, Z+6	; 0x06
    2984:	97 81       	ldd	r25, Z+7	; 0x07
    2986:	9a 83       	std	Y+2, r25	; 0x02
    2988:	89 83       	std	Y+1, r24	; 0x01
			uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    298a:	89 81       	ldd	r24, Y+1	; 0x01
    298c:	9a 81       	ldd	r25, Y+2	; 0x02
    298e:	0c 96       	adiw	r24, 0x0c	; 12
    2990:	0e 94 5e 13 	call	0x26bc	; 0x26bc <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    2994:	78 94       	sei

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    2996:	89 81       	ldd	r24, Y+1	; 0x01
    2998:	9a 81       	ldd	r25, Y+2	; 0x02
    299a:	02 96       	adiw	r24, 0x02	; 2
    299c:	0e 94 5e 13 	call	0x26bc	; 0x26bc <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    29a0:	89 81       	ldd	r24, Y+1	; 0x01
    29a2:	9a 81       	ldd	r25, Y+2	; 0x02
    29a4:	fc 01       	movw	r30, r24
    29a6:	96 89       	ldd	r25, Z+22	; 0x16
    29a8:	80 91 b6 02 	lds	r24, 0x02B6
    29ac:	89 17       	cp	r24, r25
    29ae:	30 f4       	brcc	.+12     	; 0x29bc <prvCheckPendingReadyList+0x54>
    29b0:	89 81       	ldd	r24, Y+1	; 0x01
    29b2:	9a 81       	ldd	r25, Y+2	; 0x02
    29b4:	fc 01       	movw	r30, r24
    29b6:	86 89       	ldd	r24, Z+22	; 0x16
    29b8:	80 93 b6 02 	sts	0x02B6, r24
    29bc:	89 81       	ldd	r24, Y+1	; 0x01
    29be:	9a 81       	ldd	r25, Y+2	; 0x02
    29c0:	ac 01       	movw	r20, r24
    29c2:	4e 5f       	subi	r20, 0xFE	; 254
    29c4:	5f 4f       	sbci	r21, 0xFF	; 255
    29c6:	89 81       	ldd	r24, Y+1	; 0x01
    29c8:	9a 81       	ldd	r25, Y+2	; 0x02
    29ca:	fc 01       	movw	r30, r24
    29cc:	86 89       	ldd	r24, Z+22	; 0x16
    29ce:	28 2f       	mov	r18, r24
    29d0:	30 e0       	ldi	r19, 0x00	; 0
    29d2:	c9 01       	movw	r24, r18
    29d4:	88 0f       	add	r24, r24
    29d6:	99 1f       	adc	r25, r25
    29d8:	88 0f       	add	r24, r24
    29da:	99 1f       	adc	r25, r25
    29dc:	88 0f       	add	r24, r24
    29de:	99 1f       	adc	r25, r25
    29e0:	82 0f       	add	r24, r18
    29e2:	93 1f       	adc	r25, r19
    29e4:	8b 57       	subi	r24, 0x7B	; 123
    29e6:	9d 4f       	sbci	r25, 0xFD	; 253
    29e8:	ba 01       	movw	r22, r20
    29ea:	0e 94 8e 12 	call	0x251c	; 0x251c <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    29ee:	80 91 ad 02 	lds	r24, 0x02AD
    29f2:	88 23       	and	r24, r24
    29f4:	09 f0       	breq	.+2      	; 0x29f8 <prvCheckPendingReadyList+0x90>
    29f6:	bf cf       	rjmp	.-130    	; 0x2976 <prvCheckPendingReadyList+0xe>
		portENABLE_INTERRUPTS();

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    29f8:	0f 90       	pop	r0
    29fa:	0f 90       	pop	r0
    29fc:	df 91       	pop	r29
    29fe:	cf 91       	pop	r28
    2a00:	08 95       	ret

00002a02 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    2a02:	cf 93       	push	r28
    2a04:	df 93       	push	r29
    2a06:	00 d0       	rcall	.+0      	; 0x2a08 <prvCheckDelayedList+0x6>
    2a08:	1f 92       	push	r1
    2a0a:	cd b7       	in	r28, 0x3d	; 61
    2a0c:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    2a0e:	0e 94 0f 07 	call	0xe1e	; 0xe1e <xTaskGetTickCount>
    2a12:	9c 01       	movw	r18, r24
    2a14:	80 91 b9 02 	lds	r24, 0x02B9
    2a18:	90 91 ba 02 	lds	r25, 0x02BA
    2a1c:	a9 01       	movw	r20, r18
    2a1e:	48 1b       	sub	r20, r24
    2a20:	59 0b       	sbc	r21, r25
    2a22:	ca 01       	movw	r24, r20
    2a24:	90 93 bc 02 	sts	0x02BC, r25
    2a28:	80 93 bb 02 	sts	0x02BB, r24
	while( xPassedTicks )
    2a2c:	8a c0       	rjmp	.+276    	; 0x2b42 <prvCheckDelayedList+0x140>
	{
		xCoRoutineTickCount++;
    2a2e:	80 91 b7 02 	lds	r24, 0x02B7
    2a32:	90 91 b8 02 	lds	r25, 0x02B8
    2a36:	01 96       	adiw	r24, 0x01	; 1
    2a38:	90 93 b8 02 	sts	0x02B8, r25
    2a3c:	80 93 b7 02 	sts	0x02B7, r24
		xPassedTicks--;
    2a40:	80 91 bb 02 	lds	r24, 0x02BB
    2a44:	90 91 bc 02 	lds	r25, 0x02BC
    2a48:	01 97       	sbiw	r24, 0x01	; 1
    2a4a:	90 93 bc 02 	sts	0x02BC, r25
    2a4e:	80 93 bb 02 	sts	0x02BB, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    2a52:	80 91 b7 02 	lds	r24, 0x02B7
    2a56:	90 91 b8 02 	lds	r25, 0x02B8
    2a5a:	00 97       	sbiw	r24, 0x00	; 0
    2a5c:	a9 f4       	brne	.+42     	; 0x2a88 <prvCheckDelayedList+0x86>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    2a5e:	80 91 a9 02 	lds	r24, 0x02A9
    2a62:	90 91 aa 02 	lds	r25, 0x02AA
    2a66:	9a 83       	std	Y+2, r25	; 0x02
    2a68:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    2a6a:	80 91 ab 02 	lds	r24, 0x02AB
    2a6e:	90 91 ac 02 	lds	r25, 0x02AC
    2a72:	90 93 aa 02 	sts	0x02AA, r25
    2a76:	80 93 a9 02 	sts	0x02A9, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    2a7a:	89 81       	ldd	r24, Y+1	; 0x01
    2a7c:	9a 81       	ldd	r25, Y+2	; 0x02
    2a7e:	90 93 ac 02 	sts	0x02AC, r25
    2a82:	80 93 ab 02 	sts	0x02AB, r24
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    2a86:	54 c0       	rjmp	.+168    	; 0x2b30 <prvCheckDelayedList+0x12e>
    2a88:	53 c0       	rjmp	.+166    	; 0x2b30 <prvCheckDelayedList+0x12e>
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    2a8a:	80 91 a9 02 	lds	r24, 0x02A9
    2a8e:	90 91 aa 02 	lds	r25, 0x02AA
    2a92:	fc 01       	movw	r30, r24
    2a94:	85 81       	ldd	r24, Z+5	; 0x05
    2a96:	96 81       	ldd	r25, Z+6	; 0x06
    2a98:	fc 01       	movw	r30, r24
    2a9a:	86 81       	ldd	r24, Z+6	; 0x06
    2a9c:	97 81       	ldd	r25, Z+7	; 0x07
    2a9e:	9c 83       	std	Y+4, r25	; 0x04
    2aa0:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    2aa2:	8b 81       	ldd	r24, Y+3	; 0x03
    2aa4:	9c 81       	ldd	r25, Y+4	; 0x04
    2aa6:	fc 01       	movw	r30, r24
    2aa8:	22 81       	ldd	r18, Z+2	; 0x02
    2aaa:	33 81       	ldd	r19, Z+3	; 0x03
    2aac:	80 91 b7 02 	lds	r24, 0x02B7
    2ab0:	90 91 b8 02 	lds	r25, 0x02B8
    2ab4:	82 17       	cp	r24, r18
    2ab6:	93 07       	cpc	r25, r19
    2ab8:	08 f4       	brcc	.+2      	; 0x2abc <prvCheckDelayedList+0xba>
			{			
				/* Timeout not yet expired. */																			
				break;																				
    2aba:	43 c0       	rjmp	.+134    	; 0x2b42 <prvCheckDelayedList+0x140>
			}																						

			portDISABLE_INTERRUPTS();
    2abc:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				uxListRemove( &( pxCRCB->xGenericListItem ) );											
    2abe:	8b 81       	ldd	r24, Y+3	; 0x03
    2ac0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ac2:	02 96       	adiw	r24, 0x02	; 2
    2ac4:	0e 94 5e 13 	call	0x26bc	; 0x26bc <uxListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    2ac8:	8b 81       	ldd	r24, Y+3	; 0x03
    2aca:	9c 81       	ldd	r25, Y+4	; 0x04
    2acc:	fc 01       	movw	r30, r24
    2ace:	84 89       	ldd	r24, Z+20	; 0x14
    2ad0:	95 89       	ldd	r25, Z+21	; 0x15
    2ad2:	00 97       	sbiw	r24, 0x00	; 0
    2ad4:	29 f0       	breq	.+10     	; 0x2ae0 <prvCheckDelayedList+0xde>
				{															
					uxListRemove( &( pxCRCB->xEventListItem ) );											
    2ad6:	8b 81       	ldd	r24, Y+3	; 0x03
    2ad8:	9c 81       	ldd	r25, Y+4	; 0x04
    2ada:	0c 96       	adiw	r24, 0x0c	; 12
    2adc:	0e 94 5e 13 	call	0x26bc	; 0x26bc <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    2ae0:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    2ae2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ae4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ae6:	fc 01       	movw	r30, r24
    2ae8:	96 89       	ldd	r25, Z+22	; 0x16
    2aea:	80 91 b6 02 	lds	r24, 0x02B6
    2aee:	89 17       	cp	r24, r25
    2af0:	30 f4       	brcc	.+12     	; 0x2afe <prvCheckDelayedList+0xfc>
    2af2:	8b 81       	ldd	r24, Y+3	; 0x03
    2af4:	9c 81       	ldd	r25, Y+4	; 0x04
    2af6:	fc 01       	movw	r30, r24
    2af8:	86 89       	ldd	r24, Z+22	; 0x16
    2afa:	80 93 b6 02 	sts	0x02B6, r24
    2afe:	8b 81       	ldd	r24, Y+3	; 0x03
    2b00:	9c 81       	ldd	r25, Y+4	; 0x04
    2b02:	ac 01       	movw	r20, r24
    2b04:	4e 5f       	subi	r20, 0xFE	; 254
    2b06:	5f 4f       	sbci	r21, 0xFF	; 255
    2b08:	8b 81       	ldd	r24, Y+3	; 0x03
    2b0a:	9c 81       	ldd	r25, Y+4	; 0x04
    2b0c:	fc 01       	movw	r30, r24
    2b0e:	86 89       	ldd	r24, Z+22	; 0x16
    2b10:	28 2f       	mov	r18, r24
    2b12:	30 e0       	ldi	r19, 0x00	; 0
    2b14:	c9 01       	movw	r24, r18
    2b16:	88 0f       	add	r24, r24
    2b18:	99 1f       	adc	r25, r25
    2b1a:	88 0f       	add	r24, r24
    2b1c:	99 1f       	adc	r25, r25
    2b1e:	88 0f       	add	r24, r24
    2b20:	99 1f       	adc	r25, r25
    2b22:	82 0f       	add	r24, r18
    2b24:	93 1f       	adc	r25, r19
    2b26:	8b 57       	subi	r24, 0x7B	; 123
    2b28:	9d 4f       	sbci	r25, 0xFD	; 253
    2b2a:	ba 01       	movw	r22, r20
    2b2c:	0e 94 8e 12 	call	0x251c	; 0x251c <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    2b30:	80 91 a9 02 	lds	r24, 0x02A9
    2b34:	90 91 aa 02 	lds	r25, 0x02AA
    2b38:	fc 01       	movw	r30, r24
    2b3a:	80 81       	ld	r24, Z
    2b3c:	88 23       	and	r24, r24
    2b3e:	09 f0       	breq	.+2      	; 0x2b42 <prvCheckDelayedList+0x140>
    2b40:	a4 cf       	rjmp	.-184    	; 0x2a8a <prvCheckDelayedList+0x88>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    2b42:	80 91 bb 02 	lds	r24, 0x02BB
    2b46:	90 91 bc 02 	lds	r25, 0x02BC
    2b4a:	00 97       	sbiw	r24, 0x00	; 0
    2b4c:	09 f0       	breq	.+2      	; 0x2b50 <prvCheckDelayedList+0x14e>
    2b4e:	6f cf       	rjmp	.-290    	; 0x2a2e <prvCheckDelayedList+0x2c>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    2b50:	80 91 b7 02 	lds	r24, 0x02B7
    2b54:	90 91 b8 02 	lds	r25, 0x02B8
    2b58:	90 93 ba 02 	sts	0x02BA, r25
    2b5c:	80 93 b9 02 	sts	0x02B9, r24
}
    2b60:	0f 90       	pop	r0
    2b62:	0f 90       	pop	r0
    2b64:	0f 90       	pop	r0
    2b66:	0f 90       	pop	r0
    2b68:	df 91       	pop	r29
    2b6a:	cf 91       	pop	r28
    2b6c:	08 95       	ret

00002b6e <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    2b6e:	cf 93       	push	r28
    2b70:	df 93       	push	r29
    2b72:	1f 92       	push	r1
    2b74:	1f 92       	push	r1
    2b76:	cd b7       	in	r28, 0x3d	; 61
    2b78:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    2b7a:	0e 94 b4 14 	call	0x2968	; 0x2968 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    2b7e:	0e 94 01 15 	call	0x2a02	; 0x2a02 <prvCheckDelayedList>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2b82:	0a c0       	rjmp	.+20     	; 0x2b98 <vCoRoutineSchedule+0x2a>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    2b84:	80 91 b6 02 	lds	r24, 0x02B6
    2b88:	88 23       	and	r24, r24
    2b8a:	09 f4       	brne	.+2      	; 0x2b8e <vCoRoutineSchedule+0x20>
		{
			/* No more co-routines to check. */
			return;
    2b8c:	6f c0       	rjmp	.+222    	; 0x2c6c <vCoRoutineSchedule+0xfe>
		}
		--uxTopCoRoutineReadyPriority;
    2b8e:	80 91 b6 02 	lds	r24, 0x02B6
    2b92:	81 50       	subi	r24, 0x01	; 1
    2b94:	80 93 b6 02 	sts	0x02B6, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2b98:	80 91 b6 02 	lds	r24, 0x02B6
    2b9c:	28 2f       	mov	r18, r24
    2b9e:	30 e0       	ldi	r19, 0x00	; 0
    2ba0:	c9 01       	movw	r24, r18
    2ba2:	88 0f       	add	r24, r24
    2ba4:	99 1f       	adc	r25, r25
    2ba6:	88 0f       	add	r24, r24
    2ba8:	99 1f       	adc	r25, r25
    2baa:	88 0f       	add	r24, r24
    2bac:	99 1f       	adc	r25, r25
    2bae:	82 0f       	add	r24, r18
    2bb0:	93 1f       	adc	r25, r19
    2bb2:	8b 57       	subi	r24, 0x7B	; 123
    2bb4:	9d 4f       	sbci	r25, 0xFD	; 253
    2bb6:	fc 01       	movw	r30, r24
    2bb8:	80 81       	ld	r24, Z
    2bba:	88 23       	and	r24, r24
    2bbc:	19 f3       	breq	.-58     	; 0x2b84 <vCoRoutineSchedule+0x16>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    2bbe:	80 91 b6 02 	lds	r24, 0x02B6
    2bc2:	28 2f       	mov	r18, r24
    2bc4:	30 e0       	ldi	r19, 0x00	; 0
    2bc6:	c9 01       	movw	r24, r18
    2bc8:	88 0f       	add	r24, r24
    2bca:	99 1f       	adc	r25, r25
    2bcc:	88 0f       	add	r24, r24
    2bce:	99 1f       	adc	r25, r25
    2bd0:	88 0f       	add	r24, r24
    2bd2:	99 1f       	adc	r25, r25
    2bd4:	82 0f       	add	r24, r18
    2bd6:	93 1f       	adc	r25, r19
    2bd8:	8b 57       	subi	r24, 0x7B	; 123
    2bda:	9d 4f       	sbci	r25, 0xFD	; 253
    2bdc:	9a 83       	std	Y+2, r25	; 0x02
    2bde:	89 83       	std	Y+1, r24	; 0x01
    2be0:	89 81       	ldd	r24, Y+1	; 0x01
    2be2:	9a 81       	ldd	r25, Y+2	; 0x02
    2be4:	fc 01       	movw	r30, r24
    2be6:	81 81       	ldd	r24, Z+1	; 0x01
    2be8:	92 81       	ldd	r25, Z+2	; 0x02
    2bea:	fc 01       	movw	r30, r24
    2bec:	22 81       	ldd	r18, Z+2	; 0x02
    2bee:	33 81       	ldd	r19, Z+3	; 0x03
    2bf0:	89 81       	ldd	r24, Y+1	; 0x01
    2bf2:	9a 81       	ldd	r25, Y+2	; 0x02
    2bf4:	fc 01       	movw	r30, r24
    2bf6:	32 83       	std	Z+2, r19	; 0x02
    2bf8:	21 83       	std	Z+1, r18	; 0x01
    2bfa:	89 81       	ldd	r24, Y+1	; 0x01
    2bfc:	9a 81       	ldd	r25, Y+2	; 0x02
    2bfe:	fc 01       	movw	r30, r24
    2c00:	21 81       	ldd	r18, Z+1	; 0x01
    2c02:	32 81       	ldd	r19, Z+2	; 0x02
    2c04:	89 81       	ldd	r24, Y+1	; 0x01
    2c06:	9a 81       	ldd	r25, Y+2	; 0x02
    2c08:	03 96       	adiw	r24, 0x03	; 3
    2c0a:	28 17       	cp	r18, r24
    2c0c:	39 07       	cpc	r19, r25
    2c0e:	69 f4       	brne	.+26     	; 0x2c2a <vCoRoutineSchedule+0xbc>
    2c10:	89 81       	ldd	r24, Y+1	; 0x01
    2c12:	9a 81       	ldd	r25, Y+2	; 0x02
    2c14:	fc 01       	movw	r30, r24
    2c16:	81 81       	ldd	r24, Z+1	; 0x01
    2c18:	92 81       	ldd	r25, Z+2	; 0x02
    2c1a:	fc 01       	movw	r30, r24
    2c1c:	22 81       	ldd	r18, Z+2	; 0x02
    2c1e:	33 81       	ldd	r19, Z+3	; 0x03
    2c20:	89 81       	ldd	r24, Y+1	; 0x01
    2c22:	9a 81       	ldd	r25, Y+2	; 0x02
    2c24:	fc 01       	movw	r30, r24
    2c26:	32 83       	std	Z+2, r19	; 0x02
    2c28:	21 83       	std	Z+1, r18	; 0x01
    2c2a:	89 81       	ldd	r24, Y+1	; 0x01
    2c2c:	9a 81       	ldd	r25, Y+2	; 0x02
    2c2e:	fc 01       	movw	r30, r24
    2c30:	81 81       	ldd	r24, Z+1	; 0x01
    2c32:	92 81       	ldd	r25, Z+2	; 0x02
    2c34:	fc 01       	movw	r30, r24
    2c36:	86 81       	ldd	r24, Z+6	; 0x06
    2c38:	97 81       	ldd	r25, Z+7	; 0x07
    2c3a:	90 93 84 02 	sts	0x0284, r25
    2c3e:	80 93 83 02 	sts	0x0283, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2c42:	80 91 83 02 	lds	r24, 0x0283
    2c46:	90 91 84 02 	lds	r25, 0x0284
    2c4a:	fc 01       	movw	r30, r24
    2c4c:	20 81       	ld	r18, Z
    2c4e:	31 81       	ldd	r19, Z+1	; 0x01
    2c50:	80 91 83 02 	lds	r24, 0x0283
    2c54:	90 91 84 02 	lds	r25, 0x0284
    2c58:	fc 01       	movw	r30, r24
    2c5a:	47 89       	ldd	r20, Z+23	; 0x17
    2c5c:	80 91 83 02 	lds	r24, 0x0283
    2c60:	90 91 84 02 	lds	r25, 0x0284
    2c64:	64 2f       	mov	r22, r20
    2c66:	f9 01       	movw	r30, r18
    2c68:	19 95       	eicall

	return;
    2c6a:	00 00       	nop
}
    2c6c:	0f 90       	pop	r0
    2c6e:	0f 90       	pop	r0
    2c70:	df 91       	pop	r29
    2c72:	cf 91       	pop	r28
    2c74:	08 95       	ret

00002c76 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    2c76:	cf 93       	push	r28
    2c78:	df 93       	push	r29
    2c7a:	1f 92       	push	r1
    2c7c:	cd b7       	in	r28, 0x3d	; 61
    2c7e:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2c80:	19 82       	std	Y+1, r1	; 0x01
    2c82:	13 c0       	rjmp	.+38     	; 0x2caa <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    2c84:	89 81       	ldd	r24, Y+1	; 0x01
    2c86:	28 2f       	mov	r18, r24
    2c88:	30 e0       	ldi	r19, 0x00	; 0
    2c8a:	c9 01       	movw	r24, r18
    2c8c:	88 0f       	add	r24, r24
    2c8e:	99 1f       	adc	r25, r25
    2c90:	88 0f       	add	r24, r24
    2c92:	99 1f       	adc	r25, r25
    2c94:	88 0f       	add	r24, r24
    2c96:	99 1f       	adc	r25, r25
    2c98:	82 0f       	add	r24, r18
    2c9a:	93 1f       	adc	r25, r19
    2c9c:	8b 57       	subi	r24, 0x7B	; 123
    2c9e:	9d 4f       	sbci	r25, 0xFD	; 253
    2ca0:	0e 94 46 12 	call	0x248c	; 0x248c <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2ca4:	89 81       	ldd	r24, Y+1	; 0x01
    2ca6:	8f 5f       	subi	r24, 0xFF	; 255
    2ca8:	89 83       	std	Y+1, r24	; 0x01
    2caa:	89 81       	ldd	r24, Y+1	; 0x01
    2cac:	82 30       	cpi	r24, 0x02	; 2
    2cae:	50 f3       	brcs	.-44     	; 0x2c84 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    2cb0:	87 e9       	ldi	r24, 0x97	; 151
    2cb2:	92 e0       	ldi	r25, 0x02	; 2
    2cb4:	0e 94 46 12 	call	0x248c	; 0x248c <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    2cb8:	80 ea       	ldi	r24, 0xA0	; 160
    2cba:	92 e0       	ldi	r25, 0x02	; 2
    2cbc:	0e 94 46 12 	call	0x248c	; 0x248c <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    2cc0:	8d ea       	ldi	r24, 0xAD	; 173
    2cc2:	92 e0       	ldi	r25, 0x02	; 2
    2cc4:	0e 94 46 12 	call	0x248c	; 0x248c <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    2cc8:	87 e9       	ldi	r24, 0x97	; 151
    2cca:	92 e0       	ldi	r25, 0x02	; 2
    2ccc:	90 93 aa 02 	sts	0x02AA, r25
    2cd0:	80 93 a9 02 	sts	0x02A9, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    2cd4:	80 ea       	ldi	r24, 0xA0	; 160
    2cd6:	92 e0       	ldi	r25, 0x02	; 2
    2cd8:	90 93 ac 02 	sts	0x02AC, r25
    2cdc:	80 93 ab 02 	sts	0x02AB, r24
}
    2ce0:	0f 90       	pop	r0
    2ce2:	df 91       	pop	r29
    2ce4:	cf 91       	pop	r28
    2ce6:	08 95       	ret

00002ce8 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    2ce8:	cf 93       	push	r28
    2cea:	df 93       	push	r29
    2cec:	00 d0       	rcall	.+0      	; 0x2cee <xCoRoutineRemoveFromEventList+0x6>
    2cee:	1f 92       	push	r1
    2cf0:	1f 92       	push	r1
    2cf2:	cd b7       	in	r28, 0x3d	; 61
    2cf4:	de b7       	in	r29, 0x3e	; 62
    2cf6:	9d 83       	std	Y+5, r25	; 0x05
    2cf8:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2cfa:	8c 81       	ldd	r24, Y+4	; 0x04
    2cfc:	9d 81       	ldd	r25, Y+5	; 0x05
    2cfe:	fc 01       	movw	r30, r24
    2d00:	85 81       	ldd	r24, Z+5	; 0x05
    2d02:	96 81       	ldd	r25, Z+6	; 0x06
    2d04:	fc 01       	movw	r30, r24
    2d06:	86 81       	ldd	r24, Z+6	; 0x06
    2d08:	97 81       	ldd	r25, Z+7	; 0x07
    2d0a:	9b 83       	std	Y+3, r25	; 0x03
    2d0c:	8a 83       	std	Y+2, r24	; 0x02
	uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2d0e:	8a 81       	ldd	r24, Y+2	; 0x02
    2d10:	9b 81       	ldd	r25, Y+3	; 0x03
    2d12:	0c 96       	adiw	r24, 0x0c	; 12
    2d14:	0e 94 5e 13 	call	0x26bc	; 0x26bc <uxListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    2d18:	8a 81       	ldd	r24, Y+2	; 0x02
    2d1a:	9b 81       	ldd	r25, Y+3	; 0x03
    2d1c:	0c 96       	adiw	r24, 0x0c	; 12
    2d1e:	bc 01       	movw	r22, r24
    2d20:	8d ea       	ldi	r24, 0xAD	; 173
    2d22:	92 e0       	ldi	r25, 0x02	; 2
    2d24:	0e 94 8e 12 	call	0x251c	; 0x251c <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    2d28:	8a 81       	ldd	r24, Y+2	; 0x02
    2d2a:	9b 81       	ldd	r25, Y+3	; 0x03
    2d2c:	fc 01       	movw	r30, r24
    2d2e:	26 89       	ldd	r18, Z+22	; 0x16
    2d30:	80 91 83 02 	lds	r24, 0x0283
    2d34:	90 91 84 02 	lds	r25, 0x0284
    2d38:	fc 01       	movw	r30, r24
    2d3a:	86 89       	ldd	r24, Z+22	; 0x16
    2d3c:	28 17       	cp	r18, r24
    2d3e:	18 f0       	brcs	.+6      	; 0x2d46 <xCoRoutineRemoveFromEventList+0x5e>
	{
		xReturn = pdTRUE;
    2d40:	81 e0       	ldi	r24, 0x01	; 1
    2d42:	89 83       	std	Y+1, r24	; 0x01
    2d44:	01 c0       	rjmp	.+2      	; 0x2d48 <xCoRoutineRemoveFromEventList+0x60>
	}
	else
	{
		xReturn = pdFALSE;
    2d46:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2d48:	89 81       	ldd	r24, Y+1	; 0x01
}
    2d4a:	0f 90       	pop	r0
    2d4c:	0f 90       	pop	r0
    2d4e:	0f 90       	pop	r0
    2d50:	0f 90       	pop	r0
    2d52:	0f 90       	pop	r0
    2d54:	df 91       	pop	r29
    2d56:	cf 91       	pop	r28
    2d58:	08 95       	ret

00002d5a <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2d5a:	cf 93       	push	r28
    2d5c:	df 93       	push	r29
    2d5e:	00 d0       	rcall	.+0      	; 0x2d60 <pvPortMalloc+0x6>
    2d60:	1f 92       	push	r1
    2d62:	cd b7       	in	r28, 0x3d	; 61
    2d64:	de b7       	in	r29, 0x3e	; 62
    2d66:	9c 83       	std	Y+4, r25	; 0x04
    2d68:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    2d6a:	1a 82       	std	Y+2, r1	; 0x02
    2d6c:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    2d6e:	0e 94 7f 06 	call	0xcfe	; 0xcfe <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    2d72:	20 91 bd 1a 	lds	r18, 0x1ABD
    2d76:	30 91 be 1a 	lds	r19, 0x1ABE
    2d7a:	8b 81       	ldd	r24, Y+3	; 0x03
    2d7c:	9c 81       	ldd	r25, Y+4	; 0x04
    2d7e:	82 0f       	add	r24, r18
    2d80:	93 1f       	adc	r25, r19
    2d82:	81 15       	cp	r24, r1
    2d84:	28 e1       	ldi	r18, 0x18	; 24
    2d86:	92 07       	cpc	r25, r18
    2d88:	18 f5       	brcc	.+70     	; 0x2dd0 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
    2d8a:	20 91 bd 1a 	lds	r18, 0x1ABD
    2d8e:	30 91 be 1a 	lds	r19, 0x1ABE
    2d92:	8b 81       	ldd	r24, Y+3	; 0x03
    2d94:	9c 81       	ldd	r25, Y+4	; 0x04
    2d96:	28 0f       	add	r18, r24
    2d98:	39 1f       	adc	r19, r25
    2d9a:	80 91 bd 1a 	lds	r24, 0x1ABD
    2d9e:	90 91 be 1a 	lds	r25, 0x1ABE
	#endif

	vTaskSuspendAll();
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    2da2:	82 17       	cp	r24, r18
    2da4:	93 07       	cpc	r25, r19
    2da6:	a0 f4       	brcc	.+40     	; 0x2dd0 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    2da8:	80 91 bd 1a 	lds	r24, 0x1ABD
    2dac:	90 91 be 1a 	lds	r25, 0x1ABE
    2db0:	83 54       	subi	r24, 0x43	; 67
    2db2:	9d 4f       	sbci	r25, 0xFD	; 253
    2db4:	9a 83       	std	Y+2, r25	; 0x02
    2db6:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    2db8:	20 91 bd 1a 	lds	r18, 0x1ABD
    2dbc:	30 91 be 1a 	lds	r19, 0x1ABE
    2dc0:	8b 81       	ldd	r24, Y+3	; 0x03
    2dc2:	9c 81       	ldd	r25, Y+4	; 0x04
    2dc4:	82 0f       	add	r24, r18
    2dc6:	93 1f       	adc	r25, r19
    2dc8:	90 93 be 1a 	sts	0x1ABE, r25
    2dcc:	80 93 bd 1a 	sts	0x1ABD, r24
		}
	}
	xTaskResumeAll();
    2dd0:	0e 94 8b 06 	call	0xd16	; 0xd16 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    2dd4:	89 81       	ldd	r24, Y+1	; 0x01
    2dd6:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2dd8:	0f 90       	pop	r0
    2dda:	0f 90       	pop	r0
    2ddc:	0f 90       	pop	r0
    2dde:	0f 90       	pop	r0
    2de0:	df 91       	pop	r29
    2de2:	cf 91       	pop	r28
    2de4:	08 95       	ret

00002de6 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2de6:	cf 93       	push	r28
    2de8:	df 93       	push	r29
    2dea:	1f 92       	push	r1
    2dec:	1f 92       	push	r1
    2dee:	cd b7       	in	r28, 0x3d	; 61
    2df0:	de b7       	in	r29, 0x3e	; 62
    2df2:	9a 83       	std	Y+2, r25	; 0x02
    2df4:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    2df6:	0f 90       	pop	r0
    2df8:	0f 90       	pop	r0
    2dfa:	df 91       	pop	r29
    2dfc:	cf 91       	pop	r28
    2dfe:	08 95       	ret

00002e00 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    2e00:	cf 93       	push	r28
    2e02:	df 93       	push	r29
    2e04:	cd b7       	in	r28, 0x3d	; 61
    2e06:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    2e08:	10 92 be 1a 	sts	0x1ABE, r1
    2e0c:	10 92 bd 1a 	sts	0x1ABD, r1
}
    2e10:	df 91       	pop	r29
    2e12:	cf 91       	pop	r28
    2e14:	08 95       	ret

00002e16 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    2e16:	cf 93       	push	r28
    2e18:	df 93       	push	r29
    2e1a:	cd b7       	in	r28, 0x3d	; 61
    2e1c:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    2e1e:	80 91 bd 1a 	lds	r24, 0x1ABD
    2e22:	90 91 be 1a 	lds	r25, 0x1ABE
    2e26:	20 e0       	ldi	r18, 0x00	; 0
    2e28:	38 e1       	ldi	r19, 0x18	; 24
    2e2a:	a9 01       	movw	r20, r18
    2e2c:	48 1b       	sub	r20, r24
    2e2e:	59 0b       	sbc	r21, r25
    2e30:	ca 01       	movw	r24, r20
}
    2e32:	df 91       	pop	r29
    2e34:	cf 91       	pop	r28
    2e36:	08 95       	ret

00002e38 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    2e38:	cf 93       	push	r28
    2e3a:	df 93       	push	r29
    2e3c:	cd b7       	in	r28, 0x3d	; 61
    2e3e:	de b7       	in	r29, 0x3e	; 62
    2e40:	28 97       	sbiw	r28, 0x08	; 8
    2e42:	0f b6       	in	r0, 0x3f	; 63
    2e44:	f8 94       	cli
    2e46:	de bf       	out	0x3e, r29	; 62
    2e48:	0f be       	out	0x3f, r0	; 63
    2e4a:	cd bf       	out	0x3d, r28	; 61
    2e4c:	9c 83       	std	Y+4, r25	; 0x04
    2e4e:	8b 83       	std	Y+3, r24	; 0x03
    2e50:	7e 83       	std	Y+6, r23	; 0x06
    2e52:	6d 83       	std	Y+5, r22	; 0x05
    2e54:	58 87       	std	Y+8, r21	; 0x08
    2e56:	4f 83       	std	Y+7, r20	; 0x07
#endif

	/* Place a few bytes of known values on the bottom of the stack.
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2e58:	8b 81       	ldd	r24, Y+3	; 0x03
    2e5a:	9c 81       	ldd	r25, Y+4	; 0x04
    2e5c:	21 e1       	ldi	r18, 0x11	; 17
    2e5e:	fc 01       	movw	r30, r24
    2e60:	20 83       	st	Z, r18
	pxTopOfStack--;
    2e62:	8b 81       	ldd	r24, Y+3	; 0x03
    2e64:	9c 81       	ldd	r25, Y+4	; 0x04
    2e66:	01 97       	sbiw	r24, 0x01	; 1
    2e68:	9c 83       	std	Y+4, r25	; 0x04
    2e6a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    2e6c:	8b 81       	ldd	r24, Y+3	; 0x03
    2e6e:	9c 81       	ldd	r25, Y+4	; 0x04
    2e70:	22 e2       	ldi	r18, 0x22	; 34
    2e72:	fc 01       	movw	r30, r24
    2e74:	20 83       	st	Z, r18
	pxTopOfStack--;
    2e76:	8b 81       	ldd	r24, Y+3	; 0x03
    2e78:	9c 81       	ldd	r25, Y+4	; 0x04
    2e7a:	01 97       	sbiw	r24, 0x01	; 1
    2e7c:	9c 83       	std	Y+4, r25	; 0x04
    2e7e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    2e80:	8b 81       	ldd	r24, Y+3	; 0x03
    2e82:	9c 81       	ldd	r25, Y+4	; 0x04
    2e84:	23 e3       	ldi	r18, 0x33	; 51
    2e86:	fc 01       	movw	r30, r24
    2e88:	20 83       	st	Z, r18
	pxTopOfStack--;
    2e8a:	8b 81       	ldd	r24, Y+3	; 0x03
    2e8c:	9c 81       	ldd	r25, Y+4	; 0x04
    2e8e:	01 97       	sbiw	r24, 0x01	; 1
    2e90:	9c 83       	std	Y+4, r25	; 0x04
    2e92:	8b 83       	std	Y+3, r24	; 0x03
	 * of flash. We do this by adding the .task label in the linker script.
	 *
	 * In order to do this properly, we would need to get a full 3-byte pointer to
	 * pxCode.  That requires a change to GCC.  Not likely to happen any time soon.
	 */
	usAddress = ( unsigned portSHORT ) pxCode;
    2e94:	8d 81       	ldd	r24, Y+5	; 0x05
    2e96:	9e 81       	ldd	r25, Y+6	; 0x06
    2e98:	9a 83       	std	Y+2, r25	; 0x02
    2e9a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    2e9c:	29 81       	ldd	r18, Y+1	; 0x01
    2e9e:	8b 81       	ldd	r24, Y+3	; 0x03
    2ea0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ea2:	fc 01       	movw	r30, r24
    2ea4:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ea6:	8b 81       	ldd	r24, Y+3	; 0x03
    2ea8:	9c 81       	ldd	r25, Y+4	; 0x04
    2eaa:	01 97       	sbiw	r24, 0x01	; 1
    2eac:	9c 83       	std	Y+4, r25	; 0x04
    2eae:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2eb0:	89 81       	ldd	r24, Y+1	; 0x01
    2eb2:	9a 81       	ldd	r25, Y+2	; 0x02
    2eb4:	89 2f       	mov	r24, r25
    2eb6:	99 27       	eor	r25, r25
    2eb8:	9a 83       	std	Y+2, r25	; 0x02
    2eba:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    2ebc:	29 81       	ldd	r18, Y+1	; 0x01
    2ebe:	8b 81       	ldd	r24, Y+3	; 0x03
    2ec0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ec2:	fc 01       	movw	r30, r24
    2ec4:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ec6:	8b 81       	ldd	r24, Y+3	; 0x03
    2ec8:	9c 81       	ldd	r25, Y+4	; 0x04
    2eca:	01 97       	sbiw	r24, 0x01	; 1
    2ecc:	9c 83       	std	Y+4, r25	; 0x04
    2ece:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = 0;
    2ed0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ed2:	9c 81       	ldd	r25, Y+4	; 0x04
    2ed4:	fc 01       	movw	r30, r24
    2ed6:	10 82       	st	Z, r1
	pxTopOfStack--;
    2ed8:	8b 81       	ldd	r24, Y+3	; 0x03
    2eda:	9c 81       	ldd	r25, Y+4	; 0x04
    2edc:	01 97       	sbiw	r24, 0x01	; 1
    2ede:	9c 83       	std	Y+4, r25	; 0x04
    2ee0:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    2ee2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ee4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ee6:	fc 01       	movw	r30, r24
    2ee8:	10 82       	st	Z, r1
	pxTopOfStack--;
    2eea:	8b 81       	ldd	r24, Y+3	; 0x03
    2eec:	9c 81       	ldd	r25, Y+4	; 0x04
    2eee:	01 97       	sbiw	r24, 0x01	; 1
    2ef0:	9c 83       	std	Y+4, r25	; 0x04
    2ef2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2ef4:	8b 81       	ldd	r24, Y+3	; 0x03
    2ef6:	9c 81       	ldd	r25, Y+4	; 0x04
    2ef8:	20 e8       	ldi	r18, 0x80	; 128
    2efa:	fc 01       	movw	r30, r24
    2efc:	20 83       	st	Z, r18
	pxTopOfStack--;
    2efe:	8b 81       	ldd	r24, Y+3	; 0x03
    2f00:	9c 81       	ldd	r25, Y+4	; 0x04
    2f02:	01 97       	sbiw	r24, 0x01	; 1
    2f04:	9c 83       	std	Y+4, r25	; 0x04
    2f06:	8b 83       	std	Y+3, r24	; 0x03
#if defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

	/* If we have an ATmega256x, we are also saving the RAMPZ and EIND registers.
	 * We should default those to 0.
	 */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* EIND */
    2f08:	8b 81       	ldd	r24, Y+3	; 0x03
    2f0a:	9c 81       	ldd	r25, Y+4	; 0x04
    2f0c:	fc 01       	movw	r30, r24
    2f0e:	10 82       	st	Z, r1
	pxTopOfStack--;
    2f10:	8b 81       	ldd	r24, Y+3	; 0x03
    2f12:	9c 81       	ldd	r25, Y+4	; 0x04
    2f14:	01 97       	sbiw	r24, 0x01	; 1
    2f16:	9c 83       	std	Y+4, r25	; 0x04
    2f18:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* RAMPZ */
    2f1a:	8b 81       	ldd	r24, Y+3	; 0x03
    2f1c:	9c 81       	ldd	r25, Y+4	; 0x04
    2f1e:	fc 01       	movw	r30, r24
    2f20:	10 82       	st	Z, r1
	pxTopOfStack--;
    2f22:	8b 81       	ldd	r24, Y+3	; 0x03
    2f24:	9c 81       	ldd	r25, Y+4	; 0x04
    2f26:	01 97       	sbiw	r24, 0x01	; 1
    2f28:	9c 83       	std	Y+4, r25	; 0x04
    2f2a:	8b 83       	std	Y+3, r24	; 0x03

#endif

	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    2f2c:	8b 81       	ldd	r24, Y+3	; 0x03
    2f2e:	9c 81       	ldd	r25, Y+4	; 0x04
    2f30:	fc 01       	movw	r30, r24
    2f32:	10 82       	st	Z, r1
	pxTopOfStack--;
    2f34:	8b 81       	ldd	r24, Y+3	; 0x03
    2f36:	9c 81       	ldd	r25, Y+4	; 0x04
    2f38:	01 97       	sbiw	r24, 0x01	; 1
    2f3a:	9c 83       	std	Y+4, r25	; 0x04
    2f3c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    2f3e:	8b 81       	ldd	r24, Y+3	; 0x03
    2f40:	9c 81       	ldd	r25, Y+4	; 0x04
    2f42:	22 e0       	ldi	r18, 0x02	; 2
    2f44:	fc 01       	movw	r30, r24
    2f46:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f48:	8b 81       	ldd	r24, Y+3	; 0x03
    2f4a:	9c 81       	ldd	r25, Y+4	; 0x04
    2f4c:	01 97       	sbiw	r24, 0x01	; 1
    2f4e:	9c 83       	std	Y+4, r25	; 0x04
    2f50:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    2f52:	8b 81       	ldd	r24, Y+3	; 0x03
    2f54:	9c 81       	ldd	r25, Y+4	; 0x04
    2f56:	23 e0       	ldi	r18, 0x03	; 3
    2f58:	fc 01       	movw	r30, r24
    2f5a:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f5c:	8b 81       	ldd	r24, Y+3	; 0x03
    2f5e:	9c 81       	ldd	r25, Y+4	; 0x04
    2f60:	01 97       	sbiw	r24, 0x01	; 1
    2f62:	9c 83       	std	Y+4, r25	; 0x04
    2f64:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    2f66:	8b 81       	ldd	r24, Y+3	; 0x03
    2f68:	9c 81       	ldd	r25, Y+4	; 0x04
    2f6a:	24 e0       	ldi	r18, 0x04	; 4
    2f6c:	fc 01       	movw	r30, r24
    2f6e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f70:	8b 81       	ldd	r24, Y+3	; 0x03
    2f72:	9c 81       	ldd	r25, Y+4	; 0x04
    2f74:	01 97       	sbiw	r24, 0x01	; 1
    2f76:	9c 83       	std	Y+4, r25	; 0x04
    2f78:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    2f7a:	8b 81       	ldd	r24, Y+3	; 0x03
    2f7c:	9c 81       	ldd	r25, Y+4	; 0x04
    2f7e:	25 e0       	ldi	r18, 0x05	; 5
    2f80:	fc 01       	movw	r30, r24
    2f82:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f84:	8b 81       	ldd	r24, Y+3	; 0x03
    2f86:	9c 81       	ldd	r25, Y+4	; 0x04
    2f88:	01 97       	sbiw	r24, 0x01	; 1
    2f8a:	9c 83       	std	Y+4, r25	; 0x04
    2f8c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    2f8e:	8b 81       	ldd	r24, Y+3	; 0x03
    2f90:	9c 81       	ldd	r25, Y+4	; 0x04
    2f92:	26 e0       	ldi	r18, 0x06	; 6
    2f94:	fc 01       	movw	r30, r24
    2f96:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f98:	8b 81       	ldd	r24, Y+3	; 0x03
    2f9a:	9c 81       	ldd	r25, Y+4	; 0x04
    2f9c:	01 97       	sbiw	r24, 0x01	; 1
    2f9e:	9c 83       	std	Y+4, r25	; 0x04
    2fa0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    2fa2:	8b 81       	ldd	r24, Y+3	; 0x03
    2fa4:	9c 81       	ldd	r25, Y+4	; 0x04
    2fa6:	27 e0       	ldi	r18, 0x07	; 7
    2fa8:	fc 01       	movw	r30, r24
    2faa:	20 83       	st	Z, r18
	pxTopOfStack--;
    2fac:	8b 81       	ldd	r24, Y+3	; 0x03
    2fae:	9c 81       	ldd	r25, Y+4	; 0x04
    2fb0:	01 97       	sbiw	r24, 0x01	; 1
    2fb2:	9c 83       	std	Y+4, r25	; 0x04
    2fb4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    2fb6:	8b 81       	ldd	r24, Y+3	; 0x03
    2fb8:	9c 81       	ldd	r25, Y+4	; 0x04
    2fba:	28 e0       	ldi	r18, 0x08	; 8
    2fbc:	fc 01       	movw	r30, r24
    2fbe:	20 83       	st	Z, r18
	pxTopOfStack--;
    2fc0:	8b 81       	ldd	r24, Y+3	; 0x03
    2fc2:	9c 81       	ldd	r25, Y+4	; 0x04
    2fc4:	01 97       	sbiw	r24, 0x01	; 1
    2fc6:	9c 83       	std	Y+4, r25	; 0x04
    2fc8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    2fca:	8b 81       	ldd	r24, Y+3	; 0x03
    2fcc:	9c 81       	ldd	r25, Y+4	; 0x04
    2fce:	29 e0       	ldi	r18, 0x09	; 9
    2fd0:	fc 01       	movw	r30, r24
    2fd2:	20 83       	st	Z, r18
	pxTopOfStack--;
    2fd4:	8b 81       	ldd	r24, Y+3	; 0x03
    2fd6:	9c 81       	ldd	r25, Y+4	; 0x04
    2fd8:	01 97       	sbiw	r24, 0x01	; 1
    2fda:	9c 83       	std	Y+4, r25	; 0x04
    2fdc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    2fde:	8b 81       	ldd	r24, Y+3	; 0x03
    2fe0:	9c 81       	ldd	r25, Y+4	; 0x04
    2fe2:	20 e1       	ldi	r18, 0x10	; 16
    2fe4:	fc 01       	movw	r30, r24
    2fe6:	20 83       	st	Z, r18
	pxTopOfStack--;
    2fe8:	8b 81       	ldd	r24, Y+3	; 0x03
    2fea:	9c 81       	ldd	r25, Y+4	; 0x04
    2fec:	01 97       	sbiw	r24, 0x01	; 1
    2fee:	9c 83       	std	Y+4, r25	; 0x04
    2ff0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    2ff2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ff4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ff6:	21 e1       	ldi	r18, 0x11	; 17
    2ff8:	fc 01       	movw	r30, r24
    2ffa:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ffc:	8b 81       	ldd	r24, Y+3	; 0x03
    2ffe:	9c 81       	ldd	r25, Y+4	; 0x04
    3000:	01 97       	sbiw	r24, 0x01	; 1
    3002:	9c 83       	std	Y+4, r25	; 0x04
    3004:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    3006:	8b 81       	ldd	r24, Y+3	; 0x03
    3008:	9c 81       	ldd	r25, Y+4	; 0x04
    300a:	22 e1       	ldi	r18, 0x12	; 18
    300c:	fc 01       	movw	r30, r24
    300e:	20 83       	st	Z, r18
	pxTopOfStack--;
    3010:	8b 81       	ldd	r24, Y+3	; 0x03
    3012:	9c 81       	ldd	r25, Y+4	; 0x04
    3014:	01 97       	sbiw	r24, 0x01	; 1
    3016:	9c 83       	std	Y+4, r25	; 0x04
    3018:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    301a:	8b 81       	ldd	r24, Y+3	; 0x03
    301c:	9c 81       	ldd	r25, Y+4	; 0x04
    301e:	23 e1       	ldi	r18, 0x13	; 19
    3020:	fc 01       	movw	r30, r24
    3022:	20 83       	st	Z, r18
	pxTopOfStack--;
    3024:	8b 81       	ldd	r24, Y+3	; 0x03
    3026:	9c 81       	ldd	r25, Y+4	; 0x04
    3028:	01 97       	sbiw	r24, 0x01	; 1
    302a:	9c 83       	std	Y+4, r25	; 0x04
    302c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    302e:	8b 81       	ldd	r24, Y+3	; 0x03
    3030:	9c 81       	ldd	r25, Y+4	; 0x04
    3032:	24 e1       	ldi	r18, 0x14	; 20
    3034:	fc 01       	movw	r30, r24
    3036:	20 83       	st	Z, r18
	pxTopOfStack--;
    3038:	8b 81       	ldd	r24, Y+3	; 0x03
    303a:	9c 81       	ldd	r25, Y+4	; 0x04
    303c:	01 97       	sbiw	r24, 0x01	; 1
    303e:	9c 83       	std	Y+4, r25	; 0x04
    3040:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    3042:	8b 81       	ldd	r24, Y+3	; 0x03
    3044:	9c 81       	ldd	r25, Y+4	; 0x04
    3046:	25 e1       	ldi	r18, 0x15	; 21
    3048:	fc 01       	movw	r30, r24
    304a:	20 83       	st	Z, r18
	pxTopOfStack--;
    304c:	8b 81       	ldd	r24, Y+3	; 0x03
    304e:	9c 81       	ldd	r25, Y+4	; 0x04
    3050:	01 97       	sbiw	r24, 0x01	; 1
    3052:	9c 83       	std	Y+4, r25	; 0x04
    3054:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    3056:	8b 81       	ldd	r24, Y+3	; 0x03
    3058:	9c 81       	ldd	r25, Y+4	; 0x04
    305a:	26 e1       	ldi	r18, 0x16	; 22
    305c:	fc 01       	movw	r30, r24
    305e:	20 83       	st	Z, r18
	pxTopOfStack--;
    3060:	8b 81       	ldd	r24, Y+3	; 0x03
    3062:	9c 81       	ldd	r25, Y+4	; 0x04
    3064:	01 97       	sbiw	r24, 0x01	; 1
    3066:	9c 83       	std	Y+4, r25	; 0x04
    3068:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    306a:	8b 81       	ldd	r24, Y+3	; 0x03
    306c:	9c 81       	ldd	r25, Y+4	; 0x04
    306e:	27 e1       	ldi	r18, 0x17	; 23
    3070:	fc 01       	movw	r30, r24
    3072:	20 83       	st	Z, r18
	pxTopOfStack--;
    3074:	8b 81       	ldd	r24, Y+3	; 0x03
    3076:	9c 81       	ldd	r25, Y+4	; 0x04
    3078:	01 97       	sbiw	r24, 0x01	; 1
    307a:	9c 83       	std	Y+4, r25	; 0x04
    307c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    307e:	8b 81       	ldd	r24, Y+3	; 0x03
    3080:	9c 81       	ldd	r25, Y+4	; 0x04
    3082:	28 e1       	ldi	r18, 0x18	; 24
    3084:	fc 01       	movw	r30, r24
    3086:	20 83       	st	Z, r18
	pxTopOfStack--;
    3088:	8b 81       	ldd	r24, Y+3	; 0x03
    308a:	9c 81       	ldd	r25, Y+4	; 0x04
    308c:	01 97       	sbiw	r24, 0x01	; 1
    308e:	9c 83       	std	Y+4, r25	; 0x04
    3090:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    3092:	8b 81       	ldd	r24, Y+3	; 0x03
    3094:	9c 81       	ldd	r25, Y+4	; 0x04
    3096:	29 e1       	ldi	r18, 0x19	; 25
    3098:	fc 01       	movw	r30, r24
    309a:	20 83       	st	Z, r18
	pxTopOfStack--;
    309c:	8b 81       	ldd	r24, Y+3	; 0x03
    309e:	9c 81       	ldd	r25, Y+4	; 0x04
    30a0:	01 97       	sbiw	r24, 0x01	; 1
    30a2:	9c 83       	std	Y+4, r25	; 0x04
    30a4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    30a6:	8b 81       	ldd	r24, Y+3	; 0x03
    30a8:	9c 81       	ldd	r25, Y+4	; 0x04
    30aa:	20 e2       	ldi	r18, 0x20	; 32
    30ac:	fc 01       	movw	r30, r24
    30ae:	20 83       	st	Z, r18
	pxTopOfStack--;
    30b0:	8b 81       	ldd	r24, Y+3	; 0x03
    30b2:	9c 81       	ldd	r25, Y+4	; 0x04
    30b4:	01 97       	sbiw	r24, 0x01	; 1
    30b6:	9c 83       	std	Y+4, r25	; 0x04
    30b8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    30ba:	8b 81       	ldd	r24, Y+3	; 0x03
    30bc:	9c 81       	ldd	r25, Y+4	; 0x04
    30be:	21 e2       	ldi	r18, 0x21	; 33
    30c0:	fc 01       	movw	r30, r24
    30c2:	20 83       	st	Z, r18
	pxTopOfStack--;
    30c4:	8b 81       	ldd	r24, Y+3	; 0x03
    30c6:	9c 81       	ldd	r25, Y+4	; 0x04
    30c8:	01 97       	sbiw	r24, 0x01	; 1
    30ca:	9c 83       	std	Y+4, r25	; 0x04
    30cc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    30ce:	8b 81       	ldd	r24, Y+3	; 0x03
    30d0:	9c 81       	ldd	r25, Y+4	; 0x04
    30d2:	22 e2       	ldi	r18, 0x22	; 34
    30d4:	fc 01       	movw	r30, r24
    30d6:	20 83       	st	Z, r18
	pxTopOfStack--;
    30d8:	8b 81       	ldd	r24, Y+3	; 0x03
    30da:	9c 81       	ldd	r25, Y+4	; 0x04
    30dc:	01 97       	sbiw	r24, 0x01	; 1
    30de:	9c 83       	std	Y+4, r25	; 0x04
    30e0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    30e2:	8b 81       	ldd	r24, Y+3	; 0x03
    30e4:	9c 81       	ldd	r25, Y+4	; 0x04
    30e6:	23 e2       	ldi	r18, 0x23	; 35
    30e8:	fc 01       	movw	r30, r24
    30ea:	20 83       	st	Z, r18
	pxTopOfStack--;
    30ec:	8b 81       	ldd	r24, Y+3	; 0x03
    30ee:	9c 81       	ldd	r25, Y+4	; 0x04
    30f0:	01 97       	sbiw	r24, 0x01	; 1
    30f2:	9c 83       	std	Y+4, r25	; 0x04
    30f4:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    30f6:	8f 81       	ldd	r24, Y+7	; 0x07
    30f8:	98 85       	ldd	r25, Y+8	; 0x08
    30fa:	9a 83       	std	Y+2, r25	; 0x02
    30fc:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    30fe:	29 81       	ldd	r18, Y+1	; 0x01
    3100:	8b 81       	ldd	r24, Y+3	; 0x03
    3102:	9c 81       	ldd	r25, Y+4	; 0x04
    3104:	fc 01       	movw	r30, r24
    3106:	20 83       	st	Z, r18
	pxTopOfStack--;
    3108:	8b 81       	ldd	r24, Y+3	; 0x03
    310a:	9c 81       	ldd	r25, Y+4	; 0x04
    310c:	01 97       	sbiw	r24, 0x01	; 1
    310e:	9c 83       	std	Y+4, r25	; 0x04
    3110:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    3112:	89 81       	ldd	r24, Y+1	; 0x01
    3114:	9a 81       	ldd	r25, Y+2	; 0x02
    3116:	89 2f       	mov	r24, r25
    3118:	99 27       	eor	r25, r25
    311a:	9a 83       	std	Y+2, r25	; 0x02
    311c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    311e:	29 81       	ldd	r18, Y+1	; 0x01
    3120:	8b 81       	ldd	r24, Y+3	; 0x03
    3122:	9c 81       	ldd	r25, Y+4	; 0x04
    3124:	fc 01       	movw	r30, r24
    3126:	20 83       	st	Z, r18
	pxTopOfStack--;
    3128:	8b 81       	ldd	r24, Y+3	; 0x03
    312a:	9c 81       	ldd	r25, Y+4	; 0x04
    312c:	01 97       	sbiw	r24, 0x01	; 1
    312e:	9c 83       	std	Y+4, r25	; 0x04
    3130:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    3132:	8b 81       	ldd	r24, Y+3	; 0x03
    3134:	9c 81       	ldd	r25, Y+4	; 0x04
    3136:	26 e2       	ldi	r18, 0x26	; 38
    3138:	fc 01       	movw	r30, r24
    313a:	20 83       	st	Z, r18
	pxTopOfStack--;
    313c:	8b 81       	ldd	r24, Y+3	; 0x03
    313e:	9c 81       	ldd	r25, Y+4	; 0x04
    3140:	01 97       	sbiw	r24, 0x01	; 1
    3142:	9c 83       	std	Y+4, r25	; 0x04
    3144:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    3146:	8b 81       	ldd	r24, Y+3	; 0x03
    3148:	9c 81       	ldd	r25, Y+4	; 0x04
    314a:	27 e2       	ldi	r18, 0x27	; 39
    314c:	fc 01       	movw	r30, r24
    314e:	20 83       	st	Z, r18
	pxTopOfStack--;
    3150:	8b 81       	ldd	r24, Y+3	; 0x03
    3152:	9c 81       	ldd	r25, Y+4	; 0x04
    3154:	01 97       	sbiw	r24, 0x01	; 1
    3156:	9c 83       	std	Y+4, r25	; 0x04
    3158:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    315a:	8b 81       	ldd	r24, Y+3	; 0x03
    315c:	9c 81       	ldd	r25, Y+4	; 0x04
    315e:	28 e2       	ldi	r18, 0x28	; 40
    3160:	fc 01       	movw	r30, r24
    3162:	20 83       	st	Z, r18
	pxTopOfStack--;
    3164:	8b 81       	ldd	r24, Y+3	; 0x03
    3166:	9c 81       	ldd	r25, Y+4	; 0x04
    3168:	01 97       	sbiw	r24, 0x01	; 1
    316a:	9c 83       	std	Y+4, r25	; 0x04
    316c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    316e:	8b 81       	ldd	r24, Y+3	; 0x03
    3170:	9c 81       	ldd	r25, Y+4	; 0x04
    3172:	29 e2       	ldi	r18, 0x29	; 41
    3174:	fc 01       	movw	r30, r24
    3176:	20 83       	st	Z, r18
	pxTopOfStack--;
    3178:	8b 81       	ldd	r24, Y+3	; 0x03
    317a:	9c 81       	ldd	r25, Y+4	; 0x04
    317c:	01 97       	sbiw	r24, 0x01	; 1
    317e:	9c 83       	std	Y+4, r25	; 0x04
    3180:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    3182:	8b 81       	ldd	r24, Y+3	; 0x03
    3184:	9c 81       	ldd	r25, Y+4	; 0x04
    3186:	20 e3       	ldi	r18, 0x30	; 48
    3188:	fc 01       	movw	r30, r24
    318a:	20 83       	st	Z, r18
	pxTopOfStack--;
    318c:	8b 81       	ldd	r24, Y+3	; 0x03
    318e:	9c 81       	ldd	r25, Y+4	; 0x04
    3190:	01 97       	sbiw	r24, 0x01	; 1
    3192:	9c 83       	std	Y+4, r25	; 0x04
    3194:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    3196:	8b 81       	ldd	r24, Y+3	; 0x03
    3198:	9c 81       	ldd	r25, Y+4	; 0x04
    319a:	21 e3       	ldi	r18, 0x31	; 49
    319c:	fc 01       	movw	r30, r24
    319e:	20 83       	st	Z, r18
	pxTopOfStack--;
    31a0:	8b 81       	ldd	r24, Y+3	; 0x03
    31a2:	9c 81       	ldd	r25, Y+4	; 0x04
    31a4:	01 97       	sbiw	r24, 0x01	; 1
    31a6:	9c 83       	std	Y+4, r25	; 0x04
    31a8:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    31aa:	8b 81       	ldd	r24, Y+3	; 0x03
    31ac:	9c 81       	ldd	r25, Y+4	; 0x04
}
    31ae:	28 96       	adiw	r28, 0x08	; 8
    31b0:	0f b6       	in	r0, 0x3f	; 63
    31b2:	f8 94       	cli
    31b4:	de bf       	out	0x3e, r29	; 62
    31b6:	0f be       	out	0x3f, r0	; 63
    31b8:	cd bf       	out	0x3d, r28	; 61
    31ba:	df 91       	pop	r29
    31bc:	cf 91       	pop	r28
    31be:	08 95       	ret

000031c0 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    31c0:	cf 93       	push	r28
    31c2:	df 93       	push	r29
    31c4:	cd b7       	in	r28, 0x3d	; 61
    31c6:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    31c8:	0e 94 e4 19 	call	0x33c8	; 0x33c8 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    31cc:	a0 91 2a 02 	lds	r26, 0x022A
    31d0:	b0 91 2b 02 	lds	r27, 0x022B
    31d4:	cd 91       	ld	r28, X+
    31d6:	cd bf       	out	0x3d, r28	; 61
    31d8:	dd 91       	ld	r29, X+
    31da:	de bf       	out	0x3e, r29	; 62
    31dc:	ff 91       	pop	r31
    31de:	ef 91       	pop	r30
    31e0:	df 91       	pop	r29
    31e2:	cf 91       	pop	r28
    31e4:	bf 91       	pop	r27
    31e6:	af 91       	pop	r26
    31e8:	9f 91       	pop	r25
    31ea:	8f 91       	pop	r24
    31ec:	7f 91       	pop	r23
    31ee:	6f 91       	pop	r22
    31f0:	5f 91       	pop	r21
    31f2:	4f 91       	pop	r20
    31f4:	3f 91       	pop	r19
    31f6:	2f 91       	pop	r18
    31f8:	1f 91       	pop	r17
    31fa:	0f 91       	pop	r16
    31fc:	ff 90       	pop	r15
    31fe:	ef 90       	pop	r14
    3200:	df 90       	pop	r13
    3202:	cf 90       	pop	r12
    3204:	bf 90       	pop	r11
    3206:	af 90       	pop	r10
    3208:	9f 90       	pop	r9
    320a:	8f 90       	pop	r8
    320c:	7f 90       	pop	r7
    320e:	6f 90       	pop	r6
    3210:	5f 90       	pop	r5
    3212:	4f 90       	pop	r4
    3214:	3f 90       	pop	r3
    3216:	2f 90       	pop	r2
    3218:	1f 90       	pop	r1
    321a:	0f 90       	pop	r0
    321c:	0c be       	out	0x3c, r0	; 60
    321e:	0f 90       	pop	r0
    3220:	0b be       	out	0x3b, r0	; 59
    3222:	0f 90       	pop	r0
    3224:	0f be       	out	0x3f, r0	; 63
    3226:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    3228:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    322a:	81 e0       	ldi	r24, 0x01	; 1
}
    322c:	df 91       	pop	r29
    322e:	cf 91       	pop	r28
    3230:	08 95       	ret

00003232 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    3232:	cf 93       	push	r28
    3234:	df 93       	push	r29
    3236:	cd b7       	in	r28, 0x3d	; 61
    3238:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    323a:	df 91       	pop	r29
    323c:	cf 91       	pop	r28
    323e:	08 95       	ret

00003240 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    3240:	0f 92       	push	r0
    3242:	0f b6       	in	r0, 0x3f	; 63
    3244:	f8 94       	cli
    3246:	0f 92       	push	r0
    3248:	0b b6       	in	r0, 0x3b	; 59
    324a:	0f 92       	push	r0
    324c:	0c b6       	in	r0, 0x3c	; 60
    324e:	0f 92       	push	r0
    3250:	1f 92       	push	r1
    3252:	11 24       	eor	r1, r1
    3254:	2f 92       	push	r2
    3256:	3f 92       	push	r3
    3258:	4f 92       	push	r4
    325a:	5f 92       	push	r5
    325c:	6f 92       	push	r6
    325e:	7f 92       	push	r7
    3260:	8f 92       	push	r8
    3262:	9f 92       	push	r9
    3264:	af 92       	push	r10
    3266:	bf 92       	push	r11
    3268:	cf 92       	push	r12
    326a:	df 92       	push	r13
    326c:	ef 92       	push	r14
    326e:	ff 92       	push	r15
    3270:	0f 93       	push	r16
    3272:	1f 93       	push	r17
    3274:	2f 93       	push	r18
    3276:	3f 93       	push	r19
    3278:	4f 93       	push	r20
    327a:	5f 93       	push	r21
    327c:	6f 93       	push	r22
    327e:	7f 93       	push	r23
    3280:	8f 93       	push	r24
    3282:	9f 93       	push	r25
    3284:	af 93       	push	r26
    3286:	bf 93       	push	r27
    3288:	cf 93       	push	r28
    328a:	df 93       	push	r29
    328c:	ef 93       	push	r30
    328e:	ff 93       	push	r31
    3290:	a0 91 2a 02 	lds	r26, 0x022A
    3294:	b0 91 2b 02 	lds	r27, 0x022B
    3298:	0d b6       	in	r0, 0x3d	; 61
    329a:	0d 92       	st	X+, r0
    329c:	0e b6       	in	r0, 0x3e	; 62
    329e:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    32a0:	0e 94 21 08 	call	0x1042	; 0x1042 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    32a4:	a0 91 2a 02 	lds	r26, 0x022A
    32a8:	b0 91 2b 02 	lds	r27, 0x022B
    32ac:	cd 91       	ld	r28, X+
    32ae:	cd bf       	out	0x3d, r28	; 61
    32b0:	dd 91       	ld	r29, X+
    32b2:	de bf       	out	0x3e, r29	; 62
    32b4:	ff 91       	pop	r31
    32b6:	ef 91       	pop	r30
    32b8:	df 91       	pop	r29
    32ba:	cf 91       	pop	r28
    32bc:	bf 91       	pop	r27
    32be:	af 91       	pop	r26
    32c0:	9f 91       	pop	r25
    32c2:	8f 91       	pop	r24
    32c4:	7f 91       	pop	r23
    32c6:	6f 91       	pop	r22
    32c8:	5f 91       	pop	r21
    32ca:	4f 91       	pop	r20
    32cc:	3f 91       	pop	r19
    32ce:	2f 91       	pop	r18
    32d0:	1f 91       	pop	r17
    32d2:	0f 91       	pop	r16
    32d4:	ff 90       	pop	r15
    32d6:	ef 90       	pop	r14
    32d8:	df 90       	pop	r13
    32da:	cf 90       	pop	r12
    32dc:	bf 90       	pop	r11
    32de:	af 90       	pop	r10
    32e0:	9f 90       	pop	r9
    32e2:	8f 90       	pop	r8
    32e4:	7f 90       	pop	r7
    32e6:	6f 90       	pop	r6
    32e8:	5f 90       	pop	r5
    32ea:	4f 90       	pop	r4
    32ec:	3f 90       	pop	r3
    32ee:	2f 90       	pop	r2
    32f0:	1f 90       	pop	r1
    32f2:	0f 90       	pop	r0
    32f4:	0c be       	out	0x3c, r0	; 60
    32f6:	0f 90       	pop	r0
    32f8:	0b be       	out	0x3b, r0	; 59
    32fa:	0f 90       	pop	r0
    32fc:	0f be       	out	0x3f, r0	; 63
    32fe:	0f 90       	pop	r0

	asm volatile ( "ret" );
    3300:	08 95       	ret

00003302 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    3302:	0f 92       	push	r0
    3304:	0f b6       	in	r0, 0x3f	; 63
    3306:	f8 94       	cli
    3308:	0f 92       	push	r0
    330a:	0b b6       	in	r0, 0x3b	; 59
    330c:	0f 92       	push	r0
    330e:	0c b6       	in	r0, 0x3c	; 60
    3310:	0f 92       	push	r0
    3312:	1f 92       	push	r1
    3314:	11 24       	eor	r1, r1
    3316:	2f 92       	push	r2
    3318:	3f 92       	push	r3
    331a:	4f 92       	push	r4
    331c:	5f 92       	push	r5
    331e:	6f 92       	push	r6
    3320:	7f 92       	push	r7
    3322:	8f 92       	push	r8
    3324:	9f 92       	push	r9
    3326:	af 92       	push	r10
    3328:	bf 92       	push	r11
    332a:	cf 92       	push	r12
    332c:	df 92       	push	r13
    332e:	ef 92       	push	r14
    3330:	ff 92       	push	r15
    3332:	0f 93       	push	r16
    3334:	1f 93       	push	r17
    3336:	2f 93       	push	r18
    3338:	3f 93       	push	r19
    333a:	4f 93       	push	r20
    333c:	5f 93       	push	r21
    333e:	6f 93       	push	r22
    3340:	7f 93       	push	r23
    3342:	8f 93       	push	r24
    3344:	9f 93       	push	r25
    3346:	af 93       	push	r26
    3348:	bf 93       	push	r27
    334a:	cf 93       	push	r28
    334c:	df 93       	push	r29
    334e:	ef 93       	push	r30
    3350:	ff 93       	push	r31
    3352:	a0 91 2a 02 	lds	r26, 0x022A
    3356:	b0 91 2b 02 	lds	r27, 0x022B
    335a:	0d b6       	in	r0, 0x3d	; 61
    335c:	0d 92       	st	X+, r0
    335e:	0e b6       	in	r0, 0x3e	; 62
    3360:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    3362:	0e 94 44 07 	call	0xe88	; 0xe88 <vTaskIncrementTick>
	vTaskSwitchContext();
    3366:	0e 94 21 08 	call	0x1042	; 0x1042 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    336a:	a0 91 2a 02 	lds	r26, 0x022A
    336e:	b0 91 2b 02 	lds	r27, 0x022B
    3372:	cd 91       	ld	r28, X+
    3374:	cd bf       	out	0x3d, r28	; 61
    3376:	dd 91       	ld	r29, X+
    3378:	de bf       	out	0x3e, r29	; 62
    337a:	ff 91       	pop	r31
    337c:	ef 91       	pop	r30
    337e:	df 91       	pop	r29
    3380:	cf 91       	pop	r28
    3382:	bf 91       	pop	r27
    3384:	af 91       	pop	r26
    3386:	9f 91       	pop	r25
    3388:	8f 91       	pop	r24
    338a:	7f 91       	pop	r23
    338c:	6f 91       	pop	r22
    338e:	5f 91       	pop	r21
    3390:	4f 91       	pop	r20
    3392:	3f 91       	pop	r19
    3394:	2f 91       	pop	r18
    3396:	1f 91       	pop	r17
    3398:	0f 91       	pop	r16
    339a:	ff 90       	pop	r15
    339c:	ef 90       	pop	r14
    339e:	df 90       	pop	r13
    33a0:	cf 90       	pop	r12
    33a2:	bf 90       	pop	r11
    33a4:	af 90       	pop	r10
    33a6:	9f 90       	pop	r9
    33a8:	8f 90       	pop	r8
    33aa:	7f 90       	pop	r7
    33ac:	6f 90       	pop	r6
    33ae:	5f 90       	pop	r5
    33b0:	4f 90       	pop	r4
    33b2:	3f 90       	pop	r3
    33b4:	2f 90       	pop	r2
    33b6:	1f 90       	pop	r1
    33b8:	0f 90       	pop	r0
    33ba:	0c be       	out	0x3c, r0	; 60
    33bc:	0f 90       	pop	r0
    33be:	0b be       	out	0x3b, r0	; 59
    33c0:	0f 90       	pop	r0
    33c2:	0f be       	out	0x3f, r0	; 63
    33c4:	0f 90       	pop	r0

	asm volatile ( "ret" );
    33c6:	08 95       	ret

000033c8 <prvSetupTimerInterrupt>:

/*
 * Setup timer 0 or 3 or 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    33c8:	cf 93       	push	r28
    33ca:	df 93       	push	r29
    33cc:	00 d0       	rcall	.+0      	; 0x33ce <prvSetupTimerInterrupt+0x6>
    33ce:	00 d0       	rcall	.+0      	; 0x33d0 <prvSetupTimerInterrupt+0x8>
    33d0:	cd b7       	in	r28, 0x3d	; 61
    33d2:	de b7       	in	r29, 0x3e	; 62

    /* Using 8bit Timer0 or 16bit Timer1 or Timer3 to generate the tick. */

    // ulCompareMatch 40,000 = 20,000,000 / 500; 20MHz
    // ulCompareMatch 110,592 = 22,118,400 / 200; 22.1184 MHz
    ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    33d4:	80 e0       	ldi	r24, 0x00	; 0
    33d6:	9d e7       	ldi	r25, 0x7D	; 125
    33d8:	a0 e0       	ldi	r26, 0x00	; 0
    33da:	b0 e0       	ldi	r27, 0x00	; 0
    33dc:	89 83       	std	Y+1, r24	; 0x01
    33de:	9a 83       	std	Y+2, r25	; 0x02
    33e0:	ab 83       	std	Y+3, r26	; 0x03
    33e2:	bc 83       	std	Y+4, r27	; 0x04

    /* We only have 8 or 16 bits so have to scale 64 or 256 to get our required tick rate. */
    //ulCompareMatch = 625 /= portCLOCK_PRESCALER; 20MHz with 64 prescale
    //ulCompareMatch = 108 /= portCLOCK_PRESCALER; 22.1184 MHz with 1024 prescale
    ulCompareMatch /= portCLOCK_PRESCALER;
    33e4:	89 81       	ldd	r24, Y+1	; 0x01
    33e6:	9a 81       	ldd	r25, Y+2	; 0x02
    33e8:	ab 81       	ldd	r26, Y+3	; 0x03
    33ea:	bc 81       	ldd	r27, Y+4	; 0x04
    33ec:	68 94       	set
    33ee:	15 f8       	bld	r1, 5
    33f0:	b6 95       	lsr	r27
    33f2:	a7 95       	ror	r26
    33f4:	97 95       	ror	r25
    33f6:	87 95       	ror	r24
    33f8:	16 94       	lsr	r1
    33fa:	d1 f7       	brne	.-12     	; 0x33f0 <prvSetupTimerInterrupt+0x28>
    33fc:	89 83       	std	Y+1, r24	; 0x01
    33fe:	9a 83       	std	Y+2, r25	; 0x02
    3400:	ab 83       	std	Y+3, r26	; 0x03
    3402:	bc 83       	std	Y+4, r27	; 0x04

    /* Adjust for correct value. */
    ulCompareMatch -= ( unsigned portLONG ) 1;
    3404:	89 81       	ldd	r24, Y+1	; 0x01
    3406:	9a 81       	ldd	r25, Y+2	; 0x02
    3408:	ab 81       	ldd	r26, Y+3	; 0x03
    340a:	bc 81       	ldd	r27, Y+4	; 0x04
    340c:	01 97       	sbiw	r24, 0x01	; 1
    340e:	a1 09       	sbc	r26, r1
    3410:	b1 09       	sbc	r27, r1
    3412:	89 83       	std	Y+1, r24	; 0x01
    3414:	9a 83       	std	Y+2, r25	; 0x02
    3416:	ab 83       	std	Y+3, r26	; 0x03
    3418:	bc 83       	std	Y+4, r27	; 0x04

    /* Setup compare match value for compare match A.  Interrupts are disabled
    before this is called so we need not worry here. */
    ucLowByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
    341a:	89 81       	ldd	r24, Y+1	; 0x01
    341c:	8d 83       	std	Y+5, r24	; 0x05
    //  OCR3AL = ucLowByte;

    // the HiByte is only needed, if a 16 Bit counter is being utilized
#ifdef portOCRH

    ulCompareMatch >>= 8;
    341e:	89 81       	ldd	r24, Y+1	; 0x01
    3420:	9a 81       	ldd	r25, Y+2	; 0x02
    3422:	ab 81       	ldd	r26, Y+3	; 0x03
    3424:	bc 81       	ldd	r27, Y+4	; 0x04
    3426:	89 2f       	mov	r24, r25
    3428:	9a 2f       	mov	r25, r26
    342a:	ab 2f       	mov	r26, r27
    342c:	bb 27       	eor	r27, r27
    342e:	89 83       	std	Y+1, r24	; 0x01
    3430:	9a 83       	std	Y+2, r25	; 0x02
    3432:	ab 83       	std	Y+3, r26	; 0x03
    3434:	bc 83       	std	Y+4, r27	; 0x04
    ucHighByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
    3436:	89 81       	ldd	r24, Y+1	; 0x01
    3438:	8e 83       	std	Y+6, r24	; 0x06
    portOCRH = ucHighByte;
    343a:	89 e9       	ldi	r24, 0x99	; 153
    343c:	90 e0       	ldi	r25, 0x00	; 0
    343e:	2e 81       	ldd	r18, Y+6	; 0x06
    3440:	fc 01       	movw	r30, r24
    3442:	20 83       	st	Z, r18

#endif

    portOCRL = ucLowByte;
    3444:	88 e9       	ldi	r24, 0x98	; 152
    3446:	90 e0       	ldi	r25, 0x00	; 0
    3448:	2d 81       	ldd	r18, Y+5	; 0x05
    344a:	fc 01       	movw	r30, r24
    344c:	20 83       	st	Z, r18
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	portTCCRb = ucLowByte;

#elif defined( portUSE_TIMER3 )
	/* Setup clock source and compare match behaviour. Assuming  640 / 1280 /1281 / 1284p / 2560 / 2561 (with Timer3) */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    344e:	8b e0       	ldi	r24, 0x0B	; 11
    3450:	8d 83       	std	Y+5, r24	; 0x05
	portTCCRb = ucLowByte;
    3452:	81 e9       	ldi	r24, 0x91	; 145
    3454:	90 e0       	ldi	r25, 0x00	; 0
    3456:	2d 81       	ldd	r18, Y+5	; 0x05
    3458:	fc 01       	movw	r30, r24
    345a:	20 83       	st	Z, r18
#endif

    /* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
    ucLowByte = portTIMSK;
    345c:	81 e7       	ldi	r24, 0x71	; 113
    345e:	90 e0       	ldi	r25, 0x00	; 0
    3460:	fc 01       	movw	r30, r24
    3462:	80 81       	ld	r24, Z
    3464:	8d 83       	std	Y+5, r24	; 0x05
    ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    3466:	8d 81       	ldd	r24, Y+5	; 0x05
    3468:	82 60       	ori	r24, 0x02	; 2
    346a:	8d 83       	std	Y+5, r24	; 0x05
    portTIMSK = ucLowByte;
    346c:	81 e7       	ldi	r24, 0x71	; 113
    346e:	90 e0       	ldi	r25, 0x00	; 0
    3470:	2d 81       	ldd	r18, Y+5	; 0x05
    3472:	fc 01       	movw	r30, r24
    3474:	20 83       	st	Z, r18

}
    3476:	26 96       	adiw	r28, 0x06	; 6
    3478:	0f b6       	in	r0, 0x3f	; 63
    347a:	f8 94       	cli
    347c:	de bf       	out	0x3e, r29	; 62
    347e:	0f be       	out	0x3f, r0	; 63
    3480:	cd bf       	out	0x3d, r28	; 61
    3482:	df 91       	pop	r29
    3484:	cf 91       	pop	r28
    3486:	08 95       	ret

00003488 <__vector_32>:

	#elif defined( portUSE_TIMER3 )
		#warning "Timer3 used for PRE-EMPTIVE scheduler."
		ISR(TIMER3_COMPA_vect, ISR_NAKED)
		{
			vPortYieldFromTick();
    3488:	0e 94 81 19 	call	0x3302	; 0x3302 <vPortYieldFromTick>
			asm volatile ( "reti" );
    348c:	18 95       	reti

0000348e <USART_Init>:
*  the specified baud rate and clk speed.
*
* Param buadin: The desired Baud rate.
* Param clk_seedin: The clk speed of the ATmega328p
************************************/
void USART_Init(uint16_t baudin, uint32_t clk_speedin) {
    348e:	cf 93       	push	r28
    3490:	df 93       	push	r29
    3492:	00 d0       	rcall	.+0      	; 0x3494 <USART_Init+0x6>
    3494:	00 d0       	rcall	.+0      	; 0x3496 <USART_Init+0x8>
    3496:	cd b7       	in	r28, 0x3d	; 61
    3498:	de b7       	in	r29, 0x3e	; 62
    349a:	9a 83       	std	Y+2, r25	; 0x02
    349c:	89 83       	std	Y+1, r24	; 0x01
    349e:	4b 83       	std	Y+3, r20	; 0x03
    34a0:	5c 83       	std	Y+4, r21	; 0x04
    34a2:	6d 83       	std	Y+5, r22	; 0x05
    34a4:	7e 83       	std	Y+6, r23	; 0x06
    USART_WriteQueue = xQueueCreate(64,sizeof(uint8_t));
    34a6:	40 e0       	ldi	r20, 0x00	; 0
    34a8:	61 e0       	ldi	r22, 0x01	; 1
    34aa:	80 e4       	ldi	r24, 0x40	; 64
    34ac:	0e 94 23 0d 	call	0x1a46	; 0x1a46 <xQueueGenericCreate>
    34b0:	90 93 d1 1a 	sts	0x1AD1, r25
    34b4:	80 93 d0 1a 	sts	0x1AD0, r24
    USART_ReadQueue = xQueueCreate(8,sizeof(uint8_t));
    34b8:	40 e0       	ldi	r20, 0x00	; 0
    34ba:	61 e0       	ldi	r22, 0x01	; 1
    34bc:	88 e0       	ldi	r24, 0x08	; 8
    34be:	0e 94 23 0d 	call	0x1a46	; 0x1a46 <xQueueGenericCreate>
    34c2:	90 93 cd 1a 	sts	0x1ACD, r25
    34c6:	80 93 cc 1a 	sts	0x1ACC, r24

    //uint32_t ubrr = clk_speedin/(16UL)/baudin-1;
    //UBRR1H = (unsigned char)(ubrr>>8) ;// & 0x7F;
    //UBRR1L = (unsigned char)ubrr;
    
    UBRR0H = 0; //115200
    34ca:	85 ec       	ldi	r24, 0xC5	; 197
    34cc:	90 e0       	ldi	r25, 0x00	; 0
    34ce:	fc 01       	movw	r30, r24
    34d0:	10 82       	st	Z, r1
    UBRR0L = 8;
    34d2:	84 ec       	ldi	r24, 0xC4	; 196
    34d4:	90 e0       	ldi	r25, 0x00	; 0
    34d6:	28 e0       	ldi	r18, 0x08	; 8
    34d8:	fc 01       	movw	r30, r24
    34da:	20 83       	st	Z, r18

    /* Enable receiver and transmitter */
    UCSR0B = (1<<RXEN0)|(1<<TXEN0);//|(1<<RXCIE1);
    34dc:	81 ec       	ldi	r24, 0xC1	; 193
    34de:	90 e0       	ldi	r25, 0x00	; 0
    34e0:	28 e1       	ldi	r18, 0x18	; 24
    34e2:	fc 01       	movw	r30, r24
    34e4:	20 83       	st	Z, r18
    /* Set frame format: 8data, 1stop bit */
    UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);
    34e6:	82 ec       	ldi	r24, 0xC2	; 194
    34e8:	90 e0       	ldi	r25, 0x00	; 0
    34ea:	26 e0       	ldi	r18, 0x06	; 6
    34ec:	fc 01       	movw	r30, r24
    34ee:	20 83       	st	Z, r18
	 // clear U2X0 for Synchronous operation
    UCSR0A &= ~(1<<U2X0);
    34f0:	80 ec       	ldi	r24, 0xC0	; 192
    34f2:	90 e0       	ldi	r25, 0x00	; 0
    34f4:	20 ec       	ldi	r18, 0xC0	; 192
    34f6:	30 e0       	ldi	r19, 0x00	; 0
    34f8:	f9 01       	movw	r30, r18
    34fa:	20 81       	ld	r18, Z
    34fc:	2d 7f       	andi	r18, 0xFD	; 253
    34fe:	fc 01       	movw	r30, r24
    3500:	20 83       	st	Z, r18
    /* Set frame format: 8data, 1stop bit */
    //UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);
    // clear U2X0 for Synchronous operation
    //UCSR0A &= ~(1<<U2X0);*/

}
    3502:	26 96       	adiw	r28, 0x06	; 6
    3504:	0f b6       	in	r0, 0x3f	; 63
    3506:	f8 94       	cli
    3508:	de bf       	out	0x3e, r29	; 62
    350a:	0f be       	out	0x3f, r0	; 63
    350c:	cd bf       	out	0x3d, r28	; 61
    350e:	df 91       	pop	r29
    3510:	cf 91       	pop	r28
    3512:	08 95       	ret

00003514 <USART_Write>:

/*the send function will put 8bits on the trans line. */
void USART_Write(uint8_t data) {
    3514:	cf 93       	push	r28
    3516:	df 93       	push	r29
    3518:	1f 92       	push	r1
    351a:	cd b7       	in	r28, 0x3d	; 61
    351c:	de b7       	in	r29, 0x3e	; 62
    351e:	89 83       	std	Y+1, r24	; 0x01
		/* Wait for empty transmit buffer */
		while ( !( UCSR0A & (1<<UDRE0)) )
    3520:	00 00       	nop
    3522:	80 ec       	ldi	r24, 0xC0	; 192
    3524:	90 e0       	ldi	r25, 0x00	; 0
    3526:	fc 01       	movw	r30, r24
    3528:	80 81       	ld	r24, Z
    352a:	88 2f       	mov	r24, r24
    352c:	90 e0       	ldi	r25, 0x00	; 0
    352e:	80 72       	andi	r24, 0x20	; 32
    3530:	99 27       	eor	r25, r25
    3532:	00 97       	sbiw	r24, 0x00	; 0
    3534:	b1 f3       	breq	.-20     	; 0x3522 <USART_Write+0xe>
		;
		/* Put data into buffer, sends the data */
		UDR0 = data;
    3536:	86 ec       	ldi	r24, 0xC6	; 198
    3538:	90 e0       	ldi	r25, 0x00	; 0
    353a:	29 81       	ldd	r18, Y+1	; 0x01
    353c:	fc 01       	movw	r30, r24
    353e:	20 83       	st	Z, r18
}
    3540:	0f 90       	pop	r0
    3542:	df 91       	pop	r29
    3544:	cf 91       	pop	r28
    3546:	08 95       	ret

00003548 <USART_Write_Unprotected>:

/*the send function will put 8bits on the trans line. */
void USART_Write_Unprotected(uint8_t data) {
    3548:	cf 93       	push	r28
    354a:	df 93       	push	r29
    354c:	1f 92       	push	r1
    354e:	cd b7       	in	r28, 0x3d	; 61
    3550:	de b7       	in	r29, 0x3e	; 62
    3552:	89 83       	std	Y+1, r24	; 0x01
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)) )
    3554:	00 00       	nop
    3556:	80 ec       	ldi	r24, 0xC0	; 192
    3558:	90 e0       	ldi	r25, 0x00	; 0
    355a:	fc 01       	movw	r30, r24
    355c:	80 81       	ld	r24, Z
    355e:	88 2f       	mov	r24, r24
    3560:	90 e0       	ldi	r25, 0x00	; 0
    3562:	80 72       	andi	r24, 0x20	; 32
    3564:	99 27       	eor	r25, r25
    3566:	00 97       	sbiw	r24, 0x00	; 0
    3568:	b1 f3       	breq	.-20     	; 0x3556 <USART_Write_Unprotected+0xe>
	;
	/* Put data into buffer, sends the data */
	UDR0 = data;
    356a:	86 ec       	ldi	r24, 0xC6	; 198
    356c:	90 e0       	ldi	r25, 0x00	; 0
    356e:	29 81       	ldd	r18, Y+1	; 0x01
    3570:	fc 01       	movw	r30, r24
    3572:	20 83       	st	Z, r18
}
    3574:	0f 90       	pop	r0
    3576:	df 91       	pop	r29
    3578:	cf 91       	pop	r28
    357a:	08 95       	ret

0000357c <USART_Read>:
Therefore you may not get control back after this is called 
until a much later time. It may be helpful to use the 
istheredata() function to check before calling this function
        @return 8bit data packet from sender
*/
uint8_t USART_Read(void) {
    357c:	cf 93       	push	r28
    357e:	df 93       	push	r29
    3580:	cd b7       	in	r28, 0x3d	; 61
    3582:	de b7       	in	r29, 0x3e	; 62
    /* Wait for data to be received */
    while ( !(UCSR2A & (1<<RXC2)) )
    3584:	00 00       	nop
    3586:	80 ed       	ldi	r24, 0xD0	; 208
    3588:	90 e0       	ldi	r25, 0x00	; 0
    358a:	fc 01       	movw	r30, r24
    358c:	80 81       	ld	r24, Z
    358e:	88 23       	and	r24, r24
    3590:	d4 f7       	brge	.-12     	; 0x3586 <USART_Read+0xa>
        ;
    /* Get and return received data from buffer */
    return UDR2;
    3592:	86 ed       	ldi	r24, 0xD6	; 214
    3594:	90 e0       	ldi	r25, 0x00	; 0
    3596:	fc 01       	movw	r30, r24
    3598:	80 81       	ld	r24, Z
}
    359a:	df 91       	pop	r29
    359c:	cf 91       	pop	r28
    359e:	08 95       	ret

000035a0 <__vector_36>:


ISR(USART1_RX_vect){
    35a0:	1f 92       	push	r1
    35a2:	0f 92       	push	r0
    35a4:	00 90 5f 00 	lds	r0, 0x005F
    35a8:	0f 92       	push	r0
    35aa:	11 24       	eor	r1, r1
    35ac:	00 90 5b 00 	lds	r0, 0x005B
    35b0:	0f 92       	push	r0
    35b2:	8f 93       	push	r24
    35b4:	9f 93       	push	r25
    35b6:	ef 93       	push	r30
    35b8:	ff 93       	push	r31
    35ba:	cf 93       	push	r28
    35bc:	df 93       	push	r29
    35be:	1f 92       	push	r1
    35c0:	cd b7       	in	r28, 0x3d	; 61
    35c2:	de b7       	in	r29, 0x3e	; 62
    uint8_t data;
    data = UDR1;
    35c4:	8e ec       	ldi	r24, 0xCE	; 206
    35c6:	90 e0       	ldi	r25, 0x00	; 0
    35c8:	fc 01       	movw	r30, r24
    35ca:	80 81       	ld	r24, Z
    35cc:	89 83       	std	Y+1, r24	; 0x01
    //UDR1 = data;
    

  //  USART_AddToQueue(data);
    //xQueueSendToBackFromISR(USART_ReadQueue,&data,NULL);
}
    35ce:	0f 90       	pop	r0
    35d0:	df 91       	pop	r29
    35d2:	cf 91       	pop	r28
    35d4:	ff 91       	pop	r31
    35d6:	ef 91       	pop	r30
    35d8:	9f 91       	pop	r25
    35da:	8f 91       	pop	r24
    35dc:	0f 90       	pop	r0
    35de:	00 92 5b 00 	sts	0x005B, r0
    35e2:	0f 90       	pop	r0
    35e4:	00 92 5f 00 	sts	0x005F, r0
    35e8:	0f 90       	pop	r0
    35ea:	1f 90       	pop	r1
    35ec:	18 95       	reti

000035ee <USART_AddToQueue>:

void USART_AddToQueue(uint8_t data){
    35ee:	cf 93       	push	r28
    35f0:	df 93       	push	r29
    35f2:	1f 92       	push	r1
    35f4:	cd b7       	in	r28, 0x3d	; 61
    35f6:	de b7       	in	r29, 0x3e	; 62
    35f8:	89 83       	std	Y+1, r24	; 0x01
    
    xQueueSendToBack(USART_WriteQueue,&data,portMAX_DELAY);
    35fa:	80 91 d0 1a 	lds	r24, 0x1AD0
    35fe:	90 91 d1 1a 	lds	r25, 0x1AD1
    3602:	20 e0       	ldi	r18, 0x00	; 0
    3604:	4f ef       	ldi	r20, 0xFF	; 255
    3606:	5f ef       	ldi	r21, 0xFF	; 255
    3608:	be 01       	movw	r22, r28
    360a:	6f 5f       	subi	r22, 0xFF	; 255
    360c:	7f 4f       	sbci	r23, 0xFF	; 255
    360e:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <xQueueGenericSend>

}
    3612:	0f 90       	pop	r0
    3614:	df 91       	pop	r29
    3616:	cf 91       	pop	r28
    3618:	08 95       	ret

0000361a <USART_TransmitString>:

void USART_TransmitString(char* str){
    361a:	cf 93       	push	r28
    361c:	df 93       	push	r29
    361e:	1f 92       	push	r1
    3620:	1f 92       	push	r1
    3622:	cd b7       	in	r28, 0x3d	; 61
    3624:	de b7       	in	r29, 0x3e	; 62
    3626:	9a 83       	std	Y+2, r25	; 0x02
    3628:	89 83       	std	Y+1, r24	; 0x01
    while(*str) {
    362a:	0b c0       	rjmp	.+22     	; 0x3642 <USART_TransmitString+0x28>
        USART_AddToQueue(*str);
    362c:	89 81       	ldd	r24, Y+1	; 0x01
    362e:	9a 81       	ldd	r25, Y+2	; 0x02
    3630:	fc 01       	movw	r30, r24
    3632:	80 81       	ld	r24, Z
    3634:	0e 94 f7 1a 	call	0x35ee	; 0x35ee <USART_AddToQueue>
        str++;
    3638:	89 81       	ldd	r24, Y+1	; 0x01
    363a:	9a 81       	ldd	r25, Y+2	; 0x02
    363c:	01 96       	adiw	r24, 0x01	; 1
    363e:	9a 83       	std	Y+2, r25	; 0x02
    3640:	89 83       	std	Y+1, r24	; 0x01
    xQueueSendToBack(USART_WriteQueue,&data,portMAX_DELAY);

}

void USART_TransmitString(char* str){
    while(*str) {
    3642:	89 81       	ldd	r24, Y+1	; 0x01
    3644:	9a 81       	ldd	r25, Y+2	; 0x02
    3646:	fc 01       	movw	r30, r24
    3648:	80 81       	ld	r24, Z
    364a:	88 23       	and	r24, r24
    364c:	79 f7       	brne	.-34     	; 0x362c <USART_TransmitString+0x12>
        USART_AddToQueue(*str);
        str++;
    }
}
    364e:	0f 90       	pop	r0
    3650:	0f 90       	pop	r0
    3652:	df 91       	pop	r29
    3654:	cf 91       	pop	r28
    3656:	08 95       	ret

00003658 <vTaskUSARTWrite>:

void vTaskUSARTWrite(void *pvParameters){
    3658:	cf 93       	push	r28
    365a:	df 93       	push	r29
    365c:	00 d0       	rcall	.+0      	; 0x365e <vTaskUSARTWrite+0x6>
    365e:	cd b7       	in	r28, 0x3d	; 61
    3660:	de b7       	in	r29, 0x3e	; 62
    3662:	9b 83       	std	Y+3, r25	; 0x03
    3664:	8a 83       	std	Y+2, r24	; 0x02
    uint8_t data;
    while(1){
    xQueueReceive(USART_WriteQueue,&data,portMAX_DELAY);
    3666:	80 91 d0 1a 	lds	r24, 0x1AD0
    366a:	90 91 d1 1a 	lds	r25, 0x1AD1
    366e:	20 e0       	ldi	r18, 0x00	; 0
    3670:	4f ef       	ldi	r20, 0xFF	; 255
    3672:	5f ef       	ldi	r21, 0xFF	; 255
    3674:	be 01       	movw	r22, r28
    3676:	6f 5f       	subi	r22, 0xFF	; 255
    3678:	7f 4f       	sbci	r23, 0xFF	; 255
    367a:	0e 94 d7 0e 	call	0x1dae	; 0x1dae <xQueueGenericReceive>

        while(!(UCSR1A & (1<<UDRE1)));
    367e:	00 00       	nop
    3680:	88 ec       	ldi	r24, 0xC8	; 200
    3682:	90 e0       	ldi	r25, 0x00	; 0
    3684:	fc 01       	movw	r30, r24
    3686:	80 81       	ld	r24, Z
    3688:	88 2f       	mov	r24, r24
    368a:	90 e0       	ldi	r25, 0x00	; 0
    368c:	80 72       	andi	r24, 0x20	; 32
    368e:	99 27       	eor	r25, r25
    3690:	00 97       	sbiw	r24, 0x00	; 0
    3692:	b1 f3       	breq	.-20     	; 0x3680 <vTaskUSARTWrite+0x28>
        UDR1 = data;
    3694:	8e ec       	ldi	r24, 0xCE	; 206
    3696:	90 e0       	ldi	r25, 0x00	; 0
    3698:	29 81       	ldd	r18, Y+1	; 0x01
    369a:	fc 01       	movw	r30, r24
    369c:	20 83       	st	Z, r18

    }
    369e:	e3 cf       	rjmp	.-58     	; 0x3666 <vTaskUSARTWrite+0xe>

000036a0 <USART_LogChar>:
}

void USART_LogChar(uint8_t data){
    36a0:	cf 93       	push	r28
    36a2:	df 93       	push	r29
    36a4:	1f 92       	push	r1
    36a6:	cd b7       	in	r28, 0x3d	; 61
    36a8:	de b7       	in	r29, 0x3e	; 62
    36aa:	89 83       	std	Y+1, r24	; 0x01
    xQueueSendToBack(USART_WriteQueueLog,&data,portMAX_DELAY);
    36ac:	80 91 ce 1a 	lds	r24, 0x1ACE
    36b0:	90 91 cf 1a 	lds	r25, 0x1ACF
    36b4:	20 e0       	ldi	r18, 0x00	; 0
    36b6:	4f ef       	ldi	r20, 0xFF	; 255
    36b8:	5f ef       	ldi	r21, 0xFF	; 255
    36ba:	be 01       	movw	r22, r28
    36bc:	6f 5f       	subi	r22, 0xFF	; 255
    36be:	7f 4f       	sbci	r23, 0xFF	; 255
    36c0:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <xQueueGenericSend>
}
    36c4:	0f 90       	pop	r0
    36c6:	df 91       	pop	r29
    36c8:	cf 91       	pop	r28
    36ca:	08 95       	ret

000036cc <USART_LogString>:

void USART_LogString(char* str){
    36cc:	cf 93       	push	r28
    36ce:	df 93       	push	r29
    36d0:	1f 92       	push	r1
    36d2:	1f 92       	push	r1
    36d4:	cd b7       	in	r28, 0x3d	; 61
    36d6:	de b7       	in	r29, 0x3e	; 62
    36d8:	9a 83       	std	Y+2, r25	; 0x02
    36da:	89 83       	std	Y+1, r24	; 0x01
    while(*str){
    36dc:	0b c0       	rjmp	.+22     	; 0x36f4 <USART_LogString+0x28>
        USART_LogChar(*str);
    36de:	89 81       	ldd	r24, Y+1	; 0x01
    36e0:	9a 81       	ldd	r25, Y+2	; 0x02
    36e2:	fc 01       	movw	r30, r24
    36e4:	80 81       	ld	r24, Z
    36e6:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <USART_LogChar>
        str++;
    36ea:	89 81       	ldd	r24, Y+1	; 0x01
    36ec:	9a 81       	ldd	r25, Y+2	; 0x02
    36ee:	01 96       	adiw	r24, 0x01	; 1
    36f0:	9a 83       	std	Y+2, r25	; 0x02
    36f2:	89 83       	std	Y+1, r24	; 0x01
void USART_LogChar(uint8_t data){
    xQueueSendToBack(USART_WriteQueueLog,&data,portMAX_DELAY);
}

void USART_LogString(char* str){
    while(*str){
    36f4:	89 81       	ldd	r24, Y+1	; 0x01
    36f6:	9a 81       	ldd	r25, Y+2	; 0x02
    36f8:	fc 01       	movw	r30, r24
    36fa:	80 81       	ld	r24, Z
    36fc:	88 23       	and	r24, r24
    36fe:	79 f7       	brne	.-34     	; 0x36de <USART_LogString+0x12>
        USART_LogChar(*str);
        str++;
    }
}
    3700:	0f 90       	pop	r0
    3702:	0f 90       	pop	r0
    3704:	df 91       	pop	r29
    3706:	cf 91       	pop	r28
    3708:	08 95       	ret

0000370a <vTaskUSARTLog>:

void vTaskUSARTLog(void *pvParameters){
    370a:	cf 93       	push	r28
    370c:	df 93       	push	r29
    370e:	00 d0       	rcall	.+0      	; 0x3710 <vTaskUSARTLog+0x6>
    3710:	cd b7       	in	r28, 0x3d	; 61
    3712:	de b7       	in	r29, 0x3e	; 62
    3714:	9b 83       	std	Y+3, r25	; 0x03
    3716:	8a 83       	std	Y+2, r24	; 0x02
    uint8_t data;
    while(1){
        xQueueReceive(USART_WriteQueueLog,&data,portMAX_DELAY);
    3718:	80 91 ce 1a 	lds	r24, 0x1ACE
    371c:	90 91 cf 1a 	lds	r25, 0x1ACF
    3720:	20 e0       	ldi	r18, 0x00	; 0
    3722:	4f ef       	ldi	r20, 0xFF	; 255
    3724:	5f ef       	ldi	r21, 0xFF	; 255
    3726:	be 01       	movw	r22, r28
    3728:	6f 5f       	subi	r22, 0xFF	; 255
    372a:	7f 4f       	sbci	r23, 0xFF	; 255
    372c:	0e 94 d7 0e 	call	0x1dae	; 0x1dae <xQueueGenericReceive>

        while(!(UCSR0A & (1<<UDRE0)));
    3730:	00 00       	nop
    3732:	80 ec       	ldi	r24, 0xC0	; 192
    3734:	90 e0       	ldi	r25, 0x00	; 0
    3736:	fc 01       	movw	r30, r24
    3738:	80 81       	ld	r24, Z
    373a:	88 2f       	mov	r24, r24
    373c:	90 e0       	ldi	r25, 0x00	; 0
    373e:	80 72       	andi	r24, 0x20	; 32
    3740:	99 27       	eor	r25, r25
    3742:	00 97       	sbiw	r24, 0x00	; 0
    3744:	b1 f3       	breq	.-20     	; 0x3732 <vTaskUSARTLog+0x28>
        UDR0 = data;
    3746:	86 ec       	ldi	r24, 0xC6	; 198
    3748:	90 e0       	ldi	r25, 0x00	; 0
    374a:	29 81       	ldd	r18, Y+1	; 0x01
    374c:	fc 01       	movw	r30, r24
    374e:	20 83       	st	Z, r18

    }
    3750:	e3 cf       	rjmp	.-58     	; 0x3718 <vTaskUSARTLog+0xe>

00003752 <USART_GetChar>:

}

uint8_t USART_GetChar(){
    3752:	cf 93       	push	r28
    3754:	df 93       	push	r29
    3756:	1f 92       	push	r1
    3758:	cd b7       	in	r28, 0x3d	; 61
    375a:	de b7       	in	r29, 0x3e	; 62
    uint8_t data;
    if(xQueueReceive(USART_ReadQueue,&data,1) == pdTRUE){
    375c:	80 91 cc 1a 	lds	r24, 0x1ACC
    3760:	90 91 cd 1a 	lds	r25, 0x1ACD
    3764:	20 e0       	ldi	r18, 0x00	; 0
    3766:	41 e0       	ldi	r20, 0x01	; 1
    3768:	50 e0       	ldi	r21, 0x00	; 0
    376a:	be 01       	movw	r22, r28
    376c:	6f 5f       	subi	r22, 0xFF	; 255
    376e:	7f 4f       	sbci	r23, 0xFF	; 255
    3770:	0e 94 d7 0e 	call	0x1dae	; 0x1dae <xQueueGenericReceive>
    3774:	81 30       	cpi	r24, 0x01	; 1
    3776:	11 f4       	brne	.+4      	; 0x377c <USART_GetChar+0x2a>
        //USART_AddToQueue('~');
        return data;
    3778:	89 81       	ldd	r24, Y+1	; 0x01
    377a:	01 c0       	rjmp	.+2      	; 0x377e <USART_GetChar+0x2c>
    } else {
        return 255;
    377c:	8f ef       	ldi	r24, 0xFF	; 255
    }
}
    377e:	0f 90       	pop	r0
    3780:	df 91       	pop	r29
    3782:	cf 91       	pop	r28
    3784:	08 95       	ret

00003786 <delay>:

void delay(int a){
    3786:	cf 93       	push	r28
    3788:	df 93       	push	r29
    378a:	00 d0       	rcall	.+0      	; 0x378c <delay+0x6>
    378c:	1f 92       	push	r1
    378e:	cd b7       	in	r28, 0x3d	; 61
    3790:	de b7       	in	r29, 0x3e	; 62
    3792:	9c 83       	std	Y+4, r25	; 0x04
    3794:	8b 83       	std	Y+3, r24	; 0x03
	int i;
	for(i = 0;i < a;i++);
    3796:	1a 82       	std	Y+2, r1	; 0x02
    3798:	19 82       	std	Y+1, r1	; 0x01
    379a:	05 c0       	rjmp	.+10     	; 0x37a6 <delay+0x20>
    379c:	89 81       	ldd	r24, Y+1	; 0x01
    379e:	9a 81       	ldd	r25, Y+2	; 0x02
    37a0:	01 96       	adiw	r24, 0x01	; 1
    37a2:	9a 83       	std	Y+2, r25	; 0x02
    37a4:	89 83       	std	Y+1, r24	; 0x01
    37a6:	29 81       	ldd	r18, Y+1	; 0x01
    37a8:	3a 81       	ldd	r19, Y+2	; 0x02
    37aa:	8b 81       	ldd	r24, Y+3	; 0x03
    37ac:	9c 81       	ldd	r25, Y+4	; 0x04
    37ae:	28 17       	cp	r18, r24
    37b0:	39 07       	cpc	r19, r25
    37b2:	a4 f3       	brlt	.-24     	; 0x379c <delay+0x16>
}
    37b4:	0f 90       	pop	r0
    37b6:	0f 90       	pop	r0
    37b8:	0f 90       	pop	r0
    37ba:	0f 90       	pop	r0
    37bc:	df 91       	pop	r29
    37be:	cf 91       	pop	r28
    37c0:	08 95       	ret

000037c2 <sendACK>:

void sendACK(){
    37c2:	cf 93       	push	r28
    37c4:	df 93       	push	r29
    37c6:	cd b7       	in	r28, 0x3d	; 61
    37c8:	de b7       	in	r29, 0x3e	; 62
    USART_Write(ACK_BYTE);
    37ca:	80 e8       	ldi	r24, 0x80	; 128
    37cc:	0e 94 8a 1a 	call	0x3514	; 0x3514 <USART_Write>
}
    37d0:	df 91       	pop	r29
    37d2:	cf 91       	pop	r28
    37d4:	08 95       	ret

000037d6 <sendNACK>:

void sendNACK(){
    37d6:	cf 93       	push	r28
    37d8:	df 93       	push	r29
    37da:	cd b7       	in	r28, 0x3d	; 61
    37dc:	de b7       	in	r29, 0x3e	; 62
    USART_Write(NACK_BYTE);
    37de:	80 e0       	ldi	r24, 0x00	; 0
    37e0:	0e 94 8a 1a 	call	0x3514	; 0x3514 <USART_Write>
}
    37e4:	df 91       	pop	r29
    37e6:	cf 91       	pop	r28
    37e8:	08 95       	ret

000037ea <recievePayload>:

int recievePayload(int size,unsigned char *buffer){
    37ea:	cf 93       	push	r28
    37ec:	df 93       	push	r29
    37ee:	cd b7       	in	r28, 0x3d	; 61
    37f0:	de b7       	in	r29, 0x3e	; 62
    37f2:	2d 97       	sbiw	r28, 0x0d	; 13
    37f4:	0f b6       	in	r0, 0x3f	; 63
    37f6:	f8 94       	cli
    37f8:	de bf       	out	0x3e, r29	; 62
    37fa:	0f be       	out	0x3f, r0	; 63
    37fc:	cd bf       	out	0x3d, r28	; 61
    37fe:	9b 87       	std	Y+11, r25	; 0x0b
    3800:	8a 87       	std	Y+10, r24	; 0x0a
    3802:	7d 87       	std	Y+13, r23	; 0x0d
    3804:	6c 87       	std	Y+12, r22	; 0x0c

	int bytesRecieved = 0;
    3806:	1a 82       	std	Y+2, r1	; 0x02
    3808:	19 82       	std	Y+1, r1	; 0x01
	int numTries = 0;
    380a:	1c 82       	std	Y+4, r1	; 0x04
    380c:	1b 82       	std	Y+3, r1	; 0x03
	const int maxNumTries = 3;
    380e:	83 e0       	ldi	r24, 0x03	; 3
    3810:	90 e0       	ldi	r25, 0x00	; 0
    3812:	98 87       	std	Y+8, r25	; 0x08
    3814:	8f 83       	std	Y+7, r24	; 0x07
	unsigned char data;
	int timeout;

	while(numTries < maxNumTries){
    3816:	6d c0       	rjmp	.+218    	; 0x38f2 <recievePayload+0x108>
		while(bytesRecieved < size){
    3818:	2e c0       	rjmp	.+92     	; 0x3876 <recievePayload+0x8c>
			timeout = 50;
    381a:	82 e3       	ldi	r24, 0x32	; 50
    381c:	90 e0       	ldi	r25, 0x00	; 0
    381e:	9e 83       	std	Y+6, r25	; 0x06
    3820:	8d 83       	std	Y+5, r24	; 0x05
			while ( !(UCSR0A & (1<<RXC0)) ){
    3822:	10 c0       	rjmp	.+32     	; 0x3844 <recievePayload+0x5a>
  				timeout--;
    3824:	8d 81       	ldd	r24, Y+5	; 0x05
    3826:	9e 81       	ldd	r25, Y+6	; 0x06
    3828:	01 97       	sbiw	r24, 0x01	; 1
    382a:	9e 83       	std	Y+6, r25	; 0x06
    382c:	8d 83       	std	Y+5, r24	; 0x05
     			if(timeout == 0){
    382e:	8d 81       	ldd	r24, Y+5	; 0x05
    3830:	9e 81       	ldd	r25, Y+6	; 0x06
    3832:	00 97       	sbiw	r24, 0x00	; 0
    3834:	19 f4       	brne	.+6      	; 0x383c <recievePayload+0x52>
					return -1;
    3836:	8f ef       	ldi	r24, 0xFF	; 255
    3838:	9f ef       	ldi	r25, 0xFF	; 255
    383a:	65 c0       	rjmp	.+202    	; 0x3906 <recievePayload+0x11c>
     			}
     			vTaskDelay(1);
    383c:	81 e0       	ldi	r24, 0x01	; 1
    383e:	90 e0       	ldi	r25, 0x00	; 0
    3840:	0e 94 ab 04 	call	0x956	; 0x956 <vTaskDelay>
	int timeout;

	while(numTries < maxNumTries){
		while(bytesRecieved < size){
			timeout = 50;
			while ( !(UCSR0A & (1<<RXC0)) ){
    3844:	80 ec       	ldi	r24, 0xC0	; 192
    3846:	90 e0       	ldi	r25, 0x00	; 0
    3848:	fc 01       	movw	r30, r24
    384a:	80 81       	ld	r24, Z
    384c:	88 23       	and	r24, r24
    384e:	54 f7       	brge	.-44     	; 0x3824 <recievePayload+0x3a>
     			if(timeout == 0){
					return -1;
     			}
     			vTaskDelay(1);
   		}
			data = UDR0;
    3850:	86 ec       	ldi	r24, 0xC6	; 198
    3852:	90 e0       	ldi	r25, 0x00	; 0
    3854:	fc 01       	movw	r30, r24
    3856:	80 81       	ld	r24, Z
    3858:	89 87       	std	Y+9, r24	; 0x09
			buffer[bytesRecieved] = data;
    385a:	89 81       	ldd	r24, Y+1	; 0x01
    385c:	9a 81       	ldd	r25, Y+2	; 0x02
    385e:	2c 85       	ldd	r18, Y+12	; 0x0c
    3860:	3d 85       	ldd	r19, Y+13	; 0x0d
    3862:	82 0f       	add	r24, r18
    3864:	93 1f       	adc	r25, r19
    3866:	29 85       	ldd	r18, Y+9	; 0x09
    3868:	fc 01       	movw	r30, r24
    386a:	20 83       	st	Z, r18
			bytesRecieved++;
    386c:	89 81       	ldd	r24, Y+1	; 0x01
    386e:	9a 81       	ldd	r25, Y+2	; 0x02
    3870:	01 96       	adiw	r24, 0x01	; 1
    3872:	9a 83       	std	Y+2, r25	; 0x02
    3874:	89 83       	std	Y+1, r24	; 0x01
	const int maxNumTries = 3;
	unsigned char data;
	int timeout;

	while(numTries < maxNumTries){
		while(bytesRecieved < size){
    3876:	29 81       	ldd	r18, Y+1	; 0x01
    3878:	3a 81       	ldd	r19, Y+2	; 0x02
    387a:	8a 85       	ldd	r24, Y+10	; 0x0a
    387c:	9b 85       	ldd	r25, Y+11	; 0x0b
    387e:	28 17       	cp	r18, r24
    3880:	39 07       	cpc	r19, r25
    3882:	5c f2       	brlt	.-106    	; 0x381a <recievePayload+0x30>
			data = UDR0;
			buffer[bytesRecieved] = data;
			bytesRecieved++;
		}
		
		timeout = 50;
    3884:	82 e3       	ldi	r24, 0x32	; 50
    3886:	90 e0       	ldi	r25, 0x00	; 0
    3888:	9e 83       	std	Y+6, r25	; 0x06
    388a:	8d 83       	std	Y+5, r24	; 0x05
		while ( !(UCSR0A & (1<<RXC0)) ){
    388c:	10 c0       	rjmp	.+32     	; 0x38ae <recievePayload+0xc4>
  			timeout--;
    388e:	8d 81       	ldd	r24, Y+5	; 0x05
    3890:	9e 81       	ldd	r25, Y+6	; 0x06
    3892:	01 97       	sbiw	r24, 0x01	; 1
    3894:	9e 83       	std	Y+6, r25	; 0x06
    3896:	8d 83       	std	Y+5, r24	; 0x05
     		if(timeout == 0){
    3898:	8d 81       	ldd	r24, Y+5	; 0x05
    389a:	9e 81       	ldd	r25, Y+6	; 0x06
    389c:	00 97       	sbiw	r24, 0x00	; 0
    389e:	19 f4       	brne	.+6      	; 0x38a6 <recievePayload+0xbc>
				return -1;
    38a0:	8f ef       	ldi	r24, 0xFF	; 255
    38a2:	9f ef       	ldi	r25, 0xFF	; 255
    38a4:	30 c0       	rjmp	.+96     	; 0x3906 <recievePayload+0x11c>
     		}
     		vTaskDelay(1);
    38a6:	81 e0       	ldi	r24, 0x01	; 1
    38a8:	90 e0       	ldi	r25, 0x00	; 0
    38aa:	0e 94 ab 04 	call	0x956	; 0x956 <vTaskDelay>
			buffer[bytesRecieved] = data;
			bytesRecieved++;
		}
		
		timeout = 50;
		while ( !(UCSR0A & (1<<RXC0)) ){
    38ae:	80 ec       	ldi	r24, 0xC0	; 192
    38b0:	90 e0       	ldi	r25, 0x00	; 0
    38b2:	fc 01       	movw	r30, r24
    38b4:	80 81       	ld	r24, Z
    38b6:	88 23       	and	r24, r24
    38b8:	54 f7       	brge	.-44     	; 0x388e <recievePayload+0xa4>
     		if(timeout == 0){
				return -1;
     		}
     		vTaskDelay(1);
   	}	
		data = UDR0;
    38ba:	86 ec       	ldi	r24, 0xC6	; 198
    38bc:	90 e0       	ldi	r25, 0x00	; 0
    38be:	fc 01       	movw	r30, r24
    38c0:	80 81       	ld	r24, Z
    38c2:	89 87       	std	Y+9, r24	; 0x09
		if(data != calcChecksum(buffer,size)){
    38c4:	2a 85       	ldd	r18, Y+10	; 0x0a
    38c6:	8c 85       	ldd	r24, Y+12	; 0x0c
    38c8:	9d 85       	ldd	r25, Y+13	; 0x0d
    38ca:	62 2f       	mov	r22, r18
    38cc:	0e 94 cc 1d 	call	0x3b98	; 0x3b98 <calcChecksum>
    38d0:	98 2f       	mov	r25, r24
    38d2:	89 85       	ldd	r24, Y+9	; 0x09
    38d4:	98 17       	cp	r25, r24
    38d6:	41 f0       	breq	.+16     	; 0x38e8 <recievePayload+0xfe>
			sendNACK();
    38d8:	0e 94 eb 1b 	call	0x37d6	; 0x37d6 <sendNACK>
			numTries++;
    38dc:	8b 81       	ldd	r24, Y+3	; 0x03
    38de:	9c 81       	ldd	r25, Y+4	; 0x04
    38e0:	01 96       	adiw	r24, 0x01	; 1
    38e2:	9c 83       	std	Y+4, r25	; 0x04
    38e4:	8b 83       	std	Y+3, r24	; 0x03
    38e6:	05 c0       	rjmp	.+10     	; 0x38f2 <recievePayload+0x108>
		} else {
			sendACK();
    38e8:	0e 94 e1 1b 	call	0x37c2	; 0x37c2 <sendACK>
			return 0;
    38ec:	80 e0       	ldi	r24, 0x00	; 0
    38ee:	90 e0       	ldi	r25, 0x00	; 0
    38f0:	0a c0       	rjmp	.+20     	; 0x3906 <recievePayload+0x11c>
	int numTries = 0;
	const int maxNumTries = 3;
	unsigned char data;
	int timeout;

	while(numTries < maxNumTries){
    38f2:	2b 81       	ldd	r18, Y+3	; 0x03
    38f4:	3c 81       	ldd	r19, Y+4	; 0x04
    38f6:	8f 81       	ldd	r24, Y+7	; 0x07
    38f8:	98 85       	ldd	r25, Y+8	; 0x08
    38fa:	28 17       	cp	r18, r24
    38fc:	39 07       	cpc	r19, r25
    38fe:	0c f4       	brge	.+2      	; 0x3902 <recievePayload+0x118>
    3900:	8b cf       	rjmp	.-234    	; 0x3818 <recievePayload+0x2e>
		} else {
			sendACK();
			return 0;
		}
	}
	return -1;
    3902:	8f ef       	ldi	r24, 0xFF	; 255
    3904:	9f ef       	ldi	r25, 0xFF	; 255
}
    3906:	2d 96       	adiw	r28, 0x0d	; 13
    3908:	0f b6       	in	r0, 0x3f	; 63
    390a:	f8 94       	cli
    390c:	de bf       	out	0x3e, r29	; 62
    390e:	0f be       	out	0x3f, r0	; 63
    3910:	cd bf       	out	0x3d, r28	; 61
    3912:	df 91       	pop	r29
    3914:	cf 91       	pop	r28
    3916:	08 95       	ret

00003918 <vTaskUSARTRead>:

void vTaskUSARTRead(void *pvParameters){
    3918:	cf 93       	push	r28
    391a:	df 93       	push	r29
    391c:	cd b7       	in	r28, 0x3d	; 61
    391e:	de b7       	in	r29, 0x3e	; 62
    3920:	cc 55       	subi	r28, 0x5C	; 92
    3922:	d1 09       	sbc	r29, r1
    3924:	0f b6       	in	r0, 0x3f	; 63
    3926:	f8 94       	cli
    3928:	de bf       	out	0x3e, r29	; 62
    392a:	0f be       	out	0x3f, r0	; 63
    392c:	cd bf       	out	0x3d, r28	; 61
    392e:	9e 01       	movw	r18, r28
    3930:	25 5a       	subi	r18, 0xA5	; 165
    3932:	3f 4f       	sbci	r19, 0xFF	; 255
    3934:	f9 01       	movw	r30, r18
    3936:	91 83       	std	Z+1, r25	; 0x01
    3938:	80 83       	st	Z, r24
    unsigned char size;
    char groupID;
    char cmd;
    unsigned int timeout;

	DDRB = 0xFF;
    393a:	84 e2       	ldi	r24, 0x24	; 36
    393c:	90 e0       	ldi	r25, 0x00	; 0
    393e:	2f ef       	ldi	r18, 0xFF	; 255
    3940:	fc 01       	movw	r30, r24
    3942:	20 83       	st	Z, r18

    Command command;
    Response response;
    while(1){
        bytesRecieved = 0;
    3944:	19 82       	std	Y+1, r1	; 0x01
        int timeout = 30;
    3946:	8e e1       	ldi	r24, 0x1E	; 30
    3948:	90 e0       	ldi	r25, 0x00	; 0
    394a:	9b 83       	std	Y+3, r25	; 0x03
    394c:	8a 83       	std	Y+2, r24	; 0x02
        while(bytesRecieved < 4){
    394e:	2d c0       	rjmp	.+90     	; 0x39aa <vTaskUSARTRead+0x92>
            
            while ( !(UCSR0A & (1<<RXC0)) ){
    3950:	12 c0       	rjmp	.+36     	; 0x3976 <vTaskUSARTRead+0x5e>
                timeout--;
    3952:	8a 81       	ldd	r24, Y+2	; 0x02
    3954:	9b 81       	ldd	r25, Y+3	; 0x03
    3956:	01 97       	sbiw	r24, 0x01	; 1
    3958:	9b 83       	std	Y+3, r25	; 0x03
    395a:	8a 83       	std	Y+2, r24	; 0x02
                if(timeout == 0){
    395c:	8a 81       	ldd	r24, Y+2	; 0x02
    395e:	9b 81       	ldd	r25, Y+3	; 0x03
    3960:	00 97       	sbiw	r24, 0x00	; 0
    3962:	29 f4       	brne	.+10     	; 0x396e <vTaskUSARTRead+0x56>
                    bytesRecieved = 0;
    3964:	19 82       	std	Y+1, r1	; 0x01
                    timeout = 30;
    3966:	8e e1       	ldi	r24, 0x1E	; 30
    3968:	90 e0       	ldi	r25, 0x00	; 0
    396a:	9b 83       	std	Y+3, r25	; 0x03
    396c:	8a 83       	std	Y+2, r24	; 0x02
                }
                vTaskDelay(1);
    396e:	81 e0       	ldi	r24, 0x01	; 1
    3970:	90 e0       	ldi	r25, 0x00	; 0
    3972:	0e 94 ab 04 	call	0x956	; 0x956 <vTaskDelay>
    while(1){
        bytesRecieved = 0;
        int timeout = 30;
        while(bytesRecieved < 4){
            
            while ( !(UCSR0A & (1<<RXC0)) ){
    3976:	80 ec       	ldi	r24, 0xC0	; 192
    3978:	90 e0       	ldi	r25, 0x00	; 0
    397a:	fc 01       	movw	r30, r24
    397c:	80 81       	ld	r24, Z
    397e:	88 23       	and	r24, r24
    3980:	44 f7       	brge	.-48     	; 0x3952 <vTaskUSARTRead+0x3a>
                    bytesRecieved = 0;
                    timeout = 30;
                }
                vTaskDelay(1);
            }
            data = UDR0;
    3982:	86 ec       	ldi	r24, 0xC6	; 198
    3984:	90 e0       	ldi	r25, 0x00	; 0
    3986:	fc 01       	movw	r30, r24
    3988:	80 81       	ld	r24, Z
    398a:	8c 83       	std	Y+4, r24	; 0x04
            buffer[bytesRecieved] = data;
    398c:	89 81       	ldd	r24, Y+1	; 0x01
    398e:	99 27       	eor	r25, r25
    3990:	87 fd       	sbrc	r24, 7
    3992:	90 95       	com	r25
    3994:	9e 01       	movw	r18, r28
    3996:	2a 5f       	subi	r18, 0xFA	; 250
    3998:	3f 4f       	sbci	r19, 0xFF	; 255
    399a:	82 0f       	add	r24, r18
    399c:	93 1f       	adc	r25, r19
    399e:	2c 81       	ldd	r18, Y+4	; 0x04
    39a0:	fc 01       	movw	r30, r24
    39a2:	20 83       	st	Z, r18
            bytesRecieved++;        
    39a4:	89 81       	ldd	r24, Y+1	; 0x01
    39a6:	8f 5f       	subi	r24, 0xFF	; 255
    39a8:	89 83       	std	Y+1, r24	; 0x01
    Command command;
    Response response;
    while(1){
        bytesRecieved = 0;
        int timeout = 30;
        while(bytesRecieved < 4){
    39aa:	89 81       	ldd	r24, Y+1	; 0x01
    39ac:	84 30       	cpi	r24, 0x04	; 4
    39ae:	84 f2       	brlt	.-96     	; 0x3950 <vTaskUSARTRead+0x38>
            data = UDR0;
            buffer[bytesRecieved] = data;
            bytesRecieved++;        
        }

        if(calcChecksum(buffer,3) != buffer[3]){
    39b0:	ce 01       	movw	r24, r28
    39b2:	06 96       	adiw	r24, 0x06	; 6
    39b4:	63 e0       	ldi	r22, 0x03	; 3
    39b6:	0e 94 cc 1d 	call	0x3b98	; 0x3b98 <calcChecksum>
    39ba:	98 2f       	mov	r25, r24
    39bc:	89 85       	ldd	r24, Y+9	; 0x09
    39be:	98 17       	cp	r25, r24
    39c0:	21 f0       	breq	.+8      	; 0x39ca <vTaskUSARTRead+0xb2>
            sendNACK();
    39c2:	0e 94 eb 1b 	call	0x37d6	; 0x37d6 <sendNACK>
            bytesRecieved = 0;
    39c6:	19 82       	std	Y+1, r1	; 0x01
    39c8:	29 c0       	rjmp	.+82     	; 0x3a1c <vTaskUSARTRead+0x104>
        } else {
            sendACK();
    39ca:	0e 94 e1 1b 	call	0x37c2	; 0x37c2 <sendACK>
            bytesRecieved = 0;
    39ce:	19 82       	std	Y+1, r1	; 0x01
				command.groupID = buffer[0];
    39d0:	8e 81       	ldd	r24, Y+6	; 0x06
    39d2:	8e 8b       	std	Y+22, r24	; 0x16
				command.cmd = buffer[1];
    39d4:	8f 81       	ldd	r24, Y+7	; 0x07
    39d6:	8f 8b       	std	Y+23, r24	; 0x17
				size = buffer[2];
    39d8:	88 85       	ldd	r24, Y+8	; 0x08
    39da:	8d 83       	std	Y+5, r24	; 0x05

				if(size > 0){ //No dynamic memory allocations. 16 is the size of the buffer
    39dc:	8d 81       	ldd	r24, Y+5	; 0x05
    39de:	88 23       	and	r24, r24
    39e0:	81 f0       	breq	.+32     	; 0x3a02 <vTaskUSARTRead+0xea>
					if(recievePayload(size,command.payload) == -1){
    39e2:	8d 81       	ldd	r24, Y+5	; 0x05
    39e4:	88 2f       	mov	r24, r24
    39e6:	90 e0       	ldi	r25, 0x00	; 0
    39e8:	9e 01       	movw	r18, r28
    39ea:	2a 5e       	subi	r18, 0xEA	; 234
    39ec:	3f 4f       	sbci	r19, 0xFF	; 255
    39ee:	2d 5f       	subi	r18, 0xFD	; 253
    39f0:	3f 4f       	sbci	r19, 0xFF	; 255
    39f2:	b9 01       	movw	r22, r18
    39f4:	0e 94 f5 1b 	call	0x37ea	; 0x37ea <recievePayload>
    39f8:	8f 3f       	cpi	r24, 0xFF	; 255
    39fa:	ff ef       	ldi	r31, 0xFF	; 255
    39fc:	9f 07       	cpc	r25, r31
    39fe:	09 f4       	brne	.+2      	; 0x3a02 <vTaskUSARTRead+0xea>
						continue;	//Restart comms
    3a00:	0d c0       	rjmp	.+26     	; 0x3a1c <vTaskUSARTRead+0x104>
					}
				}
				
 
            processCommand(&command,&response);
    3a02:	9e 01       	movw	r18, r28
    3a04:	27 5c       	subi	r18, 0xC7	; 199
    3a06:	3f 4f       	sbci	r19, 0xFF	; 255
    3a08:	ce 01       	movw	r24, r28
    3a0a:	46 96       	adiw	r24, 0x16	; 22
    3a0c:	b9 01       	movw	r22, r18
    3a0e:	0e 94 a3 1f 	call	0x3f46	; 0x3f46 <processCommand>
            sendResponse(&response);
    3a12:	ce 01       	movw	r24, r28
    3a14:	c9 96       	adiw	r24, 0x39	; 57
    3a16:	0e 94 0f 1d 	call	0x3a1e	; 0x3a1e <sendResponse>

        }

    }
    3a1a:	94 cf       	rjmp	.-216    	; 0x3944 <vTaskUSARTRead+0x2c>
    3a1c:	93 cf       	rjmp	.-218    	; 0x3944 <vTaskUSARTRead+0x2c>

00003a1e <sendResponse>:

}

int sendResponse(Response* response){
    3a1e:	cf 93       	push	r28
    3a20:	df 93       	push	r29
    3a22:	cd b7       	in	r28, 0x3d	; 61
    3a24:	de b7       	in	r29, 0x3e	; 62
    3a26:	28 97       	sbiw	r28, 0x08	; 8
    3a28:	0f b6       	in	r0, 0x3f	; 63
    3a2a:	f8 94       	cli
    3a2c:	de bf       	out	0x3e, r29	; 62
    3a2e:	0f be       	out	0x3f, r0	; 63
    3a30:	cd bf       	out	0x3d, r28	; 61
    3a32:	98 87       	std	Y+8, r25	; 0x08
    3a34:	8f 83       	std	Y+7, r24	; 0x07
    char checksumBuffer[2];
    int i;
    int timeout = 50;
    3a36:	82 e3       	ldi	r24, 0x32	; 50
    3a38:	90 e0       	ldi	r25, 0x00	; 0
    3a3a:	9c 83       	std	Y+4, r25	; 0x04
    3a3c:	8b 83       	std	Y+3, r24	; 0x03
    while(1){
        	USART_Write(response->commandBack);
    3a3e:	8f 81       	ldd	r24, Y+7	; 0x07
    3a40:	98 85       	ldd	r25, Y+8	; 0x08
    3a42:	fc 01       	movw	r30, r24
    3a44:	80 81       	ld	r24, Z
    3a46:	0e 94 8a 1a 	call	0x3514	; 0x3514 <USART_Write>
			vTaskDelay(1);
    3a4a:	81 e0       	ldi	r24, 0x01	; 1
    3a4c:	90 e0       	ldi	r25, 0x00	; 0
    3a4e:	0e 94 ab 04 	call	0x956	; 0x956 <vTaskDelay>
        	USART_Write(response->size);
    3a52:	8f 81       	ldd	r24, Y+7	; 0x07
    3a54:	98 85       	ldd	r25, Y+8	; 0x08
    3a56:	fc 01       	movw	r30, r24
    3a58:	81 81       	ldd	r24, Z+1	; 0x01
    3a5a:	0e 94 8a 1a 	call	0x3514	; 0x3514 <USART_Write>
			vTaskDelay(1);
    3a5e:	81 e0       	ldi	r24, 0x01	; 1
    3a60:	90 e0       	ldi	r25, 0x00	; 0
    3a62:	0e 94 ab 04 	call	0x956	; 0x956 <vTaskDelay>
        	checksumBuffer[0] = response->commandBack;
    3a66:	8f 81       	ldd	r24, Y+7	; 0x07
    3a68:	98 85       	ldd	r25, Y+8	; 0x08
    3a6a:	fc 01       	movw	r30, r24
    3a6c:	80 81       	ld	r24, Z
    3a6e:	8d 83       	std	Y+5, r24	; 0x05
        	checksumBuffer[1] = response->size;
    3a70:	8f 81       	ldd	r24, Y+7	; 0x07
    3a72:	98 85       	ldd	r25, Y+8	; 0x08
    3a74:	fc 01       	movw	r30, r24
    3a76:	81 81       	ldd	r24, Z+1	; 0x01
    3a78:	8e 83       	std	Y+6, r24	; 0x06
        	USART_Write(calcChecksum(checksumBuffer,2));
    3a7a:	ce 01       	movw	r24, r28
    3a7c:	05 96       	adiw	r24, 0x05	; 5
    3a7e:	62 e0       	ldi	r22, 0x02	; 2
    3a80:	0e 94 cc 1d 	call	0x3b98	; 0x3b98 <calcChecksum>
    3a84:	0e 94 8a 1a 	call	0x3514	; 0x3514 <USART_Write>
        	switch(waitForAck()){
    3a88:	0e 94 a2 1d 	call	0x3b44	; 0x3b44 <waitForAck>
    3a8c:	99 27       	eor	r25, r25
    3a8e:	87 fd       	sbrc	r24, 7
    3a90:	90 95       	com	r25
    3a92:	00 97       	sbiw	r24, 0x00	; 0
    3a94:	59 f0       	breq	.+22     	; 0x3aac <sendResponse+0x8e>
    3a96:	81 30       	cpi	r24, 0x01	; 1
    3a98:	91 05       	cpc	r25, r1
    3a9a:	a9 f0       	breq	.+42     	; 0x3ac6 <sendResponse+0xa8>
    3a9c:	8f 3f       	cpi	r24, 0xFF	; 255
    3a9e:	ff ef       	ldi	r31, 0xFF	; 255
    3aa0:	9f 07       	cpc	r25, r31
    3aa2:	09 f0       	breq	.+2      	; 0x3aa6 <sendResponse+0x88>
           	timeout--;
           	if(!timeout){
              	return -1;
           	}
        	}
    }
    3aa4:	cc cf       	rjmp	.-104    	; 0x3a3e <sendResponse+0x20>
        	USART_Write(calcChecksum(checksumBuffer,2));
        	switch(waitForAck()){
        	case 1:
           	goto outOfWhile;
        	case -1:
           	return -1;
    3aa6:	8f ef       	ldi	r24, 0xFF	; 255
    3aa8:	9f ef       	ldi	r25, 0xFF	; 255
    3aaa:	43 c0       	rjmp	.+134    	; 0x3b32 <sendResponse+0x114>
        	case 0:
           	timeout--;
    3aac:	8b 81       	ldd	r24, Y+3	; 0x03
    3aae:	9c 81       	ldd	r25, Y+4	; 0x04
    3ab0:	01 97       	sbiw	r24, 0x01	; 1
    3ab2:	9c 83       	std	Y+4, r25	; 0x04
    3ab4:	8b 83       	std	Y+3, r24	; 0x03
           	if(!timeout){
    3ab6:	8b 81       	ldd	r24, Y+3	; 0x03
    3ab8:	9c 81       	ldd	r25, Y+4	; 0x04
    3aba:	00 97       	sbiw	r24, 0x00	; 0
    3abc:	19 f4       	brne	.+6      	; 0x3ac4 <sendResponse+0xa6>
              	return -1;
    3abe:	8f ef       	ldi	r24, 0xFF	; 255
    3ac0:	9f ef       	ldi	r25, 0xFF	; 255
    3ac2:	37 c0       	rjmp	.+110    	; 0x3b32 <sendResponse+0x114>
           	}
        	}
    }
    3ac4:	bc cf       	rjmp	.-136    	; 0x3a3e <sendResponse+0x20>
        	checksumBuffer[0] = response->commandBack;
        	checksumBuffer[1] = response->size;
        	USART_Write(calcChecksum(checksumBuffer,2));
        	switch(waitForAck()){
        	case 1:
           	goto outOfWhile;
    3ac6:	00 00       	nop
    }

    outOfWhile:


    for(i=0;i<response->size;i++){
    3ac8:	1a 82       	std	Y+2, r1	; 0x02
    3aca:	19 82       	std	Y+1, r1	; 0x01
    3acc:	14 c0       	rjmp	.+40     	; 0x3af6 <sendResponse+0xd8>
        USART_Write(response->payload[i]);
    3ace:	2f 81       	ldd	r18, Y+7	; 0x07
    3ad0:	38 85       	ldd	r19, Y+8	; 0x08
    3ad2:	89 81       	ldd	r24, Y+1	; 0x01
    3ad4:	9a 81       	ldd	r25, Y+2	; 0x02
    3ad6:	82 0f       	add	r24, r18
    3ad8:	93 1f       	adc	r25, r19
    3ada:	02 96       	adiw	r24, 0x02	; 2
    3adc:	fc 01       	movw	r30, r24
    3ade:	80 81       	ld	r24, Z
    3ae0:	0e 94 8a 1a 	call	0x3514	; 0x3514 <USART_Write>
			vTaskDelay(1);
    3ae4:	81 e0       	ldi	r24, 0x01	; 1
    3ae6:	90 e0       	ldi	r25, 0x00	; 0
    3ae8:	0e 94 ab 04 	call	0x956	; 0x956 <vTaskDelay>
    }

    outOfWhile:


    for(i=0;i<response->size;i++){
    3aec:	89 81       	ldd	r24, Y+1	; 0x01
    3aee:	9a 81       	ldd	r25, Y+2	; 0x02
    3af0:	01 96       	adiw	r24, 0x01	; 1
    3af2:	9a 83       	std	Y+2, r25	; 0x02
    3af4:	89 83       	std	Y+1, r24	; 0x01
    3af6:	8f 81       	ldd	r24, Y+7	; 0x07
    3af8:	98 85       	ldd	r25, Y+8	; 0x08
    3afa:	fc 01       	movw	r30, r24
    3afc:	81 81       	ldd	r24, Z+1	; 0x01
    3afe:	28 2f       	mov	r18, r24
    3b00:	33 27       	eor	r19, r19
    3b02:	27 fd       	sbrc	r18, 7
    3b04:	30 95       	com	r19
    3b06:	89 81       	ldd	r24, Y+1	; 0x01
    3b08:	9a 81       	ldd	r25, Y+2	; 0x02
    3b0a:	82 17       	cp	r24, r18
    3b0c:	93 07       	cpc	r25, r19
    3b0e:	fc f2       	brlt	.-66     	; 0x3ace <sendResponse+0xb0>
        USART_Write(response->payload[i]);
			vTaskDelay(1);
		  //USART_AddToQueue(0x30 | (i + 2));
        //USART_AddToQueue()
    }
    USART_Write(calcChecksum((uint8_t*)response->payload,response->size));
    3b10:	8f 81       	ldd	r24, Y+7	; 0x07
    3b12:	98 85       	ldd	r25, Y+8	; 0x08
    3b14:	fc 01       	movw	r30, r24
    3b16:	81 81       	ldd	r24, Z+1	; 0x01
    3b18:	28 2f       	mov	r18, r24
    3b1a:	8f 81       	ldd	r24, Y+7	; 0x07
    3b1c:	98 85       	ldd	r25, Y+8	; 0x08
    3b1e:	02 96       	adiw	r24, 0x02	; 2
    3b20:	62 2f       	mov	r22, r18
    3b22:	0e 94 cc 1d 	call	0x3b98	; 0x3b98 <calcChecksum>
    3b26:	0e 94 8a 1a 	call	0x3514	; 0x3514 <USART_Write>
	 

    waitForAck();
    3b2a:	0e 94 a2 1d 	call	0x3b44	; 0x3b44 <waitForAck>

    return 0;
    3b2e:	80 e0       	ldi	r24, 0x00	; 0
    3b30:	90 e0       	ldi	r25, 0x00	; 0

}
    3b32:	28 96       	adiw	r28, 0x08	; 8
    3b34:	0f b6       	in	r0, 0x3f	; 63
    3b36:	f8 94       	cli
    3b38:	de bf       	out	0x3e, r29	; 62
    3b3a:	0f be       	out	0x3f, r0	; 63
    3b3c:	cd bf       	out	0x3d, r28	; 61
    3b3e:	df 91       	pop	r29
    3b40:	cf 91       	pop	r28
    3b42:	08 95       	ret

00003b44 <waitForAck>:

char waitForAck(){
    3b44:	cf 93       	push	r28
    3b46:	df 93       	push	r29
    3b48:	1f 92       	push	r1
    3b4a:	1f 92       	push	r1
    3b4c:	cd b7       	in	r28, 0x3d	; 61
    3b4e:	de b7       	in	r29, 0x3e	; 62
    int timeout = 5000;
    3b50:	88 e8       	ldi	r24, 0x88	; 136
    3b52:	93 e1       	ldi	r25, 0x13	; 19
    3b54:	9a 83       	std	Y+2, r25	; 0x02
    3b56:	89 83       	std	Y+1, r24	; 0x01
    while ( !(UCSR2A & (1<<RXC2)) ){
    3b58:	0b c0       	rjmp	.+22     	; 0x3b70 <waitForAck+0x2c>
        timeout--;
    3b5a:	89 81       	ldd	r24, Y+1	; 0x01
    3b5c:	9a 81       	ldd	r25, Y+2	; 0x02
    3b5e:	01 97       	sbiw	r24, 0x01	; 1
    3b60:	9a 83       	std	Y+2, r25	; 0x02
    3b62:	89 83       	std	Y+1, r24	; 0x01
        if(!timeout){
    3b64:	89 81       	ldd	r24, Y+1	; 0x01
    3b66:	9a 81       	ldd	r25, Y+2	; 0x02
    3b68:	00 97       	sbiw	r24, 0x00	; 0
    3b6a:	11 f4       	brne	.+4      	; 0x3b70 <waitForAck+0x2c>
            return -1;
    3b6c:	8f ef       	ldi	r24, 0xFF	; 255
    3b6e:	0f c0       	rjmp	.+30     	; 0x3b8e <waitForAck+0x4a>

}

char waitForAck(){
    int timeout = 5000;
    while ( !(UCSR2A & (1<<RXC2)) ){
    3b70:	80 ed       	ldi	r24, 0xD0	; 208
    3b72:	90 e0       	ldi	r25, 0x00	; 0
    3b74:	fc 01       	movw	r30, r24
    3b76:	80 81       	ld	r24, Z
    3b78:	88 23       	and	r24, r24
    3b7a:	7c f7       	brge	.-34     	; 0x3b5a <waitForAck+0x16>
        timeout--;
        if(!timeout){
            return -1;
        }
    }
    if(UDR2 == ACK_BYTE){
    3b7c:	86 ed       	ldi	r24, 0xD6	; 214
    3b7e:	90 e0       	ldi	r25, 0x00	; 0
    3b80:	fc 01       	movw	r30, r24
    3b82:	80 81       	ld	r24, Z
    3b84:	80 38       	cpi	r24, 0x80	; 128
    3b86:	11 f4       	brne	.+4      	; 0x3b8c <waitForAck+0x48>
        return 1;
    3b88:	81 e0       	ldi	r24, 0x01	; 1
    3b8a:	01 c0       	rjmp	.+2      	; 0x3b8e <waitForAck+0x4a>
    } else {
        return 0;
    3b8c:	80 e0       	ldi	r24, 0x00	; 0
    }
}
    3b8e:	0f 90       	pop	r0
    3b90:	0f 90       	pop	r0
    3b92:	df 91       	pop	r29
    3b94:	cf 91       	pop	r28
    3b96:	08 95       	ret

00003b98 <calcChecksum>:

uint8_t calcChecksum(uint8_t* buffer,uint8_t size){
    3b98:	cf 93       	push	r28
    3b9a:	df 93       	push	r29
    3b9c:	00 d0       	rcall	.+0      	; 0x3b9e <calcChecksum+0x6>
    3b9e:	00 d0       	rcall	.+0      	; 0x3ba0 <calcChecksum+0x8>
    3ba0:	cd b7       	in	r28, 0x3d	; 61
    3ba2:	de b7       	in	r29, 0x3e	; 62
    3ba4:	9d 83       	std	Y+5, r25	; 0x05
    3ba6:	8c 83       	std	Y+4, r24	; 0x04
    3ba8:	6e 83       	std	Y+6, r22	; 0x06
    uint8_t checksum = 0;
    3baa:	19 82       	std	Y+1, r1	; 0x01
    for(int i = 0; i < size; i++) {
    3bac:	1b 82       	std	Y+3, r1	; 0x03
    3bae:	1a 82       	std	Y+2, r1	; 0x02
    3bb0:	11 c0       	rjmp	.+34     	; 0x3bd4 <calcChecksum+0x3c>
        checksum += *(buffer++);
    3bb2:	8c 81       	ldd	r24, Y+4	; 0x04
    3bb4:	9d 81       	ldd	r25, Y+5	; 0x05
    3bb6:	9c 01       	movw	r18, r24
    3bb8:	2f 5f       	subi	r18, 0xFF	; 255
    3bba:	3f 4f       	sbci	r19, 0xFF	; 255
    3bbc:	3d 83       	std	Y+5, r19	; 0x05
    3bbe:	2c 83       	std	Y+4, r18	; 0x04
    3bc0:	fc 01       	movw	r30, r24
    3bc2:	80 81       	ld	r24, Z
    3bc4:	99 81       	ldd	r25, Y+1	; 0x01
    3bc6:	89 0f       	add	r24, r25
    3bc8:	89 83       	std	Y+1, r24	; 0x01
    }
}

uint8_t calcChecksum(uint8_t* buffer,uint8_t size){
    uint8_t checksum = 0;
    for(int i = 0; i < size; i++) {
    3bca:	8a 81       	ldd	r24, Y+2	; 0x02
    3bcc:	9b 81       	ldd	r25, Y+3	; 0x03
    3bce:	01 96       	adiw	r24, 0x01	; 1
    3bd0:	9b 83       	std	Y+3, r25	; 0x03
    3bd2:	8a 83       	std	Y+2, r24	; 0x02
    3bd4:	8e 81       	ldd	r24, Y+6	; 0x06
    3bd6:	28 2f       	mov	r18, r24
    3bd8:	30 e0       	ldi	r19, 0x00	; 0
    3bda:	8a 81       	ldd	r24, Y+2	; 0x02
    3bdc:	9b 81       	ldd	r25, Y+3	; 0x03
    3bde:	82 17       	cp	r24, r18
    3be0:	93 07       	cpc	r25, r19
    3be2:	3c f3       	brlt	.-50     	; 0x3bb2 <calcChecksum+0x1a>
        checksum += *(buffer++);
    }
    return checksum;
    3be4:	89 81       	ldd	r24, Y+1	; 0x01
}
    3be6:	26 96       	adiw	r28, 0x06	; 6
    3be8:	0f b6       	in	r0, 0x3f	; 63
    3bea:	f8 94       	cli
    3bec:	de bf       	out	0x3e, r29	; 62
    3bee:	0f be       	out	0x3f, r0	; 63
    3bf0:	cd bf       	out	0x3d, r28	; 61
    3bf2:	df 91       	pop	r29
    3bf4:	cf 91       	pop	r28
    3bf6:	08 95       	ret

00003bf8 <commandIntegCheck>:
#include "protocol.h"
#include "Components/Sonar/Sonar.h"


//function to CRC the command structure
char commandIntegCheck(Command *command) {
    3bf8:	cf 93       	push	r28
    3bfa:	df 93       	push	r29
    3bfc:	1f 92       	push	r1
    3bfe:	1f 92       	push	r1
    3c00:	cd b7       	in	r28, 0x3d	; 61
    3c02:	de b7       	in	r29, 0x3e	; 62
    3c04:	9a 83       	std	Y+2, r25	; 0x02
    3c06:	89 83       	std	Y+1, r24	; 0x01
   //CRC the command with 0x00 in place of the CRC
   //return success for now
   return 1;
    3c08:	81 e0       	ldi	r24, 0x01	; 1
}
    3c0a:	0f 90       	pop	r0
    3c0c:	0f 90       	pop	r0
    3c0e:	df 91       	pop	r29
    3c10:	cf 91       	pop	r28
    3c12:	08 95       	ret

00003c14 <processUltrasonicCommand>:

char processUltrasonicCommand(char commandCode, void* commandData,char* size, void* responseData) {
    3c14:	cf 93       	push	r28
    3c16:	df 93       	push	r29
    3c18:	cd b7       	in	r28, 0x3d	; 61
    3c1a:	de b7       	in	r29, 0x3e	; 62
    3c1c:	27 97       	sbiw	r28, 0x07	; 7
    3c1e:	0f b6       	in	r0, 0x3f	; 63
    3c20:	f8 94       	cli
    3c22:	de bf       	out	0x3e, r29	; 62
    3c24:	0f be       	out	0x3f, r0	; 63
    3c26:	cd bf       	out	0x3d, r28	; 61
    3c28:	89 83       	std	Y+1, r24	; 0x01
    3c2a:	7b 83       	std	Y+3, r23	; 0x03
    3c2c:	6a 83       	std	Y+2, r22	; 0x02
    3c2e:	5d 83       	std	Y+5, r21	; 0x05
    3c30:	4c 83       	std	Y+4, r20	; 0x04
    3c32:	3f 83       	std	Y+7, r19	; 0x07
    3c34:	2e 83       	std	Y+6, r18	; 0x06
   switch(commandCode) {
    3c36:	89 81       	ldd	r24, Y+1	; 0x01
    3c38:	99 27       	eor	r25, r25
    3c3a:	87 fd       	sbrc	r24, 7
    3c3c:	90 95       	com	r25
    3c3e:	82 30       	cpi	r24, 0x02	; 2
    3c40:	91 05       	cpc	r25, r1
    3c42:	81 f0       	breq	.+32     	; 0x3c64 <processUltrasonicCommand+0x50>
    3c44:	83 30       	cpi	r24, 0x03	; 3
    3c46:	91 05       	cpc	r25, r1
    3c48:	c1 f0       	breq	.+48     	; 0x3c7a <processUltrasonicCommand+0x66>
    3c4a:	81 30       	cpi	r24, 0x01	; 1
    3c4c:	91 05       	cpc	r25, r1
    3c4e:	01 f5       	brne	.+64     	; 0x3c90 <processUltrasonicCommand+0x7c>
      case GET_ALL_SENSORS:
         getAllSensors((int*) responseData);
    3c50:	8e 81       	ldd	r24, Y+6	; 0x06
    3c52:	9f 81       	ldd	r25, Y+7	; 0x07
    3c54:	0e 94 69 22 	call	0x44d2	; 0x44d2 <getAllSensors>
         *size = 12;
    3c58:	8c 81       	ldd	r24, Y+4	; 0x04
    3c5a:	9d 81       	ldd	r25, Y+5	; 0x05
    3c5c:	2c e0       	ldi	r18, 0x0C	; 12
    3c5e:	fc 01       	movw	r30, r24
    3c60:	20 83       	st	Z, r18
         break;
    3c62:	16 c0       	rjmp	.+44     	; 0x3c90 <processUltrasonicCommand+0x7c>
      case GET_CERTAIN_SENSORS:
         getCertainSensor(((char*)commandData)[0], (int*) responseData);
    3c64:	8a 81       	ldd	r24, Y+2	; 0x02
    3c66:	9b 81       	ldd	r25, Y+3	; 0x03
    3c68:	fc 01       	movw	r30, r24
    3c6a:	20 81       	ld	r18, Z
    3c6c:	8e 81       	ldd	r24, Y+6	; 0x06
    3c6e:	9f 81       	ldd	r25, Y+7	; 0x07
    3c70:	bc 01       	movw	r22, r24
    3c72:	82 2f       	mov	r24, r18
    3c74:	0e 94 94 22 	call	0x4528	; 0x4528 <getCertainSensor>
         break;
    3c78:	0b c0       	rjmp	.+22     	; 0x3c90 <processUltrasonicCommand+0x7c>
      case GET_SENSOR_GROUP:
         getSensorGroup(((char*)commandData)[0], (int*) responseData);
    3c7a:	8a 81       	ldd	r24, Y+2	; 0x02
    3c7c:	9b 81       	ldd	r25, Y+3	; 0x03
    3c7e:	fc 01       	movw	r30, r24
    3c80:	20 81       	ld	r18, Z
    3c82:	8e 81       	ldd	r24, Y+6	; 0x06
    3c84:	9f 81       	ldd	r25, Y+7	; 0x07
    3c86:	bc 01       	movw	r22, r24
    3c88:	82 2f       	mov	r24, r18
    3c8a:	0e 94 bf 22 	call	0x457e	; 0x457e <getSensorGroup>
         break;
    3c8e:	00 00       	nop
   }
   //return success for now...
   return 1;
    3c90:	81 e0       	ldi	r24, 0x01	; 1
}
    3c92:	27 96       	adiw	r28, 0x07	; 7
    3c94:	0f b6       	in	r0, 0x3f	; 63
    3c96:	f8 94       	cli
    3c98:	de bf       	out	0x3e, r29	; 62
    3c9a:	0f be       	out	0x3f, r0	; 63
    3c9c:	cd bf       	out	0x3d, r28	; 61
    3c9e:	df 91       	pop	r29
    3ca0:	cf 91       	pop	r28
    3ca2:	08 95       	ret

00003ca4 <processSpeedCommand>:

char processSpeedCommand(char commandCode, void* commandData, Response* responseData) {
    3ca4:	cf 93       	push	r28
    3ca6:	df 93       	push	r29
    3ca8:	00 d0       	rcall	.+0      	; 0x3caa <processSpeedCommand+0x6>
    3caa:	1f 92       	push	r1
    3cac:	1f 92       	push	r1
    3cae:	cd b7       	in	r28, 0x3d	; 61
    3cb0:	de b7       	in	r29, 0x3e	; 62
    3cb2:	89 83       	std	Y+1, r24	; 0x01
    3cb4:	7b 83       	std	Y+3, r23	; 0x03
    3cb6:	6a 83       	std	Y+2, r22	; 0x02
    3cb8:	5d 83       	std	Y+5, r21	; 0x05
    3cba:	4c 83       	std	Y+4, r20	; 0x04
   switch(commandCode) {
    3cbc:	89 81       	ldd	r24, Y+1	; 0x01
    3cbe:	99 27       	eor	r25, r25
    3cc0:	87 fd       	sbrc	r24, 7
    3cc2:	90 95       	com	r25
    3cc4:	00 97       	sbiw	r24, 0x00	; 0
    3cc6:	21 f0       	breq	.+8      	; 0x3cd0 <processSpeedCommand+0x2c>
    3cc8:	81 30       	cpi	r24, 0x01	; 1
    3cca:	91 05       	cpc	r25, r1
    3ccc:	31 f0       	breq	.+12     	; 0x3cda <processSpeedCommand+0x36>
    3cce:	13 c0       	rjmp	.+38     	; 0x3cf6 <processSpeedCommand+0x52>
      case GET_SPEED:
         getSpeed((char*) responseData);
    3cd0:	8c 81       	ldd	r24, Y+4	; 0x04
    3cd2:	9d 81       	ldd	r25, Y+5	; 0x05
    3cd4:	0e 94 67 23 	call	0x46ce	; 0x46ce <getSpeed>
         break;
    3cd8:	0e c0       	rjmp	.+28     	; 0x3cf6 <processSpeedCommand+0x52>
      case SET_SPEED:
			responseData->size = 0;
    3cda:	8c 81       	ldd	r24, Y+4	; 0x04
    3cdc:	9d 81       	ldd	r25, Y+5	; 0x05
    3cde:	fc 01       	movw	r30, r24
    3ce0:	11 82       	std	Z+1, r1	; 0x01
         setSpeed(((char*)commandData)[0]);
    3ce2:	8a 81       	ldd	r24, Y+2	; 0x02
    3ce4:	9b 81       	ldd	r25, Y+3	; 0x03
    3ce6:	fc 01       	movw	r30, r24
    3ce8:	80 81       	ld	r24, Z
    3cea:	99 27       	eor	r25, r25
    3cec:	87 fd       	sbrc	r24, 7
    3cee:	90 95       	com	r25
    3cf0:	0e 94 79 23 	call	0x46f2	; 0x46f2 <setSpeed>
         break;
    3cf4:	00 00       	nop
   }
   //return success for now
   return 1;
    3cf6:	81 e0       	ldi	r24, 0x01	; 1
}
    3cf8:	0f 90       	pop	r0
    3cfa:	0f 90       	pop	r0
    3cfc:	0f 90       	pop	r0
    3cfe:	0f 90       	pop	r0
    3d00:	0f 90       	pop	r0
    3d02:	df 91       	pop	r29
    3d04:	cf 91       	pop	r28
    3d06:	08 95       	ret

00003d08 <processSteeringCommand>:

char processSteeringCommand(char commandCode, void* commandData, void* responseData) {
    3d08:	cf 93       	push	r28
    3d0a:	df 93       	push	r29
    3d0c:	00 d0       	rcall	.+0      	; 0x3d0e <processSteeringCommand+0x6>
    3d0e:	1f 92       	push	r1
    3d10:	1f 92       	push	r1
    3d12:	cd b7       	in	r28, 0x3d	; 61
    3d14:	de b7       	in	r29, 0x3e	; 62
    3d16:	89 83       	std	Y+1, r24	; 0x01
    3d18:	7b 83       	std	Y+3, r23	; 0x03
    3d1a:	6a 83       	std	Y+2, r22	; 0x02
    3d1c:	5d 83       	std	Y+5, r21	; 0x05
    3d1e:	4c 83       	std	Y+4, r20	; 0x04
   switch(commandCode) {
    3d20:	89 81       	ldd	r24, Y+1	; 0x01
    3d22:	99 27       	eor	r25, r25
    3d24:	87 fd       	sbrc	r24, 7
    3d26:	90 95       	com	r25
    3d28:	82 30       	cpi	r24, 0x02	; 2
    3d2a:	91 05       	cpc	r25, r1
    3d2c:	f9 f0       	breq	.+62     	; 0x3d6c <processSteeringCommand+0x64>
    3d2e:	83 30       	cpi	r24, 0x03	; 3
    3d30:	91 05       	cpc	r25, r1
    3d32:	34 f4       	brge	.+12     	; 0x3d40 <processSteeringCommand+0x38>
    3d34:	00 97       	sbiw	r24, 0x00	; 0
    3d36:	59 f0       	breq	.+22     	; 0x3d4e <processSteeringCommand+0x46>
    3d38:	81 30       	cpi	r24, 0x01	; 1
    3d3a:	91 05       	cpc	r25, r1
    3d3c:	91 f0       	breq	.+36     	; 0x3d62 <processSteeringCommand+0x5a>
    3d3e:	4c c0       	rjmp	.+152    	; 0x3dd8 <processSteeringCommand+0xd0>
    3d40:	83 30       	cpi	r24, 0x03	; 3
    3d42:	91 05       	cpc	r25, r1
    3d44:	c1 f0       	breq	.+48     	; 0x3d76 <processSteeringCommand+0x6e>
    3d46:	84 30       	cpi	r24, 0x04	; 4
    3d48:	91 05       	cpc	r25, r1
    3d4a:	91 f1       	breq	.+100    	; 0x3db0 <processSteeringCommand+0xa8>
    3d4c:	45 c0       	rjmp	.+138    	; 0x3dd8 <processSteeringCommand+0xd0>
      case SET_ANGLE:
         setAngle(*((char*)commandData));
    3d4e:	8a 81       	ldd	r24, Y+2	; 0x02
    3d50:	9b 81       	ldd	r25, Y+3	; 0x03
    3d52:	fc 01       	movw	r30, r24
    3d54:	80 81       	ld	r24, Z
    3d56:	99 27       	eor	r25, r25
    3d58:	87 fd       	sbrc	r24, 7
    3d5a:	90 95       	com	r25
    3d5c:	0e 94 8a 23 	call	0x4714	; 0x4714 <setAngle>
         break;
    3d60:	3b c0       	rjmp	.+118    	; 0x3dd8 <processSteeringCommand+0xd0>
      case GET_ANGLE:
         getAngle((char*) responseData);
    3d62:	8c 81       	ldd	r24, Y+4	; 0x04
    3d64:	9d 81       	ldd	r25, Y+5	; 0x05
    3d66:	0e 94 95 23 	call	0x472a	; 0x472a <getAngle>
         break;
    3d6a:	36 c0       	rjmp	.+108    	; 0x3dd8 <processSteeringCommand+0xd0>
      case GET_DESIRED_ANGLE:
         getDesiredAngle((char*) responseData);
    3d6c:	8c 81       	ldd	r24, Y+4	; 0x04
    3d6e:	9d 81       	ldd	r25, Y+5	; 0x05
    3d70:	0e 94 a7 23 	call	0x474e	; 0x474e <getDesiredAngle>
         break;
    3d74:	31 c0       	rjmp	.+98     	; 0x3dd8 <processSteeringCommand+0xd0>
      case CHANGE_PID:
         changePID(((char*)commandData)[0], ((char*)commandData)[1], ((char*)commandData)[2]);
    3d76:	8a 81       	ldd	r24, Y+2	; 0x02
    3d78:	9b 81       	ldd	r25, Y+3	; 0x03
    3d7a:	02 96       	adiw	r24, 0x02	; 2
    3d7c:	fc 01       	movw	r30, r24
    3d7e:	80 81       	ld	r24, Z
    3d80:	48 2f       	mov	r20, r24
    3d82:	55 27       	eor	r21, r21
    3d84:	47 fd       	sbrc	r20, 7
    3d86:	50 95       	com	r21
    3d88:	8a 81       	ldd	r24, Y+2	; 0x02
    3d8a:	9b 81       	ldd	r25, Y+3	; 0x03
    3d8c:	01 96       	adiw	r24, 0x01	; 1
    3d8e:	fc 01       	movw	r30, r24
    3d90:	80 81       	ld	r24, Z
    3d92:	28 2f       	mov	r18, r24
    3d94:	33 27       	eor	r19, r19
    3d96:	27 fd       	sbrc	r18, 7
    3d98:	30 95       	com	r19
    3d9a:	8a 81       	ldd	r24, Y+2	; 0x02
    3d9c:	9b 81       	ldd	r25, Y+3	; 0x03
    3d9e:	fc 01       	movw	r30, r24
    3da0:	80 81       	ld	r24, Z
    3da2:	99 27       	eor	r25, r25
    3da4:	87 fd       	sbrc	r24, 7
    3da6:	90 95       	com	r25
    3da8:	b9 01       	movw	r22, r18
    3daa:	0e 94 b9 23 	call	0x4772	; 0x4772 <changePID>
         break;
    3dae:	14 c0       	rjmp	.+40     	; 0x3dd8 <processSteeringCommand+0xd0>
      case SET_LIMITS:
         setLimits(((char*)commandData)[0], ((char*)commandData)[1]);
    3db0:	8a 81       	ldd	r24, Y+2	; 0x02
    3db2:	9b 81       	ldd	r25, Y+3	; 0x03
    3db4:	01 96       	adiw	r24, 0x01	; 1
    3db6:	fc 01       	movw	r30, r24
    3db8:	80 81       	ld	r24, Z
    3dba:	28 2f       	mov	r18, r24
    3dbc:	33 27       	eor	r19, r19
    3dbe:	27 fd       	sbrc	r18, 7
    3dc0:	30 95       	com	r19
    3dc2:	8a 81       	ldd	r24, Y+2	; 0x02
    3dc4:	9b 81       	ldd	r25, Y+3	; 0x03
    3dc6:	fc 01       	movw	r30, r24
    3dc8:	80 81       	ld	r24, Z
    3dca:	99 27       	eor	r25, r25
    3dcc:	87 fd       	sbrc	r24, 7
    3dce:	90 95       	com	r25
    3dd0:	b9 01       	movw	r22, r18
    3dd2:	0e 94 c8 23 	call	0x4790	; 0x4790 <setLimits>
         break;
    3dd6:	00 00       	nop
   }
   //return success for now
   return 1;
    3dd8:	81 e0       	ldi	r24, 0x01	; 1
}
    3dda:	0f 90       	pop	r0
    3ddc:	0f 90       	pop	r0
    3dde:	0f 90       	pop	r0
    3de0:	0f 90       	pop	r0
    3de2:	0f 90       	pop	r0
    3de4:	df 91       	pop	r29
    3de6:	cf 91       	pop	r28
    3de8:	08 95       	ret

00003dea <processFNRCommand>:

char processFNRCommand(char commandCode, void* commandData, Response* responseData) {
    3dea:	cf 93       	push	r28
    3dec:	df 93       	push	r29
    3dee:	00 d0       	rcall	.+0      	; 0x3df0 <processFNRCommand+0x6>
    3df0:	1f 92       	push	r1
    3df2:	1f 92       	push	r1
    3df4:	cd b7       	in	r28, 0x3d	; 61
    3df6:	de b7       	in	r29, 0x3e	; 62
    3df8:	89 83       	std	Y+1, r24	; 0x01
    3dfa:	7b 83       	std	Y+3, r23	; 0x03
    3dfc:	6a 83       	std	Y+2, r22	; 0x02
    3dfe:	5d 83       	std	Y+5, r21	; 0x05
    3e00:	4c 83       	std	Y+4, r20	; 0x04
	responseData->size = 0;	
    3e02:	8c 81       	ldd	r24, Y+4	; 0x04
    3e04:	9d 81       	ldd	r25, Y+5	; 0x05
    3e06:	fc 01       	movw	r30, r24
    3e08:	11 82       	std	Z+1, r1	; 0x01
   switch(commandCode) {
    3e0a:	89 81       	ldd	r24, Y+1	; 0x01
    3e0c:	99 27       	eor	r25, r25
    3e0e:	87 fd       	sbrc	r24, 7
    3e10:	90 95       	com	r25
    3e12:	00 97       	sbiw	r24, 0x00	; 0
    3e14:	21 f0       	breq	.+8      	; 0x3e1e <processFNRCommand+0x34>
    3e16:	81 30       	cpi	r24, 0x01	; 1
    3e18:	91 05       	cpc	r25, r1
    3e1a:	59 f0       	breq	.+22     	; 0x3e32 <processFNRCommand+0x48>
    3e1c:	0f c0       	rjmp	.+30     	; 0x3e3c <processFNRCommand+0x52>
      case SET_FNR:
         setFNR(*((char*)commandData));
    3e1e:	8a 81       	ldd	r24, Y+2	; 0x02
    3e20:	9b 81       	ldd	r25, Y+3	; 0x03
    3e22:	fc 01       	movw	r30, r24
    3e24:	80 81       	ld	r24, Z
    3e26:	99 27       	eor	r25, r25
    3e28:	87 fd       	sbrc	r24, 7
    3e2a:	90 95       	com	r25
    3e2c:	0e 94 fd 20 	call	0x41fa	; 0x41fa <setFNR>
         break;
    3e30:	05 c0       	rjmp	.+10     	; 0x3e3c <processFNRCommand+0x52>
      case GET_FNR:
         getFNR((char*) responseData);
    3e32:	8c 81       	ldd	r24, Y+4	; 0x04
    3e34:	9d 81       	ldd	r25, Y+5	; 0x05
    3e36:	0e 94 19 21 	call	0x4232	; 0x4232 <getFNR>
         break;
    3e3a:	00 00       	nop
   }
}
    3e3c:	0f 90       	pop	r0
    3e3e:	0f 90       	pop	r0
    3e40:	0f 90       	pop	r0
    3e42:	0f 90       	pop	r0
    3e44:	0f 90       	pop	r0
    3e46:	df 91       	pop	r29
    3e48:	cf 91       	pop	r28
    3e4a:	08 95       	ret

00003e4c <processBrakeCommand>:

char processBrakeCommand(char commandCode, void* commandData, void* responseData) {
    3e4c:	cf 93       	push	r28
    3e4e:	df 93       	push	r29
    3e50:	00 d0       	rcall	.+0      	; 0x3e52 <processBrakeCommand+0x6>
    3e52:	1f 92       	push	r1
    3e54:	1f 92       	push	r1
    3e56:	cd b7       	in	r28, 0x3d	; 61
    3e58:	de b7       	in	r29, 0x3e	; 62
    3e5a:	89 83       	std	Y+1, r24	; 0x01
    3e5c:	7b 83       	std	Y+3, r23	; 0x03
    3e5e:	6a 83       	std	Y+2, r22	; 0x02
    3e60:	5d 83       	std	Y+5, r21	; 0x05
    3e62:	4c 83       	std	Y+4, r20	; 0x04
   switch(commandCode) {
    3e64:	89 81       	ldd	r24, Y+1	; 0x01
    3e66:	99 27       	eor	r25, r25
    3e68:	87 fd       	sbrc	r24, 7
    3e6a:	90 95       	com	r25
    3e6c:	00 97       	sbiw	r24, 0x00	; 0
    3e6e:	21 f0       	breq	.+8      	; 0x3e78 <processBrakeCommand+0x2c>
    3e70:	81 30       	cpi	r24, 0x01	; 1
    3e72:	91 05       	cpc	r25, r1
    3e74:	59 f0       	breq	.+22     	; 0x3e8c <processBrakeCommand+0x40>
    3e76:	0f c0       	rjmp	.+30     	; 0x3e96 <processBrakeCommand+0x4a>
      case SET_BRAKE:
	 setBrake(*((char*)commandData));
    3e78:	8a 81       	ldd	r24, Y+2	; 0x02
    3e7a:	9b 81       	ldd	r25, Y+3	; 0x03
    3e7c:	fc 01       	movw	r30, r24
    3e7e:	80 81       	ld	r24, Z
    3e80:	99 27       	eor	r25, r25
    3e82:	87 fd       	sbrc	r24, 7
    3e84:	90 95       	com	r25
    3e86:	0e 94 44 20 	call	0x4088	; 0x4088 <setBrake>
	 break;
    3e8a:	05 c0       	rjmp	.+10     	; 0x3e96 <processBrakeCommand+0x4a>
      case GET_BRAKE:
	 getBrake((char*) responseData);
    3e8c:	8c 81       	ldd	r24, Y+4	; 0x04
    3e8e:	9d 81       	ldd	r25, Y+5	; 0x05
    3e90:	0e 94 4f 20 	call	0x409e	; 0x409e <getBrake>
	 break; 
    3e94:	00 00       	nop
   }
}
    3e96:	0f 90       	pop	r0
    3e98:	0f 90       	pop	r0
    3e9a:	0f 90       	pop	r0
    3e9c:	0f 90       	pop	r0
    3e9e:	0f 90       	pop	r0
    3ea0:	df 91       	pop	r29
    3ea2:	cf 91       	pop	r28
    3ea4:	08 95       	ret

00003ea6 <processBatteryCommand>:

char processBatteryCommand(char commandCode, void* commandData, void* responseData) {
    3ea6:	cf 93       	push	r28
    3ea8:	df 93       	push	r29
    3eaa:	00 d0       	rcall	.+0      	; 0x3eac <processBatteryCommand+0x6>
    3eac:	1f 92       	push	r1
    3eae:	1f 92       	push	r1
    3eb0:	cd b7       	in	r28, 0x3d	; 61
    3eb2:	de b7       	in	r29, 0x3e	; 62
    3eb4:	89 83       	std	Y+1, r24	; 0x01
    3eb6:	7b 83       	std	Y+3, r23	; 0x03
    3eb8:	6a 83       	std	Y+2, r22	; 0x02
    3eba:	5d 83       	std	Y+5, r21	; 0x05
    3ebc:	4c 83       	std	Y+4, r20	; 0x04
   switch(commandCode) {
    3ebe:	89 81       	ldd	r24, Y+1	; 0x01
    3ec0:	99 27       	eor	r25, r25
    3ec2:	87 fd       	sbrc	r24, 7
    3ec4:	90 95       	com	r25
    3ec6:	00 97       	sbiw	r24, 0x00	; 0
    3ec8:	21 f0       	breq	.+8      	; 0x3ed2 <processBatteryCommand+0x2c>
    3eca:	81 30       	cpi	r24, 0x01	; 1
    3ecc:	91 05       	cpc	r25, r1
    3ece:	31 f0       	breq	.+12     	; 0x3edc <processBatteryCommand+0x36>
    3ed0:	0a c0       	rjmp	.+20     	; 0x3ee6 <processBatteryCommand+0x40>
      case GET_BATTERY_VOLTAGE:
         getBatteryVoltage((char*) responseData);
    3ed2:	8c 81       	ldd	r24, Y+4	; 0x04
    3ed4:	9d 81       	ldd	r25, Y+5	; 0x05
    3ed6:	0e 94 20 20 	call	0x4040	; 0x4040 <getBatteryVoltage>
         break;
    3eda:	05 c0       	rjmp	.+10     	; 0x3ee6 <processBatteryCommand+0x40>
      case GET_STEERING_VOLTAGE:
         getSteeringVoltage((char*) responseData);
    3edc:	8c 81       	ldd	r24, Y+4	; 0x04
    3ede:	9d 81       	ldd	r25, Y+5	; 0x05
    3ee0:	0e 94 32 20 	call	0x4064	; 0x4064 <getSteeringVoltage>
         break;
    3ee4:	00 00       	nop
   }
}
    3ee6:	0f 90       	pop	r0
    3ee8:	0f 90       	pop	r0
    3eea:	0f 90       	pop	r0
    3eec:	0f 90       	pop	r0
    3eee:	0f 90       	pop	r0
    3ef0:	df 91       	pop	r29
    3ef2:	cf 91       	pop	r28
    3ef4:	08 95       	ret

00003ef6 <processLightCommand>:

char processLightCommand(char commandCode, void* commandData, Response* responseData) {
    3ef6:	cf 93       	push	r28
    3ef8:	df 93       	push	r29
    3efa:	00 d0       	rcall	.+0      	; 0x3efc <processLightCommand+0x6>
    3efc:	1f 92       	push	r1
    3efe:	1f 92       	push	r1
    3f00:	cd b7       	in	r28, 0x3d	; 61
    3f02:	de b7       	in	r29, 0x3e	; 62
    3f04:	89 83       	std	Y+1, r24	; 0x01
    3f06:	7b 83       	std	Y+3, r23	; 0x03
    3f08:	6a 83       	std	Y+2, r22	; 0x02
    3f0a:	5d 83       	std	Y+5, r21	; 0x05
    3f0c:	4c 83       	std	Y+4, r20	; 0x04
	responseData->size = 0;
    3f0e:	8c 81       	ldd	r24, Y+4	; 0x04
    3f10:	9d 81       	ldd	r25, Y+5	; 0x05
    3f12:	fc 01       	movw	r30, r24
    3f14:	11 82       	std	Z+1, r1	; 0x01
   switch(commandCode) {
    3f16:	89 81       	ldd	r24, Y+1	; 0x01
    3f18:	99 27       	eor	r25, r25
    3f1a:	87 fd       	sbrc	r24, 7
    3f1c:	90 95       	com	r25
    3f1e:	00 97       	sbiw	r24, 0x00	; 0
    3f20:	51 f4       	brne	.+20     	; 0x3f36 <processLightCommand+0x40>
   case SET_LIGHT:
	 	setLight(*((char*)commandData));
    3f22:	8a 81       	ldd	r24, Y+2	; 0x02
    3f24:	9b 81       	ldd	r25, Y+3	; 0x03
    3f26:	fc 01       	movw	r30, r24
    3f28:	80 81       	ld	r24, Z
    3f2a:	99 27       	eor	r25, r25
    3f2c:	87 fd       	sbrc	r24, 7
    3f2e:	90 95       	com	r25
    3f30:	0e 94 2b 21 	call	0x4256	; 0x4256 <setLight>
      break;
    3f34:	00 00       	nop
   }
}
    3f36:	0f 90       	pop	r0
    3f38:	0f 90       	pop	r0
    3f3a:	0f 90       	pop	r0
    3f3c:	0f 90       	pop	r0
    3f3e:	0f 90       	pop	r0
    3f40:	df 91       	pop	r29
    3f42:	cf 91       	pop	r28
    3f44:	08 95       	ret

00003f46 <processCommand>:



//Function that will take in a command (as char array) and process it into a
//correct response to be stored into response
char processCommand(Command *command, Response *response) {
    3f46:	cf 93       	push	r28
    3f48:	df 93       	push	r29
    3f4a:	00 d0       	rcall	.+0      	; 0x3f4c <processCommand+0x6>
    3f4c:	1f 92       	push	r1
    3f4e:	cd b7       	in	r28, 0x3d	; 61
    3f50:	de b7       	in	r29, 0x3e	; 62
    3f52:	9a 83       	std	Y+2, r25	; 0x02
    3f54:	89 83       	std	Y+1, r24	; 0x01
    3f56:	7c 83       	std	Y+4, r23	; 0x04
    3f58:	6b 83       	std	Y+3, r22	; 0x03
	response->commandBack = command->cmd;
    3f5a:	89 81       	ldd	r24, Y+1	; 0x01
    3f5c:	9a 81       	ldd	r25, Y+2	; 0x02
    3f5e:	dc 01       	movw	r26, r24
    3f60:	11 96       	adiw	r26, 0x01	; 1
    3f62:	2c 91       	ld	r18, X
    3f64:	8b 81       	ldd	r24, Y+3	; 0x03
    3f66:	9c 81       	ldd	r25, Y+4	; 0x04
    3f68:	fc 01       	movw	r30, r24
    3f6a:	20 83       	st	Z, r18
   switch(command->groupID) {
    3f6c:	89 81       	ldd	r24, Y+1	; 0x01
    3f6e:	9a 81       	ldd	r25, Y+2	; 0x02
    3f70:	dc 01       	movw	r26, r24
    3f72:	8c 91       	ld	r24, X
    3f74:	99 27       	eor	r25, r25
    3f76:	87 fd       	sbrc	r24, 7
    3f78:	90 95       	com	r25
    3f7a:	aa 27       	eor	r26, r26
    3f7c:	97 fd       	sbrc	r25, 7
    3f7e:	a0 95       	com	r26
    3f80:	ba 2f       	mov	r27, r26
    3f82:	41 e0       	ldi	r20, 0x01	; 1
    3f84:	50 e0       	ldi	r21, 0x00	; 0
    3f86:	27 e0       	ldi	r18, 0x07	; 7
    3f88:	30 e0       	ldi	r19, 0x00	; 0
    3f8a:	84 1b       	sub	r24, r20
    3f8c:	95 0b       	sbc	r25, r21
    3f8e:	28 17       	cp	r18, r24
    3f90:	39 07       	cpc	r19, r25
    3f92:	08 f4       	brcc	.+2      	; 0x3f96 <processCommand+0x50>
    3f94:	4d c0       	rjmp	.+154    	; 0x4030 <processCommand+0xea>
    3f96:	8e 58       	subi	r24, 0x8E	; 142
    3f98:	9f 4f       	sbci	r25, 0xFF	; 255
    3f9a:	fc 01       	movw	r30, r24
    3f9c:	0c 94 1b 26 	jmp	0x4c36	; 0x4c36 <__tablejump2__>
      case ULTRASONIC_GROUP:
         processUltrasonicCommand(command->cmd, command->payload,&response->size, response->payload);
    3fa0:	8b 81       	ldd	r24, Y+3	; 0x03
    3fa2:	9c 81       	ldd	r25, Y+4	; 0x04
    3fa4:	9c 01       	movw	r18, r24
    3fa6:	2e 5f       	subi	r18, 0xFE	; 254
    3fa8:	3f 4f       	sbci	r19, 0xFF	; 255
    3faa:	8b 81       	ldd	r24, Y+3	; 0x03
    3fac:	9c 81       	ldd	r25, Y+4	; 0x04
    3fae:	ac 01       	movw	r20, r24
    3fb0:	4f 5f       	subi	r20, 0xFF	; 255
    3fb2:	5f 4f       	sbci	r21, 0xFF	; 255
    3fb4:	89 81       	ldd	r24, Y+1	; 0x01
    3fb6:	9a 81       	ldd	r25, Y+2	; 0x02
    3fb8:	03 96       	adiw	r24, 0x03	; 3
    3fba:	69 81       	ldd	r22, Y+1	; 0x01
    3fbc:	7a 81       	ldd	r23, Y+2	; 0x02
    3fbe:	db 01       	movw	r26, r22
    3fc0:	11 96       	adiw	r26, 0x01	; 1
    3fc2:	ec 91       	ld	r30, X
    3fc4:	bc 01       	movw	r22, r24
    3fc6:	8e 2f       	mov	r24, r30
    3fc8:	0e 94 0a 1e 	call	0x3c14	; 0x3c14 <processUltrasonicCommand>
         break;
    3fcc:	31 c0       	rjmp	.+98     	; 0x4030 <processCommand+0xea>
      case SPEED_GROUP:
			processSpeedCommand(command->cmd,command->payload,response);
    3fce:	89 81       	ldd	r24, Y+1	; 0x01
    3fd0:	9a 81       	ldd	r25, Y+2	; 0x02
    3fd2:	03 96       	adiw	r24, 0x03	; 3
    3fd4:	29 81       	ldd	r18, Y+1	; 0x01
    3fd6:	3a 81       	ldd	r19, Y+2	; 0x02
    3fd8:	d9 01       	movw	r26, r18
    3fda:	11 96       	adiw	r26, 0x01	; 1
    3fdc:	ec 91       	ld	r30, X
    3fde:	2b 81       	ldd	r18, Y+3	; 0x03
    3fe0:	3c 81       	ldd	r19, Y+4	; 0x04
    3fe2:	a9 01       	movw	r20, r18
    3fe4:	bc 01       	movw	r22, r24
    3fe6:	8e 2f       	mov	r24, r30
    3fe8:	0e 94 52 1e 	call	0x3ca4	; 0x3ca4 <processSpeedCommand>
         break;
    3fec:	21 c0       	rjmp	.+66     	; 0x4030 <processCommand+0xea>
      case STEERING_GROUP:
         /*do steering things*/
         break;
      case FNR_GROUP:
			processFNRCommand(command->cmd,command->payload,response);
    3fee:	89 81       	ldd	r24, Y+1	; 0x01
    3ff0:	9a 81       	ldd	r25, Y+2	; 0x02
    3ff2:	03 96       	adiw	r24, 0x03	; 3
    3ff4:	29 81       	ldd	r18, Y+1	; 0x01
    3ff6:	3a 81       	ldd	r19, Y+2	; 0x02
    3ff8:	d9 01       	movw	r26, r18
    3ffa:	11 96       	adiw	r26, 0x01	; 1
    3ffc:	ec 91       	ld	r30, X
    3ffe:	2b 81       	ldd	r18, Y+3	; 0x03
    4000:	3c 81       	ldd	r19, Y+4	; 0x04
    4002:	a9 01       	movw	r20, r18
    4004:	bc 01       	movw	r22, r24
    4006:	8e 2f       	mov	r24, r30
    4008:	0e 94 f5 1e 	call	0x3dea	; 0x3dea <processFNRCommand>
         break;
    400c:	11 c0       	rjmp	.+34     	; 0x4030 <processCommand+0xea>
         break;
      case BATTERY_GROUP:
         /*do battery things*/
         break;
      case LIGHTS_GROUP:
	      processLightCommand(command->cmd,command->payload,response);
    400e:	89 81       	ldd	r24, Y+1	; 0x01
    4010:	9a 81       	ldd	r25, Y+2	; 0x02
    4012:	03 96       	adiw	r24, 0x03	; 3
    4014:	29 81       	ldd	r18, Y+1	; 0x01
    4016:	3a 81       	ldd	r19, Y+2	; 0x02
    4018:	d9 01       	movw	r26, r18
    401a:	11 96       	adiw	r26, 0x01	; 1
    401c:	ec 91       	ld	r30, X
    401e:	2b 81       	ldd	r18, Y+3	; 0x03
    4020:	3c 81       	ldd	r19, Y+4	; 0x04
    4022:	a9 01       	movw	r20, r18
    4024:	bc 01       	movw	r22, r24
    4026:	8e 2f       	mov	r24, r30
    4028:	0e 94 7b 1f 	call	0x3ef6	; 0x3ef6 <processLightCommand>
         break;
    402c:	01 c0       	rjmp	.+2      	; 0x4030 <processCommand+0xea>
      case ERROR_GROUP:
         /*do error things*/
         break;
    402e:	00 00       	nop
   }
   //return a dummy success for now
   return 1;
    4030:	81 e0       	ldi	r24, 0x01	; 1
}
    4032:	0f 90       	pop	r0
    4034:	0f 90       	pop	r0
    4036:	0f 90       	pop	r0
    4038:	0f 90       	pop	r0
    403a:	df 91       	pop	r29
    403c:	cf 91       	pop	r28
    403e:	08 95       	ret

00004040 <getBatteryVoltage>:

//battery controller functions

//read battery strength in a char. Might need to be unsigned, specs don't say
//anything regarding that.
char getBatteryVoltage(char *sensorResponse) {
    4040:	cf 93       	push	r28
    4042:	df 93       	push	r29
    4044:	1f 92       	push	r1
    4046:	1f 92       	push	r1
    4048:	cd b7       	in	r28, 0x3d	; 61
    404a:	de b7       	in	r29, 0x3e	; 62
    404c:	9a 83       	std	Y+2, r25	; 0x02
    404e:	89 83       	std	Y+1, r24	; 0x01
   //fake battery reading
   *sensorResponse = 0;
    4050:	89 81       	ldd	r24, Y+1	; 0x01
    4052:	9a 81       	ldd	r25, Y+2	; 0x02
    4054:	fc 01       	movw	r30, r24
    4056:	10 82       	st	Z, r1
   //return success
   return 1;
    4058:	81 e0       	ldi	r24, 0x01	; 1
}
    405a:	0f 90       	pop	r0
    405c:	0f 90       	pop	r0
    405e:	df 91       	pop	r29
    4060:	cf 91       	pop	r28
    4062:	08 95       	ret

00004064 <getSteeringVoltage>:

//gets voltage from steering?
char getSteeringVoltage(char *sensorResponse) {
    4064:	cf 93       	push	r28
    4066:	df 93       	push	r29
    4068:	1f 92       	push	r1
    406a:	1f 92       	push	r1
    406c:	cd b7       	in	r28, 0x3d	; 61
    406e:	de b7       	in	r29, 0x3e	; 62
    4070:	9a 83       	std	Y+2, r25	; 0x02
    4072:	89 83       	std	Y+1, r24	; 0x01
   //fake steering voltage reading
   *sensorResponse = 0;
    4074:	89 81       	ldd	r24, Y+1	; 0x01
    4076:	9a 81       	ldd	r25, Y+2	; 0x02
    4078:	fc 01       	movw	r30, r24
    407a:	10 82       	st	Z, r1
   //return success
   return 1;
    407c:	81 e0       	ldi	r24, 0x01	; 1
}
    407e:	0f 90       	pop	r0
    4080:	0f 90       	pop	r0
    4082:	df 91       	pop	r29
    4084:	cf 91       	pop	r28
    4086:	08 95       	ret

00004088 <setBrake>:
//Brake controller functions. THERE IS CURRENTLY NO WAY TO GET THE DESIRED
//BRAKE TARGET IN THE SPECS

//set brake target
char setBrake(char gainTarget) {
    4088:	cf 93       	push	r28
    408a:	df 93       	push	r29
    408c:	1f 92       	push	r1
    408e:	cd b7       	in	r28, 0x3d	; 61
    4090:	de b7       	in	r29, 0x3e	; 62
    4092:	89 83       	std	Y+1, r24	; 0x01
   //dummy function, nothing happens
   //return success
   return 1;
    4094:	81 e0       	ldi	r24, 0x01	; 1
}
    4096:	0f 90       	pop	r0
    4098:	df 91       	pop	r29
    409a:	cf 91       	pop	r28
    409c:	08 95       	ret

0000409e <getBrake>:

//get what is assumed to be the current brake value?
char getBrake(char* sensorResponse) {
    409e:	cf 93       	push	r28
    40a0:	df 93       	push	r29
    40a2:	1f 92       	push	r1
    40a4:	1f 92       	push	r1
    40a6:	cd b7       	in	r28, 0x3d	; 61
    40a8:	de b7       	in	r29, 0x3e	; 62
    40aa:	9a 83       	std	Y+2, r25	; 0x02
    40ac:	89 83       	std	Y+1, r24	; 0x01
   //fake brake reading
   *sensorResponse = 0;
    40ae:	89 81       	ldd	r24, Y+1	; 0x01
    40b0:	9a 81       	ldd	r25, Y+2	; 0x02
    40b2:	fc 01       	movw	r30, r24
    40b4:	10 82       	st	Z, r1
   //return success
   return 1;
    40b6:	81 e0       	ldi	r24, 0x01	; 1
}
    40b8:	0f 90       	pop	r0
    40ba:	0f 90       	pop	r0
    40bc:	df 91       	pop	r29
    40be:	cf 91       	pop	r28
    40c0:	08 95       	ret

000040c2 <FNRForward>:

#define clearABit(x) \
PORTA &= ~(1 << (x));


void FNRForward(){
    40c2:	cf 93       	push	r28
    40c4:	df 93       	push	r29
    40c6:	cd b7       	in	r28, 0x3d	; 61
    40c8:	de b7       	in	r29, 0x3e	; 62
	clearABit(1);
    40ca:	82 e2       	ldi	r24, 0x22	; 34
    40cc:	90 e0       	ldi	r25, 0x00	; 0
    40ce:	22 e2       	ldi	r18, 0x22	; 34
    40d0:	30 e0       	ldi	r19, 0x00	; 0
    40d2:	f9 01       	movw	r30, r18
    40d4:	20 81       	ld	r18, Z
    40d6:	2d 7f       	andi	r18, 0xFD	; 253
    40d8:	fc 01       	movw	r30, r24
    40da:	20 83       	st	Z, r18
	while((PORTA & 0x2) != 0){
    40dc:	0d c0       	rjmp	.+26     	; 0x40f8 <FNRForward+0x36>
		clearABit(1);
    40de:	82 e2       	ldi	r24, 0x22	; 34
    40e0:	90 e0       	ldi	r25, 0x00	; 0
    40e2:	22 e2       	ldi	r18, 0x22	; 34
    40e4:	30 e0       	ldi	r19, 0x00	; 0
    40e6:	f9 01       	movw	r30, r18
    40e8:	20 81       	ld	r18, Z
    40ea:	2d 7f       	andi	r18, 0xFD	; 253
    40ec:	fc 01       	movw	r30, r24
    40ee:	20 83       	st	Z, r18
		vTaskDelay(1);
    40f0:	81 e0       	ldi	r24, 0x01	; 1
    40f2:	90 e0       	ldi	r25, 0x00	; 0
    40f4:	0e 94 ab 04 	call	0x956	; 0x956 <vTaskDelay>
PORTA &= ~(1 << (x));


void FNRForward(){
	clearABit(1);
	while((PORTA & 0x2) != 0){
    40f8:	82 e2       	ldi	r24, 0x22	; 34
    40fa:	90 e0       	ldi	r25, 0x00	; 0
    40fc:	fc 01       	movw	r30, r24
    40fe:	80 81       	ld	r24, Z
    4100:	88 2f       	mov	r24, r24
    4102:	90 e0       	ldi	r25, 0x00	; 0
    4104:	82 70       	andi	r24, 0x02	; 2
    4106:	99 27       	eor	r25, r25
    4108:	00 97       	sbiw	r24, 0x00	; 0
    410a:	49 f7       	brne	.-46     	; 0x40de <FNRForward+0x1c>
		clearABit(1);
		vTaskDelay(1);
	}
	setABit(0);
    410c:	82 e2       	ldi	r24, 0x22	; 34
    410e:	90 e0       	ldi	r25, 0x00	; 0
    4110:	22 e2       	ldi	r18, 0x22	; 34
    4112:	30 e0       	ldi	r19, 0x00	; 0
    4114:	f9 01       	movw	r30, r18
    4116:	20 81       	ld	r18, Z
    4118:	21 60       	ori	r18, 0x01	; 1
    411a:	fc 01       	movw	r30, r24
    411c:	20 83       	st	Z, r18
}
    411e:	df 91       	pop	r29
    4120:	cf 91       	pop	r28
    4122:	08 95       	ret

00004124 <FNRReverse>:

void FNRReverse(){
    4124:	cf 93       	push	r28
    4126:	df 93       	push	r29
    4128:	cd b7       	in	r28, 0x3d	; 61
    412a:	de b7       	in	r29, 0x3e	; 62
	clearABit(0);
    412c:	82 e2       	ldi	r24, 0x22	; 34
    412e:	90 e0       	ldi	r25, 0x00	; 0
    4130:	22 e2       	ldi	r18, 0x22	; 34
    4132:	30 e0       	ldi	r19, 0x00	; 0
    4134:	f9 01       	movw	r30, r18
    4136:	20 81       	ld	r18, Z
    4138:	2e 7f       	andi	r18, 0xFE	; 254
    413a:	fc 01       	movw	r30, r24
    413c:	20 83       	st	Z, r18
	while((PORTA & 0x1) != 0){
    413e:	0d c0       	rjmp	.+26     	; 0x415a <FNRReverse+0x36>
		clearABit(0);
    4140:	82 e2       	ldi	r24, 0x22	; 34
    4142:	90 e0       	ldi	r25, 0x00	; 0
    4144:	22 e2       	ldi	r18, 0x22	; 34
    4146:	30 e0       	ldi	r19, 0x00	; 0
    4148:	f9 01       	movw	r30, r18
    414a:	20 81       	ld	r18, Z
    414c:	2e 7f       	andi	r18, 0xFE	; 254
    414e:	fc 01       	movw	r30, r24
    4150:	20 83       	st	Z, r18
		vTaskDelay(1);
    4152:	81 e0       	ldi	r24, 0x01	; 1
    4154:	90 e0       	ldi	r25, 0x00	; 0
    4156:	0e 94 ab 04 	call	0x956	; 0x956 <vTaskDelay>
	setABit(0);
}

void FNRReverse(){
	clearABit(0);
	while((PORTA & 0x1) != 0){
    415a:	82 e2       	ldi	r24, 0x22	; 34
    415c:	90 e0       	ldi	r25, 0x00	; 0
    415e:	fc 01       	movw	r30, r24
    4160:	80 81       	ld	r24, Z
    4162:	88 2f       	mov	r24, r24
    4164:	90 e0       	ldi	r25, 0x00	; 0
    4166:	81 70       	andi	r24, 0x01	; 1
    4168:	99 27       	eor	r25, r25
    416a:	00 97       	sbiw	r24, 0x00	; 0
    416c:	49 f7       	brne	.-46     	; 0x4140 <FNRReverse+0x1c>
		clearABit(0);
		vTaskDelay(1);
	}
	setABit(1);
    416e:	82 e2       	ldi	r24, 0x22	; 34
    4170:	90 e0       	ldi	r25, 0x00	; 0
    4172:	22 e2       	ldi	r18, 0x22	; 34
    4174:	30 e0       	ldi	r19, 0x00	; 0
    4176:	f9 01       	movw	r30, r18
    4178:	20 81       	ld	r18, Z
    417a:	22 60       	ori	r18, 0x02	; 2
    417c:	fc 01       	movw	r30, r24
    417e:	20 83       	st	Z, r18
}
    4180:	df 91       	pop	r29
    4182:	cf 91       	pop	r28
    4184:	08 95       	ret

00004186 <FNRNeutral>:

void FNRNeutral(){
    4186:	cf 93       	push	r28
    4188:	df 93       	push	r29
    418a:	cd b7       	in	r28, 0x3d	; 61
    418c:	de b7       	in	r29, 0x3e	; 62
	clearABit(0);
    418e:	82 e2       	ldi	r24, 0x22	; 34
    4190:	90 e0       	ldi	r25, 0x00	; 0
    4192:	22 e2       	ldi	r18, 0x22	; 34
    4194:	30 e0       	ldi	r19, 0x00	; 0
    4196:	f9 01       	movw	r30, r18
    4198:	20 81       	ld	r18, Z
    419a:	2e 7f       	andi	r18, 0xFE	; 254
    419c:	fc 01       	movw	r30, r24
    419e:	20 83       	st	Z, r18
	clearABit(1);
    41a0:	82 e2       	ldi	r24, 0x22	; 34
    41a2:	90 e0       	ldi	r25, 0x00	; 0
    41a4:	22 e2       	ldi	r18, 0x22	; 34
    41a6:	30 e0       	ldi	r19, 0x00	; 0
    41a8:	f9 01       	movw	r30, r18
    41aa:	20 81       	ld	r18, Z
    41ac:	2d 7f       	andi	r18, 0xFD	; 253
    41ae:	fc 01       	movw	r30, r24
    41b0:	20 83       	st	Z, r18
	while((PORTA & 0x3) != 0){
    41b2:	16 c0       	rjmp	.+44     	; 0x41e0 <FNRNeutral+0x5a>
		clearABit(0);
    41b4:	82 e2       	ldi	r24, 0x22	; 34
    41b6:	90 e0       	ldi	r25, 0x00	; 0
    41b8:	22 e2       	ldi	r18, 0x22	; 34
    41ba:	30 e0       	ldi	r19, 0x00	; 0
    41bc:	f9 01       	movw	r30, r18
    41be:	20 81       	ld	r18, Z
    41c0:	2e 7f       	andi	r18, 0xFE	; 254
    41c2:	fc 01       	movw	r30, r24
    41c4:	20 83       	st	Z, r18
		clearABit(1);
    41c6:	82 e2       	ldi	r24, 0x22	; 34
    41c8:	90 e0       	ldi	r25, 0x00	; 0
    41ca:	22 e2       	ldi	r18, 0x22	; 34
    41cc:	30 e0       	ldi	r19, 0x00	; 0
    41ce:	f9 01       	movw	r30, r18
    41d0:	20 81       	ld	r18, Z
    41d2:	2d 7f       	andi	r18, 0xFD	; 253
    41d4:	fc 01       	movw	r30, r24
    41d6:	20 83       	st	Z, r18
		vTaskDelay(1);
    41d8:	81 e0       	ldi	r24, 0x01	; 1
    41da:	90 e0       	ldi	r25, 0x00	; 0
    41dc:	0e 94 ab 04 	call	0x956	; 0x956 <vTaskDelay>
}

void FNRNeutral(){
	clearABit(0);
	clearABit(1);
	while((PORTA & 0x3) != 0){
    41e0:	82 e2       	ldi	r24, 0x22	; 34
    41e2:	90 e0       	ldi	r25, 0x00	; 0
    41e4:	fc 01       	movw	r30, r24
    41e6:	80 81       	ld	r24, Z
    41e8:	88 2f       	mov	r24, r24
    41ea:	90 e0       	ldi	r25, 0x00	; 0
    41ec:	83 70       	andi	r24, 0x03	; 3
    41ee:	99 27       	eor	r25, r25
    41f0:	00 97       	sbiw	r24, 0x00	; 0
    41f2:	01 f7       	brne	.-64     	; 0x41b4 <FNRNeutral+0x2e>
		clearABit(0);
		clearABit(1);
		vTaskDelay(1);
	}
}
    41f4:	df 91       	pop	r29
    41f6:	cf 91       	pop	r28
    41f8:	08 95       	ret

000041fa <setFNR>:

//set the FNR controller, inputs are either -1, 0, or 1.
char setFNR(char FNR) {
    41fa:	cf 93       	push	r28
    41fc:	df 93       	push	r29
    41fe:	1f 92       	push	r1
    4200:	cd b7       	in	r28, 0x3d	; 61
    4202:	de b7       	in	r29, 0x3e	; 62
    4204:	89 83       	std	Y+1, r24	; 0x01
   //dummy function, nothing happens
   //return success
	if(FNR == 0){
    4206:	89 81       	ldd	r24, Y+1	; 0x01
    4208:	88 23       	and	r24, r24
    420a:	19 f4       	brne	.+6      	; 0x4212 <setFNR+0x18>
		FNRNeutral();
    420c:	0e 94 c3 20 	call	0x4186	; 0x4186 <FNRNeutral>
    4210:	0b c0       	rjmp	.+22     	; 0x4228 <setFNR+0x2e>
	} else if(FNR == 1){
    4212:	89 81       	ldd	r24, Y+1	; 0x01
    4214:	81 30       	cpi	r24, 0x01	; 1
    4216:	19 f4       	brne	.+6      	; 0x421e <setFNR+0x24>
		FNRForward();
    4218:	0e 94 61 20 	call	0x40c2	; 0x40c2 <FNRForward>
    421c:	05 c0       	rjmp	.+10     	; 0x4228 <setFNR+0x2e>
	} else if(FNR == -1){
    421e:	89 81       	ldd	r24, Y+1	; 0x01
    4220:	8f 3f       	cpi	r24, 0xFF	; 255
    4222:	11 f4       	brne	.+4      	; 0x4228 <setFNR+0x2e>
		FNRReverse();
    4224:	0e 94 92 20 	call	0x4124	; 0x4124 <FNRReverse>
	}

   return 1;
    4228:	81 e0       	ldi	r24, 0x01	; 1
}
    422a:	0f 90       	pop	r0
    422c:	df 91       	pop	r29
    422e:	cf 91       	pop	r28
    4230:	08 95       	ret

00004232 <getFNR>:

//get the current FNR state. Function follows same format for consistancy
char getFNR(char *sensorResponse) {
    4232:	cf 93       	push	r28
    4234:	df 93       	push	r29
    4236:	1f 92       	push	r1
    4238:	1f 92       	push	r1
    423a:	cd b7       	in	r28, 0x3d	; 61
    423c:	de b7       	in	r29, 0x3e	; 62
    423e:	9a 83       	std	Y+2, r25	; 0x02
    4240:	89 83       	std	Y+1, r24	; 0x01
   //fake reading
   *sensorResponse = 0;
    4242:	89 81       	ldd	r24, Y+1	; 0x01
    4244:	9a 81       	ldd	r25, Y+2	; 0x02
    4246:	fc 01       	movw	r30, r24
    4248:	10 82       	st	Z, r1
   //return success
   return 1;
    424a:	81 e0       	ldi	r24, 0x01	; 1
}
    424c:	0f 90       	pop	r0
    424e:	0f 90       	pop	r0
    4250:	df 91       	pop	r29
    4252:	cf 91       	pop	r28
    4254:	08 95       	ret

00004256 <setLight>:
//light controller functions
#include <avr/io.h>

//turn lights on and off
char setLight(unsigned char lightTarget) {
    4256:	cf 93       	push	r28
    4258:	df 93       	push	r29
    425a:	1f 92       	push	r1
    425c:	cd b7       	in	r28, 0x3d	; 61
    425e:	de b7       	in	r29, 0x3e	; 62
    4260:	89 83       	std	Y+1, r24	; 0x01
   //dummy function, nothing happens
	//PORTB ^= 0x80;
	if(lightTarget == 1){
    4262:	89 81       	ldd	r24, Y+1	; 0x01
    4264:	81 30       	cpi	r24, 0x01	; 1
    4266:	51 f4       	brne	.+20     	; 0x427c <setLight+0x26>
		PORTB |= 0x80;
    4268:	85 e2       	ldi	r24, 0x25	; 37
    426a:	90 e0       	ldi	r25, 0x00	; 0
    426c:	25 e2       	ldi	r18, 0x25	; 37
    426e:	30 e0       	ldi	r19, 0x00	; 0
    4270:	f9 01       	movw	r30, r18
    4272:	20 81       	ld	r18, Z
    4274:	20 68       	ori	r18, 0x80	; 128
    4276:	fc 01       	movw	r30, r24
    4278:	20 83       	st	Z, r18
    427a:	09 c0       	rjmp	.+18     	; 0x428e <setLight+0x38>
	} else {
		PORTB &= ~0x80;
    427c:	85 e2       	ldi	r24, 0x25	; 37
    427e:	90 e0       	ldi	r25, 0x00	; 0
    4280:	25 e2       	ldi	r18, 0x25	; 37
    4282:	30 e0       	ldi	r19, 0x00	; 0
    4284:	f9 01       	movw	r30, r18
    4286:	20 81       	ld	r18, Z
    4288:	2f 77       	andi	r18, 0x7F	; 127
    428a:	fc 01       	movw	r30, r24
    428c:	20 83       	st	Z, r18
	}
   return 1;
    428e:	81 e0       	ldi	r24, 0x01	; 1
}
    4290:	0f 90       	pop	r0
    4292:	df 91       	pop	r29
    4294:	cf 91       	pop	r28
    4296:	08 95       	ret

00004298 <setSonarData>:
extern int count;

unsigned char currSonar;
unsigned char lastSonarData = 0;
   
void setSonarData(int i,unsigned char data){
    4298:	cf 93       	push	r28
    429a:	df 93       	push	r29
    429c:	00 d0       	rcall	.+0      	; 0x429e <setSonarData+0x6>
    429e:	cd b7       	in	r28, 0x3d	; 61
    42a0:	de b7       	in	r29, 0x3e	; 62
    42a2:	9a 83       	std	Y+2, r25	; 0x02
    42a4:	89 83       	std	Y+1, r24	; 0x01
    42a6:	6b 83       	std	Y+3, r22	; 0x03
// xSemaphoreTake(sonarDataMutex[i],portMAX_DELAY);
   sonarData[i] = data;
    42a8:	89 81       	ldd	r24, Y+1	; 0x01
    42aa:	9a 81       	ldd	r25, Y+2	; 0x02
    42ac:	8e 52       	subi	r24, 0x2E	; 46
    42ae:	95 4e       	sbci	r25, 0xE5	; 229
    42b0:	2b 81       	ldd	r18, Y+3	; 0x03
    42b2:	fc 01       	movw	r30, r24
    42b4:	20 83       	st	Z, r18
   //xSemaphoreGive(sonarDataMutex[i]);
}
    42b6:	0f 90       	pop	r0
    42b8:	0f 90       	pop	r0
    42ba:	0f 90       	pop	r0
    42bc:	df 91       	pop	r29
    42be:	cf 91       	pop	r28
    42c0:	08 95       	ret

000042c2 <getSonarData>:

unsigned char getSonarData(int i){
    42c2:	cf 93       	push	r28
    42c4:	df 93       	push	r29
    42c6:	1f 92       	push	r1
    42c8:	1f 92       	push	r1
    42ca:	cd b7       	in	r28, 0x3d	; 61
    42cc:	de b7       	in	r29, 0x3e	; 62
    42ce:	9a 83       	std	Y+2, r25	; 0x02
    42d0:	89 83       	std	Y+1, r24	; 0x01
   //xSemaphoreTake(sonarDataMutex[i],portMAX_DELAY);
   //return sonarData[i];
   return i + 2;
    42d2:	89 81       	ldd	r24, Y+1	; 0x01
    42d4:	8e 5f       	subi	r24, 0xFE	; 254
   //xSemaphoreGive(sonarDataMutex[i]);
}
    42d6:	0f 90       	pop	r0
    42d8:	0f 90       	pop	r0
    42da:	df 91       	pop	r29
    42dc:	cf 91       	pop	r28
    42de:	08 95       	ret

000042e0 <getTimerCount>:

unsigned char getTimerCount(){
    42e0:	cf 93       	push	r28
    42e2:	df 93       	push	r29
    42e4:	cd b7       	in	r28, 0x3d	; 61
    42e6:	de b7       	in	r29, 0x3e	; 62
   return TCNT0;
    42e8:	86 e4       	ldi	r24, 0x46	; 70
    42ea:	90 e0       	ldi	r25, 0x00	; 0
    42ec:	fc 01       	movw	r30, r24
    42ee:	80 81       	ld	r24, Z
}
    42f0:	df 91       	pop	r29
    42f2:	cf 91       	pop	r28
    42f4:	08 95       	ret

000042f6 <__vector_11>:

inline void setTimerCount(unsigned char i){
   TCNT0 = i;
}

ISR(PCINT2_vect) {
    42f6:	1f 92       	push	r1
    42f8:	0f 92       	push	r0
    42fa:	00 90 5f 00 	lds	r0, 0x005F
    42fe:	0f 92       	push	r0
    4300:	11 24       	eor	r1, r1
    4302:	00 90 5b 00 	lds	r0, 0x005B
    4306:	0f 92       	push	r0
    4308:	2f 93       	push	r18
    430a:	3f 93       	push	r19
    430c:	4f 93       	push	r20
    430e:	5f 93       	push	r21
    4310:	6f 93       	push	r22
    4312:	7f 93       	push	r23
    4314:	8f 93       	push	r24
    4316:	9f 93       	push	r25
    4318:	af 93       	push	r26
    431a:	bf 93       	push	r27
    431c:	ef 93       	push	r30
    431e:	ff 93       	push	r31
    4320:	cf 93       	push	r28
    4322:	df 93       	push	r29
    4324:	00 d0       	rcall	.+0      	; 0x4326 <__vector_11+0x30>
    4326:	cd b7       	in	r28, 0x3d	; 61
    4328:	de b7       	in	r29, 0x3e	; 62

   unsigned char beginCount;
   unsigned char currCount;
   char i=0;   
    432a:	19 82       	std	Y+1, r1	; 0x01

   if(PINK&(1<<currSonar)){
    432c:	86 e0       	ldi	r24, 0x06	; 6
    432e:	91 e0       	ldi	r25, 0x01	; 1
    4330:	fc 01       	movw	r30, r24
    4332:	80 81       	ld	r24, Z
    4334:	88 2f       	mov	r24, r24
    4336:	90 e0       	ldi	r25, 0x00	; 0
    4338:	20 91 e6 1a 	lds	r18, 0x1AE6
    433c:	22 2f       	mov	r18, r18
    433e:	30 e0       	ldi	r19, 0x00	; 0
    4340:	02 2e       	mov	r0, r18
    4342:	02 c0       	rjmp	.+4      	; 0x4348 <__vector_11+0x52>
    4344:	95 95       	asr	r25
    4346:	87 95       	ror	r24
    4348:	0a 94       	dec	r0
    434a:	e2 f7       	brpl	.-8      	; 0x4344 <__vector_11+0x4e>
    434c:	81 70       	andi	r24, 0x01	; 1
    434e:	99 27       	eor	r25, r25
    4350:	00 97       	sbiw	r24, 0x00	; 0
    4352:	49 f0       	breq	.+18     	; 0x4366 <__vector_11+0x70>
      //USART_AddToQueue('U');
      beginCount = getTimerCount();
    4354:	0e 94 70 21 	call	0x42e0	; 0x42e0 <getTimerCount>
    4358:	8a 83       	std	Y+2, r24	; 0x02
      PORTE = 0xFF;
    435a:	8e e2       	ldi	r24, 0x2E	; 46
    435c:	90 e0       	ldi	r25, 0x00	; 0
    435e:	2f ef       	ldi	r18, 0xFF	; 255
    4360:	fc 01       	movw	r30, r24
    4362:	20 83       	st	Z, r18
    4364:	1d c0       	rjmp	.+58     	; 0x43a0 <__vector_11+0xaa>
   } else {
      //USART_AddToQueue('D');
      currCount = getTimerCount();
    4366:	0e 94 70 21 	call	0x42e0	; 0x42e0 <getTimerCount>
    436a:	8b 83       	std	Y+3, r24	; 0x03
      if(currCount > beginCount){
    436c:	9b 81       	ldd	r25, Y+3	; 0x03
    436e:	8a 81       	ldd	r24, Y+2	; 0x02
    4370:	89 17       	cp	r24, r25
    4372:	38 f4       	brcc	.+14     	; 0x4382 <__vector_11+0x8c>
         lastSonarData = currCount - beginCount;
    4374:	9b 81       	ldd	r25, Y+3	; 0x03
    4376:	8a 81       	ldd	r24, Y+2	; 0x02
    4378:	f9 2f       	mov	r31, r25
    437a:	f8 1b       	sub	r31, r24
    437c:	8f 2f       	mov	r24, r31
    437e:	80 93 bf 1a 	sts	0x1ABF, r24
      }
      PORTE = 0;
    4382:	8e e2       	ldi	r24, 0x2E	; 46
    4384:	90 e0       	ldi	r25, 0x00	; 0
    4386:	fc 01       	movw	r30, r24
    4388:	10 82       	st	Z, r1
      xSemaphoreGiveFromISR(sonarSemaphore,0);
    438a:	80 91 d8 1a 	lds	r24, 0x1AD8
    438e:	90 91 d9 1a 	lds	r25, 0x1AD9
    4392:	20 e0       	ldi	r18, 0x00	; 0
    4394:	40 e0       	ldi	r20, 0x00	; 0
    4396:	50 e0       	ldi	r21, 0x00	; 0
    4398:	60 e0       	ldi	r22, 0x00	; 0
    439a:	70 e0       	ldi	r23, 0x00	; 0
    439c:	0e 94 7e 0e 	call	0x1cfc	; 0x1cfc <xQueueGenericSendFromISR>
   }

}
    43a0:	0f 90       	pop	r0
    43a2:	0f 90       	pop	r0
    43a4:	0f 90       	pop	r0
    43a6:	df 91       	pop	r29
    43a8:	cf 91       	pop	r28
    43aa:	ff 91       	pop	r31
    43ac:	ef 91       	pop	r30
    43ae:	bf 91       	pop	r27
    43b0:	af 91       	pop	r26
    43b2:	9f 91       	pop	r25
    43b4:	8f 91       	pop	r24
    43b6:	7f 91       	pop	r23
    43b8:	6f 91       	pop	r22
    43ba:	5f 91       	pop	r21
    43bc:	4f 91       	pop	r20
    43be:	3f 91       	pop	r19
    43c0:	2f 91       	pop	r18
    43c2:	0f 90       	pop	r0
    43c4:	00 92 5b 00 	sts	0x005B, r0
    43c8:	0f 90       	pop	r0
    43ca:	00 92 5f 00 	sts	0x005F, r0
    43ce:	0f 90       	pop	r0
    43d0:	1f 90       	pop	r1
    43d2:	18 95       	reti

000043d4 <initializeSonarSensors>:

void initializeSonarSensors(){
    43d4:	cf 93       	push	r28
    43d6:	df 93       	push	r29
    43d8:	cd b7       	in	r28, 0x3d	; 61
    43da:	de b7       	in	r29, 0x3e	; 62
   //DDRD &= 0xFE;   
   DIDR2 = 0;
    43dc:	8d e7       	ldi	r24, 0x7D	; 125
    43de:	90 e0       	ldi	r25, 0x00	; 0
    43e0:	fc 01       	movw	r30, r24
    43e2:	10 82       	st	Z, r1
   DDRK = 0;
    43e4:	87 e0       	ldi	r24, 0x07	; 7
    43e6:	91 e0       	ldi	r25, 0x01	; 1
    43e8:	fc 01       	movw	r30, r24
    43ea:	10 82       	st	Z, r1
   DDRC = 0;
    43ec:	87 e2       	ldi	r24, 0x27	; 39
    43ee:	90 e0       	ldi	r25, 0x00	; 0
    43f0:	fc 01       	movw	r30, r24
    43f2:	10 82       	st	Z, r1

   PORTC = 0;
    43f4:	88 e2       	ldi	r24, 0x28	; 40
    43f6:	90 e0       	ldi	r25, 0x00	; 0
    43f8:	fc 01       	movw	r30, r24
    43fa:	10 82       	st	Z, r1

   //EICRA = 1;
   //EIMSK = 1;

   PCMSK2 = 0xFF;
    43fc:	8d e6       	ldi	r24, 0x6D	; 109
    43fe:	90 e0       	ldi	r25, 0x00	; 0
    4400:	2f ef       	ldi	r18, 0xFF	; 255
    4402:	fc 01       	movw	r30, r24
    4404:	20 83       	st	Z, r18
   PCICR = 0x7;
    4406:	88 e6       	ldi	r24, 0x68	; 104
    4408:	90 e0       	ldi	r25, 0x00	; 0
    440a:	27 e0       	ldi	r18, 0x07	; 7
    440c:	fc 01       	movw	r30, r24
    440e:	20 83       	st	Z, r18

   TCCR0A = 0;
    4410:	84 e4       	ldi	r24, 0x44	; 68
    4412:	90 e0       	ldi	r25, 0x00	; 0
    4414:	fc 01       	movw	r30, r24
    4416:	10 82       	st	Z, r1
   TCCR0B = 5;
    4418:	85 e4       	ldi	r24, 0x45	; 69
    441a:	90 e0       	ldi	r25, 0x00	; 0
    441c:	25 e0       	ldi	r18, 0x05	; 5
    441e:	fc 01       	movw	r30, r24
    4420:	20 83       	st	Z, r18

}
    4422:	df 91       	pop	r29
    4424:	cf 91       	pop	r28
    4426:	08 95       	ret

00004428 <vTaskSonar>:

void vTaskSonar(void* parameter){
    4428:	cf 93       	push	r28
    442a:	df 93       	push	r29
    442c:	00 d0       	rcall	.+0      	; 0x442e <vTaskSonar+0x6>
    442e:	1f 92       	push	r1
    4430:	cd b7       	in	r28, 0x3d	; 61
    4432:	de b7       	in	r29, 0x3e	; 62
    4434:	9c 83       	std	Y+4, r25	; 0x04
    4436:	8b 83       	std	Y+3, r24	; 0x03

   int i;
   initializeSonarSensors();
    4438:	0e 94 ea 21 	call	0x43d4	; 0x43d4 <initializeSonarSensors>
   
   vSemaphoreCreateBinary(sonarSemaphore);
    443c:	43 e0       	ldi	r20, 0x03	; 3
    443e:	60 e0       	ldi	r22, 0x00	; 0
    4440:	81 e0       	ldi	r24, 0x01	; 1
    4442:	0e 94 23 0d 	call	0x1a46	; 0x1a46 <xQueueGenericCreate>
    4446:	90 93 d9 1a 	sts	0x1AD9, r25
    444a:	80 93 d8 1a 	sts	0x1AD8, r24
    444e:	80 91 d8 1a 	lds	r24, 0x1AD8
    4452:	90 91 d9 1a 	lds	r25, 0x1AD9
    4456:	00 97       	sbiw	r24, 0x00	; 0
    4458:	59 f0       	breq	.+22     	; 0x4470 <vTaskSonar+0x48>
    445a:	80 91 d8 1a 	lds	r24, 0x1AD8
    445e:	90 91 d9 1a 	lds	r25, 0x1AD9
    4462:	20 e0       	ldi	r18, 0x00	; 0
    4464:	40 e0       	ldi	r20, 0x00	; 0
    4466:	50 e0       	ldi	r21, 0x00	; 0
    4468:	60 e0       	ldi	r22, 0x00	; 0
    446a:	70 e0       	ldi	r23, 0x00	; 0
    446c:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <xQueueGenericSend>
      
   currSonar = 0;
    4470:	10 92 e6 1a 	sts	0x1AE6, r1

   while(1){
      for(i=0;i<2;i++){
    4474:	1a 82       	std	Y+2, r1	; 0x02
    4476:	19 82       	std	Y+1, r1	; 0x01
    4478:	26 c0       	rjmp	.+76     	; 0x44c6 <vTaskSonar+0x9e>
         currSonar = i;
    447a:	89 81       	ldd	r24, Y+1	; 0x01
    447c:	80 93 e6 1a 	sts	0x1AE6, r24
         PORTC = (1<<i);
    4480:	88 e2       	ldi	r24, 0x28	; 40
    4482:	90 e0       	ldi	r25, 0x00	; 0
    4484:	21 e0       	ldi	r18, 0x01	; 1
    4486:	30 e0       	ldi	r19, 0x00	; 0
    4488:	09 80       	ldd	r0, Y+1	; 0x01
    448a:	02 c0       	rjmp	.+4      	; 0x4490 <vTaskSonar+0x68>
    448c:	22 0f       	add	r18, r18
    448e:	33 1f       	adc	r19, r19
    4490:	0a 94       	dec	r0
    4492:	e2 f7       	brpl	.-8      	; 0x448c <vTaskSonar+0x64>
    4494:	fc 01       	movw	r30, r24
    4496:	20 83       	st	Z, r18
         xSemaphoreTake(sonarSemaphore,portMAX_DELAY);
    4498:	80 91 d8 1a 	lds	r24, 0x1AD8
    449c:	90 91 d9 1a 	lds	r25, 0x1AD9
    44a0:	20 e0       	ldi	r18, 0x00	; 0
    44a2:	4f ef       	ldi	r20, 0xFF	; 255
    44a4:	5f ef       	ldi	r21, 0xFF	; 255
    44a6:	60 e0       	ldi	r22, 0x00	; 0
    44a8:	70 e0       	ldi	r23, 0x00	; 0
    44aa:	0e 94 d7 0e 	call	0x1dae	; 0x1dae <xQueueGenericReceive>
         setSonarData(i,lastSonarData);
    44ae:	20 91 bf 1a 	lds	r18, 0x1ABF
    44b2:	89 81       	ldd	r24, Y+1	; 0x01
    44b4:	9a 81       	ldd	r25, Y+2	; 0x02
    44b6:	62 2f       	mov	r22, r18
    44b8:	0e 94 4c 21 	call	0x4298	; 0x4298 <setSonarData>
   vSemaphoreCreateBinary(sonarSemaphore);
      
   currSonar = 0;

   while(1){
      for(i=0;i<2;i++){
    44bc:	89 81       	ldd	r24, Y+1	; 0x01
    44be:	9a 81       	ldd	r25, Y+2	; 0x02
    44c0:	01 96       	adiw	r24, 0x01	; 1
    44c2:	9a 83       	std	Y+2, r25	; 0x02
    44c4:	89 83       	std	Y+1, r24	; 0x01
    44c6:	89 81       	ldd	r24, Y+1	; 0x01
    44c8:	9a 81       	ldd	r25, Y+2	; 0x02
    44ca:	82 30       	cpi	r24, 0x02	; 2
    44cc:	91 05       	cpc	r25, r1
    44ce:	ac f2       	brlt	.-86     	; 0x447a <vTaskSonar+0x52>
         currSonar = i;
         PORTC = (1<<i);
         xSemaphoreTake(sonarSemaphore,portMAX_DELAY);
         setSonarData(i,lastSonarData);
      }
   }
    44d0:	d1 cf       	rjmp	.-94     	; 0x4474 <vTaskSonar+0x4c>

000044d2 <getAllSensors>:
            
} 

char getAllSensors(unsigned short* responseData){
    44d2:	cf 93       	push	r28
    44d4:	df 93       	push	r29
    44d6:	00 d0       	rcall	.+0      	; 0x44d8 <getAllSensors+0x6>
    44d8:	1f 92       	push	r1
    44da:	cd b7       	in	r28, 0x3d	; 61
    44dc:	de b7       	in	r29, 0x3e	; 62
    44de:	9c 83       	std	Y+4, r25	; 0x04
    44e0:	8b 83       	std	Y+3, r24	; 0x03
   unsigned short i;
   for(i=0;i<6;i++){
    44e2:	1a 82       	std	Y+2, r1	; 0x02
    44e4:	19 82       	std	Y+1, r1	; 0x01
    44e6:	14 c0       	rjmp	.+40     	; 0x4510 <getAllSensors+0x3e>
      //responseData[i] = getSonarData(i);
      responseData[i] = i+1;
    44e8:	89 81       	ldd	r24, Y+1	; 0x01
    44ea:	9a 81       	ldd	r25, Y+2	; 0x02
    44ec:	88 0f       	add	r24, r24
    44ee:	99 1f       	adc	r25, r25
    44f0:	2b 81       	ldd	r18, Y+3	; 0x03
    44f2:	3c 81       	ldd	r19, Y+4	; 0x04
    44f4:	82 0f       	add	r24, r18
    44f6:	93 1f       	adc	r25, r19
    44f8:	29 81       	ldd	r18, Y+1	; 0x01
    44fa:	3a 81       	ldd	r19, Y+2	; 0x02
    44fc:	2f 5f       	subi	r18, 0xFF	; 255
    44fe:	3f 4f       	sbci	r19, 0xFF	; 255
    4500:	fc 01       	movw	r30, r24
    4502:	31 83       	std	Z+1, r19	; 0x01
    4504:	20 83       	st	Z, r18
            
} 

char getAllSensors(unsigned short* responseData){
   unsigned short i;
   for(i=0;i<6;i++){
    4506:	89 81       	ldd	r24, Y+1	; 0x01
    4508:	9a 81       	ldd	r25, Y+2	; 0x02
    450a:	01 96       	adiw	r24, 0x01	; 1
    450c:	9a 83       	std	Y+2, r25	; 0x02
    450e:	89 83       	std	Y+1, r24	; 0x01
    4510:	89 81       	ldd	r24, Y+1	; 0x01
    4512:	9a 81       	ldd	r25, Y+2	; 0x02
    4514:	86 30       	cpi	r24, 0x06	; 6
    4516:	91 05       	cpc	r25, r1
    4518:	38 f3       	brcs	.-50     	; 0x44e8 <getAllSensors+0x16>
      //responseData[i] = getSonarData(i);
      responseData[i] = i+1;
   }
}
    451a:	0f 90       	pop	r0
    451c:	0f 90       	pop	r0
    451e:	0f 90       	pop	r0
    4520:	0f 90       	pop	r0
    4522:	df 91       	pop	r29
    4524:	cf 91       	pop	r28
    4526:	08 95       	ret

00004528 <getCertainSensor>:

char getCertainSensor(char commandData,int* responseData){
    4528:	0f 93       	push	r16
    452a:	1f 93       	push	r17
    452c:	cf 93       	push	r28
    452e:	df 93       	push	r29
    4530:	00 d0       	rcall	.+0      	; 0x4532 <getCertainSensor+0xa>
    4532:	cd b7       	in	r28, 0x3d	; 61
    4534:	de b7       	in	r29, 0x3e	; 62
    4536:	89 83       	std	Y+1, r24	; 0x01
    4538:	7b 83       	std	Y+3, r23	; 0x03
    453a:	6a 83       	std	Y+2, r22	; 0x02
   if(commandData < 6){
    453c:	89 81       	ldd	r24, Y+1	; 0x01
    453e:	86 30       	cpi	r24, 0x06	; 6
    4540:	b4 f4       	brge	.+44     	; 0x456e <getCertainSensor+0x46>
      responseData[commandData] = getSonarData(commandData);
    4542:	89 81       	ldd	r24, Y+1	; 0x01
    4544:	99 27       	eor	r25, r25
    4546:	87 fd       	sbrc	r24, 7
    4548:	90 95       	com	r25
    454a:	88 0f       	add	r24, r24
    454c:	99 1f       	adc	r25, r25
    454e:	2a 81       	ldd	r18, Y+2	; 0x02
    4550:	3b 81       	ldd	r19, Y+3	; 0x03
    4552:	89 01       	movw	r16, r18
    4554:	08 0f       	add	r16, r24
    4556:	19 1f       	adc	r17, r25
    4558:	89 81       	ldd	r24, Y+1	; 0x01
    455a:	99 27       	eor	r25, r25
    455c:	87 fd       	sbrc	r24, 7
    455e:	90 95       	com	r25
    4560:	0e 94 61 21 	call	0x42c2	; 0x42c2 <getSonarData>
    4564:	88 2f       	mov	r24, r24
    4566:	90 e0       	ldi	r25, 0x00	; 0
    4568:	f8 01       	movw	r30, r16
    456a:	91 83       	std	Z+1, r25	; 0x01
    456c:	80 83       	st	Z, r24
   }
}
    456e:	0f 90       	pop	r0
    4570:	0f 90       	pop	r0
    4572:	0f 90       	pop	r0
    4574:	df 91       	pop	r29
    4576:	cf 91       	pop	r28
    4578:	1f 91       	pop	r17
    457a:	0f 91       	pop	r16
    457c:	08 95       	ret

0000457e <getSensorGroup>:

char getSensorGroup(char commandData,int* responseData){
    457e:	0f 93       	push	r16
    4580:	1f 93       	push	r17
    4582:	cf 93       	push	r28
    4584:	df 93       	push	r29
    4586:	00 d0       	rcall	.+0      	; 0x4588 <getSensorGroup+0xa>
    4588:	cd b7       	in	r28, 0x3d	; 61
    458a:	de b7       	in	r29, 0x3e	; 62
    458c:	89 83       	std	Y+1, r24	; 0x01
    458e:	7b 83       	std	Y+3, r23	; 0x03
    4590:	6a 83       	std	Y+2, r22	; 0x02

   switch(commandData){
    4592:	89 81       	ldd	r24, Y+1	; 0x01
    4594:	99 27       	eor	r25, r25
    4596:	87 fd       	sbrc	r24, 7
    4598:	90 95       	com	r25
    459a:	81 30       	cpi	r24, 0x01	; 1
    459c:	91 05       	cpc	r25, r1
    459e:	01 f1       	breq	.+64     	; 0x45e0 <getSensorGroup+0x62>
    45a0:	82 30       	cpi	r24, 0x02	; 2
    45a2:	91 05       	cpc	r25, r1
    45a4:	b9 f1       	breq	.+110    	; 0x4614 <getSensorGroup+0x96>
    45a6:	00 97       	sbiw	r24, 0x00	; 0
    45a8:	09 f0       	breq	.+2      	; 0x45ac <getSensorGroup+0x2e>
    45aa:	4e c0       	rjmp	.+156    	; 0x4648 <getSensorGroup+0xca>
      case SONAR_GROUP_LEFT:
         responseData[0] = getSonarData(0);
    45ac:	80 e0       	ldi	r24, 0x00	; 0
    45ae:	90 e0       	ldi	r25, 0x00	; 0
    45b0:	0e 94 61 21 	call	0x42c2	; 0x42c2 <getSonarData>
    45b4:	28 2f       	mov	r18, r24
    45b6:	30 e0       	ldi	r19, 0x00	; 0
    45b8:	8a 81       	ldd	r24, Y+2	; 0x02
    45ba:	9b 81       	ldd	r25, Y+3	; 0x03
    45bc:	fc 01       	movw	r30, r24
    45be:	31 83       	std	Z+1, r19	; 0x01
    45c0:	20 83       	st	Z, r18
         responseData[1] = getSonarData(1);
    45c2:	8a 81       	ldd	r24, Y+2	; 0x02
    45c4:	9b 81       	ldd	r25, Y+3	; 0x03
    45c6:	8c 01       	movw	r16, r24
    45c8:	0e 5f       	subi	r16, 0xFE	; 254
    45ca:	1f 4f       	sbci	r17, 0xFF	; 255
    45cc:	81 e0       	ldi	r24, 0x01	; 1
    45ce:	90 e0       	ldi	r25, 0x00	; 0
    45d0:	0e 94 61 21 	call	0x42c2	; 0x42c2 <getSonarData>
    45d4:	88 2f       	mov	r24, r24
    45d6:	90 e0       	ldi	r25, 0x00	; 0
    45d8:	f8 01       	movw	r30, r16
    45da:	91 83       	std	Z+1, r25	; 0x01
    45dc:	80 83       	st	Z, r24
         break;
    45de:	34 c0       	rjmp	.+104    	; 0x4648 <getSensorGroup+0xca>
      case SONAR_GROUP_FRONT:
         responseData[0] = getSonarData(2);
    45e0:	82 e0       	ldi	r24, 0x02	; 2
    45e2:	90 e0       	ldi	r25, 0x00	; 0
    45e4:	0e 94 61 21 	call	0x42c2	; 0x42c2 <getSonarData>
    45e8:	28 2f       	mov	r18, r24
    45ea:	30 e0       	ldi	r19, 0x00	; 0
    45ec:	8a 81       	ldd	r24, Y+2	; 0x02
    45ee:	9b 81       	ldd	r25, Y+3	; 0x03
    45f0:	fc 01       	movw	r30, r24
    45f2:	31 83       	std	Z+1, r19	; 0x01
    45f4:	20 83       	st	Z, r18
         responseData[1] = getSonarData(3);
    45f6:	8a 81       	ldd	r24, Y+2	; 0x02
    45f8:	9b 81       	ldd	r25, Y+3	; 0x03
    45fa:	8c 01       	movw	r16, r24
    45fc:	0e 5f       	subi	r16, 0xFE	; 254
    45fe:	1f 4f       	sbci	r17, 0xFF	; 255
    4600:	83 e0       	ldi	r24, 0x03	; 3
    4602:	90 e0       	ldi	r25, 0x00	; 0
    4604:	0e 94 61 21 	call	0x42c2	; 0x42c2 <getSonarData>
    4608:	88 2f       	mov	r24, r24
    460a:	90 e0       	ldi	r25, 0x00	; 0
    460c:	f8 01       	movw	r30, r16
    460e:	91 83       	std	Z+1, r25	; 0x01
    4610:	80 83       	st	Z, r24
         break;
    4612:	1a c0       	rjmp	.+52     	; 0x4648 <getSensorGroup+0xca>
      case SONAR_GROUP_RIGHT:
         responseData[0] = getSonarData(4);
    4614:	84 e0       	ldi	r24, 0x04	; 4
    4616:	90 e0       	ldi	r25, 0x00	; 0
    4618:	0e 94 61 21 	call	0x42c2	; 0x42c2 <getSonarData>
    461c:	28 2f       	mov	r18, r24
    461e:	30 e0       	ldi	r19, 0x00	; 0
    4620:	8a 81       	ldd	r24, Y+2	; 0x02
    4622:	9b 81       	ldd	r25, Y+3	; 0x03
    4624:	fc 01       	movw	r30, r24
    4626:	31 83       	std	Z+1, r19	; 0x01
    4628:	20 83       	st	Z, r18
         responseData[1] = getSonarData(5);
    462a:	8a 81       	ldd	r24, Y+2	; 0x02
    462c:	9b 81       	ldd	r25, Y+3	; 0x03
    462e:	8c 01       	movw	r16, r24
    4630:	0e 5f       	subi	r16, 0xFE	; 254
    4632:	1f 4f       	sbci	r17, 0xFF	; 255
    4634:	85 e0       	ldi	r24, 0x05	; 5
    4636:	90 e0       	ldi	r25, 0x00	; 0
    4638:	0e 94 61 21 	call	0x42c2	; 0x42c2 <getSonarData>
    463c:	88 2f       	mov	r24, r24
    463e:	90 e0       	ldi	r25, 0x00	; 0
    4640:	f8 01       	movw	r30, r16
    4642:	91 83       	std	Z+1, r25	; 0x01
    4644:	80 83       	st	Z, r24
         break;
    4646:	00 00       	nop
   }

    4648:	0f 90       	pop	r0
    464a:	0f 90       	pop	r0
    464c:	0f 90       	pop	r0
    464e:	df 91       	pop	r29
    4650:	cf 91       	pop	r28
    4652:	1f 91       	pop	r17
    4654:	0f 91       	pop	r16
    4656:	08 95       	ret

00004658 <initSpeedController>:
//Speed Sensor group

#include "spi.h"

void initSpeedController(){
    4658:	cf 93       	push	r28
    465a:	df 93       	push	r29
    465c:	cd b7       	in	r28, 0x3d	; 61
    465e:	de b7       	in	r29, 0x3e	; 62
	SPIsendShort(0x400F);
    4660:	8f e0       	ldi	r24, 0x0F	; 15
    4662:	90 e4       	ldi	r25, 0x40	; 64
    4664:	0e 94 8c 24 	call	0x4918	; 0x4918 <SPIsendShort>
}
    4668:	df 91       	pop	r29
    466a:	cf 91       	pop	r28
    466c:	08 95       	ret

0000466e <setPot>:

void setPot(int value){
    466e:	cf 93       	push	r28
    4670:	df 93       	push	r29
    4672:	00 d0       	rcall	.+0      	; 0x4674 <setPot+0x6>
    4674:	1f 92       	push	r1
    4676:	cd b7       	in	r28, 0x3d	; 61
    4678:	de b7       	in	r29, 0x3e	; 62
    467a:	9c 83       	std	Y+4, r25	; 0x04
    467c:	8b 83       	std	Y+3, r24	; 0x03
	unsigned short data = 0;
    467e:	1a 82       	std	Y+2, r1	; 0x02
    4680:	19 82       	std	Y+1, r1	; 0x01
	data = value & 0xFF;
    4682:	8b 81       	ldd	r24, Y+3	; 0x03
    4684:	9c 81       	ldd	r25, Y+4	; 0x04
    4686:	99 27       	eor	r25, r25
    4688:	9a 83       	std	Y+2, r25	; 0x02
    468a:	89 83       	std	Y+1, r24	; 0x01

	SPIsendShort(data);
    468c:	89 81       	ldd	r24, Y+1	; 0x01
    468e:	9a 81       	ldd	r25, Y+2	; 0x02
    4690:	0e 94 8c 24 	call	0x4918	; 0x4918 <SPIsendShort>
}
    4694:	0f 90       	pop	r0
    4696:	0f 90       	pop	r0
    4698:	0f 90       	pop	r0
    469a:	0f 90       	pop	r0
    469c:	df 91       	pop	r29
    469e:	cf 91       	pop	r28
    46a0:	08 95       	ret

000046a2 <decrementPot>:

void decrementPot(){
    46a2:	cf 93       	push	r28
    46a4:	df 93       	push	r29
    46a6:	cd b7       	in	r28, 0x3d	; 61
    46a8:	de b7       	in	r29, 0x3e	; 62
	SPIsendByte(0x06);
    46aa:	86 e0       	ldi	r24, 0x06	; 6
    46ac:	90 e0       	ldi	r25, 0x00	; 0
    46ae:	0e 94 46 24 	call	0x488c	; 0x488c <SPIsendByte>
}
    46b2:	df 91       	pop	r29
    46b4:	cf 91       	pop	r28
    46b6:	08 95       	ret

000046b8 <incrementPot>:

void incrementPot(){
    46b8:	cf 93       	push	r28
    46ba:	df 93       	push	r29
    46bc:	cd b7       	in	r28, 0x3d	; 61
    46be:	de b7       	in	r29, 0x3e	; 62
	SPIsendByte(0x0A);
    46c0:	8a e0       	ldi	r24, 0x0A	; 10
    46c2:	90 e0       	ldi	r25, 0x00	; 0
    46c4:	0e 94 46 24 	call	0x488c	; 0x488c <SPIsendByte>
}
    46c8:	df 91       	pop	r29
    46ca:	cf 91       	pop	r28
    46cc:	08 95       	ret

000046ce <getSpeed>:

//get the speed of the vehicle
char getSpeed(char* sensorResponse) {
    46ce:	cf 93       	push	r28
    46d0:	df 93       	push	r29
    46d2:	1f 92       	push	r1
    46d4:	1f 92       	push	r1
    46d6:	cd b7       	in	r28, 0x3d	; 61
    46d8:	de b7       	in	r29, 0x3e	; 62
    46da:	9a 83       	std	Y+2, r25	; 0x02
    46dc:	89 83       	std	Y+1, r24	; 0x01
   //store dummy speed value
   *sensorResponse = 0;
    46de:	89 81       	ldd	r24, Y+1	; 0x01
    46e0:	9a 81       	ldd	r25, Y+2	; 0x02
    46e2:	fc 01       	movw	r30, r24
    46e4:	10 82       	st	Z, r1
   //return success
   return 1;
    46e6:	81 e0       	ldi	r24, 0x01	; 1
}
    46e8:	0f 90       	pop	r0
    46ea:	0f 90       	pop	r0
    46ec:	df 91       	pop	r29
    46ee:	cf 91       	pop	r28
    46f0:	08 95       	ret

000046f2 <setSpeed>:

//will set just the speed of the wheels of the car
char setSpeed(char speedTarget) {
    46f2:	cf 93       	push	r28
    46f4:	df 93       	push	r29
    46f6:	1f 92       	push	r1
    46f8:	cd b7       	in	r28, 0x3d	; 61
    46fa:	de b7       	in	r29, 0x3e	; 62
    46fc:	89 83       	std	Y+1, r24	; 0x01
   //nothing done down here
   //return success
	setPot(speedTarget);
    46fe:	89 81       	ldd	r24, Y+1	; 0x01
    4700:	99 27       	eor	r25, r25
    4702:	87 fd       	sbrc	r24, 7
    4704:	90 95       	com	r25
    4706:	0e 94 37 23 	call	0x466e	; 0x466e <setPot>
   return 1;
    470a:	81 e0       	ldi	r24, 0x01	; 1
}
    470c:	0f 90       	pop	r0
    470e:	df 91       	pop	r29
    4710:	cf 91       	pop	r28
    4712:	08 95       	ret

00004714 <setAngle>:

//Steering group

//JUST SETS ANGLE TARGET. Actual angle changing is lower level
char setAngle(char angleTarget) {
    4714:	cf 93       	push	r28
    4716:	df 93       	push	r29
    4718:	1f 92       	push	r1
    471a:	cd b7       	in	r28, 0x3d	; 61
    471c:	de b7       	in	r29, 0x3e	; 62
    471e:	89 83       	std	Y+1, r24	; 0x01
   //dummy function, nothing will happen for now...
   //return success
   return 1;
    4720:	81 e0       	ldi	r24, 0x01	; 1
}
    4722:	0f 90       	pop	r0
    4724:	df 91       	pop	r29
    4726:	cf 91       	pop	r28
    4728:	08 95       	ret

0000472a <getAngle>:

//get the current angle of the steering system
char getAngle(char* sensorResponse) {
    472a:	cf 93       	push	r28
    472c:	df 93       	push	r29
    472e:	1f 92       	push	r1
    4730:	1f 92       	push	r1
    4732:	cd b7       	in	r28, 0x3d	; 61
    4734:	de b7       	in	r29, 0x3e	; 62
    4736:	9a 83       	std	Y+2, r25	; 0x02
    4738:	89 83       	std	Y+1, r24	; 0x01
   //store fake angle reading
   *sensorResponse = 0;
    473a:	89 81       	ldd	r24, Y+1	; 0x01
    473c:	9a 81       	ldd	r25, Y+2	; 0x02
    473e:	fc 01       	movw	r30, r24
    4740:	10 82       	st	Z, r1
   //return success
   return 1;
    4742:	81 e0       	ldi	r24, 0x01	; 1
}
    4744:	0f 90       	pop	r0
    4746:	0f 90       	pop	r0
    4748:	df 91       	pop	r29
    474a:	cf 91       	pop	r28
    474c:	08 95       	ret

0000474e <getDesiredAngle>:

//get the angle target. argument name is sensorResponse for the sake of consistancy
char getDesiredAngle(char* sensorResponse) {
    474e:	cf 93       	push	r28
    4750:	df 93       	push	r29
    4752:	1f 92       	push	r1
    4754:	1f 92       	push	r1
    4756:	cd b7       	in	r28, 0x3d	; 61
    4758:	de b7       	in	r29, 0x3e	; 62
    475a:	9a 83       	std	Y+2, r25	; 0x02
    475c:	89 83       	std	Y+1, r24	; 0x01
   //fake response
   *sensorResponse = 0;
    475e:	89 81       	ldd	r24, Y+1	; 0x01
    4760:	9a 81       	ldd	r25, Y+2	; 0x02
    4762:	fc 01       	movw	r30, r24
    4764:	10 82       	st	Z, r1
   //return success
   return 1;
    4766:	81 e0       	ldi	r24, 0x01	; 1
}
    4768:	0f 90       	pop	r0
    476a:	0f 90       	pop	r0
    476c:	df 91       	pop	r29
    476e:	cf 91       	pop	r28
    4770:	08 95       	ret

00004772 <changePID>:

//change the PID controller
char changePID(char P, char I, char D) {
    4772:	cf 93       	push	r28
    4774:	df 93       	push	r29
    4776:	00 d0       	rcall	.+0      	; 0x4778 <changePID+0x6>
    4778:	cd b7       	in	r28, 0x3d	; 61
    477a:	de b7       	in	r29, 0x3e	; 62
    477c:	89 83       	std	Y+1, r24	; 0x01
    477e:	6a 83       	std	Y+2, r22	; 0x02
    4780:	4b 83       	std	Y+3, r20	; 0x03
   //dummy function, nothing happens
   //return success
   return 1;
    4782:	81 e0       	ldi	r24, 0x01	; 1
}
    4784:	0f 90       	pop	r0
    4786:	0f 90       	pop	r0
    4788:	0f 90       	pop	r0
    478a:	df 91       	pop	r29
    478c:	cf 91       	pop	r28
    478e:	08 95       	ret

00004790 <setLimits>:

//not sure what this does. Also not sure why upper and lower are separated
//but its in the specs so...
char setLimits(char upper, char lower) {
    4790:	cf 93       	push	r28
    4792:	df 93       	push	r29
    4794:	1f 92       	push	r1
    4796:	1f 92       	push	r1
    4798:	cd b7       	in	r28, 0x3d	; 61
    479a:	de b7       	in	r29, 0x3e	; 62
    479c:	89 83       	std	Y+1, r24	; 0x01
    479e:	6a 83       	std	Y+2, r22	; 0x02
   //dummy function, nothing happens
   //return success
   return 1;
    47a0:	81 e0       	ldi	r24, 0x01	; 1
}
    47a2:	0f 90       	pop	r0
    47a4:	0f 90       	pop	r0
    47a6:	df 91       	pop	r29
    47a8:	cf 91       	pop	r28
    47aa:	08 95       	ret

000047ac <initializeSPI>:
const static int mosi_pin = 2;
const static int miso_pin = 3;
const static int sck_pin = 1;
const static int ss_pin = 0; 

void initializeSPI(){
    47ac:	cf 93       	push	r28
    47ae:	df 93       	push	r29
    47b0:	cd b7       	in	r28, 0x3d	; 61
    47b2:	de b7       	in	r29, 0x3e	; 62
	SPCR = (1 << SPE)|(1 << MSTR)|(1 << SPR1)|(1 << SPR0);
    47b4:	8c e4       	ldi	r24, 0x4C	; 76
    47b6:	90 e0       	ldi	r25, 0x00	; 0
    47b8:	23 e5       	ldi	r18, 0x53	; 83
    47ba:	fc 01       	movw	r30, r24
    47bc:	20 83       	st	Z, r18
	DDRB |= (1 << ss_pin)|(1 << sck_pin)|(1 << mosi_pin);
    47be:	84 e2       	ldi	r24, 0x24	; 36
    47c0:	90 e0       	ldi	r25, 0x00	; 0
    47c2:	24 e2       	ldi	r18, 0x24	; 36
    47c4:	30 e0       	ldi	r19, 0x00	; 0
    47c6:	f9 01       	movw	r30, r18
    47c8:	20 81       	ld	r18, Z
    47ca:	62 2f       	mov	r22, r18
    47cc:	40 e0       	ldi	r20, 0x00	; 0
    47ce:	50 e0       	ldi	r21, 0x00	; 0
    47d0:	21 e0       	ldi	r18, 0x01	; 1
    47d2:	30 e0       	ldi	r19, 0x00	; 0
    47d4:	02 c0       	rjmp	.+4      	; 0x47da <initializeSPI+0x2e>
    47d6:	22 0f       	add	r18, r18
    47d8:	33 1f       	adc	r19, r19
    47da:	4a 95       	dec	r20
    47dc:	e2 f7       	brpl	.-8      	; 0x47d6 <initializeSPI+0x2a>
    47de:	72 2f       	mov	r23, r18
    47e0:	41 e0       	ldi	r20, 0x01	; 1
    47e2:	50 e0       	ldi	r21, 0x00	; 0
    47e4:	21 e0       	ldi	r18, 0x01	; 1
    47e6:	30 e0       	ldi	r19, 0x00	; 0
    47e8:	02 c0       	rjmp	.+4      	; 0x47ee <initializeSPI+0x42>
    47ea:	22 0f       	add	r18, r18
    47ec:	33 1f       	adc	r19, r19
    47ee:	4a 95       	dec	r20
    47f0:	e2 f7       	brpl	.-8      	; 0x47ea <initializeSPI+0x3e>
    47f2:	72 2b       	or	r23, r18
    47f4:	42 e0       	ldi	r20, 0x02	; 2
    47f6:	50 e0       	ldi	r21, 0x00	; 0
    47f8:	21 e0       	ldi	r18, 0x01	; 1
    47fa:	30 e0       	ldi	r19, 0x00	; 0
    47fc:	02 c0       	rjmp	.+4      	; 0x4802 <initializeSPI+0x56>
    47fe:	22 0f       	add	r18, r18
    4800:	33 1f       	adc	r19, r19
    4802:	4a 95       	dec	r20
    4804:	e2 f7       	brpl	.-8      	; 0x47fe <initializeSPI+0x52>
    4806:	27 2b       	or	r18, r23
    4808:	26 2b       	or	r18, r22
    480a:	fc 01       	movw	r30, r24
    480c:	20 83       	st	Z, r18
	DDRB &= ~(1 << miso_pin);
    480e:	84 e2       	ldi	r24, 0x24	; 36
    4810:	90 e0       	ldi	r25, 0x00	; 0
    4812:	24 e2       	ldi	r18, 0x24	; 36
    4814:	30 e0       	ldi	r19, 0x00	; 0
    4816:	f9 01       	movw	r30, r18
    4818:	20 81       	ld	r18, Z
    481a:	62 2f       	mov	r22, r18
    481c:	43 e0       	ldi	r20, 0x03	; 3
    481e:	50 e0       	ldi	r21, 0x00	; 0
    4820:	21 e0       	ldi	r18, 0x01	; 1
    4822:	30 e0       	ldi	r19, 0x00	; 0
    4824:	02 c0       	rjmp	.+4      	; 0x482a <initializeSPI+0x7e>
    4826:	22 0f       	add	r18, r18
    4828:	33 1f       	adc	r19, r19
    482a:	4a 95       	dec	r20
    482c:	e2 f7       	brpl	.-8      	; 0x4826 <initializeSPI+0x7a>
    482e:	20 95       	com	r18
    4830:	26 23       	and	r18, r22
    4832:	fc 01       	movw	r30, r24
    4834:	20 83       	st	Z, r18
	PORTB |= 1 << ss_pin;
    4836:	85 e2       	ldi	r24, 0x25	; 37
    4838:	90 e0       	ldi	r25, 0x00	; 0
    483a:	25 e2       	ldi	r18, 0x25	; 37
    483c:	30 e0       	ldi	r19, 0x00	; 0
    483e:	f9 01       	movw	r30, r18
    4840:	20 81       	ld	r18, Z
    4842:	62 2f       	mov	r22, r18
    4844:	40 e0       	ldi	r20, 0x00	; 0
    4846:	50 e0       	ldi	r21, 0x00	; 0
    4848:	21 e0       	ldi	r18, 0x01	; 1
    484a:	30 e0       	ldi	r19, 0x00	; 0
    484c:	02 c0       	rjmp	.+4      	; 0x4852 <initializeSPI+0xa6>
    484e:	22 0f       	add	r18, r18
    4850:	33 1f       	adc	r19, r19
    4852:	4a 95       	dec	r20
    4854:	e2 f7       	brpl	.-8      	; 0x484e <initializeSPI+0xa2>
    4856:	26 2b       	or	r18, r22
    4858:	fc 01       	movw	r30, r24
    485a:	20 83       	st	Z, r18
	PORTB &= ~(1 << sck_pin);
    485c:	85 e2       	ldi	r24, 0x25	; 37
    485e:	90 e0       	ldi	r25, 0x00	; 0
    4860:	25 e2       	ldi	r18, 0x25	; 37
    4862:	30 e0       	ldi	r19, 0x00	; 0
    4864:	f9 01       	movw	r30, r18
    4866:	20 81       	ld	r18, Z
    4868:	62 2f       	mov	r22, r18
    486a:	41 e0       	ldi	r20, 0x01	; 1
    486c:	50 e0       	ldi	r21, 0x00	; 0
    486e:	21 e0       	ldi	r18, 0x01	; 1
    4870:	30 e0       	ldi	r19, 0x00	; 0
    4872:	04 2e       	mov	r0, r20
    4874:	02 c0       	rjmp	.+4      	; 0x487a <initializeSPI+0xce>
    4876:	22 0f       	add	r18, r18
    4878:	33 1f       	adc	r19, r19
    487a:	0a 94       	dec	r0
    487c:	e2 f7       	brpl	.-8      	; 0x4876 <initializeSPI+0xca>
    487e:	20 95       	com	r18
    4880:	26 23       	and	r18, r22
    4882:	fc 01       	movw	r30, r24
    4884:	20 83       	st	Z, r18
}
    4886:	df 91       	pop	r29
    4888:	cf 91       	pop	r28
    488a:	08 95       	ret

0000488c <SPIsendByte>:

void SPIsendByte(unsigned char byte){
    488c:	cf 93       	push	r28
    488e:	df 93       	push	r29
    4890:	1f 92       	push	r1
    4892:	cd b7       	in	r28, 0x3d	; 61
    4894:	de b7       	in	r29, 0x3e	; 62
    4896:	89 83       	std	Y+1, r24	; 0x01
	PORTB &= ~(1 << ss_pin);
    4898:	85 e2       	ldi	r24, 0x25	; 37
    489a:	90 e0       	ldi	r25, 0x00	; 0
    489c:	25 e2       	ldi	r18, 0x25	; 37
    489e:	30 e0       	ldi	r19, 0x00	; 0
    48a0:	f9 01       	movw	r30, r18
    48a2:	20 81       	ld	r18, Z
    48a4:	62 2f       	mov	r22, r18
    48a6:	40 e0       	ldi	r20, 0x00	; 0
    48a8:	50 e0       	ldi	r21, 0x00	; 0
    48aa:	21 e0       	ldi	r18, 0x01	; 1
    48ac:	30 e0       	ldi	r19, 0x00	; 0
    48ae:	02 c0       	rjmp	.+4      	; 0x48b4 <SPIsendByte+0x28>
    48b0:	22 0f       	add	r18, r18
    48b2:	33 1f       	adc	r19, r19
    48b4:	4a 95       	dec	r20
    48b6:	e2 f7       	brpl	.-8      	; 0x48b0 <SPIsendByte+0x24>
    48b8:	20 95       	com	r18
    48ba:	26 23       	and	r18, r22
    48bc:	fc 01       	movw	r30, r24
    48be:	20 83       	st	Z, r18
	vTaskDelay(1);
    48c0:	81 e0       	ldi	r24, 0x01	; 1
    48c2:	90 e0       	ldi	r25, 0x00	; 0
    48c4:	0e 94 ab 04 	call	0x956	; 0x956 <vTaskDelay>
	SPDR = byte;
    48c8:	8e e4       	ldi	r24, 0x4E	; 78
    48ca:	90 e0       	ldi	r25, 0x00	; 0
    48cc:	29 81       	ldd	r18, Y+1	; 0x01
    48ce:	fc 01       	movw	r30, r24
    48d0:	20 83       	st	Z, r18
	while((SPSR & (1 << SPIF)) == 0)
    48d2:	00 00       	nop
    48d4:	8d e4       	ldi	r24, 0x4D	; 77
    48d6:	90 e0       	ldi	r25, 0x00	; 0
    48d8:	fc 01       	movw	r30, r24
    48da:	80 81       	ld	r24, Z
    48dc:	88 23       	and	r24, r24
    48de:	d4 f7       	brge	.-12     	; 0x48d4 <SPIsendByte+0x48>
	;
	vTaskDelay(1);
    48e0:	81 e0       	ldi	r24, 0x01	; 1
    48e2:	90 e0       	ldi	r25, 0x00	; 0
    48e4:	0e 94 ab 04 	call	0x956	; 0x956 <vTaskDelay>
	PORTB |= (1 << ss_pin);
    48e8:	85 e2       	ldi	r24, 0x25	; 37
    48ea:	90 e0       	ldi	r25, 0x00	; 0
    48ec:	25 e2       	ldi	r18, 0x25	; 37
    48ee:	30 e0       	ldi	r19, 0x00	; 0
    48f0:	f9 01       	movw	r30, r18
    48f2:	20 81       	ld	r18, Z
    48f4:	62 2f       	mov	r22, r18
    48f6:	40 e0       	ldi	r20, 0x00	; 0
    48f8:	50 e0       	ldi	r21, 0x00	; 0
    48fa:	21 e0       	ldi	r18, 0x01	; 1
    48fc:	30 e0       	ldi	r19, 0x00	; 0
    48fe:	04 2e       	mov	r0, r20
    4900:	02 c0       	rjmp	.+4      	; 0x4906 <SPIsendByte+0x7a>
    4902:	22 0f       	add	r18, r18
    4904:	33 1f       	adc	r19, r19
    4906:	0a 94       	dec	r0
    4908:	e2 f7       	brpl	.-8      	; 0x4902 <SPIsendByte+0x76>
    490a:	26 2b       	or	r18, r22
    490c:	fc 01       	movw	r30, r24
    490e:	20 83       	st	Z, r18

}
    4910:	0f 90       	pop	r0
    4912:	df 91       	pop	r29
    4914:	cf 91       	pop	r28
    4916:	08 95       	ret

00004918 <SPIsendShort>:

void SPIsendShort(unsigned short data){
    4918:	cf 93       	push	r28
    491a:	df 93       	push	r29
    491c:	1f 92       	push	r1
    491e:	1f 92       	push	r1
    4920:	cd b7       	in	r28, 0x3d	; 61
    4922:	de b7       	in	r29, 0x3e	; 62
    4924:	9a 83       	std	Y+2, r25	; 0x02
    4926:	89 83       	std	Y+1, r24	; 0x01
	PORTB &= ~(1 << ss_pin);
    4928:	85 e2       	ldi	r24, 0x25	; 37
    492a:	90 e0       	ldi	r25, 0x00	; 0
    492c:	25 e2       	ldi	r18, 0x25	; 37
    492e:	30 e0       	ldi	r19, 0x00	; 0
    4930:	f9 01       	movw	r30, r18
    4932:	20 81       	ld	r18, Z
    4934:	62 2f       	mov	r22, r18
    4936:	40 e0       	ldi	r20, 0x00	; 0
    4938:	50 e0       	ldi	r21, 0x00	; 0
    493a:	21 e0       	ldi	r18, 0x01	; 1
    493c:	30 e0       	ldi	r19, 0x00	; 0
    493e:	02 c0       	rjmp	.+4      	; 0x4944 <SPIsendShort+0x2c>
    4940:	22 0f       	add	r18, r18
    4942:	33 1f       	adc	r19, r19
    4944:	4a 95       	dec	r20
    4946:	e2 f7       	brpl	.-8      	; 0x4940 <SPIsendShort+0x28>
    4948:	20 95       	com	r18
    494a:	26 23       	and	r18, r22
    494c:	fc 01       	movw	r30, r24
    494e:	20 83       	st	Z, r18
	vTaskDelay(2);
    4950:	82 e0       	ldi	r24, 0x02	; 2
    4952:	90 e0       	ldi	r25, 0x00	; 0
    4954:	0e 94 ab 04 	call	0x956	; 0x956 <vTaskDelay>
	SPDR = (data >> 8);
    4958:	8e e4       	ldi	r24, 0x4E	; 78
    495a:	90 e0       	ldi	r25, 0x00	; 0
    495c:	29 81       	ldd	r18, Y+1	; 0x01
    495e:	3a 81       	ldd	r19, Y+2	; 0x02
    4960:	23 2f       	mov	r18, r19
    4962:	33 27       	eor	r19, r19
    4964:	fc 01       	movw	r30, r24
    4966:	20 83       	st	Z, r18
	while((SPSR & (1 << SPIF)) == 0)
    4968:	00 00       	nop
    496a:	8d e4       	ldi	r24, 0x4D	; 77
    496c:	90 e0       	ldi	r25, 0x00	; 0
    496e:	fc 01       	movw	r30, r24
    4970:	80 81       	ld	r24, Z
    4972:	88 23       	and	r24, r24
    4974:	d4 f7       	brge	.-12     	; 0x496a <SPIsendShort+0x52>
	;
	SPDR = data & 0xFF;
    4976:	8e e4       	ldi	r24, 0x4E	; 78
    4978:	90 e0       	ldi	r25, 0x00	; 0
    497a:	29 81       	ldd	r18, Y+1	; 0x01
    497c:	fc 01       	movw	r30, r24
    497e:	20 83       	st	Z, r18
	while((SPSR & (1 << SPIF)) == 0)
    4980:	00 00       	nop
    4982:	8d e4       	ldi	r24, 0x4D	; 77
    4984:	90 e0       	ldi	r25, 0x00	; 0
    4986:	fc 01       	movw	r30, r24
    4988:	80 81       	ld	r24, Z
    498a:	88 23       	and	r24, r24
    498c:	d4 f7       	brge	.-12     	; 0x4982 <SPIsendShort+0x6a>
	;
	vTaskDelay(2);
    498e:	82 e0       	ldi	r24, 0x02	; 2
    4990:	90 e0       	ldi	r25, 0x00	; 0
    4992:	0e 94 ab 04 	call	0x956	; 0x956 <vTaskDelay>
	PORTB |= (1 << ss_pin);
    4996:	85 e2       	ldi	r24, 0x25	; 37
    4998:	90 e0       	ldi	r25, 0x00	; 0
    499a:	25 e2       	ldi	r18, 0x25	; 37
    499c:	30 e0       	ldi	r19, 0x00	; 0
    499e:	f9 01       	movw	r30, r18
    49a0:	20 81       	ld	r18, Z
    49a2:	62 2f       	mov	r22, r18
    49a4:	40 e0       	ldi	r20, 0x00	; 0
    49a6:	50 e0       	ldi	r21, 0x00	; 0
    49a8:	21 e0       	ldi	r18, 0x01	; 1
    49aa:	30 e0       	ldi	r19, 0x00	; 0
    49ac:	04 2e       	mov	r0, r20
    49ae:	02 c0       	rjmp	.+4      	; 0x49b4 <SPIsendShort+0x9c>
    49b0:	22 0f       	add	r18, r18
    49b2:	33 1f       	adc	r19, r19
    49b4:	0a 94       	dec	r0
    49b6:	e2 f7       	brpl	.-8      	; 0x49b0 <SPIsendShort+0x98>
    49b8:	26 2b       	or	r18, r22
    49ba:	fc 01       	movw	r30, r24
    49bc:	20 83       	st	Z, r18
}
    49be:	0f 90       	pop	r0
    49c0:	0f 90       	pop	r0
    49c2:	df 91       	pop	r29
    49c4:	cf 91       	pop	r28
    49c6:	08 95       	ret

000049c8 <getSonarResult>:
xSemaphoreHandle* adcSemaphore;

static int ADCResult;
static int last4[4];

int getSonarResult(){
    49c8:	cf 93       	push	r28
    49ca:	df 93       	push	r29
    49cc:	cd b7       	in	r28, 0x3d	; 61
    49ce:	de b7       	in	r29, 0x3e	; 62
	return ADCResult;
    49d0:	80 91 c0 1a 	lds	r24, 0x1AC0
    49d4:	90 91 c1 1a 	lds	r25, 0x1AC1
}
    49d8:	df 91       	pop	r29
    49da:	cf 91       	pop	r28
    49dc:	08 95       	ret

000049de <addResult>:

void addResult(int result){
    49de:	cf 93       	push	r28
    49e0:	df 93       	push	r29
    49e2:	00 d0       	rcall	.+0      	; 0x49e4 <addResult+0x6>
    49e4:	1f 92       	push	r1
    49e6:	cd b7       	in	r28, 0x3d	; 61
    49e8:	de b7       	in	r29, 0x3e	; 62
    49ea:	9c 83       	std	Y+4, r25	; 0x04
    49ec:	8b 83       	std	Y+3, r24	; 0x03
	int i;
	for(i = 0;i < 3;i++){
    49ee:	1a 82       	std	Y+2, r1	; 0x02
    49f0:	19 82       	std	Y+1, r1	; 0x01
    49f2:	18 c0       	rjmp	.+48     	; 0x4a24 <addResult+0x46>
		last4[i] = last4[i + 1];
    49f4:	89 81       	ldd	r24, Y+1	; 0x01
    49f6:	9a 81       	ldd	r25, Y+2	; 0x02
    49f8:	01 96       	adiw	r24, 0x01	; 1
    49fa:	88 0f       	add	r24, r24
    49fc:	99 1f       	adc	r25, r25
    49fe:	8e 53       	subi	r24, 0x3E	; 62
    4a00:	95 4e       	sbci	r25, 0xE5	; 229
    4a02:	fc 01       	movw	r30, r24
    4a04:	20 81       	ld	r18, Z
    4a06:	31 81       	ldd	r19, Z+1	; 0x01
    4a08:	89 81       	ldd	r24, Y+1	; 0x01
    4a0a:	9a 81       	ldd	r25, Y+2	; 0x02
    4a0c:	88 0f       	add	r24, r24
    4a0e:	99 1f       	adc	r25, r25
    4a10:	8e 53       	subi	r24, 0x3E	; 62
    4a12:	95 4e       	sbci	r25, 0xE5	; 229
    4a14:	fc 01       	movw	r30, r24
    4a16:	31 83       	std	Z+1, r19	; 0x01
    4a18:	20 83       	st	Z, r18
	return ADCResult;
}

void addResult(int result){
	int i;
	for(i = 0;i < 3;i++){
    4a1a:	89 81       	ldd	r24, Y+1	; 0x01
    4a1c:	9a 81       	ldd	r25, Y+2	; 0x02
    4a1e:	01 96       	adiw	r24, 0x01	; 1
    4a20:	9a 83       	std	Y+2, r25	; 0x02
    4a22:	89 83       	std	Y+1, r24	; 0x01
    4a24:	89 81       	ldd	r24, Y+1	; 0x01
    4a26:	9a 81       	ldd	r25, Y+2	; 0x02
    4a28:	83 30       	cpi	r24, 0x03	; 3
    4a2a:	91 05       	cpc	r25, r1
    4a2c:	1c f3       	brlt	.-58     	; 0x49f4 <addResult+0x16>
		last4[i] = last4[i + 1];
	}
	last4[3] = result;
    4a2e:	8b 81       	ldd	r24, Y+3	; 0x03
    4a30:	9c 81       	ldd	r25, Y+4	; 0x04
    4a32:	90 93 c9 1a 	sts	0x1AC9, r25
    4a36:	80 93 c8 1a 	sts	0x1AC8, r24
	ADCResult = result;
    4a3a:	8b 81       	ldd	r24, Y+3	; 0x03
    4a3c:	9c 81       	ldd	r25, Y+4	; 0x04
    4a3e:	90 93 c1 1a 	sts	0x1AC1, r25
    4a42:	80 93 c0 1a 	sts	0x1AC0, r24
	ADCResult = result;
    4a46:	8b 81       	ldd	r24, Y+3	; 0x03
    4a48:	9c 81       	ldd	r25, Y+4	; 0x04
    4a4a:	90 93 c1 1a 	sts	0x1AC1, r25
    4a4e:	80 93 c0 1a 	sts	0x1AC0, r24
	ADCResult = (last4[0] + last4[1] + last4[2] + last4[3]) >> 2;
    4a52:	20 91 c2 1a 	lds	r18, 0x1AC2
    4a56:	30 91 c3 1a 	lds	r19, 0x1AC3
    4a5a:	80 91 c4 1a 	lds	r24, 0x1AC4
    4a5e:	90 91 c5 1a 	lds	r25, 0x1AC5
    4a62:	28 0f       	add	r18, r24
    4a64:	39 1f       	adc	r19, r25
    4a66:	80 91 c6 1a 	lds	r24, 0x1AC6
    4a6a:	90 91 c7 1a 	lds	r25, 0x1AC7
    4a6e:	28 0f       	add	r18, r24
    4a70:	39 1f       	adc	r19, r25
    4a72:	80 91 c8 1a 	lds	r24, 0x1AC8
    4a76:	90 91 c9 1a 	lds	r25, 0x1AC9
    4a7a:	82 0f       	add	r24, r18
    4a7c:	93 1f       	adc	r25, r19
    4a7e:	95 95       	asr	r25
    4a80:	87 95       	ror	r24
    4a82:	95 95       	asr	r25
    4a84:	87 95       	ror	r24
    4a86:	90 93 c1 1a 	sts	0x1AC1, r25
    4a8a:	80 93 c0 1a 	sts	0x1AC0, r24
}
    4a8e:	0f 90       	pop	r0
    4a90:	0f 90       	pop	r0
    4a92:	0f 90       	pop	r0
    4a94:	0f 90       	pop	r0
    4a96:	df 91       	pop	r29
    4a98:	cf 91       	pop	r28
    4a9a:	08 95       	ret

00004a9c <initADC>:
		
	
//Initialize ADC registers
void initADC(){
    4a9c:	cf 93       	push	r28
    4a9e:	df 93       	push	r29
    4aa0:	cd b7       	in	r28, 0x3d	; 61
    4aa2:	de b7       	in	r29, 0x3e	; 62
	ADCSRA = _BV(ADEN);
    4aa4:	8a e7       	ldi	r24, 0x7A	; 122
    4aa6:	90 e0       	ldi	r25, 0x00	; 0
    4aa8:	20 e8       	ldi	r18, 0x80	; 128
    4aaa:	fc 01       	movw	r30, r24
    4aac:	20 83       	st	Z, r18
	ADMUX = _BV(REFS0)|(1);
    4aae:	8c e7       	ldi	r24, 0x7C	; 124
    4ab0:	90 e0       	ldi	r25, 0x00	; 0
    4ab2:	21 e4       	ldi	r18, 0x41	; 65
    4ab4:	fc 01       	movw	r30, r24
    4ab6:	20 83       	st	Z, r18

	ADCSRB = (1 << MUX5);
    4ab8:	8b e7       	ldi	r24, 0x7B	; 123
    4aba:	90 e0       	ldi	r25, 0x00	; 0
    4abc:	28 e0       	ldi	r18, 0x08	; 8
    4abe:	fc 01       	movw	r30, r24
    4ac0:	20 83       	st	Z, r18
	//DIDR2 = 0xFF;
}
    4ac2:	df 91       	pop	r29
    4ac4:	cf 91       	pop	r28
    4ac6:	08 95       	ret

00004ac8 <ADCStart>:

//If the ADC isn't running, start it
void ADCStart() {
    4ac8:	cf 93       	push	r28
    4aca:	df 93       	push	r29
    4acc:	cd b7       	in	r28, 0x3d	; 61
    4ace:	de b7       	in	r29, 0x3e	; 62
	if(!(ADCSRA & _BV(ADSC))){
    4ad0:	8a e7       	ldi	r24, 0x7A	; 122
    4ad2:	90 e0       	ldi	r25, 0x00	; 0
    4ad4:	fc 01       	movw	r30, r24
    4ad6:	80 81       	ld	r24, Z
    4ad8:	88 2f       	mov	r24, r24
    4ada:	90 e0       	ldi	r25, 0x00	; 0
    4adc:	80 74       	andi	r24, 0x40	; 64
    4ade:	99 27       	eor	r25, r25
    4ae0:	00 97       	sbiw	r24, 0x00	; 0
    4ae2:	91 f4       	brne	.+36     	; 0x4b08 <ADCStart+0x40>
		ADCSRA |= _BV(ADIE);
    4ae4:	8a e7       	ldi	r24, 0x7A	; 122
    4ae6:	90 e0       	ldi	r25, 0x00	; 0
    4ae8:	2a e7       	ldi	r18, 0x7A	; 122
    4aea:	30 e0       	ldi	r19, 0x00	; 0
    4aec:	f9 01       	movw	r30, r18
    4aee:	20 81       	ld	r18, Z
    4af0:	28 60       	ori	r18, 0x08	; 8
    4af2:	fc 01       	movw	r30, r24
    4af4:	20 83       	st	Z, r18
		ADCSRA |= _BV(ADSC);
    4af6:	8a e7       	ldi	r24, 0x7A	; 122
    4af8:	90 e0       	ldi	r25, 0x00	; 0
    4afa:	2a e7       	ldi	r18, 0x7A	; 122
    4afc:	30 e0       	ldi	r19, 0x00	; 0
    4afe:	f9 01       	movw	r30, r18
    4b00:	20 81       	ld	r18, Z
    4b02:	20 64       	ori	r18, 0x40	; 64
    4b04:	fc 01       	movw	r30, r24
    4b06:	20 83       	st	Z, r18
	}
}
    4b08:	df 91       	pop	r29
    4b0a:	cf 91       	pop	r28
    4b0c:	08 95       	ret

00004b0e <__vector_29>:

//Read the finished value of the ADC and store it
ISR(ADC_vect) {
    4b0e:	1f 92       	push	r1
    4b10:	0f 92       	push	r0
    4b12:	00 90 5f 00 	lds	r0, 0x005F
    4b16:	0f 92       	push	r0
    4b18:	11 24       	eor	r1, r1
    4b1a:	00 90 5b 00 	lds	r0, 0x005B
    4b1e:	0f 92       	push	r0
    4b20:	2f 93       	push	r18
    4b22:	3f 93       	push	r19
    4b24:	4f 93       	push	r20
    4b26:	5f 93       	push	r21
    4b28:	6f 93       	push	r22
    4b2a:	7f 93       	push	r23
    4b2c:	8f 93       	push	r24
    4b2e:	9f 93       	push	r25
    4b30:	af 93       	push	r26
    4b32:	bf 93       	push	r27
    4b34:	ef 93       	push	r30
    4b36:	ff 93       	push	r31
    4b38:	cf 93       	push	r28
    4b3a:	df 93       	push	r29
    4b3c:	1f 92       	push	r1
    4b3e:	1f 92       	push	r1
    4b40:	cd b7       	in	r28, 0x3d	; 61
    4b42:	de b7       	in	r29, 0x3e	; 62
	int result = ADCL;
    4b44:	88 e7       	ldi	r24, 0x78	; 120
    4b46:	90 e0       	ldi	r25, 0x00	; 0
    4b48:	fc 01       	movw	r30, r24
    4b4a:	80 81       	ld	r24, Z
    4b4c:	88 2f       	mov	r24, r24
    4b4e:	90 e0       	ldi	r25, 0x00	; 0
    4b50:	9a 83       	std	Y+2, r25	; 0x02
    4b52:	89 83       	std	Y+1, r24	; 0x01
	result |= (ADCH << 8);
    4b54:	89 e7       	ldi	r24, 0x79	; 121
    4b56:	90 e0       	ldi	r25, 0x00	; 0
    4b58:	fc 01       	movw	r30, r24
    4b5a:	80 81       	ld	r24, Z
    4b5c:	88 2f       	mov	r24, r24
    4b5e:	90 e0       	ldi	r25, 0x00	; 0
    4b60:	98 2f       	mov	r25, r24
    4b62:	88 27       	eor	r24, r24
    4b64:	29 81       	ldd	r18, Y+1	; 0x01
    4b66:	3a 81       	ldd	r19, Y+2	; 0x02
    4b68:	82 2b       	or	r24, r18
    4b6a:	93 2b       	or	r25, r19
    4b6c:	9a 83       	std	Y+2, r25	; 0x02
    4b6e:	89 83       	std	Y+1, r24	; 0x01
	
	addResult(result);
    4b70:	89 81       	ldd	r24, Y+1	; 0x01
    4b72:	9a 81       	ldd	r25, Y+2	; 0x02
    4b74:	0e 94 ef 24 	call	0x49de	; 0x49de <addResult>
	
	ADCSRA &= ~(_BV(ADIE));
    4b78:	8a e7       	ldi	r24, 0x7A	; 122
    4b7a:	90 e0       	ldi	r25, 0x00	; 0
    4b7c:	2a e7       	ldi	r18, 0x7A	; 122
    4b7e:	30 e0       	ldi	r19, 0x00	; 0
    4b80:	f9 01       	movw	r30, r18
    4b82:	20 81       	ld	r18, Z
    4b84:	27 7f       	andi	r18, 0xF7	; 247
    4b86:	fc 01       	movw	r30, r24
    4b88:	20 83       	st	Z, r18

	xSemaphoreGiveFromISR(adcSemaphore,0);
    4b8a:	80 91 e7 1a 	lds	r24, 0x1AE7
    4b8e:	90 91 e8 1a 	lds	r25, 0x1AE8
    4b92:	20 e0       	ldi	r18, 0x00	; 0
    4b94:	40 e0       	ldi	r20, 0x00	; 0
    4b96:	50 e0       	ldi	r21, 0x00	; 0
    4b98:	60 e0       	ldi	r22, 0x00	; 0
    4b9a:	70 e0       	ldi	r23, 0x00	; 0
    4b9c:	0e 94 7e 0e 	call	0x1cfc	; 0x1cfc <xQueueGenericSendFromISR>
}
    4ba0:	0f 90       	pop	r0
    4ba2:	0f 90       	pop	r0
    4ba4:	df 91       	pop	r29
    4ba6:	cf 91       	pop	r28
    4ba8:	ff 91       	pop	r31
    4baa:	ef 91       	pop	r30
    4bac:	bf 91       	pop	r27
    4bae:	af 91       	pop	r26
    4bb0:	9f 91       	pop	r25
    4bb2:	8f 91       	pop	r24
    4bb4:	7f 91       	pop	r23
    4bb6:	6f 91       	pop	r22
    4bb8:	5f 91       	pop	r21
    4bba:	4f 91       	pop	r20
    4bbc:	3f 91       	pop	r19
    4bbe:	2f 91       	pop	r18
    4bc0:	0f 90       	pop	r0
    4bc2:	00 92 5b 00 	sts	0x005B, r0
    4bc6:	0f 90       	pop	r0
    4bc8:	00 92 5f 00 	sts	0x005F, r0
    4bcc:	0f 90       	pop	r0
    4bce:	1f 90       	pop	r1
    4bd0:	18 95       	reti

00004bd2 <vTaskADC>:

void vTaskADC(void *parameters){
    4bd2:	cf 93       	push	r28
    4bd4:	df 93       	push	r29
    4bd6:	1f 92       	push	r1
    4bd8:	1f 92       	push	r1
    4bda:	cd b7       	in	r28, 0x3d	; 61
    4bdc:	de b7       	in	r29, 0x3e	; 62
    4bde:	9a 83       	std	Y+2, r25	; 0x02
    4be0:	89 83       	std	Y+1, r24	; 0x01
	initADC();
    4be2:	0e 94 4e 25 	call	0x4a9c	; 0x4a9c <initADC>

	vSemaphoreCreateBinary(adcSemaphore);
    4be6:	43 e0       	ldi	r20, 0x03	; 3
    4be8:	60 e0       	ldi	r22, 0x00	; 0
    4bea:	81 e0       	ldi	r24, 0x01	; 1
    4bec:	0e 94 23 0d 	call	0x1a46	; 0x1a46 <xQueueGenericCreate>
    4bf0:	90 93 e8 1a 	sts	0x1AE8, r25
    4bf4:	80 93 e7 1a 	sts	0x1AE7, r24
    4bf8:	80 91 e7 1a 	lds	r24, 0x1AE7
    4bfc:	90 91 e8 1a 	lds	r25, 0x1AE8
    4c00:	00 97       	sbiw	r24, 0x00	; 0
    4c02:	59 f0       	breq	.+22     	; 0x4c1a <vTaskADC+0x48>
    4c04:	80 91 e7 1a 	lds	r24, 0x1AE7
    4c08:	90 91 e8 1a 	lds	r25, 0x1AE8
    4c0c:	20 e0       	ldi	r18, 0x00	; 0
    4c0e:	40 e0       	ldi	r20, 0x00	; 0
    4c10:	50 e0       	ldi	r21, 0x00	; 0
    4c12:	60 e0       	ldi	r22, 0x00	; 0
    4c14:	70 e0       	ldi	r23, 0x00	; 0
    4c16:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <xQueueGenericSend>

	while(1){
		ADCStart();
    4c1a:	0e 94 64 25 	call	0x4ac8	; 0x4ac8 <ADCStart>
		xSemaphoreTake(adcSemaphore,portMAX_DELAY);
    4c1e:	80 91 e7 1a 	lds	r24, 0x1AE7
    4c22:	90 91 e8 1a 	lds	r25, 0x1AE8
    4c26:	20 e0       	ldi	r18, 0x00	; 0
    4c28:	4f ef       	ldi	r20, 0xFF	; 255
    4c2a:	5f ef       	ldi	r21, 0xFF	; 255
    4c2c:	60 e0       	ldi	r22, 0x00	; 0
    4c2e:	70 e0       	ldi	r23, 0x00	; 0
    4c30:	0e 94 d7 0e 	call	0x1dae	; 0x1dae <xQueueGenericReceive>
	}
    4c34:	f2 cf       	rjmp	.-28     	; 0x4c1a <vTaskADC+0x48>

00004c36 <__tablejump2__>:
    4c36:	ee 0f       	add	r30, r30
    4c38:	ff 1f       	adc	r31, r31

00004c3a <__tablejump__>:
    4c3a:	05 90       	lpm	r0, Z+
    4c3c:	f4 91       	lpm	r31, Z
    4c3e:	e0 2d       	mov	r30, r0
    4c40:	19 94       	eijmp

00004c42 <memcpy>:
    4c42:	fb 01       	movw	r30, r22
    4c44:	dc 01       	movw	r26, r24
    4c46:	02 c0       	rjmp	.+4      	; 0x4c4c <memcpy+0xa>
    4c48:	01 90       	ld	r0, Z+
    4c4a:	0d 92       	st	X+, r0
    4c4c:	41 50       	subi	r20, 0x01	; 1
    4c4e:	50 40       	sbci	r21, 0x00	; 0
    4c50:	d8 f7       	brcc	.-10     	; 0x4c48 <memcpy+0x6>
    4c52:	08 95       	ret

00004c54 <memset>:
    4c54:	dc 01       	movw	r26, r24
    4c56:	01 c0       	rjmp	.+2      	; 0x4c5a <memset+0x6>
    4c58:	6d 93       	st	X+, r22
    4c5a:	41 50       	subi	r20, 0x01	; 1
    4c5c:	50 40       	sbci	r21, 0x00	; 0
    4c5e:	e0 f7       	brcc	.-8      	; 0x4c58 <memset+0x4>
    4c60:	08 95       	ret

00004c62 <strncpy>:
    4c62:	fb 01       	movw	r30, r22
    4c64:	dc 01       	movw	r26, r24
    4c66:	41 50       	subi	r20, 0x01	; 1
    4c68:	50 40       	sbci	r21, 0x00	; 0
    4c6a:	48 f0       	brcs	.+18     	; 0x4c7e <strncpy+0x1c>
    4c6c:	01 90       	ld	r0, Z+
    4c6e:	0d 92       	st	X+, r0
    4c70:	00 20       	and	r0, r0
    4c72:	c9 f7       	brne	.-14     	; 0x4c66 <strncpy+0x4>
    4c74:	01 c0       	rjmp	.+2      	; 0x4c78 <strncpy+0x16>
    4c76:	1d 92       	st	X+, r1
    4c78:	41 50       	subi	r20, 0x01	; 1
    4c7a:	50 40       	sbci	r21, 0x00	; 0
    4c7c:	e0 f7       	brcc	.-8      	; 0x4c76 <strncpy+0x14>
    4c7e:	08 95       	ret

00004c80 <itoa>:
    4c80:	fb 01       	movw	r30, r22
    4c82:	9f 01       	movw	r18, r30
    4c84:	e8 94       	clt
    4c86:	42 30       	cpi	r20, 0x02	; 2
    4c88:	c4 f0       	brlt	.+48     	; 0x4cba <itoa+0x3a>
    4c8a:	45 32       	cpi	r20, 0x25	; 37
    4c8c:	b4 f4       	brge	.+44     	; 0x4cba <itoa+0x3a>
    4c8e:	4a 30       	cpi	r20, 0x0A	; 10
    4c90:	29 f4       	brne	.+10     	; 0x4c9c <itoa+0x1c>
    4c92:	97 fb       	bst	r25, 7
    4c94:	1e f4       	brtc	.+6      	; 0x4c9c <itoa+0x1c>
    4c96:	90 95       	com	r25
    4c98:	81 95       	neg	r24
    4c9a:	9f 4f       	sbci	r25, 0xFF	; 255
    4c9c:	64 2f       	mov	r22, r20
    4c9e:	77 27       	eor	r23, r23
    4ca0:	0e 94 71 26 	call	0x4ce2	; 0x4ce2 <__udivmodhi4>
    4ca4:	80 5d       	subi	r24, 0xD0	; 208
    4ca6:	8a 33       	cpi	r24, 0x3A	; 58
    4ca8:	0c f0       	brlt	.+2      	; 0x4cac <itoa+0x2c>
    4caa:	89 5d       	subi	r24, 0xD9	; 217
    4cac:	81 93       	st	Z+, r24
    4cae:	cb 01       	movw	r24, r22
    4cb0:	00 97       	sbiw	r24, 0x00	; 0
    4cb2:	a1 f7       	brne	.-24     	; 0x4c9c <itoa+0x1c>
    4cb4:	16 f4       	brtc	.+4      	; 0x4cba <itoa+0x3a>
    4cb6:	5d e2       	ldi	r21, 0x2D	; 45
    4cb8:	51 93       	st	Z+, r21
    4cba:	10 82       	st	Z, r1
    4cbc:	c9 01       	movw	r24, r18
    4cbe:	0c 94 61 26 	jmp	0x4cc2	; 0x4cc2 <strrev>

00004cc2 <strrev>:
    4cc2:	dc 01       	movw	r26, r24
    4cc4:	fc 01       	movw	r30, r24
    4cc6:	67 2f       	mov	r22, r23
    4cc8:	71 91       	ld	r23, Z+
    4cca:	77 23       	and	r23, r23
    4ccc:	e1 f7       	brne	.-8      	; 0x4cc6 <strrev+0x4>
    4cce:	32 97       	sbiw	r30, 0x02	; 2
    4cd0:	04 c0       	rjmp	.+8      	; 0x4cda <strrev+0x18>
    4cd2:	7c 91       	ld	r23, X
    4cd4:	6d 93       	st	X+, r22
    4cd6:	70 83       	st	Z, r23
    4cd8:	62 91       	ld	r22, -Z
    4cda:	ae 17       	cp	r26, r30
    4cdc:	bf 07       	cpc	r27, r31
    4cde:	c8 f3       	brcs	.-14     	; 0x4cd2 <strrev+0x10>
    4ce0:	08 95       	ret

00004ce2 <__udivmodhi4>:
    4ce2:	aa 1b       	sub	r26, r26
    4ce4:	bb 1b       	sub	r27, r27
    4ce6:	51 e1       	ldi	r21, 0x11	; 17
    4ce8:	07 c0       	rjmp	.+14     	; 0x4cf8 <__udivmodhi4_ep>

00004cea <__udivmodhi4_loop>:
    4cea:	aa 1f       	adc	r26, r26
    4cec:	bb 1f       	adc	r27, r27
    4cee:	a6 17       	cp	r26, r22
    4cf0:	b7 07       	cpc	r27, r23
    4cf2:	10 f0       	brcs	.+4      	; 0x4cf8 <__udivmodhi4_ep>
    4cf4:	a6 1b       	sub	r26, r22
    4cf6:	b7 0b       	sbc	r27, r23

00004cf8 <__udivmodhi4_ep>:
    4cf8:	88 1f       	adc	r24, r24
    4cfa:	99 1f       	adc	r25, r25
    4cfc:	5a 95       	dec	r21
    4cfe:	a9 f7       	brne	.-22     	; 0x4cea <__udivmodhi4_loop>
    4d00:	80 95       	com	r24
    4d02:	90 95       	com	r25
    4d04:	bc 01       	movw	r22, r24
    4d06:	cd 01       	movw	r24, r26
    4d08:	08 95       	ret

00004d0a <_exit>:
    4d0a:	f8 94       	cli

00004d0c <__stop_program>:
    4d0c:	ff cf       	rjmp	.-2      	; 0x4d0c <__stop_program>
