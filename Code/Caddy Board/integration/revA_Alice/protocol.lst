   1               		.file	"protocol.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
  68               	.global	commandIntegCheck
  70               	commandIntegCheck:
  71               		.stabd	46,0,0
   1:protocol.c    **** /**
   2:protocol.c    ****  * Skeleton of command recieve and response
   3:protocol.c    ****  *
   4:protocol.c    ****  * @author Louie Thiros
   5:protocol.c    ****  */
   6:protocol.c    **** 
   7:protocol.c    **** #include "protocol.h"
   8:protocol.c    **** #include "Components/Sonar/Sonar.h"
   9:protocol.c    **** 
  10:protocol.c    **** 
  11:protocol.c    **** //function to CRC the command structure
  12:protocol.c    **** char commandIntegCheck(Command *command) {
  73               	.LM0:
  74               	.LFBB1:
  75 0000 CF93      		push r28
  76 0002 DF93      		push r29
  77 0004 1F92      		push __zero_reg__
  78 0006 1F92      		push __zero_reg__
  79 0008 CDB7      		in r28,__SP_L__
  80 000a DEB7      		in r29,__SP_H__
  81               	/* prologue: function */
  82               	/* frame size = 2 */
  83               	/* stack size = 4 */
  84               	.L__stack_usage = 4
  85 000c 9A83      		std Y+2,r25
  86 000e 8983      		std Y+1,r24
  13:protocol.c    ****    //CRC the command with 0x00 in place of the CRC
  14:protocol.c    ****    //return success for now
  15:protocol.c    ****    return 1;
  88               	.LM1:
  89 0010 81E0      		ldi r24,lo8(1)
  90               	/* epilogue start */
  16:protocol.c    **** }
  92               	.LM2:
  93 0012 0F90      		pop __tmp_reg__
  94 0014 0F90      		pop __tmp_reg__
  95 0016 DF91      		pop r29
  96 0018 CF91      		pop r28
  97 001a 0895      		ret
  99               	.Lscope1:
 101               		.stabd	78,0,0
 107               	.global	processUltrasonicCommand
 109               	processUltrasonicCommand:
 110               		.stabd	46,0,0
  17:protocol.c    **** 
  18:protocol.c    **** char processUltrasonicCommand(char commandCode, void* commandData,char* size, void* responseData) {
 112               	.LM3:
 113               	.LFBB2:
 114 001c CF93      		push r28
 115 001e DF93      		push r29
 116 0020 CDB7      		in r28,__SP_L__
 117 0022 DEB7      		in r29,__SP_H__
 118 0024 2797      		sbiw r28,7
 119 0026 0FB6      		in __tmp_reg__,__SREG__
 120 0028 F894      		cli
 121 002a DEBF      		out __SP_H__,r29
 122 002c 0FBE      		out __SREG__,__tmp_reg__
 123 002e CDBF      		out __SP_L__,r28
 124               	/* prologue: function */
 125               	/* frame size = 7 */
 126               	/* stack size = 9 */
 127               	.L__stack_usage = 9
 128 0030 8983      		std Y+1,r24
 129 0032 7B83      		std Y+3,r23
 130 0034 6A83      		std Y+2,r22
 131 0036 5D83      		std Y+5,r21
 132 0038 4C83      		std Y+4,r20
 133 003a 3F83      		std Y+7,r19
 134 003c 2E83      		std Y+6,r18
  19:protocol.c    ****    switch(commandCode) {
 136               	.LM4:
 137 003e 8981      		ldd r24,Y+1
 138 0040 9927      		clr r25
 139 0042 87FD      		sbrc r24,7
 140 0044 9095      		com r25
 141 0046 8230      		cpi r24,2
 142 0048 9105      		cpc r25,__zero_reg__
 143 004a 01F0      		breq .L5
 144 004c 8330      		cpi r24,3
 145 004e 9105      		cpc r25,__zero_reg__
 146 0050 01F0      		breq .L6
 147 0052 8130      		cpi r24,1
 148 0054 9105      		cpc r25,__zero_reg__
 149 0056 01F4      		brne .L4
  20:protocol.c    ****       case GET_ALL_SENSORS:
  21:protocol.c    ****          getAllSensors((int*) responseData);
 151               	.LM5:
 152 0058 8E81      		ldd r24,Y+6
 153 005a 9F81      		ldd r25,Y+7
 154 005c 0E94 0000 		call getAllSensors
  22:protocol.c    ****          *size = 12;
 156               	.LM6:
 157 0060 8C81      		ldd r24,Y+4
 158 0062 9D81      		ldd r25,Y+5
 159 0064 2CE0      		ldi r18,lo8(12)
 160 0066 FC01      		movw r30,r24
 161 0068 2083      		st Z,r18
  23:protocol.c    ****          break;
 163               	.LM7:
 164 006a 00C0      		rjmp .L4
 165               	.L5:
  24:protocol.c    ****       case GET_CERTAIN_SENSORS:
  25:protocol.c    ****          getCertainSensor(((char*)commandData)[0], (int*) responseData);
 167               	.LM8:
 168 006c 8A81      		ldd r24,Y+2
 169 006e 9B81      		ldd r25,Y+3
 170 0070 FC01      		movw r30,r24
 171 0072 2081      		ld r18,Z
 172 0074 8E81      		ldd r24,Y+6
 173 0076 9F81      		ldd r25,Y+7
 174 0078 BC01      		movw r22,r24
 175 007a 822F      		mov r24,r18
 176 007c 0E94 0000 		call getCertainSensor
  26:protocol.c    ****          break;
 178               	.LM9:
 179 0080 00C0      		rjmp .L4
 180               	.L6:
  27:protocol.c    ****       case GET_SENSOR_GROUP:
  28:protocol.c    ****          getSensorGroup(((char*)commandData)[0], (int*) responseData);
 182               	.LM10:
 183 0082 8A81      		ldd r24,Y+2
 184 0084 9B81      		ldd r25,Y+3
 185 0086 FC01      		movw r30,r24
 186 0088 2081      		ld r18,Z
 187 008a 8E81      		ldd r24,Y+6
 188 008c 9F81      		ldd r25,Y+7
 189 008e BC01      		movw r22,r24
 190 0090 822F      		mov r24,r18
 191 0092 0E94 0000 		call getSensorGroup
  29:protocol.c    ****          break;
 193               	.LM11:
 194 0096 0000      		nop
 195               	.L4:
  30:protocol.c    ****    }
  31:protocol.c    ****    //return success for now...
  32:protocol.c    ****    return 1;
 197               	.LM12:
 198 0098 81E0      		ldi r24,lo8(1)
 199               	/* epilogue start */
  33:protocol.c    **** }
 201               	.LM13:
 202 009a 2796      		adiw r28,7
 203 009c 0FB6      		in __tmp_reg__,__SREG__
 204 009e F894      		cli
 205 00a0 DEBF      		out __SP_H__,r29
 206 00a2 0FBE      		out __SREG__,__tmp_reg__
 207 00a4 CDBF      		out __SP_L__,r28
 208 00a6 DF91      		pop r29
 209 00a8 CF91      		pop r28
 210 00aa 0895      		ret
 212               	.Lscope2:
 214               		.stabd	78,0,0
 219               	.global	processSpeedCommand
 221               	processSpeedCommand:
 222               		.stabd	46,0,0
  34:protocol.c    **** 
  35:protocol.c    **** char processSpeedCommand(char commandCode, void* commandData, void* responseData) {
 224               	.LM14:
 225               	.LFBB3:
 226 00ac CF93      		push r28
 227 00ae DF93      		push r29
 228 00b0 00D0      		rcall .
 229 00b2 1F92      		push __zero_reg__
 230 00b4 1F92      		push __zero_reg__
 231 00b6 CDB7      		in r28,__SP_L__
 232 00b8 DEB7      		in r29,__SP_H__
 233               	/* prologue: function */
 234               	/* frame size = 5 */
 235               	/* stack size = 7 */
 236               	.L__stack_usage = 7
 237 00ba 8983      		std Y+1,r24
 238 00bc 7B83      		std Y+3,r23
 239 00be 6A83      		std Y+2,r22
 240 00c0 5D83      		std Y+5,r21
 241 00c2 4C83      		std Y+4,r20
  36:protocol.c    ****    switch(commandCode) {
 243               	.LM15:
 244 00c4 8981      		ldd r24,Y+1
 245 00c6 9927      		clr r25
 246 00c8 87FD      		sbrc r24,7
 247 00ca 9095      		com r25
 248 00cc 0097      		sbiw r24,0
 249 00ce 01F0      		breq .L11
 250 00d0 8130      		cpi r24,1
 251 00d2 9105      		cpc r25,__zero_reg__
 252 00d4 01F0      		breq .L12
 253 00d6 00C0      		rjmp .L10
 254               	.L11:
 255               	.LBB2:
  37:protocol.c    ****       case GET_SPEED:
  38:protocol.c    ****          getSpeed((char*) responseData);
 257               	.LM16:
 258 00d8 8C81      		ldd r24,Y+4
 259 00da 9D81      		ldd r25,Y+5
 260 00dc 0E94 0000 		call getSpeed
  39:protocol.c    ****          break;
 262               	.LM17:
 263 00e0 00C0      		rjmp .L10
 264               	.L12:
  40:protocol.c    ****       case SET_SPEED:
  41:protocol.c    ****          setSpeed(((char*)commandData)[0]);
 266               	.LM18:
 267 00e2 8A81      		ldd r24,Y+2
 268 00e4 9B81      		ldd r25,Y+3
 269 00e6 FC01      		movw r30,r24
 270 00e8 8081      		ld r24,Z
 271 00ea 9927      		clr r25
 272 00ec 87FD      		sbrc r24,7
 273 00ee 9095      		com r25
 274 00f0 0E94 0000 		call setSpeed
  42:protocol.c    ****          break;
 276               	.LM19:
 277 00f4 0000      		nop
 278               	.L10:
 279               	.LBE2:
  43:protocol.c    ****    }
  44:protocol.c    ****    //return success for now
  45:protocol.c    ****    return 1;
 281               	.LM20:
 282 00f6 81E0      		ldi r24,lo8(1)
 283               	/* epilogue start */
  46:protocol.c    **** }
 285               	.LM21:
 286 00f8 0F90      		pop __tmp_reg__
 287 00fa 0F90      		pop __tmp_reg__
 288 00fc 0F90      		pop __tmp_reg__
 289 00fe 0F90      		pop __tmp_reg__
 290 0100 0F90      		pop __tmp_reg__
 291 0102 DF91      		pop r29
 292 0104 CF91      		pop r28
 293 0106 0895      		ret
 295               	.Lscope3:
 297               		.stabd	78,0,0
 302               	.global	processSteeringCommand
 304               	processSteeringCommand:
 305               		.stabd	46,0,0
  47:protocol.c    **** 
  48:protocol.c    **** char processSteeringCommand(char commandCode, void* commandData, void* responseData) {
 307               	.LM22:
 308               	.LFBB4:
 309 0108 CF93      		push r28
 310 010a DF93      		push r29
 311 010c 00D0      		rcall .
 312 010e 1F92      		push __zero_reg__
 313 0110 1F92      		push __zero_reg__
 314 0112 CDB7      		in r28,__SP_L__
 315 0114 DEB7      		in r29,__SP_H__
 316               	/* prologue: function */
 317               	/* frame size = 5 */
 318               	/* stack size = 7 */
 319               	.L__stack_usage = 7
 320 0116 8983      		std Y+1,r24
 321 0118 7B83      		std Y+3,r23
 322 011a 6A83      		std Y+2,r22
 323 011c 5D83      		std Y+5,r21
 324 011e 4C83      		std Y+4,r20
  49:protocol.c    ****    switch(commandCode) {
 326               	.LM23:
 327 0120 8981      		ldd r24,Y+1
 328 0122 9927      		clr r25
 329 0124 87FD      		sbrc r24,7
 330 0126 9095      		com r25
 331 0128 8230      		cpi r24,2
 332 012a 9105      		cpc r25,__zero_reg__
 333 012c 01F0      		breq .L16
 334 012e 8330      		cpi r24,3
 335 0130 9105      		cpc r25,__zero_reg__
 336 0132 04F4      		brge .L17
 337 0134 0097      		sbiw r24,0
 338 0136 01F0      		breq .L18
 339 0138 8130      		cpi r24,1
 340 013a 9105      		cpc r25,__zero_reg__
 341 013c 01F0      		breq .L19
 342 013e 00C0      		rjmp .L15
 343               	.L17:
 344 0140 8330      		cpi r24,3
 345 0142 9105      		cpc r25,__zero_reg__
 346 0144 01F0      		breq .L20
 347 0146 8430      		cpi r24,4
 348 0148 9105      		cpc r25,__zero_reg__
 349 014a 01F0      		breq .L21
 350 014c 00C0      		rjmp .L15
 351               	.L18:
 352               	.LBB3:
  50:protocol.c    ****       case SET_ANGLE:
  51:protocol.c    ****          setAngle(*((char*)commandData));
 354               	.LM24:
 355 014e 8A81      		ldd r24,Y+2
 356 0150 9B81      		ldd r25,Y+3
 357 0152 FC01      		movw r30,r24
 358 0154 8081      		ld r24,Z
 359 0156 9927      		clr r25
 360 0158 87FD      		sbrc r24,7
 361 015a 9095      		com r25
 362 015c 0E94 0000 		call setAngle
  52:protocol.c    ****          break;
 364               	.LM25:
 365 0160 00C0      		rjmp .L15
 366               	.L19:
  53:protocol.c    ****       case GET_ANGLE:
  54:protocol.c    ****          getAngle((char*) responseData);
 368               	.LM26:
 369 0162 8C81      		ldd r24,Y+4
 370 0164 9D81      		ldd r25,Y+5
 371 0166 0E94 0000 		call getAngle
  55:protocol.c    ****          break;
 373               	.LM27:
 374 016a 00C0      		rjmp .L15
 375               	.L16:
  56:protocol.c    ****       case GET_DESIRED_ANGLE:
  57:protocol.c    ****          getDesiredAngle((char*) responseData);
 377               	.LM28:
 378 016c 8C81      		ldd r24,Y+4
 379 016e 9D81      		ldd r25,Y+5
 380 0170 0E94 0000 		call getDesiredAngle
  58:protocol.c    ****          break;
 382               	.LM29:
 383 0174 00C0      		rjmp .L15
 384               	.L20:
  59:protocol.c    ****       case CHANGE_PID:
  60:protocol.c    ****          changePID(((char*)commandData)[0], ((char*)commandData)[1], ((char*)commandData)[2]);
 386               	.LM30:
 387 0176 8A81      		ldd r24,Y+2
 388 0178 9B81      		ldd r25,Y+3
 389 017a 0296      		adiw r24,2
 390 017c FC01      		movw r30,r24
 391 017e 8081      		ld r24,Z
 392 0180 482F      		mov r20,r24
 393 0182 5527      		clr r21
 394 0184 47FD      		sbrc r20,7
 395 0186 5095      		com r21
 396 0188 8A81      		ldd r24,Y+2
 397 018a 9B81      		ldd r25,Y+3
 398 018c 0196      		adiw r24,1
 399 018e FC01      		movw r30,r24
 400 0190 8081      		ld r24,Z
 401 0192 282F      		mov r18,r24
 402 0194 3327      		clr r19
 403 0196 27FD      		sbrc r18,7
 404 0198 3095      		com r19
 405 019a 8A81      		ldd r24,Y+2
 406 019c 9B81      		ldd r25,Y+3
 407 019e FC01      		movw r30,r24
 408 01a0 8081      		ld r24,Z
 409 01a2 9927      		clr r25
 410 01a4 87FD      		sbrc r24,7
 411 01a6 9095      		com r25
 412 01a8 B901      		movw r22,r18
 413 01aa 0E94 0000 		call changePID
  61:protocol.c    ****          break;
 415               	.LM31:
 416 01ae 00C0      		rjmp .L15
 417               	.L21:
  62:protocol.c    ****       case SET_LIMITS:
  63:protocol.c    ****          setLimits(((char*)commandData)[0], ((char*)commandData)[1]);
 419               	.LM32:
 420 01b0 8A81      		ldd r24,Y+2
 421 01b2 9B81      		ldd r25,Y+3
 422 01b4 0196      		adiw r24,1
 423 01b6 FC01      		movw r30,r24
 424 01b8 8081      		ld r24,Z
 425 01ba 282F      		mov r18,r24
 426 01bc 3327      		clr r19
 427 01be 27FD      		sbrc r18,7
 428 01c0 3095      		com r19
 429 01c2 8A81      		ldd r24,Y+2
 430 01c4 9B81      		ldd r25,Y+3
 431 01c6 FC01      		movw r30,r24
 432 01c8 8081      		ld r24,Z
 433 01ca 9927      		clr r25
 434 01cc 87FD      		sbrc r24,7
 435 01ce 9095      		com r25
 436 01d0 B901      		movw r22,r18
 437 01d2 0E94 0000 		call setLimits
  64:protocol.c    ****          break;
 439               	.LM33:
 440 01d6 0000      		nop
 441               	.L15:
 442               	.LBE3:
  65:protocol.c    ****    }
  66:protocol.c    ****    //return success for now
  67:protocol.c    ****    return 1;
 444               	.LM34:
 445 01d8 81E0      		ldi r24,lo8(1)
 446               	/* epilogue start */
  68:protocol.c    **** }
 448               	.LM35:
 449 01da 0F90      		pop __tmp_reg__
 450 01dc 0F90      		pop __tmp_reg__
 451 01de 0F90      		pop __tmp_reg__
 452 01e0 0F90      		pop __tmp_reg__
 453 01e2 0F90      		pop __tmp_reg__
 454 01e4 DF91      		pop r29
 455 01e6 CF91      		pop r28
 456 01e8 0895      		ret
 458               	.Lscope4:
 460               		.stabd	78,0,0
 465               	.global	processFNRCommand
 467               	processFNRCommand:
 468               		.stabd	46,0,0
  69:protocol.c    **** 
  70:protocol.c    **** char processFNRCommand(char commandCode, void* commandData, void* responseData) {
 470               	.LM36:
 471               	.LFBB5:
 472 01ea CF93      		push r28
 473 01ec DF93      		push r29
 474 01ee 00D0      		rcall .
 475 01f0 1F92      		push __zero_reg__
 476 01f2 1F92      		push __zero_reg__
 477 01f4 CDB7      		in r28,__SP_L__
 478 01f6 DEB7      		in r29,__SP_H__
 479               	/* prologue: function */
 480               	/* frame size = 5 */
 481               	/* stack size = 7 */
 482               	.L__stack_usage = 7
 483 01f8 8983      		std Y+1,r24
 484 01fa 7B83      		std Y+3,r23
 485 01fc 6A83      		std Y+2,r22
 486 01fe 5D83      		std Y+5,r21
 487 0200 4C83      		std Y+4,r20
  71:protocol.c    ****    switch(commandCode) {
 489               	.LM37:
 490 0202 8981      		ldd r24,Y+1
 491 0204 9927      		clr r25
 492 0206 87FD      		sbrc r24,7
 493 0208 9095      		com r25
 494 020a 0097      		sbiw r24,0
 495 020c 01F0      		breq .L25
 496 020e 8130      		cpi r24,1
 497 0210 9105      		cpc r25,__zero_reg__
 498 0212 01F0      		breq .L26
 499 0214 00C0      		rjmp .L27
 500               	.L25:
 501               	.LBB4:
  72:protocol.c    ****       case SET_FNR:
  73:protocol.c    ****          setFNR(*((char*)commandData));
 503               	.LM38:
 504 0216 8A81      		ldd r24,Y+2
 505 0218 9B81      		ldd r25,Y+3
 506 021a FC01      		movw r30,r24
 507 021c 8081      		ld r24,Z
 508 021e 9927      		clr r25
 509 0220 87FD      		sbrc r24,7
 510 0222 9095      		com r25
 511 0224 0E94 0000 		call setFNR
  74:protocol.c    ****          break;
 513               	.LM39:
 514 0228 00C0      		rjmp .L27
 515               	.L26:
  75:protocol.c    ****       case GET_FNR:
  76:protocol.c    ****          getFNR((char*) responseData);
 517               	.LM40:
 518 022a 8C81      		ldd r24,Y+4
 519 022c 9D81      		ldd r25,Y+5
 520 022e 0E94 0000 		call getFNR
  77:protocol.c    ****          break;
 522               	.LM41:
 523 0232 0000      		nop
 524               	.L27:
 525               	/* epilogue start */
 526               	.LBE4:
  78:protocol.c    ****    }
  79:protocol.c    **** }
 528               	.LM42:
 529 0234 0F90      		pop __tmp_reg__
 530 0236 0F90      		pop __tmp_reg__
 531 0238 0F90      		pop __tmp_reg__
 532 023a 0F90      		pop __tmp_reg__
 533 023c 0F90      		pop __tmp_reg__
 534 023e DF91      		pop r29
 535 0240 CF91      		pop r28
 536 0242 0895      		ret
 538               	.Lscope5:
 540               		.stabd	78,0,0
 545               	.global	processBrakeCommand
 547               	processBrakeCommand:
 548               		.stabd	46,0,0
  80:protocol.c    **** 
  81:protocol.c    **** char processBrakeCommand(char commandCode, void* commandData, void* responseData) {
 550               	.LM43:
 551               	.LFBB6:
 552 0244 CF93      		push r28
 553 0246 DF93      		push r29
 554 0248 00D0      		rcall .
 555 024a 1F92      		push __zero_reg__
 556 024c 1F92      		push __zero_reg__
 557 024e CDB7      		in r28,__SP_L__
 558 0250 DEB7      		in r29,__SP_H__
 559               	/* prologue: function */
 560               	/* frame size = 5 */
 561               	/* stack size = 7 */
 562               	.L__stack_usage = 7
 563 0252 8983      		std Y+1,r24
 564 0254 7B83      		std Y+3,r23
 565 0256 6A83      		std Y+2,r22
 566 0258 5D83      		std Y+5,r21
 567 025a 4C83      		std Y+4,r20
  82:protocol.c    ****    switch(commandCode) {
 569               	.LM44:
 570 025c 8981      		ldd r24,Y+1
 571 025e 9927      		clr r25
 572 0260 87FD      		sbrc r24,7
 573 0262 9095      		com r25
 574 0264 0097      		sbiw r24,0
 575 0266 01F0      		breq .L30
 576 0268 8130      		cpi r24,1
 577 026a 9105      		cpc r25,__zero_reg__
 578 026c 01F0      		breq .L31
 579 026e 00C0      		rjmp .L32
 580               	.L30:
 581               	.LBB5:
  83:protocol.c    ****       case SET_BRAKE:
  84:protocol.c    **** 	 setBrake(*((char*)commandData));
 583               	.LM45:
 584 0270 8A81      		ldd r24,Y+2
 585 0272 9B81      		ldd r25,Y+3
 586 0274 FC01      		movw r30,r24
 587 0276 8081      		ld r24,Z
 588 0278 9927      		clr r25
 589 027a 87FD      		sbrc r24,7
 590 027c 9095      		com r25
 591 027e 0E94 0000 		call setBrake
  85:protocol.c    **** 	 break;
 593               	.LM46:
 594 0282 00C0      		rjmp .L32
 595               	.L31:
  86:protocol.c    ****       case GET_BRAKE:
  87:protocol.c    **** 	 getBrake((char*) responseData);
 597               	.LM47:
 598 0284 8C81      		ldd r24,Y+4
 599 0286 9D81      		ldd r25,Y+5
 600 0288 0E94 0000 		call getBrake
  88:protocol.c    **** 	 break; 
 602               	.LM48:
 603 028c 0000      		nop
 604               	.L32:
 605               	/* epilogue start */
 606               	.LBE5:
  89:protocol.c    ****    }
  90:protocol.c    **** }
 608               	.LM49:
 609 028e 0F90      		pop __tmp_reg__
 610 0290 0F90      		pop __tmp_reg__
 611 0292 0F90      		pop __tmp_reg__
 612 0294 0F90      		pop __tmp_reg__
 613 0296 0F90      		pop __tmp_reg__
 614 0298 DF91      		pop r29
 615 029a CF91      		pop r28
 616 029c 0895      		ret
 618               	.Lscope6:
 620               		.stabd	78,0,0
 625               	.global	processBatteryCommand
 627               	processBatteryCommand:
 628               		.stabd	46,0,0
  91:protocol.c    **** 
  92:protocol.c    **** char processBatteryCommand(char commandCode, void* commandData, void* responseData) {
 630               	.LM50:
 631               	.LFBB7:
 632 029e CF93      		push r28
 633 02a0 DF93      		push r29
 634 02a2 00D0      		rcall .
 635 02a4 1F92      		push __zero_reg__
 636 02a6 1F92      		push __zero_reg__
 637 02a8 CDB7      		in r28,__SP_L__
 638 02aa DEB7      		in r29,__SP_H__
 639               	/* prologue: function */
 640               	/* frame size = 5 */
 641               	/* stack size = 7 */
 642               	.L__stack_usage = 7
 643 02ac 8983      		std Y+1,r24
 644 02ae 7B83      		std Y+3,r23
 645 02b0 6A83      		std Y+2,r22
 646 02b2 5D83      		std Y+5,r21
 647 02b4 4C83      		std Y+4,r20
  93:protocol.c    ****    switch(commandCode) {
 649               	.LM51:
 650 02b6 8981      		ldd r24,Y+1
 651 02b8 9927      		clr r25
 652 02ba 87FD      		sbrc r24,7
 653 02bc 9095      		com r25
 654 02be 0097      		sbiw r24,0
 655 02c0 01F0      		breq .L35
 656 02c2 8130      		cpi r24,1
 657 02c4 9105      		cpc r25,__zero_reg__
 658 02c6 01F0      		breq .L36
 659 02c8 00C0      		rjmp .L37
 660               	.L35:
 661               	.LBB6:
  94:protocol.c    ****       case GET_BATTERY_VOLTAGE:
  95:protocol.c    ****          getBatteryVoltage((char*) responseData);
 663               	.LM52:
 664 02ca 8C81      		ldd r24,Y+4
 665 02cc 9D81      		ldd r25,Y+5
 666 02ce 0E94 0000 		call getBatteryVoltage
  96:protocol.c    ****          break;
 668               	.LM53:
 669 02d2 00C0      		rjmp .L37
 670               	.L36:
  97:protocol.c    ****       case GET_STEERING_VOLTAGE:
  98:protocol.c    ****          getSteeringVoltage((char*) responseData);
 672               	.LM54:
 673 02d4 8C81      		ldd r24,Y+4
 674 02d6 9D81      		ldd r25,Y+5
 675 02d8 0E94 0000 		call getSteeringVoltage
  99:protocol.c    ****          break;
 677               	.LM55:
 678 02dc 0000      		nop
 679               	.L37:
 680               	/* epilogue start */
 681               	.LBE6:
 100:protocol.c    ****    }
 101:protocol.c    **** }
 683               	.LM56:
 684 02de 0F90      		pop __tmp_reg__
 685 02e0 0F90      		pop __tmp_reg__
 686 02e2 0F90      		pop __tmp_reg__
 687 02e4 0F90      		pop __tmp_reg__
 688 02e6 0F90      		pop __tmp_reg__
 689 02e8 DF91      		pop r29
 690 02ea CF91      		pop r28
 691 02ec 0895      		ret
 693               	.Lscope7:
 695               		.stabd	78,0,0
 700               	.global	processLightCommand
 702               	processLightCommand:
 703               		.stabd	46,0,0
 102:protocol.c    **** 
 103:protocol.c    **** char processLightCommand(char commandCode, void* commandData, Response* responseData) {
 705               	.LM57:
 706               	.LFBB8:
 707 02ee CF93      		push r28
 708 02f0 DF93      		push r29
 709 02f2 00D0      		rcall .
 710 02f4 1F92      		push __zero_reg__
 711 02f6 1F92      		push __zero_reg__
 712 02f8 CDB7      		in r28,__SP_L__
 713 02fa DEB7      		in r29,__SP_H__
 714               	/* prologue: function */
 715               	/* frame size = 5 */
 716               	/* stack size = 7 */
 717               	.L__stack_usage = 7
 718 02fc 8983      		std Y+1,r24
 719 02fe 7B83      		std Y+3,r23
 720 0300 6A83      		std Y+2,r22
 721 0302 5D83      		std Y+5,r21
 722 0304 4C83      		std Y+4,r20
 104:protocol.c    **** 	responseData->size = 0;
 724               	.LM58:
 725 0306 8C81      		ldd r24,Y+4
 726 0308 9D81      		ldd r25,Y+5
 727 030a FC01      		movw r30,r24
 728 030c 1182      		std Z+1,__zero_reg__
 105:protocol.c    ****    switch(commandCode) {
 730               	.LM59:
 731 030e 8981      		ldd r24,Y+1
 732 0310 9927      		clr r25
 733 0312 87FD      		sbrc r24,7
 734 0314 9095      		com r25
 735 0316 0097      		sbiw r24,0
 736 0318 01F4      		brne .L41
 737               	.LBB7:
 106:protocol.c    ****    case SET_LIGHT:
 107:protocol.c    **** 	 	setLight(*((char*)commandData));
 739               	.LM60:
 740 031a 8A81      		ldd r24,Y+2
 741 031c 9B81      		ldd r25,Y+3
 742 031e FC01      		movw r30,r24
 743 0320 8081      		ld r24,Z
 744 0322 9927      		clr r25
 745 0324 87FD      		sbrc r24,7
 746 0326 9095      		com r25
 747 0328 0E94 0000 		call setLight
 108:protocol.c    ****       break;
 749               	.LM61:
 750 032c 0000      		nop
 751               	.L41:
 752               	/* epilogue start */
 753               	.LBE7:
 109:protocol.c    ****    }
 110:protocol.c    **** }
 755               	.LM62:
 756 032e 0F90      		pop __tmp_reg__
 757 0330 0F90      		pop __tmp_reg__
 758 0332 0F90      		pop __tmp_reg__
 759 0334 0F90      		pop __tmp_reg__
 760 0336 0F90      		pop __tmp_reg__
 761 0338 DF91      		pop r29
 762 033a CF91      		pop r28
 763 033c 0895      		ret
 765               	.Lscope8:
 767               		.stabd	78,0,0
 771               	.global	processCommand
 773               	processCommand:
 774               		.stabd	46,0,0
 111:protocol.c    **** 
 112:protocol.c    **** 
 113:protocol.c    **** 
 114:protocol.c    **** //Function that will take in a command (as char array) and process it into a
 115:protocol.c    **** //correct response to be stored into response
 116:protocol.c    **** char processCommand(Command *command, Response *response) {
 776               	.LM63:
 777               	.LFBB9:
 778 033e CF93      		push r28
 779 0340 DF93      		push r29
 780 0342 00D0      		rcall .
 781 0344 1F92      		push __zero_reg__
 782 0346 CDB7      		in r28,__SP_L__
 783 0348 DEB7      		in r29,__SP_H__
 784               	/* prologue: function */
 785               	/* frame size = 4 */
 786               	/* stack size = 6 */
 787               	.L__stack_usage = 6
 788 034a 9A83      		std Y+2,r25
 789 034c 8983      		std Y+1,r24
 790 034e 7C83      		std Y+4,r23
 791 0350 6B83      		std Y+3,r22
 117:protocol.c    **** 	response->commandBack = command->cmd;
 793               	.LM64:
 794 0352 8981      		ldd r24,Y+1
 795 0354 9A81      		ldd r25,Y+2
 796 0356 DC01      		movw r26,r24
 797 0358 1196      		adiw r26,1
 798 035a 2C91      		ld r18,X
 799 035c 8B81      		ldd r24,Y+3
 800 035e 9C81      		ldd r25,Y+4
 801 0360 FC01      		movw r30,r24
 802 0362 2083      		st Z,r18
 118:protocol.c    ****    switch(command->groupID) {
 804               	.LM65:
 805 0364 8981      		ldd r24,Y+1
 806 0366 9A81      		ldd r25,Y+2
 807 0368 DC01      		movw r26,r24
 808 036a 8C91      		ld r24,X
 809 036c 9927      		clr r25
 810 036e 87FD      		sbrc r24,7
 811 0370 9095      		com r25
 812 0372 AA27      		clr r26
 813 0374 97FD      		sbrc r25,7
 814 0376 A095      		com r26
 815 0378 BA2F      		mov r27,r26
 816 037a 41E0      		ldi r20,lo8(1)
 817 037c 50E0      		ldi r21,0
 818 037e 27E0      		ldi r18,lo8(7)
 819 0380 30E0      		ldi r19,0
 820 0382 841B      		sub r24,r20
 821 0384 950B      		sbc r25,r21
 822 0386 2817      		cp r18,r24
 823 0388 3907      		cpc r19,r25
 824 038a 00F0      		brlo .L43
 825 038c 8050      		subi r24,lo8(-(gs(.L45)))
 826 038e 9040      		sbci r25,hi8(-(gs(.L45)))
 827 0390 FC01      		movw r30,r24
 828 0392 0C94 0000 		jmp __tablejump2__
 829               		.section	.progmem.gcc_sw_table,"a",@progbits
 830               		.p2align	1
 831               	.L45:
 832 0000 0000      		.word gs(.L44)
 833 0002 0000      		.word gs(.L54)
 834 0004 0000      		.word gs(.L54)
 835 0006 0000      		.word gs(.L54)
 836 0008 0000      		.word gs(.L54)
 837 000a 0000      		.word gs(.L54)
 838 000c 0000      		.word gs(.L51)
 839 000e 0000      		.word gs(.L54)
 840               		.text
 841               	.L44:
 119:protocol.c    ****       case ULTRASONIC_GROUP:
 120:protocol.c    ****          processUltrasonicCommand(command->cmd, command->payload,&response->size, response->payload
 843               	.LM66:
 844 0396 8B81      		ldd r24,Y+3
 845 0398 9C81      		ldd r25,Y+4
 846 039a 9C01      		movw r18,r24
 847 039c 2E5F      		subi r18,-2
 848 039e 3F4F      		sbci r19,-1
 849 03a0 8B81      		ldd r24,Y+3
 850 03a2 9C81      		ldd r25,Y+4
 851 03a4 AC01      		movw r20,r24
 852 03a6 4F5F      		subi r20,-1
 853 03a8 5F4F      		sbci r21,-1
 854 03aa 8981      		ldd r24,Y+1
 855 03ac 9A81      		ldd r25,Y+2
 856 03ae 0396      		adiw r24,3
 857 03b0 6981      		ldd r22,Y+1
 858 03b2 7A81      		ldd r23,Y+2
 859 03b4 DB01      		movw r26,r22
 860 03b6 1196      		adiw r26,1
 861 03b8 EC91      		ld r30,X
 862 03ba BC01      		movw r22,r24
 863 03bc 8E2F      		mov r24,r30
 864 03be 0E94 0000 		call processUltrasonicCommand
 121:protocol.c    ****          break;
 866               	.LM67:
 867 03c2 00C0      		rjmp .L43
 868               	.L51:
 122:protocol.c    ****       case SPEED_GROUP:
 123:protocol.c    ****          /*do speed things*/
 124:protocol.c    ****          break;
 125:protocol.c    ****       case STEERING_GROUP:
 126:protocol.c    ****          /*do steering things*/
 127:protocol.c    ****          break;
 128:protocol.c    ****       case FNR_GROUP:
 129:protocol.c    ****          /*do FRN things*/
 130:protocol.c    ****          break;
 131:protocol.c    ****       case BRAKES_GROUP:
 132:protocol.c    ****          /*do brakes things*/
 133:protocol.c    ****          break;
 134:protocol.c    ****       case BATTERY_GROUP:
 135:protocol.c    ****          /*do battery things*/
 136:protocol.c    ****          break;
 137:protocol.c    ****       case LIGHTS_GROUP:
 138:protocol.c    **** 	      processLightCommand(command->cmd,command->payload,response);
 870               	.LM68:
 871 03c4 8981      		ldd r24,Y+1
 872 03c6 9A81      		ldd r25,Y+2
 873 03c8 0396      		adiw r24,3
 874 03ca 2981      		ldd r18,Y+1
 875 03cc 3A81      		ldd r19,Y+2
 876 03ce D901      		movw r26,r18
 877 03d0 1196      		adiw r26,1
 878 03d2 EC91      		ld r30,X
 879 03d4 2B81      		ldd r18,Y+3
 880 03d6 3C81      		ldd r19,Y+4
 881 03d8 A901      		movw r20,r18
 882 03da BC01      		movw r22,r24
 883 03dc 8E2F      		mov r24,r30
 884 03de 0E94 0000 		call processLightCommand
 139:protocol.c    ****          break;
 886               	.LM69:
 887 03e2 00C0      		rjmp .L43
 888               	.L54:
 140:protocol.c    ****       case ERROR_GROUP:
 141:protocol.c    ****          /*do error things*/
 142:protocol.c    ****          break;
 890               	.LM70:
 891 03e4 0000      		nop
 892               	.L43:
 143:protocol.c    ****    }
 144:protocol.c    ****    //return a dummy success for now
 145:protocol.c    ****    return 1;
 894               	.LM71:
 895 03e6 81E0      		ldi r24,lo8(1)
 896               	/* epilogue start */
 146:protocol.c    **** }
 898               	.LM72:
 899 03e8 0F90      		pop __tmp_reg__
 900 03ea 0F90      		pop __tmp_reg__
 901 03ec 0F90      		pop __tmp_reg__
 902 03ee 0F90      		pop __tmp_reg__
 903 03f0 DF91      		pop r29
 904 03f2 CF91      		pop r28
 905 03f4 0895      		ret
 907               	.Lscope9:
 909               		.stabd	78,0,0
 911               	.Letext0:
 912               		.ident	"GCC: (GNU) 4.8.2"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 protocol.c
     /tmp/ccadQq81.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccadQq81.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccadQq81.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccadQq81.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccadQq81.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccadQq81.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccadQq81.s:70     .text:0000000000000000 commandIntegCheck
     /tmp/ccadQq81.s:109    .text:000000000000001c processUltrasonicCommand
     /tmp/ccadQq81.s:221    .text:00000000000000ac processSpeedCommand
     /tmp/ccadQq81.s:304    .text:0000000000000108 processSteeringCommand
     /tmp/ccadQq81.s:467    .text:00000000000001ea processFNRCommand
     /tmp/ccadQq81.s:547    .text:0000000000000244 processBrakeCommand
     /tmp/ccadQq81.s:627    .text:000000000000029e processBatteryCommand
     /tmp/ccadQq81.s:702    .text:00000000000002ee processLightCommand
     /tmp/ccadQq81.s:773    .text:000000000000033e processCommand

UNDEFINED SYMBOLS
getAllSensors
getCertainSensor
getSensorGroup
getSpeed
setSpeed
setAngle
getAngle
getDesiredAngle
changePID
setLimits
setFNR
getFNR
setBrake
getBrake
getBatteryVoltage
getSteeringVoltage
setLight
__tablejump2__
