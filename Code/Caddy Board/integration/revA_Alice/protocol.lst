   1               		.file	"protocol.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
  68               	.global	commandIntegCheck
  70               	commandIntegCheck:
  71               		.stabd	46,0,0
   1:protocol.c    **** /**
   2:protocol.c    ****  * Skeleton of command recieve and response
   3:protocol.c    ****  *
   4:protocol.c    ****  * @author Louie Thiros
   5:protocol.c    ****  */
   6:protocol.c    **** 
   7:protocol.c    **** #include "protocol.h"
   8:protocol.c    **** #include "Components/Sonar/Sonar.h"
   9:protocol.c    **** 
  10:protocol.c    **** 
  11:protocol.c    **** //function to CRC the command structure
  12:protocol.c    **** char commandIntegCheck(Command *command) {
  73               	.LM0:
  74               	.LFBB1:
  75 0000 CF93      		push r28
  76 0002 DF93      		push r29
  77 0004 1F92      		push __zero_reg__
  78 0006 1F92      		push __zero_reg__
  79 0008 CDB7      		in r28,__SP_L__
  80 000a DEB7      		in r29,__SP_H__
  81               	/* prologue: function */
  82               	/* frame size = 2 */
  83               	/* stack size = 4 */
  84               	.L__stack_usage = 4
  85 000c 9A83      		std Y+2,r25
  86 000e 8983      		std Y+1,r24
  13:protocol.c    ****    //CRC the command with 0x00 in place of the CRC
  14:protocol.c    ****    //return success for now
  15:protocol.c    ****    return 1;
  88               	.LM1:
  89 0010 81E0      		ldi r24,lo8(1)
  90               	/* epilogue start */
  16:protocol.c    **** }
  92               	.LM2:
  93 0012 0F90      		pop __tmp_reg__
  94 0014 0F90      		pop __tmp_reg__
  95 0016 DF91      		pop r29
  96 0018 CF91      		pop r28
  97 001a 0895      		ret
  99               	.Lscope1:
 101               		.stabd	78,0,0
 107               	.global	processUltrasonicCommand
 109               	processUltrasonicCommand:
 110               		.stabd	46,0,0
  17:protocol.c    **** 
  18:protocol.c    **** char processUltrasonicCommand(char commandCode, void* commandData,char* size, void* responseData) {
 112               	.LM3:
 113               	.LFBB2:
 114 001c CF93      		push r28
 115 001e DF93      		push r29
 116 0020 CDB7      		in r28,__SP_L__
 117 0022 DEB7      		in r29,__SP_H__
 118 0024 2797      		sbiw r28,7
 119 0026 0FB6      		in __tmp_reg__,__SREG__
 120 0028 F894      		cli
 121 002a DEBF      		out __SP_H__,r29
 122 002c 0FBE      		out __SREG__,__tmp_reg__
 123 002e CDBF      		out __SP_L__,r28
 124               	/* prologue: function */
 125               	/* frame size = 7 */
 126               	/* stack size = 9 */
 127               	.L__stack_usage = 9
 128 0030 8983      		std Y+1,r24
 129 0032 7B83      		std Y+3,r23
 130 0034 6A83      		std Y+2,r22
 131 0036 5D83      		std Y+5,r21
 132 0038 4C83      		std Y+4,r20
 133 003a 3F83      		std Y+7,r19
 134 003c 2E83      		std Y+6,r18
  19:protocol.c    ****    switch(commandCode) {
 136               	.LM4:
 137 003e 8981      		ldd r24,Y+1
 138 0040 9927      		clr r25
 139 0042 87FD      		sbrc r24,7
 140 0044 9095      		com r25
 141 0046 8230      		cpi r24,2
 142 0048 9105      		cpc r25,__zero_reg__
 143 004a 01F0      		breq .L5
 144 004c 8330      		cpi r24,3
 145 004e 9105      		cpc r25,__zero_reg__
 146 0050 01F0      		breq .L6
 147 0052 8130      		cpi r24,1
 148 0054 9105      		cpc r25,__zero_reg__
 149 0056 01F4      		brne .L4
  20:protocol.c    ****       case GET_ALL_SENSORS:
  21:protocol.c    ****          getAllSensors((int*) responseData);
 151               	.LM5:
 152 0058 8E81      		ldd r24,Y+6
 153 005a 9F81      		ldd r25,Y+7
 154 005c 0E94 0000 		call getAllSensors
  22:protocol.c    ****          *size = 12;
 156               	.LM6:
 157 0060 8C81      		ldd r24,Y+4
 158 0062 9D81      		ldd r25,Y+5
 159 0064 2CE0      		ldi r18,lo8(12)
 160 0066 FC01      		movw r30,r24
 161 0068 2083      		st Z,r18
  23:protocol.c    ****          break;
 163               	.LM7:
 164 006a 00C0      		rjmp .L4
 165               	.L5:
  24:protocol.c    ****       case GET_CERTAIN_SENSORS:
  25:protocol.c    ****          getCertainSensor(((char*)commandData)[0], (int*) responseData);
 167               	.LM8:
 168 006c 8A81      		ldd r24,Y+2
 169 006e 9B81      		ldd r25,Y+3
 170 0070 FC01      		movw r30,r24
 171 0072 2081      		ld r18,Z
 172 0074 8E81      		ldd r24,Y+6
 173 0076 9F81      		ldd r25,Y+7
 174 0078 BC01      		movw r22,r24
 175 007a 822F      		mov r24,r18
 176 007c 0E94 0000 		call getCertainSensor
  26:protocol.c    ****          break;
 178               	.LM9:
 179 0080 00C0      		rjmp .L4
 180               	.L6:
  27:protocol.c    ****       case GET_SENSOR_GROUP:
  28:protocol.c    ****          getSensorGroup(((char*)commandData)[0], (int*) responseData);
 182               	.LM10:
 183 0082 8A81      		ldd r24,Y+2
 184 0084 9B81      		ldd r25,Y+3
 185 0086 FC01      		movw r30,r24
 186 0088 2081      		ld r18,Z
 187 008a 8E81      		ldd r24,Y+6
 188 008c 9F81      		ldd r25,Y+7
 189 008e BC01      		movw r22,r24
 190 0090 822F      		mov r24,r18
 191 0092 0E94 0000 		call getSensorGroup
  29:protocol.c    ****          break;
 193               	.LM11:
 194 0096 0000      		nop
 195               	.L4:
  30:protocol.c    ****    }
  31:protocol.c    ****    //return success for now...
  32:protocol.c    ****    return 1;
 197               	.LM12:
 198 0098 81E0      		ldi r24,lo8(1)
 199               	/* epilogue start */
  33:protocol.c    **** }
 201               	.LM13:
 202 009a 2796      		adiw r28,7
 203 009c 0FB6      		in __tmp_reg__,__SREG__
 204 009e F894      		cli
 205 00a0 DEBF      		out __SP_H__,r29
 206 00a2 0FBE      		out __SREG__,__tmp_reg__
 207 00a4 CDBF      		out __SP_L__,r28
 208 00a6 DF91      		pop r29
 209 00a8 CF91      		pop r28
 210 00aa 0895      		ret
 212               	.Lscope2:
 214               		.stabd	78,0,0
 219               	.global	processSpeedCommand
 221               	processSpeedCommand:
 222               		.stabd	46,0,0
  34:protocol.c    **** 
  35:protocol.c    **** char processSpeedCommand(char commandCode, void* commandData, Response* responseData) {
 224               	.LM14:
 225               	.LFBB3:
 226 00ac CF93      		push r28
 227 00ae DF93      		push r29
 228 00b0 00D0      		rcall .
 229 00b2 1F92      		push __zero_reg__
 230 00b4 1F92      		push __zero_reg__
 231 00b6 CDB7      		in r28,__SP_L__
 232 00b8 DEB7      		in r29,__SP_H__
 233               	/* prologue: function */
 234               	/* frame size = 5 */
 235               	/* stack size = 7 */
 236               	.L__stack_usage = 7
 237 00ba 8983      		std Y+1,r24
 238 00bc 7B83      		std Y+3,r23
 239 00be 6A83      		std Y+2,r22
 240 00c0 5D83      		std Y+5,r21
 241 00c2 4C83      		std Y+4,r20
  36:protocol.c    ****    switch(commandCode) {
 243               	.LM15:
 244 00c4 8981      		ldd r24,Y+1
 245 00c6 9927      		clr r25
 246 00c8 87FD      		sbrc r24,7
 247 00ca 9095      		com r25
 248 00cc 0097      		sbiw r24,0
 249 00ce 01F0      		breq .L11
 250 00d0 8130      		cpi r24,1
 251 00d2 9105      		cpc r25,__zero_reg__
 252 00d4 01F0      		breq .L12
 253 00d6 00C0      		rjmp .L10
 254               	.L11:
 255               	.LBB2:
  37:protocol.c    ****       case GET_SPEED:
  38:protocol.c    ****          getSpeed((char*) responseData);
 257               	.LM16:
 258 00d8 8C81      		ldd r24,Y+4
 259 00da 9D81      		ldd r25,Y+5
 260 00dc 0E94 0000 		call getSpeed
  39:protocol.c    ****          break;
 262               	.LM17:
 263 00e0 00C0      		rjmp .L10
 264               	.L12:
  40:protocol.c    ****       case SET_SPEED:
  41:protocol.c    **** 			responseData->size = 0;
 266               	.LM18:
 267 00e2 8C81      		ldd r24,Y+4
 268 00e4 9D81      		ldd r25,Y+5
 269 00e6 FC01      		movw r30,r24
 270 00e8 1182      		std Z+1,__zero_reg__
  42:protocol.c    ****          setSpeed(((char*)commandData)[0]);
 272               	.LM19:
 273 00ea 8A81      		ldd r24,Y+2
 274 00ec 9B81      		ldd r25,Y+3
 275 00ee FC01      		movw r30,r24
 276 00f0 8081      		ld r24,Z
 277 00f2 9927      		clr r25
 278 00f4 87FD      		sbrc r24,7
 279 00f6 9095      		com r25
 280 00f8 0E94 0000 		call setSpeed
  43:protocol.c    ****          break;
 282               	.LM20:
 283 00fc 0000      		nop
 284               	.L10:
 285               	.LBE2:
  44:protocol.c    ****    }
  45:protocol.c    ****    //return success for now
  46:protocol.c    ****    return 1;
 287               	.LM21:
 288 00fe 81E0      		ldi r24,lo8(1)
 289               	/* epilogue start */
  47:protocol.c    **** }
 291               	.LM22:
 292 0100 0F90      		pop __tmp_reg__
 293 0102 0F90      		pop __tmp_reg__
 294 0104 0F90      		pop __tmp_reg__
 295 0106 0F90      		pop __tmp_reg__
 296 0108 0F90      		pop __tmp_reg__
 297 010a DF91      		pop r29
 298 010c CF91      		pop r28
 299 010e 0895      		ret
 301               	.Lscope3:
 303               		.stabd	78,0,0
 308               	.global	processSteeringCommand
 310               	processSteeringCommand:
 311               		.stabd	46,0,0
  48:protocol.c    **** 
  49:protocol.c    **** char processSteeringCommand(char commandCode, void* commandData, void* responseData) {
 313               	.LM23:
 314               	.LFBB4:
 315 0110 CF93      		push r28
 316 0112 DF93      		push r29
 317 0114 00D0      		rcall .
 318 0116 1F92      		push __zero_reg__
 319 0118 1F92      		push __zero_reg__
 320 011a CDB7      		in r28,__SP_L__
 321 011c DEB7      		in r29,__SP_H__
 322               	/* prologue: function */
 323               	/* frame size = 5 */
 324               	/* stack size = 7 */
 325               	.L__stack_usage = 7
 326 011e 8983      		std Y+1,r24
 327 0120 7B83      		std Y+3,r23
 328 0122 6A83      		std Y+2,r22
 329 0124 5D83      		std Y+5,r21
 330 0126 4C83      		std Y+4,r20
  50:protocol.c    ****    switch(commandCode) {
 332               	.LM24:
 333 0128 8981      		ldd r24,Y+1
 334 012a 9927      		clr r25
 335 012c 87FD      		sbrc r24,7
 336 012e 9095      		com r25
 337 0130 8230      		cpi r24,2
 338 0132 9105      		cpc r25,__zero_reg__
 339 0134 01F0      		breq .L16
 340 0136 8330      		cpi r24,3
 341 0138 9105      		cpc r25,__zero_reg__
 342 013a 04F4      		brge .L17
 343 013c 0097      		sbiw r24,0
 344 013e 01F0      		breq .L18
 345 0140 8130      		cpi r24,1
 346 0142 9105      		cpc r25,__zero_reg__
 347 0144 01F0      		breq .L19
 348 0146 00C0      		rjmp .L15
 349               	.L17:
 350 0148 8330      		cpi r24,3
 351 014a 9105      		cpc r25,__zero_reg__
 352 014c 01F0      		breq .L20
 353 014e 8430      		cpi r24,4
 354 0150 9105      		cpc r25,__zero_reg__
 355 0152 01F0      		breq .L21
 356 0154 00C0      		rjmp .L15
 357               	.L18:
 358               	.LBB3:
  51:protocol.c    ****       case SET_ANGLE:
  52:protocol.c    ****          setAngle(*((char*)commandData));
 360               	.LM25:
 361 0156 8A81      		ldd r24,Y+2
 362 0158 9B81      		ldd r25,Y+3
 363 015a FC01      		movw r30,r24
 364 015c 8081      		ld r24,Z
 365 015e 9927      		clr r25
 366 0160 87FD      		sbrc r24,7
 367 0162 9095      		com r25
 368 0164 0E94 0000 		call setAngle
  53:protocol.c    ****          break;
 370               	.LM26:
 371 0168 00C0      		rjmp .L15
 372               	.L19:
  54:protocol.c    ****       case GET_ANGLE:
  55:protocol.c    ****          getAngle((char*) responseData);
 374               	.LM27:
 375 016a 8C81      		ldd r24,Y+4
 376 016c 9D81      		ldd r25,Y+5
 377 016e 0E94 0000 		call getAngle
  56:protocol.c    ****          break;
 379               	.LM28:
 380 0172 00C0      		rjmp .L15
 381               	.L16:
  57:protocol.c    ****       case GET_DESIRED_ANGLE:
  58:protocol.c    ****          getDesiredAngle((char*) responseData);
 383               	.LM29:
 384 0174 8C81      		ldd r24,Y+4
 385 0176 9D81      		ldd r25,Y+5
 386 0178 0E94 0000 		call getDesiredAngle
  59:protocol.c    ****          break;
 388               	.LM30:
 389 017c 00C0      		rjmp .L15
 390               	.L20:
  60:protocol.c    ****       case CHANGE_PID:
  61:protocol.c    ****          changePID(((char*)commandData)[0], ((char*)commandData)[1], ((char*)commandData)[2]);
 392               	.LM31:
 393 017e 8A81      		ldd r24,Y+2
 394 0180 9B81      		ldd r25,Y+3
 395 0182 0296      		adiw r24,2
 396 0184 FC01      		movw r30,r24
 397 0186 8081      		ld r24,Z
 398 0188 482F      		mov r20,r24
 399 018a 5527      		clr r21
 400 018c 47FD      		sbrc r20,7
 401 018e 5095      		com r21
 402 0190 8A81      		ldd r24,Y+2
 403 0192 9B81      		ldd r25,Y+3
 404 0194 0196      		adiw r24,1
 405 0196 FC01      		movw r30,r24
 406 0198 8081      		ld r24,Z
 407 019a 282F      		mov r18,r24
 408 019c 3327      		clr r19
 409 019e 27FD      		sbrc r18,7
 410 01a0 3095      		com r19
 411 01a2 8A81      		ldd r24,Y+2
 412 01a4 9B81      		ldd r25,Y+3
 413 01a6 FC01      		movw r30,r24
 414 01a8 8081      		ld r24,Z
 415 01aa 9927      		clr r25
 416 01ac 87FD      		sbrc r24,7
 417 01ae 9095      		com r25
 418 01b0 B901      		movw r22,r18
 419 01b2 0E94 0000 		call changePID
  62:protocol.c    ****          break;
 421               	.LM32:
 422 01b6 00C0      		rjmp .L15
 423               	.L21:
  63:protocol.c    ****       case SET_LIMITS:
  64:protocol.c    ****          setLimits(((char*)commandData)[0], ((char*)commandData)[1]);
 425               	.LM33:
 426 01b8 8A81      		ldd r24,Y+2
 427 01ba 9B81      		ldd r25,Y+3
 428 01bc 0196      		adiw r24,1
 429 01be FC01      		movw r30,r24
 430 01c0 8081      		ld r24,Z
 431 01c2 282F      		mov r18,r24
 432 01c4 3327      		clr r19
 433 01c6 27FD      		sbrc r18,7
 434 01c8 3095      		com r19
 435 01ca 8A81      		ldd r24,Y+2
 436 01cc 9B81      		ldd r25,Y+3
 437 01ce FC01      		movw r30,r24
 438 01d0 8081      		ld r24,Z
 439 01d2 9927      		clr r25
 440 01d4 87FD      		sbrc r24,7
 441 01d6 9095      		com r25
 442 01d8 B901      		movw r22,r18
 443 01da 0E94 0000 		call setLimits
  65:protocol.c    ****          break;
 445               	.LM34:
 446 01de 0000      		nop
 447               	.L15:
 448               	.LBE3:
  66:protocol.c    ****    }
  67:protocol.c    ****    //return success for now
  68:protocol.c    ****    return 1;
 450               	.LM35:
 451 01e0 81E0      		ldi r24,lo8(1)
 452               	/* epilogue start */
  69:protocol.c    **** }
 454               	.LM36:
 455 01e2 0F90      		pop __tmp_reg__
 456 01e4 0F90      		pop __tmp_reg__
 457 01e6 0F90      		pop __tmp_reg__
 458 01e8 0F90      		pop __tmp_reg__
 459 01ea 0F90      		pop __tmp_reg__
 460 01ec DF91      		pop r29
 461 01ee CF91      		pop r28
 462 01f0 0895      		ret
 464               	.Lscope4:
 466               		.stabd	78,0,0
 471               	.global	processFNRCommand
 473               	processFNRCommand:
 474               		.stabd	46,0,0
  70:protocol.c    **** 
  71:protocol.c    **** char processFNRCommand(char commandCode, void* commandData, Response* responseData) {
 476               	.LM37:
 477               	.LFBB5:
 478 01f2 CF93      		push r28
 479 01f4 DF93      		push r29
 480 01f6 00D0      		rcall .
 481 01f8 1F92      		push __zero_reg__
 482 01fa 1F92      		push __zero_reg__
 483 01fc CDB7      		in r28,__SP_L__
 484 01fe DEB7      		in r29,__SP_H__
 485               	/* prologue: function */
 486               	/* frame size = 5 */
 487               	/* stack size = 7 */
 488               	.L__stack_usage = 7
 489 0200 8983      		std Y+1,r24
 490 0202 7B83      		std Y+3,r23
 491 0204 6A83      		std Y+2,r22
 492 0206 5D83      		std Y+5,r21
 493 0208 4C83      		std Y+4,r20
  72:protocol.c    **** 	responseData->size = 0;	
 495               	.LM38:
 496 020a 8C81      		ldd r24,Y+4
 497 020c 9D81      		ldd r25,Y+5
 498 020e FC01      		movw r30,r24
 499 0210 1182      		std Z+1,__zero_reg__
  73:protocol.c    ****    switch(commandCode) {
 501               	.LM39:
 502 0212 8981      		ldd r24,Y+1
 503 0214 9927      		clr r25
 504 0216 87FD      		sbrc r24,7
 505 0218 9095      		com r25
 506 021a 0097      		sbiw r24,0
 507 021c 01F0      		breq .L25
 508 021e 8130      		cpi r24,1
 509 0220 9105      		cpc r25,__zero_reg__
 510 0222 01F0      		breq .L26
 511 0224 00C0      		rjmp .L27
 512               	.L25:
 513               	.LBB4:
  74:protocol.c    ****       case SET_FNR:
  75:protocol.c    ****          setFNR(*((char*)commandData));
 515               	.LM40:
 516 0226 8A81      		ldd r24,Y+2
 517 0228 9B81      		ldd r25,Y+3
 518 022a FC01      		movw r30,r24
 519 022c 8081      		ld r24,Z
 520 022e 9927      		clr r25
 521 0230 87FD      		sbrc r24,7
 522 0232 9095      		com r25
 523 0234 0E94 0000 		call setFNR
  76:protocol.c    ****          break;
 525               	.LM41:
 526 0238 00C0      		rjmp .L27
 527               	.L26:
  77:protocol.c    ****       case GET_FNR:
  78:protocol.c    ****          getFNR((char*) responseData);
 529               	.LM42:
 530 023a 8C81      		ldd r24,Y+4
 531 023c 9D81      		ldd r25,Y+5
 532 023e 0E94 0000 		call getFNR
  79:protocol.c    ****          break;
 534               	.LM43:
 535 0242 0000      		nop
 536               	.L27:
 537               	/* epilogue start */
 538               	.LBE4:
  80:protocol.c    ****    }
  81:protocol.c    **** }
 540               	.LM44:
 541 0244 0F90      		pop __tmp_reg__
 542 0246 0F90      		pop __tmp_reg__
 543 0248 0F90      		pop __tmp_reg__
 544 024a 0F90      		pop __tmp_reg__
 545 024c 0F90      		pop __tmp_reg__
 546 024e DF91      		pop r29
 547 0250 CF91      		pop r28
 548 0252 0895      		ret
 550               	.Lscope5:
 552               		.stabd	78,0,0
 557               	.global	processBrakeCommand
 559               	processBrakeCommand:
 560               		.stabd	46,0,0
  82:protocol.c    **** 
  83:protocol.c    **** char processBrakeCommand(char commandCode, void* commandData, void* responseData) {
 562               	.LM45:
 563               	.LFBB6:
 564 0254 CF93      		push r28
 565 0256 DF93      		push r29
 566 0258 00D0      		rcall .
 567 025a 1F92      		push __zero_reg__
 568 025c 1F92      		push __zero_reg__
 569 025e CDB7      		in r28,__SP_L__
 570 0260 DEB7      		in r29,__SP_H__
 571               	/* prologue: function */
 572               	/* frame size = 5 */
 573               	/* stack size = 7 */
 574               	.L__stack_usage = 7
 575 0262 8983      		std Y+1,r24
 576 0264 7B83      		std Y+3,r23
 577 0266 6A83      		std Y+2,r22
 578 0268 5D83      		std Y+5,r21
 579 026a 4C83      		std Y+4,r20
  84:protocol.c    ****    switch(commandCode) {
 581               	.LM46:
 582 026c 8981      		ldd r24,Y+1
 583 026e 9927      		clr r25
 584 0270 87FD      		sbrc r24,7
 585 0272 9095      		com r25
 586 0274 0097      		sbiw r24,0
 587 0276 01F0      		breq .L30
 588 0278 8130      		cpi r24,1
 589 027a 9105      		cpc r25,__zero_reg__
 590 027c 01F0      		breq .L31
 591 027e 00C0      		rjmp .L32
 592               	.L30:
 593               	.LBB5:
  85:protocol.c    ****       case SET_BRAKE:
  86:protocol.c    **** 	 setBrake(*((char*)commandData));
 595               	.LM47:
 596 0280 8A81      		ldd r24,Y+2
 597 0282 9B81      		ldd r25,Y+3
 598 0284 FC01      		movw r30,r24
 599 0286 8081      		ld r24,Z
 600 0288 9927      		clr r25
 601 028a 87FD      		sbrc r24,7
 602 028c 9095      		com r25
 603 028e 0E94 0000 		call setBrake
  87:protocol.c    **** 	 break;
 605               	.LM48:
 606 0292 00C0      		rjmp .L32
 607               	.L31:
  88:protocol.c    ****       case GET_BRAKE:
  89:protocol.c    **** 	 getBrake((char*) responseData);
 609               	.LM49:
 610 0294 8C81      		ldd r24,Y+4
 611 0296 9D81      		ldd r25,Y+5
 612 0298 0E94 0000 		call getBrake
  90:protocol.c    **** 	 break; 
 614               	.LM50:
 615 029c 0000      		nop
 616               	.L32:
 617               	/* epilogue start */
 618               	.LBE5:
  91:protocol.c    ****    }
  92:protocol.c    **** }
 620               	.LM51:
 621 029e 0F90      		pop __tmp_reg__
 622 02a0 0F90      		pop __tmp_reg__
 623 02a2 0F90      		pop __tmp_reg__
 624 02a4 0F90      		pop __tmp_reg__
 625 02a6 0F90      		pop __tmp_reg__
 626 02a8 DF91      		pop r29
 627 02aa CF91      		pop r28
 628 02ac 0895      		ret
 630               	.Lscope6:
 632               		.stabd	78,0,0
 637               	.global	processBatteryCommand
 639               	processBatteryCommand:
 640               		.stabd	46,0,0
  93:protocol.c    **** 
  94:protocol.c    **** char processBatteryCommand(char commandCode, void* commandData, void* responseData) {
 642               	.LM52:
 643               	.LFBB7:
 644 02ae CF93      		push r28
 645 02b0 DF93      		push r29
 646 02b2 00D0      		rcall .
 647 02b4 1F92      		push __zero_reg__
 648 02b6 1F92      		push __zero_reg__
 649 02b8 CDB7      		in r28,__SP_L__
 650 02ba DEB7      		in r29,__SP_H__
 651               	/* prologue: function */
 652               	/* frame size = 5 */
 653               	/* stack size = 7 */
 654               	.L__stack_usage = 7
 655 02bc 8983      		std Y+1,r24
 656 02be 7B83      		std Y+3,r23
 657 02c0 6A83      		std Y+2,r22
 658 02c2 5D83      		std Y+5,r21
 659 02c4 4C83      		std Y+4,r20
  95:protocol.c    ****    switch(commandCode) {
 661               	.LM53:
 662 02c6 8981      		ldd r24,Y+1
 663 02c8 9927      		clr r25
 664 02ca 87FD      		sbrc r24,7
 665 02cc 9095      		com r25
 666 02ce 0097      		sbiw r24,0
 667 02d0 01F0      		breq .L35
 668 02d2 8130      		cpi r24,1
 669 02d4 9105      		cpc r25,__zero_reg__
 670 02d6 01F0      		breq .L36
 671 02d8 00C0      		rjmp .L37
 672               	.L35:
 673               	.LBB6:
  96:protocol.c    ****       case GET_BATTERY_VOLTAGE:
  97:protocol.c    ****          getBatteryVoltage((char*) responseData);
 675               	.LM54:
 676 02da 8C81      		ldd r24,Y+4
 677 02dc 9D81      		ldd r25,Y+5
 678 02de 0E94 0000 		call getBatteryVoltage
  98:protocol.c    ****          break;
 680               	.LM55:
 681 02e2 00C0      		rjmp .L37
 682               	.L36:
  99:protocol.c    ****       case GET_STEERING_VOLTAGE:
 100:protocol.c    ****          getSteeringVoltage((char*) responseData);
 684               	.LM56:
 685 02e4 8C81      		ldd r24,Y+4
 686 02e6 9D81      		ldd r25,Y+5
 687 02e8 0E94 0000 		call getSteeringVoltage
 101:protocol.c    ****          break;
 689               	.LM57:
 690 02ec 0000      		nop
 691               	.L37:
 692               	/* epilogue start */
 693               	.LBE6:
 102:protocol.c    ****    }
 103:protocol.c    **** }
 695               	.LM58:
 696 02ee 0F90      		pop __tmp_reg__
 697 02f0 0F90      		pop __tmp_reg__
 698 02f2 0F90      		pop __tmp_reg__
 699 02f4 0F90      		pop __tmp_reg__
 700 02f6 0F90      		pop __tmp_reg__
 701 02f8 DF91      		pop r29
 702 02fa CF91      		pop r28
 703 02fc 0895      		ret
 705               	.Lscope7:
 707               		.stabd	78,0,0
 712               	.global	processLightCommand
 714               	processLightCommand:
 715               		.stabd	46,0,0
 104:protocol.c    **** 
 105:protocol.c    **** char processLightCommand(char commandCode, void* commandData, Response* responseData) {
 717               	.LM59:
 718               	.LFBB8:
 719 02fe CF93      		push r28
 720 0300 DF93      		push r29
 721 0302 00D0      		rcall .
 722 0304 1F92      		push __zero_reg__
 723 0306 1F92      		push __zero_reg__
 724 0308 CDB7      		in r28,__SP_L__
 725 030a DEB7      		in r29,__SP_H__
 726               	/* prologue: function */
 727               	/* frame size = 5 */
 728               	/* stack size = 7 */
 729               	.L__stack_usage = 7
 730 030c 8983      		std Y+1,r24
 731 030e 7B83      		std Y+3,r23
 732 0310 6A83      		std Y+2,r22
 733 0312 5D83      		std Y+5,r21
 734 0314 4C83      		std Y+4,r20
 106:protocol.c    **** 	responseData->size = 0;
 736               	.LM60:
 737 0316 8C81      		ldd r24,Y+4
 738 0318 9D81      		ldd r25,Y+5
 739 031a FC01      		movw r30,r24
 740 031c 1182      		std Z+1,__zero_reg__
 107:protocol.c    ****    switch(commandCode) {
 742               	.LM61:
 743 031e 8981      		ldd r24,Y+1
 744 0320 9927      		clr r25
 745 0322 87FD      		sbrc r24,7
 746 0324 9095      		com r25
 747 0326 0097      		sbiw r24,0
 748 0328 01F4      		brne .L41
 749               	.LBB7:
 108:protocol.c    ****    case SET_LIGHT:
 109:protocol.c    **** 	 	setLight(*((char*)commandData));
 751               	.LM62:
 752 032a 8A81      		ldd r24,Y+2
 753 032c 9B81      		ldd r25,Y+3
 754 032e FC01      		movw r30,r24
 755 0330 8081      		ld r24,Z
 756 0332 9927      		clr r25
 757 0334 87FD      		sbrc r24,7
 758 0336 9095      		com r25
 759 0338 0E94 0000 		call setLight
 110:protocol.c    ****       break;
 761               	.LM63:
 762 033c 0000      		nop
 763               	.L41:
 764               	/* epilogue start */
 765               	.LBE7:
 111:protocol.c    ****    }
 112:protocol.c    **** }
 767               	.LM64:
 768 033e 0F90      		pop __tmp_reg__
 769 0340 0F90      		pop __tmp_reg__
 770 0342 0F90      		pop __tmp_reg__
 771 0344 0F90      		pop __tmp_reg__
 772 0346 0F90      		pop __tmp_reg__
 773 0348 DF91      		pop r29
 774 034a CF91      		pop r28
 775 034c 0895      		ret
 777               	.Lscope8:
 779               		.stabd	78,0,0
 783               	.global	processCommand
 785               	processCommand:
 786               		.stabd	46,0,0
 113:protocol.c    **** 
 114:protocol.c    **** 
 115:protocol.c    **** 
 116:protocol.c    **** //Function that will take in a command (as char array) and process it into a
 117:protocol.c    **** //correct response to be stored into response
 118:protocol.c    **** char processCommand(Command *command, Response *response) {
 788               	.LM65:
 789               	.LFBB9:
 790 034e CF93      		push r28
 791 0350 DF93      		push r29
 792 0352 00D0      		rcall .
 793 0354 1F92      		push __zero_reg__
 794 0356 CDB7      		in r28,__SP_L__
 795 0358 DEB7      		in r29,__SP_H__
 796               	/* prologue: function */
 797               	/* frame size = 4 */
 798               	/* stack size = 6 */
 799               	.L__stack_usage = 6
 800 035a 9A83      		std Y+2,r25
 801 035c 8983      		std Y+1,r24
 802 035e 7C83      		std Y+4,r23
 803 0360 6B83      		std Y+3,r22
 119:protocol.c    **** 	response->commandBack = command->cmd;
 805               	.LM66:
 806 0362 8981      		ldd r24,Y+1
 807 0364 9A81      		ldd r25,Y+2
 808 0366 DC01      		movw r26,r24
 809 0368 1196      		adiw r26,1
 810 036a 2C91      		ld r18,X
 811 036c 8B81      		ldd r24,Y+3
 812 036e 9C81      		ldd r25,Y+4
 813 0370 FC01      		movw r30,r24
 814 0372 2083      		st Z,r18
 120:protocol.c    ****    switch(command->groupID) {
 816               	.LM67:
 817 0374 8981      		ldd r24,Y+1
 818 0376 9A81      		ldd r25,Y+2
 819 0378 DC01      		movw r26,r24
 820 037a 8C91      		ld r24,X
 821 037c 9927      		clr r25
 822 037e 87FD      		sbrc r24,7
 823 0380 9095      		com r25
 824 0382 AA27      		clr r26
 825 0384 97FD      		sbrc r25,7
 826 0386 A095      		com r26
 827 0388 BA2F      		mov r27,r26
 828 038a 41E0      		ldi r20,lo8(1)
 829 038c 50E0      		ldi r21,0
 830 038e 27E0      		ldi r18,lo8(7)
 831 0390 30E0      		ldi r19,0
 832 0392 841B      		sub r24,r20
 833 0394 950B      		sbc r25,r21
 834 0396 2817      		cp r18,r24
 835 0398 3907      		cpc r19,r25
 836 039a 00F4      		brsh .+2
 837 039c 00C0      		rjmp .L43
 838 039e 8050      		subi r24,lo8(-(gs(.L45)))
 839 03a0 9040      		sbci r25,hi8(-(gs(.L45)))
 840 03a2 FC01      		movw r30,r24
 841 03a4 0C94 0000 		jmp __tablejump2__
 842               		.section	.progmem.gcc_sw_table,"a",@progbits
 843               		.p2align	1
 844               	.L45:
 845 0000 0000      		.word gs(.L44)
 846 0002 0000      		.word gs(.L46)
 847 0004 0000      		.word gs(.L54)
 848 0006 0000      		.word gs(.L48)
 849 0008 0000      		.word gs(.L54)
 850 000a 0000      		.word gs(.L54)
 851 000c 0000      		.word gs(.L51)
 852 000e 0000      		.word gs(.L54)
 853               		.text
 854               	.L44:
 121:protocol.c    ****       case ULTRASONIC_GROUP:
 122:protocol.c    ****          processUltrasonicCommand(command->cmd, command->payload,&response->size, response->payload
 856               	.LM68:
 857 03a8 8B81      		ldd r24,Y+3
 858 03aa 9C81      		ldd r25,Y+4
 859 03ac 9C01      		movw r18,r24
 860 03ae 2E5F      		subi r18,-2
 861 03b0 3F4F      		sbci r19,-1
 862 03b2 8B81      		ldd r24,Y+3
 863 03b4 9C81      		ldd r25,Y+4
 864 03b6 AC01      		movw r20,r24
 865 03b8 4F5F      		subi r20,-1
 866 03ba 5F4F      		sbci r21,-1
 867 03bc 8981      		ldd r24,Y+1
 868 03be 9A81      		ldd r25,Y+2
 869 03c0 0396      		adiw r24,3
 870 03c2 6981      		ldd r22,Y+1
 871 03c4 7A81      		ldd r23,Y+2
 872 03c6 DB01      		movw r26,r22
 873 03c8 1196      		adiw r26,1
 874 03ca EC91      		ld r30,X
 875 03cc BC01      		movw r22,r24
 876 03ce 8E2F      		mov r24,r30
 877 03d0 0E94 0000 		call processUltrasonicCommand
 123:protocol.c    ****          break;
 879               	.LM69:
 880 03d4 00C0      		rjmp .L43
 881               	.L46:
 124:protocol.c    ****       case SPEED_GROUP:
 125:protocol.c    **** 			processSpeedCommand(command->cmd,command->payload,response);
 883               	.LM70:
 884 03d6 8981      		ldd r24,Y+1
 885 03d8 9A81      		ldd r25,Y+2
 886 03da 0396      		adiw r24,3
 887 03dc 2981      		ldd r18,Y+1
 888 03de 3A81      		ldd r19,Y+2
 889 03e0 D901      		movw r26,r18
 890 03e2 1196      		adiw r26,1
 891 03e4 EC91      		ld r30,X
 892 03e6 2B81      		ldd r18,Y+3
 893 03e8 3C81      		ldd r19,Y+4
 894 03ea A901      		movw r20,r18
 895 03ec BC01      		movw r22,r24
 896 03ee 8E2F      		mov r24,r30
 897 03f0 0E94 0000 		call processSpeedCommand
 126:protocol.c    ****          break;
 899               	.LM71:
 900 03f4 00C0      		rjmp .L43
 901               	.L48:
 127:protocol.c    ****       case STEERING_GROUP:
 128:protocol.c    ****          /*do steering things*/
 129:protocol.c    ****          break;
 130:protocol.c    ****       case FNR_GROUP:
 131:protocol.c    **** 			processFNRCommand(command->cmd,command->payload,response);
 903               	.LM72:
 904 03f6 8981      		ldd r24,Y+1
 905 03f8 9A81      		ldd r25,Y+2
 906 03fa 0396      		adiw r24,3
 907 03fc 2981      		ldd r18,Y+1
 908 03fe 3A81      		ldd r19,Y+2
 909 0400 D901      		movw r26,r18
 910 0402 1196      		adiw r26,1
 911 0404 EC91      		ld r30,X
 912 0406 2B81      		ldd r18,Y+3
 913 0408 3C81      		ldd r19,Y+4
 914 040a A901      		movw r20,r18
 915 040c BC01      		movw r22,r24
 916 040e 8E2F      		mov r24,r30
 917 0410 0E94 0000 		call processFNRCommand
 132:protocol.c    ****          break;
 919               	.LM73:
 920 0414 00C0      		rjmp .L43
 921               	.L51:
 133:protocol.c    ****       case BRAKES_GROUP:
 134:protocol.c    ****          /*do brakes things*/
 135:protocol.c    ****          break;
 136:protocol.c    ****       case BATTERY_GROUP:
 137:protocol.c    ****          /*do battery things*/
 138:protocol.c    ****          break;
 139:protocol.c    ****       case LIGHTS_GROUP:
 140:protocol.c    **** 	      processLightCommand(command->cmd,command->payload,response);
 923               	.LM74:
 924 0416 8981      		ldd r24,Y+1
 925 0418 9A81      		ldd r25,Y+2
 926 041a 0396      		adiw r24,3
 927 041c 2981      		ldd r18,Y+1
 928 041e 3A81      		ldd r19,Y+2
 929 0420 D901      		movw r26,r18
 930 0422 1196      		adiw r26,1
 931 0424 EC91      		ld r30,X
 932 0426 2B81      		ldd r18,Y+3
 933 0428 3C81      		ldd r19,Y+4
 934 042a A901      		movw r20,r18
 935 042c BC01      		movw r22,r24
 936 042e 8E2F      		mov r24,r30
 937 0430 0E94 0000 		call processLightCommand
 141:protocol.c    ****          break;
 939               	.LM75:
 940 0434 00C0      		rjmp .L43
 941               	.L54:
 142:protocol.c    ****       case ERROR_GROUP:
 143:protocol.c    ****          /*do error things*/
 144:protocol.c    ****          break;
 943               	.LM76:
 944 0436 0000      		nop
 945               	.L43:
 145:protocol.c    ****    }
 146:protocol.c    ****    //return a dummy success for now
 147:protocol.c    ****    return 1;
 947               	.LM77:
 948 0438 81E0      		ldi r24,lo8(1)
 949               	/* epilogue start */
 148:protocol.c    **** }
 951               	.LM78:
 952 043a 0F90      		pop __tmp_reg__
 953 043c 0F90      		pop __tmp_reg__
 954 043e 0F90      		pop __tmp_reg__
 955 0440 0F90      		pop __tmp_reg__
 956 0442 DF91      		pop r29
 957 0444 CF91      		pop r28
 958 0446 0895      		ret
 960               	.Lscope9:
 962               		.stabd	78,0,0
 964               	.Letext0:
 965               		.ident	"GCC: (GNU) 4.8.2"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 protocol.c
     /tmp/cck2kNQR.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cck2kNQR.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cck2kNQR.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cck2kNQR.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/cck2kNQR.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cck2kNQR.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/cck2kNQR.s:70     .text:0000000000000000 commandIntegCheck
     /tmp/cck2kNQR.s:109    .text:000000000000001c processUltrasonicCommand
     /tmp/cck2kNQR.s:221    .text:00000000000000ac processSpeedCommand
     /tmp/cck2kNQR.s:310    .text:0000000000000110 processSteeringCommand
     /tmp/cck2kNQR.s:473    .text:00000000000001f2 processFNRCommand
     /tmp/cck2kNQR.s:559    .text:0000000000000254 processBrakeCommand
     /tmp/cck2kNQR.s:639    .text:00000000000002ae processBatteryCommand
     /tmp/cck2kNQR.s:714    .text:00000000000002fe processLightCommand
     /tmp/cck2kNQR.s:785    .text:000000000000034e processCommand

UNDEFINED SYMBOLS
getAllSensors
getCertainSensor
getSensorGroup
getSpeed
setSpeed
setAngle
getAngle
getDesiredAngle
changePID
setLimits
setFNR
getFNR
setBrake
getBrake
getBatteryVoltage
getSteeringVoltage
setLight
__tablejump2__
