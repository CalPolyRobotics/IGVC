   1               		.file	"tasks.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 160               	.global	pxCurrentTCB
 161               		.section .bss
 164               	pxCurrentTCB:
 165 0000 0000      		.zero	2
 166               		.local	pxReadyTasksLists
 167               		.comm	pxReadyTasksLists,36,1
 168               		.local	xDelayedTaskList1
 169               		.comm	xDelayedTaskList1,9,1
 170               		.local	xDelayedTaskList2
 171               		.comm	xDelayedTaskList2,9,1
 172               		.local	pxDelayedTaskList
 173               		.comm	pxDelayedTaskList,2,1
 174               		.local	pxOverflowDelayedTaskList
 175               		.comm	pxOverflowDelayedTaskList,2,1
 176               		.local	xPendingReadyList
 177               		.comm	xPendingReadyList,9,1
 178               		.local	xSuspendedTaskList
 179               		.comm	xSuspendedTaskList,9,1
 180               		.local	uxCurrentNumberOfTasks
 181               		.comm	uxCurrentNumberOfTasks,1,1
 182               		.local	xTickCount
 183               		.comm	xTickCount,2,1
 184               		.local	uxTopUsedPriority
 185               		.comm	uxTopUsedPriority,1,1
 186               		.local	uxTopReadyPriority
 187               		.comm	uxTopReadyPriority,1,1
 188               		.local	xSchedulerRunning
 189               		.comm	xSchedulerRunning,1,1
 190               		.local	uxSchedulerSuspended
 191               		.comm	uxSchedulerSuspended,1,1
 192               		.local	uxMissedTicks
 193               		.comm	uxMissedTicks,1,1
 194               		.local	xMissedYield
 195               		.comm	xMissedYield,1,1
 196               		.local	xNumOfOverflows
 197               		.comm	xNumOfOverflows,1,1
 198               		.local	uxTaskNumber
 199               		.comm	uxTaskNumber,1,1
 200               		.data
 203               	xNextTaskUnblockTime:
 204 0000 FFFF      		.word	-1
 205               		.text
 215               	.global	xTaskGenericCreate
 217               	xTaskGenericCreate:
 218               		.stabd	46,0,0
   1:../../FreeRTOS/Source/tasks.c **** /*
   2:../../FreeRTOS/Source/tasks.c ****     FreeRTOS V7.3.0 - Copyright (C) 2012 Real Time Engineers Ltd.
   3:../../FreeRTOS/Source/tasks.c **** 
   4:../../FreeRTOS/Source/tasks.c ****     FEATURES AND PORTS ARE ADDED TO FREERTOS ALL THE TIME.  PLEASE VISIT
   5:../../FreeRTOS/Source/tasks.c ****     http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:../../FreeRTOS/Source/tasks.c **** 
   7:../../FreeRTOS/Source/tasks.c ****     ***************************************************************************
   8:../../FreeRTOS/Source/tasks.c ****      *                                                                       *
   9:../../FreeRTOS/Source/tasks.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
  10:../../FreeRTOS/Source/tasks.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
  11:../../FreeRTOS/Source/tasks.c ****      *    available.                                                         *
  12:../../FreeRTOS/Source/tasks.c ****      *                                                                       *
  13:../../FreeRTOS/Source/tasks.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  14:../../FreeRTOS/Source/tasks.c ****      *    ensuring you get running as quickly as possible and with an        *
  15:../../FreeRTOS/Source/tasks.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  16:../../FreeRTOS/Source/tasks.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  17:../../FreeRTOS/Source/tasks.c ****      *    professional grade, cross platform, de facto standard solutions    *
  18:../../FreeRTOS/Source/tasks.c ****      *    for microcontrollers - completely free of charge!                  *
  19:../../FreeRTOS/Source/tasks.c ****      *                                                                       *
  20:../../FreeRTOS/Source/tasks.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  21:../../FreeRTOS/Source/tasks.c ****      *                                                                       *
  22:../../FreeRTOS/Source/tasks.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  23:../../FreeRTOS/Source/tasks.c ****      *                                                                       *
  24:../../FreeRTOS/Source/tasks.c ****     ***************************************************************************
  25:../../FreeRTOS/Source/tasks.c **** 
  26:../../FreeRTOS/Source/tasks.c **** 
  27:../../FreeRTOS/Source/tasks.c ****     This file is part of the FreeRTOS distribution.
  28:../../FreeRTOS/Source/tasks.c **** 
  29:../../FreeRTOS/Source/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  30:../../FreeRTOS/Source/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  31:../../FreeRTOS/Source/tasks.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  32:../../FreeRTOS/Source/tasks.c ****     >>>NOTE<<< The modification to the GPL is included to allow you to
  33:../../FreeRTOS/Source/tasks.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  34:../../FreeRTOS/Source/tasks.c ****     provide the source code for proprietary components outside of the FreeRTOS
  35:../../FreeRTOS/Source/tasks.c ****     kernel.  FreeRTOS is distributed in the hope that it will be useful, but
  36:../../FreeRTOS/Source/tasks.c ****     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  37:../../FreeRTOS/Source/tasks.c ****     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  38:../../FreeRTOS/Source/tasks.c ****     more details. You should have received a copy of the GNU General Public
  39:../../FreeRTOS/Source/tasks.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  40:../../FreeRTOS/Source/tasks.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  41:../../FreeRTOS/Source/tasks.c ****     by writing to Richard Barry, contact details for whom are available on the
  42:../../FreeRTOS/Source/tasks.c ****     FreeRTOS WEB site.
  43:../../FreeRTOS/Source/tasks.c **** 
  44:../../FreeRTOS/Source/tasks.c ****     1 tab == 4 spaces!
  45:../../FreeRTOS/Source/tasks.c **** 
  46:../../FreeRTOS/Source/tasks.c ****     ***************************************************************************
  47:../../FreeRTOS/Source/tasks.c ****      *                                                                       *
  48:../../FreeRTOS/Source/tasks.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  49:../../FreeRTOS/Source/tasks.c ****      *    not run, what could be wrong?"                                     *
  50:../../FreeRTOS/Source/tasks.c ****      *                                                                       *
  51:../../FreeRTOS/Source/tasks.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  52:../../FreeRTOS/Source/tasks.c ****      *                                                                       *
  53:../../FreeRTOS/Source/tasks.c ****     ***************************************************************************
  54:../../FreeRTOS/Source/tasks.c **** 
  55:../../FreeRTOS/Source/tasks.c **** 
  56:../../FreeRTOS/Source/tasks.c ****     http://www.FreeRTOS.org - Documentation, training, latest versions, license
  57:../../FreeRTOS/Source/tasks.c ****     and contact details.
  58:../../FreeRTOS/Source/tasks.c **** 
  59:../../FreeRTOS/Source/tasks.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  60:../../FreeRTOS/Source/tasks.c ****     including FreeRTOS+Trace - an indispensable productivity tool.
  61:../../FreeRTOS/Source/tasks.c **** 
  62:../../FreeRTOS/Source/tasks.c ****     Real Time Engineers ltd license FreeRTOS to High Integrity Systems, who sell
  63:../../FreeRTOS/Source/tasks.c ****     the code with commercial support, indemnification, and middleware, under
  64:../../FreeRTOS/Source/tasks.c ****     the OpenRTOS brand: http://www.OpenRTOS.com.  High Integrity Systems also
  65:../../FreeRTOS/Source/tasks.c ****     provide a safety engineered and independently SIL3 certified version under
  66:../../FreeRTOS/Source/tasks.c ****     the SafeRTOS brand: http://www.SafeRTOS.com.
  67:../../FreeRTOS/Source/tasks.c **** */
  68:../../FreeRTOS/Source/tasks.c **** 
  69:../../FreeRTOS/Source/tasks.c **** #pragma GCC diagnostic ignored "-Wint-to-pointer-cast" 
  70:../../FreeRTOS/Source/tasks.c **** #pragma GCC diagnostic ignored "-Wpointer-to-int-cast"
  71:../../FreeRTOS/Source/tasks.c **** 
  72:../../FreeRTOS/Source/tasks.c **** /* Standard includes. */
  73:../../FreeRTOS/Source/tasks.c **** #include <stdio.h>
  74:../../FreeRTOS/Source/tasks.c **** #include <stdlib.h>
  75:../../FreeRTOS/Source/tasks.c **** #include <string.h>
  76:../../FreeRTOS/Source/tasks.c **** 
  77:../../FreeRTOS/Source/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  78:../../FreeRTOS/Source/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  79:../../FreeRTOS/Source/tasks.c **** task.h is included from an application file. */
  80:../../FreeRTOS/Source/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  81:../../FreeRTOS/Source/tasks.c **** 
  82:../../FreeRTOS/Source/tasks.c **** /* FreeRTOS includes. */
  83:../../FreeRTOS/Source/tasks.c **** #include "FreeRTOS.h"
  84:../../FreeRTOS/Source/tasks.c **** #include "task.h"
  85:../../FreeRTOS/Source/tasks.c **** #include "timers.h"
  86:../../FreeRTOS/Source/tasks.c **** #include "StackMacros.h"
  87:../../FreeRTOS/Source/tasks.c **** 
  88:../../FreeRTOS/Source/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  89:../../FreeRTOS/Source/tasks.c **** 
  90:../../FreeRTOS/Source/tasks.c **** /*
  91:../../FreeRTOS/Source/tasks.c ****  * Defines the size, in words, of the stack allocated to the idle task.
  92:../../FreeRTOS/Source/tasks.c ****  */
  93:../../FreeRTOS/Source/tasks.c **** #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
  94:../../FreeRTOS/Source/tasks.c **** 
  95:../../FreeRTOS/Source/tasks.c **** /*
  96:../../FreeRTOS/Source/tasks.c ****  * Task control block.  A task control block (TCB) is allocated for each task,
  97:../../FreeRTOS/Source/tasks.c ****  * and stores task state information, including a pointer to the task's context
  98:../../FreeRTOS/Source/tasks.c ****  * (the task's run time environment, including register values)
  99:../../FreeRTOS/Source/tasks.c ****  */
 100:../../FreeRTOS/Source/tasks.c **** typedef struct tskTaskControlBlock
 101:../../FreeRTOS/Source/tasks.c **** {
 102:../../FreeRTOS/Source/tasks.c **** 	volatile portSTACK_TYPE	*pxTopOfStack;		/*< Points to the location of the last item placed on the 
 103:../../FreeRTOS/Source/tasks.c **** 
 104:../../FreeRTOS/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 105:../../FreeRTOS/Source/tasks.c **** 		xMPU_SETTINGS xMPUSettings;				/*< The MPU settings are defined as part of the port layer.  THIS 
 106:../../FreeRTOS/Source/tasks.c **** 	#endif
 107:../../FreeRTOS/Source/tasks.c **** 
 108:../../FreeRTOS/Source/tasks.c **** 	xListItem				xGenericListItem;		/*< The list that the state list item of a task is reference from 
 109:../../FreeRTOS/Source/tasks.c **** 	xListItem				xEventListItem;		/*< Used to reference a task from an event list. */
 110:../../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE	uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
 111:../../FreeRTOS/Source/tasks.c **** 	portSTACK_TYPE			*pxStack;			/*< Points to the start of the stack. */
 112:../../FreeRTOS/Source/tasks.c **** 	signed char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when c
 113:../../FreeRTOS/Source/tasks.c **** 
 114:../../FreeRTOS/Source/tasks.c **** 	#if ( portSTACK_GROWTH > 0 )
 115:../../FreeRTOS/Source/tasks.c **** 		portSTACK_TYPE *pxEndOfStack;			/*< Points to the end of the stack on architectures where the sta
 116:../../FreeRTOS/Source/tasks.c **** 	#endif
 117:../../FreeRTOS/Source/tasks.c **** 
 118:../../FreeRTOS/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 119:../../FreeRTOS/Source/tasks.c **** 		unsigned portBASE_TYPE uxCriticalNesting; /*< Holds the critical section nesting depth for ports 
 120:../../FreeRTOS/Source/tasks.c **** 	#endif
 121:../../FreeRTOS/Source/tasks.c **** 
 122:../../FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 123:../../FreeRTOS/Source/tasks.c **** 		unsigned portBASE_TYPE	uxTCBNumber;	/*< Stores a number that increments each time a TCB is create
 124:../../FreeRTOS/Source/tasks.c **** 		unsigned portBASE_TYPE  uxTaskNumber;	/*< Stores a number specifically for use by third party tra
 125:../../FreeRTOS/Source/tasks.c **** 	#endif
 126:../../FreeRTOS/Source/tasks.c **** 
 127:../../FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 128:../../FreeRTOS/Source/tasks.c **** 		unsigned portBASE_TYPE uxBasePriority;	/*< The priority last assigned to the task - used by the p
 129:../../FreeRTOS/Source/tasks.c **** 	#endif
 130:../../FreeRTOS/Source/tasks.c **** 
 131:../../FreeRTOS/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 132:../../FreeRTOS/Source/tasks.c **** 		pdTASK_HOOK_CODE pxTaskTag;
 133:../../FreeRTOS/Source/tasks.c **** 	#endif
 134:../../FreeRTOS/Source/tasks.c **** 
 135:../../FreeRTOS/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 136:../../FreeRTOS/Source/tasks.c **** 		unsigned long ulRunTimeCounter;			/*< Stores the amount of time the task has spent in the Running
 137:../../FreeRTOS/Source/tasks.c **** 	#endif
 138:../../FreeRTOS/Source/tasks.c **** 
 139:../../FreeRTOS/Source/tasks.c **** } tskTCB;
 140:../../FreeRTOS/Source/tasks.c **** 
 141:../../FreeRTOS/Source/tasks.c **** 
 142:../../FreeRTOS/Source/tasks.c **** /*
 143:../../FreeRTOS/Source/tasks.c ****  * Some kernel aware debuggers require the data the debugger needs access to to
 144:../../FreeRTOS/Source/tasks.c ****  * be global, rather than file scope.
 145:../../FreeRTOS/Source/tasks.c ****  */
 146:../../FreeRTOS/Source/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 147:../../FreeRTOS/Source/tasks.c **** 	#define static
 148:../../FreeRTOS/Source/tasks.c **** #endif
 149:../../FreeRTOS/Source/tasks.c **** 
 150:../../FreeRTOS/Source/tasks.c **** /*lint -e956 */
 151:../../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA tskTCB * volatile pxCurrentTCB = NULL;
 152:../../FreeRTOS/Source/tasks.c **** 
 153:../../FreeRTOS/Source/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 154:../../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList pxReadyTasksLists[ configMAX_PRIORITIES ];	/*< Prioritised ready tasks
 155:../../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList1;							/*< Delayed tasks. */
 156:../../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList2;							/*< Delayed tasks (two lists are used - one f
 157:../../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList * volatile pxDelayedTaskList ;				/*< Points to the delayed task list 
 158:../../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task 
 159:../../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList xPendingReadyList;							/*< Tasks that have been readied while the sc
 160:../../FreeRTOS/Source/tasks.c **** 
 161:../../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 162:../../FreeRTOS/Source/tasks.c **** 
 163:../../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static xList xTasksWaitingTermination;				/*< Tasks that have been deleted - but t
 164:../../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTasksDeleted = ( unsigned portBASE_TYPE )
 165:../../FreeRTOS/Source/tasks.c **** 
 166:../../FreeRTOS/Source/tasks.c **** #endif
 167:../../FreeRTOS/Source/tasks.c **** 
 168:../../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 169:../../FreeRTOS/Source/tasks.c **** 
 170:../../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static xList xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 171:../../FreeRTOS/Source/tasks.c **** 
 172:../../FreeRTOS/Source/tasks.c **** #endif
 173:../../FreeRTOS/Source/tasks.c **** 
 174:../../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
 175:../../FreeRTOS/Source/tasks.c **** 
 176:../../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static xTaskHandle xIdleTaskHandle = NULL;			/*< Holds the handle of the idle task
 177:../../FreeRTOS/Source/tasks.c **** 
 178:../../FreeRTOS/Source/tasks.c **** #endif
 179:../../FreeRTOS/Source/tasks.c **** 
 180:../../FreeRTOS/Source/tasks.c **** /* File private variables. --------------------------------*/
 181:../../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxCurrentNumberOfTasks 	= ( unsigned portBAS
 182:../../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile portTickType xTickCount 						= ( portTickType ) 0U;
 183:../../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTopUsedPriority	 				= tskIDLE_PRIORITY;
 184:../../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTopReadyPriority 		= tskIDLE_PRIORITY;
 185:../../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile signed portBASE_TYPE xSchedulerRunning 			= pdFALSE;
 186:../../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxSchedulerSuspended	 	= ( unsigned portBASE
 187:../../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxMissedTicks 			= ( unsigned portBASE_TYPE 
 188:../../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xMissedYield 						= ( portBASE_TYPE ) pdFALSE;
 189:../../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xNumOfOverflows 					= ( portBASE_TYPE ) 0;
 190:../../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTaskNumber 						= ( unsigned portBASE_TYPE ) 0U;
 191:../../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile portTickType xNextTaskUnblockTime				= ( portTickType ) portMAX_DEL
 192:../../FreeRTOS/Source/tasks.c **** 
 193:../../FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 194:../../FreeRTOS/Source/tasks.c **** 
 195:../../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static char pcStatsString[ 50 ] ;
 196:../../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static unsigned long ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/co
 197:../../FreeRTOS/Source/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
 198:../../FreeRTOS/Source/tasks.c **** 
 199:../../FreeRTOS/Source/tasks.c **** #endif
 200:../../FreeRTOS/Source/tasks.c **** 
 201:../../FreeRTOS/Source/tasks.c **** /* Debugging and trace facilities private variables and macros. ------------*/
 202:../../FreeRTOS/Source/tasks.c **** 
 203:../../FreeRTOS/Source/tasks.c **** /*
 204:../../FreeRTOS/Source/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 205:../../FreeRTOS/Source/tasks.c ****  * is used purely for checking the high water mark for tasks.
 206:../../FreeRTOS/Source/tasks.c ****  */
 207:../../FreeRTOS/Source/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
 208:../../FreeRTOS/Source/tasks.c **** 
 209:../../FreeRTOS/Source/tasks.c **** /*
 210:../../FreeRTOS/Source/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 211:../../FreeRTOS/Source/tasks.c ****  */
 212:../../FreeRTOS/Source/tasks.c **** #define tskBLOCKED_CHAR		( ( signed char ) 'B' )
 213:../../FreeRTOS/Source/tasks.c **** #define tskREADY_CHAR		( ( signed char ) 'R' )
 214:../../FreeRTOS/Source/tasks.c **** #define tskDELETED_CHAR		( ( signed char ) 'D' )
 215:../../FreeRTOS/Source/tasks.c **** #define tskSUSPENDED_CHAR	( ( signed char ) 'S' )
 216:../../FreeRTOS/Source/tasks.c **** 
 217:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 218:../../FreeRTOS/Source/tasks.c **** 
 219:../../FreeRTOS/Source/tasks.c **** #if configUSE_PORT_OPTIMISED_TASK_SELECTION == 0
 220:../../FreeRTOS/Source/tasks.c **** 
 221:../../FreeRTOS/Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
 222:../../FreeRTOS/Source/tasks.c **** 	performed in a generic way that is not optimised to any particular
 223:../../FreeRTOS/Source/tasks.c **** 	microcontroller architecture. */
 224:../../FreeRTOS/Source/tasks.c **** 
 225:../../FreeRTOS/Source/tasks.c **** 	/* uxTopReadyPriority holds the priority of the highest priority ready
 226:../../FreeRTOS/Source/tasks.c **** 	state task. */
 227:../../FreeRTOS/Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )																		\
 228:../../FreeRTOS/Source/tasks.c **** 	{																													\
 229:../../FreeRTOS/Source/tasks.c **** 		if( ( uxPriority ) > uxTopReadyPriority )																		\
 230:../../FreeRTOS/Source/tasks.c **** 		{																												\
 231:../../FreeRTOS/Source/tasks.c **** 			uxTopReadyPriority = ( uxPriority );																		\
 232:../../FreeRTOS/Source/tasks.c **** 		}																												\
 233:../../FreeRTOS/Source/tasks.c **** 	} /* taskRECORD_READY_PRIORITY */
 234:../../FreeRTOS/Source/tasks.c **** 
 235:../../FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 236:../../FreeRTOS/Source/tasks.c **** 
 237:../../FreeRTOS/Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()																			\
 238:../../FreeRTOS/Source/tasks.c **** 	{																													\
 239:../../FreeRTOS/Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */												\
 240:../../FreeRTOS/Source/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )										\
 241:../../FreeRTOS/Source/tasks.c **** 		{																												\
 242:../../FreeRTOS/Source/tasks.c **** 			configASSERT( uxTopReadyPriority );																			\
 243:../../FreeRTOS/Source/tasks.c **** 			--uxTopReadyPriority;																						\
 244:../../FreeRTOS/Source/tasks.c **** 		}																												\
 245:../../FreeRTOS/Source/tasks.c **** 																														\
 246:../../FreeRTOS/Source/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of										\
 247:../../FreeRTOS/Source/tasks.c **** 		the	same priority get an equal share of the processor time. */													\
 248:../../FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );						\
 249:../../FreeRTOS/Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
 250:../../FreeRTOS/Source/tasks.c **** 
 251:../../FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 252:../../FreeRTOS/Source/tasks.c **** 
 253:../../FreeRTOS/Source/tasks.c **** 	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
 254:../../FreeRTOS/Source/tasks.c **** 	they are only required when a port optimised method of task selection is
 255:../../FreeRTOS/Source/tasks.c **** 	being used. */
 256:../../FreeRTOS/Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )
 257:../../FreeRTOS/Source/tasks.c **** 	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
 258:../../FreeRTOS/Source/tasks.c **** 
 259:../../FreeRTOS/Source/tasks.c **** #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 260:../../FreeRTOS/Source/tasks.c **** 
 261:../../FreeRTOS/Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
 262:../../FreeRTOS/Source/tasks.c **** 	performed in a way that is tailored to the particular microcontroller
 263:../../FreeRTOS/Source/tasks.c **** 	architecture being used. */
 264:../../FreeRTOS/Source/tasks.c **** 
 265:../../FreeRTOS/Source/tasks.c **** 	/* A port optimised version is provided.  Call the port defined macros. */
 266:../../FreeRTOS/Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyP
 267:../../FreeRTOS/Source/tasks.c **** 
 268:../../FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 269:../../FreeRTOS/Source/tasks.c **** 
 270:../../FreeRTOS/Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
 271:../../FreeRTOS/Source/tasks.c **** 	{																								\
 272:../../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxTopPriority;															\
 273:../../FreeRTOS/Source/tasks.c **** 																									\
 274:../../FreeRTOS/Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */							\
 275:../../FreeRTOS/Source/tasks.c **** 		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
 276:../../FreeRTOS/Source/tasks.c **** 		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
 277:../../FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
 278:../../FreeRTOS/Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
 279:../../FreeRTOS/Source/tasks.c **** 
 280:../../FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 281:../../FreeRTOS/Source/tasks.c **** 
 282:../../FreeRTOS/Source/tasks.c **** 	/* A port optimised version is provided, call it only if the TCB being reset
 283:../../FreeRTOS/Source/tasks.c **** 	is being referenced from a ready list.  If it is referenced from a delayed
 284:../../FreeRTOS/Source/tasks.c **** 	or suspended list then it won't be in a ready list. */
 285:../../FreeRTOS/Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )													\
 286:../../FreeRTOS/Source/tasks.c **** 	{																								\
 287:../../FreeRTOS/Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == 0 )				\
 288:../../FreeRTOS/Source/tasks.c **** 		{																							\
 289:../../FreeRTOS/Source/tasks.c **** 			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );						\
 290:../../FreeRTOS/Source/tasks.c **** 		}																							\
 291:../../FreeRTOS/Source/tasks.c **** 	}
 292:../../FreeRTOS/Source/tasks.c **** 
 293:../../FreeRTOS/Source/tasks.c **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 294:../../FreeRTOS/Source/tasks.c **** 
 295:../../FreeRTOS/Source/tasks.c **** /*
 296:../../FreeRTOS/Source/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready queue for
 297:../../FreeRTOS/Source/tasks.c ****  * the task.  It is inserted at the end of the list.  One quirk of this is
 298:../../FreeRTOS/Source/tasks.c ****  * that if the task being inserted is at the same priority as the currently
 299:../../FreeRTOS/Source/tasks.c ****  * executing task, then it will only be rescheduled after the currently
 300:../../FreeRTOS/Source/tasks.c ****  * executing task has been rescheduled.
 301:../../FreeRTOS/Source/tasks.c ****  */
 302:../../FreeRTOS/Source/tasks.c **** #define prvAddTaskToReadyQueue( pxTCB )																				\
 303:../../FreeRTOS/Source/tasks.c **** 	traceMOVED_TASK_TO_READY_STATE( pxTCB )																			\
 304:../../FreeRTOS/Source/tasks.c **** 	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );																\
 305:../../FreeRTOS/Source/tasks.c **** 	vListInsertEnd( ( xList * ) &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGeneri
 306:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 307:../../FreeRTOS/Source/tasks.c **** 
 308:../../FreeRTOS/Source/tasks.c **** /*
 309:../../FreeRTOS/Source/tasks.c ****  * Macro that looks at the list of tasks that are currently delayed to see if
 310:../../FreeRTOS/Source/tasks.c ****  * any require waking.
 311:../../FreeRTOS/Source/tasks.c ****  *
 312:../../FreeRTOS/Source/tasks.c ****  * Tasks are stored in the queue in the order of their wake time - meaning
 313:../../FreeRTOS/Source/tasks.c ****  * once one tasks has been found whose timer has not expired we need not look
 314:../../FreeRTOS/Source/tasks.c ****  * any further down the list.
 315:../../FreeRTOS/Source/tasks.c ****  */
 316:../../FreeRTOS/Source/tasks.c **** #define prvCheckDelayedTasks()															\
 317:../../FreeRTOS/Source/tasks.c **** {																						\
 318:../../FreeRTOS/Source/tasks.c **** portTickType xItemValue;																\
 319:../../FreeRTOS/Source/tasks.c **** 																						\
 320:../../FreeRTOS/Source/tasks.c **** 	/* Is the tick count greater than or equal to the wake time of the first			\
 321:../../FreeRTOS/Source/tasks.c **** 	task referenced from the delayed tasks list? */										\
 322:../../FreeRTOS/Source/tasks.c **** 	if( xTickCount >= xNextTaskUnblockTime )											\
 323:../../FreeRTOS/Source/tasks.c **** 	{																					\
 324:../../FreeRTOS/Source/tasks.c **** 		for( ;; )																		\
 325:../../FreeRTOS/Source/tasks.c **** 		{																				\
 326:../../FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )						\
 327:../../FreeRTOS/Source/tasks.c **** 			{																			\
 328:../../FreeRTOS/Source/tasks.c **** 				/* The delayed list is empty.  Set xNextTaskUnblockTime to the			\
 329:../../FreeRTOS/Source/tasks.c **** 				maximum possible value so it is extremely unlikely that the				\
 330:../../FreeRTOS/Source/tasks.c **** 				if( xTickCount >= xNextTaskUnblockTime ) test will pass next			\
 331:../../FreeRTOS/Source/tasks.c **** 				time through. */														\
 332:../../FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime = portMAX_DELAY;									\
 333:../../FreeRTOS/Source/tasks.c **** 				break;																	\
 334:../../FreeRTOS/Source/tasks.c **** 			}																			\
 335:../../FreeRTOS/Source/tasks.c **** 			else																		\
 336:../../FreeRTOS/Source/tasks.c **** 			{																			\
 337:../../FreeRTOS/Source/tasks.c **** 				/* The delayed list is not empty, get the value of the item at			\
 338:../../FreeRTOS/Source/tasks.c **** 				the head of the delayed list.  This is the time at which the			\
 339:../../FreeRTOS/Source/tasks.c **** 				task at the head of the delayed list should be removed from				\
 340:../../FreeRTOS/Source/tasks.c **** 				the Blocked state. */													\
 341:../../FreeRTOS/Source/tasks.c **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );	\
 342:../../FreeRTOS/Source/tasks.c **** 				xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );	\
 343:../../FreeRTOS/Source/tasks.c **** 																						\
 344:../../FreeRTOS/Source/tasks.c **** 				if( xTickCount < xItemValue )											\
 345:../../FreeRTOS/Source/tasks.c **** 				{																		\
 346:../../FreeRTOS/Source/tasks.c **** 					/* It is not time to unblock this item yet, but the item			\
 347:../../FreeRTOS/Source/tasks.c **** 					value is the time at which the task at the head of the				\
 348:../../FreeRTOS/Source/tasks.c **** 					blocked list should be removed from the Blocked state -				\
 349:../../FreeRTOS/Source/tasks.c **** 					so record the item value in xNextTaskUnblockTime. */				\
 350:../../FreeRTOS/Source/tasks.c **** 					xNextTaskUnblockTime = xItemValue;									\
 351:../../FreeRTOS/Source/tasks.c **** 					break;																\
 352:../../FreeRTOS/Source/tasks.c **** 				}																		\
 353:../../FreeRTOS/Source/tasks.c **** 																						\
 354:../../FreeRTOS/Source/tasks.c **** 				/* It is time to remove the item from the Blocked state. */				\
 355:../../FreeRTOS/Source/tasks.c **** 				uxListRemove( &( pxTCB->xGenericListItem ) );							\
 356:../../FreeRTOS/Source/tasks.c **** 																						\
 357:../../FreeRTOS/Source/tasks.c **** 				/* Is the task waiting on an event also? */								\
 358:../../FreeRTOS/Source/tasks.c **** 				if( pxTCB->xEventListItem.pvContainer != NULL )							\
 359:../../FreeRTOS/Source/tasks.c **** 				{																		\
 360:../../FreeRTOS/Source/tasks.c **** 					uxListRemove( &( pxTCB->xEventListItem ) );							\
 361:../../FreeRTOS/Source/tasks.c **** 				}																		\
 362:../../FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );										\
 363:../../FreeRTOS/Source/tasks.c **** 			}																			\
 364:../../FreeRTOS/Source/tasks.c **** 		}																				\
 365:../../FreeRTOS/Source/tasks.c **** 	}																					\
 366:../../FreeRTOS/Source/tasks.c **** }
 367:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 368:../../FreeRTOS/Source/tasks.c **** 
 369:../../FreeRTOS/Source/tasks.c **** /*
 370:../../FreeRTOS/Source/tasks.c ****  * Several functions take an xTaskHandle parameter that can optionally be NULL,
 371:../../FreeRTOS/Source/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 372:../../FreeRTOS/Source/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 373:../../FreeRTOS/Source/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 374:../../FreeRTOS/Source/tasks.c ****  */
 375:../../FreeRTOS/Source/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( tskTCB * ) pxCurrentTCB : ( 
 376:../../FreeRTOS/Source/tasks.c **** 
 377:../../FreeRTOS/Source/tasks.c **** /* Callback function prototypes. --------------------------*/
 378:../../FreeRTOS/Source/tasks.c **** extern void vApplicationStackOverflowHook( xTaskHandle pxTask, signed char *pcTaskName ) __attribut
 379:../../FreeRTOS/Source/tasks.c **** extern void vApplicationTickHook( void );
 380:../../FreeRTOS/Source/tasks.c **** 
 381:../../FreeRTOS/Source/tasks.c **** /* File private functions. --------------------------------*/
 382:../../FreeRTOS/Source/tasks.c **** 
 383:../../FreeRTOS/Source/tasks.c **** /*
 384:../../FreeRTOS/Source/tasks.c ****  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
 385:../../FreeRTOS/Source/tasks.c ****  * into the TCB structure.
 386:../../FreeRTOS/Source/tasks.c ****  */
 387:../../FreeRTOS/Source/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
 388:../../FreeRTOS/Source/tasks.c **** 
 389:../../FreeRTOS/Source/tasks.c **** /*
 390:../../FreeRTOS/Source/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 391:../../FreeRTOS/Source/tasks.c ****  * automatically upon the creation of the first task.
 392:../../FreeRTOS/Source/tasks.c ****  */
 393:../../FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 394:../../FreeRTOS/Source/tasks.c **** 
 395:../../FreeRTOS/Source/tasks.c **** /*
 396:../../FreeRTOS/Source/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 397:../../FreeRTOS/Source/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 398:../../FreeRTOS/Source/tasks.c ****  * creation of the first user task.
 399:../../FreeRTOS/Source/tasks.c ****  *
 400:../../FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 401:../../FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 402:../../FreeRTOS/Source/tasks.c ****  *
 403:../../FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
 404:../../FreeRTOS/Source/tasks.c ****  *
 405:../../FreeRTOS/Source/tasks.c ****  */
 406:../../FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 407:../../FreeRTOS/Source/tasks.c **** 
 408:../../FreeRTOS/Source/tasks.c **** /*
 409:../../FreeRTOS/Source/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 410:../../FreeRTOS/Source/tasks.c ****  * including the stack pointed to by the TCB.
 411:../../FreeRTOS/Source/tasks.c ****  *
 412:../../FreeRTOS/Source/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 413:../../FreeRTOS/Source/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 414:../../FreeRTOS/Source/tasks.c ****  */
 415:../../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 416:../../FreeRTOS/Source/tasks.c **** 
 417:../../FreeRTOS/Source/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB ) PRIVILEGED_FUNCTION;
 418:../../FreeRTOS/Source/tasks.c **** 
 419:../../FreeRTOS/Source/tasks.c **** #endif
 420:../../FreeRTOS/Source/tasks.c **** 
 421:../../FreeRTOS/Source/tasks.c **** /*
 422:../../FreeRTOS/Source/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 423:../../FreeRTOS/Source/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 424:../../FreeRTOS/Source/tasks.c ****  * and its TCB deleted.
 425:../../FreeRTOS/Source/tasks.c ****  */
 426:../../FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 427:../../FreeRTOS/Source/tasks.c **** 
 428:../../FreeRTOS/Source/tasks.c **** /*
 429:../../FreeRTOS/Source/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 430:../../FreeRTOS/Source/tasks.c ****  * either the current or the overflow delayed task list.
 431:../../FreeRTOS/Source/tasks.c ****  */
 432:../../FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake ) PRIVILEGED_FUNCTION;
 433:../../FreeRTOS/Source/tasks.c **** 
 434:../../FreeRTOS/Source/tasks.c **** /*
 435:../../FreeRTOS/Source/tasks.c ****  * Allocates memory from the heap for a TCB and associated stack.  Checks the
 436:../../FreeRTOS/Source/tasks.c ****  * allocation was successful.
 437:../../FreeRTOS/Source/tasks.c ****  */
 438:../../FreeRTOS/Source/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
 439:../../FreeRTOS/Source/tasks.c **** 
 440:../../FreeRTOS/Source/tasks.c **** /*
 441:../../FreeRTOS/Source/tasks.c ****  * Called from vTaskList.  vListTasks details all the tasks currently under
 442:../../FreeRTOS/Source/tasks.c ****  * control of the scheduler.  The tasks may be in one of a number of lists.
 443:../../FreeRTOS/Source/tasks.c ****  * prvListTaskWithinSingleList accepts a list and details the tasks from
 444:../../FreeRTOS/Source/tasks.c ****  * within just that list.
 445:../../FreeRTOS/Source/tasks.c ****  *
 446:../../FreeRTOS/Source/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 447:../../FreeRTOS/Source/tasks.c ****  * NORMAL APPLICATION CODE.
 448:../../FreeRTOS/Source/tasks.c ****  */
 449:../../FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 450:../../FreeRTOS/Source/tasks.c **** 
 451:../../FreeRTOS/Source/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
 452:../../FreeRTOS/Source/tasks.c **** 
 453:../../FreeRTOS/Source/tasks.c **** #endif
 454:../../FreeRTOS/Source/tasks.c **** 
 455:../../FreeRTOS/Source/tasks.c **** /*
 456:../../FreeRTOS/Source/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 457:../../FreeRTOS/Source/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 458:../../FreeRTOS/Source/tasks.c ****  * determining how much of the stack remains at the original preset value.
 459:../../FreeRTOS/Source/tasks.c ****  */
 460:../../FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 461:../../FreeRTOS/Source/tasks.c **** 
 462:../../FreeRTOS/Source/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte ) PRIVILEGED_F
 463:../../FreeRTOS/Source/tasks.c **** 
 464:../../FreeRTOS/Source/tasks.c **** #endif
 465:../../FreeRTOS/Source/tasks.c **** 
 466:../../FreeRTOS/Source/tasks.c **** /*
 467:../../FreeRTOS/Source/tasks.c ****  * Return the amount of time, in ticks, that will pass before the kernel will
 468:../../FreeRTOS/Source/tasks.c ****  * next move a task from the Blocked state to the Running state.
 469:../../FreeRTOS/Source/tasks.c ****  *
 470:../../FreeRTOS/Source/tasks.c ****  * This conditional compilation should use inequality to 0, not equality to 1.
 471:../../FreeRTOS/Source/tasks.c ****  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 472:../../FreeRTOS/Source/tasks.c ****  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 473:../../FreeRTOS/Source/tasks.c ****  * set to a value other than 1.
 474:../../FreeRTOS/Source/tasks.c ****  */
 475:../../FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
 476:../../FreeRTOS/Source/tasks.c **** 
 477:../../FreeRTOS/Source/tasks.c **** 	static portTickType prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
 478:../../FreeRTOS/Source/tasks.c **** 
 479:../../FreeRTOS/Source/tasks.c **** #endif
 480:../../FreeRTOS/Source/tasks.c **** 
 481:../../FreeRTOS/Source/tasks.c **** /*lint +e956 */
 482:../../FreeRTOS/Source/tasks.c **** 
 483:../../FreeRTOS/Source/tasks.c **** 
 484:../../FreeRTOS/Source/tasks.c **** 
 485:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
 486:../../FreeRTOS/Source/tasks.c ****  * TASK CREATION API documented in task.h
 487:../../FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
 488:../../FreeRTOS/Source/tasks.c **** 
 489:../../FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, 
 490:../../FreeRTOS/Source/tasks.c **** {
 220               	.LM0:
 221               	.LFBB1:
 222 0000 AF92      		push r10
 223 0002 BF92      		push r11
 224 0004 CF92      		push r12
 225 0006 DF92      		push r13
 226 0008 EF92      		push r14
 227 000a FF92      		push r15
 228 000c 0F93      		push r16
 229 000e 1F93      		push r17
 230 0010 CF93      		push r28
 231 0012 DF93      		push r29
 232 0014 CDB7      		in r28,__SP_L__
 233 0016 DEB7      		in r29,__SP_H__
 234 0018 6497      		sbiw r28,20
 235 001a 0FB6      		in __tmp_reg__,__SREG__
 236 001c F894      		cli
 237 001e DEBF      		out __SP_H__,r29
 238 0020 0FBE      		out __SREG__,__tmp_reg__
 239 0022 CDBF      		out __SP_L__,r28
 240               	/* prologue: function */
 241               	/* frame size = 20 */
 242               	/* stack size = 30 */
 243               	.L__stack_usage = 30
 244 0024 9F83      		std Y+7,r25
 245 0026 8E83      		std Y+6,r24
 246 0028 7987      		std Y+9,r23
 247 002a 6887      		std Y+8,r22
 248 002c 5B87      		std Y+11,r21
 249 002e 4A87      		std Y+10,r20
 250 0030 3D87      		std Y+13,r19
 251 0032 2C87      		std Y+12,r18
 252 0034 0E87      		std Y+14,r16
 253 0036 F88A      		std Y+16,r15
 254 0038 EF86      		std Y+15,r14
 255 003a DA8A      		std Y+18,r13
 256 003c C98A      		std Y+17,r12
 257 003e BC8A      		std Y+20,r11
 258 0040 AB8A      		std Y+19,r10
 491:../../FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xReturn;
 492:../../FreeRTOS/Source/tasks.c **** tskTCB * pxNewTCB;
 493:../../FreeRTOS/Source/tasks.c **** 
 494:../../FreeRTOS/Source/tasks.c **** 	configASSERT( pxTaskCode );
 495:../../FreeRTOS/Source/tasks.c **** 	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
 496:../../FreeRTOS/Source/tasks.c **** 
 497:../../FreeRTOS/Source/tasks.c **** 	/* Allocate the memory required by the TCB and stack for the new task,
 498:../../FreeRTOS/Source/tasks.c **** 	checking that the allocation was successful. */
 499:../../FreeRTOS/Source/tasks.c **** 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 260               	.LM1:
 261 0042 2989      		ldd r18,Y+17
 262 0044 3A89      		ldd r19,Y+18
 263 0046 8A85      		ldd r24,Y+10
 264 0048 9B85      		ldd r25,Y+11
 265 004a B901      		movw r22,r18
 266 004c 0E94 0000 		call prvAllocateTCBAndStack
 267 0050 9B83      		std Y+3,r25
 268 0052 8A83      		std Y+2,r24
 500:../../FreeRTOS/Source/tasks.c **** 
 501:../../FreeRTOS/Source/tasks.c **** 	if( pxNewTCB != NULL )
 270               	.LM2:
 271 0054 8A81      		ldd r24,Y+2
 272 0056 9B81      		ldd r25,Y+3
 273 0058 0097      		sbiw r24,0
 274 005a 01F4      		brne .+2
 275 005c 00C0      		rjmp .L2
 276               	.LBB2:
 502:../../FreeRTOS/Source/tasks.c **** 	{
 503:../../FreeRTOS/Source/tasks.c **** 		portSTACK_TYPE *pxTopOfStack;
 504:../../FreeRTOS/Source/tasks.c **** 
 505:../../FreeRTOS/Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 506:../../FreeRTOS/Source/tasks.c **** 			/* Should the task be created in privileged mode? */
 507:../../FreeRTOS/Source/tasks.c **** 			portBASE_TYPE xRunPrivileged;
 508:../../FreeRTOS/Source/tasks.c **** 			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 509:../../FreeRTOS/Source/tasks.c **** 			{
 510:../../FreeRTOS/Source/tasks.c **** 				xRunPrivileged = pdTRUE;
 511:../../FreeRTOS/Source/tasks.c **** 			}
 512:../../FreeRTOS/Source/tasks.c **** 			else
 513:../../FreeRTOS/Source/tasks.c **** 			{
 514:../../FreeRTOS/Source/tasks.c **** 				xRunPrivileged = pdFALSE;
 515:../../FreeRTOS/Source/tasks.c **** 			}
 516:../../FreeRTOS/Source/tasks.c **** 			uxPriority &= ~portPRIVILEGE_BIT;
 517:../../FreeRTOS/Source/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS == 1 */
 518:../../FreeRTOS/Source/tasks.c **** 
 519:../../FreeRTOS/Source/tasks.c **** 		/* Calculate the top of stack address.  This depends on whether the
 520:../../FreeRTOS/Source/tasks.c **** 		stack grows from high memory to low (as per the 80x86) or visa versa.
 521:../../FreeRTOS/Source/tasks.c **** 		portSTACK_GROWTH is used to make the result positive or negative as
 522:../../FreeRTOS/Source/tasks.c **** 		required by the port. */
 523:../../FreeRTOS/Source/tasks.c **** 		#if( portSTACK_GROWTH < 0 )
 524:../../FreeRTOS/Source/tasks.c **** 		{
 525:../../FreeRTOS/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 278               	.LM3:
 279 005e 8A81      		ldd r24,Y+2
 280 0060 9B81      		ldd r25,Y+3
 281 0062 FC01      		movw r30,r24
 282 0064 2789      		ldd r18,Z+23
 283 0066 308D      		ldd r19,Z+24
 284 0068 8A85      		ldd r24,Y+10
 285 006a 9B85      		ldd r25,Y+11
 286 006c 0197      		sbiw r24,1
 287 006e 820F      		add r24,r18
 288 0070 931F      		adc r25,r19
 289 0072 9D83      		std Y+5,r25
 290 0074 8C83      		std Y+4,r24
 526:../../FreeRTOS/Source/tasks.c **** 			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINT
 527:../../FreeRTOS/Source/tasks.c **** 
 528:../../FreeRTOS/Source/tasks.c **** 			/* Check the alignment of the calculated top of stack is correct. */
 529:../../FreeRTOS/Source/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) =
 530:../../FreeRTOS/Source/tasks.c **** 		}
 531:../../FreeRTOS/Source/tasks.c **** 		#else
 532:../../FreeRTOS/Source/tasks.c **** 		{
 533:../../FreeRTOS/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack;
 534:../../FreeRTOS/Source/tasks.c **** 
 535:../../FreeRTOS/Source/tasks.c **** 			/* Check the alignment of the stack buffer is correct. */
 536:../../FreeRTOS/Source/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxNewTCB->pxStack & ( unsigned long ) portBYTE_ALIGNMENT_MAS
 537:../../FreeRTOS/Source/tasks.c **** 
 538:../../FreeRTOS/Source/tasks.c **** 			/* If we want to use stack checking on architectures that use
 539:../../FreeRTOS/Source/tasks.c **** 			a positive stack growth direction then we also need to store the
 540:../../FreeRTOS/Source/tasks.c **** 			other extreme of the stack space. */
 541:../../FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 542:../../FreeRTOS/Source/tasks.c **** 		}
 543:../../FreeRTOS/Source/tasks.c **** 		#endif
 544:../../FreeRTOS/Source/tasks.c **** 
 545:../../FreeRTOS/Source/tasks.c **** 		/* Setup the newly allocated TCB with the initial state of the task. */
 546:../../FreeRTOS/Source/tasks.c **** 		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 292               	.LM4:
 293 0076 4A85      		ldd r20,Y+10
 294 0078 5B85      		ldd r21,Y+11
 295 007a 2B89      		ldd r18,Y+19
 296 007c 3C89      		ldd r19,Y+20
 297 007e 6885      		ldd r22,Y+8
 298 0080 7985      		ldd r23,Y+9
 299 0082 8A81      		ldd r24,Y+2
 300 0084 9B81      		ldd r25,Y+3
 301 0086 8A01      		movw r16,r20
 302 0088 4E85      		ldd r20,Y+14
 303 008a 0E94 0000 		call prvInitialiseTCBVariables
 547:../../FreeRTOS/Source/tasks.c **** 
 548:../../FreeRTOS/Source/tasks.c **** 		/* Initialize the TCB stack to look as if the task was already running,
 549:../../FreeRTOS/Source/tasks.c **** 		but had been interrupted by the scheduler.  The return address is set
 550:../../FreeRTOS/Source/tasks.c **** 		to the start of the task function. Once the stack has been initialised
 551:../../FreeRTOS/Source/tasks.c **** 		the	top of stack variable is updated. */
 552:../../FreeRTOS/Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 553:../../FreeRTOS/Source/tasks.c **** 		{
 554:../../FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
 555:../../FreeRTOS/Source/tasks.c **** 		}
 556:../../FreeRTOS/Source/tasks.c **** 		#else
 557:../../FreeRTOS/Source/tasks.c **** 		{
 558:../../FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 305               	.LM5:
 306 008e 4C85      		ldd r20,Y+12
 307 0090 5D85      		ldd r21,Y+13
 308 0092 2E81      		ldd r18,Y+6
 309 0094 3F81      		ldd r19,Y+7
 310 0096 8C81      		ldd r24,Y+4
 311 0098 9D81      		ldd r25,Y+5
 312 009a B901      		movw r22,r18
 313 009c 0E94 0000 		call pxPortInitialiseStack
 314 00a0 9C01      		movw r18,r24
 315 00a2 8A81      		ldd r24,Y+2
 316 00a4 9B81      		ldd r25,Y+3
 317 00a6 FC01      		movw r30,r24
 318 00a8 3183      		std Z+1,r19
 319 00aa 2083      		st Z,r18
 559:../../FreeRTOS/Source/tasks.c **** 		}
 560:../../FreeRTOS/Source/tasks.c **** 		#endif
 561:../../FreeRTOS/Source/tasks.c **** 
 562:../../FreeRTOS/Source/tasks.c **** 		/* Check the alignment of the initialised stack. */
 563:../../FreeRTOS/Source/tasks.c **** 		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long
 564:../../FreeRTOS/Source/tasks.c **** 
 565:../../FreeRTOS/Source/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 321               	.LM6:
 322 00ac 8F85      		ldd r24,Y+15
 323 00ae 9889      		ldd r25,Y+16
 324 00b0 0097      		sbiw r24,0
 325 00b2 01F0      		breq .L3
 566:../../FreeRTOS/Source/tasks.c **** 		{
 567:../../FreeRTOS/Source/tasks.c **** 			/* Pass the TCB out - in an anonymous way.  The calling function/
 568:../../FreeRTOS/Source/tasks.c **** 			task can use this as a handle to delete the task later if
 569:../../FreeRTOS/Source/tasks.c **** 			required.*/
 570:../../FreeRTOS/Source/tasks.c **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 327               	.LM7:
 328 00b4 8F85      		ldd r24,Y+15
 329 00b6 9889      		ldd r25,Y+16
 330 00b8 2A81      		ldd r18,Y+2
 331 00ba 3B81      		ldd r19,Y+3
 332 00bc FC01      		movw r30,r24
 333 00be 3183      		std Z+1,r19
 334 00c0 2083      		st Z,r18
 335               	.L3:
 571:../../FreeRTOS/Source/tasks.c **** 		}
 572:../../FreeRTOS/Source/tasks.c **** 
 573:../../FreeRTOS/Source/tasks.c **** 		/* We are going to manipulate the task queues to add this task to a
 574:../../FreeRTOS/Source/tasks.c **** 		ready list, so must make sure no interrupts occur. */
 575:../../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 337               	.LM8:
 338               	/* #APP */
 339               	 ;  575 "../../FreeRTOS/Source/tasks.c" 1
 340 00c2 0FB6      		in		__tmp_reg__, __SREG__
 341               	 ;  0 "" 2
 342               	 ;  575 "../../FreeRTOS/Source/tasks.c" 1
 343 00c4 F894      		cli
 344               	 ;  0 "" 2
 345               	 ;  575 "../../FreeRTOS/Source/tasks.c" 1
 346 00c6 0F92      		push	__tmp_reg__
 347               	 ;  0 "" 2
 576:../../FreeRTOS/Source/tasks.c **** 		{
 577:../../FreeRTOS/Source/tasks.c **** 			uxCurrentNumberOfTasks++;
 349               	.LM9:
 350               	/* #NOAPP */
 351 00c8 8091 0000 		lds r24,uxCurrentNumberOfTasks
 352 00cc 8F5F      		subi r24,lo8(-(1))
 353 00ce 8093 0000 		sts uxCurrentNumberOfTasks,r24
 578:../../FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB == NULL )
 355               	.LM10:
 356 00d2 8091 0000 		lds r24,pxCurrentTCB
 357 00d6 9091 0000 		lds r25,pxCurrentTCB+1
 358 00da 0097      		sbiw r24,0
 359 00dc 01F4      		brne .L4
 579:../../FreeRTOS/Source/tasks.c **** 			{
 580:../../FreeRTOS/Source/tasks.c **** 				/* There are no other tasks, or all the other tasks are in
 581:../../FreeRTOS/Source/tasks.c **** 				the suspended state - make this the current task. */
 582:../../FreeRTOS/Source/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 361               	.LM11:
 362 00de 8A81      		ldd r24,Y+2
 363 00e0 9B81      		ldd r25,Y+3
 364 00e2 9093 0000 		sts pxCurrentTCB+1,r25
 365 00e6 8093 0000 		sts pxCurrentTCB,r24
 583:../../FreeRTOS/Source/tasks.c **** 
 584:../../FreeRTOS/Source/tasks.c **** 				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 367               	.LM12:
 368 00ea 8091 0000 		lds r24,uxCurrentNumberOfTasks
 369 00ee 8130      		cpi r24,lo8(1)
 370 00f0 01F4      		brne .L6
 585:../../FreeRTOS/Source/tasks.c **** 				{
 586:../../FreeRTOS/Source/tasks.c **** 					/* This is the first task to be created so do the preliminary
 587:../../FreeRTOS/Source/tasks.c **** 					initialisation required.  We will not recover if this call
 588:../../FreeRTOS/Source/tasks.c **** 					fails, but we will report the failure. */
 589:../../FreeRTOS/Source/tasks.c **** 					prvInitialiseTaskLists();
 372               	.LM13:
 373 00f2 0E94 0000 		call prvInitialiseTaskLists
 374 00f6 00C0      		rjmp .L6
 375               	.L4:
 590:../../FreeRTOS/Source/tasks.c **** 				}
 591:../../FreeRTOS/Source/tasks.c **** 			}
 592:../../FreeRTOS/Source/tasks.c **** 			else
 593:../../FreeRTOS/Source/tasks.c **** 			{
 594:../../FreeRTOS/Source/tasks.c **** 				/* If the scheduler is not already running, make this task the
 595:../../FreeRTOS/Source/tasks.c **** 				current task if it is the highest priority task to be created
 596:../../FreeRTOS/Source/tasks.c **** 				so far. */
 597:../../FreeRTOS/Source/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 377               	.LM14:
 378 00f8 8091 0000 		lds r24,xSchedulerRunning
 379 00fc 8823      		tst r24
 380 00fe 01F4      		brne .L6
 598:../../FreeRTOS/Source/tasks.c **** 				{
 599:../../FreeRTOS/Source/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 382               	.LM15:
 383 0100 8091 0000 		lds r24,pxCurrentTCB
 384 0104 9091 0000 		lds r25,pxCurrentTCB+1
 385 0108 FC01      		movw r30,r24
 386 010a 9689      		ldd r25,Z+22
 387 010c 8E85      		ldd r24,Y+14
 388 010e 8917      		cp r24,r25
 389 0110 00F0      		brlo .L6
 600:../../FreeRTOS/Source/tasks.c **** 					{
 601:../../FreeRTOS/Source/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 391               	.LM16:
 392 0112 8A81      		ldd r24,Y+2
 393 0114 9B81      		ldd r25,Y+3
 394 0116 9093 0000 		sts pxCurrentTCB+1,r25
 395 011a 8093 0000 		sts pxCurrentTCB,r24
 396               	.L6:
 602:../../FreeRTOS/Source/tasks.c **** 					}
 603:../../FreeRTOS/Source/tasks.c **** 				}
 604:../../FreeRTOS/Source/tasks.c **** 			}
 605:../../FreeRTOS/Source/tasks.c **** 
 606:../../FreeRTOS/Source/tasks.c **** 			/* Remember the top priority to make context switching faster.  Use
 607:../../FreeRTOS/Source/tasks.c **** 			the priority in pxNewTCB as this has been capped to a valid value. */
 608:../../FreeRTOS/Source/tasks.c **** 			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 398               	.LM17:
 399 011e 8A81      		ldd r24,Y+2
 400 0120 9B81      		ldd r25,Y+3
 401 0122 FC01      		movw r30,r24
 402 0124 9689      		ldd r25,Z+22
 403 0126 8091 0000 		lds r24,uxTopUsedPriority
 404 012a 8917      		cp r24,r25
 405 012c 00F4      		brsh .L7
 609:../../FreeRTOS/Source/tasks.c **** 			{
 610:../../FreeRTOS/Source/tasks.c **** 				uxTopUsedPriority = pxNewTCB->uxPriority;
 407               	.LM18:
 408 012e 8A81      		ldd r24,Y+2
 409 0130 9B81      		ldd r25,Y+3
 410 0132 FC01      		movw r30,r24
 411 0134 8689      		ldd r24,Z+22
 412 0136 8093 0000 		sts uxTopUsedPriority,r24
 413               	.L7:
 611:../../FreeRTOS/Source/tasks.c **** 			}
 612:../../FreeRTOS/Source/tasks.c **** 
 613:../../FreeRTOS/Source/tasks.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 614:../../FreeRTOS/Source/tasks.c **** 			{
 615:../../FreeRTOS/Source/tasks.c **** 				/* Add a counter into the TCB for tracing only. */
 616:../../FreeRTOS/Source/tasks.c **** 				pxNewTCB->uxTCBNumber = uxTaskNumber;
 617:../../FreeRTOS/Source/tasks.c **** 			}
 618:../../FreeRTOS/Source/tasks.c **** 			#endif
 619:../../FreeRTOS/Source/tasks.c **** 			uxTaskNumber++;
 415               	.LM19:
 416 013a 8091 0000 		lds r24,uxTaskNumber
 417 013e 8F5F      		subi r24,lo8(-(1))
 418 0140 8093 0000 		sts uxTaskNumber,r24
 620:../../FreeRTOS/Source/tasks.c **** 
 621:../../FreeRTOS/Source/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 420               	.LM20:
 421 0144 8A81      		ldd r24,Y+2
 422 0146 9B81      		ldd r25,Y+3
 423 0148 FC01      		movw r30,r24
 424 014a 9689      		ldd r25,Z+22
 425 014c 8091 0000 		lds r24,uxTopReadyPriority
 426 0150 8917      		cp r24,r25
 427 0152 00F4      		brsh .L8
 429               	.LM21:
 430 0154 8A81      		ldd r24,Y+2
 431 0156 9B81      		ldd r25,Y+3
 432 0158 FC01      		movw r30,r24
 433 015a 8689      		ldd r24,Z+22
 434 015c 8093 0000 		sts uxTopReadyPriority,r24
 435               	.L8:
 437               	.LM22:
 438 0160 8A81      		ldd r24,Y+2
 439 0162 9B81      		ldd r25,Y+3
 440 0164 AC01      		movw r20,r24
 441 0166 4E5F      		subi r20,-2
 442 0168 5F4F      		sbci r21,-1
 443 016a 8A81      		ldd r24,Y+2
 444 016c 9B81      		ldd r25,Y+3
 445 016e FC01      		movw r30,r24
 446 0170 8689      		ldd r24,Z+22
 447 0172 282F      		mov r18,r24
 448 0174 30E0      		ldi r19,0
 449 0176 C901      		movw r24,r18
 450 0178 880F      		lsl r24
 451 017a 991F      		rol r25
 452 017c 880F      		lsl r24
 453 017e 991F      		rol r25
 454 0180 880F      		lsl r24
 455 0182 991F      		rol r25
 456 0184 820F      		add r24,r18
 457 0186 931F      		adc r25,r19
 458 0188 8050      		subi r24,lo8(-(pxReadyTasksLists))
 459 018a 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 460 018c BA01      		movw r22,r20
 461 018e 0E94 0000 		call vListInsertEnd
 622:../../FreeRTOS/Source/tasks.c **** 
 623:../../FreeRTOS/Source/tasks.c **** 			xReturn = pdPASS;
 463               	.LM23:
 464 0192 81E0      		ldi r24,lo8(1)
 465 0194 8983      		std Y+1,r24
 624:../../FreeRTOS/Source/tasks.c **** 			portSETUP_TCB( pxNewTCB );
 625:../../FreeRTOS/Source/tasks.c **** 			traceTASK_CREATE( pxNewTCB );
 626:../../FreeRTOS/Source/tasks.c **** 		}
 627:../../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 467               	.LM24:
 468               	/* #APP */
 469               	 ;  627 "../../FreeRTOS/Source/tasks.c" 1
 470 0196 0F90      		pop		__tmp_reg__
 471               	 ;  0 "" 2
 472               	 ;  627 "../../FreeRTOS/Source/tasks.c" 1
 473 0198 0FBE      		out		__SREG__, __tmp_reg__
 474               	 ;  0 "" 2
 475               	/* #NOAPP */
 476               	.LBE2:
 477 019a 00C0      		rjmp .L9
 478               	.L2:
 628:../../FreeRTOS/Source/tasks.c **** 	}
 629:../../FreeRTOS/Source/tasks.c **** 	else
 630:../../FreeRTOS/Source/tasks.c **** 	{
 631:../../FreeRTOS/Source/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 480               	.LM25:
 481 019c 8FEF      		ldi r24,lo8(-1)
 482 019e 8983      		std Y+1,r24
 483               	.L9:
 632:../../FreeRTOS/Source/tasks.c **** 		traceTASK_CREATE_FAILED();
 633:../../FreeRTOS/Source/tasks.c **** 	}
 634:../../FreeRTOS/Source/tasks.c **** 
 635:../../FreeRTOS/Source/tasks.c **** 	if( xReturn == pdPASS )
 485               	.LM26:
 486 01a0 8981      		ldd r24,Y+1
 487 01a2 8130      		cpi r24,lo8(1)
 488 01a4 01F4      		brne .L10
 636:../../FreeRTOS/Source/tasks.c **** 	{
 637:../../FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 490               	.LM27:
 491 01a6 8091 0000 		lds r24,xSchedulerRunning
 492 01aa 8823      		tst r24
 493 01ac 01F0      		breq .L10
 638:../../FreeRTOS/Source/tasks.c **** 		{
 639:../../FreeRTOS/Source/tasks.c **** 			/* If the created task is of a higher priority than the current task
 640:../../FreeRTOS/Source/tasks.c **** 			then it should run now. */
 641:../../FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 495               	.LM28:
 496 01ae 8091 0000 		lds r24,pxCurrentTCB
 497 01b2 9091 0000 		lds r25,pxCurrentTCB+1
 498 01b6 FC01      		movw r30,r24
 499 01b8 9689      		ldd r25,Z+22
 500 01ba 8E85      		ldd r24,Y+14
 501 01bc 9817      		cp r25,r24
 502 01be 00F4      		brsh .L10
 642:../../FreeRTOS/Source/tasks.c **** 			{
 643:../../FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 504               	.LM29:
 505 01c0 0E94 0000 		call vPortYield
 506               	.L10:
 644:../../FreeRTOS/Source/tasks.c **** 			}
 645:../../FreeRTOS/Source/tasks.c **** 		}
 646:../../FreeRTOS/Source/tasks.c **** 	}
 647:../../FreeRTOS/Source/tasks.c **** 
 648:../../FreeRTOS/Source/tasks.c **** 	return xReturn;
 508               	.LM30:
 509 01c4 8981      		ldd r24,Y+1
 510               	/* epilogue start */
 649:../../FreeRTOS/Source/tasks.c **** }
 512               	.LM31:
 513 01c6 6496      		adiw r28,20
 514 01c8 0FB6      		in __tmp_reg__,__SREG__
 515 01ca F894      		cli
 516 01cc DEBF      		out __SP_H__,r29
 517 01ce 0FBE      		out __SREG__,__tmp_reg__
 518 01d0 CDBF      		out __SP_L__,r28
 519 01d2 DF91      		pop r29
 520 01d4 CF91      		pop r28
 521 01d6 1F91      		pop r17
 522 01d8 0F91      		pop r16
 523 01da FF90      		pop r15
 524 01dc EF90      		pop r14
 525 01de DF90      		pop r13
 526 01e0 CF90      		pop r12
 527 01e2 BF90      		pop r11
 528 01e4 AF90      		pop r10
 529 01e6 0895      		ret
 538               	.Lscope1:
 540               		.stabd	78,0,0
 544               	.global	vTaskDelayUntil
 546               	vTaskDelayUntil:
 547               		.stabd	46,0,0
 650:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 651:../../FreeRTOS/Source/tasks.c **** 
 652:../../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 653:../../FreeRTOS/Source/tasks.c **** 
 654:../../FreeRTOS/Source/tasks.c **** 	void vTaskDelete( xTaskHandle pxTaskToDelete )
 655:../../FreeRTOS/Source/tasks.c **** 	{
 656:../../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 657:../../FreeRTOS/Source/tasks.c **** 
 658:../../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 659:../../FreeRTOS/Source/tasks.c **** 		{
 660:../../FreeRTOS/Source/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 661:../../FreeRTOS/Source/tasks.c **** 			deleted. */
 662:../../FreeRTOS/Source/tasks.c **** 			if( pxTaskToDelete == pxCurrentTCB )
 663:../../FreeRTOS/Source/tasks.c **** 			{
 664:../../FreeRTOS/Source/tasks.c **** 				pxTaskToDelete = NULL;
 665:../../FreeRTOS/Source/tasks.c **** 			}
 666:../../FreeRTOS/Source/tasks.c **** 
 667:../../FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are deleting ourselves. */
 668:../../FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
 669:../../FreeRTOS/Source/tasks.c **** 
 670:../../FreeRTOS/Source/tasks.c **** 			/* Remove task from the ready list and place in the	termination list.
 671:../../FreeRTOS/Source/tasks.c **** 			This will stop the task from be scheduled.  The idle task will check
 672:../../FreeRTOS/Source/tasks.c **** 			the termination list and free up any memory allocated by the
 673:../../FreeRTOS/Source/tasks.c **** 			scheduler for the TCB and stack. */
 674:../../FreeRTOS/Source/tasks.c **** 			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
 675:../../FreeRTOS/Source/tasks.c **** 			{
 676:../../FreeRTOS/Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 677:../../FreeRTOS/Source/tasks.c **** 			}
 678:../../FreeRTOS/Source/tasks.c **** 
 679:../../FreeRTOS/Source/tasks.c **** 			/* Is the task waiting on an event also? */
 680:../../FreeRTOS/Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 681:../../FreeRTOS/Source/tasks.c **** 			{
 682:../../FreeRTOS/Source/tasks.c **** 				uxListRemove( &( pxTCB->xEventListItem ) );
 683:../../FreeRTOS/Source/tasks.c **** 			}
 684:../../FreeRTOS/Source/tasks.c **** 
 685:../../FreeRTOS/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 686:../../FreeRTOS/Source/tasks.c **** 
 687:../../FreeRTOS/Source/tasks.c **** 			/* Increment the ucTasksDeleted variable so the idle task knows
 688:../../FreeRTOS/Source/tasks.c **** 			there is a task that has been deleted and that it should therefore
 689:../../FreeRTOS/Source/tasks.c **** 			check the xTasksWaitingTermination list. */
 690:../../FreeRTOS/Source/tasks.c **** 			++uxTasksDeleted;
 691:../../FreeRTOS/Source/tasks.c **** 
 692:../../FreeRTOS/Source/tasks.c **** 			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
 693:../../FreeRTOS/Source/tasks.c **** 			can detect that the task lists need re-generating. */
 694:../../FreeRTOS/Source/tasks.c **** 			uxTaskNumber++;
 695:../../FreeRTOS/Source/tasks.c **** 
 696:../../FreeRTOS/Source/tasks.c **** 			traceTASK_DELETE( pxTCB );
 697:../../FreeRTOS/Source/tasks.c **** 		}
 698:../../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 699:../../FreeRTOS/Source/tasks.c **** 
 700:../../FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if we have just deleted the current task. */
 701:../../FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 702:../../FreeRTOS/Source/tasks.c **** 		{
 703:../../FreeRTOS/Source/tasks.c **** 			if( ( void * ) pxTaskToDelete == NULL )
 704:../../FreeRTOS/Source/tasks.c **** 			{
 705:../../FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 706:../../FreeRTOS/Source/tasks.c **** 			}
 707:../../FreeRTOS/Source/tasks.c **** 		}
 708:../../FreeRTOS/Source/tasks.c **** 	}
 709:../../FreeRTOS/Source/tasks.c **** 
 710:../../FreeRTOS/Source/tasks.c **** #endif
 711:../../FreeRTOS/Source/tasks.c **** 
 712:../../FreeRTOS/Source/tasks.c **** 
 713:../../FreeRTOS/Source/tasks.c **** 
 714:../../FreeRTOS/Source/tasks.c **** 
 715:../../FreeRTOS/Source/tasks.c **** 
 716:../../FreeRTOS/Source/tasks.c **** 
 717:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
 718:../../FreeRTOS/Source/tasks.c ****  * TASK CONTROL API documented in task.h
 719:../../FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
 720:../../FreeRTOS/Source/tasks.c **** 
 721:../../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
 722:../../FreeRTOS/Source/tasks.c **** 
 723:../../FreeRTOS/Source/tasks.c **** 	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
 724:../../FreeRTOS/Source/tasks.c **** 	{
 549               	.LM32:
 550               	.LFBB2:
 551 01e8 CF93      		push r28
 552 01ea DF93      		push r29
 553 01ec CDB7      		in r28,__SP_L__
 554 01ee DEB7      		in r29,__SP_H__
 555 01f0 2897      		sbiw r28,8
 556 01f2 0FB6      		in __tmp_reg__,__SREG__
 557 01f4 F894      		cli
 558 01f6 DEBF      		out __SP_H__,r29
 559 01f8 0FBE      		out __SREG__,__tmp_reg__
 560 01fa CDBF      		out __SP_L__,r28
 561               	/* prologue: function */
 562               	/* frame size = 8 */
 563               	/* stack size = 10 */
 564               	.L__stack_usage = 10
 565 01fc 9E83      		std Y+6,r25
 566 01fe 8D83      		std Y+5,r24
 567 0200 7887      		std Y+8,r23
 568 0202 6F83      		std Y+7,r22
 725:../../FreeRTOS/Source/tasks.c **** 	portTickType xTimeToWake;
 726:../../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 570               	.LM33:
 571 0204 1982      		std Y+1,__zero_reg__
 727:../../FreeRTOS/Source/tasks.c **** 
 728:../../FreeRTOS/Source/tasks.c **** 		configASSERT( pxPreviousWakeTime );
 729:../../FreeRTOS/Source/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
 730:../../FreeRTOS/Source/tasks.c **** 
 731:../../FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
 573               	.LM34:
 574 0206 0E94 0000 		call vTaskSuspendAll
 732:../../FreeRTOS/Source/tasks.c **** 		{
 733:../../FreeRTOS/Source/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
 734:../../FreeRTOS/Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 576               	.LM35:
 577 020a 8D81      		ldd r24,Y+5
 578 020c 9E81      		ldd r25,Y+6
 579 020e FC01      		movw r30,r24
 580 0210 2081      		ld r18,Z
 581 0212 3181      		ldd r19,Z+1
 582 0214 8F81      		ldd r24,Y+7
 583 0216 9885      		ldd r25,Y+8
 584 0218 820F      		add r24,r18
 585 021a 931F      		adc r25,r19
 586 021c 9B83      		std Y+3,r25
 587 021e 8A83      		std Y+2,r24
 735:../../FreeRTOS/Source/tasks.c **** 
 736:../../FreeRTOS/Source/tasks.c **** 			if( xTickCount < *pxPreviousWakeTime )
 589               	.LM36:
 590 0220 8D81      		ldd r24,Y+5
 591 0222 9E81      		ldd r25,Y+6
 592 0224 FC01      		movw r30,r24
 593 0226 2081      		ld r18,Z
 594 0228 3181      		ldd r19,Z+1
 595 022a 8091 0000 		lds r24,xTickCount
 596 022e 9091 0000 		lds r25,xTickCount+1
 597 0232 8217      		cp r24,r18
 598 0234 9307      		cpc r25,r19
 599 0236 00F4      		brsh .L13
 737:../../FreeRTOS/Source/tasks.c **** 			{
 738:../../FreeRTOS/Source/tasks.c **** 				/* The tick count has overflowed since this function was
 739:../../FreeRTOS/Source/tasks.c **** 				lasted called.  In this case the only time we should ever
 740:../../FreeRTOS/Source/tasks.c **** 				actually delay is if the wake time has also	overflowed,
 741:../../FreeRTOS/Source/tasks.c **** 				and the wake time is greater than the tick time.  When this
 742:../../FreeRTOS/Source/tasks.c **** 				is the case it is as if neither time had overflowed. */
 743:../../FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 601               	.LM37:
 602 0238 8D81      		ldd r24,Y+5
 603 023a 9E81      		ldd r25,Y+6
 604 023c FC01      		movw r30,r24
 605 023e 2081      		ld r18,Z
 606 0240 3181      		ldd r19,Z+1
 607 0242 8A81      		ldd r24,Y+2
 608 0244 9B81      		ldd r25,Y+3
 609 0246 8217      		cp r24,r18
 610 0248 9307      		cpc r25,r19
 611 024a 00F4      		brsh .L15
 613               	.LM38:
 614 024c 8091 0000 		lds r24,xTickCount
 615 0250 9091 0000 		lds r25,xTickCount+1
 616 0254 2A81      		ldd r18,Y+2
 617 0256 3B81      		ldd r19,Y+3
 618 0258 8217      		cp r24,r18
 619 025a 9307      		cpc r25,r19
 620 025c 00F4      		brsh .L15
 744:../../FreeRTOS/Source/tasks.c **** 				{
 745:../../FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 622               	.LM39:
 623 025e 81E0      		ldi r24,lo8(1)
 624 0260 8983      		std Y+1,r24
 625 0262 00C0      		rjmp .L15
 626               	.L13:
 746:../../FreeRTOS/Source/tasks.c **** 				}
 747:../../FreeRTOS/Source/tasks.c **** 			}
 748:../../FreeRTOS/Source/tasks.c **** 			else
 749:../../FreeRTOS/Source/tasks.c **** 			{
 750:../../FreeRTOS/Source/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
 751:../../FreeRTOS/Source/tasks.c **** 				delay if either the wake time has overflowed, and/or the
 752:../../FreeRTOS/Source/tasks.c **** 				tick time is less than the wake time. */
 753:../../FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 628               	.LM40:
 629 0264 8D81      		ldd r24,Y+5
 630 0266 9E81      		ldd r25,Y+6
 631 0268 FC01      		movw r30,r24
 632 026a 2081      		ld r18,Z
 633 026c 3181      		ldd r19,Z+1
 634 026e 8A81      		ldd r24,Y+2
 635 0270 9B81      		ldd r25,Y+3
 636 0272 8217      		cp r24,r18
 637 0274 9307      		cpc r25,r19
 638 0276 00F0      		brlo .L16
 640               	.LM41:
 641 0278 8091 0000 		lds r24,xTickCount
 642 027c 9091 0000 		lds r25,xTickCount+1
 643 0280 2A81      		ldd r18,Y+2
 644 0282 3B81      		ldd r19,Y+3
 645 0284 8217      		cp r24,r18
 646 0286 9307      		cpc r25,r19
 647 0288 00F4      		brsh .L15
 648               	.L16:
 754:../../FreeRTOS/Source/tasks.c **** 				{
 755:../../FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 650               	.LM42:
 651 028a 81E0      		ldi r24,lo8(1)
 652 028c 8983      		std Y+1,r24
 653               	.L15:
 756:../../FreeRTOS/Source/tasks.c **** 				}
 757:../../FreeRTOS/Source/tasks.c **** 			}
 758:../../FreeRTOS/Source/tasks.c **** 
 759:../../FreeRTOS/Source/tasks.c **** 			/* Update the wake time ready for the next call. */
 760:../../FreeRTOS/Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 655               	.LM43:
 656 028e 8D81      		ldd r24,Y+5
 657 0290 9E81      		ldd r25,Y+6
 658 0292 2A81      		ldd r18,Y+2
 659 0294 3B81      		ldd r19,Y+3
 660 0296 FC01      		movw r30,r24
 661 0298 3183      		std Z+1,r19
 662 029a 2083      		st Z,r18
 761:../../FreeRTOS/Source/tasks.c **** 
 762:../../FreeRTOS/Source/tasks.c **** 			if( xShouldDelay != pdFALSE )
 664               	.LM44:
 665 029c 8981      		ldd r24,Y+1
 666 029e 8823      		tst r24
 667 02a0 01F0      		breq .L17
 763:../../FreeRTOS/Source/tasks.c **** 			{
 764:../../FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY_UNTIL();
 765:../../FreeRTOS/Source/tasks.c **** 
 766:../../FreeRTOS/Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 767:../../FreeRTOS/Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 768:../../FreeRTOS/Source/tasks.c **** 				both lists. */
 769:../../FreeRTOS/Source/tasks.c **** 				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
 669               	.LM45:
 670 02a2 8091 0000 		lds r24,pxCurrentTCB
 671 02a6 9091 0000 		lds r25,pxCurrentTCB+1
 672 02aa 0296      		adiw r24,2
 673 02ac 0E94 0000 		call uxListRemove
 770:../../FreeRTOS/Source/tasks.c **** 				{
 771:../../FreeRTOS/Source/tasks.c **** 					/* The current task must be in a ready list, so there is
 772:../../FreeRTOS/Source/tasks.c **** 					no need to check, and the port reset macro can be called
 773:../../FreeRTOS/Source/tasks.c **** 					directly. */
 774:../../FreeRTOS/Source/tasks.c **** 					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 775:../../FreeRTOS/Source/tasks.c **** 				}
 776:../../FreeRTOS/Source/tasks.c **** 
 777:../../FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 675               	.LM46:
 676 02b0 8A81      		ldd r24,Y+2
 677 02b2 9B81      		ldd r25,Y+3
 678 02b4 0E94 0000 		call prvAddCurrentTaskToDelayedList
 679               	.L17:
 778:../../FreeRTOS/Source/tasks.c **** 			}
 779:../../FreeRTOS/Source/tasks.c **** 		}
 780:../../FreeRTOS/Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 681               	.LM47:
 682 02b8 0E94 0000 		call xTaskResumeAll
 683 02bc 8C83      		std Y+4,r24
 781:../../FreeRTOS/Source/tasks.c **** 
 782:../../FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 783:../../FreeRTOS/Source/tasks.c **** 		have put ourselves to sleep. */
 784:../../FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 685               	.LM48:
 686 02be 8C81      		ldd r24,Y+4
 687 02c0 8823      		tst r24
 688 02c2 01F4      		brne .L12
 785:../../FreeRTOS/Source/tasks.c **** 		{
 786:../../FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
 690               	.LM49:
 691 02c4 0E94 0000 		call vPortYield
 692               	.L12:
 693               	/* epilogue start */
 787:../../FreeRTOS/Source/tasks.c **** 		}
 788:../../FreeRTOS/Source/tasks.c **** 	}
 695               	.LM50:
 696 02c8 2896      		adiw r28,8
 697 02ca 0FB6      		in __tmp_reg__,__SREG__
 698 02cc F894      		cli
 699 02ce DEBF      		out __SP_H__,r29
 700 02d0 0FBE      		out __SREG__,__tmp_reg__
 701 02d2 CDBF      		out __SP_L__,r28
 702 02d4 DF91      		pop r29
 703 02d6 CF91      		pop r28
 704 02d8 0895      		ret
 711               	.Lscope2:
 713               		.stabd	78,0,0
 716               	.global	vTaskDelay
 718               	vTaskDelay:
 719               		.stabd	46,0,0
 789:../../FreeRTOS/Source/tasks.c **** 
 790:../../FreeRTOS/Source/tasks.c **** #endif
 791:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 792:../../FreeRTOS/Source/tasks.c **** 
 793:../../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
 794:../../FreeRTOS/Source/tasks.c **** 
 795:../../FreeRTOS/Source/tasks.c **** 	void vTaskDelay( portTickType xTicksToDelay )
 796:../../FreeRTOS/Source/tasks.c **** 	{
 721               	.LM51:
 722               	.LFBB3:
 723 02da CF93      		push r28
 724 02dc DF93      		push r29
 725 02de 00D0      		rcall .
 726 02e0 1F92      		push __zero_reg__
 727 02e2 1F92      		push __zero_reg__
 728 02e4 CDB7      		in r28,__SP_L__
 729 02e6 DEB7      		in r29,__SP_H__
 730               	/* prologue: function */
 731               	/* frame size = 5 */
 732               	/* stack size = 7 */
 733               	.L__stack_usage = 7
 734 02e8 9D83      		std Y+5,r25
 735 02ea 8C83      		std Y+4,r24
 797:../../FreeRTOS/Source/tasks.c **** 	portTickType xTimeToWake;
 798:../../FreeRTOS/Source/tasks.c **** 	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 737               	.LM52:
 738 02ec 1982      		std Y+1,__zero_reg__
 799:../../FreeRTOS/Source/tasks.c **** 
 800:../../FreeRTOS/Source/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
 801:../../FreeRTOS/Source/tasks.c **** 		if( xTicksToDelay > ( portTickType ) 0U )
 740               	.LM53:
 741 02ee 8C81      		ldd r24,Y+4
 742 02f0 9D81      		ldd r25,Y+5
 743 02f2 0097      		sbiw r24,0
 744 02f4 01F0      		breq .L20
 802:../../FreeRTOS/Source/tasks.c **** 		{
 803:../../FreeRTOS/Source/tasks.c **** 			vTaskSuspendAll();
 746               	.LM54:
 747 02f6 0E94 0000 		call vTaskSuspendAll
 804:../../FreeRTOS/Source/tasks.c **** 			{
 805:../../FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY();
 806:../../FreeRTOS/Source/tasks.c **** 
 807:../../FreeRTOS/Source/tasks.c **** 				/* A task that is removed from the event list while the
 808:../../FreeRTOS/Source/tasks.c **** 				scheduler is suspended will not get placed in the ready
 809:../../FreeRTOS/Source/tasks.c **** 				list or removed from the blocked list until the scheduler
 810:../../FreeRTOS/Source/tasks.c **** 				is resumed.
 811:../../FreeRTOS/Source/tasks.c **** 
 812:../../FreeRTOS/Source/tasks.c **** 				This task cannot be in an event list as it is the currently
 813:../../FreeRTOS/Source/tasks.c **** 				executing task. */
 814:../../FreeRTOS/Source/tasks.c **** 
 815:../../FreeRTOS/Source/tasks.c **** 				/* Calculate the time to wake - this may overflow but this is
 816:../../FreeRTOS/Source/tasks.c **** 				not a problem. */
 817:../../FreeRTOS/Source/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 749               	.LM55:
 750 02fa 2091 0000 		lds r18,xTickCount
 751 02fe 3091 0000 		lds r19,xTickCount+1
 752 0302 8C81      		ldd r24,Y+4
 753 0304 9D81      		ldd r25,Y+5
 754 0306 820F      		add r24,r18
 755 0308 931F      		adc r25,r19
 756 030a 9B83      		std Y+3,r25
 757 030c 8A83      		std Y+2,r24
 818:../../FreeRTOS/Source/tasks.c **** 
 819:../../FreeRTOS/Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 820:../../FreeRTOS/Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 821:../../FreeRTOS/Source/tasks.c **** 				both lists. */
 822:../../FreeRTOS/Source/tasks.c **** 				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
 759               	.LM56:
 760 030e 8091 0000 		lds r24,pxCurrentTCB
 761 0312 9091 0000 		lds r25,pxCurrentTCB+1
 762 0316 0296      		adiw r24,2
 763 0318 0E94 0000 		call uxListRemove
 823:../../FreeRTOS/Source/tasks.c **** 				{
 824:../../FreeRTOS/Source/tasks.c **** 					/* The current task must be in a ready list, so there is
 825:../../FreeRTOS/Source/tasks.c **** 					no need to check, and the port reset macro can be called
 826:../../FreeRTOS/Source/tasks.c **** 					directly. */
 827:../../FreeRTOS/Source/tasks.c **** 					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 828:../../FreeRTOS/Source/tasks.c **** 				}
 829:../../FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 765               	.LM57:
 766 031c 8A81      		ldd r24,Y+2
 767 031e 9B81      		ldd r25,Y+3
 768 0320 0E94 0000 		call prvAddCurrentTaskToDelayedList
 830:../../FreeRTOS/Source/tasks.c **** 			}
 831:../../FreeRTOS/Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 770               	.LM58:
 771 0324 0E94 0000 		call xTaskResumeAll
 772 0328 8983      		std Y+1,r24
 773               	.L20:
 832:../../FreeRTOS/Source/tasks.c **** 		}
 833:../../FreeRTOS/Source/tasks.c **** 
 834:../../FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 835:../../FreeRTOS/Source/tasks.c **** 		have put ourselves to sleep. */
 836:../../FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 775               	.LM59:
 776 032a 8981      		ldd r24,Y+1
 777 032c 8823      		tst r24
 778 032e 01F4      		brne .L19
 837:../../FreeRTOS/Source/tasks.c **** 		{
 838:../../FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
 780               	.LM60:
 781 0330 0E94 0000 		call vPortYield
 782               	.L19:
 783               	/* epilogue start */
 839:../../FreeRTOS/Source/tasks.c **** 		}
 840:../../FreeRTOS/Source/tasks.c **** 	}
 785               	.LM61:
 786 0334 0F90      		pop __tmp_reg__
 787 0336 0F90      		pop __tmp_reg__
 788 0338 0F90      		pop __tmp_reg__
 789 033a 0F90      		pop __tmp_reg__
 790 033c 0F90      		pop __tmp_reg__
 791 033e DF91      		pop r29
 792 0340 CF91      		pop r28
 793 0342 0895      		ret
 799               	.Lscope3:
 801               		.stabd	78,0,0
 804               	.global	vTaskSuspend
 806               	vTaskSuspend:
 807               		.stabd	46,0,0
 841:../../FreeRTOS/Source/tasks.c **** 
 842:../../FreeRTOS/Source/tasks.c **** #endif
 843:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 844:../../FreeRTOS/Source/tasks.c **** 
 845:../../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_eTaskStateGet == 1 )
 846:../../FreeRTOS/Source/tasks.c **** 
 847:../../FreeRTOS/Source/tasks.c **** 	eTaskState eTaskStateGet( xTaskHandle pxTask )
 848:../../FreeRTOS/Source/tasks.c **** 	{
 849:../../FreeRTOS/Source/tasks.c **** 	eTaskState eReturn;
 850:../../FreeRTOS/Source/tasks.c **** 	xList *pxStateList;
 851:../../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 852:../../FreeRTOS/Source/tasks.c **** 
 853:../../FreeRTOS/Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTask;
 854:../../FreeRTOS/Source/tasks.c **** 
 855:../../FreeRTOS/Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
 856:../../FreeRTOS/Source/tasks.c **** 		{
 857:../../FreeRTOS/Source/tasks.c **** 			/* The task calling this function is querying its own state. */
 858:../../FreeRTOS/Source/tasks.c **** 			eReturn = eRunning;
 859:../../FreeRTOS/Source/tasks.c **** 		}
 860:../../FreeRTOS/Source/tasks.c **** 		else
 861:../../FreeRTOS/Source/tasks.c **** 		{
 862:../../FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
 863:../../FreeRTOS/Source/tasks.c **** 			{
 864:../../FreeRTOS/Source/tasks.c **** 				pxStateList = ( xList * ) listLIST_ITEM_CONTAINER( &( pxTCB->xGenericListItem ) );
 865:../../FreeRTOS/Source/tasks.c **** 			}
 866:../../FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
 867:../../FreeRTOS/Source/tasks.c **** 
 868:../../FreeRTOS/Source/tasks.c **** 			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
 869:../../FreeRTOS/Source/tasks.c **** 			{
 870:../../FreeRTOS/Source/tasks.c **** 				/* The task being queried is referenced from one of the Blocked
 871:../../FreeRTOS/Source/tasks.c **** 				lists. */
 872:../../FreeRTOS/Source/tasks.c **** 				eReturn = eBlocked;
 873:../../FreeRTOS/Source/tasks.c **** 			}
 874:../../FreeRTOS/Source/tasks.c **** 
 875:../../FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
 876:../../FreeRTOS/Source/tasks.c **** 				else if( pxStateList == &xSuspendedTaskList )
 877:../../FreeRTOS/Source/tasks.c **** 				{
 878:../../FreeRTOS/Source/tasks.c **** 					/* The task being queried is referenced from the suspended
 879:../../FreeRTOS/Source/tasks.c **** 					list. */
 880:../../FreeRTOS/Source/tasks.c **** 					eReturn = eSuspended;
 881:../../FreeRTOS/Source/tasks.c **** 				}
 882:../../FreeRTOS/Source/tasks.c **** 			#endif
 883:../../FreeRTOS/Source/tasks.c **** 
 884:../../FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
 885:../../FreeRTOS/Source/tasks.c **** 				else if( pxStateList == &xTasksWaitingTermination )
 886:../../FreeRTOS/Source/tasks.c **** 				{
 887:../../FreeRTOS/Source/tasks.c **** 					/* The task being queried is referenced from the deleted
 888:../../FreeRTOS/Source/tasks.c **** 					tasks list. */
 889:../../FreeRTOS/Source/tasks.c **** 					eReturn = eDeleted;
 890:../../FreeRTOS/Source/tasks.c **** 				}
 891:../../FreeRTOS/Source/tasks.c **** 			#endif
 892:../../FreeRTOS/Source/tasks.c **** 
 893:../../FreeRTOS/Source/tasks.c **** 			else
 894:../../FreeRTOS/Source/tasks.c **** 			{
 895:../../FreeRTOS/Source/tasks.c **** 				/* If the task is not in any other state, it must be in the
 896:../../FreeRTOS/Source/tasks.c **** 				Ready (including pending ready) state. */
 897:../../FreeRTOS/Source/tasks.c **** 				eReturn = eReady;
 898:../../FreeRTOS/Source/tasks.c **** 			}
 899:../../FreeRTOS/Source/tasks.c **** 		}
 900:../../FreeRTOS/Source/tasks.c **** 
 901:../../FreeRTOS/Source/tasks.c **** 		return eReturn;
 902:../../FreeRTOS/Source/tasks.c **** 	}
 903:../../FreeRTOS/Source/tasks.c **** 
 904:../../FreeRTOS/Source/tasks.c **** #endif
 905:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 906:../../FreeRTOS/Source/tasks.c **** 
 907:../../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
 908:../../FreeRTOS/Source/tasks.c **** 
 909:../../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
 910:../../FreeRTOS/Source/tasks.c **** 	{
 911:../../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 912:../../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
 913:../../FreeRTOS/Source/tasks.c **** 
 914:../../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 915:../../FreeRTOS/Source/tasks.c **** 		{
 916:../../FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are changing the
 917:../../FreeRTOS/Source/tasks.c **** 			priority of the calling function. */
 918:../../FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 919:../../FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 920:../../FreeRTOS/Source/tasks.c **** 		}
 921:../../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 922:../../FreeRTOS/Source/tasks.c **** 
 923:../../FreeRTOS/Source/tasks.c **** 		return uxReturn;
 924:../../FreeRTOS/Source/tasks.c **** 	}
 925:../../FreeRTOS/Source/tasks.c **** 
 926:../../FreeRTOS/Source/tasks.c **** #endif
 927:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 928:../../FreeRTOS/Source/tasks.c **** 
 929:../../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
 930:../../FreeRTOS/Source/tasks.c **** 
 931:../../FreeRTOS/Source/tasks.c **** 	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
 932:../../FreeRTOS/Source/tasks.c **** 	{
 933:../../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 934:../../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxCurrentPriority, uxPriorityUsedOnEntry;
 935:../../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 936:../../FreeRTOS/Source/tasks.c **** 
 937:../../FreeRTOS/Source/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 938:../../FreeRTOS/Source/tasks.c **** 
 939:../../FreeRTOS/Source/tasks.c **** 		/* Ensure the new priority is valid. */
 940:../../FreeRTOS/Source/tasks.c **** 		if( uxNewPriority >= configMAX_PRIORITIES )
 941:../../FreeRTOS/Source/tasks.c **** 		{
 942:../../FreeRTOS/Source/tasks.c **** 			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 943:../../FreeRTOS/Source/tasks.c **** 		}
 944:../../FreeRTOS/Source/tasks.c **** 
 945:../../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 946:../../FreeRTOS/Source/tasks.c **** 		{
 947:../../FreeRTOS/Source/tasks.c **** 			if( pxTask == pxCurrentTCB )
 948:../../FreeRTOS/Source/tasks.c **** 			{
 949:../../FreeRTOS/Source/tasks.c **** 				pxTask = NULL;
 950:../../FreeRTOS/Source/tasks.c **** 			}
 951:../../FreeRTOS/Source/tasks.c **** 
 952:../../FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are changing the
 953:../../FreeRTOS/Source/tasks.c **** 			priority of the calling function. */
 954:../../FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 955:../../FreeRTOS/Source/tasks.c **** 
 956:../../FreeRTOS/Source/tasks.c **** 			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
 957:../../FreeRTOS/Source/tasks.c **** 
 958:../../FreeRTOS/Source/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
 959:../../FreeRTOS/Source/tasks.c **** 			{
 960:../../FreeRTOS/Source/tasks.c **** 				uxCurrentPriority = pxTCB->uxBasePriority;
 961:../../FreeRTOS/Source/tasks.c **** 			}
 962:../../FreeRTOS/Source/tasks.c **** 			#else
 963:../../FreeRTOS/Source/tasks.c **** 			{
 964:../../FreeRTOS/Source/tasks.c **** 				uxCurrentPriority = pxTCB->uxPriority;
 965:../../FreeRTOS/Source/tasks.c **** 			}
 966:../../FreeRTOS/Source/tasks.c **** 			#endif
 967:../../FreeRTOS/Source/tasks.c **** 
 968:../../FreeRTOS/Source/tasks.c **** 			if( uxCurrentPriority != uxNewPriority )
 969:../../FreeRTOS/Source/tasks.c **** 			{
 970:../../FreeRTOS/Source/tasks.c **** 				/* The priority change may have readied a task of higher
 971:../../FreeRTOS/Source/tasks.c **** 				priority than the calling task. */
 972:../../FreeRTOS/Source/tasks.c **** 				if( uxNewPriority > uxCurrentPriority )
 973:../../FreeRTOS/Source/tasks.c **** 				{
 974:../../FreeRTOS/Source/tasks.c **** 					if( pxTask != NULL )
 975:../../FreeRTOS/Source/tasks.c **** 					{
 976:../../FreeRTOS/Source/tasks.c **** 						/* The priority of another task is being raised.  If we
 977:../../FreeRTOS/Source/tasks.c **** 						were raising the priority of the currently running task
 978:../../FreeRTOS/Source/tasks.c **** 						there would be no need to switch as it must have already
 979:../../FreeRTOS/Source/tasks.c **** 						been the highest priority task. */
 980:../../FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
 981:../../FreeRTOS/Source/tasks.c **** 					}
 982:../../FreeRTOS/Source/tasks.c **** 				}
 983:../../FreeRTOS/Source/tasks.c **** 				else if( pxTask == NULL )
 984:../../FreeRTOS/Source/tasks.c **** 				{
 985:../../FreeRTOS/Source/tasks.c **** 					/* Setting our own priority down means there may now be another
 986:../../FreeRTOS/Source/tasks.c **** 					task of higher priority that is ready to execute. */
 987:../../FreeRTOS/Source/tasks.c **** 					xYieldRequired = pdTRUE;
 988:../../FreeRTOS/Source/tasks.c **** 				}
 989:../../FreeRTOS/Source/tasks.c **** 
 990:../../FreeRTOS/Source/tasks.c **** 				/* Remember the ready list the task might be referenced from
 991:../../FreeRTOS/Source/tasks.c **** 				before its uxPriority member is changed so the
 992:../../FreeRTOS/Source/tasks.c **** 				taskRESET_READY_PRIORITY() macro can function correctly. */
 993:../../FreeRTOS/Source/tasks.c **** 				uxPriorityUsedOnEntry = pxTCB->uxPriority;
 994:../../FreeRTOS/Source/tasks.c **** 
 995:../../FreeRTOS/Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
 996:../../FreeRTOS/Source/tasks.c **** 				{
 997:../../FreeRTOS/Source/tasks.c **** 					/* Only change the priority being used if the task is not
 998:../../FreeRTOS/Source/tasks.c **** 					currently using an inherited priority. */
 999:../../FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
1000:../../FreeRTOS/Source/tasks.c **** 					{
1001:../../FreeRTOS/Source/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
1002:../../FreeRTOS/Source/tasks.c **** 					}
1003:../../FreeRTOS/Source/tasks.c **** 
1004:../../FreeRTOS/Source/tasks.c **** 					/* The base priority gets set whatever. */
1005:../../FreeRTOS/Source/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
1006:../../FreeRTOS/Source/tasks.c **** 				}
1007:../../FreeRTOS/Source/tasks.c **** 				#else
1008:../../FreeRTOS/Source/tasks.c **** 				{
1009:../../FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
1010:../../FreeRTOS/Source/tasks.c **** 				}
1011:../../FreeRTOS/Source/tasks.c **** 				#endif
1012:../../FreeRTOS/Source/tasks.c **** 
1013:../../FreeRTOS/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) 
1014:../../FreeRTOS/Source/tasks.c **** 
1015:../../FreeRTOS/Source/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
1016:../../FreeRTOS/Source/tasks.c **** 				nothing more than change it's priority variable. However, if
1017:../../FreeRTOS/Source/tasks.c **** 				the task is in a ready list it needs to be removed and placed
1018:../../FreeRTOS/Source/tasks.c **** 				in the queue appropriate to its new priority. */
1019:../../FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericLis
1020:../../FreeRTOS/Source/tasks.c **** 				{
1021:../../FreeRTOS/Source/tasks.c **** 					/* The task is currently in its ready list - remove before adding
1022:../../FreeRTOS/Source/tasks.c **** 					it to it's new ready list.  As we are in a critical section we
1023:../../FreeRTOS/Source/tasks.c **** 					can do this even if the scheduler is suspended. */
1024:../../FreeRTOS/Source/tasks.c **** 					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
1025:../../FreeRTOS/Source/tasks.c **** 					{
1026:../../FreeRTOS/Source/tasks.c **** 						taskRESET_READY_PRIORITY( uxPriorityUsedOnEntry );
1027:../../FreeRTOS/Source/tasks.c **** 					}
1028:../../FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
1029:../../FreeRTOS/Source/tasks.c **** 				}
1030:../../FreeRTOS/Source/tasks.c **** 
1031:../../FreeRTOS/Source/tasks.c **** 				if( xYieldRequired == pdTRUE )
1032:../../FreeRTOS/Source/tasks.c **** 				{
1033:../../FreeRTOS/Source/tasks.c **** 					portYIELD_WITHIN_API();
1034:../../FreeRTOS/Source/tasks.c **** 				}
1035:../../FreeRTOS/Source/tasks.c **** 			}
1036:../../FreeRTOS/Source/tasks.c **** 		}
1037:../../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1038:../../FreeRTOS/Source/tasks.c **** 
1039:../../FreeRTOS/Source/tasks.c **** 		/* Remove compiler warning about unused parameter when the port
1040:../../FreeRTOS/Source/tasks.c **** 		optimised task selection is not being used. */
1041:../../FreeRTOS/Source/tasks.c **** 		( void ) uxPriorityUsedOnEntry;
1042:../../FreeRTOS/Source/tasks.c **** 	}
1043:../../FreeRTOS/Source/tasks.c **** 
1044:../../FreeRTOS/Source/tasks.c **** #endif
1045:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1046:../../FreeRTOS/Source/tasks.c **** 
1047:../../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1048:../../FreeRTOS/Source/tasks.c **** 
1049:../../FreeRTOS/Source/tasks.c **** 	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
1050:../../FreeRTOS/Source/tasks.c **** 	{
 809               	.LM62:
 810               	.LFBB4:
 811 0344 CF93      		push r28
 812 0346 DF93      		push r29
 813 0348 00D0      		rcall .
 814 034a 1F92      		push __zero_reg__
 815 034c CDB7      		in r28,__SP_L__
 816 034e DEB7      		in r29,__SP_H__
 817               	/* prologue: function */
 818               	/* frame size = 4 */
 819               	/* stack size = 6 */
 820               	.L__stack_usage = 6
 821 0350 9C83      		std Y+4,r25
 822 0352 8B83      		std Y+3,r24
1051:../../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
1052:../../FreeRTOS/Source/tasks.c **** 
1053:../../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 824               	.LM63:
 825               	/* #APP */
 826               	 ;  1053 "../../FreeRTOS/Source/tasks.c" 1
 827 0354 0FB6      		in		__tmp_reg__, __SREG__
 828               	 ;  0 "" 2
 829               	 ;  1053 "../../FreeRTOS/Source/tasks.c" 1
 830 0356 F894      		cli
 831               	 ;  0 "" 2
 832               	 ;  1053 "../../FreeRTOS/Source/tasks.c" 1
 833 0358 0F92      		push	__tmp_reg__
 834               	 ;  0 "" 2
1054:../../FreeRTOS/Source/tasks.c **** 		{
1055:../../FreeRTOS/Source/tasks.c **** 			/* Ensure a yield is performed if the current task is being
1056:../../FreeRTOS/Source/tasks.c **** 			suspended. */
1057:../../FreeRTOS/Source/tasks.c **** 			if( pxTaskToSuspend == pxCurrentTCB )
 836               	.LM64:
 837               	/* #NOAPP */
 838 035a 8091 0000 		lds r24,pxCurrentTCB
 839 035e 9091 0000 		lds r25,pxCurrentTCB+1
 840 0362 2B81      		ldd r18,Y+3
 841 0364 3C81      		ldd r19,Y+4
 842 0366 2817      		cp r18,r24
 843 0368 3907      		cpc r19,r25
 844 036a 01F4      		brne .L23
1058:../../FreeRTOS/Source/tasks.c **** 			{
1059:../../FreeRTOS/Source/tasks.c **** 				pxTaskToSuspend = NULL;
 846               	.LM65:
 847 036c 1C82      		std Y+4,__zero_reg__
 848 036e 1B82      		std Y+3,__zero_reg__
 849               	.L23:
1060:../../FreeRTOS/Source/tasks.c **** 			}
1061:../../FreeRTOS/Source/tasks.c **** 
1062:../../FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are suspending ourselves. */
1063:../../FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 851               	.LM66:
 852 0370 8B81      		ldd r24,Y+3
 853 0372 9C81      		ldd r25,Y+4
 854 0374 0097      		sbiw r24,0
 855 0376 01F4      		brne .L24
 857               	.LM67:
 858 0378 8091 0000 		lds r24,pxCurrentTCB
 859 037c 9091 0000 		lds r25,pxCurrentTCB+1
 860 0380 00C0      		rjmp .L25
 861               	.L24:
 863               	.LM68:
 864 0382 8B81      		ldd r24,Y+3
 865 0384 9C81      		ldd r25,Y+4
 866               	.L25:
 868               	.LM69:
 869 0386 9A83      		std Y+2,r25
 870 0388 8983      		std Y+1,r24
1064:../../FreeRTOS/Source/tasks.c **** 
1065:../../FreeRTOS/Source/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
1066:../../FreeRTOS/Source/tasks.c **** 
1067:../../FreeRTOS/Source/tasks.c **** 			/* Remove task from the ready/delayed list and place in the	suspended list. */
1068:../../FreeRTOS/Source/tasks.c **** 			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
 872               	.LM70:
 873 038a 8981      		ldd r24,Y+1
 874 038c 9A81      		ldd r25,Y+2
 875 038e 0296      		adiw r24,2
 876 0390 0E94 0000 		call uxListRemove
1069:../../FreeRTOS/Source/tasks.c **** 			{
1070:../../FreeRTOS/Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1071:../../FreeRTOS/Source/tasks.c **** 			}
1072:../../FreeRTOS/Source/tasks.c **** 
1073:../../FreeRTOS/Source/tasks.c **** 			/* Is the task waiting on an event also? */
1074:../../FreeRTOS/Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 878               	.LM71:
 879 0394 8981      		ldd r24,Y+1
 880 0396 9A81      		ldd r25,Y+2
 881 0398 FC01      		movw r30,r24
 882 039a 8489      		ldd r24,Z+20
 883 039c 9589      		ldd r25,Z+21
 884 039e 0097      		sbiw r24,0
 885 03a0 01F0      		breq .L26
1075:../../FreeRTOS/Source/tasks.c **** 			{
1076:../../FreeRTOS/Source/tasks.c **** 				uxListRemove( &( pxTCB->xEventListItem ) );
 887               	.LM72:
 888 03a2 8981      		ldd r24,Y+1
 889 03a4 9A81      		ldd r25,Y+2
 890 03a6 0C96      		adiw r24,12
 891 03a8 0E94 0000 		call uxListRemove
 892               	.L26:
1077:../../FreeRTOS/Source/tasks.c **** 			}
1078:../../FreeRTOS/Source/tasks.c **** 
1079:../../FreeRTOS/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 894               	.LM73:
 895 03ac 8981      		ldd r24,Y+1
 896 03ae 9A81      		ldd r25,Y+2
 897 03b0 0296      		adiw r24,2
 898 03b2 BC01      		movw r22,r24
 899 03b4 80E0      		ldi r24,lo8(xSuspendedTaskList)
 900 03b6 90E0      		ldi r25,hi8(xSuspendedTaskList)
 901 03b8 0E94 0000 		call vListInsertEnd
1080:../../FreeRTOS/Source/tasks.c **** 		}
1081:../../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 903               	.LM74:
 904               	/* #APP */
 905               	 ;  1081 "../../FreeRTOS/Source/tasks.c" 1
 906 03bc 0F90      		pop		__tmp_reg__
 907               	 ;  0 "" 2
 908               	 ;  1081 "../../FreeRTOS/Source/tasks.c" 1
 909 03be 0FBE      		out		__SREG__, __tmp_reg__
 910               	 ;  0 "" 2
1082:../../FreeRTOS/Source/tasks.c **** 
1083:../../FreeRTOS/Source/tasks.c **** 		if( ( void * ) pxTaskToSuspend == NULL )
 912               	.LM75:
 913               	/* #NOAPP */
 914 03c0 8B81      		ldd r24,Y+3
 915 03c2 9C81      		ldd r25,Y+4
 916 03c4 0097      		sbiw r24,0
 917 03c6 01F4      		brne .L22
1084:../../FreeRTOS/Source/tasks.c **** 		{
1085:../../FreeRTOS/Source/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
 919               	.LM76:
 920 03c8 8091 0000 		lds r24,xSchedulerRunning
 921 03cc 8823      		tst r24
 922 03ce 01F0      		breq .L28
1086:../../FreeRTOS/Source/tasks.c **** 			{
1087:../../FreeRTOS/Source/tasks.c **** 				/* We have just suspended the current task. */
1088:../../FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 924               	.LM77:
 925 03d0 0E94 0000 		call vPortYield
 926 03d4 00C0      		rjmp .L22
 927               	.L28:
1089:../../FreeRTOS/Source/tasks.c **** 			}
1090:../../FreeRTOS/Source/tasks.c **** 			else
1091:../../FreeRTOS/Source/tasks.c **** 			{
1092:../../FreeRTOS/Source/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
1093:../../FreeRTOS/Source/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
1094:../../FreeRTOS/Source/tasks.c **** 				must be adjusted to point to a different task. */
1095:../../FreeRTOS/Source/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 929               	.LM78:
 930 03d6 9091 0000 		lds r25,xSuspendedTaskList
 931 03da 8091 0000 		lds r24,uxCurrentNumberOfTasks
 932 03de 9817      		cp r25,r24
 933 03e0 01F4      		brne .L29
1096:../../FreeRTOS/Source/tasks.c **** 				{
1097:../../FreeRTOS/Source/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
1098:../../FreeRTOS/Source/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
1099:../../FreeRTOS/Source/tasks.c **** 					be set to point to it no matter what its relative priority
1100:../../FreeRTOS/Source/tasks.c **** 					is. */
1101:../../FreeRTOS/Source/tasks.c **** 					pxCurrentTCB = NULL;
 935               	.LM79:
 936 03e2 1092 0000 		sts pxCurrentTCB+1,__zero_reg__
 937 03e6 1092 0000 		sts pxCurrentTCB,__zero_reg__
 938 03ea 00C0      		rjmp .L22
 939               	.L29:
1102:../../FreeRTOS/Source/tasks.c **** 				}
1103:../../FreeRTOS/Source/tasks.c **** 				else
1104:../../FreeRTOS/Source/tasks.c **** 				{
1105:../../FreeRTOS/Source/tasks.c **** 					vTaskSwitchContext();
 941               	.LM80:
 942 03ec 0E94 0000 		call vTaskSwitchContext
 943               	.L22:
 944               	/* epilogue start */
1106:../../FreeRTOS/Source/tasks.c **** 				}
1107:../../FreeRTOS/Source/tasks.c **** 			}
1108:../../FreeRTOS/Source/tasks.c **** 		}
1109:../../FreeRTOS/Source/tasks.c **** 	}
 946               	.LM81:
 947 03f0 0F90      		pop __tmp_reg__
 948 03f2 0F90      		pop __tmp_reg__
 949 03f4 0F90      		pop __tmp_reg__
 950 03f6 0F90      		pop __tmp_reg__
 951 03f8 DF91      		pop r29
 952 03fa CF91      		pop r28
 953 03fc 0895      		ret
 958               	.Lscope4:
 960               		.stabd	78,0,0
 963               	.global	xTaskIsTaskSuspended
 965               	xTaskIsTaskSuspended:
 966               		.stabd	46,0,0
1110:../../FreeRTOS/Source/tasks.c **** 
1111:../../FreeRTOS/Source/tasks.c **** #endif
1112:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1113:../../FreeRTOS/Source/tasks.c **** 
1114:../../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1115:../../FreeRTOS/Source/tasks.c **** 
1116:../../FreeRTOS/Source/tasks.c **** 	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
1117:../../FreeRTOS/Source/tasks.c **** 	{
 968               	.LM82:
 969               	.LFBB5:
 970 03fe CF93      		push r28
 971 0400 DF93      		push r29
 972 0402 00D0      		rcall .
 973 0404 1F92      		push __zero_reg__
 974 0406 1F92      		push __zero_reg__
 975 0408 CDB7      		in r28,__SP_L__
 976 040a DEB7      		in r29,__SP_H__
 977               	/* prologue: function */
 978               	/* frame size = 5 */
 979               	/* stack size = 7 */
 980               	.L__stack_usage = 7
 981 040c 9D83      		std Y+5,r25
 982 040e 8C83      		std Y+4,r24
1118:../../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xReturn = pdFALSE;
 984               	.LM83:
 985 0410 1982      		std Y+1,__zero_reg__
1119:../../FreeRTOS/Source/tasks.c **** 	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
 987               	.LM84:
 988 0412 8C81      		ldd r24,Y+4
 989 0414 9D81      		ldd r25,Y+5
 990 0416 9B83      		std Y+3,r25
 991 0418 8A83      		std Y+2,r24
1120:../../FreeRTOS/Source/tasks.c **** 
1121:../../FreeRTOS/Source/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
1122:../../FreeRTOS/Source/tasks.c **** 		configASSERT( xTask );
1123:../../FreeRTOS/Source/tasks.c **** 
1124:../../FreeRTOS/Source/tasks.c **** 		/* Is the task we are attempting to resume actually in the
1125:../../FreeRTOS/Source/tasks.c **** 		suspended list? */
1126:../../FreeRTOS/Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 993               	.LM85:
 994 041a 8A81      		ldd r24,Y+2
 995 041c 9B81      		ldd r25,Y+3
 996 041e FC01      		movw r30,r24
 997 0420 8285      		ldd r24,Z+10
 998 0422 9385      		ldd r25,Z+11
 999 0424 F0E0      		ldi r31,hi8(xSuspendedTaskList)
 1000 0426 8030      		cpi r24,lo8(xSuspendedTaskList)
 1001 0428 9F07      		cpc r25,r31
 1002 042a 01F4      		brne .L31
1127:../../FreeRTOS/Source/tasks.c **** 		{
1128:../../FreeRTOS/Source/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
1129:../../FreeRTOS/Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
 1004               	.LM86:
 1005 042c 8A81      		ldd r24,Y+2
 1006 042e 9B81      		ldd r25,Y+3
 1007 0430 FC01      		movw r30,r24
 1008 0432 8489      		ldd r24,Z+20
 1009 0434 9589      		ldd r25,Z+21
 1010 0436 F0E0      		ldi r31,hi8(xPendingReadyList)
 1011 0438 8030      		cpi r24,lo8(xPendingReadyList)
 1012 043a 9F07      		cpc r25,r31
 1013 043c 01F0      		breq .L31
1130:../../FreeRTOS/Source/tasks.c **** 			{
1131:../../FreeRTOS/Source/tasks.c **** 				/* Is it in the suspended list because it is in the
1132:../../FreeRTOS/Source/tasks.c **** 				Suspended state?  It is possible to be in the suspended
1133:../../FreeRTOS/Source/tasks.c **** 				list because it is blocked on a task with no timeout
1134:../../FreeRTOS/Source/tasks.c **** 				specified. */
1135:../../FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
 1015               	.LM87:
 1016 043e 8A81      		ldd r24,Y+2
 1017 0440 9B81      		ldd r25,Y+3
 1018 0442 FC01      		movw r30,r24
 1019 0444 8489      		ldd r24,Z+20
 1020 0446 9589      		ldd r25,Z+21
 1021 0448 0097      		sbiw r24,0
 1022 044a 01F4      		brne .L31
1136:../../FreeRTOS/Source/tasks.c **** 				{
1137:../../FreeRTOS/Source/tasks.c **** 					xReturn = pdTRUE;
 1024               	.LM88:
 1025 044c 81E0      		ldi r24,lo8(1)
 1026 044e 8983      		std Y+1,r24
 1027               	.L31:
1138:../../FreeRTOS/Source/tasks.c **** 				}
1139:../../FreeRTOS/Source/tasks.c **** 			}
1140:../../FreeRTOS/Source/tasks.c **** 		}
1141:../../FreeRTOS/Source/tasks.c **** 
1142:../../FreeRTOS/Source/tasks.c **** 		return xReturn;
 1029               	.LM89:
 1030 0450 8981      		ldd r24,Y+1
 1031               	/* epilogue start */
1143:../../FreeRTOS/Source/tasks.c **** 	}
 1033               	.LM90:
 1034 0452 0F90      		pop __tmp_reg__
 1035 0454 0F90      		pop __tmp_reg__
 1036 0456 0F90      		pop __tmp_reg__
 1037 0458 0F90      		pop __tmp_reg__
 1038 045a 0F90      		pop __tmp_reg__
 1039 045c DF91      		pop r29
 1040 045e CF91      		pop r28
 1041 0460 0895      		ret
 1047               	.Lscope5:
 1049               		.stabd	78,0,0
 1052               	.global	vTaskResume
 1054               	vTaskResume:
 1055               		.stabd	46,0,0
1144:../../FreeRTOS/Source/tasks.c **** 
1145:../../FreeRTOS/Source/tasks.c **** #endif
1146:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1147:../../FreeRTOS/Source/tasks.c **** 
1148:../../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1149:../../FreeRTOS/Source/tasks.c **** 
1150:../../FreeRTOS/Source/tasks.c **** 	void vTaskResume( xTaskHandle pxTaskToResume )
1151:../../FreeRTOS/Source/tasks.c **** 	{
 1057               	.LM91:
 1058               	.LFBB6:
 1059 0462 CF93      		push r28
 1060 0464 DF93      		push r29
 1061 0466 00D0      		rcall .
 1062 0468 1F92      		push __zero_reg__
 1063 046a CDB7      		in r28,__SP_L__
 1064 046c DEB7      		in r29,__SP_H__
 1065               	/* prologue: function */
 1066               	/* frame size = 4 */
 1067               	/* stack size = 6 */
 1068               	.L__stack_usage = 6
 1069 046e 9C83      		std Y+4,r25
 1070 0470 8B83      		std Y+3,r24
1152:../../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
1153:../../FreeRTOS/Source/tasks.c **** 
1154:../../FreeRTOS/Source/tasks.c **** 		/* It does not make sense to resume the calling task. */
1155:../../FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskToResume );
1156:../../FreeRTOS/Source/tasks.c **** 
1157:../../FreeRTOS/Source/tasks.c **** 		/* Remove the task from whichever list it is currently in, and place
1158:../../FreeRTOS/Source/tasks.c **** 		it in the ready list. */
1159:../../FreeRTOS/Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 1072               	.LM92:
 1073 0472 8B81      		ldd r24,Y+3
 1074 0474 9C81      		ldd r25,Y+4
 1075 0476 9A83      		std Y+2,r25
 1076 0478 8983      		std Y+1,r24
1160:../../FreeRTOS/Source/tasks.c **** 
1161:../../FreeRTOS/Source/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
1162:../../FreeRTOS/Source/tasks.c **** 		currently executing task. */
1163:../../FreeRTOS/Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 1078               	.LM93:
 1079 047a 8981      		ldd r24,Y+1
 1080 047c 9A81      		ldd r25,Y+2
 1081 047e 0097      		sbiw r24,0
 1082 0480 01F4      		brne .+2
 1083 0482 00C0      		rjmp .L33
 1085               	.LM94:
 1086 0484 8091 0000 		lds r24,pxCurrentTCB
 1087 0488 9091 0000 		lds r25,pxCurrentTCB+1
 1088 048c 2981      		ldd r18,Y+1
 1089 048e 3A81      		ldd r19,Y+2
 1090 0490 2817      		cp r18,r24
 1091 0492 3907      		cpc r19,r25
 1092 0494 01F4      		brne .+2
 1093 0496 00C0      		rjmp .L33
1164:../../FreeRTOS/Source/tasks.c **** 		{
1165:../../FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
 1095               	.LM95:
 1096               	/* #APP */
 1097               	 ;  1165 "../../FreeRTOS/Source/tasks.c" 1
 1098 0498 0FB6      		in		__tmp_reg__, __SREG__
 1099               	 ;  0 "" 2
 1100               	 ;  1165 "../../FreeRTOS/Source/tasks.c" 1
 1101 049a F894      		cli
 1102               	 ;  0 "" 2
 1103               	 ;  1165 "../../FreeRTOS/Source/tasks.c" 1
 1104 049c 0F92      		push	__tmp_reg__
 1105               	 ;  0 "" 2
1166:../../FreeRTOS/Source/tasks.c **** 			{
1167:../../FreeRTOS/Source/tasks.c **** 				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1107               	.LM96:
 1108               	/* #NOAPP */
 1109 049e 8981      		ldd r24,Y+1
 1110 04a0 9A81      		ldd r25,Y+2
 1111 04a2 0E94 0000 		call xTaskIsTaskSuspended
 1112 04a6 8130      		cpi r24,lo8(1)
 1113 04a8 01F4      		brne .L35
1168:../../FreeRTOS/Source/tasks.c **** 				{
1169:../../FreeRTOS/Source/tasks.c **** 					traceTASK_RESUME( pxTCB );
1170:../../FreeRTOS/Source/tasks.c **** 
1171:../../FreeRTOS/Source/tasks.c **** 					/* As we are in a critical section we can access the ready
1172:../../FreeRTOS/Source/tasks.c **** 					lists even if the scheduler is suspended. */
1173:../../FreeRTOS/Source/tasks.c **** 					uxListRemove(  &( pxTCB->xGenericListItem ) );
 1115               	.LM97:
 1116 04aa 8981      		ldd r24,Y+1
 1117 04ac 9A81      		ldd r25,Y+2
 1118 04ae 0296      		adiw r24,2
 1119 04b0 0E94 0000 		call uxListRemove
1174:../../FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1121               	.LM98:
 1122 04b4 8981      		ldd r24,Y+1
 1123 04b6 9A81      		ldd r25,Y+2
 1124 04b8 FC01      		movw r30,r24
 1125 04ba 9689      		ldd r25,Z+22
 1126 04bc 8091 0000 		lds r24,uxTopReadyPriority
 1127 04c0 8917      		cp r24,r25
 1128 04c2 00F4      		brsh .L36
 1130               	.LM99:
 1131 04c4 8981      		ldd r24,Y+1
 1132 04c6 9A81      		ldd r25,Y+2
 1133 04c8 FC01      		movw r30,r24
 1134 04ca 8689      		ldd r24,Z+22
 1135 04cc 8093 0000 		sts uxTopReadyPriority,r24
 1136               	.L36:
 1138               	.LM100:
 1139 04d0 8981      		ldd r24,Y+1
 1140 04d2 9A81      		ldd r25,Y+2
 1141 04d4 AC01      		movw r20,r24
 1142 04d6 4E5F      		subi r20,-2
 1143 04d8 5F4F      		sbci r21,-1
 1144 04da 8981      		ldd r24,Y+1
 1145 04dc 9A81      		ldd r25,Y+2
 1146 04de FC01      		movw r30,r24
 1147 04e0 8689      		ldd r24,Z+22
 1148 04e2 282F      		mov r18,r24
 1149 04e4 30E0      		ldi r19,0
 1150 04e6 C901      		movw r24,r18
 1151 04e8 880F      		lsl r24
 1152 04ea 991F      		rol r25
 1153 04ec 880F      		lsl r24
 1154 04ee 991F      		rol r25
 1155 04f0 880F      		lsl r24
 1156 04f2 991F      		rol r25
 1157 04f4 820F      		add r24,r18
 1158 04f6 931F      		adc r25,r19
 1159 04f8 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1160 04fa 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1161 04fc BA01      		movw r22,r20
 1162 04fe 0E94 0000 		call vListInsertEnd
1175:../../FreeRTOS/Source/tasks.c **** 
1176:../../FreeRTOS/Source/tasks.c **** 					/* We may have just resumed a higher priority task. */
1177:../../FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1164               	.LM101:
 1165 0502 8981      		ldd r24,Y+1
 1166 0504 9A81      		ldd r25,Y+2
 1167 0506 FC01      		movw r30,r24
 1168 0508 2689      		ldd r18,Z+22
 1169 050a 8091 0000 		lds r24,pxCurrentTCB
 1170 050e 9091 0000 		lds r25,pxCurrentTCB+1
 1171 0512 FC01      		movw r30,r24
 1172 0514 8689      		ldd r24,Z+22
 1173 0516 2817      		cp r18,r24
 1174 0518 00F0      		brlo .L35
1178:../../FreeRTOS/Source/tasks.c **** 					{
1179:../../FreeRTOS/Source/tasks.c **** 						/* This yield may not cause the task just resumed to run, but
1180:../../FreeRTOS/Source/tasks.c **** 						will leave the lists in the correct state for the next yield. */
1181:../../FreeRTOS/Source/tasks.c **** 						portYIELD_WITHIN_API();
 1176               	.LM102:
 1177 051a 0E94 0000 		call vPortYield
 1178               	.L35:
1182:../../FreeRTOS/Source/tasks.c **** 					}
1183:../../FreeRTOS/Source/tasks.c **** 				}
1184:../../FreeRTOS/Source/tasks.c **** 			}
1185:../../FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
 1180               	.LM103:
 1181               	/* #APP */
 1182               	 ;  1185 "../../FreeRTOS/Source/tasks.c" 1
 1183 051e 0F90      		pop		__tmp_reg__
 1184               	 ;  0 "" 2
 1185               	 ;  1185 "../../FreeRTOS/Source/tasks.c" 1
 1186 0520 0FBE      		out		__SREG__, __tmp_reg__
 1187               	 ;  0 "" 2
 1188               	/* #NOAPP */
 1189               	.L33:
 1190               	/* epilogue start */
1186:../../FreeRTOS/Source/tasks.c **** 		}
1187:../../FreeRTOS/Source/tasks.c **** 	}
 1192               	.LM104:
 1193 0522 0F90      		pop __tmp_reg__
 1194 0524 0F90      		pop __tmp_reg__
 1195 0526 0F90      		pop __tmp_reg__
 1196 0528 0F90      		pop __tmp_reg__
 1197 052a DF91      		pop r29
 1198 052c CF91      		pop r28
 1199 052e 0895      		ret
 1204               	.Lscope6:
 1206               		.stabd	78,0,0
 1209               	.global	xTaskResumeFromISR
 1211               	xTaskResumeFromISR:
 1212               		.stabd	46,0,0
1188:../../FreeRTOS/Source/tasks.c **** 
1189:../../FreeRTOS/Source/tasks.c **** #endif
1190:../../FreeRTOS/Source/tasks.c **** 
1191:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1192:../../FreeRTOS/Source/tasks.c **** 
1193:../../FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1194:../../FreeRTOS/Source/tasks.c **** 
1195:../../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
1196:../../FreeRTOS/Source/tasks.c **** 	{
 1214               	.LM105:
 1215               	.LFBB7:
 1216 0530 CF93      		push r28
 1217 0532 DF93      		push r29
 1218 0534 00D0      		rcall .
 1219 0536 00D0      		rcall .
 1220 0538 CDB7      		in r28,__SP_L__
 1221 053a DEB7      		in r29,__SP_H__
 1222               	/* prologue: function */
 1223               	/* frame size = 6 */
 1224               	/* stack size = 8 */
 1225               	.L__stack_usage = 8
 1226 053c 9E83      		std Y+6,r25
 1227 053e 8D83      		std Y+5,r24
1197:../../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 1229               	.LM106:
 1230 0540 1982      		std Y+1,__zero_reg__
1198:../../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
1199:../../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxSavedInterruptStatus;
1200:../../FreeRTOS/Source/tasks.c **** 
1201:../../FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskToResume );
1202:../../FreeRTOS/Source/tasks.c **** 
1203:../../FreeRTOS/Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 1232               	.LM107:
 1233 0542 8D81      		ldd r24,Y+5
 1234 0544 9E81      		ldd r25,Y+6
 1235 0546 9B83      		std Y+3,r25
 1236 0548 8A83      		std Y+2,r24
1204:../../FreeRTOS/Source/tasks.c **** 
1205:../../FreeRTOS/Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1238               	.LM108:
 1239 054a 1C82      		std Y+4,__zero_reg__
1206:../../FreeRTOS/Source/tasks.c **** 		{
1207:../../FreeRTOS/Source/tasks.c **** 			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1241               	.LM109:
 1242 054c 8A81      		ldd r24,Y+2
 1243 054e 9B81      		ldd r25,Y+3
 1244 0550 0E94 0000 		call xTaskIsTaskSuspended
 1245 0554 8130      		cpi r24,lo8(1)
 1246 0556 01F0      		breq .+2
 1247 0558 00C0      		rjmp .L38
1208:../../FreeRTOS/Source/tasks.c **** 			{
1209:../../FreeRTOS/Source/tasks.c **** 				traceTASK_RESUME_FROM_ISR( pxTCB );
1210:../../FreeRTOS/Source/tasks.c **** 
1211:../../FreeRTOS/Source/tasks.c **** 				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1249               	.LM110:
 1250 055a 8091 0000 		lds r24,uxSchedulerSuspended
 1251 055e 8823      		tst r24
 1252 0560 01F4      		brne .L39
1212:../../FreeRTOS/Source/tasks.c **** 				{
1213:../../FreeRTOS/Source/tasks.c **** 					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
 1254               	.LM111:
 1255 0562 8A81      		ldd r24,Y+2
 1256 0564 9B81      		ldd r25,Y+3
 1257 0566 FC01      		movw r30,r24
 1258 0568 2689      		ldd r18,Z+22
 1259 056a 8091 0000 		lds r24,pxCurrentTCB
 1260 056e 9091 0000 		lds r25,pxCurrentTCB+1
 1261 0572 FC01      		movw r30,r24
 1262 0574 9689      		ldd r25,Z+22
 1263 0576 81E0      		ldi r24,lo8(1)
 1264 0578 2917      		cp r18,r25
 1265 057a 00F4      		brsh .L40
 1266 057c 80E0      		ldi r24,0
 1267               	.L40:
 1268 057e 8983      		std Y+1,r24
1214:../../FreeRTOS/Source/tasks.c **** 					uxListRemove(  &( pxTCB->xGenericListItem ) );
 1270               	.LM112:
 1271 0580 8A81      		ldd r24,Y+2
 1272 0582 9B81      		ldd r25,Y+3
 1273 0584 0296      		adiw r24,2
 1274 0586 0E94 0000 		call uxListRemove
1215:../../FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1276               	.LM113:
 1277 058a 8A81      		ldd r24,Y+2
 1278 058c 9B81      		ldd r25,Y+3
 1279 058e FC01      		movw r30,r24
 1280 0590 9689      		ldd r25,Z+22
 1281 0592 8091 0000 		lds r24,uxTopReadyPriority
 1282 0596 8917      		cp r24,r25
 1283 0598 00F4      		brsh .L41
 1285               	.LM114:
 1286 059a 8A81      		ldd r24,Y+2
 1287 059c 9B81      		ldd r25,Y+3
 1288 059e FC01      		movw r30,r24
 1289 05a0 8689      		ldd r24,Z+22
 1290 05a2 8093 0000 		sts uxTopReadyPriority,r24
 1291               	.L41:
 1293               	.LM115:
 1294 05a6 8A81      		ldd r24,Y+2
 1295 05a8 9B81      		ldd r25,Y+3
 1296 05aa AC01      		movw r20,r24
 1297 05ac 4E5F      		subi r20,-2
 1298 05ae 5F4F      		sbci r21,-1
 1299 05b0 8A81      		ldd r24,Y+2
 1300 05b2 9B81      		ldd r25,Y+3
 1301 05b4 FC01      		movw r30,r24
 1302 05b6 8689      		ldd r24,Z+22
 1303 05b8 282F      		mov r18,r24
 1304 05ba 30E0      		ldi r19,0
 1305 05bc C901      		movw r24,r18
 1306 05be 880F      		lsl r24
 1307 05c0 991F      		rol r25
 1308 05c2 880F      		lsl r24
 1309 05c4 991F      		rol r25
 1310 05c6 880F      		lsl r24
 1311 05c8 991F      		rol r25
 1312 05ca 820F      		add r24,r18
 1313 05cc 931F      		adc r25,r19
 1314 05ce 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1315 05d0 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1316 05d2 BA01      		movw r22,r20
 1317 05d4 0E94 0000 		call vListInsertEnd
 1318 05d8 00C0      		rjmp .L38
 1319               	.L39:
1216:../../FreeRTOS/Source/tasks.c **** 				}
1217:../../FreeRTOS/Source/tasks.c **** 				else
1218:../../FreeRTOS/Source/tasks.c **** 				{
1219:../../FreeRTOS/Source/tasks.c **** 					/* We cannot access the delayed or ready lists, so will hold this
1220:../../FreeRTOS/Source/tasks.c **** 					task pending until the scheduler is resumed, at which point a
1221:../../FreeRTOS/Source/tasks.c **** 					yield will be performed if necessary. */
1222:../../FreeRTOS/Source/tasks.c **** 					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 1321               	.LM116:
 1322 05da 8A81      		ldd r24,Y+2
 1323 05dc 9B81      		ldd r25,Y+3
 1324 05de 0C96      		adiw r24,12
 1325 05e0 BC01      		movw r22,r24
 1326 05e2 80E0      		ldi r24,lo8(xPendingReadyList)
 1327 05e4 90E0      		ldi r25,hi8(xPendingReadyList)
 1328 05e6 0E94 0000 		call vListInsertEnd
 1329               	.L38:
1223:../../FreeRTOS/Source/tasks.c **** 				}
1224:../../FreeRTOS/Source/tasks.c **** 			}
1225:../../FreeRTOS/Source/tasks.c **** 		}
1226:../../FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1227:../../FreeRTOS/Source/tasks.c **** 
1228:../../FreeRTOS/Source/tasks.c **** 		return xYieldRequired;
 1331               	.LM117:
 1332 05ea 8981      		ldd r24,Y+1
 1333               	/* epilogue start */
1229:../../FreeRTOS/Source/tasks.c **** 	}
 1335               	.LM118:
 1336 05ec 2696      		adiw r28,6
 1337 05ee 0FB6      		in __tmp_reg__,__SREG__
 1338 05f0 F894      		cli
 1339 05f2 DEBF      		out __SP_H__,r29
 1340 05f4 0FBE      		out __SREG__,__tmp_reg__
 1341 05f6 CDBF      		out __SP_L__,r28
 1342 05f8 DF91      		pop r29
 1343 05fa CF91      		pop r28
 1344 05fc 0895      		ret
 1351               	.Lscope7:
 1353               		.stabd	78,0,0
 1354               		.section	.rodata
 1355               	.LC0:
 1356 0000 4944 4C45 		.string	"IDLE"
 1356      00
 1357               		.text
 1359               	.global	vTaskStartScheduler
 1361               	vTaskStartScheduler:
 1362               		.stabd	46,0,0
1230:../../FreeRTOS/Source/tasks.c **** 
1231:../../FreeRTOS/Source/tasks.c **** #endif
1232:../../FreeRTOS/Source/tasks.c **** 
1233:../../FreeRTOS/Source/tasks.c **** 
1234:../../FreeRTOS/Source/tasks.c **** 
1235:../../FreeRTOS/Source/tasks.c **** 
1236:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
1237:../../FreeRTOS/Source/tasks.c ****  * PUBLIC SCHEDULER CONTROL documented in task.h
1238:../../FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
1239:../../FreeRTOS/Source/tasks.c **** 
1240:../../FreeRTOS/Source/tasks.c **** 
1241:../../FreeRTOS/Source/tasks.c **** void vTaskStartScheduler( void )
1242:../../FreeRTOS/Source/tasks.c **** {
 1364               	.LM119:
 1365               	.LFBB8:
 1366 05fe AF92      		push r10
 1367 0600 BF92      		push r11
 1368 0602 CF92      		push r12
 1369 0604 DF92      		push r13
 1370 0606 EF92      		push r14
 1371 0608 FF92      		push r15
 1372 060a 0F93      		push r16
 1373 060c CF93      		push r28
 1374 060e DF93      		push r29
 1375 0610 1F92      		push __zero_reg__
 1376 0612 CDB7      		in r28,__SP_L__
 1377 0614 DEB7      		in r29,__SP_H__
 1378               	/* prologue: function */
 1379               	/* frame size = 1 */
 1380               	/* stack size = 10 */
 1381               	.L__stack_usage = 10
1243:../../FreeRTOS/Source/tasks.c **** portBASE_TYPE xReturn;
1244:../../FreeRTOS/Source/tasks.c **** 
1245:../../FreeRTOS/Source/tasks.c **** 	/* Add the idle task at the lowest priority. */
1246:../../FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1247:../../FreeRTOS/Source/tasks.c **** 	{
1248:../../FreeRTOS/Source/tasks.c **** 		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
1249:../../FreeRTOS/Source/tasks.c **** 		be returned by the xTaskGetIdleTaskHandle() function. */
1250:../../FreeRTOS/Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
1251:../../FreeRTOS/Source/tasks.c **** 	}
1252:../../FreeRTOS/Source/tasks.c **** 	#else
1253:../../FreeRTOS/Source/tasks.c **** 	{
1254:../../FreeRTOS/Source/tasks.c **** 		/* Create the idle task without storing its handle. */
1255:../../FreeRTOS/Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
 1383               	.LM120:
 1384 0616 A12C      		mov r10,__zero_reg__
 1385 0618 B12C      		mov r11,__zero_reg__
 1386 061a C12C      		mov r12,__zero_reg__
 1387 061c D12C      		mov r13,__zero_reg__
 1388 061e E12C      		mov r14,__zero_reg__
 1389 0620 F12C      		mov r15,__zero_reg__
 1390 0622 00E0      		ldi r16,0
 1391 0624 20E0      		ldi r18,0
 1392 0626 30E0      		ldi r19,0
 1393 0628 45E5      		ldi r20,lo8(85)
 1394 062a 50E0      		ldi r21,0
 1395 062c 60E0      		ldi r22,lo8(.LC0)
 1396 062e 70E0      		ldi r23,hi8(.LC0)
 1397 0630 80E0      		ldi r24,lo8(gs(prvIdleTask))
 1398 0632 90E0      		ldi r25,hi8(gs(prvIdleTask))
 1399 0634 0E94 0000 		call xTaskGenericCreate
 1400 0638 8983      		std Y+1,r24
1256:../../FreeRTOS/Source/tasks.c **** 	}
1257:../../FreeRTOS/Source/tasks.c **** 	#endif
1258:../../FreeRTOS/Source/tasks.c **** 
1259:../../FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
1260:../../FreeRTOS/Source/tasks.c **** 	{
1261:../../FreeRTOS/Source/tasks.c **** 		if( xReturn == pdPASS )
1262:../../FreeRTOS/Source/tasks.c **** 		{
1263:../../FreeRTOS/Source/tasks.c **** 			xReturn = xTimerCreateTimerTask();
1264:../../FreeRTOS/Source/tasks.c **** 		}
1265:../../FreeRTOS/Source/tasks.c **** 	}
1266:../../FreeRTOS/Source/tasks.c **** 	#endif
1267:../../FreeRTOS/Source/tasks.c **** 
1268:../../FreeRTOS/Source/tasks.c **** 	if( xReturn == pdPASS )
 1402               	.LM121:
 1403 063a 8981      		ldd r24,Y+1
 1404 063c 8130      		cpi r24,lo8(1)
 1405 063e 01F4      		brne .L43
1269:../../FreeRTOS/Source/tasks.c **** 	{
1270:../../FreeRTOS/Source/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1271:../../FreeRTOS/Source/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1272:../../FreeRTOS/Source/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1273:../../FreeRTOS/Source/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1274:../../FreeRTOS/Source/tasks.c **** 		starts to run.
1275:../../FreeRTOS/Source/tasks.c **** 
1276:../../FreeRTOS/Source/tasks.c **** 		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
1277:../../FreeRTOS/Source/tasks.c **** 		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
1278:../../FreeRTOS/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
 1407               	.LM122:
 1408               	/* #APP */
 1409               	 ;  1278 "../../FreeRTOS/Source/tasks.c" 1
 1410 0640 F894      		cli
 1411               	 ;  0 "" 2
1279:../../FreeRTOS/Source/tasks.c **** 
1280:../../FreeRTOS/Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
 1413               	.LM123:
 1414               	/* #NOAPP */
 1415 0642 81E0      		ldi r24,lo8(1)
 1416 0644 8093 0000 		sts xSchedulerRunning,r24
1281:../../FreeRTOS/Source/tasks.c **** 		xTickCount = ( portTickType ) 0U;
 1418               	.LM124:
 1419 0648 1092 0000 		sts xTickCount+1,__zero_reg__
 1420 064c 1092 0000 		sts xTickCount,__zero_reg__
1282:../../FreeRTOS/Source/tasks.c **** 
1283:../../FreeRTOS/Source/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1284:../../FreeRTOS/Source/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
1285:../../FreeRTOS/Source/tasks.c **** 		the run time counter time base. */
1286:../../FreeRTOS/Source/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1287:../../FreeRTOS/Source/tasks.c **** 
1288:../../FreeRTOS/Source/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
1289:../../FreeRTOS/Source/tasks.c **** 		portable interface. */
1290:../../FreeRTOS/Source/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
 1422               	.LM125:
 1423 0650 0E94 0000 		call xPortStartScheduler
 1424               	.L43:
 1425               	/* epilogue start */
1291:../../FreeRTOS/Source/tasks.c **** 		{
1292:../../FreeRTOS/Source/tasks.c **** 			/* Should not reach here as if the scheduler is running the
1293:../../FreeRTOS/Source/tasks.c **** 			function will not return. */
1294:../../FreeRTOS/Source/tasks.c **** 		}
1295:../../FreeRTOS/Source/tasks.c **** 		else
1296:../../FreeRTOS/Source/tasks.c **** 		{
1297:../../FreeRTOS/Source/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1298:../../FreeRTOS/Source/tasks.c **** 		}
1299:../../FreeRTOS/Source/tasks.c **** 	}
1300:../../FreeRTOS/Source/tasks.c **** 
1301:../../FreeRTOS/Source/tasks.c **** 	/* This line will only be reached if the kernel could not be started. */
1302:../../FreeRTOS/Source/tasks.c **** 	configASSERT( xReturn );
1303:../../FreeRTOS/Source/tasks.c **** }
 1427               	.LM126:
 1428 0654 0F90      		pop __tmp_reg__
 1429 0656 DF91      		pop r29
 1430 0658 CF91      		pop r28
 1431 065a 0F91      		pop r16
 1432 065c FF90      		pop r15
 1433 065e EF90      		pop r14
 1434 0660 DF90      		pop r13
 1435 0662 CF90      		pop r12
 1436 0664 BF90      		pop r11
 1437 0666 AF90      		pop r10
 1438 0668 0895      		ret
 1443               	.Lscope8:
 1445               		.stabd	78,0,0
 1447               	.global	vTaskEndScheduler
 1449               	vTaskEndScheduler:
 1450               		.stabd	46,0,0
1304:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1305:../../FreeRTOS/Source/tasks.c **** 
1306:../../FreeRTOS/Source/tasks.c **** void vTaskEndScheduler( void )
1307:../../FreeRTOS/Source/tasks.c **** {
 1452               	.LM127:
 1453               	.LFBB9:
 1454 066a CF93      		push r28
 1455 066c DF93      		push r29
 1456 066e CDB7      		in r28,__SP_L__
 1457 0670 DEB7      		in r29,__SP_H__
 1458               	/* prologue: function */
 1459               	/* frame size = 0 */
 1460               	/* stack size = 2 */
 1461               	.L__stack_usage = 2
1308:../../FreeRTOS/Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
1309:../../FreeRTOS/Source/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
1310:../../FreeRTOS/Source/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
1311:../../FreeRTOS/Source/tasks.c **** 	portDISABLE_INTERRUPTS();
 1463               	.LM128:
 1464               	/* #APP */
 1465               	 ;  1311 "../../FreeRTOS/Source/tasks.c" 1
 1466 0672 F894      		cli
 1467               	 ;  0 "" 2
1312:../../FreeRTOS/Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
 1469               	.LM129:
 1470               	/* #NOAPP */
 1471 0674 1092 0000 		sts xSchedulerRunning,__zero_reg__
1313:../../FreeRTOS/Source/tasks.c **** 	vPortEndScheduler();
 1473               	.LM130:
 1474 0678 0E94 0000 		call vPortEndScheduler
 1475               	/* epilogue start */
1314:../../FreeRTOS/Source/tasks.c **** }
 1477               	.LM131:
 1478 067c DF91      		pop r29
 1479 067e CF91      		pop r28
 1480 0680 0895      		ret
 1482               	.Lscope9:
 1484               		.stabd	78,0,0
 1486               	.global	vTaskSuspendAll
 1488               	vTaskSuspendAll:
 1489               		.stabd	46,0,0
1315:../../FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1316:../../FreeRTOS/Source/tasks.c **** 
1317:../../FreeRTOS/Source/tasks.c **** void vTaskSuspendAll( void )
1318:../../FreeRTOS/Source/tasks.c **** {
 1491               	.LM132:
 1492               	.LFBB10:
 1493 0682 CF93      		push r28
 1494 0684 DF93      		push r29
 1495 0686 CDB7      		in r28,__SP_L__
 1496 0688 DEB7      		in r29,__SP_H__
 1497               	/* prologue: function */
 1498               	/* frame size = 0 */
 1499               	/* stack size = 2 */
 1500               	.L__stack_usage = 2
1319:../../FreeRTOS/Source/tasks.c **** 	/* A critical section is not required as the variable is of type
1320:../../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE. */
1321:../../FreeRTOS/Source/tasks.c **** 	++uxSchedulerSuspended;
 1502               	.LM133:
 1503 068a 8091 0000 		lds r24,uxSchedulerSuspended
 1504 068e 8F5F      		subi r24,lo8(-(1))
 1505 0690 8093 0000 		sts uxSchedulerSuspended,r24
 1506               	/* epilogue start */
1322:../../FreeRTOS/Source/tasks.c **** }
 1508               	.LM134:
 1509 0694 DF91      		pop r29
 1510 0696 CF91      		pop r28
 1511 0698 0895      		ret
 1513               	.Lscope10:
 1515               		.stabd	78,0,0
 1517               	.global	xTaskResumeAll
 1519               	xTaskResumeAll:
 1520               		.stabd	46,0,0
1323:../../FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1324:../../FreeRTOS/Source/tasks.c **** 
1325:../../FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
1326:../../FreeRTOS/Source/tasks.c **** 
1327:../../FreeRTOS/Source/tasks.c **** 	portTickType prvGetExpectedIdleTime( void )
1328:../../FreeRTOS/Source/tasks.c **** 	{
1329:../../FreeRTOS/Source/tasks.c **** 	portTickType xReturn;
1330:../../FreeRTOS/Source/tasks.c **** 
1331:../../FreeRTOS/Source/tasks.c **** 		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
1332:../../FreeRTOS/Source/tasks.c **** 		{
1333:../../FreeRTOS/Source/tasks.c **** 			xReturn = 0;
1334:../../FreeRTOS/Source/tasks.c **** 		}
1335:../../FreeRTOS/Source/tasks.c **** 		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
1336:../../FreeRTOS/Source/tasks.c **** 		{
1337:../../FreeRTOS/Source/tasks.c **** 			/* There are other idle priority tasks in the ready state.  If
1338:../../FreeRTOS/Source/tasks.c **** 			time slicing is used then the very next tick interrupt must be
1339:../../FreeRTOS/Source/tasks.c **** 			processed. */
1340:../../FreeRTOS/Source/tasks.c **** 			xReturn = 0;
1341:../../FreeRTOS/Source/tasks.c **** 		}
1342:../../FreeRTOS/Source/tasks.c **** 		else
1343:../../FreeRTOS/Source/tasks.c **** 		{
1344:../../FreeRTOS/Source/tasks.c **** 			xReturn = xNextTaskUnblockTime - xTickCount;
1345:../../FreeRTOS/Source/tasks.c **** 		}
1346:../../FreeRTOS/Source/tasks.c **** 
1347:../../FreeRTOS/Source/tasks.c **** 		return xReturn;
1348:../../FreeRTOS/Source/tasks.c **** 	}
1349:../../FreeRTOS/Source/tasks.c **** 
1350:../../FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE != 0  */
1351:../../FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1352:../../FreeRTOS/Source/tasks.c **** 
1353:../../FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xTaskResumeAll( void )
1354:../../FreeRTOS/Source/tasks.c **** {
 1522               	.LM135:
 1523               	.LFBB11:
 1524 069a 0F93      		push r16
 1525 069c 1F93      		push r17
 1526 069e CF93      		push r28
 1527 06a0 DF93      		push r29
 1528 06a2 1F92      		push __zero_reg__
 1529 06a4 1F92      		push __zero_reg__
 1530 06a6 CDB7      		in r28,__SP_L__
 1531 06a8 DEB7      		in r29,__SP_H__
 1532               	/* prologue: function */
 1533               	/* frame size = 2 */
 1534               	/* stack size = 6 */
 1535               	.L__stack_usage = 6
1355:../../FreeRTOS/Source/tasks.c **** register tskTCB *pxTCB;
1356:../../FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 1537               	.LM136:
 1538 06aa 1982      		std Y+1,__zero_reg__
1357:../../FreeRTOS/Source/tasks.c **** 
1358:../../FreeRTOS/Source/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
1359:../../FreeRTOS/Source/tasks.c **** 	previous call to vTaskSuspendAll(). */
1360:../../FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended );
1361:../../FreeRTOS/Source/tasks.c **** 
1362:../../FreeRTOS/Source/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
1363:../../FreeRTOS/Source/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
1364:../../FreeRTOS/Source/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
1365:../../FreeRTOS/Source/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
1366:../../FreeRTOS/Source/tasks.c **** 	tasks from this list into their appropriate ready list. */
1367:../../FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
 1540               	.LM137:
 1541               	/* #APP */
 1542               	 ;  1367 "../../FreeRTOS/Source/tasks.c" 1
 1543 06ac 0FB6      		in		__tmp_reg__, __SREG__
 1544               	 ;  0 "" 2
 1545               	 ;  1367 "../../FreeRTOS/Source/tasks.c" 1
 1546 06ae F894      		cli
 1547               	 ;  0 "" 2
 1548               	 ;  1367 "../../FreeRTOS/Source/tasks.c" 1
 1549 06b0 0F92      		push	__tmp_reg__
 1550               	 ;  0 "" 2
1368:../../FreeRTOS/Source/tasks.c **** 	{
1369:../../FreeRTOS/Source/tasks.c **** 		--uxSchedulerSuspended;
 1552               	.LM138:
 1553               	/* #NOAPP */
 1554 06b2 8091 0000 		lds r24,uxSchedulerSuspended
 1555 06b6 8150      		subi r24,lo8(-(-1))
 1556 06b8 8093 0000 		sts uxSchedulerSuspended,r24
1370:../../FreeRTOS/Source/tasks.c **** 
1371:../../FreeRTOS/Source/tasks.c **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1558               	.LM139:
 1559 06bc 8091 0000 		lds r24,uxSchedulerSuspended
 1560 06c0 8823      		tst r24
 1561 06c2 01F0      		breq .+2
 1562 06c4 00C0      		rjmp .L48
1372:../../FreeRTOS/Source/tasks.c **** 		{
1373:../../FreeRTOS/Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
 1564               	.LM140:
 1565 06c6 8091 0000 		lds r24,uxCurrentNumberOfTasks
 1566 06ca 8823      		tst r24
 1567 06cc 01F4      		brne .+2
 1568 06ce 00C0      		rjmp .L48
 1569               	.LBB3:
1374:../../FreeRTOS/Source/tasks.c **** 			{
1375:../../FreeRTOS/Source/tasks.c **** 				portBASE_TYPE xYieldRequired = pdFALSE;
 1571               	.LM141:
 1572 06d0 1A82      		std Y+2,__zero_reg__
1376:../../FreeRTOS/Source/tasks.c **** 
1377:../../FreeRTOS/Source/tasks.c **** 				/* Move any readied tasks from the pending list into the
1378:../../FreeRTOS/Source/tasks.c **** 				appropriate ready list. */
1379:../../FreeRTOS/Source/tasks.c **** 				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 1574               	.LM142:
 1575 06d2 00C0      		rjmp .L49
 1576               	.L51:
1380:../../FreeRTOS/Source/tasks.c **** 				{
1381:../../FreeRTOS/Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
 1578               	.LM143:
 1579 06d4 8091 0000 		lds r24,xPendingReadyList+5
 1580 06d8 9091 0000 		lds r25,xPendingReadyList+5+1
 1581 06dc FC01      		movw r30,r24
 1582 06de 0681      		ldd r16,Z+6
 1583 06e0 1781      		ldd r17,Z+7
1382:../../FreeRTOS/Source/tasks.c **** 					uxListRemove( &( pxTCB->xEventListItem ) );
 1585               	.LM144:
 1586 06e2 C801      		movw r24,r16
 1587 06e4 0C96      		adiw r24,12
 1588 06e6 0E94 0000 		call uxListRemove
1383:../../FreeRTOS/Source/tasks.c **** 					uxListRemove( &( pxTCB->xGenericListItem ) );
 1590               	.LM145:
 1591 06ea C801      		movw r24,r16
 1592 06ec 0296      		adiw r24,2
 1593 06ee 0E94 0000 		call uxListRemove
1384:../../FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1595               	.LM146:
 1596 06f2 F801      		movw r30,r16
 1597 06f4 9689      		ldd r25,Z+22
 1598 06f6 8091 0000 		lds r24,uxTopReadyPriority
 1599 06fa 8917      		cp r24,r25
 1600 06fc 00F4      		brsh .L50
 1602               	.LM147:
 1603 06fe F801      		movw r30,r16
 1604 0700 8689      		ldd r24,Z+22
 1605 0702 8093 0000 		sts uxTopReadyPriority,r24
 1606               	.L50:
 1608               	.LM148:
 1609 0706 A801      		movw r20,r16
 1610 0708 4E5F      		subi r20,-2
 1611 070a 5F4F      		sbci r21,-1
 1612 070c F801      		movw r30,r16
 1613 070e 8689      		ldd r24,Z+22
 1614 0710 282F      		mov r18,r24
 1615 0712 30E0      		ldi r19,0
 1616 0714 C901      		movw r24,r18
 1617 0716 880F      		lsl r24
 1618 0718 991F      		rol r25
 1619 071a 880F      		lsl r24
 1620 071c 991F      		rol r25
 1621 071e 880F      		lsl r24
 1622 0720 991F      		rol r25
 1623 0722 820F      		add r24,r18
 1624 0724 931F      		adc r25,r19
 1625 0726 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1626 0728 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1627 072a BA01      		movw r22,r20
 1628 072c 0E94 0000 		call vListInsertEnd
1385:../../FreeRTOS/Source/tasks.c **** 
1386:../../FreeRTOS/Source/tasks.c **** 					/* If we have moved a task that has a priority higher than
1387:../../FreeRTOS/Source/tasks.c **** 					the current task then we should yield. */
1388:../../FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1630               	.LM149:
 1631 0730 F801      		movw r30,r16
 1632 0732 2689      		ldd r18,Z+22
 1633 0734 8091 0000 		lds r24,pxCurrentTCB
 1634 0738 9091 0000 		lds r25,pxCurrentTCB+1
 1635 073c FC01      		movw r30,r24
 1636 073e 8689      		ldd r24,Z+22
 1637 0740 2817      		cp r18,r24
 1638 0742 00F0      		brlo .L49
1389:../../FreeRTOS/Source/tasks.c **** 					{
1390:../../FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
 1640               	.LM150:
 1641 0744 81E0      		ldi r24,lo8(1)
 1642 0746 8A83      		std Y+2,r24
 1643               	.L49:
1379:../../FreeRTOS/Source/tasks.c **** 				{
 1645               	.LM151:
 1646 0748 8091 0000 		lds r24,xPendingReadyList
 1647 074c 8823      		tst r24
 1648 074e 01F4      		brne .L51
1391:../../FreeRTOS/Source/tasks.c **** 					}
1392:../../FreeRTOS/Source/tasks.c **** 				}
1393:../../FreeRTOS/Source/tasks.c **** 
1394:../../FreeRTOS/Source/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
1395:../../FreeRTOS/Source/tasks.c **** 				they should be processed now.  This ensures the tick count does not
1396:../../FreeRTOS/Source/tasks.c **** 				slip, and that any delayed tasks are resumed at the correct time. */
1397:../../FreeRTOS/Source/tasks.c **** 				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 1650               	.LM152:
 1651 0750 8091 0000 		lds r24,uxMissedTicks
 1652 0754 8823      		tst r24
 1653 0756 01F0      		breq .L52
1398:../../FreeRTOS/Source/tasks.c **** 				{
1399:../../FreeRTOS/Source/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 1655               	.LM153:
 1656 0758 00C0      		rjmp .L53
 1657               	.L54:
1400:../../FreeRTOS/Source/tasks.c **** 					{
1401:../../FreeRTOS/Source/tasks.c **** 						vTaskIncrementTick();
 1659               	.LM154:
 1660 075a 0E94 0000 		call vTaskIncrementTick
1402:../../FreeRTOS/Source/tasks.c **** 						--uxMissedTicks;
 1662               	.LM155:
 1663 075e 8091 0000 		lds r24,uxMissedTicks
 1664 0762 8150      		subi r24,lo8(-(-1))
 1665 0764 8093 0000 		sts uxMissedTicks,r24
 1666               	.L53:
1399:../../FreeRTOS/Source/tasks.c **** 					{
 1668               	.LM156:
 1669 0768 8091 0000 		lds r24,uxMissedTicks
 1670 076c 8823      		tst r24
 1671 076e 01F4      		brne .L54
1403:../../FreeRTOS/Source/tasks.c **** 					}
1404:../../FreeRTOS/Source/tasks.c **** 
1405:../../FreeRTOS/Source/tasks.c **** 					/* As we have processed some ticks it is appropriate to yield
1406:../../FreeRTOS/Source/tasks.c **** 					to ensure the highest priority task that is ready to run is
1407:../../FreeRTOS/Source/tasks.c **** 					the task actually running. */
1408:../../FreeRTOS/Source/tasks.c **** 					#if configUSE_PREEMPTION == 1
1409:../../FreeRTOS/Source/tasks.c **** 					{
1410:../../FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
 1673               	.LM157:
 1674 0770 81E0      		ldi r24,lo8(1)
 1675 0772 8A83      		std Y+2,r24
 1676               	.L52:
1411:../../FreeRTOS/Source/tasks.c **** 					}
1412:../../FreeRTOS/Source/tasks.c **** 					#endif
1413:../../FreeRTOS/Source/tasks.c **** 				}
1414:../../FreeRTOS/Source/tasks.c **** 
1415:../../FreeRTOS/Source/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 1678               	.LM158:
 1679 0774 8A81      		ldd r24,Y+2
 1680 0776 8130      		cpi r24,lo8(1)
 1681 0778 01F0      		breq .L55
 1683               	.LM159:
 1684 077a 8091 0000 		lds r24,xMissedYield
 1685 077e 8130      		cpi r24,lo8(1)
 1686 0780 01F4      		brne .L48
 1687               	.L55:
1416:../../FreeRTOS/Source/tasks.c **** 				{
1417:../../FreeRTOS/Source/tasks.c **** 					xAlreadyYielded = pdTRUE;
 1689               	.LM160:
 1690 0782 81E0      		ldi r24,lo8(1)
 1691 0784 8983      		std Y+1,r24
1418:../../FreeRTOS/Source/tasks.c **** 					xMissedYield = pdFALSE;
 1693               	.LM161:
 1694 0786 1092 0000 		sts xMissedYield,__zero_reg__
1419:../../FreeRTOS/Source/tasks.c **** 					portYIELD_WITHIN_API();
 1696               	.LM162:
 1697 078a 0E94 0000 		call vPortYield
 1698               	.L48:
 1699               	.LBE3:
1420:../../FreeRTOS/Source/tasks.c **** 				}
1421:../../FreeRTOS/Source/tasks.c **** 			}
1422:../../FreeRTOS/Source/tasks.c **** 		}
1423:../../FreeRTOS/Source/tasks.c **** 	}
1424:../../FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
 1701               	.LM163:
 1702               	/* #APP */
 1703               	 ;  1424 "../../FreeRTOS/Source/tasks.c" 1
 1704 078e 0F90      		pop		__tmp_reg__
 1705               	 ;  0 "" 2
 1706               	 ;  1424 "../../FreeRTOS/Source/tasks.c" 1
 1707 0790 0FBE      		out		__SREG__, __tmp_reg__
 1708               	 ;  0 "" 2
1425:../../FreeRTOS/Source/tasks.c **** 
1426:../../FreeRTOS/Source/tasks.c **** 	return xAlreadyYielded;
 1710               	.LM164:
 1711               	/* #NOAPP */
 1712 0792 8981      		ldd r24,Y+1
 1713               	/* epilogue start */
1427:../../FreeRTOS/Source/tasks.c **** }
 1715               	.LM165:
 1716 0794 0F90      		pop __tmp_reg__
 1717 0796 0F90      		pop __tmp_reg__
 1718 0798 DF91      		pop r29
 1719 079a CF91      		pop r28
 1720 079c 1F91      		pop r17
 1721 079e 0F91      		pop r16
 1722 07a0 0895      		ret
 1731               	.Lscope11:
 1733               		.stabd	78,0,0
 1735               	.global	xTaskGetTickCount
 1737               	xTaskGetTickCount:
 1738               		.stabd	46,0,0
1428:../../FreeRTOS/Source/tasks.c **** 
1429:../../FreeRTOS/Source/tasks.c **** 
1430:../../FreeRTOS/Source/tasks.c **** 
1431:../../FreeRTOS/Source/tasks.c **** 
1432:../../FreeRTOS/Source/tasks.c **** 
1433:../../FreeRTOS/Source/tasks.c **** 
1434:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
1435:../../FreeRTOS/Source/tasks.c ****  * PUBLIC TASK UTILITIES documented in task.h
1436:../../FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
1437:../../FreeRTOS/Source/tasks.c **** 
1438:../../FreeRTOS/Source/tasks.c **** 
1439:../../FreeRTOS/Source/tasks.c **** 
1440:../../FreeRTOS/Source/tasks.c **** portTickType xTaskGetTickCount( void )
1441:../../FreeRTOS/Source/tasks.c **** {
 1740               	.LM166:
 1741               	.LFBB12:
 1742 07a2 CF93      		push r28
 1743 07a4 DF93      		push r29
 1744 07a6 1F92      		push __zero_reg__
 1745 07a8 1F92      		push __zero_reg__
 1746 07aa CDB7      		in r28,__SP_L__
 1747 07ac DEB7      		in r29,__SP_H__
 1748               	/* prologue: function */
 1749               	/* frame size = 2 */
 1750               	/* stack size = 4 */
 1751               	.L__stack_usage = 4
1442:../../FreeRTOS/Source/tasks.c **** portTickType xTicks;
1443:../../FreeRTOS/Source/tasks.c **** 
1444:../../FreeRTOS/Source/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
1445:../../FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
 1753               	.LM167:
 1754               	/* #APP */
 1755               	 ;  1445 "../../FreeRTOS/Source/tasks.c" 1
 1756 07ae 0FB6      		in		__tmp_reg__, __SREG__
 1757               	 ;  0 "" 2
 1758               	 ;  1445 "../../FreeRTOS/Source/tasks.c" 1
 1759 07b0 F894      		cli
 1760               	 ;  0 "" 2
 1761               	 ;  1445 "../../FreeRTOS/Source/tasks.c" 1
 1762 07b2 0F92      		push	__tmp_reg__
 1763               	 ;  0 "" 2
1446:../../FreeRTOS/Source/tasks.c **** 	{
1447:../../FreeRTOS/Source/tasks.c **** 		xTicks = xTickCount;
 1765               	.LM168:
 1766               	/* #NOAPP */
 1767 07b4 8091 0000 		lds r24,xTickCount
 1768 07b8 9091 0000 		lds r25,xTickCount+1
 1769 07bc 9A83      		std Y+2,r25
 1770 07be 8983      		std Y+1,r24
1448:../../FreeRTOS/Source/tasks.c **** 	}
1449:../../FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
 1772               	.LM169:
 1773               	/* #APP */
 1774               	 ;  1449 "../../FreeRTOS/Source/tasks.c" 1
 1775 07c0 0F90      		pop		__tmp_reg__
 1776               	 ;  0 "" 2
 1777               	 ;  1449 "../../FreeRTOS/Source/tasks.c" 1
 1778 07c2 0FBE      		out		__SREG__, __tmp_reg__
 1779               	 ;  0 "" 2
1450:../../FreeRTOS/Source/tasks.c **** 
1451:../../FreeRTOS/Source/tasks.c **** 	return xTicks;
 1781               	.LM170:
 1782               	/* #NOAPP */
 1783 07c4 8981      		ldd r24,Y+1
 1784 07c6 9A81      		ldd r25,Y+2
 1785               	/* epilogue start */
1452:../../FreeRTOS/Source/tasks.c **** }
 1787               	.LM171:
 1788 07c8 0F90      		pop __tmp_reg__
 1789 07ca 0F90      		pop __tmp_reg__
 1790 07cc DF91      		pop r29
 1791 07ce CF91      		pop r28
 1792 07d0 0895      		ret
 1797               	.Lscope12:
 1799               		.stabd	78,0,0
 1801               	.global	xTaskGetTickCountFromISR
 1803               	xTaskGetTickCountFromISR:
 1804               		.stabd	46,0,0
1453:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1454:../../FreeRTOS/Source/tasks.c **** 
1455:../../FreeRTOS/Source/tasks.c **** portTickType xTaskGetTickCountFromISR( void )
1456:../../FreeRTOS/Source/tasks.c **** {
 1806               	.LM172:
 1807               	.LFBB13:
 1808 07d2 CF93      		push r28
 1809 07d4 DF93      		push r29
 1810 07d6 00D0      		rcall .
 1811 07d8 CDB7      		in r28,__SP_L__
 1812 07da DEB7      		in r29,__SP_H__
 1813               	/* prologue: function */
 1814               	/* frame size = 3 */
 1815               	/* stack size = 5 */
 1816               	.L__stack_usage = 5
1457:../../FreeRTOS/Source/tasks.c **** portTickType xReturn;
1458:../../FreeRTOS/Source/tasks.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1459:../../FreeRTOS/Source/tasks.c **** 
1460:../../FreeRTOS/Source/tasks.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1818               	.LM173:
 1819 07dc 1982      		std Y+1,__zero_reg__
1461:../../FreeRTOS/Source/tasks.c **** 	xReturn = xTickCount;
 1821               	.LM174:
 1822 07de 8091 0000 		lds r24,xTickCount
 1823 07e2 9091 0000 		lds r25,xTickCount+1
 1824 07e6 9B83      		std Y+3,r25
 1825 07e8 8A83      		std Y+2,r24
1462:../../FreeRTOS/Source/tasks.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1463:../../FreeRTOS/Source/tasks.c **** 
1464:../../FreeRTOS/Source/tasks.c **** 	return xReturn;
 1827               	.LM175:
 1828 07ea 8A81      		ldd r24,Y+2
 1829 07ec 9B81      		ldd r25,Y+3
 1830               	/* epilogue start */
1465:../../FreeRTOS/Source/tasks.c **** }
 1832               	.LM176:
 1833 07ee 0F90      		pop __tmp_reg__
 1834 07f0 0F90      		pop __tmp_reg__
 1835 07f2 0F90      		pop __tmp_reg__
 1836 07f4 DF91      		pop r29
 1837 07f6 CF91      		pop r28
 1838 07f8 0895      		ret
 1844               	.Lscope13:
 1846               		.stabd	78,0,0
 1848               	.global	uxTaskGetNumberOfTasks
 1850               	uxTaskGetNumberOfTasks:
 1851               		.stabd	46,0,0
1466:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1467:../../FreeRTOS/Source/tasks.c **** 
1468:../../FreeRTOS/Source/tasks.c **** unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
1469:../../FreeRTOS/Source/tasks.c **** {
 1853               	.LM177:
 1854               	.LFBB14:
 1855 07fa CF93      		push r28
 1856 07fc DF93      		push r29
 1857 07fe CDB7      		in r28,__SP_L__
 1858 0800 DEB7      		in r29,__SP_H__
 1859               	/* prologue: function */
 1860               	/* frame size = 0 */
 1861               	/* stack size = 2 */
 1862               	.L__stack_usage = 2
1470:../../FreeRTOS/Source/tasks.c **** 	/* A critical section is not required because the variables are of type
1471:../../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE. */
1472:../../FreeRTOS/Source/tasks.c **** 	return uxCurrentNumberOfTasks;
 1864               	.LM178:
 1865 0802 8091 0000 		lds r24,uxCurrentNumberOfTasks
 1866               	/* epilogue start */
1473:../../FreeRTOS/Source/tasks.c **** }
 1868               	.LM179:
 1869 0806 DF91      		pop r29
 1870 0808 CF91      		pop r28
 1871 080a 0895      		ret
 1873               	.Lscope14:
 1875               		.stabd	78,0,0
 1877               	.global	vTaskIncrementTick
 1879               	vTaskIncrementTick:
 1880               		.stabd	46,0,0
1474:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1475:../../FreeRTOS/Source/tasks.c **** 
1476:../../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_pcTaskGetTaskName == 1 )
1477:../../FreeRTOS/Source/tasks.c **** 
1478:../../FreeRTOS/Source/tasks.c **** 	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
1479:../../FreeRTOS/Source/tasks.c **** 	{
1480:../../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
1481:../../FreeRTOS/Source/tasks.c **** 
1482:../../FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then the name of the calling task is being queried. */
1483:../../FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
1484:../../FreeRTOS/Source/tasks.c **** 		configASSERT( pxTCB );
1485:../../FreeRTOS/Source/tasks.c **** 		return &( pxTCB->pcTaskName[ 0 ] );
1486:../../FreeRTOS/Source/tasks.c **** 	}
1487:../../FreeRTOS/Source/tasks.c **** 
1488:../../FreeRTOS/Source/tasks.c **** #endif
1489:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1490:../../FreeRTOS/Source/tasks.c **** 
1491:../../FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1492:../../FreeRTOS/Source/tasks.c **** 
1493:../../FreeRTOS/Source/tasks.c **** 	void vTaskList( signed char *pcWriteBuffer )
1494:../../FreeRTOS/Source/tasks.c **** 	{
1495:../../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1496:../../FreeRTOS/Source/tasks.c **** 
1497:../../FreeRTOS/Source/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1498:../../FreeRTOS/Source/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1499:../../FreeRTOS/Source/tasks.c **** 
1500:../../FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
1501:../../FreeRTOS/Source/tasks.c **** 		{
1502:../../FreeRTOS/Source/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB and
1503:../../FreeRTOS/Source/tasks.c **** 			report the task name, state and stack high water mark. */
1504:../../FreeRTOS/Source/tasks.c **** 
1505:../../FreeRTOS/Source/tasks.c **** 			*pcWriteBuffer = ( signed char ) 0x00;
1506:../../FreeRTOS/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1507:../../FreeRTOS/Source/tasks.c **** 
1508:../../FreeRTOS/Source/tasks.c **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
1509:../../FreeRTOS/Source/tasks.c **** 
1510:../../FreeRTOS/Source/tasks.c **** 			do
1511:../../FreeRTOS/Source/tasks.c **** 			{
1512:../../FreeRTOS/Source/tasks.c **** 				uxQueue--;
1513:../../FreeRTOS/Source/tasks.c **** 
1514:../../FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
1515:../../FreeRTOS/Source/tasks.c **** 				{
1516:../../FreeRTOS/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tsk
1517:../../FreeRTOS/Source/tasks.c **** 				}
1518:../../FreeRTOS/Source/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1519:../../FreeRTOS/Source/tasks.c **** 
1520:../../FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
1521:../../FreeRTOS/Source/tasks.c **** 			{
1522:../../FreeRTOS/Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
1523:../../FreeRTOS/Source/tasks.c **** 			}
1524:../../FreeRTOS/Source/tasks.c **** 
1525:../../FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
1526:../../FreeRTOS/Source/tasks.c **** 			{
1527:../../FreeRTOS/Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_C
1528:../../FreeRTOS/Source/tasks.c **** 			}
1529:../../FreeRTOS/Source/tasks.c **** 
1530:../../FreeRTOS/Source/tasks.c **** 			#if( INCLUDE_vTaskDelete == 1 )
1531:../../FreeRTOS/Source/tasks.c **** 			{
1532:../../FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
1533:../../FreeRTOS/Source/tasks.c **** 				{
1534:../../FreeRTOS/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, &xTasksWaitingTermination, tskDELETED_CHAR );
1535:../../FreeRTOS/Source/tasks.c **** 				}
1536:../../FreeRTOS/Source/tasks.c **** 			}
1537:../../FreeRTOS/Source/tasks.c **** 			#endif
1538:../../FreeRTOS/Source/tasks.c **** 
1539:../../FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1540:../../FreeRTOS/Source/tasks.c **** 			{
1541:../../FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
1542:../../FreeRTOS/Source/tasks.c **** 				{
1543:../../FreeRTOS/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, &xSuspendedTaskList, tskSUSPENDED_CHAR );
1544:../../FreeRTOS/Source/tasks.c **** 				}
1545:../../FreeRTOS/Source/tasks.c **** 			}
1546:../../FreeRTOS/Source/tasks.c **** 			#endif
1547:../../FreeRTOS/Source/tasks.c **** 		}
1548:../../FreeRTOS/Source/tasks.c **** 		xTaskResumeAll();
1549:../../FreeRTOS/Source/tasks.c **** 	}
1550:../../FreeRTOS/Source/tasks.c **** 
1551:../../FreeRTOS/Source/tasks.c **** #endif
1552:../../FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1553:../../FreeRTOS/Source/tasks.c **** 
1554:../../FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
1555:../../FreeRTOS/Source/tasks.c **** 
1556:../../FreeRTOS/Source/tasks.c **** 	void vTaskGetRunTimeStats( signed char *pcWriteBuffer )
1557:../../FreeRTOS/Source/tasks.c **** 	{
1558:../../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1559:../../FreeRTOS/Source/tasks.c **** 	unsigned long ulTotalRunTime;
1560:../../FreeRTOS/Source/tasks.c **** 
1561:../../FreeRTOS/Source/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1562:../../FreeRTOS/Source/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1563:../../FreeRTOS/Source/tasks.c **** 
1564:../../FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
1565:../../FreeRTOS/Source/tasks.c **** 		{
1566:../../FreeRTOS/Source/tasks.c **** 			#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1567:../../FreeRTOS/Source/tasks.c **** 				portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
1568:../../FreeRTOS/Source/tasks.c **** 			#else
1569:../../FreeRTOS/Source/tasks.c **** 				ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1570:../../FreeRTOS/Source/tasks.c **** 			#endif
1571:../../FreeRTOS/Source/tasks.c **** 
1572:../../FreeRTOS/Source/tasks.c **** 			/* Divide ulTotalRunTime by 100 to make the percentage caluclations
1573:../../FreeRTOS/Source/tasks.c **** 			simpler in the prvGenerateRunTimeStatsForTasksInList() function. */
1574:../../FreeRTOS/Source/tasks.c **** 			ulTotalRunTime /= 100UL;
1575:../../FreeRTOS/Source/tasks.c **** 
1576:../../FreeRTOS/Source/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB,
1577:../../FreeRTOS/Source/tasks.c **** 			generating a table of run timer percentages in the provided
1578:../../FreeRTOS/Source/tasks.c **** 			buffer. */
1579:../../FreeRTOS/Source/tasks.c **** 
1580:../../FreeRTOS/Source/tasks.c **** 			*pcWriteBuffer = ( signed char ) 0x00;
1581:../../FreeRTOS/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1582:../../FreeRTOS/Source/tasks.c **** 
1583:../../FreeRTOS/Source/tasks.c **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
1584:../../FreeRTOS/Source/tasks.c **** 
1585:../../FreeRTOS/Source/tasks.c **** 			do
1586:../../FreeRTOS/Source/tasks.c **** 			{
1587:../../FreeRTOS/Source/tasks.c **** 				uxQueue--;
1588:../../FreeRTOS/Source/tasks.c **** 
1589:../../FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
1590:../../FreeRTOS/Source/tasks.c **** 				{
1591:../../FreeRTOS/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueu
1592:../../FreeRTOS/Source/tasks.c **** 				}
1593:../../FreeRTOS/Source/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1594:../../FreeRTOS/Source/tasks.c **** 
1595:../../FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
1596:../../FreeRTOS/Source/tasks.c **** 			{
1597:../../FreeRTOS/Source/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, ulTotalRun
1598:../../FreeRTOS/Source/tasks.c **** 			}
1599:../../FreeRTOS/Source/tasks.c **** 
1600:../../FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
1601:../../FreeRTOS/Source/tasks.c **** 			{
1602:../../FreeRTOS/Source/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, ul
1603:../../FreeRTOS/Source/tasks.c **** 			}
1604:../../FreeRTOS/Source/tasks.c **** 
1605:../../FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1606:../../FreeRTOS/Source/tasks.c **** 			{
1607:../../FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
1608:../../FreeRTOS/Source/tasks.c **** 				{
1609:../../FreeRTOS/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xTasksWaitingTermination, ulTotalRunTim
1610:../../FreeRTOS/Source/tasks.c **** 				}
1611:../../FreeRTOS/Source/tasks.c **** 			}
1612:../../FreeRTOS/Source/tasks.c **** 			#endif
1613:../../FreeRTOS/Source/tasks.c **** 
1614:../../FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1615:../../FreeRTOS/Source/tasks.c **** 			{
1616:../../FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
1617:../../FreeRTOS/Source/tasks.c **** 				{
1618:../../FreeRTOS/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xSuspendedTaskList, ulTotalRunTime );
1619:../../FreeRTOS/Source/tasks.c **** 				}
1620:../../FreeRTOS/Source/tasks.c **** 			}
1621:../../FreeRTOS/Source/tasks.c **** 			#endif
1622:../../FreeRTOS/Source/tasks.c **** 		}
1623:../../FreeRTOS/Source/tasks.c **** 		xTaskResumeAll();
1624:../../FreeRTOS/Source/tasks.c **** 	}
1625:../../FreeRTOS/Source/tasks.c **** 
1626:../../FreeRTOS/Source/tasks.c **** #endif
1627:../../FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1628:../../FreeRTOS/Source/tasks.c **** 
1629:../../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1630:../../FreeRTOS/Source/tasks.c **** 
1631:../../FreeRTOS/Source/tasks.c **** 	xTaskHandle xTaskGetIdleTaskHandle( void )
1632:../../FreeRTOS/Source/tasks.c **** 	{
1633:../../FreeRTOS/Source/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
1634:../../FreeRTOS/Source/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
1635:../../FreeRTOS/Source/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
1636:../../FreeRTOS/Source/tasks.c **** 		return xIdleTaskHandle;
1637:../../FreeRTOS/Source/tasks.c **** 	}
1638:../../FreeRTOS/Source/tasks.c **** 
1639:../../FreeRTOS/Source/tasks.c **** #endif
1640:../../FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1641:../../FreeRTOS/Source/tasks.c **** 
1642:../../FreeRTOS/Source/tasks.c **** /* This conditional compilation should use inequality to 0, not equality to 1.
1643:../../FreeRTOS/Source/tasks.c **** This is to ensure vTaskStepTick() is available when user defined low power mode
1644:../../FreeRTOS/Source/tasks.c **** implementations require configUSE_TICKLESS_IDLE to be set to a value other than
1645:../../FreeRTOS/Source/tasks.c **** 1. */
1646:../../FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
1647:../../FreeRTOS/Source/tasks.c **** 
1648:../../FreeRTOS/Source/tasks.c **** 	void vTaskStepTick( portTickType xTicksToJump )
1649:../../FreeRTOS/Source/tasks.c **** 	{
1650:../../FreeRTOS/Source/tasks.c **** 		configASSERT( xTicksToJump <= xNextTaskUnblockTime );
1651:../../FreeRTOS/Source/tasks.c **** 		xTickCount += xTicksToJump;
1652:../../FreeRTOS/Source/tasks.c **** 	}
1653:../../FreeRTOS/Source/tasks.c **** 
1654:../../FreeRTOS/Source/tasks.c **** #endif
1655:../../FreeRTOS/Source/tasks.c **** 
1656:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
1657:../../FreeRTOS/Source/tasks.c ****  * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
1658:../../FreeRTOS/Source/tasks.c ****  * documented in task.h
1659:../../FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
1660:../../FreeRTOS/Source/tasks.c **** 
1661:../../FreeRTOS/Source/tasks.c **** void vTaskIncrementTick( void )
1662:../../FreeRTOS/Source/tasks.c **** {
 1882               	.LM180:
 1883               	.LFBB15:
 1884 080c CF93      		push r28
 1885 080e DF93      		push r29
 1886 0810 00D0      		rcall .
 1887 0812 00D0      		rcall .
 1888 0814 CDB7      		in r28,__SP_L__
 1889 0816 DEB7      		in r29,__SP_H__
 1890               	/* prologue: function */
 1891               	/* frame size = 6 */
 1892               	/* stack size = 8 */
 1893               	.L__stack_usage = 8
1663:../../FreeRTOS/Source/tasks.c **** tskTCB * pxTCB;
1664:../../FreeRTOS/Source/tasks.c **** 
1665:../../FreeRTOS/Source/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
1666:../../FreeRTOS/Source/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
1667:../../FreeRTOS/Source/tasks.c **** 	tasks to be unblocked. */
1668:../../FreeRTOS/Source/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
1669:../../FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1895               	.LM181:
 1896 0818 8091 0000 		lds r24,uxSchedulerSuspended
 1897 081c 8823      		tst r24
 1898 081e 01F0      		breq .+2
 1899 0820 00C0      		rjmp .L64
1670:../../FreeRTOS/Source/tasks.c **** 	{
1671:../../FreeRTOS/Source/tasks.c **** 		++xTickCount;
 1901               	.LM182:
 1902 0822 8091 0000 		lds r24,xTickCount
 1903 0826 9091 0000 		lds r25,xTickCount+1
 1904 082a 0196      		adiw r24,1
 1905 082c 9093 0000 		sts xTickCount+1,r25
 1906 0830 8093 0000 		sts xTickCount,r24
1672:../../FreeRTOS/Source/tasks.c **** 		if( xTickCount == ( portTickType ) 0U )
 1908               	.LM183:
 1909 0834 8091 0000 		lds r24,xTickCount
 1910 0838 9091 0000 		lds r25,xTickCount+1
 1911 083c 0097      		sbiw r24,0
 1912 083e 01F4      		brne .L65
 1913               	.LBB4:
1673:../../FreeRTOS/Source/tasks.c **** 		{
1674:../../FreeRTOS/Source/tasks.c **** 			xList *pxTemp;
1675:../../FreeRTOS/Source/tasks.c **** 
1676:../../FreeRTOS/Source/tasks.c **** 			/* Tick count has overflowed so we need to swap the delay lists.
1677:../../FreeRTOS/Source/tasks.c **** 			If there are any items in pxDelayedTaskList here then there is
1678:../../FreeRTOS/Source/tasks.c **** 			an error! */
1679:../../FreeRTOS/Source/tasks.c **** 			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
1680:../../FreeRTOS/Source/tasks.c **** 
1681:../../FreeRTOS/Source/tasks.c **** 			pxTemp = pxDelayedTaskList;
 1915               	.LM184:
 1916 0840 8091 0000 		lds r24,pxDelayedTaskList
 1917 0844 9091 0000 		lds r25,pxDelayedTaskList+1
 1918 0848 9A83      		std Y+2,r25
 1919 084a 8983      		std Y+1,r24
1682:../../FreeRTOS/Source/tasks.c **** 			pxDelayedTaskList = pxOverflowDelayedTaskList;
 1921               	.LM185:
 1922 084c 8091 0000 		lds r24,pxOverflowDelayedTaskList
 1923 0850 9091 0000 		lds r25,pxOverflowDelayedTaskList+1
 1924 0854 9093 0000 		sts pxDelayedTaskList+1,r25
 1925 0858 8093 0000 		sts pxDelayedTaskList,r24
1683:../../FreeRTOS/Source/tasks.c **** 			pxOverflowDelayedTaskList = pxTemp;
 1927               	.LM186:
 1928 085c 8981      		ldd r24,Y+1
 1929 085e 9A81      		ldd r25,Y+2
 1930 0860 9093 0000 		sts pxOverflowDelayedTaskList+1,r25
 1931 0864 8093 0000 		sts pxOverflowDelayedTaskList,r24
1684:../../FreeRTOS/Source/tasks.c **** 			xNumOfOverflows++;
 1933               	.LM187:
 1934 0868 8091 0000 		lds r24,xNumOfOverflows
 1935 086c 8F5F      		subi r24,lo8(-(1))
 1936 086e 8093 0000 		sts xNumOfOverflows,r24
1685:../../FreeRTOS/Source/tasks.c **** 
1686:../../FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 1938               	.LM188:
 1939 0872 8091 0000 		lds r24,pxDelayedTaskList
 1940 0876 9091 0000 		lds r25,pxDelayedTaskList+1
 1941 087a FC01      		movw r30,r24
 1942 087c 8081      		ld r24,Z
 1943 087e 8823      		tst r24
 1944 0880 01F4      		brne .L66
1687:../../FreeRTOS/Source/tasks.c **** 			{
1688:../../FreeRTOS/Source/tasks.c **** 				/* The new current delayed list is empty.  Set
1689:../../FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime to the maximum possible value so it is
1690:../../FreeRTOS/Source/tasks.c **** 				extremely unlikely that the
1691:../../FreeRTOS/Source/tasks.c **** 				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
1692:../../FreeRTOS/Source/tasks.c **** 				there is an item in the delayed list. */
1693:../../FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime = portMAX_DELAY;
 1946               	.LM189:
 1947 0882 8FEF      		ldi r24,lo8(-1)
 1948 0884 9FEF      		ldi r25,lo8(-1)
 1949 0886 9093 0000 		sts xNextTaskUnblockTime+1,r25
 1950 088a 8093 0000 		sts xNextTaskUnblockTime,r24
 1951 088e 00C0      		rjmp .L65
 1952               	.L66:
1694:../../FreeRTOS/Source/tasks.c **** 			}
1695:../../FreeRTOS/Source/tasks.c **** 			else
1696:../../FreeRTOS/Source/tasks.c **** 			{
1697:../../FreeRTOS/Source/tasks.c **** 				/* The new current delayed list is not empty, get the value of
1698:../../FreeRTOS/Source/tasks.c **** 				the item at the head of the delayed list.  This is the time at
1699:../../FreeRTOS/Source/tasks.c **** 				which the task at the head of the delayed list should be removed
1700:../../FreeRTOS/Source/tasks.c **** 				from the Blocked state. */
1701:../../FreeRTOS/Source/tasks.c **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 1954               	.LM190:
 1955 0890 8091 0000 		lds r24,pxDelayedTaskList
 1956 0894 9091 0000 		lds r25,pxDelayedTaskList+1
 1957 0898 FC01      		movw r30,r24
 1958 089a 8581      		ldd r24,Z+5
 1959 089c 9681      		ldd r25,Z+6
 1960 089e FC01      		movw r30,r24
 1961 08a0 8681      		ldd r24,Z+6
 1962 08a2 9781      		ldd r25,Z+7
 1963 08a4 9C83      		std Y+4,r25
 1964 08a6 8B83      		std Y+3,r24
1702:../../FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 1966               	.LM191:
 1967 08a8 8B81      		ldd r24,Y+3
 1968 08aa 9C81      		ldd r25,Y+4
 1969 08ac FC01      		movw r30,r24
 1970 08ae 8281      		ldd r24,Z+2
 1971 08b0 9381      		ldd r25,Z+3
 1972 08b2 9093 0000 		sts xNextTaskUnblockTime+1,r25
 1973 08b6 8093 0000 		sts xNextTaskUnblockTime,r24
 1974               	.L65:
 1975               	.LBE4:
 1976               	.LBB5:
1703:../../FreeRTOS/Source/tasks.c **** 			}
1704:../../FreeRTOS/Source/tasks.c **** 		}
1705:../../FreeRTOS/Source/tasks.c **** 
1706:../../FreeRTOS/Source/tasks.c **** 		/* See if this tick has made a timeout expire. */
1707:../../FreeRTOS/Source/tasks.c **** 		prvCheckDelayedTasks();
 1978               	.LM192:
 1979 08ba 2091 0000 		lds r18,xTickCount
 1980 08be 3091 0000 		lds r19,xTickCount+1
 1981 08c2 8091 0000 		lds r24,xNextTaskUnblockTime
 1982 08c6 9091 0000 		lds r25,xNextTaskUnblockTime+1
 1983 08ca 2817      		cp r18,r24
 1984 08cc 3907      		cpc r19,r25
 1985 08ce 00F4      		brsh .+2
 1986 08d0 00C0      		rjmp .L67
 1987               	.L72:
 1989               	.LM193:
 1990 08d2 8091 0000 		lds r24,pxDelayedTaskList
 1991 08d6 9091 0000 		lds r25,pxDelayedTaskList+1
 1992 08da FC01      		movw r30,r24
 1993 08dc 8081      		ld r24,Z
 1994 08de 8823      		tst r24
 1995 08e0 01F4      		brne .L68
 1997               	.LM194:
 1998 08e2 8FEF      		ldi r24,lo8(-1)
 1999 08e4 9FEF      		ldi r25,lo8(-1)
 2000 08e6 9093 0000 		sts xNextTaskUnblockTime+1,r25
 2001 08ea 8093 0000 		sts xNextTaskUnblockTime,r24
 2002 08ee 00C0      		rjmp .L67
 2003               	.L68:
 2005               	.LM195:
 2006 08f0 8091 0000 		lds r24,pxDelayedTaskList
 2007 08f4 9091 0000 		lds r25,pxDelayedTaskList+1
 2008 08f8 FC01      		movw r30,r24
 2009 08fa 8581      		ldd r24,Z+5
 2010 08fc 9681      		ldd r25,Z+6
 2011 08fe FC01      		movw r30,r24
 2012 0900 8681      		ldd r24,Z+6
 2013 0902 9781      		ldd r25,Z+7
 2014 0904 9C83      		std Y+4,r25
 2015 0906 8B83      		std Y+3,r24
 2016 0908 8B81      		ldd r24,Y+3
 2017 090a 9C81      		ldd r25,Y+4
 2018 090c FC01      		movw r30,r24
 2019 090e 8281      		ldd r24,Z+2
 2020 0910 9381      		ldd r25,Z+3
 2021 0912 9E83      		std Y+6,r25
 2022 0914 8D83      		std Y+5,r24
 2023 0916 2091 0000 		lds r18,xTickCount
 2024 091a 3091 0000 		lds r19,xTickCount+1
 2025 091e 8D81      		ldd r24,Y+5
 2026 0920 9E81      		ldd r25,Y+6
 2027 0922 2817      		cp r18,r24
 2028 0924 3907      		cpc r19,r25
 2029 0926 00F4      		brsh .L69
 2031               	.LM196:
 2032 0928 8D81      		ldd r24,Y+5
 2033 092a 9E81      		ldd r25,Y+6
 2034 092c 9093 0000 		sts xNextTaskUnblockTime+1,r25
 2035 0930 8093 0000 		sts xNextTaskUnblockTime,r24
 2036 0934 00C0      		rjmp .L67
 2037               	.L69:
 2039               	.LM197:
 2040 0936 8B81      		ldd r24,Y+3
 2041 0938 9C81      		ldd r25,Y+4
 2042 093a 0296      		adiw r24,2
 2043 093c 0E94 0000 		call uxListRemove
 2044 0940 8B81      		ldd r24,Y+3
 2045 0942 9C81      		ldd r25,Y+4
 2046 0944 FC01      		movw r30,r24
 2047 0946 8489      		ldd r24,Z+20
 2048 0948 9589      		ldd r25,Z+21
 2049 094a 0097      		sbiw r24,0
 2050 094c 01F0      		breq .L70
 2052               	.LM198:
 2053 094e 8B81      		ldd r24,Y+3
 2054 0950 9C81      		ldd r25,Y+4
 2055 0952 0C96      		adiw r24,12
 2056 0954 0E94 0000 		call uxListRemove
 2057               	.L70:
 2059               	.LM199:
 2060 0958 8B81      		ldd r24,Y+3
 2061 095a 9C81      		ldd r25,Y+4
 2062 095c FC01      		movw r30,r24
 2063 095e 9689      		ldd r25,Z+22
 2064 0960 8091 0000 		lds r24,uxTopReadyPriority
 2065 0964 8917      		cp r24,r25
 2066 0966 00F4      		brsh .L71
 2068               	.LM200:
 2069 0968 8B81      		ldd r24,Y+3
 2070 096a 9C81      		ldd r25,Y+4
 2071 096c FC01      		movw r30,r24
 2072 096e 8689      		ldd r24,Z+22
 2073 0970 8093 0000 		sts uxTopReadyPriority,r24
 2074               	.L71:
 2076               	.LM201:
 2077 0974 8B81      		ldd r24,Y+3
 2078 0976 9C81      		ldd r25,Y+4
 2079 0978 AC01      		movw r20,r24
 2080 097a 4E5F      		subi r20,-2
 2081 097c 5F4F      		sbci r21,-1
 2082 097e 8B81      		ldd r24,Y+3
 2083 0980 9C81      		ldd r25,Y+4
 2084 0982 FC01      		movw r30,r24
 2085 0984 8689      		ldd r24,Z+22
 2086 0986 282F      		mov r18,r24
 2087 0988 30E0      		ldi r19,0
 2088 098a C901      		movw r24,r18
 2089 098c 880F      		lsl r24
 2090 098e 991F      		rol r25
 2091 0990 880F      		lsl r24
 2092 0992 991F      		rol r25
 2093 0994 880F      		lsl r24
 2094 0996 991F      		rol r25
 2095 0998 820F      		add r24,r18
 2096 099a 931F      		adc r25,r19
 2097 099c 8050      		subi r24,lo8(-(pxReadyTasksLists))
 2098 099e 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 2099 09a0 BA01      		movw r22,r20
 2100 09a2 0E94 0000 		call vListInsertEnd
 2101 09a6 00C0      		rjmp .L72
 2102               	.L67:
 2103               	.LBE5:
 2104 09a8 00C0      		rjmp .L63
 2105               	.L64:
1708:../../FreeRTOS/Source/tasks.c **** 	}
1709:../../FreeRTOS/Source/tasks.c **** 	else
1710:../../FreeRTOS/Source/tasks.c **** 	{
1711:../../FreeRTOS/Source/tasks.c **** 		++uxMissedTicks;
 2107               	.LM202:
 2108 09aa 8091 0000 		lds r24,uxMissedTicks
 2109 09ae 8F5F      		subi r24,lo8(-(1))
 2110 09b0 8093 0000 		sts uxMissedTicks,r24
 2111               	.L63:
 2112               	/* epilogue start */
1712:../../FreeRTOS/Source/tasks.c **** 
1713:../../FreeRTOS/Source/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
1714:../../FreeRTOS/Source/tasks.c **** 		scheduler is locked. */
1715:../../FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
1716:../../FreeRTOS/Source/tasks.c **** 		{
1717:../../FreeRTOS/Source/tasks.c **** 			vApplicationTickHook();
1718:../../FreeRTOS/Source/tasks.c **** 		}
1719:../../FreeRTOS/Source/tasks.c **** 		#endif
1720:../../FreeRTOS/Source/tasks.c **** 	}
1721:../../FreeRTOS/Source/tasks.c **** 
1722:../../FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TICK_HOOK == 1 )
1723:../../FreeRTOS/Source/tasks.c **** 	{
1724:../../FreeRTOS/Source/tasks.c **** 		/* Guard against the tick hook being called when the missed tick
1725:../../FreeRTOS/Source/tasks.c **** 		count is being unwound (when the scheduler is being unlocked. */
1726:../../FreeRTOS/Source/tasks.c **** 		if( uxMissedTicks == ( unsigned portBASE_TYPE ) 0U )
1727:../../FreeRTOS/Source/tasks.c **** 		{
1728:../../FreeRTOS/Source/tasks.c **** 			vApplicationTickHook();
1729:../../FreeRTOS/Source/tasks.c **** 		}
1730:../../FreeRTOS/Source/tasks.c **** 	}
1731:../../FreeRTOS/Source/tasks.c **** 	#endif
1732:../../FreeRTOS/Source/tasks.c **** }
 2114               	.LM203:
 2115 09b4 2696      		adiw r28,6
 2116 09b6 0FB6      		in __tmp_reg__,__SREG__
 2117 09b8 F894      		cli
 2118 09ba DEBF      		out __SP_H__,r29
 2119 09bc 0FBE      		out __SREG__,__tmp_reg__
 2120 09be CDBF      		out __SP_L__,r28
 2121 09c0 DF91      		pop r29
 2122 09c2 CF91      		pop r28
 2123 09c4 0895      		ret
 2134               	.Lscope15:
 2136               		.stabd	78,0,0
 2138               	.global	vTaskSwitchContext
 2140               	vTaskSwitchContext:
 2141               		.stabd	46,0,0
1733:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1734:../../FreeRTOS/Source/tasks.c **** 
1735:../../FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1736:../../FreeRTOS/Source/tasks.c **** 
1737:../../FreeRTOS/Source/tasks.c **** 	void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction )
1738:../../FreeRTOS/Source/tasks.c **** 	{
1739:../../FreeRTOS/Source/tasks.c **** 	tskTCB *xTCB;
1740:../../FreeRTOS/Source/tasks.c **** 
1741:../../FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1742:../../FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
1743:../../FreeRTOS/Source/tasks.c **** 		{
1744:../../FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1745:../../FreeRTOS/Source/tasks.c **** 		}
1746:../../FreeRTOS/Source/tasks.c **** 		else
1747:../../FreeRTOS/Source/tasks.c **** 		{
1748:../../FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1749:../../FreeRTOS/Source/tasks.c **** 		}
1750:../../FreeRTOS/Source/tasks.c **** 
1751:../../FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1752:../../FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
1753:../../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1754:../../FreeRTOS/Source/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
1755:../../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1756:../../FreeRTOS/Source/tasks.c **** 	}
1757:../../FreeRTOS/Source/tasks.c **** 
1758:../../FreeRTOS/Source/tasks.c **** #endif
1759:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1760:../../FreeRTOS/Source/tasks.c **** 
1761:../../FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1762:../../FreeRTOS/Source/tasks.c **** 
1763:../../FreeRTOS/Source/tasks.c **** 	pdTASK_HOOK_CODE xTaskGetApplicationTaskTag( xTaskHandle xTask )
1764:../../FreeRTOS/Source/tasks.c **** 	{
1765:../../FreeRTOS/Source/tasks.c **** 	tskTCB *xTCB;
1766:../../FreeRTOS/Source/tasks.c **** 	pdTASK_HOOK_CODE xReturn;
1767:../../FreeRTOS/Source/tasks.c **** 
1768:../../FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1769:../../FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
1770:../../FreeRTOS/Source/tasks.c **** 		{
1771:../../FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1772:../../FreeRTOS/Source/tasks.c **** 		}
1773:../../FreeRTOS/Source/tasks.c **** 		else
1774:../../FreeRTOS/Source/tasks.c **** 		{
1775:../../FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1776:../../FreeRTOS/Source/tasks.c **** 		}
1777:../../FreeRTOS/Source/tasks.c **** 
1778:../../FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1779:../../FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
1780:../../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1781:../../FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag;
1782:../../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1783:../../FreeRTOS/Source/tasks.c **** 
1784:../../FreeRTOS/Source/tasks.c **** 		return xReturn;
1785:../../FreeRTOS/Source/tasks.c **** 	}
1786:../../FreeRTOS/Source/tasks.c **** 
1787:../../FreeRTOS/Source/tasks.c **** #endif
1788:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1789:../../FreeRTOS/Source/tasks.c **** 
1790:../../FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1791:../../FreeRTOS/Source/tasks.c **** 
1792:../../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter )
1793:../../FreeRTOS/Source/tasks.c **** 	{
1794:../../FreeRTOS/Source/tasks.c **** 	tskTCB *xTCB;
1795:../../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xReturn;
1796:../../FreeRTOS/Source/tasks.c **** 
1797:../../FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
1798:../../FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
1799:../../FreeRTOS/Source/tasks.c **** 		{
1800:../../FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1801:../../FreeRTOS/Source/tasks.c **** 		}
1802:../../FreeRTOS/Source/tasks.c **** 		else
1803:../../FreeRTOS/Source/tasks.c **** 		{
1804:../../FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1805:../../FreeRTOS/Source/tasks.c **** 		}
1806:../../FreeRTOS/Source/tasks.c **** 
1807:../../FreeRTOS/Source/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
1808:../../FreeRTOS/Source/tasks.c **** 		{
1809:../../FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
1810:../../FreeRTOS/Source/tasks.c **** 		}
1811:../../FreeRTOS/Source/tasks.c **** 		else
1812:../../FreeRTOS/Source/tasks.c **** 		{
1813:../../FreeRTOS/Source/tasks.c **** 			xReturn = pdFAIL;
1814:../../FreeRTOS/Source/tasks.c **** 		}
1815:../../FreeRTOS/Source/tasks.c **** 
1816:../../FreeRTOS/Source/tasks.c **** 		return xReturn;
1817:../../FreeRTOS/Source/tasks.c **** 	}
1818:../../FreeRTOS/Source/tasks.c **** 
1819:../../FreeRTOS/Source/tasks.c **** #endif
1820:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1821:../../FreeRTOS/Source/tasks.c **** 
1822:../../FreeRTOS/Source/tasks.c **** void vTaskSwitchContext( void )
1823:../../FreeRTOS/Source/tasks.c **** {
 2143               	.LM204:
 2144               	.LFBB16:
 2145 09c6 CF93      		push r28
 2146 09c8 DF93      		push r29
 2147 09ca 1F92      		push __zero_reg__
 2148 09cc 1F92      		push __zero_reg__
 2149 09ce CDB7      		in r28,__SP_L__
 2150 09d0 DEB7      		in r29,__SP_H__
 2151               	/* prologue: function */
 2152               	/* frame size = 2 */
 2153               	/* stack size = 4 */
 2154               	.L__stack_usage = 4
1824:../../FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 2156               	.LM205:
 2157 09d2 8091 0000 		lds r24,uxSchedulerSuspended
 2158 09d6 8823      		tst r24
 2159 09d8 01F0      		breq .L75
1825:../../FreeRTOS/Source/tasks.c **** 	{
1826:../../FreeRTOS/Source/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
1827:../../FreeRTOS/Source/tasks.c **** 		switch. */
1828:../../FreeRTOS/Source/tasks.c **** 		xMissedYield = pdTRUE;
 2161               	.LM206:
 2162 09da 81E0      		ldi r24,lo8(1)
 2163 09dc 8093 0000 		sts xMissedYield,r24
 2164 09e0 00C0      		rjmp .L74
 2165               	.L75:
1829:../../FreeRTOS/Source/tasks.c **** 	}
1830:../../FreeRTOS/Source/tasks.c **** 	else
1831:../../FreeRTOS/Source/tasks.c **** 	{
1832:../../FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
1833:../../FreeRTOS/Source/tasks.c **** 
1834:../../FreeRTOS/Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
1835:../../FreeRTOS/Source/tasks.c **** 		{
1836:../../FreeRTOS/Source/tasks.c **** 			unsigned long ulTempCounter;
1837:../../FreeRTOS/Source/tasks.c **** 
1838:../../FreeRTOS/Source/tasks.c **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1839:../../FreeRTOS/Source/tasks.c **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTempCounter );
1840:../../FreeRTOS/Source/tasks.c **** 				#else
1841:../../FreeRTOS/Source/tasks.c **** 					ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
1842:../../FreeRTOS/Source/tasks.c **** 				#endif
1843:../../FreeRTOS/Source/tasks.c **** 
1844:../../FreeRTOS/Source/tasks.c **** 				/* Add the amount of time the task has been running to the accumulated
1845:../../FreeRTOS/Source/tasks.c **** 				time so far.  The time the task started running was stored in
1846:../../FreeRTOS/Source/tasks.c **** 				ulTaskSwitchedInTime.  Note that there is no overflow protection here
1847:../../FreeRTOS/Source/tasks.c **** 				so count values are only valid until the timer overflows.  Generally
1848:../../FreeRTOS/Source/tasks.c **** 				this will be about 1 hour assuming a 1uS timer increment. */
1849:../../FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
1850:../../FreeRTOS/Source/tasks.c **** 				ulTaskSwitchedInTime = ulTempCounter;
1851:../../FreeRTOS/Source/tasks.c **** 		}
1852:../../FreeRTOS/Source/tasks.c **** 		#endif
1853:../../FreeRTOS/Source/tasks.c **** 
1854:../../FreeRTOS/Source/tasks.c **** 		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
 2167               	.LM207:
 2168 09e2 8091 0000 		lds r24,pxCurrentTCB
 2169 09e6 9091 0000 		lds r25,pxCurrentTCB+1
 2170 09ea FC01      		movw r30,r24
 2171 09ec 2081      		ld r18,Z
 2172 09ee 3181      		ldd r19,Z+1
 2173 09f0 8091 0000 		lds r24,pxCurrentTCB
 2174 09f4 9091 0000 		lds r25,pxCurrentTCB+1
 2175 09f8 FC01      		movw r30,r24
 2176 09fa 8789      		ldd r24,Z+23
 2177 09fc 908D      		ldd r25,Z+24
 2178 09fe 8217      		cp r24,r18
 2179 0a00 9307      		cpc r25,r19
 2180 0a02 00F0      		brlo .L77
 2182               	.LM208:
 2183 0a04 8091 0000 		lds r24,pxCurrentTCB
 2184 0a08 9091 0000 		lds r25,pxCurrentTCB+1
 2185 0a0c 9C01      		movw r18,r24
 2186 0a0e 275E      		subi r18,-25
 2187 0a10 3F4F      		sbci r19,-1
 2188 0a12 8091 0000 		lds r24,pxCurrentTCB
 2189 0a16 9091 0000 		lds r25,pxCurrentTCB+1
 2190 0a1a B901      		movw r22,r18
 2191 0a1c 0E94 0000 		call vApplicationStackOverflowHook
 2192               	.L77:
1855:../../FreeRTOS/Source/tasks.c **** 		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
1856:../../FreeRTOS/Source/tasks.c **** 
1857:../../FreeRTOS/Source/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
 2194               	.LM209:
 2195 0a20 00C0      		rjmp .L78
 2196               	.L79:
 2198               	.LM210:
 2199 0a22 8091 0000 		lds r24,uxTopReadyPriority
 2200 0a26 8150      		subi r24,lo8(-(-1))
 2201 0a28 8093 0000 		sts uxTopReadyPriority,r24
 2202               	.L78:
 2204               	.LM211:
 2205 0a2c 8091 0000 		lds r24,uxTopReadyPriority
 2206 0a30 282F      		mov r18,r24
 2207 0a32 30E0      		ldi r19,0
 2208 0a34 C901      		movw r24,r18
 2209 0a36 880F      		lsl r24
 2210 0a38 991F      		rol r25
 2211 0a3a 880F      		lsl r24
 2212 0a3c 991F      		rol r25
 2213 0a3e 880F      		lsl r24
 2214 0a40 991F      		rol r25
 2215 0a42 820F      		add r24,r18
 2216 0a44 931F      		adc r25,r19
 2217 0a46 8050      		subi r24,lo8(-(pxReadyTasksLists))
 2218 0a48 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 2219 0a4a FC01      		movw r30,r24
 2220 0a4c 8081      		ld r24,Z
 2221 0a4e 8823      		tst r24
 2222 0a50 01F0      		breq .L79
 2223               	.LBB6:
 2225               	.LM212:
 2226 0a52 8091 0000 		lds r24,uxTopReadyPriority
 2227 0a56 282F      		mov r18,r24
 2228 0a58 30E0      		ldi r19,0
 2229 0a5a C901      		movw r24,r18
 2230 0a5c 880F      		lsl r24
 2231 0a5e 991F      		rol r25
 2232 0a60 880F      		lsl r24
 2233 0a62 991F      		rol r25
 2234 0a64 880F      		lsl r24
 2235 0a66 991F      		rol r25
 2236 0a68 820F      		add r24,r18
 2237 0a6a 931F      		adc r25,r19
 2238 0a6c 8050      		subi r24,lo8(-(pxReadyTasksLists))
 2239 0a6e 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 2240 0a70 9A83      		std Y+2,r25
 2241 0a72 8983      		std Y+1,r24
 2242 0a74 8981      		ldd r24,Y+1
 2243 0a76 9A81      		ldd r25,Y+2
 2244 0a78 FC01      		movw r30,r24
 2245 0a7a 8181      		ldd r24,Z+1
 2246 0a7c 9281      		ldd r25,Z+2
 2247 0a7e FC01      		movw r30,r24
 2248 0a80 2281      		ldd r18,Z+2
 2249 0a82 3381      		ldd r19,Z+3
 2250 0a84 8981      		ldd r24,Y+1
 2251 0a86 9A81      		ldd r25,Y+2
 2252 0a88 FC01      		movw r30,r24
 2253 0a8a 3283      		std Z+2,r19
 2254 0a8c 2183      		std Z+1,r18
 2255 0a8e 8981      		ldd r24,Y+1
 2256 0a90 9A81      		ldd r25,Y+2
 2257 0a92 FC01      		movw r30,r24
 2258 0a94 2181      		ldd r18,Z+1
 2259 0a96 3281      		ldd r19,Z+2
 2260 0a98 8981      		ldd r24,Y+1
 2261 0a9a 9A81      		ldd r25,Y+2
 2262 0a9c 0396      		adiw r24,3
 2263 0a9e 2817      		cp r18,r24
 2264 0aa0 3907      		cpc r19,r25
 2265 0aa2 01F4      		brne .L80
 2267               	.LM213:
 2268 0aa4 8981      		ldd r24,Y+1
 2269 0aa6 9A81      		ldd r25,Y+2
 2270 0aa8 FC01      		movw r30,r24
 2271 0aaa 8181      		ldd r24,Z+1
 2272 0aac 9281      		ldd r25,Z+2
 2273 0aae FC01      		movw r30,r24
 2274 0ab0 2281      		ldd r18,Z+2
 2275 0ab2 3381      		ldd r19,Z+3
 2276 0ab4 8981      		ldd r24,Y+1
 2277 0ab6 9A81      		ldd r25,Y+2
 2278 0ab8 FC01      		movw r30,r24
 2279 0aba 3283      		std Z+2,r19
 2280 0abc 2183      		std Z+1,r18
 2281               	.L80:
 2283               	.LM214:
 2284 0abe 8981      		ldd r24,Y+1
 2285 0ac0 9A81      		ldd r25,Y+2
 2286 0ac2 FC01      		movw r30,r24
 2287 0ac4 8181      		ldd r24,Z+1
 2288 0ac6 9281      		ldd r25,Z+2
 2289 0ac8 FC01      		movw r30,r24
 2290 0aca 8681      		ldd r24,Z+6
 2291 0acc 9781      		ldd r25,Z+7
 2292 0ace 9093 0000 		sts pxCurrentTCB+1,r25
 2293 0ad2 8093 0000 		sts pxCurrentTCB,r24
 2294               	.L74:
 2295               	/* epilogue start */
 2296               	.LBE6:
1858:../../FreeRTOS/Source/tasks.c **** 
1859:../../FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
1860:../../FreeRTOS/Source/tasks.c **** 	}
1861:../../FreeRTOS/Source/tasks.c **** }
 2298               	.LM215:
 2299 0ad6 0F90      		pop __tmp_reg__
 2300 0ad8 0F90      		pop __tmp_reg__
 2301 0ada DF91      		pop r29
 2302 0adc CF91      		pop r28
 2303 0ade 0895      		ret
 2308               	.Lscope16:
 2310               		.stabd	78,0,0
 2314               	.global	vTaskPlaceOnEventList
 2316               	vTaskPlaceOnEventList:
 2317               		.stabd	46,0,0
1862:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1863:../../FreeRTOS/Source/tasks.c **** 
1864:../../FreeRTOS/Source/tasks.c **** void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
1865:../../FreeRTOS/Source/tasks.c **** {
 2319               	.LM216:
 2320               	.LFBB17:
 2321 0ae0 CF93      		push r28
 2322 0ae2 DF93      		push r29
 2323 0ae4 00D0      		rcall .
 2324 0ae6 00D0      		rcall .
 2325 0ae8 CDB7      		in r28,__SP_L__
 2326 0aea DEB7      		in r29,__SP_H__
 2327               	/* prologue: function */
 2328               	/* frame size = 6 */
 2329               	/* stack size = 8 */
 2330               	.L__stack_usage = 8
 2331 0aec 9C83      		std Y+4,r25
 2332 0aee 8B83      		std Y+3,r24
 2333 0af0 7E83      		std Y+6,r23
 2334 0af2 6D83      		std Y+5,r22
1866:../../FreeRTOS/Source/tasks.c **** portTickType xTimeToWake;
1867:../../FreeRTOS/Source/tasks.c **** 
1868:../../FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
1869:../../FreeRTOS/Source/tasks.c **** 
1870:../../FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1871:../../FreeRTOS/Source/tasks.c **** 	SCHEDULER SUSPENDED. */
1872:../../FreeRTOS/Source/tasks.c **** 
1873:../../FreeRTOS/Source/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
1874:../../FreeRTOS/Source/tasks.c **** 	This is placed in the list in priority order so the highest priority task
1875:../../FreeRTOS/Source/tasks.c **** 	is the first to be woken by the event. */
1876:../../FreeRTOS/Source/tasks.c **** 	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 2336               	.LM217:
 2337 0af4 8091 0000 		lds r24,pxCurrentTCB
 2338 0af8 9091 0000 		lds r25,pxCurrentTCB+1
 2339 0afc 9C01      		movw r18,r24
 2340 0afe 245F      		subi r18,-12
 2341 0b00 3F4F      		sbci r19,-1
 2342 0b02 8B81      		ldd r24,Y+3
 2343 0b04 9C81      		ldd r25,Y+4
 2344 0b06 B901      		movw r22,r18
 2345 0b08 0E94 0000 		call vListInsert
1877:../../FreeRTOS/Source/tasks.c **** 
1878:../../FreeRTOS/Source/tasks.c **** 	/* We must remove ourselves from the ready list before adding ourselves
1879:../../FreeRTOS/Source/tasks.c **** 	to the blocked list as the same list item is used for both lists.  We have
1880:../../FreeRTOS/Source/tasks.c **** 	exclusive access to the ready lists as the scheduler is locked. */
1881:../../FreeRTOS/Source/tasks.c **** 	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
 2347               	.LM218:
 2348 0b0c 8091 0000 		lds r24,pxCurrentTCB
 2349 0b10 9091 0000 		lds r25,pxCurrentTCB+1
 2350 0b14 0296      		adiw r24,2
 2351 0b16 0E94 0000 		call uxListRemove
1882:../../FreeRTOS/Source/tasks.c **** 	{
1883:../../FreeRTOS/Source/tasks.c **** 		/* The current task must be in a ready list, so there is no need to
1884:../../FreeRTOS/Source/tasks.c **** 		check, and the port reset macro can be called directly. */
1885:../../FreeRTOS/Source/tasks.c **** 		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
1886:../../FreeRTOS/Source/tasks.c **** 	}
1887:../../FreeRTOS/Source/tasks.c **** 
1888:../../FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
1889:../../FreeRTOS/Source/tasks.c **** 	{
1890:../../FreeRTOS/Source/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
 2353               	.LM219:
 2354 0b1a 8D81      		ldd r24,Y+5
 2355 0b1c 9E81      		ldd r25,Y+6
 2356 0b1e 8F3F      		cpi r24,-1
 2357 0b20 2FEF      		ldi r18,-1
 2358 0b22 9207      		cpc r25,r18
 2359 0b24 01F4      		brne .L82
1891:../../FreeRTOS/Source/tasks.c **** 		{
1892:../../FreeRTOS/Source/tasks.c **** 			/* Add ourselves to the suspended task list instead of a delayed task
1893:../../FreeRTOS/Source/tasks.c **** 			list to ensure we are not woken by a timing event.  We will block
1894:../../FreeRTOS/Source/tasks.c **** 			indefinitely. */
1895:../../FreeRTOS/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListIt
 2361               	.LM220:
 2362 0b26 8091 0000 		lds r24,pxCurrentTCB
 2363 0b2a 9091 0000 		lds r25,pxCurrentTCB+1
 2364 0b2e 0296      		adiw r24,2
 2365 0b30 BC01      		movw r22,r24
 2366 0b32 80E0      		ldi r24,lo8(xSuspendedTaskList)
 2367 0b34 90E0      		ldi r25,hi8(xSuspendedTaskList)
 2368 0b36 0E94 0000 		call vListInsertEnd
 2369 0b3a 00C0      		rjmp .L81
 2370               	.L82:
1896:../../FreeRTOS/Source/tasks.c **** 		}
1897:../../FreeRTOS/Source/tasks.c **** 		else
1898:../../FreeRTOS/Source/tasks.c **** 		{
1899:../../FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1900:../../FreeRTOS/Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1901:../../FreeRTOS/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
 2372               	.LM221:
 2373 0b3c 2091 0000 		lds r18,xTickCount
 2374 0b40 3091 0000 		lds r19,xTickCount+1
 2375 0b44 8D81      		ldd r24,Y+5
 2376 0b46 9E81      		ldd r25,Y+6
 2377 0b48 820F      		add r24,r18
 2378 0b4a 931F      		adc r25,r19
 2379 0b4c 9A83      		std Y+2,r25
 2380 0b4e 8983      		std Y+1,r24
1902:../../FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 2382               	.LM222:
 2383 0b50 8981      		ldd r24,Y+1
 2384 0b52 9A81      		ldd r25,Y+2
 2385 0b54 0E94 0000 		call prvAddCurrentTaskToDelayedList
 2386               	.L81:
 2387               	/* epilogue start */
1903:../../FreeRTOS/Source/tasks.c **** 		}
1904:../../FreeRTOS/Source/tasks.c **** 	}
1905:../../FreeRTOS/Source/tasks.c **** 	#else
1906:../../FreeRTOS/Source/tasks.c **** 	{
1907:../../FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1908:../../FreeRTOS/Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1909:../../FreeRTOS/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1910:../../FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
1911:../../FreeRTOS/Source/tasks.c **** 	}
1912:../../FreeRTOS/Source/tasks.c **** 	#endif
1913:../../FreeRTOS/Source/tasks.c **** }
 2389               	.LM223:
 2390 0b58 2696      		adiw r28,6
 2391 0b5a 0FB6      		in __tmp_reg__,__SREG__
 2392 0b5c F894      		cli
 2393 0b5e DEBF      		out __SP_H__,r29
 2394 0b60 0FBE      		out __SREG__,__tmp_reg__
 2395 0b62 CDBF      		out __SP_L__,r28
 2396 0b64 DF91      		pop r29
 2397 0b66 CF91      		pop r28
 2398 0b68 0895      		ret
 2403               	.Lscope17:
 2405               		.stabd	78,0,0
 2408               	.global	xTaskRemoveFromEventList
 2410               	xTaskRemoveFromEventList:
 2411               		.stabd	46,0,0
1914:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1915:../../FreeRTOS/Source/tasks.c **** 
1916:../../FreeRTOS/Source/tasks.c **** #if configUSE_TIMERS == 1
1917:../../FreeRTOS/Source/tasks.c **** 
1918:../../FreeRTOS/Source/tasks.c **** 	void vTaskPlaceOnEventListRestricted( const xList * const pxEventList, portTickType xTicksToWait )
1919:../../FreeRTOS/Source/tasks.c **** 	{
1920:../../FreeRTOS/Source/tasks.c **** 	portTickType xTimeToWake;
1921:../../FreeRTOS/Source/tasks.c **** 
1922:../../FreeRTOS/Source/tasks.c **** 		configASSERT( pxEventList );
1923:../../FreeRTOS/Source/tasks.c **** 
1924:../../FreeRTOS/Source/tasks.c **** 		/* This function should not be called by application code hence the
1925:../../FreeRTOS/Source/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
1926:../../FreeRTOS/Source/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
1927:../../FreeRTOS/Source/tasks.c **** 		it should be called from a critical section. */
1928:../../FreeRTOS/Source/tasks.c **** 
1929:../../FreeRTOS/Source/tasks.c **** 
1930:../../FreeRTOS/Source/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
1931:../../FreeRTOS/Source/tasks.c **** 		In this case it is assume that this is the only task that is going to
1932:../../FreeRTOS/Source/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
1933:../../FreeRTOS/Source/tasks.c **** 		can be used in place of vListInsert. */
1934:../../FreeRTOS/Source/tasks.c **** 		vListInsertEnd( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
1935:../../FreeRTOS/Source/tasks.c **** 
1936:../../FreeRTOS/Source/tasks.c **** 		/* We must remove this task from the ready list before adding it to the
1937:../../FreeRTOS/Source/tasks.c **** 		blocked list as the same list item is used for both lists.  This
1938:../../FreeRTOS/Source/tasks.c **** 		function is called form a critical section. */
1939:../../FreeRTOS/Source/tasks.c **** 		if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
1940:../../FreeRTOS/Source/tasks.c **** 		{
1941:../../FreeRTOS/Source/tasks.c **** 			/* The current task must be in a ready list, so there is no need to
1942:../../FreeRTOS/Source/tasks.c **** 			check, and the port reset macro can be called directly. */
1943:../../FreeRTOS/Source/tasks.c **** 			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
1944:../../FreeRTOS/Source/tasks.c **** 		}
1945:../../FreeRTOS/Source/tasks.c **** 
1946:../../FreeRTOS/Source/tasks.c **** 		/* Calculate the time at which the task should be woken if the event does
1947:../../FreeRTOS/Source/tasks.c **** 		not occur.  This may overflow but this doesn't matter. */
1948:../../FreeRTOS/Source/tasks.c **** 		xTimeToWake = xTickCount + xTicksToWait;
1949:../../FreeRTOS/Source/tasks.c **** 
1950:../../FreeRTOS/Source/tasks.c **** 		traceTASK_DELAY_UNTIL();
1951:../../FreeRTOS/Source/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTimeToWake );
1952:../../FreeRTOS/Source/tasks.c **** 	}
1953:../../FreeRTOS/Source/tasks.c **** 
1954:../../FreeRTOS/Source/tasks.c **** #endif /* configUSE_TIMERS */
1955:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1956:../../FreeRTOS/Source/tasks.c **** 
1957:../../FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
1958:../../FreeRTOS/Source/tasks.c **** {
 2413               	.LM224:
 2414               	.LFBB18:
 2415 0b6a CF93      		push r28
 2416 0b6c DF93      		push r29
 2417 0b6e 00D0      		rcall .
 2418 0b70 1F92      		push __zero_reg__
 2419 0b72 1F92      		push __zero_reg__
 2420 0b74 CDB7      		in r28,__SP_L__
 2421 0b76 DEB7      		in r29,__SP_H__
 2422               	/* prologue: function */
 2423               	/* frame size = 5 */
 2424               	/* stack size = 7 */
 2425               	.L__stack_usage = 7
 2426 0b78 9D83      		std Y+5,r25
 2427 0b7a 8C83      		std Y+4,r24
1959:../../FreeRTOS/Source/tasks.c **** tskTCB *pxUnblockedTCB;
1960:../../FreeRTOS/Source/tasks.c **** portBASE_TYPE xReturn;
1961:../../FreeRTOS/Source/tasks.c **** 
1962:../../FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1963:../../FreeRTOS/Source/tasks.c **** 	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
1964:../../FreeRTOS/Source/tasks.c **** 
1965:../../FreeRTOS/Source/tasks.c **** 	/* The event list is sorted in priority order, so we can remove the
1966:../../FreeRTOS/Source/tasks.c **** 	first in the list, remove the TCB from the delayed list, and add
1967:../../FreeRTOS/Source/tasks.c **** 	it to the ready list.
1968:../../FreeRTOS/Source/tasks.c **** 
1969:../../FreeRTOS/Source/tasks.c **** 	If an event is for a queue that is locked then this function will never
1970:../../FreeRTOS/Source/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
1971:../../FreeRTOS/Source/tasks.c **** 	means we can always expect exclusive access to the event list here.
1972:../../FreeRTOS/Source/tasks.c **** 
1973:../../FreeRTOS/Source/tasks.c **** 	This function assumes that a check has already been made to ensure that
1974:../../FreeRTOS/Source/tasks.c **** 	pxEventList is not empty. */
1975:../../FreeRTOS/Source/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 2429               	.LM225:
 2430 0b7c 8C81      		ldd r24,Y+4
 2431 0b7e 9D81      		ldd r25,Y+5
 2432 0b80 FC01      		movw r30,r24
 2433 0b82 8581      		ldd r24,Z+5
 2434 0b84 9681      		ldd r25,Z+6
 2435 0b86 FC01      		movw r30,r24
 2436 0b88 8681      		ldd r24,Z+6
 2437 0b8a 9781      		ldd r25,Z+7
 2438 0b8c 9B83      		std Y+3,r25
 2439 0b8e 8A83      		std Y+2,r24
1976:../../FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
1977:../../FreeRTOS/Source/tasks.c **** 	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 2441               	.LM226:
 2442 0b90 8A81      		ldd r24,Y+2
 2443 0b92 9B81      		ldd r25,Y+3
 2444 0b94 0C96      		adiw r24,12
 2445 0b96 0E94 0000 		call uxListRemove
1978:../../FreeRTOS/Source/tasks.c **** 
1979:../../FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 2447               	.LM227:
 2448 0b9a 8091 0000 		lds r24,uxSchedulerSuspended
 2449 0b9e 8823      		tst r24
 2450 0ba0 01F4      		brne .L85
1980:../../FreeRTOS/Source/tasks.c **** 	{
1981:../../FreeRTOS/Source/tasks.c **** 		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 2452               	.LM228:
 2453 0ba2 8A81      		ldd r24,Y+2
 2454 0ba4 9B81      		ldd r25,Y+3
 2455 0ba6 0296      		adiw r24,2
 2456 0ba8 0E94 0000 		call uxListRemove
1982:../../FreeRTOS/Source/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
 2458               	.LM229:
 2459 0bac 8A81      		ldd r24,Y+2
 2460 0bae 9B81      		ldd r25,Y+3
 2461 0bb0 FC01      		movw r30,r24
 2462 0bb2 9689      		ldd r25,Z+22
 2463 0bb4 8091 0000 		lds r24,uxTopReadyPriority
 2464 0bb8 8917      		cp r24,r25
 2465 0bba 00F4      		brsh .L86
 2467               	.LM230:
 2468 0bbc 8A81      		ldd r24,Y+2
 2469 0bbe 9B81      		ldd r25,Y+3
 2470 0bc0 FC01      		movw r30,r24
 2471 0bc2 8689      		ldd r24,Z+22
 2472 0bc4 8093 0000 		sts uxTopReadyPriority,r24
 2473               	.L86:
 2475               	.LM231:
 2476 0bc8 8A81      		ldd r24,Y+2
 2477 0bca 9B81      		ldd r25,Y+3
 2478 0bcc AC01      		movw r20,r24
 2479 0bce 4E5F      		subi r20,-2
 2480 0bd0 5F4F      		sbci r21,-1
 2481 0bd2 8A81      		ldd r24,Y+2
 2482 0bd4 9B81      		ldd r25,Y+3
 2483 0bd6 FC01      		movw r30,r24
 2484 0bd8 8689      		ldd r24,Z+22
 2485 0bda 282F      		mov r18,r24
 2486 0bdc 30E0      		ldi r19,0
 2487 0bde C901      		movw r24,r18
 2488 0be0 880F      		lsl r24
 2489 0be2 991F      		rol r25
 2490 0be4 880F      		lsl r24
 2491 0be6 991F      		rol r25
 2492 0be8 880F      		lsl r24
 2493 0bea 991F      		rol r25
 2494 0bec 820F      		add r24,r18
 2495 0bee 931F      		adc r25,r19
 2496 0bf0 8050      		subi r24,lo8(-(pxReadyTasksLists))
 2497 0bf2 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 2498 0bf4 BA01      		movw r22,r20
 2499 0bf6 0E94 0000 		call vListInsertEnd
 2500 0bfa 00C0      		rjmp .L87
 2501               	.L85:
1983:../../FreeRTOS/Source/tasks.c **** 	}
1984:../../FreeRTOS/Source/tasks.c **** 	else
1985:../../FreeRTOS/Source/tasks.c **** 	{
1986:../../FreeRTOS/Source/tasks.c **** 		/* We cannot access the delayed or ready lists, so will hold this
1987:../../FreeRTOS/Source/tasks.c **** 		task pending until the scheduler is resumed. */
1988:../../FreeRTOS/Source/tasks.c **** 		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 2503               	.LM232:
 2504 0bfc 8A81      		ldd r24,Y+2
 2505 0bfe 9B81      		ldd r25,Y+3
 2506 0c00 0C96      		adiw r24,12
 2507 0c02 BC01      		movw r22,r24
 2508 0c04 80E0      		ldi r24,lo8(xPendingReadyList)
 2509 0c06 90E0      		ldi r25,hi8(xPendingReadyList)
 2510 0c08 0E94 0000 		call vListInsertEnd
 2511               	.L87:
1989:../../FreeRTOS/Source/tasks.c **** 	}
1990:../../FreeRTOS/Source/tasks.c **** 
1991:../../FreeRTOS/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2513               	.LM233:
 2514 0c0c 8A81      		ldd r24,Y+2
 2515 0c0e 9B81      		ldd r25,Y+3
 2516 0c10 FC01      		movw r30,r24
 2517 0c12 2689      		ldd r18,Z+22
 2518 0c14 8091 0000 		lds r24,pxCurrentTCB
 2519 0c18 9091 0000 		lds r25,pxCurrentTCB+1
 2520 0c1c FC01      		movw r30,r24
 2521 0c1e 8689      		ldd r24,Z+22
 2522 0c20 2817      		cp r18,r24
 2523 0c22 00F0      		brlo .L88
1992:../../FreeRTOS/Source/tasks.c **** 	{
1993:../../FreeRTOS/Source/tasks.c **** 		/* Return true if the task removed from the event list has
1994:../../FreeRTOS/Source/tasks.c **** 		a higher priority than the calling task.  This allows
1995:../../FreeRTOS/Source/tasks.c **** 		the calling task to know if it should force a context
1996:../../FreeRTOS/Source/tasks.c **** 		switch now. */
1997:../../FreeRTOS/Source/tasks.c **** 		xReturn = pdTRUE;
 2525               	.LM234:
 2526 0c24 81E0      		ldi r24,lo8(1)
 2527 0c26 8983      		std Y+1,r24
 2528 0c28 00C0      		rjmp .L89
 2529               	.L88:
1998:../../FreeRTOS/Source/tasks.c **** 	}
1999:../../FreeRTOS/Source/tasks.c **** 	else
2000:../../FreeRTOS/Source/tasks.c **** 	{
2001:../../FreeRTOS/Source/tasks.c **** 		xReturn = pdFALSE;
 2531               	.LM235:
 2532 0c2a 1982      		std Y+1,__zero_reg__
 2533               	.L89:
2002:../../FreeRTOS/Source/tasks.c **** 	}
2003:../../FreeRTOS/Source/tasks.c **** 
2004:../../FreeRTOS/Source/tasks.c **** 	return xReturn;
 2535               	.LM236:
 2536 0c2c 8981      		ldd r24,Y+1
 2537               	/* epilogue start */
2005:../../FreeRTOS/Source/tasks.c **** }
 2539               	.LM237:
 2540 0c2e 0F90      		pop __tmp_reg__
 2541 0c30 0F90      		pop __tmp_reg__
 2542 0c32 0F90      		pop __tmp_reg__
 2543 0c34 0F90      		pop __tmp_reg__
 2544 0c36 0F90      		pop __tmp_reg__
 2545 0c38 DF91      		pop r29
 2546 0c3a CF91      		pop r28
 2547 0c3c 0895      		ret
 2553               	.Lscope18:
 2555               		.stabd	78,0,0
 2558               	.global	vTaskSetTimeOutState
 2560               	vTaskSetTimeOutState:
 2561               		.stabd	46,0,0
2006:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2007:../../FreeRTOS/Source/tasks.c **** 
2008:../../FreeRTOS/Source/tasks.c **** void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
2009:../../FreeRTOS/Source/tasks.c **** {
 2563               	.LM238:
 2564               	.LFBB19:
 2565 0c3e CF93      		push r28
 2566 0c40 DF93      		push r29
 2567 0c42 1F92      		push __zero_reg__
 2568 0c44 1F92      		push __zero_reg__
 2569 0c46 CDB7      		in r28,__SP_L__
 2570 0c48 DEB7      		in r29,__SP_H__
 2571               	/* prologue: function */
 2572               	/* frame size = 2 */
 2573               	/* stack size = 4 */
 2574               	.L__stack_usage = 4
 2575 0c4a 9A83      		std Y+2,r25
 2576 0c4c 8983      		std Y+1,r24
2010:../../FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
2011:../../FreeRTOS/Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 2578               	.LM239:
 2579 0c4e 2091 0000 		lds r18,xNumOfOverflows
 2580 0c52 8981      		ldd r24,Y+1
 2581 0c54 9A81      		ldd r25,Y+2
 2582 0c56 FC01      		movw r30,r24
 2583 0c58 2083      		st Z,r18
2012:../../FreeRTOS/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 2585               	.LM240:
 2586 0c5a 2091 0000 		lds r18,xTickCount
 2587 0c5e 3091 0000 		lds r19,xTickCount+1
 2588 0c62 8981      		ldd r24,Y+1
 2589 0c64 9A81      		ldd r25,Y+2
 2590 0c66 FC01      		movw r30,r24
 2591 0c68 3283      		std Z+2,r19
 2592 0c6a 2183      		std Z+1,r18
 2593               	/* epilogue start */
2013:../../FreeRTOS/Source/tasks.c **** }
 2595               	.LM241:
 2596 0c6c 0F90      		pop __tmp_reg__
 2597 0c6e 0F90      		pop __tmp_reg__
 2598 0c70 DF91      		pop r29
 2599 0c72 CF91      		pop r28
 2600 0c74 0895      		ret
 2602               	.Lscope19:
 2604               		.stabd	78,0,0
 2608               	.global	xTaskCheckForTimeOut
 2610               	xTaskCheckForTimeOut:
 2611               		.stabd	46,0,0
2014:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2015:../../FreeRTOS/Source/tasks.c **** 
2016:../../FreeRTOS/Source/tasks.c **** portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToW
2017:../../FreeRTOS/Source/tasks.c **** {
 2613               	.LM242:
 2614               	.LFBB20:
 2615 0c76 CF93      		push r28
 2616 0c78 DF93      		push r29
 2617 0c7a 00D0      		rcall .
 2618 0c7c 1F92      		push __zero_reg__
 2619 0c7e 1F92      		push __zero_reg__
 2620 0c80 CDB7      		in r28,__SP_L__
 2621 0c82 DEB7      		in r29,__SP_H__
 2622               	/* prologue: function */
 2623               	/* frame size = 5 */
 2624               	/* stack size = 7 */
 2625               	.L__stack_usage = 7
 2626 0c84 9B83      		std Y+3,r25
 2627 0c86 8A83      		std Y+2,r24
 2628 0c88 7D83      		std Y+5,r23
 2629 0c8a 6C83      		std Y+4,r22
2018:../../FreeRTOS/Source/tasks.c **** portBASE_TYPE xReturn;
2019:../../FreeRTOS/Source/tasks.c **** 
2020:../../FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
2021:../../FreeRTOS/Source/tasks.c **** 	configASSERT( pxTicksToWait );
2022:../../FreeRTOS/Source/tasks.c **** 
2023:../../FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
 2631               	.LM243:
 2632               	/* #APP */
 2633               	 ;  2023 "../../FreeRTOS/Source/tasks.c" 1
 2634 0c8c 0FB6      		in		__tmp_reg__, __SREG__
 2635               	 ;  0 "" 2
 2636               	 ;  2023 "../../FreeRTOS/Source/tasks.c" 1
 2637 0c8e F894      		cli
 2638               	 ;  0 "" 2
 2639               	 ;  2023 "../../FreeRTOS/Source/tasks.c" 1
 2640 0c90 0F92      		push	__tmp_reg__
 2641               	 ;  0 "" 2
2024:../../FreeRTOS/Source/tasks.c **** 	{
2025:../../FreeRTOS/Source/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
2026:../../FreeRTOS/Source/tasks.c **** 			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
2027:../../FreeRTOS/Source/tasks.c **** 			the maximum block time then the task should block indefinitely, and
2028:../../FreeRTOS/Source/tasks.c **** 			therefore never time out. */
2029:../../FreeRTOS/Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
 2643               	.LM244:
 2644               	/* #NOAPP */
 2645 0c92 8C81      		ldd r24,Y+4
 2646 0c94 9D81      		ldd r25,Y+5
 2647 0c96 FC01      		movw r30,r24
 2648 0c98 8081      		ld r24,Z
 2649 0c9a 9181      		ldd r25,Z+1
 2650 0c9c 8F3F      		cpi r24,-1
 2651 0c9e FFEF      		ldi r31,-1
 2652 0ca0 9F07      		cpc r25,r31
 2653 0ca2 01F4      		brne .L93
2030:../../FreeRTOS/Source/tasks.c **** 			{
2031:../../FreeRTOS/Source/tasks.c **** 				xReturn = pdFALSE;
 2655               	.LM245:
 2656 0ca4 1982      		std Y+1,__zero_reg__
 2657 0ca6 00C0      		rjmp .L94
 2658               	.L93:
2032:../../FreeRTOS/Source/tasks.c **** 			}
2033:../../FreeRTOS/Source/tasks.c **** 			else /* We are not blocking indefinitely, perform the checks below. */
2034:../../FreeRTOS/Source/tasks.c **** 		#endif
2035:../../FreeRTOS/Source/tasks.c **** 
2036:../../FreeRTOS/Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
 2660               	.LM246:
 2661 0ca8 8A81      		ldd r24,Y+2
 2662 0caa 9B81      		ldd r25,Y+3
 2663 0cac FC01      		movw r30,r24
 2664 0cae 9081      		ld r25,Z
 2665 0cb0 8091 0000 		lds r24,xNumOfOverflows
 2666 0cb4 9817      		cp r25,r24
 2667 0cb6 01F0      		breq .L95
 2669               	.LM247:
 2670 0cb8 8A81      		ldd r24,Y+2
 2671 0cba 9B81      		ldd r25,Y+3
 2672 0cbc FC01      		movw r30,r24
 2673 0cbe 2181      		ldd r18,Z+1
 2674 0cc0 3281      		ldd r19,Z+2
 2675 0cc2 8091 0000 		lds r24,xTickCount
 2676 0cc6 9091 0000 		lds r25,xTickCount+1
 2677 0cca 8217      		cp r24,r18
 2678 0ccc 9307      		cpc r25,r19
 2679 0cce 00F0      		brlo .L95
2037:../../FreeRTOS/Source/tasks.c **** 		{
2038:../../FreeRTOS/Source/tasks.c **** 			/* The tick count is greater than the time at which vTaskSetTimeout()
2039:../../FreeRTOS/Source/tasks.c **** 			was called, but has also overflowed since vTaskSetTimeOut() was called.
2040:../../FreeRTOS/Source/tasks.c **** 			It must have wrapped all the way around and gone past us again. This
2041:../../FreeRTOS/Source/tasks.c **** 			passed since vTaskSetTimeout() was called. */
2042:../../FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
 2681               	.LM248:
 2682 0cd0 81E0      		ldi r24,lo8(1)
 2683 0cd2 8983      		std Y+1,r24
 2684 0cd4 00C0      		rjmp .L94
 2685               	.L95:
2043:../../FreeRTOS/Source/tasks.c **** 		}
2044:../../FreeRTOS/Source/tasks.c **** 		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEn
 2687               	.LM249:
 2688 0cd6 2091 0000 		lds r18,xTickCount
 2689 0cda 3091 0000 		lds r19,xTickCount+1
 2690 0cde 8A81      		ldd r24,Y+2
 2691 0ce0 9B81      		ldd r25,Y+3
 2692 0ce2 FC01      		movw r30,r24
 2693 0ce4 8181      		ldd r24,Z+1
 2694 0ce6 9281      		ldd r25,Z+2
 2695 0ce8 281B      		sub r18,r24
 2696 0cea 390B      		sbc r19,r25
 2697 0cec 8C81      		ldd r24,Y+4
 2698 0cee 9D81      		ldd r25,Y+5
 2699 0cf0 FC01      		movw r30,r24
 2700 0cf2 8081      		ld r24,Z
 2701 0cf4 9181      		ldd r25,Z+1
 2702 0cf6 2817      		cp r18,r24
 2703 0cf8 3907      		cpc r19,r25
 2704 0cfa 00F4      		brsh .L96
2045:../../FreeRTOS/Source/tasks.c **** 		{
2046:../../FreeRTOS/Source/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
2047:../../FreeRTOS/Source/tasks.c **** 			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
 2706               	.LM250:
 2707 0cfc 2091 0000 		lds r18,xTickCount
 2708 0d00 3091 0000 		lds r19,xTickCount+1
 2709 0d04 8A81      		ldd r24,Y+2
 2710 0d06 9B81      		ldd r25,Y+3
 2711 0d08 FC01      		movw r30,r24
 2712 0d0a 8181      		ldd r24,Z+1
 2713 0d0c 9281      		ldd r25,Z+2
 2714 0d0e A901      		movw r20,r18
 2715 0d10 481B      		sub r20,r24
 2716 0d12 590B      		sbc r21,r25
 2717 0d14 CA01      		movw r24,r20
 2718 0d16 2C81      		ldd r18,Y+4
 2719 0d18 3D81      		ldd r19,Y+5
 2720 0d1a F901      		movw r30,r18
 2721 0d1c 2081      		ld r18,Z
 2722 0d1e 3181      		ldd r19,Z+1
 2723 0d20 281B      		sub r18,r24
 2724 0d22 390B      		sbc r19,r25
 2725 0d24 8C81      		ldd r24,Y+4
 2726 0d26 9D81      		ldd r25,Y+5
 2727 0d28 FC01      		movw r30,r24
 2728 0d2a 3183      		std Z+1,r19
 2729 0d2c 2083      		st Z,r18
2048:../../FreeRTOS/Source/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 2731               	.LM251:
 2732 0d2e 8A81      		ldd r24,Y+2
 2733 0d30 9B81      		ldd r25,Y+3
 2734 0d32 0E94 0000 		call vTaskSetTimeOutState
2049:../../FreeRTOS/Source/tasks.c **** 			xReturn = pdFALSE;
 2736               	.LM252:
 2737 0d36 1982      		std Y+1,__zero_reg__
 2738 0d38 00C0      		rjmp .L94
 2739               	.L96:
2050:../../FreeRTOS/Source/tasks.c **** 		}
2051:../../FreeRTOS/Source/tasks.c **** 		else
2052:../../FreeRTOS/Source/tasks.c **** 		{
2053:../../FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
 2741               	.LM253:
 2742 0d3a 81E0      		ldi r24,lo8(1)
 2743 0d3c 8983      		std Y+1,r24
 2744               	.L94:
2054:../../FreeRTOS/Source/tasks.c **** 		}
2055:../../FreeRTOS/Source/tasks.c **** 	}
2056:../../FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
 2746               	.LM254:
 2747               	/* #APP */
 2748               	 ;  2056 "../../FreeRTOS/Source/tasks.c" 1
 2749 0d3e 0F90      		pop		__tmp_reg__
 2750               	 ;  0 "" 2
 2751               	 ;  2056 "../../FreeRTOS/Source/tasks.c" 1
 2752 0d40 0FBE      		out		__SREG__, __tmp_reg__
 2753               	 ;  0 "" 2
2057:../../FreeRTOS/Source/tasks.c **** 
2058:../../FreeRTOS/Source/tasks.c **** 	return xReturn;
 2755               	.LM255:
 2756               	/* #NOAPP */
 2757 0d42 8981      		ldd r24,Y+1
 2758               	/* epilogue start */
2059:../../FreeRTOS/Source/tasks.c **** }
 2760               	.LM256:
 2761 0d44 0F90      		pop __tmp_reg__
 2762 0d46 0F90      		pop __tmp_reg__
 2763 0d48 0F90      		pop __tmp_reg__
 2764 0d4a 0F90      		pop __tmp_reg__
 2765 0d4c 0F90      		pop __tmp_reg__
 2766 0d4e DF91      		pop r29
 2767 0d50 CF91      		pop r28
 2768 0d52 0895      		ret
 2773               	.Lscope20:
 2775               		.stabd	78,0,0
 2777               	.global	vTaskMissedYield
 2779               	vTaskMissedYield:
 2780               		.stabd	46,0,0
2060:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2061:../../FreeRTOS/Source/tasks.c **** 
2062:../../FreeRTOS/Source/tasks.c **** void vTaskMissedYield( void )
2063:../../FreeRTOS/Source/tasks.c **** {
 2782               	.LM257:
 2783               	.LFBB21:
 2784 0d54 CF93      		push r28
 2785 0d56 DF93      		push r29
 2786 0d58 CDB7      		in r28,__SP_L__
 2787 0d5a DEB7      		in r29,__SP_H__
 2788               	/* prologue: function */
 2789               	/* frame size = 0 */
 2790               	/* stack size = 2 */
 2791               	.L__stack_usage = 2
2064:../../FreeRTOS/Source/tasks.c **** 	xMissedYield = pdTRUE;
 2793               	.LM258:
 2794 0d5c 81E0      		ldi r24,lo8(1)
 2795 0d5e 8093 0000 		sts xMissedYield,r24
 2796               	/* epilogue start */
2065:../../FreeRTOS/Source/tasks.c **** }
 2798               	.LM259:
 2799 0d62 DF91      		pop r29
 2800 0d64 CF91      		pop r28
 2801 0d66 0895      		ret
 2803               	.Lscope21:
 2805               		.stabd	78,0,0
 2809               	prvIdleTask:
 2810               		.stabd	46,0,0
2066:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2067:../../FreeRTOS/Source/tasks.c **** 
2068:../../FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2069:../../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetTaskNumber( xTaskHandle xTask )
2070:../../FreeRTOS/Source/tasks.c **** 	{
2071:../../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
2072:../../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
2073:../../FreeRTOS/Source/tasks.c **** 
2074:../../FreeRTOS/Source/tasks.c **** 		if( xTask != NULL )
2075:../../FreeRTOS/Source/tasks.c **** 		{
2076:../../FreeRTOS/Source/tasks.c **** 			pxTCB = ( tskTCB * ) xTask;
2077:../../FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxTaskNumber;
2078:../../FreeRTOS/Source/tasks.c **** 		}
2079:../../FreeRTOS/Source/tasks.c **** 		else
2080:../../FreeRTOS/Source/tasks.c **** 		{
2081:../../FreeRTOS/Source/tasks.c **** 			uxReturn = 0U;
2082:../../FreeRTOS/Source/tasks.c **** 		}
2083:../../FreeRTOS/Source/tasks.c **** 
2084:../../FreeRTOS/Source/tasks.c **** 		return uxReturn;
2085:../../FreeRTOS/Source/tasks.c **** 	}
2086:../../FreeRTOS/Source/tasks.c **** #endif
2087:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2088:../../FreeRTOS/Source/tasks.c **** 
2089:../../FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2090:../../FreeRTOS/Source/tasks.c **** 	void vTaskSetTaskNumber( xTaskHandle xTask, unsigned portBASE_TYPE uxHandle )
2091:../../FreeRTOS/Source/tasks.c **** 	{
2092:../../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
2093:../../FreeRTOS/Source/tasks.c **** 
2094:../../FreeRTOS/Source/tasks.c **** 		if( xTask != NULL )
2095:../../FreeRTOS/Source/tasks.c **** 		{
2096:../../FreeRTOS/Source/tasks.c **** 			pxTCB = ( tskTCB * ) xTask;
2097:../../FreeRTOS/Source/tasks.c **** 			pxTCB->uxTaskNumber = uxHandle;
2098:../../FreeRTOS/Source/tasks.c **** 		}
2099:../../FreeRTOS/Source/tasks.c **** 	}
2100:../../FreeRTOS/Source/tasks.c **** #endif
2101:../../FreeRTOS/Source/tasks.c **** 
2102:../../FreeRTOS/Source/tasks.c **** 
2103:../../FreeRTOS/Source/tasks.c **** /*
2104:../../FreeRTOS/Source/tasks.c ****  * -----------------------------------------------------------
2105:../../FreeRTOS/Source/tasks.c ****  * The Idle task.
2106:../../FreeRTOS/Source/tasks.c ****  * ----------------------------------------------------------
2107:../../FreeRTOS/Source/tasks.c ****  *
2108:../../FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
2109:../../FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
2110:../../FreeRTOS/Source/tasks.c ****  *
2111:../../FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
2112:../../FreeRTOS/Source/tasks.c ****  *
2113:../../FreeRTOS/Source/tasks.c ****  */
2114:../../FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
2115:../../FreeRTOS/Source/tasks.c **** {
 2812               	.LM260:
 2813               	.LFBB22:
 2814 0d68 CF93      		push r28
 2815 0d6a DF93      		push r29
 2816 0d6c 1F92      		push __zero_reg__
 2817 0d6e 1F92      		push __zero_reg__
 2818 0d70 CDB7      		in r28,__SP_L__
 2819 0d72 DEB7      		in r29,__SP_H__
 2820               	/* prologue: function */
 2821               	/* frame size = 2 */
 2822               	/* stack size = 4 */
 2823               	.L__stack_usage = 4
 2824 0d74 9A83      		std Y+2,r25
 2825 0d76 8983      		std Y+1,r24
 2826               	.L101:
2116:../../FreeRTOS/Source/tasks.c **** 	/* Stop warnings. */
2117:../../FreeRTOS/Source/tasks.c **** 	( void ) pvParameters;
2118:../../FreeRTOS/Source/tasks.c **** 
2119:../../FreeRTOS/Source/tasks.c **** 	for( ;; )
2120:../../FreeRTOS/Source/tasks.c **** 	{
2121:../../FreeRTOS/Source/tasks.c **** 		/* See if any tasks have been deleted. */
2122:../../FreeRTOS/Source/tasks.c **** 		prvCheckTasksWaitingTermination();
 2828               	.LM261:
 2829 0d78 0E94 0000 		call prvCheckTasksWaitingTermination
2123:../../FreeRTOS/Source/tasks.c **** 
2124:../../FreeRTOS/Source/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
2125:../../FreeRTOS/Source/tasks.c **** 		{
2126:../../FreeRTOS/Source/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
2127:../../FreeRTOS/Source/tasks.c **** 			see if any other task has become available.  If we are using
2128:../../FreeRTOS/Source/tasks.c **** 			preemption we don't need to do this as any task becoming available
2129:../../FreeRTOS/Source/tasks.c **** 			will automatically get the processor anyway. */
2130:../../FreeRTOS/Source/tasks.c **** 			taskYIELD();
2131:../../FreeRTOS/Source/tasks.c **** 		}
2132:../../FreeRTOS/Source/tasks.c **** 		#endif
2133:../../FreeRTOS/Source/tasks.c **** 
2134:../../FreeRTOS/Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
2135:../../FreeRTOS/Source/tasks.c **** 		{
2136:../../FreeRTOS/Source/tasks.c **** 			/* When using preemption tasks of equal priority will be
2137:../../FreeRTOS/Source/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
2138:../../FreeRTOS/Source/tasks.c **** 			to run then the idle task should yield before the end of the
2139:../../FreeRTOS/Source/tasks.c **** 			timeslice.
2140:../../FreeRTOS/Source/tasks.c **** 
2141:../../FreeRTOS/Source/tasks.c **** 			A critical region is not required here as we are just reading from
2142:../../FreeRTOS/Source/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
2143:../../FreeRTOS/Source/tasks.c **** 			the ready list at the idle priority contains more than one task
2144:../../FreeRTOS/Source/tasks.c **** 			then a task other than the idle task is ready to execute. */
2145:../../FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_
 2831               	.LM262:
 2832 0d7c 8091 0000 		lds r24,pxReadyTasksLists
 2833 0d80 8230      		cpi r24,lo8(2)
 2834 0d82 00F0      		brlo .L100
2146:../../FreeRTOS/Source/tasks.c **** 			{
2147:../../FreeRTOS/Source/tasks.c **** 				taskYIELD();
 2836               	.LM263:
 2837 0d84 0E94 0000 		call vPortYield
 2838               	.L100:
2148:../../FreeRTOS/Source/tasks.c **** 			}
2149:../../FreeRTOS/Source/tasks.c **** 		}
2150:../../FreeRTOS/Source/tasks.c **** 		#endif
2151:../../FreeRTOS/Source/tasks.c **** 
2152:../../FreeRTOS/Source/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
2153:../../FreeRTOS/Source/tasks.c **** 		{
2154:../../FreeRTOS/Source/tasks.c **** 			extern void vApplicationIdleHook( void );
2155:../../FreeRTOS/Source/tasks.c **** 
2156:../../FreeRTOS/Source/tasks.c **** 			/* Call the user defined function from within the idle task.  This
2157:../../FreeRTOS/Source/tasks.c **** 			allows the application designer to add background functionality
2158:../../FreeRTOS/Source/tasks.c **** 			without the overhead of a separate task.
2159:../../FreeRTOS/Source/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
2160:../../FreeRTOS/Source/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
2161:../../FreeRTOS/Source/tasks.c **** 			vApplicationIdleHook();
2162:../../FreeRTOS/Source/tasks.c **** 		}
2163:../../FreeRTOS/Source/tasks.c **** 		#endif
2164:../../FreeRTOS/Source/tasks.c **** 
2165:../../FreeRTOS/Source/tasks.c **** 		/* This conditional compilation should use inequality to 0, not equality
2166:../../FreeRTOS/Source/tasks.c **** 		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
2167:../../FreeRTOS/Source/tasks.c **** 		user defined low power mode	implementations require
2168:../../FreeRTOS/Source/tasks.c **** 		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
2169:../../FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICKLESS_IDLE != 0 )
2170:../../FreeRTOS/Source/tasks.c **** 		{
2171:../../FreeRTOS/Source/tasks.c **** 		portTickType xExpectedIdleTime;
2172:../../FreeRTOS/Source/tasks.c **** 		/* If the expected idle time is 1 then the idle time would end at
2173:../../FreeRTOS/Source/tasks.c **** 		the end of the current time slice.  The idle time must be at least
2174:../../FreeRTOS/Source/tasks.c **** 		2 to ensure any pended ticks between this point and the tick being
2175:../../FreeRTOS/Source/tasks.c **** 		stopped can be legitimately stepped over when the tick suppression
2176:../../FreeRTOS/Source/tasks.c **** 		routines returns. */
2177:../../FreeRTOS/Source/tasks.c **** 		const portTickType xMinimumExpectedIdleTime = ( portTickType ) 2;
2178:../../FreeRTOS/Source/tasks.c **** 
2179:../../FreeRTOS/Source/tasks.c **** 			/* It is not desirable to suspend then resume the scheduler on
2180:../../FreeRTOS/Source/tasks.c **** 			each iteration of the idle task.  Therefore, a preliminary
2181:../../FreeRTOS/Source/tasks.c **** 			test of the expected idle time is performed without the
2182:../../FreeRTOS/Source/tasks.c **** 			scheduler suspended.  The result here is not necessarily
2183:../../FreeRTOS/Source/tasks.c **** 			valid. */
2184:../../FreeRTOS/Source/tasks.c **** 			xExpectedIdleTime = prvGetExpectedIdleTime();
2185:../../FreeRTOS/Source/tasks.c **** 
2186:../../FreeRTOS/Source/tasks.c **** 			if( xExpectedIdleTime >= xMinimumExpectedIdleTime )
2187:../../FreeRTOS/Source/tasks.c **** 			{
2188:../../FreeRTOS/Source/tasks.c **** 				vTaskSuspendAll();
2189:../../FreeRTOS/Source/tasks.c **** 				{
2190:../../FreeRTOS/Source/tasks.c **** 					/* Now the scheduler is suspended, the expected idle
2191:../../FreeRTOS/Source/tasks.c **** 					time can be sampled again, and this time its value can
2192:../../FreeRTOS/Source/tasks.c **** 					be used. */
2193:../../FreeRTOS/Source/tasks.c **** 					configASSERT( xNextTaskUnblockTime >= xTickCount );
2194:../../FreeRTOS/Source/tasks.c **** 					xExpectedIdleTime = prvGetExpectedIdleTime();
2195:../../FreeRTOS/Source/tasks.c **** 
2196:../../FreeRTOS/Source/tasks.c **** 					if( xExpectedIdleTime >= xMinimumExpectedIdleTime )
2197:../../FreeRTOS/Source/tasks.c **** 					{
2198:../../FreeRTOS/Source/tasks.c **** 						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
2199:../../FreeRTOS/Source/tasks.c **** 					}
2200:../../FreeRTOS/Source/tasks.c **** 				}
2201:../../FreeRTOS/Source/tasks.c **** 				xTaskResumeAll();
2202:../../FreeRTOS/Source/tasks.c **** 			}
2203:../../FreeRTOS/Source/tasks.c **** 		}
2204:../../FreeRTOS/Source/tasks.c **** 		#endif
2205:../../FreeRTOS/Source/tasks.c **** 	}
 2840               	.LM264:
 2841 0d88 00C0      		rjmp .L101
 2843               	.Lscope22:
 2845               		.stabd	78,0,0
 2853               	prvInitialiseTCBVariables:
 2854               		.stabd	46,0,0
2206:../../FreeRTOS/Source/tasks.c **** } /*lint !e715 pvParameters is not accessed but all task functions require the same prototype. */
2207:../../FreeRTOS/Source/tasks.c **** 
2208:../../FreeRTOS/Source/tasks.c **** 
2209:../../FreeRTOS/Source/tasks.c **** 
2210:../../FreeRTOS/Source/tasks.c **** 
2211:../../FreeRTOS/Source/tasks.c **** 
2212:../../FreeRTOS/Source/tasks.c **** 
2213:../../FreeRTOS/Source/tasks.c **** 
2214:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
2215:../../FreeRTOS/Source/tasks.c ****  * File private functions documented at the top of the file.
2216:../../FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
2217:../../FreeRTOS/Source/tasks.c **** 
2218:../../FreeRTOS/Source/tasks.c **** 
2219:../../FreeRTOS/Source/tasks.c **** 
2220:../../FreeRTOS/Source/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
2221:../../FreeRTOS/Source/tasks.c **** {
 2856               	.LM265:
 2857               	.LFBB23:
 2858 0d8a 0F93      		push r16
 2859 0d8c 1F93      		push r17
 2860 0d8e CF93      		push r28
 2861 0d90 DF93      		push r29
 2862 0d92 CDB7      		in r28,__SP_L__
 2863 0d94 DEB7      		in r29,__SP_H__
 2864 0d96 2997      		sbiw r28,9
 2865 0d98 0FB6      		in __tmp_reg__,__SREG__
 2866 0d9a F894      		cli
 2867 0d9c DEBF      		out __SP_H__,r29
 2868 0d9e 0FBE      		out __SREG__,__tmp_reg__
 2869 0da0 CDBF      		out __SP_L__,r28
 2870               	/* prologue: function */
 2871               	/* frame size = 9 */
 2872               	/* stack size = 13 */
 2873               	.L__stack_usage = 13
 2874 0da2 9A83      		std Y+2,r25
 2875 0da4 8983      		std Y+1,r24
 2876 0da6 7C83      		std Y+4,r23
 2877 0da8 6B83      		std Y+3,r22
 2878 0daa 4D83      		std Y+5,r20
 2879 0dac 3F83      		std Y+7,r19
 2880 0dae 2E83      		std Y+6,r18
 2881 0db0 1987      		std Y+9,r17
 2882 0db2 0887      		std Y+8,r16
2222:../../FreeRTOS/Source/tasks.c **** 	/* Store the function name in the TCB. */
2223:../../FreeRTOS/Source/tasks.c **** 	#if configMAX_TASK_NAME_LEN > 1
2224:../../FreeRTOS/Source/tasks.c **** 	{
2225:../../FreeRTOS/Source/tasks.c **** 		/* Don't bring strncpy into the build unnecessarily. */
2226:../../FreeRTOS/Source/tasks.c **** 		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK
 2884               	.LM266:
 2885 0db4 8981      		ldd r24,Y+1
 2886 0db6 9A81      		ldd r25,Y+2
 2887 0db8 4996      		adiw r24,25
 2888 0dba 2B81      		ldd r18,Y+3
 2889 0dbc 3C81      		ldd r19,Y+4
 2890 0dbe 40E1      		ldi r20,lo8(16)
 2891 0dc0 50E0      		ldi r21,0
 2892 0dc2 B901      		movw r22,r18
 2893 0dc4 0E94 0000 		call strncpy
2227:../../FreeRTOS/Source/tasks.c **** 	}
2228:../../FreeRTOS/Source/tasks.c **** 	#endif
2229:../../FreeRTOS/Source/tasks.c **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed 
 2895               	.LM267:
 2896 0dc8 8981      		ldd r24,Y+1
 2897 0dca 9A81      		ldd r25,Y+2
 2898 0dcc FC01      		movw r30,r24
 2899 0dce 10A6      		std Z+40,__zero_reg__
2230:../../FreeRTOS/Source/tasks.c **** 
2231:../../FreeRTOS/Source/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
2232:../../FreeRTOS/Source/tasks.c **** 	remove the privilege bit if one is present. */
2233:../../FreeRTOS/Source/tasks.c **** 	if( uxPriority >= configMAX_PRIORITIES )
 2901               	.LM268:
 2902 0dd0 8D81      		ldd r24,Y+5
 2903 0dd2 8430      		cpi r24,lo8(4)
 2904 0dd4 00F0      		brlo .L103
2234:../../FreeRTOS/Source/tasks.c **** 	{
2235:../../FreeRTOS/Source/tasks.c **** 		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 2906               	.LM269:
 2907 0dd6 83E0      		ldi r24,lo8(3)
 2908 0dd8 8D83      		std Y+5,r24
 2909               	.L103:
2236:../../FreeRTOS/Source/tasks.c **** 	}
2237:../../FreeRTOS/Source/tasks.c **** 
2238:../../FreeRTOS/Source/tasks.c **** 	pxTCB->uxPriority = uxPriority;
 2911               	.LM270:
 2912 0dda 8981      		ldd r24,Y+1
 2913 0ddc 9A81      		ldd r25,Y+2
 2914 0dde 2D81      		ldd r18,Y+5
 2915 0de0 FC01      		movw r30,r24
 2916 0de2 268B      		std Z+22,r18
2239:../../FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
2240:../../FreeRTOS/Source/tasks.c **** 	{
2241:../../FreeRTOS/Source/tasks.c **** 		pxTCB->uxBasePriority = uxPriority;
 2918               	.LM271:
 2919 0de4 8981      		ldd r24,Y+1
 2920 0de6 9A81      		ldd r25,Y+2
 2921 0de8 2D81      		ldd r18,Y+5
 2922 0dea FC01      		movw r30,r24
 2923 0dec 21A7      		std Z+41,r18
2242:../../FreeRTOS/Source/tasks.c **** 	}
2243:../../FreeRTOS/Source/tasks.c **** 	#endif
2244:../../FreeRTOS/Source/tasks.c **** 
2245:../../FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 2925               	.LM272:
 2926 0dee 8981      		ldd r24,Y+1
 2927 0df0 9A81      		ldd r25,Y+2
 2928 0df2 0296      		adiw r24,2
 2929 0df4 0E94 0000 		call vListInitialiseItem
2246:../../FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 2931               	.LM273:
 2932 0df8 8981      		ldd r24,Y+1
 2933 0dfa 9A81      		ldd r25,Y+2
 2934 0dfc 0C96      		adiw r24,12
 2935 0dfe 0E94 0000 		call vListInitialiseItem
2247:../../FreeRTOS/Source/tasks.c **** 
2248:../../FreeRTOS/Source/tasks.c **** 	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
2249:../../FreeRTOS/Source/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
2250:../../FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 2937               	.LM274:
 2938 0e02 8981      		ldd r24,Y+1
 2939 0e04 9A81      		ldd r25,Y+2
 2940 0e06 2981      		ldd r18,Y+1
 2941 0e08 3A81      		ldd r19,Y+2
 2942 0e0a FC01      		movw r30,r24
 2943 0e0c 3187      		std Z+9,r19
 2944 0e0e 2087      		std Z+8,r18
2251:../../FreeRTOS/Source/tasks.c **** 
2252:../../FreeRTOS/Source/tasks.c **** 	/* Event lists are always in priority order. */
2253:../../FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPri
 2946               	.LM275:
 2947 0e10 8D81      		ldd r24,Y+5
 2948 0e12 882F      		mov r24,r24
 2949 0e14 90E0      		ldi r25,0
 2950 0e16 24E0      		ldi r18,lo8(4)
 2951 0e18 30E0      		ldi r19,0
 2952 0e1a 281B      		sub r18,r24
 2953 0e1c 390B      		sbc r19,r25
 2954 0e1e 8981      		ldd r24,Y+1
 2955 0e20 9A81      		ldd r25,Y+2
 2956 0e22 FC01      		movw r30,r24
 2957 0e24 3587      		std Z+13,r19
 2958 0e26 2487      		std Z+12,r18
2254:../../FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 2960               	.LM276:
 2961 0e28 8981      		ldd r24,Y+1
 2962 0e2a 9A81      		ldd r25,Y+2
 2963 0e2c 2981      		ldd r18,Y+1
 2964 0e2e 3A81      		ldd r19,Y+2
 2965 0e30 FC01      		movw r30,r24
 2966 0e32 338B      		std Z+19,r19
 2967 0e34 228B      		std Z+18,r18
 2968               	/* epilogue start */
2255:../../FreeRTOS/Source/tasks.c **** 
2256:../../FreeRTOS/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
2257:../../FreeRTOS/Source/tasks.c **** 	{
2258:../../FreeRTOS/Source/tasks.c **** 		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0U;
2259:../../FreeRTOS/Source/tasks.c **** 	}
2260:../../FreeRTOS/Source/tasks.c **** 	#endif
2261:../../FreeRTOS/Source/tasks.c **** 
2262:../../FreeRTOS/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
2263:../../FreeRTOS/Source/tasks.c **** 	{
2264:../../FreeRTOS/Source/tasks.c **** 		pxTCB->pxTaskTag = NULL;
2265:../../FreeRTOS/Source/tasks.c **** 	}
2266:../../FreeRTOS/Source/tasks.c **** 	#endif
2267:../../FreeRTOS/Source/tasks.c **** 
2268:../../FreeRTOS/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
2269:../../FreeRTOS/Source/tasks.c **** 	{
2270:../../FreeRTOS/Source/tasks.c **** 		pxTCB->ulRunTimeCounter = 0UL;
2271:../../FreeRTOS/Source/tasks.c **** 	}
2272:../../FreeRTOS/Source/tasks.c **** 	#endif
2273:../../FreeRTOS/Source/tasks.c **** 
2274:../../FreeRTOS/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
2275:../../FreeRTOS/Source/tasks.c **** 	{
2276:../../FreeRTOS/Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
2277:../../FreeRTOS/Source/tasks.c **** 	}
2278:../../FreeRTOS/Source/tasks.c **** 	#else
2279:../../FreeRTOS/Source/tasks.c **** 	{
2280:../../FreeRTOS/Source/tasks.c **** 		( void ) xRegions;
2281:../../FreeRTOS/Source/tasks.c **** 		( void ) usStackDepth;
2282:../../FreeRTOS/Source/tasks.c **** 	}
2283:../../FreeRTOS/Source/tasks.c **** 	#endif
2284:../../FreeRTOS/Source/tasks.c **** }
 2970               	.LM277:
 2971 0e36 2996      		adiw r28,9
 2972 0e38 0FB6      		in __tmp_reg__,__SREG__
 2973 0e3a F894      		cli
 2974 0e3c DEBF      		out __SP_H__,r29
 2975 0e3e 0FBE      		out __SREG__,__tmp_reg__
 2976 0e40 CDBF      		out __SP_L__,r28
 2977 0e42 DF91      		pop r29
 2978 0e44 CF91      		pop r28
 2979 0e46 1F91      		pop r17
 2980 0e48 0F91      		pop r16
 2981 0e4a 0895      		ret
 2983               	.Lscope23:
 2985               		.stabd	78,0,0
 2988               	prvInitialiseTaskLists:
 2989               		.stabd	46,0,0
2285:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2286:../../FreeRTOS/Source/tasks.c **** 
2287:../../FreeRTOS/Source/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
2288:../../FreeRTOS/Source/tasks.c **** 
2289:../../FreeRTOS/Source/tasks.c **** 	void vTaskAllocateMPURegions( xTaskHandle xTaskToModify, const xMemoryRegion * const xRegions )
2290:../../FreeRTOS/Source/tasks.c **** 	{
2291:../../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
2292:../../FreeRTOS/Source/tasks.c **** 
2293:../../FreeRTOS/Source/tasks.c **** 		if( xTaskToModify == pxCurrentTCB )
2294:../../FreeRTOS/Source/tasks.c **** 		{
2295:../../FreeRTOS/Source/tasks.c **** 			xTaskToModify = NULL;
2296:../../FreeRTOS/Source/tasks.c **** 		}
2297:../../FreeRTOS/Source/tasks.c **** 
2298:../../FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then we are deleting ourselves. */
2299:../../FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
2300:../../FreeRTOS/Source/tasks.c **** 
2301:../../FreeRTOS/Source/tasks.c ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
2302:../../FreeRTOS/Source/tasks.c **** 	}
2303:../../FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
2304:../../FreeRTOS/Source/tasks.c **** #endif
2305:../../FreeRTOS/Source/tasks.c **** 
2306:../../FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void )
2307:../../FreeRTOS/Source/tasks.c **** {
 2991               	.LM278:
 2992               	.LFBB24:
 2993 0e4c CF93      		push r28
 2994 0e4e DF93      		push r29
 2995 0e50 1F92      		push __zero_reg__
 2996 0e52 CDB7      		in r28,__SP_L__
 2997 0e54 DEB7      		in r29,__SP_H__
 2998               	/* prologue: function */
 2999               	/* frame size = 1 */
 3000               	/* stack size = 3 */
 3001               	.L__stack_usage = 3
2308:../../FreeRTOS/Source/tasks.c **** unsigned portBASE_TYPE uxPriority;
2309:../../FreeRTOS/Source/tasks.c **** 
2310:../../FreeRTOS/Source/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 3003               	.LM279:
 3004 0e56 1982      		std Y+1,__zero_reg__
 3005 0e58 00C0      		rjmp .L105
 3006               	.L106:
2311:../../FreeRTOS/Source/tasks.c **** 	{
2312:../../FreeRTOS/Source/tasks.c **** 		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 3008               	.LM280:
 3009 0e5a 8981      		ldd r24,Y+1
 3010 0e5c 282F      		mov r18,r24
 3011 0e5e 30E0      		ldi r19,0
 3012 0e60 C901      		movw r24,r18
 3013 0e62 880F      		lsl r24
 3014 0e64 991F      		rol r25
 3015 0e66 880F      		lsl r24
 3016 0e68 991F      		rol r25
 3017 0e6a 880F      		lsl r24
 3018 0e6c 991F      		rol r25
 3019 0e6e 820F      		add r24,r18
 3020 0e70 931F      		adc r25,r19
 3021 0e72 8050      		subi r24,lo8(-(pxReadyTasksLists))
 3022 0e74 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 3023 0e76 0E94 0000 		call vListInitialise
2310:../../FreeRTOS/Source/tasks.c **** 	{
 3025               	.LM281:
 3026 0e7a 8981      		ldd r24,Y+1
 3027 0e7c 8F5F      		subi r24,lo8(-(1))
 3028 0e7e 8983      		std Y+1,r24
 3029               	.L105:
2310:../../FreeRTOS/Source/tasks.c **** 	{
 3031               	.LM282:
 3032 0e80 8981      		ldd r24,Y+1
 3033 0e82 8430      		cpi r24,lo8(4)
 3034 0e84 00F0      		brlo .L106
2313:../../FreeRTOS/Source/tasks.c **** 	}
2314:../../FreeRTOS/Source/tasks.c **** 
2315:../../FreeRTOS/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 3036               	.LM283:
 3037 0e86 80E0      		ldi r24,lo8(xDelayedTaskList1)
 3038 0e88 90E0      		ldi r25,hi8(xDelayedTaskList1)
 3039 0e8a 0E94 0000 		call vListInitialise
2316:../../FreeRTOS/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 3041               	.LM284:
 3042 0e8e 80E0      		ldi r24,lo8(xDelayedTaskList2)
 3043 0e90 90E0      		ldi r25,hi8(xDelayedTaskList2)
 3044 0e92 0E94 0000 		call vListInitialise
2317:../../FreeRTOS/Source/tasks.c **** 	vListInitialise( ( xList * ) &xPendingReadyList );
 3046               	.LM285:
 3047 0e96 80E0      		ldi r24,lo8(xPendingReadyList)
 3048 0e98 90E0      		ldi r25,hi8(xPendingReadyList)
 3049 0e9a 0E94 0000 		call vListInitialise
2318:../../FreeRTOS/Source/tasks.c **** 
2319:../../FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2320:../../FreeRTOS/Source/tasks.c **** 	{
2321:../../FreeRTOS/Source/tasks.c **** 		vListInitialise( ( xList * ) &xTasksWaitingTermination );
2322:../../FreeRTOS/Source/tasks.c **** 	}
2323:../../FreeRTOS/Source/tasks.c **** 	#endif
2324:../../FreeRTOS/Source/tasks.c **** 
2325:../../FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
2326:../../FreeRTOS/Source/tasks.c **** 	{
2327:../../FreeRTOS/Source/tasks.c **** 		vListInitialise( ( xList * ) &xSuspendedTaskList );
 3051               	.LM286:
 3052 0e9e 80E0      		ldi r24,lo8(xSuspendedTaskList)
 3053 0ea0 90E0      		ldi r25,hi8(xSuspendedTaskList)
 3054 0ea2 0E94 0000 		call vListInitialise
2328:../../FreeRTOS/Source/tasks.c **** 	}
2329:../../FreeRTOS/Source/tasks.c **** 	#endif
2330:../../FreeRTOS/Source/tasks.c **** 
2331:../../FreeRTOS/Source/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
2332:../../FreeRTOS/Source/tasks.c **** 	using list2. */
2333:../../FreeRTOS/Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
 3056               	.LM287:
 3057 0ea6 80E0      		ldi r24,lo8(xDelayedTaskList1)
 3058 0ea8 90E0      		ldi r25,hi8(xDelayedTaskList1)
 3059 0eaa 9093 0000 		sts pxDelayedTaskList+1,r25
 3060 0eae 8093 0000 		sts pxDelayedTaskList,r24
2334:../../FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 3062               	.LM288:
 3063 0eb2 80E0      		ldi r24,lo8(xDelayedTaskList2)
 3064 0eb4 90E0      		ldi r25,hi8(xDelayedTaskList2)
 3065 0eb6 9093 0000 		sts pxOverflowDelayedTaskList+1,r25
 3066 0eba 8093 0000 		sts pxOverflowDelayedTaskList,r24
 3067               	/* epilogue start */
2335:../../FreeRTOS/Source/tasks.c **** }
 3069               	.LM289:
 3070 0ebe 0F90      		pop __tmp_reg__
 3071 0ec0 DF91      		pop r29
 3072 0ec2 CF91      		pop r28
 3073 0ec4 0895      		ret
 3078               	.Lscope24:
 3080               		.stabd	78,0,0
 3083               	prvCheckTasksWaitingTermination:
 3084               		.stabd	46,0,0
2336:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2337:../../FreeRTOS/Source/tasks.c **** 
2338:../../FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void )
2339:../../FreeRTOS/Source/tasks.c **** {
 3086               	.LM290:
 3087               	.LFBB25:
 3088 0ec6 CF93      		push r28
 3089 0ec8 DF93      		push r29
 3090 0eca CDB7      		in r28,__SP_L__
 3091 0ecc DEB7      		in r29,__SP_H__
 3092               	/* prologue: function */
 3093               	/* frame size = 0 */
 3094               	/* stack size = 2 */
 3095               	.L__stack_usage = 2
 3096               	/* epilogue start */
2340:../../FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2341:../../FreeRTOS/Source/tasks.c **** 	{
2342:../../FreeRTOS/Source/tasks.c **** 		portBASE_TYPE xListIsEmpty;
2343:../../FreeRTOS/Source/tasks.c **** 
2344:../../FreeRTOS/Source/tasks.c **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
2345:../../FreeRTOS/Source/tasks.c **** 		too often in the idle task. */
2346:../../FreeRTOS/Source/tasks.c **** 		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
2347:../../FreeRTOS/Source/tasks.c **** 		{
2348:../../FreeRTOS/Source/tasks.c **** 			vTaskSuspendAll();
2349:../../FreeRTOS/Source/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
2350:../../FreeRTOS/Source/tasks.c **** 			xTaskResumeAll();
2351:../../FreeRTOS/Source/tasks.c **** 
2352:../../FreeRTOS/Source/tasks.c **** 			if( xListIsEmpty == pdFALSE )
2353:../../FreeRTOS/Source/tasks.c **** 			{
2354:../../FreeRTOS/Source/tasks.c **** 				tskTCB *pxTCB;
2355:../../FreeRTOS/Source/tasks.c **** 
2356:../../FreeRTOS/Source/tasks.c **** 				taskENTER_CRITICAL();
2357:../../FreeRTOS/Source/tasks.c **** 				{
2358:../../FreeRTOS/Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
2359:../../FreeRTOS/Source/tasks.c **** 					uxListRemove( &( pxTCB->xGenericListItem ) );
2360:../../FreeRTOS/Source/tasks.c **** 					--uxCurrentNumberOfTasks;
2361:../../FreeRTOS/Source/tasks.c **** 					--uxTasksDeleted;
2362:../../FreeRTOS/Source/tasks.c **** 				}
2363:../../FreeRTOS/Source/tasks.c **** 				taskEXIT_CRITICAL();
2364:../../FreeRTOS/Source/tasks.c **** 
2365:../../FreeRTOS/Source/tasks.c **** 				prvDeleteTCB( pxTCB );
2366:../../FreeRTOS/Source/tasks.c **** 			}
2367:../../FreeRTOS/Source/tasks.c **** 		}
2368:../../FreeRTOS/Source/tasks.c **** 	}
2369:../../FreeRTOS/Source/tasks.c **** 	#endif
2370:../../FreeRTOS/Source/tasks.c **** }
 3098               	.LM291:
 3099 0ece DF91      		pop r29
 3100 0ed0 CF91      		pop r28
 3101 0ed2 0895      		ret
 3103               	.Lscope25:
 3105               		.stabd	78,0,0
 3109               	prvAddCurrentTaskToDelayedList:
 3110               		.stabd	46,0,0
2371:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2372:../../FreeRTOS/Source/tasks.c **** 
2373:../../FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
2374:../../FreeRTOS/Source/tasks.c **** {
 3112               	.LM292:
 3113               	.LFBB26:
 3114 0ed4 CF93      		push r28
 3115 0ed6 DF93      		push r29
 3116 0ed8 1F92      		push __zero_reg__
 3117 0eda 1F92      		push __zero_reg__
 3118 0edc CDB7      		in r28,__SP_L__
 3119 0ede DEB7      		in r29,__SP_H__
 3120               	/* prologue: function */
 3121               	/* frame size = 2 */
 3122               	/* stack size = 4 */
 3123               	.L__stack_usage = 4
 3124 0ee0 9A83      		std Y+2,r25
 3125 0ee2 8983      		std Y+1,r24
2375:../../FreeRTOS/Source/tasks.c **** 	/* The list item will be inserted in wake time order. */
2376:../../FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 3127               	.LM293:
 3128 0ee4 8091 0000 		lds r24,pxCurrentTCB
 3129 0ee8 9091 0000 		lds r25,pxCurrentTCB+1
 3130 0eec 2981      		ldd r18,Y+1
 3131 0eee 3A81      		ldd r19,Y+2
 3132 0ef0 FC01      		movw r30,r24
 3133 0ef2 3383      		std Z+3,r19
 3134 0ef4 2283      		std Z+2,r18
2377:../../FreeRTOS/Source/tasks.c **** 
2378:../../FreeRTOS/Source/tasks.c **** 	if( xTimeToWake < xTickCount )
 3136               	.LM294:
 3137 0ef6 8091 0000 		lds r24,xTickCount
 3138 0efa 9091 0000 		lds r25,xTickCount+1
 3139 0efe 2981      		ldd r18,Y+1
 3140 0f00 3A81      		ldd r19,Y+2
 3141 0f02 2817      		cp r18,r24
 3142 0f04 3907      		cpc r19,r25
 3143 0f06 00F4      		brsh .L109
2379:../../FreeRTOS/Source/tasks.c **** 	{
2380:../../FreeRTOS/Source/tasks.c **** 		/* Wake time has overflowed.  Place this item in the overflow list. */
2381:../../FreeRTOS/Source/tasks.c **** 		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericList
 3145               	.LM295:
 3146 0f08 8091 0000 		lds r24,pxCurrentTCB
 3147 0f0c 9091 0000 		lds r25,pxCurrentTCB+1
 3148 0f10 9C01      		movw r18,r24
 3149 0f12 2E5F      		subi r18,-2
 3150 0f14 3F4F      		sbci r19,-1
 3151 0f16 8091 0000 		lds r24,pxOverflowDelayedTaskList
 3152 0f1a 9091 0000 		lds r25,pxOverflowDelayedTaskList+1
 3153 0f1e B901      		movw r22,r18
 3154 0f20 0E94 0000 		call vListInsert
 3155 0f24 00C0      		rjmp .L108
 3156               	.L109:
2382:../../FreeRTOS/Source/tasks.c **** 	}
2383:../../FreeRTOS/Source/tasks.c **** 	else
2384:../../FreeRTOS/Source/tasks.c **** 	{
2385:../../FreeRTOS/Source/tasks.c **** 		/* The wake time has not overflowed, so we can use the current block list. */
2386:../../FreeRTOS/Source/tasks.c **** 		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) )
 3158               	.LM296:
 3159 0f26 8091 0000 		lds r24,pxCurrentTCB
 3160 0f2a 9091 0000 		lds r25,pxCurrentTCB+1
 3161 0f2e 9C01      		movw r18,r24
 3162 0f30 2E5F      		subi r18,-2
 3163 0f32 3F4F      		sbci r19,-1
 3164 0f34 8091 0000 		lds r24,pxDelayedTaskList
 3165 0f38 9091 0000 		lds r25,pxDelayedTaskList+1
 3166 0f3c B901      		movw r22,r18
 3167 0f3e 0E94 0000 		call vListInsert
2387:../../FreeRTOS/Source/tasks.c **** 
2388:../../FreeRTOS/Source/tasks.c **** 		/* If the task entering the blocked state was placed at the head of the
2389:../../FreeRTOS/Source/tasks.c **** 		list of blocked tasks then xNextTaskUnblockTime needs to be updated
2390:../../FreeRTOS/Source/tasks.c **** 		too. */
2391:../../FreeRTOS/Source/tasks.c **** 		if( xTimeToWake < xNextTaskUnblockTime )
 3169               	.LM297:
 3170 0f42 8091 0000 		lds r24,xNextTaskUnblockTime
 3171 0f46 9091 0000 		lds r25,xNextTaskUnblockTime+1
 3172 0f4a 2981      		ldd r18,Y+1
 3173 0f4c 3A81      		ldd r19,Y+2
 3174 0f4e 2817      		cp r18,r24
 3175 0f50 3907      		cpc r19,r25
 3176 0f52 00F4      		brsh .L108
2392:../../FreeRTOS/Source/tasks.c **** 		{
2393:../../FreeRTOS/Source/tasks.c **** 			xNextTaskUnblockTime = xTimeToWake;
 3178               	.LM298:
 3179 0f54 8981      		ldd r24,Y+1
 3180 0f56 9A81      		ldd r25,Y+2
 3181 0f58 9093 0000 		sts xNextTaskUnblockTime+1,r25
 3182 0f5c 8093 0000 		sts xNextTaskUnblockTime,r24
 3183               	.L108:
 3184               	/* epilogue start */
2394:../../FreeRTOS/Source/tasks.c **** 		}
2395:../../FreeRTOS/Source/tasks.c **** 	}
2396:../../FreeRTOS/Source/tasks.c **** }
 3186               	.LM299:
 3187 0f60 0F90      		pop __tmp_reg__
 3188 0f62 0F90      		pop __tmp_reg__
 3189 0f64 DF91      		pop r29
 3190 0f66 CF91      		pop r28
 3191 0f68 0895      		ret
 3193               	.Lscope26:
 3195               		.stabd	78,0,0
 3200               	prvAllocateTCBAndStack:
 3201               		.stabd	46,0,0
2397:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2398:../../FreeRTOS/Source/tasks.c **** 
2399:../../FreeRTOS/Source/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
2400:../../FreeRTOS/Source/tasks.c **** {
 3203               	.LM300:
 3204               	.LFBB27:
 3205 0f6a CF93      		push r28
 3206 0f6c DF93      		push r29
 3207 0f6e 00D0      		rcall .
 3208 0f70 00D0      		rcall .
 3209 0f72 CDB7      		in r28,__SP_L__
 3210 0f74 DEB7      		in r29,__SP_H__
 3211               	/* prologue: function */
 3212               	/* frame size = 6 */
 3213               	/* stack size = 8 */
 3214               	.L__stack_usage = 8
 3215 0f76 9C83      		std Y+4,r25
 3216 0f78 8B83      		std Y+3,r24
 3217 0f7a 7E83      		std Y+6,r23
 3218 0f7c 6D83      		std Y+5,r22
2401:../../FreeRTOS/Source/tasks.c **** tskTCB *pxNewTCB;
2402:../../FreeRTOS/Source/tasks.c **** 
2403:../../FreeRTOS/Source/tasks.c **** 	/* Allocate space for the TCB.  Where the memory comes from depends on
2404:../../FreeRTOS/Source/tasks.c **** 	the implementation of the port malloc function. */
2405:../../FreeRTOS/Source/tasks.c **** 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 3220               	.LM301:
 3221 0f7e 8AE2      		ldi r24,lo8(42)
 3222 0f80 90E0      		ldi r25,0
 3223 0f82 0E94 0000 		call pvPortMalloc
 3224 0f86 9A83      		std Y+2,r25
 3225 0f88 8983      		std Y+1,r24
2406:../../FreeRTOS/Source/tasks.c **** 
2407:../../FreeRTOS/Source/tasks.c **** 	if( pxNewTCB != NULL )
 3227               	.LM302:
 3228 0f8a 8981      		ldd r24,Y+1
 3229 0f8c 9A81      		ldd r25,Y+2
 3230 0f8e 0097      		sbiw r24,0
 3231 0f90 01F0      		breq .L112
2408:../../FreeRTOS/Source/tasks.c **** 	{
2409:../../FreeRTOS/Source/tasks.c **** 		/* Allocate space for the stack used by the task being created.
2410:../../FreeRTOS/Source/tasks.c **** 		The base of the stack memory stored in the TCB so the task can
2411:../../FreeRTOS/Source/tasks.c **** 		be deleted later if required. */
2412:../../FreeRTOS/Source/tasks.c **** 		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * size
 3233               	.LM303:
 3234 0f92 8D81      		ldd r24,Y+5
 3235 0f94 9E81      		ldd r25,Y+6
 3236 0f96 0097      		sbiw r24,0
 3237 0f98 01F4      		brne .L113
 3239               	.LM304:
 3240 0f9a 8B81      		ldd r24,Y+3
 3241 0f9c 9C81      		ldd r25,Y+4
 3242 0f9e 0E94 0000 		call pvPortMalloc
 3243 0fa2 00C0      		rjmp .L114
 3244               	.L113:
 3246               	.LM305:
 3247 0fa4 8D81      		ldd r24,Y+5
 3248 0fa6 9E81      		ldd r25,Y+6
 3249               	.L114:
 3251               	.LM306:
 3252 0fa8 2981      		ldd r18,Y+1
 3253 0faa 3A81      		ldd r19,Y+2
 3254 0fac F901      		movw r30,r18
 3255 0fae 908F      		std Z+24,r25
 3256 0fb0 878B      		std Z+23,r24
2413:../../FreeRTOS/Source/tasks.c **** 
2414:../../FreeRTOS/Source/tasks.c **** 		if( pxNewTCB->pxStack == NULL )
 3258               	.LM307:
 3259 0fb2 8981      		ldd r24,Y+1
 3260 0fb4 9A81      		ldd r25,Y+2
 3261 0fb6 FC01      		movw r30,r24
 3262 0fb8 8789      		ldd r24,Z+23
 3263 0fba 908D      		ldd r25,Z+24
 3264 0fbc 0097      		sbiw r24,0
 3265 0fbe 01F4      		brne .L115
2415:../../FreeRTOS/Source/tasks.c **** 		{
2416:../../FreeRTOS/Source/tasks.c **** 			/* Could not allocate the stack.  Delete the allocated TCB. */
2417:../../FreeRTOS/Source/tasks.c **** 			vPortFree( pxNewTCB );
 3267               	.LM308:
 3268 0fc0 8981      		ldd r24,Y+1
 3269 0fc2 9A81      		ldd r25,Y+2
 3270 0fc4 0E94 0000 		call vPortFree
2418:../../FreeRTOS/Source/tasks.c **** 			pxNewTCB = NULL;
 3272               	.LM309:
 3273 0fc8 1A82      		std Y+2,__zero_reg__
 3274 0fca 1982      		std Y+1,__zero_reg__
 3275 0fcc 00C0      		rjmp .L112
 3276               	.L115:
2419:../../FreeRTOS/Source/tasks.c **** 		}
2420:../../FreeRTOS/Source/tasks.c **** 		else
2421:../../FreeRTOS/Source/tasks.c **** 		{
2422:../../FreeRTOS/Source/tasks.c **** 			/* Just to help debugging. */
2423:../../FreeRTOS/Source/tasks.c **** 			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTA
 3278               	.LM310:
 3279 0fce 8981      		ldd r24,Y+1
 3280 0fd0 9A81      		ldd r25,Y+2
 3281 0fd2 FC01      		movw r30,r24
 3282 0fd4 8789      		ldd r24,Z+23
 3283 0fd6 908D      		ldd r25,Z+24
 3284 0fd8 2B81      		ldd r18,Y+3
 3285 0fda 3C81      		ldd r19,Y+4
 3286 0fdc A901      		movw r20,r18
 3287 0fde 65EA      		ldi r22,lo8(-91)
 3288 0fe0 70E0      		ldi r23,0
 3289 0fe2 0E94 0000 		call memset
 3290               	.L112:
2424:../../FreeRTOS/Source/tasks.c **** 		}
2425:../../FreeRTOS/Source/tasks.c **** 	}
2426:../../FreeRTOS/Source/tasks.c **** 
2427:../../FreeRTOS/Source/tasks.c **** 	return pxNewTCB;
 3292               	.LM311:
 3293 0fe6 8981      		ldd r24,Y+1
 3294 0fe8 9A81      		ldd r25,Y+2
 3295               	/* epilogue start */
2428:../../FreeRTOS/Source/tasks.c **** }
 3297               	.LM312:
 3298 0fea 2696      		adiw r28,6
 3299 0fec 0FB6      		in __tmp_reg__,__SREG__
 3300 0fee F894      		cli
 3301 0ff0 DEBF      		out __SP_H__,r29
 3302 0ff2 0FBE      		out __SREG__,__tmp_reg__
 3303 0ff4 CDBF      		out __SP_L__,r28
 3304 0ff6 DF91      		pop r29
 3305 0ff8 CF91      		pop r28
 3306 0ffa 0895      		ret
 3311               	.Lscope27:
 3313               		.stabd	78,0,0
 3317               	usTaskCheckFreeStackSpace:
 3318               		.stabd	46,0,0
2429:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2430:../../FreeRTOS/Source/tasks.c **** 
2431:../../FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2432:../../FreeRTOS/Source/tasks.c **** 
2433:../../FreeRTOS/Source/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
2434:../../FreeRTOS/Source/tasks.c **** 	{
2435:../../FreeRTOS/Source/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2436:../../FreeRTOS/Source/tasks.c **** 	unsigned short usStackRemaining;
2437:../../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static char pcStatusString[ configMAX_TASK_NAME_LEN + 30 ];
2438:../../FreeRTOS/Source/tasks.c **** 
2439:../../FreeRTOS/Source/tasks.c **** 		/* Write the details of all the TCB's in pxList into the buffer. */
2440:../../FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2441:../../FreeRTOS/Source/tasks.c **** 		do
2442:../../FreeRTOS/Source/tasks.c **** 		{
2443:../../FreeRTOS/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2444:../../FreeRTOS/Source/tasks.c **** 			#if ( portSTACK_GROWTH > 0 )
2445:../../FreeRTOS/Source/tasks.c **** 			{
2446:../../FreeRTOS/Source/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
2447:../../FreeRTOS/Source/tasks.c **** 			}
2448:../../FreeRTOS/Source/tasks.c **** 			#else
2449:../../FreeRTOS/Source/tasks.c **** 			{
2450:../../FreeRTOS/Source/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
2451:../../FreeRTOS/Source/tasks.c **** 			}
2452:../../FreeRTOS/Source/tasks.c **** 			#endif
2453:../../FreeRTOS/Source/tasks.c **** 
2454:../../FreeRTOS/Source/tasks.c **** 			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, 
2455:../../FreeRTOS/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
2456:../../FreeRTOS/Source/tasks.c **** 
2457:../../FreeRTOS/Source/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
2458:../../FreeRTOS/Source/tasks.c **** 	}
2459:../../FreeRTOS/Source/tasks.c **** 
2460:../../FreeRTOS/Source/tasks.c **** #endif
2461:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2462:../../FreeRTOS/Source/tasks.c **** 
2463:../../FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
2464:../../FreeRTOS/Source/tasks.c **** 
2465:../../FreeRTOS/Source/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
2466:../../FreeRTOS/Source/tasks.c **** 	{
2467:../../FreeRTOS/Source/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2468:../../FreeRTOS/Source/tasks.c **** 	unsigned long ulStatsAsPercentage;
2469:../../FreeRTOS/Source/tasks.c **** 
2470:../../FreeRTOS/Source/tasks.c **** 		/* Write the run time stats of all the TCB's in pxList into the buffer. */
2471:../../FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2472:../../FreeRTOS/Source/tasks.c **** 		do
2473:../../FreeRTOS/Source/tasks.c **** 		{
2474:../../FreeRTOS/Source/tasks.c **** 			/* Get next TCB in from the list. */
2475:../../FreeRTOS/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2476:../../FreeRTOS/Source/tasks.c **** 
2477:../../FreeRTOS/Source/tasks.c **** 			/* Divide by zero check. */
2478:../../FreeRTOS/Source/tasks.c **** 			if( ulTotalRunTime > 0UL )
2479:../../FreeRTOS/Source/tasks.c **** 			{
2480:../../FreeRTOS/Source/tasks.c **** 				/* Has the task run at all? */
2481:../../FreeRTOS/Source/tasks.c **** 				if( pxNextTCB->ulRunTimeCounter == 0UL )
2482:../../FreeRTOS/Source/tasks.c **** 				{
2483:../../FreeRTOS/Source/tasks.c **** 					/* The task has used no CPU time at all. */
2484:../../FreeRTOS/Source/tasks.c **** 					sprintf( pcStatsString, ( char * ) "%s\t\t0\t\t0%%\r\n", pxNextTCB->pcTaskName );
2485:../../FreeRTOS/Source/tasks.c **** 				}
2486:../../FreeRTOS/Source/tasks.c **** 				else
2487:../../FreeRTOS/Source/tasks.c **** 				{
2488:../../FreeRTOS/Source/tasks.c **** 					/* What percentage of the total run time has the task used?
2489:../../FreeRTOS/Source/tasks.c **** 					This will always be rounded down to the nearest integer.
2490:../../FreeRTOS/Source/tasks.c **** 					ulTotalRunTime has already been divided by 100. */
2491:../../FreeRTOS/Source/tasks.c **** 					ulStatsAsPercentage = pxNextTCB->ulRunTimeCounter / ulTotalRunTime;
2492:../../FreeRTOS/Source/tasks.c **** 
2493:../../FreeRTOS/Source/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
2494:../../FreeRTOS/Source/tasks.c **** 					{
2495:../../FreeRTOS/Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2496:../../FreeRTOS/Source/tasks.c **** 						{
2497:../../FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t%lu%%\r\n", pxNextTCB->pcTaskName, pxNextTC
2498:../../FreeRTOS/Source/tasks.c **** 						}
2499:../../FreeRTOS/Source/tasks.c **** 						#else
2500:../../FreeRTOS/Source/tasks.c **** 						{
2501:../../FreeRTOS/Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
2502:../../FreeRTOS/Source/tasks.c **** 							printf() library can be used. */
2503:../../FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t%u%%\r\n", pxNextTCB->pcTaskName, ( unsigned
2504:../../FreeRTOS/Source/tasks.c **** 						}
2505:../../FreeRTOS/Source/tasks.c **** 						#endif
2506:../../FreeRTOS/Source/tasks.c **** 					}
2507:../../FreeRTOS/Source/tasks.c **** 					else
2508:../../FreeRTOS/Source/tasks.c **** 					{
2509:../../FreeRTOS/Source/tasks.c **** 						/* If the percentage is zero here then the task has
2510:../../FreeRTOS/Source/tasks.c **** 						consumed less than 1% of the total run time. */
2511:../../FreeRTOS/Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2512:../../FreeRTOS/Source/tasks.c **** 						{
2513:../../FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t<1%%\r\n", pxNextTCB->pcTaskName, pxNextTCB
2514:../../FreeRTOS/Source/tasks.c **** 						}
2515:../../FreeRTOS/Source/tasks.c **** 						#else
2516:../../FreeRTOS/Source/tasks.c **** 						{
2517:../../FreeRTOS/Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
2518:../../FreeRTOS/Source/tasks.c **** 							printf() library can be used. */
2519:../../FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t<1%%\r\n", pxNextTCB->pcTaskName, ( unsigned
2520:../../FreeRTOS/Source/tasks.c **** 						}
2521:../../FreeRTOS/Source/tasks.c **** 						#endif
2522:../../FreeRTOS/Source/tasks.c **** 					}
2523:../../FreeRTOS/Source/tasks.c **** 				}
2524:../../FreeRTOS/Source/tasks.c **** 
2525:../../FreeRTOS/Source/tasks.c **** 				strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatsString );
2526:../../FreeRTOS/Source/tasks.c **** 			}
2527:../../FreeRTOS/Source/tasks.c **** 
2528:../../FreeRTOS/Source/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
2529:../../FreeRTOS/Source/tasks.c **** 	}
2530:../../FreeRTOS/Source/tasks.c **** 
2531:../../FreeRTOS/Source/tasks.c **** #endif
2532:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2533:../../FreeRTOS/Source/tasks.c **** 
2534:../../FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
2535:../../FreeRTOS/Source/tasks.c **** 
2536:../../FreeRTOS/Source/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
2537:../../FreeRTOS/Source/tasks.c **** 	{
 3320               	.LM313:
 3321               	.LFBB28:
 3322 0ffc 0F93      		push r16
 3323 0ffe 1F93      		push r17
 3324 1000 CF93      		push r28
 3325 1002 DF93      		push r29
 3326 1004 1F92      		push __zero_reg__
 3327 1006 1F92      		push __zero_reg__
 3328 1008 CDB7      		in r28,__SP_L__
 3329 100a DEB7      		in r29,__SP_H__
 3330               	/* prologue: function */
 3331               	/* frame size = 2 */
 3332               	/* stack size = 6 */
 3333               	.L__stack_usage = 6
 3334 100c 9A83      		std Y+2,r25
 3335 100e 8983      		std Y+1,r24
2538:../../FreeRTOS/Source/tasks.c **** 	register unsigned short usCount = 0U;
 3337               	.LM314:
 3338 1010 00E0      		ldi r16,0
 3339 1012 10E0      		ldi r17,0
2539:../../FreeRTOS/Source/tasks.c **** 
2540:../../FreeRTOS/Source/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
 3341               	.LM315:
 3342 1014 00C0      		rjmp .L118
 3343               	.L119:
2541:../../FreeRTOS/Source/tasks.c **** 		{
2542:../../FreeRTOS/Source/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
 3345               	.LM316:
 3346 1016 8981      		ldd r24,Y+1
 3347 1018 9A81      		ldd r25,Y+2
 3348 101a 0196      		adiw r24,1
 3349 101c 9A83      		std Y+2,r25
 3350 101e 8983      		std Y+1,r24
2543:../../FreeRTOS/Source/tasks.c **** 			usCount++;
 3352               	.LM317:
 3353 1020 C801      		movw r24,r16
 3354 1022 8C01      		movw r16,r24
 3355 1024 0F5F      		subi r16,-1
 3356 1026 1F4F      		sbci r17,-1
 3357               	.L118:
2540:../../FreeRTOS/Source/tasks.c **** 		{
 3359               	.LM318:
 3360 1028 8981      		ldd r24,Y+1
 3361 102a 9A81      		ldd r25,Y+2
 3362 102c FC01      		movw r30,r24
 3363 102e 8081      		ld r24,Z
 3364 1030 853A      		cpi r24,lo8(-91)
 3365 1032 01F0      		breq .L119
2544:../../FreeRTOS/Source/tasks.c **** 		}
2545:../../FreeRTOS/Source/tasks.c **** 
2546:../../FreeRTOS/Source/tasks.c **** 		usCount /= sizeof( portSTACK_TYPE );
2547:../../FreeRTOS/Source/tasks.c **** 
2548:../../FreeRTOS/Source/tasks.c **** 		return usCount;
 3367               	.LM319:
 3368 1034 C801      		movw r24,r16
 3369               	/* epilogue start */
2549:../../FreeRTOS/Source/tasks.c **** 	}
 3371               	.LM320:
 3372 1036 0F90      		pop __tmp_reg__
 3373 1038 0F90      		pop __tmp_reg__
 3374 103a DF91      		pop r29
 3375 103c CF91      		pop r28
 3376 103e 1F91      		pop r17
 3377 1040 0F91      		pop r16
 3378 1042 0895      		ret
 3383               	.Lscope28:
 3385               		.stabd	78,0,0
 3388               	.global	uxTaskGetStackHighWaterMark
 3390               	uxTaskGetStackHighWaterMark:
 3391               		.stabd	46,0,0
2550:../../FreeRTOS/Source/tasks.c **** 
2551:../../FreeRTOS/Source/tasks.c **** #endif
2552:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2553:../../FreeRTOS/Source/tasks.c **** 
2554:../../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
2555:../../FreeRTOS/Source/tasks.c **** 
2556:../../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
2557:../../FreeRTOS/Source/tasks.c **** 	{
 3393               	.LM321:
 3394               	.LFBB29:
 3395 1044 CF93      		push r28
 3396 1046 DF93      		push r29
 3397 1048 CDB7      		in r28,__SP_L__
 3398 104a DEB7      		in r29,__SP_H__
 3399 104c 2797      		sbiw r28,7
 3400 104e 0FB6      		in __tmp_reg__,__SREG__
 3401 1050 F894      		cli
 3402 1052 DEBF      		out __SP_H__,r29
 3403 1054 0FBE      		out __SREG__,__tmp_reg__
 3404 1056 CDBF      		out __SP_L__,r28
 3405               	/* prologue: function */
 3406               	/* frame size = 7 */
 3407               	/* stack size = 9 */
 3408               	.L__stack_usage = 9
 3409 1058 9F83      		std Y+7,r25
 3410 105a 8E83      		std Y+6,r24
2558:../../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
2559:../../FreeRTOS/Source/tasks.c **** 	unsigned char *pcEndOfStack;
2560:../../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
2561:../../FreeRTOS/Source/tasks.c **** 
2562:../../FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
 3412               	.LM322:
 3413 105c 8E81      		ldd r24,Y+6
 3414 105e 9F81      		ldd r25,Y+7
 3415 1060 0097      		sbiw r24,0
 3416 1062 01F4      		brne .L122
 3418               	.LM323:
 3419 1064 8091 0000 		lds r24,pxCurrentTCB
 3420 1068 9091 0000 		lds r25,pxCurrentTCB+1
 3421 106c 00C0      		rjmp .L123
 3422               	.L122:
 3424               	.LM324:
 3425 106e 8E81      		ldd r24,Y+6
 3426 1070 9F81      		ldd r25,Y+7
 3427               	.L123:
 3429               	.LM325:
 3430 1072 9A83      		std Y+2,r25
 3431 1074 8983      		std Y+1,r24
2563:../../FreeRTOS/Source/tasks.c **** 
2564:../../FreeRTOS/Source/tasks.c **** 		#if portSTACK_GROWTH < 0
2565:../../FreeRTOS/Source/tasks.c **** 		{
2566:../../FreeRTOS/Source/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
 3433               	.LM326:
 3434 1076 8981      		ldd r24,Y+1
 3435 1078 9A81      		ldd r25,Y+2
 3436 107a FC01      		movw r30,r24
 3437 107c 8789      		ldd r24,Z+23
 3438 107e 908D      		ldd r25,Z+24
 3439 1080 9C83      		std Y+4,r25
 3440 1082 8B83      		std Y+3,r24
2567:../../FreeRTOS/Source/tasks.c **** 		}
2568:../../FreeRTOS/Source/tasks.c **** 		#else
2569:../../FreeRTOS/Source/tasks.c **** 		{
2570:../../FreeRTOS/Source/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
2571:../../FreeRTOS/Source/tasks.c **** 		}
2572:../../FreeRTOS/Source/tasks.c **** 		#endif
2573:../../FreeRTOS/Source/tasks.c **** 
2574:../../FreeRTOS/Source/tasks.c **** 		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
 3442               	.LM327:
 3443 1084 8B81      		ldd r24,Y+3
 3444 1086 9C81      		ldd r25,Y+4
 3445 1088 0E94 0000 		call usTaskCheckFreeStackSpace
 3446 108c 8D83      		std Y+5,r24
2575:../../FreeRTOS/Source/tasks.c **** 
2576:../../FreeRTOS/Source/tasks.c **** 		return uxReturn;
 3448               	.LM328:
 3449 108e 8D81      		ldd r24,Y+5
 3450               	/* epilogue start */
2577:../../FreeRTOS/Source/tasks.c **** 	}
 3452               	.LM329:
 3453 1090 2796      		adiw r28,7
 3454 1092 0FB6      		in __tmp_reg__,__SREG__
 3455 1094 F894      		cli
 3456 1096 DEBF      		out __SP_H__,r29
 3457 1098 0FBE      		out __SREG__,__tmp_reg__
 3458 109a CDBF      		out __SP_L__,r28
 3459 109c DF91      		pop r29
 3460 109e CF91      		pop r28
 3461 10a0 0895      		ret
 3468               	.Lscope29:
 3470               		.stabd	78,0,0
 3472               	.global	xTaskGetCurrentTaskHandle
 3474               	xTaskGetCurrentTaskHandle:
 3475               		.stabd	46,0,0
2578:../../FreeRTOS/Source/tasks.c **** 
2579:../../FreeRTOS/Source/tasks.c **** #endif
2580:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2581:../../FreeRTOS/Source/tasks.c **** 
2582:../../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
2583:../../FreeRTOS/Source/tasks.c **** 
2584:../../FreeRTOS/Source/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB )
2585:../../FreeRTOS/Source/tasks.c **** 	{
2586:../../FreeRTOS/Source/tasks.c **** 		/* This call is required specifically for the TriCore port.  It must be
2587:../../FreeRTOS/Source/tasks.c **** 		above the vPortFree() calls.  The call is also used by ports/demos that
2588:../../FreeRTOS/Source/tasks.c **** 		want to allocate and clean RAM statically. */
2589:../../FreeRTOS/Source/tasks.c **** 		portCLEAN_UP_TCB( pxTCB );
2590:../../FreeRTOS/Source/tasks.c **** 
2591:../../FreeRTOS/Source/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up to
2592:../../FreeRTOS/Source/tasks.c **** 		the task to free any memory allocated at the application level. */
2593:../../FreeRTOS/Source/tasks.c **** 		vPortFreeAligned( pxTCB->pxStack );
2594:../../FreeRTOS/Source/tasks.c **** 		vPortFree( pxTCB );
2595:../../FreeRTOS/Source/tasks.c **** 	}
2596:../../FreeRTOS/Source/tasks.c **** 
2597:../../FreeRTOS/Source/tasks.c **** #endif
2598:../../FreeRTOS/Source/tasks.c **** 
2599:../../FreeRTOS/Source/tasks.c **** 
2600:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2601:../../FreeRTOS/Source/tasks.c **** 
2602:../../FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
2603:../../FreeRTOS/Source/tasks.c **** 
2604:../../FreeRTOS/Source/tasks.c **** 	xTaskHandle xTaskGetCurrentTaskHandle( void )
2605:../../FreeRTOS/Source/tasks.c **** 	{
 3477               	.LM330:
 3478               	.LFBB30:
 3479 10a2 CF93      		push r28
 3480 10a4 DF93      		push r29
 3481 10a6 1F92      		push __zero_reg__
 3482 10a8 1F92      		push __zero_reg__
 3483 10aa CDB7      		in r28,__SP_L__
 3484 10ac DEB7      		in r29,__SP_H__
 3485               	/* prologue: function */
 3486               	/* frame size = 2 */
 3487               	/* stack size = 4 */
 3488               	.L__stack_usage = 4
2606:../../FreeRTOS/Source/tasks.c **** 	xTaskHandle xReturn;
2607:../../FreeRTOS/Source/tasks.c **** 
2608:../../FreeRTOS/Source/tasks.c **** 		/* A critical section is not required as this is not called from
2609:../../FreeRTOS/Source/tasks.c **** 		an interrupt and the current TCB will always be the same for any
2610:../../FreeRTOS/Source/tasks.c **** 		individual execution thread. */
2611:../../FreeRTOS/Source/tasks.c **** 		xReturn = pxCurrentTCB;
 3490               	.LM331:
 3491 10ae 8091 0000 		lds r24,pxCurrentTCB
 3492 10b2 9091 0000 		lds r25,pxCurrentTCB+1
 3493 10b6 9A83      		std Y+2,r25
 3494 10b8 8983      		std Y+1,r24
2612:../../FreeRTOS/Source/tasks.c **** 
2613:../../FreeRTOS/Source/tasks.c **** 		return xReturn;
 3496               	.LM332:
 3497 10ba 8981      		ldd r24,Y+1
 3498 10bc 9A81      		ldd r25,Y+2
 3499               	/* epilogue start */
2614:../../FreeRTOS/Source/tasks.c **** 	}
 3501               	.LM333:
 3502 10be 0F90      		pop __tmp_reg__
 3503 10c0 0F90      		pop __tmp_reg__
 3504 10c2 DF91      		pop r29
 3505 10c4 CF91      		pop r28
 3506 10c6 0895      		ret
 3511               	.Lscope30:
 3513               		.stabd	78,0,0
 3516               	.global	vTaskPriorityInherit
 3518               	vTaskPriorityInherit:
 3519               		.stabd	46,0,0
2615:../../FreeRTOS/Source/tasks.c **** 
2616:../../FreeRTOS/Source/tasks.c **** #endif
2617:../../FreeRTOS/Source/tasks.c **** 
2618:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2619:../../FreeRTOS/Source/tasks.c **** 
2620:../../FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
2621:../../FreeRTOS/Source/tasks.c **** 
2622:../../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xTaskGetSchedulerState( void )
2623:../../FreeRTOS/Source/tasks.c **** 	{
2624:../../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xReturn;
2625:../../FreeRTOS/Source/tasks.c **** 
2626:../../FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
2627:../../FreeRTOS/Source/tasks.c **** 		{
2628:../../FreeRTOS/Source/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
2629:../../FreeRTOS/Source/tasks.c **** 		}
2630:../../FreeRTOS/Source/tasks.c **** 		else
2631:../../FreeRTOS/Source/tasks.c **** 		{
2632:../../FreeRTOS/Source/tasks.c **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
2633:../../FreeRTOS/Source/tasks.c **** 			{
2634:../../FreeRTOS/Source/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
2635:../../FreeRTOS/Source/tasks.c **** 			}
2636:../../FreeRTOS/Source/tasks.c **** 			else
2637:../../FreeRTOS/Source/tasks.c **** 			{
2638:../../FreeRTOS/Source/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
2639:../../FreeRTOS/Source/tasks.c **** 			}
2640:../../FreeRTOS/Source/tasks.c **** 		}
2641:../../FreeRTOS/Source/tasks.c **** 
2642:../../FreeRTOS/Source/tasks.c **** 		return xReturn;
2643:../../FreeRTOS/Source/tasks.c **** 	}
2644:../../FreeRTOS/Source/tasks.c **** 
2645:../../FreeRTOS/Source/tasks.c **** #endif
2646:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2647:../../FreeRTOS/Source/tasks.c **** 
2648:../../FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
2649:../../FreeRTOS/Source/tasks.c **** 
2650:../../FreeRTOS/Source/tasks.c **** 	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
2651:../../FreeRTOS/Source/tasks.c **** 	{
 3521               	.LM334:
 3522               	.LFBB31:
 3523 10c8 CF93      		push r28
 3524 10ca DF93      		push r29
 3525 10cc 00D0      		rcall .
 3526 10ce 1F92      		push __zero_reg__
 3527 10d0 CDB7      		in r28,__SP_L__
 3528 10d2 DEB7      		in r29,__SP_H__
 3529               	/* prologue: function */
 3530               	/* frame size = 4 */
 3531               	/* stack size = 6 */
 3532               	.L__stack_usage = 6
 3533 10d4 9C83      		std Y+4,r25
 3534 10d6 8B83      		std Y+3,r24
2652:../../FreeRTOS/Source/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 3536               	.LM335:
 3537 10d8 8B81      		ldd r24,Y+3
 3538 10da 9C81      		ldd r25,Y+4
 3539 10dc 9A83      		std Y+2,r25
 3540 10de 8983      		std Y+1,r24
2653:../../FreeRTOS/Source/tasks.c **** 
2654:../../FreeRTOS/Source/tasks.c **** 		/* If the mutex was given back by an interrupt while the queue was
2655:../../FreeRTOS/Source/tasks.c **** 		locked then the mutex holder might now be NULL. */
2656:../../FreeRTOS/Source/tasks.c **** 		if( pxMutexHolder != NULL )
 3542               	.LM336:
 3543 10e0 8B81      		ldd r24,Y+3
 3544 10e2 9C81      		ldd r25,Y+4
 3545 10e4 0097      		sbiw r24,0
 3546 10e6 01F4      		brne .+2
 3547 10e8 00C0      		rjmp .L127
2657:../../FreeRTOS/Source/tasks.c **** 		{
2658:../../FreeRTOS/Source/tasks.c **** 			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 3549               	.LM337:
 3550 10ea 8981      		ldd r24,Y+1
 3551 10ec 9A81      		ldd r25,Y+2
 3552 10ee FC01      		movw r30,r24
 3553 10f0 2689      		ldd r18,Z+22
 3554 10f2 8091 0000 		lds r24,pxCurrentTCB
 3555 10f6 9091 0000 		lds r25,pxCurrentTCB+1
 3556 10fa FC01      		movw r30,r24
 3557 10fc 8689      		ldd r24,Z+22
 3558 10fe 2817      		cp r18,r24
 3559 1100 00F0      		brlo .+2
 3560 1102 00C0      		rjmp .L127
2659:../../FreeRTOS/Source/tasks.c **** 			{
2660:../../FreeRTOS/Source/tasks.c **** 				/* Adjust the mutex holder state to account for its new priority. */
2661:../../FreeRTOS/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) px
 3562               	.LM338:
 3563 1104 8091 0000 		lds r24,pxCurrentTCB
 3564 1108 9091 0000 		lds r25,pxCurrentTCB+1
 3565 110c FC01      		movw r30,r24
 3566 110e 8689      		ldd r24,Z+22
 3567 1110 882F      		mov r24,r24
 3568 1112 90E0      		ldi r25,0
 3569 1114 24E0      		ldi r18,lo8(4)
 3570 1116 30E0      		ldi r19,0
 3571 1118 281B      		sub r18,r24
 3572 111a 390B      		sbc r19,r25
 3573 111c 8981      		ldd r24,Y+1
 3574 111e 9A81      		ldd r25,Y+2
 3575 1120 FC01      		movw r30,r24
 3576 1122 3587      		std Z+13,r19
 3577 1124 2487      		std Z+12,r18
2662:../../FreeRTOS/Source/tasks.c **** 
2663:../../FreeRTOS/Source/tasks.c **** 				/* If the task being modified is in the ready state it will need to
2664:../../FreeRTOS/Source/tasks.c **** 				be moved into a new list. */
2665:../../FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericLis
 3579               	.LM339:
 3580 1126 8981      		ldd r24,Y+1
 3581 1128 9A81      		ldd r25,Y+2
 3582 112a FC01      		movw r30,r24
 3583 112c 4285      		ldd r20,Z+10
 3584 112e 5385      		ldd r21,Z+11
 3585 1130 8981      		ldd r24,Y+1
 3586 1132 9A81      		ldd r25,Y+2
 3587 1134 FC01      		movw r30,r24
 3588 1136 8689      		ldd r24,Z+22
 3589 1138 282F      		mov r18,r24
 3590 113a 30E0      		ldi r19,0
 3591 113c C901      		movw r24,r18
 3592 113e 880F      		lsl r24
 3593 1140 991F      		rol r25
 3594 1142 880F      		lsl r24
 3595 1144 991F      		rol r25
 3596 1146 880F      		lsl r24
 3597 1148 991F      		rol r25
 3598 114a 820F      		add r24,r18
 3599 114c 931F      		adc r25,r19
 3600 114e 8050      		subi r24,lo8(-(pxReadyTasksLists))
 3601 1150 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 3602 1152 4817      		cp r20,r24
 3603 1154 5907      		cpc r21,r25
 3604 1156 01F4      		brne .L129
2666:../../FreeRTOS/Source/tasks.c **** 				{
2667:../../FreeRTOS/Source/tasks.c **** 					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
 3606               	.LM340:
 3607 1158 8981      		ldd r24,Y+1
 3608 115a 9A81      		ldd r25,Y+2
 3609 115c 0296      		adiw r24,2
 3610 115e 0E94 0000 		call uxListRemove
2668:../../FreeRTOS/Source/tasks.c **** 					{
2669:../../FreeRTOS/Source/tasks.c **** 						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
2670:../../FreeRTOS/Source/tasks.c **** 					}
2671:../../FreeRTOS/Source/tasks.c **** 
2672:../../FreeRTOS/Source/tasks.c **** 					/* Inherit the priority before being moved into the new list. */
2673:../../FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 3612               	.LM341:
 3613 1162 8091 0000 		lds r24,pxCurrentTCB
 3614 1166 9091 0000 		lds r25,pxCurrentTCB+1
 3615 116a FC01      		movw r30,r24
 3616 116c 2689      		ldd r18,Z+22
 3617 116e 8981      		ldd r24,Y+1
 3618 1170 9A81      		ldd r25,Y+2
 3619 1172 FC01      		movw r30,r24
 3620 1174 268B      		std Z+22,r18
2674:../../FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 3622               	.LM342:
 3623 1176 8981      		ldd r24,Y+1
 3624 1178 9A81      		ldd r25,Y+2
 3625 117a FC01      		movw r30,r24
 3626 117c 9689      		ldd r25,Z+22
 3627 117e 8091 0000 		lds r24,uxTopReadyPriority
 3628 1182 8917      		cp r24,r25
 3629 1184 00F4      		brsh .L130
 3631               	.LM343:
 3632 1186 8981      		ldd r24,Y+1
 3633 1188 9A81      		ldd r25,Y+2
 3634 118a FC01      		movw r30,r24
 3635 118c 8689      		ldd r24,Z+22
 3636 118e 8093 0000 		sts uxTopReadyPriority,r24
 3637               	.L130:
 3639               	.LM344:
 3640 1192 8981      		ldd r24,Y+1
 3641 1194 9A81      		ldd r25,Y+2
 3642 1196 AC01      		movw r20,r24
 3643 1198 4E5F      		subi r20,-2
 3644 119a 5F4F      		sbci r21,-1
 3645 119c 8981      		ldd r24,Y+1
 3646 119e 9A81      		ldd r25,Y+2
 3647 11a0 FC01      		movw r30,r24
 3648 11a2 8689      		ldd r24,Z+22
 3649 11a4 282F      		mov r18,r24
 3650 11a6 30E0      		ldi r19,0
 3651 11a8 C901      		movw r24,r18
 3652 11aa 880F      		lsl r24
 3653 11ac 991F      		rol r25
 3654 11ae 880F      		lsl r24
 3655 11b0 991F      		rol r25
 3656 11b2 880F      		lsl r24
 3657 11b4 991F      		rol r25
 3658 11b6 820F      		add r24,r18
 3659 11b8 931F      		adc r25,r19
 3660 11ba 8050      		subi r24,lo8(-(pxReadyTasksLists))
 3661 11bc 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 3662 11be BA01      		movw r22,r20
 3663 11c0 0E94 0000 		call vListInsertEnd
 3664 11c4 00C0      		rjmp .L127
 3665               	.L129:
2675:../../FreeRTOS/Source/tasks.c **** 				}
2676:../../FreeRTOS/Source/tasks.c **** 				else
2677:../../FreeRTOS/Source/tasks.c **** 				{
2678:../../FreeRTOS/Source/tasks.c **** 					/* Just inherit the priority. */
2679:../../FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 3667               	.LM345:
 3668 11c6 8091 0000 		lds r24,pxCurrentTCB
 3669 11ca 9091 0000 		lds r25,pxCurrentTCB+1
 3670 11ce FC01      		movw r30,r24
 3671 11d0 2689      		ldd r18,Z+22
 3672 11d2 8981      		ldd r24,Y+1
 3673 11d4 9A81      		ldd r25,Y+2
 3674 11d6 FC01      		movw r30,r24
 3675 11d8 268B      		std Z+22,r18
 3676               	.L127:
 3677               	/* epilogue start */
2680:../../FreeRTOS/Source/tasks.c **** 				}
2681:../../FreeRTOS/Source/tasks.c **** 
2682:../../FreeRTOS/Source/tasks.c **** 				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
2683:../../FreeRTOS/Source/tasks.c **** 			}
2684:../../FreeRTOS/Source/tasks.c **** 		}
2685:../../FreeRTOS/Source/tasks.c **** 	}
 3679               	.LM346:
 3680 11da 0F90      		pop __tmp_reg__
 3681 11dc 0F90      		pop __tmp_reg__
 3682 11de 0F90      		pop __tmp_reg__
 3683 11e0 0F90      		pop __tmp_reg__
 3684 11e2 DF91      		pop r29
 3685 11e4 CF91      		pop r28
 3686 11e6 0895      		ret
 3691               	.Lscope31:
 3693               		.stabd	78,0,0
 3696               	.global	vTaskPriorityDisinherit
 3698               	vTaskPriorityDisinherit:
 3699               		.stabd	46,0,0
2686:../../FreeRTOS/Source/tasks.c **** 
2687:../../FreeRTOS/Source/tasks.c **** #endif
2688:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2689:../../FreeRTOS/Source/tasks.c **** 
2690:../../FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
2691:../../FreeRTOS/Source/tasks.c **** 
2692:../../FreeRTOS/Source/tasks.c **** 	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
2693:../../FreeRTOS/Source/tasks.c **** 	{
 3701               	.LM347:
 3702               	.LFBB32:
 3703 11e8 CF93      		push r28
 3704 11ea DF93      		push r29
 3705 11ec 00D0      		rcall .
 3706 11ee 1F92      		push __zero_reg__
 3707 11f0 CDB7      		in r28,__SP_L__
 3708 11f2 DEB7      		in r29,__SP_H__
 3709               	/* prologue: function */
 3710               	/* frame size = 4 */
 3711               	/* stack size = 6 */
 3712               	.L__stack_usage = 6
 3713 11f4 9C83      		std Y+4,r25
 3714 11f6 8B83      		std Y+3,r24
2694:../../FreeRTOS/Source/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 3716               	.LM348:
 3717 11f8 8B81      		ldd r24,Y+3
 3718 11fa 9C81      		ldd r25,Y+4
 3719 11fc 9A83      		std Y+2,r25
 3720 11fe 8983      		std Y+1,r24
2695:../../FreeRTOS/Source/tasks.c **** 
2696:../../FreeRTOS/Source/tasks.c **** 		if( pxMutexHolder != NULL )
 3722               	.LM349:
 3723 1200 8B81      		ldd r24,Y+3
 3724 1202 9C81      		ldd r25,Y+4
 3725 1204 0097      		sbiw r24,0
 3726 1206 01F4      		brne .+2
 3727 1208 00C0      		rjmp .L131
2697:../../FreeRTOS/Source/tasks.c **** 		{
2698:../../FreeRTOS/Source/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 3729               	.LM350:
 3730 120a 8981      		ldd r24,Y+1
 3731 120c 9A81      		ldd r25,Y+2
 3732 120e FC01      		movw r30,r24
 3733 1210 2689      		ldd r18,Z+22
 3734 1212 8981      		ldd r24,Y+1
 3735 1214 9A81      		ldd r25,Y+2
 3736 1216 FC01      		movw r30,r24
 3737 1218 81A5      		ldd r24,Z+41
 3738 121a 2817      		cp r18,r24
 3739 121c 01F4      		brne .+2
 3740 121e 00C0      		rjmp .L131
2699:../../FreeRTOS/Source/tasks.c **** 			{
2700:../../FreeRTOS/Source/tasks.c **** 				/* We must be the running task to be able to give the mutex back.
2701:../../FreeRTOS/Source/tasks.c **** 				Remove ourselves from the ready list we currently appear in. */
2702:../../FreeRTOS/Source/tasks.c **** 				if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
 3742               	.LM351:
 3743 1220 8981      		ldd r24,Y+1
 3744 1222 9A81      		ldd r25,Y+2
 3745 1224 0296      		adiw r24,2
 3746 1226 0E94 0000 		call uxListRemove
2703:../../FreeRTOS/Source/tasks.c **** 				{
2704:../../FreeRTOS/Source/tasks.c **** 					taskRESET_READY_PRIORITY( pxTCB->uxPriority );
2705:../../FreeRTOS/Source/tasks.c **** 				}
2706:../../FreeRTOS/Source/tasks.c **** 
2707:../../FreeRTOS/Source/tasks.c **** 				/* Disinherit the priority before adding the task into the new
2708:../../FreeRTOS/Source/tasks.c **** 				ready list. */
2709:../../FreeRTOS/Source/tasks.c **** 				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
2710:../../FreeRTOS/Source/tasks.c **** 				pxTCB->uxPriority = pxTCB->uxBasePriority;
 3748               	.LM352:
 3749 122a 8981      		ldd r24,Y+1
 3750 122c 9A81      		ldd r25,Y+2
 3751 122e FC01      		movw r30,r24
 3752 1230 21A5      		ldd r18,Z+41
 3753 1232 8981      		ldd r24,Y+1
 3754 1234 9A81      		ldd r25,Y+2
 3755 1236 FC01      		movw r30,r24
 3756 1238 268B      		std Z+22,r18
2711:../../FreeRTOS/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) px
 3758               	.LM353:
 3759 123a 8981      		ldd r24,Y+1
 3760 123c 9A81      		ldd r25,Y+2
 3761 123e FC01      		movw r30,r24
 3762 1240 8689      		ldd r24,Z+22
 3763 1242 882F      		mov r24,r24
 3764 1244 90E0      		ldi r25,0
 3765 1246 24E0      		ldi r18,lo8(4)
 3766 1248 30E0      		ldi r19,0
 3767 124a 281B      		sub r18,r24
 3768 124c 390B      		sbc r19,r25
 3769 124e 8981      		ldd r24,Y+1
 3770 1250 9A81      		ldd r25,Y+2
 3771 1252 FC01      		movw r30,r24
 3772 1254 3587      		std Z+13,r19
 3773 1256 2487      		std Z+12,r18
2712:../../FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 3775               	.LM354:
 3776 1258 8981      		ldd r24,Y+1
 3777 125a 9A81      		ldd r25,Y+2
 3778 125c FC01      		movw r30,r24
 3779 125e 9689      		ldd r25,Z+22
 3780 1260 8091 0000 		lds r24,uxTopReadyPriority
 3781 1264 8917      		cp r24,r25
 3782 1266 00F4      		brsh .L133
 3784               	.LM355:
 3785 1268 8981      		ldd r24,Y+1
 3786 126a 9A81      		ldd r25,Y+2
 3787 126c FC01      		movw r30,r24
 3788 126e 8689      		ldd r24,Z+22
 3789 1270 8093 0000 		sts uxTopReadyPriority,r24
 3790               	.L133:
 3792               	.LM356:
 3793 1274 8981      		ldd r24,Y+1
 3794 1276 9A81      		ldd r25,Y+2
 3795 1278 AC01      		movw r20,r24
 3796 127a 4E5F      		subi r20,-2
 3797 127c 5F4F      		sbci r21,-1
 3798 127e 8981      		ldd r24,Y+1
 3799 1280 9A81      		ldd r25,Y+2
 3800 1282 FC01      		movw r30,r24
 3801 1284 8689      		ldd r24,Z+22
 3802 1286 282F      		mov r18,r24
 3803 1288 30E0      		ldi r19,0
 3804 128a C901      		movw r24,r18
 3805 128c 880F      		lsl r24
 3806 128e 991F      		rol r25
 3807 1290 880F      		lsl r24
 3808 1292 991F      		rol r25
 3809 1294 880F      		lsl r24
 3810 1296 991F      		rol r25
 3811 1298 820F      		add r24,r18
 3812 129a 931F      		adc r25,r19
 3813 129c 8050      		subi r24,lo8(-(pxReadyTasksLists))
 3814 129e 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 3815 12a0 BA01      		movw r22,r20
 3816 12a2 0E94 0000 		call vListInsertEnd
 3817               	.L131:
 3818               	/* epilogue start */
2713:../../FreeRTOS/Source/tasks.c **** 			}
2714:../../FreeRTOS/Source/tasks.c **** 		}
2715:../../FreeRTOS/Source/tasks.c **** 	}
 3820               	.LM357:
 3821 12a6 0F90      		pop __tmp_reg__
 3822 12a8 0F90      		pop __tmp_reg__
 3823 12aa 0F90      		pop __tmp_reg__
 3824 12ac 0F90      		pop __tmp_reg__
 3825 12ae DF91      		pop r29
 3826 12b0 CF91      		pop r28
 3827 12b2 0895      		ret
 3832               	.Lscope32:
 3834               		.stabd	78,0,0
 3855               	.Letext0:
 3856               		.ident	"GCC: (GNU) 4.9.0"
 3857               	.global __do_copy_data
 3858               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 tasks.c
     /tmp/cc8IZ7uD.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc8IZ7uD.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc8IZ7uD.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc8IZ7uD.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/cc8IZ7uD.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc8IZ7uD.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc8IZ7uD.s:164    .bss:0000000000000000 pxCurrentTCB
                             .bss:0000000000000002 pxReadyTasksLists
     /tmp/cc8IZ7uD.s:167    .bss:0000000000000026 xDelayedTaskList1
     /tmp/cc8IZ7uD.s:169    .bss:000000000000002f xDelayedTaskList2
     /tmp/cc8IZ7uD.s:171    .bss:0000000000000038 pxDelayedTaskList
     /tmp/cc8IZ7uD.s:173    .bss:000000000000003a pxOverflowDelayedTaskList
     /tmp/cc8IZ7uD.s:175    .bss:000000000000003c xPendingReadyList
     /tmp/cc8IZ7uD.s:177    .bss:0000000000000045 xSuspendedTaskList
     /tmp/cc8IZ7uD.s:179    .bss:000000000000004e uxCurrentNumberOfTasks
     /tmp/cc8IZ7uD.s:181    .bss:000000000000004f xTickCount
     /tmp/cc8IZ7uD.s:183    .bss:0000000000000051 uxTopUsedPriority
     /tmp/cc8IZ7uD.s:185    .bss:0000000000000052 uxTopReadyPriority
     /tmp/cc8IZ7uD.s:187    .bss:0000000000000053 xSchedulerRunning
     /tmp/cc8IZ7uD.s:189    .bss:0000000000000054 uxSchedulerSuspended
     /tmp/cc8IZ7uD.s:191    .bss:0000000000000055 uxMissedTicks
     /tmp/cc8IZ7uD.s:193    .bss:0000000000000056 xMissedYield
     /tmp/cc8IZ7uD.s:195    .bss:0000000000000057 xNumOfOverflows
     /tmp/cc8IZ7uD.s:197    .bss:0000000000000058 uxTaskNumber
     /tmp/cc8IZ7uD.s:203    .data:0000000000000000 xNextTaskUnblockTime
     /tmp/cc8IZ7uD.s:217    .text:0000000000000000 xTaskGenericCreate
     /tmp/cc8IZ7uD.s:3200   .text:0000000000000f6a prvAllocateTCBAndStack
     /tmp/cc8IZ7uD.s:2853   .text:0000000000000d8a prvInitialiseTCBVariables
     /tmp/cc8IZ7uD.s:2988   .text:0000000000000e4c prvInitialiseTaskLists
     /tmp/cc8IZ7uD.s:546    .text:00000000000001e8 vTaskDelayUntil
     /tmp/cc8IZ7uD.s:1488   .text:0000000000000682 vTaskSuspendAll
     /tmp/cc8IZ7uD.s:3109   .text:0000000000000ed4 prvAddCurrentTaskToDelayedList
     /tmp/cc8IZ7uD.s:1519   .text:000000000000069a xTaskResumeAll
     /tmp/cc8IZ7uD.s:718    .text:00000000000002da vTaskDelay
     /tmp/cc8IZ7uD.s:806    .text:0000000000000344 vTaskSuspend
     /tmp/cc8IZ7uD.s:2140   .text:00000000000009c6 vTaskSwitchContext
     /tmp/cc8IZ7uD.s:965    .text:00000000000003fe xTaskIsTaskSuspended
     /tmp/cc8IZ7uD.s:1054   .text:0000000000000462 vTaskResume
     /tmp/cc8IZ7uD.s:1211   .text:0000000000000530 xTaskResumeFromISR
     /tmp/cc8IZ7uD.s:1361   .text:00000000000005fe vTaskStartScheduler
     /tmp/cc8IZ7uD.s:2809   .text:0000000000000d68 prvIdleTask
     /tmp/cc8IZ7uD.s:1449   .text:000000000000066a vTaskEndScheduler
     /tmp/cc8IZ7uD.s:1879   .text:000000000000080c vTaskIncrementTick
     /tmp/cc8IZ7uD.s:1737   .text:00000000000007a2 xTaskGetTickCount
     /tmp/cc8IZ7uD.s:1803   .text:00000000000007d2 xTaskGetTickCountFromISR
     /tmp/cc8IZ7uD.s:1850   .text:00000000000007fa uxTaskGetNumberOfTasks
     /tmp/cc8IZ7uD.s:2316   .text:0000000000000ae0 vTaskPlaceOnEventList
     /tmp/cc8IZ7uD.s:2410   .text:0000000000000b6a xTaskRemoveFromEventList
     /tmp/cc8IZ7uD.s:2560   .text:0000000000000c3e vTaskSetTimeOutState
     /tmp/cc8IZ7uD.s:2610   .text:0000000000000c76 xTaskCheckForTimeOut
     /tmp/cc8IZ7uD.s:2779   .text:0000000000000d54 vTaskMissedYield
     /tmp/cc8IZ7uD.s:3083   .text:0000000000000ec6 prvCheckTasksWaitingTermination
     /tmp/cc8IZ7uD.s:3317   .text:0000000000000ffc usTaskCheckFreeStackSpace
     /tmp/cc8IZ7uD.s:3390   .text:0000000000001044 uxTaskGetStackHighWaterMark
     /tmp/cc8IZ7uD.s:3474   .text:00000000000010a2 xTaskGetCurrentTaskHandle
     /tmp/cc8IZ7uD.s:3518   .text:00000000000010c8 vTaskPriorityInherit
     /tmp/cc8IZ7uD.s:3698   .text:00000000000011e8 vTaskPriorityDisinherit

UNDEFINED SYMBOLS
pxPortInitialiseStack
vListInsertEnd
vPortYield
uxListRemove
xPortStartScheduler
vPortEndScheduler
vApplicationStackOverflowHook
vListInsert
strncpy
vListInitialiseItem
vListInitialise
pvPortMalloc
vPortFree
memset
__do_copy_data
__do_clear_bss
