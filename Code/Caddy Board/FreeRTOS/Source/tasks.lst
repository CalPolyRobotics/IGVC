   1               		.file	"tasks.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 126               	.global	pxCurrentTCB
 127               	.global	pxCurrentTCB
 128               		.section .bss
 131               	pxCurrentTCB:
 132 0000 0000      		.skip 2,0
 133               		.lcomm uxCurrentNumberOfTasks,1
 134               		.lcomm xTickCount,2
 135               		.lcomm uxTopUsedPriority,1
 136               		.lcomm uxTopReadyPriority,1
 137               		.lcomm xSchedulerRunning,1
 138               		.lcomm uxSchedulerSuspended,1
 139               		.lcomm uxMissedTicks,1
 140               		.lcomm xMissedYield,1
 141               		.lcomm xNumOfOverflows,1
 142               		.lcomm uxTaskNumber,1
 143               		.data
 146               	xNextTaskUnblockTime:
 147 0000 FFFF      		.word	-1
 148               		.text
 158               	.global	xTaskGenericCreate
 160               	xTaskGenericCreate:
 161               		.stabd	46,0,0
   1:../../FreeRTOS/Source/tasks.c **** /*
   2:../../FreeRTOS/Source/tasks.c ****     FreeRTOS V7.3.0 - Copyright (C) 2012 Real Time Engineers Ltd.
   3:../../FreeRTOS/Source/tasks.c **** 
   4:../../FreeRTOS/Source/tasks.c ****     FEATURES AND PORTS ARE ADDED TO FREERTOS ALL THE TIME.  PLEASE VISIT
   5:../../FreeRTOS/Source/tasks.c ****     http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:../../FreeRTOS/Source/tasks.c **** 
   7:../../FreeRTOS/Source/tasks.c ****     ***************************************************************************
   8:../../FreeRTOS/Source/tasks.c ****      *                                                                       *
   9:../../FreeRTOS/Source/tasks.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
  10:../../FreeRTOS/Source/tasks.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
  11:../../FreeRTOS/Source/tasks.c ****      *    available.                                                         *
  12:../../FreeRTOS/Source/tasks.c ****      *                                                                       *
  13:../../FreeRTOS/Source/tasks.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  14:../../FreeRTOS/Source/tasks.c ****      *    ensuring you get running as quickly as possible and with an        *
  15:../../FreeRTOS/Source/tasks.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  16:../../FreeRTOS/Source/tasks.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  17:../../FreeRTOS/Source/tasks.c ****      *    professional grade, cross platform, de facto standard solutions    *
  18:../../FreeRTOS/Source/tasks.c ****      *    for microcontrollers - completely free of charge!                  *
  19:../../FreeRTOS/Source/tasks.c ****      *                                                                       *
  20:../../FreeRTOS/Source/tasks.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  21:../../FreeRTOS/Source/tasks.c ****      *                                                                       *
  22:../../FreeRTOS/Source/tasks.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  23:../../FreeRTOS/Source/tasks.c ****      *                                                                       *
  24:../../FreeRTOS/Source/tasks.c ****     ***************************************************************************
  25:../../FreeRTOS/Source/tasks.c **** 
  26:../../FreeRTOS/Source/tasks.c **** 
  27:../../FreeRTOS/Source/tasks.c ****     This file is part of the FreeRTOS distribution.
  28:../../FreeRTOS/Source/tasks.c **** 
  29:../../FreeRTOS/Source/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  30:../../FreeRTOS/Source/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  31:../../FreeRTOS/Source/tasks.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  32:../../FreeRTOS/Source/tasks.c ****     >>>NOTE<<< The modification to the GPL is included to allow you to
  33:../../FreeRTOS/Source/tasks.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  34:../../FreeRTOS/Source/tasks.c ****     provide the source code for proprietary components outside of the FreeRTOS
  35:../../FreeRTOS/Source/tasks.c ****     kernel.  FreeRTOS is distributed in the hope that it will be useful, but
  36:../../FreeRTOS/Source/tasks.c ****     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  37:../../FreeRTOS/Source/tasks.c ****     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  38:../../FreeRTOS/Source/tasks.c ****     more details. You should have received a copy of the GNU General Public
  39:../../FreeRTOS/Source/tasks.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  40:../../FreeRTOS/Source/tasks.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  41:../../FreeRTOS/Source/tasks.c ****     by writing to Richard Barry, contact details for whom are available on the
  42:../../FreeRTOS/Source/tasks.c ****     FreeRTOS WEB site.
  43:../../FreeRTOS/Source/tasks.c **** 
  44:../../FreeRTOS/Source/tasks.c ****     1 tab == 4 spaces!
  45:../../FreeRTOS/Source/tasks.c **** 
  46:../../FreeRTOS/Source/tasks.c ****     ***************************************************************************
  47:../../FreeRTOS/Source/tasks.c ****      *                                                                       *
  48:../../FreeRTOS/Source/tasks.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  49:../../FreeRTOS/Source/tasks.c ****      *    not run, what could be wrong?"                                     *
  50:../../FreeRTOS/Source/tasks.c ****      *                                                                       *
  51:../../FreeRTOS/Source/tasks.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  52:../../FreeRTOS/Source/tasks.c ****      *                                                                       *
  53:../../FreeRTOS/Source/tasks.c ****     ***************************************************************************
  54:../../FreeRTOS/Source/tasks.c **** 
  55:../../FreeRTOS/Source/tasks.c **** 
  56:../../FreeRTOS/Source/tasks.c ****     http://www.FreeRTOS.org - Documentation, training, latest versions, license
  57:../../FreeRTOS/Source/tasks.c ****     and contact details.
  58:../../FreeRTOS/Source/tasks.c **** 
  59:../../FreeRTOS/Source/tasks.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  60:../../FreeRTOS/Source/tasks.c ****     including FreeRTOS+Trace - an indispensable productivity tool.
  61:../../FreeRTOS/Source/tasks.c **** 
  62:../../FreeRTOS/Source/tasks.c ****     Real Time Engineers ltd license FreeRTOS to High Integrity Systems, who sell
  63:../../FreeRTOS/Source/tasks.c ****     the code with commercial support, indemnification, and middleware, under
  64:../../FreeRTOS/Source/tasks.c ****     the OpenRTOS brand: http://www.OpenRTOS.com.  High Integrity Systems also
  65:../../FreeRTOS/Source/tasks.c ****     provide a safety engineered and independently SIL3 certified version under
  66:../../FreeRTOS/Source/tasks.c ****     the SafeRTOS brand: http://www.SafeRTOS.com.
  67:../../FreeRTOS/Source/tasks.c **** */
  68:../../FreeRTOS/Source/tasks.c **** 
  69:../../FreeRTOS/Source/tasks.c **** /* Standard includes. */
  70:../../FreeRTOS/Source/tasks.c **** #include <stdio.h>
  71:../../FreeRTOS/Source/tasks.c **** #include <stdlib.h>
  72:../../FreeRTOS/Source/tasks.c **** #include <string.h>
  73:../../FreeRTOS/Source/tasks.c **** 
  74:../../FreeRTOS/Source/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  75:../../FreeRTOS/Source/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  76:../../FreeRTOS/Source/tasks.c **** task.h is included from an application file. */
  77:../../FreeRTOS/Source/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  78:../../FreeRTOS/Source/tasks.c **** 
  79:../../FreeRTOS/Source/tasks.c **** /* FreeRTOS includes. */
  80:../../FreeRTOS/Source/tasks.c **** #include "FreeRTOS.h"
  81:../../FreeRTOS/Source/tasks.c **** #include "task.h"
  82:../../FreeRTOS/Source/tasks.c **** #include "timers.h"
  83:../../FreeRTOS/Source/tasks.c **** #include "StackMacros.h"
  84:../../FreeRTOS/Source/tasks.c **** 
  85:../../FreeRTOS/Source/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  86:../../FreeRTOS/Source/tasks.c **** 
  87:../../FreeRTOS/Source/tasks.c **** /*
  88:../../FreeRTOS/Source/tasks.c ****  * Defines the size, in words, of the stack allocated to the idle task.
  89:../../FreeRTOS/Source/tasks.c ****  */
  90:../../FreeRTOS/Source/tasks.c **** #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
  91:../../FreeRTOS/Source/tasks.c **** 
  92:../../FreeRTOS/Source/tasks.c **** /*
  93:../../FreeRTOS/Source/tasks.c ****  * Task control block.  A task control block (TCB) is allocated for each task,
  94:../../FreeRTOS/Source/tasks.c ****  * and stores task state information, including a pointer to the task's context
  95:../../FreeRTOS/Source/tasks.c ****  * (the task's run time environment, including register values)
  96:../../FreeRTOS/Source/tasks.c ****  */
  97:../../FreeRTOS/Source/tasks.c **** typedef struct tskTaskControlBlock
  98:../../FreeRTOS/Source/tasks.c **** {
  99:../../FreeRTOS/Source/tasks.c **** 	volatile portSTACK_TYPE	*pxTopOfStack;		/*< Points to the location of the last item placed on the 
 100:../../FreeRTOS/Source/tasks.c **** 
 101:../../FreeRTOS/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 102:../../FreeRTOS/Source/tasks.c **** 		xMPU_SETTINGS xMPUSettings;				/*< The MPU settings are defined as part of the port layer.  THIS 
 103:../../FreeRTOS/Source/tasks.c **** 	#endif
 104:../../FreeRTOS/Source/tasks.c **** 
 105:../../FreeRTOS/Source/tasks.c **** 	xListItem				xGenericListItem;		/*< The list that the state list item of a task is reference from 
 106:../../FreeRTOS/Source/tasks.c **** 	xListItem				xEventListItem;		/*< Used to reference a task from an event list. */
 107:../../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE	uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
 108:../../FreeRTOS/Source/tasks.c **** 	portSTACK_TYPE			*pxStack;			/*< Points to the start of the stack. */
 109:../../FreeRTOS/Source/tasks.c **** 	signed char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when c
 110:../../FreeRTOS/Source/tasks.c **** 
 111:../../FreeRTOS/Source/tasks.c **** 	#if ( portSTACK_GROWTH > 0 )
 112:../../FreeRTOS/Source/tasks.c **** 		portSTACK_TYPE *pxEndOfStack;			/*< Points to the end of the stack on architectures where the sta
 113:../../FreeRTOS/Source/tasks.c **** 	#endif
 114:../../FreeRTOS/Source/tasks.c **** 
 115:../../FreeRTOS/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 116:../../FreeRTOS/Source/tasks.c **** 		unsigned portBASE_TYPE uxCriticalNesting; /*< Holds the critical section nesting depth for ports 
 117:../../FreeRTOS/Source/tasks.c **** 	#endif
 118:../../FreeRTOS/Source/tasks.c **** 
 119:../../FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 120:../../FreeRTOS/Source/tasks.c **** 		unsigned portBASE_TYPE	uxTCBNumber;	/*< Stores a number that increments each time a TCB is create
 121:../../FreeRTOS/Source/tasks.c **** 		unsigned portBASE_TYPE  uxTaskNumber;	/*< Stores a number specifically for use by third party tra
 122:../../FreeRTOS/Source/tasks.c **** 	#endif
 123:../../FreeRTOS/Source/tasks.c **** 
 124:../../FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 125:../../FreeRTOS/Source/tasks.c **** 		unsigned portBASE_TYPE uxBasePriority;	/*< The priority last assigned to the task - used by the p
 126:../../FreeRTOS/Source/tasks.c **** 	#endif
 127:../../FreeRTOS/Source/tasks.c **** 
 128:../../FreeRTOS/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 129:../../FreeRTOS/Source/tasks.c **** 		pdTASK_HOOK_CODE pxTaskTag;
 130:../../FreeRTOS/Source/tasks.c **** 	#endif
 131:../../FreeRTOS/Source/tasks.c **** 
 132:../../FreeRTOS/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 133:../../FreeRTOS/Source/tasks.c **** 		unsigned long ulRunTimeCounter;			/*< Stores the amount of time the task has spent in the Running
 134:../../FreeRTOS/Source/tasks.c **** 	#endif
 135:../../FreeRTOS/Source/tasks.c **** 
 136:../../FreeRTOS/Source/tasks.c **** } tskTCB;
 137:../../FreeRTOS/Source/tasks.c **** 
 138:../../FreeRTOS/Source/tasks.c **** 
 139:../../FreeRTOS/Source/tasks.c **** /*
 140:../../FreeRTOS/Source/tasks.c ****  * Some kernel aware debuggers require the data the debugger needs access to to
 141:../../FreeRTOS/Source/tasks.c ****  * be global, rather than file scope.
 142:../../FreeRTOS/Source/tasks.c ****  */
 143:../../FreeRTOS/Source/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 144:../../FreeRTOS/Source/tasks.c **** 	#define static
 145:../../FreeRTOS/Source/tasks.c **** #endif
 146:../../FreeRTOS/Source/tasks.c **** 
 147:../../FreeRTOS/Source/tasks.c **** /*lint -e956 */
 148:../../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA tskTCB * volatile pxCurrentTCB = NULL;
 149:../../FreeRTOS/Source/tasks.c **** 
 150:../../FreeRTOS/Source/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 151:../../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList pxReadyTasksLists[ configMAX_PRIORITIES ];	/*< Prioritised ready tasks
 152:../../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList1;							/*< Delayed tasks. */
 153:../../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList2;							/*< Delayed tasks (two lists are used - one f
 154:../../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList * volatile pxDelayedTaskList ;				/*< Points to the delayed task list 
 155:../../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task 
 156:../../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList xPendingReadyList;							/*< Tasks that have been readied while the sc
 157:../../FreeRTOS/Source/tasks.c **** 
 158:../../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 159:../../FreeRTOS/Source/tasks.c **** 
 160:../../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static xList xTasksWaitingTermination;				/*< Tasks that have been deleted - but t
 161:../../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTasksDeleted = ( unsigned portBASE_TYPE )
 162:../../FreeRTOS/Source/tasks.c **** 
 163:../../FreeRTOS/Source/tasks.c **** #endif
 164:../../FreeRTOS/Source/tasks.c **** 
 165:../../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 166:../../FreeRTOS/Source/tasks.c **** 
 167:../../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static xList xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 168:../../FreeRTOS/Source/tasks.c **** 
 169:../../FreeRTOS/Source/tasks.c **** #endif
 170:../../FreeRTOS/Source/tasks.c **** 
 171:../../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
 172:../../FreeRTOS/Source/tasks.c **** 
 173:../../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static xTaskHandle xIdleTaskHandle = NULL;			/*< Holds the handle of the idle task
 174:../../FreeRTOS/Source/tasks.c **** 
 175:../../FreeRTOS/Source/tasks.c **** #endif
 176:../../FreeRTOS/Source/tasks.c **** 
 177:../../FreeRTOS/Source/tasks.c **** /* File private variables. --------------------------------*/
 178:../../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxCurrentNumberOfTasks 	= ( unsigned portBAS
 179:../../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile portTickType xTickCount 						= ( portTickType ) 0U;
 180:../../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTopUsedPriority	 				= tskIDLE_PRIORITY;
 181:../../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTopReadyPriority 		= tskIDLE_PRIORITY;
 182:../../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile signed portBASE_TYPE xSchedulerRunning 			= pdFALSE;
 183:../../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxSchedulerSuspended	 	= ( unsigned portBASE
 184:../../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxMissedTicks 			= ( unsigned portBASE_TYPE 
 185:../../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xMissedYield 						= ( portBASE_TYPE ) pdFALSE;
 186:../../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xNumOfOverflows 					= ( portBASE_TYPE ) 0;
 187:../../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTaskNumber 						= ( unsigned portBASE_TYPE ) 0U;
 188:../../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile portTickType xNextTaskUnblockTime				= ( portTickType ) portMAX_DEL
 189:../../FreeRTOS/Source/tasks.c **** 
 190:../../FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 191:../../FreeRTOS/Source/tasks.c **** 
 192:../../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static char pcStatsString[ 50 ] ;
 193:../../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static unsigned long ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/co
 194:../../FreeRTOS/Source/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
 195:../../FreeRTOS/Source/tasks.c **** 
 196:../../FreeRTOS/Source/tasks.c **** #endif
 197:../../FreeRTOS/Source/tasks.c **** 
 198:../../FreeRTOS/Source/tasks.c **** /* Debugging and trace facilities private variables and macros. ------------*/
 199:../../FreeRTOS/Source/tasks.c **** 
 200:../../FreeRTOS/Source/tasks.c **** /*
 201:../../FreeRTOS/Source/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 202:../../FreeRTOS/Source/tasks.c ****  * is used purely for checking the high water mark for tasks.
 203:../../FreeRTOS/Source/tasks.c ****  */
 204:../../FreeRTOS/Source/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
 205:../../FreeRTOS/Source/tasks.c **** 
 206:../../FreeRTOS/Source/tasks.c **** /*
 207:../../FreeRTOS/Source/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 208:../../FreeRTOS/Source/tasks.c ****  */
 209:../../FreeRTOS/Source/tasks.c **** #define tskBLOCKED_CHAR		( ( signed char ) 'B' )
 210:../../FreeRTOS/Source/tasks.c **** #define tskREADY_CHAR		( ( signed char ) 'R' )
 211:../../FreeRTOS/Source/tasks.c **** #define tskDELETED_CHAR		( ( signed char ) 'D' )
 212:../../FreeRTOS/Source/tasks.c **** #define tskSUSPENDED_CHAR	( ( signed char ) 'S' )
 213:../../FreeRTOS/Source/tasks.c **** 
 214:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 215:../../FreeRTOS/Source/tasks.c **** 
 216:../../FreeRTOS/Source/tasks.c **** #if configUSE_PORT_OPTIMISED_TASK_SELECTION == 0
 217:../../FreeRTOS/Source/tasks.c **** 
 218:../../FreeRTOS/Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
 219:../../FreeRTOS/Source/tasks.c **** 	performed in a generic way that is not optimised to any particular
 220:../../FreeRTOS/Source/tasks.c **** 	microcontroller architecture. */
 221:../../FreeRTOS/Source/tasks.c **** 
 222:../../FreeRTOS/Source/tasks.c **** 	/* uxTopReadyPriority holds the priority of the highest priority ready
 223:../../FreeRTOS/Source/tasks.c **** 	state task. */
 224:../../FreeRTOS/Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )																		\
 225:../../FreeRTOS/Source/tasks.c **** 	{																													\
 226:../../FreeRTOS/Source/tasks.c **** 		if( ( uxPriority ) > uxTopReadyPriority )																		\
 227:../../FreeRTOS/Source/tasks.c **** 		{																												\
 228:../../FreeRTOS/Source/tasks.c **** 			uxTopReadyPriority = ( uxPriority );																		\
 229:../../FreeRTOS/Source/tasks.c **** 		}																												\
 230:../../FreeRTOS/Source/tasks.c **** 	} /* taskRECORD_READY_PRIORITY */
 231:../../FreeRTOS/Source/tasks.c **** 
 232:../../FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 233:../../FreeRTOS/Source/tasks.c **** 
 234:../../FreeRTOS/Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()																			\
 235:../../FreeRTOS/Source/tasks.c **** 	{																													\
 236:../../FreeRTOS/Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */												\
 237:../../FreeRTOS/Source/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )										\
 238:../../FreeRTOS/Source/tasks.c **** 		{																												\
 239:../../FreeRTOS/Source/tasks.c **** 			configASSERT( uxTopReadyPriority );																			\
 240:../../FreeRTOS/Source/tasks.c **** 			--uxTopReadyPriority;																						\
 241:../../FreeRTOS/Source/tasks.c **** 		}																												\
 242:../../FreeRTOS/Source/tasks.c **** 																														\
 243:../../FreeRTOS/Source/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of										\
 244:../../FreeRTOS/Source/tasks.c **** 		the	same priority get an equal share of the processor time. */													\
 245:../../FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );						\
 246:../../FreeRTOS/Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
 247:../../FreeRTOS/Source/tasks.c **** 
 248:../../FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 249:../../FreeRTOS/Source/tasks.c **** 
 250:../../FreeRTOS/Source/tasks.c **** 	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
 251:../../FreeRTOS/Source/tasks.c **** 	they are only required when a port optimised method of task selection is
 252:../../FreeRTOS/Source/tasks.c **** 	being used. */
 253:../../FreeRTOS/Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )
 254:../../FreeRTOS/Source/tasks.c **** 	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
 255:../../FreeRTOS/Source/tasks.c **** 
 256:../../FreeRTOS/Source/tasks.c **** #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 257:../../FreeRTOS/Source/tasks.c **** 
 258:../../FreeRTOS/Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
 259:../../FreeRTOS/Source/tasks.c **** 	performed in a way that is tailored to the particular microcontroller
 260:../../FreeRTOS/Source/tasks.c **** 	architecture being used. */
 261:../../FreeRTOS/Source/tasks.c **** 
 262:../../FreeRTOS/Source/tasks.c **** 	/* A port optimised version is provided.  Call the port defined macros. */
 263:../../FreeRTOS/Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyP
 264:../../FreeRTOS/Source/tasks.c **** 
 265:../../FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 266:../../FreeRTOS/Source/tasks.c **** 
 267:../../FreeRTOS/Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
 268:../../FreeRTOS/Source/tasks.c **** 	{																								\
 269:../../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxTopPriority;															\
 270:../../FreeRTOS/Source/tasks.c **** 																									\
 271:../../FreeRTOS/Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */							\
 272:../../FreeRTOS/Source/tasks.c **** 		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
 273:../../FreeRTOS/Source/tasks.c **** 		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
 274:../../FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
 275:../../FreeRTOS/Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
 276:../../FreeRTOS/Source/tasks.c **** 
 277:../../FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 278:../../FreeRTOS/Source/tasks.c **** 
 279:../../FreeRTOS/Source/tasks.c **** 	/* A port optimised version is provided, call it only if the TCB being reset
 280:../../FreeRTOS/Source/tasks.c **** 	is being referenced from a ready list.  If it is referenced from a delayed
 281:../../FreeRTOS/Source/tasks.c **** 	or suspended list then it won't be in a ready list. */
 282:../../FreeRTOS/Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )													\
 283:../../FreeRTOS/Source/tasks.c **** 	{																								\
 284:../../FreeRTOS/Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == 0 )				\
 285:../../FreeRTOS/Source/tasks.c **** 		{																							\
 286:../../FreeRTOS/Source/tasks.c **** 			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );						\
 287:../../FreeRTOS/Source/tasks.c **** 		}																							\
 288:../../FreeRTOS/Source/tasks.c **** 	}
 289:../../FreeRTOS/Source/tasks.c **** 
 290:../../FreeRTOS/Source/tasks.c **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 291:../../FreeRTOS/Source/tasks.c **** 
 292:../../FreeRTOS/Source/tasks.c **** /*
 293:../../FreeRTOS/Source/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready queue for
 294:../../FreeRTOS/Source/tasks.c ****  * the task.  It is inserted at the end of the list.  One quirk of this is
 295:../../FreeRTOS/Source/tasks.c ****  * that if the task being inserted is at the same priority as the currently
 296:../../FreeRTOS/Source/tasks.c ****  * executing task, then it will only be rescheduled after the currently
 297:../../FreeRTOS/Source/tasks.c ****  * executing task has been rescheduled.
 298:../../FreeRTOS/Source/tasks.c ****  */
 299:../../FreeRTOS/Source/tasks.c **** #define prvAddTaskToReadyQueue( pxTCB )																				\
 300:../../FreeRTOS/Source/tasks.c **** 	traceMOVED_TASK_TO_READY_STATE( pxTCB )																			\
 301:../../FreeRTOS/Source/tasks.c **** 	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );																\
 302:../../FreeRTOS/Source/tasks.c **** 	vListInsertEnd( ( xList * ) &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGeneri
 303:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 304:../../FreeRTOS/Source/tasks.c **** 
 305:../../FreeRTOS/Source/tasks.c **** /*
 306:../../FreeRTOS/Source/tasks.c ****  * Macro that looks at the list of tasks that are currently delayed to see if
 307:../../FreeRTOS/Source/tasks.c ****  * any require waking.
 308:../../FreeRTOS/Source/tasks.c ****  *
 309:../../FreeRTOS/Source/tasks.c ****  * Tasks are stored in the queue in the order of their wake time - meaning
 310:../../FreeRTOS/Source/tasks.c ****  * once one tasks has been found whose timer has not expired we need not look
 311:../../FreeRTOS/Source/tasks.c ****  * any further down the list.
 312:../../FreeRTOS/Source/tasks.c ****  */
 313:../../FreeRTOS/Source/tasks.c **** #define prvCheckDelayedTasks()															\
 314:../../FreeRTOS/Source/tasks.c **** {																						\
 315:../../FreeRTOS/Source/tasks.c **** portTickType xItemValue;																\
 316:../../FreeRTOS/Source/tasks.c **** 																						\
 317:../../FreeRTOS/Source/tasks.c **** 	/* Is the tick count greater than or equal to the wake time of the first			\
 318:../../FreeRTOS/Source/tasks.c **** 	task referenced from the delayed tasks list? */										\
 319:../../FreeRTOS/Source/tasks.c **** 	if( xTickCount >= xNextTaskUnblockTime )											\
 320:../../FreeRTOS/Source/tasks.c **** 	{																					\
 321:../../FreeRTOS/Source/tasks.c **** 		for( ;; )																		\
 322:../../FreeRTOS/Source/tasks.c **** 		{																				\
 323:../../FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )						\
 324:../../FreeRTOS/Source/tasks.c **** 			{																			\
 325:../../FreeRTOS/Source/tasks.c **** 				/* The delayed list is empty.  Set xNextTaskUnblockTime to the			\
 326:../../FreeRTOS/Source/tasks.c **** 				maximum possible value so it is extremely unlikely that the				\
 327:../../FreeRTOS/Source/tasks.c **** 				if( xTickCount >= xNextTaskUnblockTime ) test will pass next			\
 328:../../FreeRTOS/Source/tasks.c **** 				time through. */														\
 329:../../FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime = portMAX_DELAY;									\
 330:../../FreeRTOS/Source/tasks.c **** 				break;																	\
 331:../../FreeRTOS/Source/tasks.c **** 			}																			\
 332:../../FreeRTOS/Source/tasks.c **** 			else																		\
 333:../../FreeRTOS/Source/tasks.c **** 			{																			\
 334:../../FreeRTOS/Source/tasks.c **** 				/* The delayed list is not empty, get the value of the item at			\
 335:../../FreeRTOS/Source/tasks.c **** 				the head of the delayed list.  This is the time at which the			\
 336:../../FreeRTOS/Source/tasks.c **** 				task at the head of the delayed list should be removed from				\
 337:../../FreeRTOS/Source/tasks.c **** 				the Blocked state. */													\
 338:../../FreeRTOS/Source/tasks.c **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );	\
 339:../../FreeRTOS/Source/tasks.c **** 				xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );	\
 340:../../FreeRTOS/Source/tasks.c **** 																						\
 341:../../FreeRTOS/Source/tasks.c **** 				if( xTickCount < xItemValue )											\
 342:../../FreeRTOS/Source/tasks.c **** 				{																		\
 343:../../FreeRTOS/Source/tasks.c **** 					/* It is not time to unblock this item yet, but the item			\
 344:../../FreeRTOS/Source/tasks.c **** 					value is the time at which the task at the head of the				\
 345:../../FreeRTOS/Source/tasks.c **** 					blocked list should be removed from the Blocked state -				\
 346:../../FreeRTOS/Source/tasks.c **** 					so record the item value in xNextTaskUnblockTime. */				\
 347:../../FreeRTOS/Source/tasks.c **** 					xNextTaskUnblockTime = xItemValue;									\
 348:../../FreeRTOS/Source/tasks.c **** 					break;																\
 349:../../FreeRTOS/Source/tasks.c **** 				}																		\
 350:../../FreeRTOS/Source/tasks.c **** 																						\
 351:../../FreeRTOS/Source/tasks.c **** 				/* It is time to remove the item from the Blocked state. */				\
 352:../../FreeRTOS/Source/tasks.c **** 				uxListRemove( &( pxTCB->xGenericListItem ) );							\
 353:../../FreeRTOS/Source/tasks.c **** 																						\
 354:../../FreeRTOS/Source/tasks.c **** 				/* Is the task waiting on an event also? */								\
 355:../../FreeRTOS/Source/tasks.c **** 				if( pxTCB->xEventListItem.pvContainer != NULL )							\
 356:../../FreeRTOS/Source/tasks.c **** 				{																		\
 357:../../FreeRTOS/Source/tasks.c **** 					uxListRemove( &( pxTCB->xEventListItem ) );							\
 358:../../FreeRTOS/Source/tasks.c **** 				}																		\
 359:../../FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );										\
 360:../../FreeRTOS/Source/tasks.c **** 			}																			\
 361:../../FreeRTOS/Source/tasks.c **** 		}																				\
 362:../../FreeRTOS/Source/tasks.c **** 	}																					\
 363:../../FreeRTOS/Source/tasks.c **** }
 364:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 365:../../FreeRTOS/Source/tasks.c **** 
 366:../../FreeRTOS/Source/tasks.c **** /*
 367:../../FreeRTOS/Source/tasks.c ****  * Several functions take an xTaskHandle parameter that can optionally be NULL,
 368:../../FreeRTOS/Source/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 369:../../FreeRTOS/Source/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 370:../../FreeRTOS/Source/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 371:../../FreeRTOS/Source/tasks.c ****  */
 372:../../FreeRTOS/Source/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( tskTCB * ) pxCurrentTCB : ( 
 373:../../FreeRTOS/Source/tasks.c **** 
 374:../../FreeRTOS/Source/tasks.c **** /* Callback function prototypes. --------------------------*/
 375:../../FreeRTOS/Source/tasks.c **** extern void vApplicationStackOverflowHook( xTaskHandle pxTask, signed char *pcTaskName ) __attribut
 376:../../FreeRTOS/Source/tasks.c **** extern void vApplicationTickHook( void );
 377:../../FreeRTOS/Source/tasks.c **** 
 378:../../FreeRTOS/Source/tasks.c **** /* File private functions. --------------------------------*/
 379:../../FreeRTOS/Source/tasks.c **** 
 380:../../FreeRTOS/Source/tasks.c **** /*
 381:../../FreeRTOS/Source/tasks.c ****  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
 382:../../FreeRTOS/Source/tasks.c ****  * into the TCB structure.
 383:../../FreeRTOS/Source/tasks.c ****  */
 384:../../FreeRTOS/Source/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
 385:../../FreeRTOS/Source/tasks.c **** 
 386:../../FreeRTOS/Source/tasks.c **** /*
 387:../../FreeRTOS/Source/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 388:../../FreeRTOS/Source/tasks.c ****  * automatically upon the creation of the first task.
 389:../../FreeRTOS/Source/tasks.c ****  */
 390:../../FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 391:../../FreeRTOS/Source/tasks.c **** 
 392:../../FreeRTOS/Source/tasks.c **** /*
 393:../../FreeRTOS/Source/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 394:../../FreeRTOS/Source/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 395:../../FreeRTOS/Source/tasks.c ****  * creation of the first user task.
 396:../../FreeRTOS/Source/tasks.c ****  *
 397:../../FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 398:../../FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 399:../../FreeRTOS/Source/tasks.c ****  *
 400:../../FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
 401:../../FreeRTOS/Source/tasks.c ****  *
 402:../../FreeRTOS/Source/tasks.c ****  */
 403:../../FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 404:../../FreeRTOS/Source/tasks.c **** 
 405:../../FreeRTOS/Source/tasks.c **** /*
 406:../../FreeRTOS/Source/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 407:../../FreeRTOS/Source/tasks.c ****  * including the stack pointed to by the TCB.
 408:../../FreeRTOS/Source/tasks.c ****  *
 409:../../FreeRTOS/Source/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 410:../../FreeRTOS/Source/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 411:../../FreeRTOS/Source/tasks.c ****  */
 412:../../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 413:../../FreeRTOS/Source/tasks.c **** 
 414:../../FreeRTOS/Source/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB ) PRIVILEGED_FUNCTION;
 415:../../FreeRTOS/Source/tasks.c **** 
 416:../../FreeRTOS/Source/tasks.c **** #endif
 417:../../FreeRTOS/Source/tasks.c **** 
 418:../../FreeRTOS/Source/tasks.c **** /*
 419:../../FreeRTOS/Source/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 420:../../FreeRTOS/Source/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 421:../../FreeRTOS/Source/tasks.c ****  * and its TCB deleted.
 422:../../FreeRTOS/Source/tasks.c ****  */
 423:../../FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 424:../../FreeRTOS/Source/tasks.c **** 
 425:../../FreeRTOS/Source/tasks.c **** /*
 426:../../FreeRTOS/Source/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 427:../../FreeRTOS/Source/tasks.c ****  * either the current or the overflow delayed task list.
 428:../../FreeRTOS/Source/tasks.c ****  */
 429:../../FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake ) PRIVILEGED_FUNCTION;
 430:../../FreeRTOS/Source/tasks.c **** 
 431:../../FreeRTOS/Source/tasks.c **** /*
 432:../../FreeRTOS/Source/tasks.c ****  * Allocates memory from the heap for a TCB and associated stack.  Checks the
 433:../../FreeRTOS/Source/tasks.c ****  * allocation was successful.
 434:../../FreeRTOS/Source/tasks.c ****  */
 435:../../FreeRTOS/Source/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
 436:../../FreeRTOS/Source/tasks.c **** 
 437:../../FreeRTOS/Source/tasks.c **** /*
 438:../../FreeRTOS/Source/tasks.c ****  * Called from vTaskList.  vListTasks details all the tasks currently under
 439:../../FreeRTOS/Source/tasks.c ****  * control of the scheduler.  The tasks may be in one of a number of lists.
 440:../../FreeRTOS/Source/tasks.c ****  * prvListTaskWithinSingleList accepts a list and details the tasks from
 441:../../FreeRTOS/Source/tasks.c ****  * within just that list.
 442:../../FreeRTOS/Source/tasks.c ****  *
 443:../../FreeRTOS/Source/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 444:../../FreeRTOS/Source/tasks.c ****  * NORMAL APPLICATION CODE.
 445:../../FreeRTOS/Source/tasks.c ****  */
 446:../../FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 447:../../FreeRTOS/Source/tasks.c **** 
 448:../../FreeRTOS/Source/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
 449:../../FreeRTOS/Source/tasks.c **** 
 450:../../FreeRTOS/Source/tasks.c **** #endif
 451:../../FreeRTOS/Source/tasks.c **** 
 452:../../FreeRTOS/Source/tasks.c **** /*
 453:../../FreeRTOS/Source/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 454:../../FreeRTOS/Source/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 455:../../FreeRTOS/Source/tasks.c ****  * determining how much of the stack remains at the original preset value.
 456:../../FreeRTOS/Source/tasks.c ****  */
 457:../../FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 458:../../FreeRTOS/Source/tasks.c **** 
 459:../../FreeRTOS/Source/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte ) PRIVILEGED_F
 460:../../FreeRTOS/Source/tasks.c **** 
 461:../../FreeRTOS/Source/tasks.c **** #endif
 462:../../FreeRTOS/Source/tasks.c **** 
 463:../../FreeRTOS/Source/tasks.c **** /*
 464:../../FreeRTOS/Source/tasks.c ****  * Return the amount of time, in ticks, that will pass before the kernel will
 465:../../FreeRTOS/Source/tasks.c ****  * next move a task from the Blocked state to the Running state.
 466:../../FreeRTOS/Source/tasks.c ****  *
 467:../../FreeRTOS/Source/tasks.c ****  * This conditional compilation should use inequality to 0, not equality to 1.
 468:../../FreeRTOS/Source/tasks.c ****  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 469:../../FreeRTOS/Source/tasks.c ****  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 470:../../FreeRTOS/Source/tasks.c ****  * set to a value other than 1.
 471:../../FreeRTOS/Source/tasks.c ****  */
 472:../../FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
 473:../../FreeRTOS/Source/tasks.c **** 
 474:../../FreeRTOS/Source/tasks.c **** 	static portTickType prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
 475:../../FreeRTOS/Source/tasks.c **** 
 476:../../FreeRTOS/Source/tasks.c **** #endif
 477:../../FreeRTOS/Source/tasks.c **** 
 478:../../FreeRTOS/Source/tasks.c **** /*lint +e956 */
 479:../../FreeRTOS/Source/tasks.c **** 
 480:../../FreeRTOS/Source/tasks.c **** 
 481:../../FreeRTOS/Source/tasks.c **** 
 482:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
 483:../../FreeRTOS/Source/tasks.c ****  * TASK CREATION API documented in task.h
 484:../../FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
 485:../../FreeRTOS/Source/tasks.c **** 
 486:../../FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, 
 487:../../FreeRTOS/Source/tasks.c **** {
 163               	.LM0:
 164               	.LFBB1:
 165 0000 AF92      		push r10
 166 0002 BF92      		push r11
 167 0004 CF92      		push r12
 168 0006 DF92      		push r13
 169 0008 EF92      		push r14
 170 000a FF92      		push r15
 171 000c 0F93      		push r16
 172 000e 1F93      		push r17
 173 0010 DF93      		push r29
 174 0012 CF93      		push r28
 175 0014 CDB7      		in r28,__SP_L__
 176 0016 DEB7      		in r29,__SP_H__
 177 0018 6497      		sbiw r28,20
 178 001a 0FB6      		in __tmp_reg__,__SREG__
 179 001c F894      		cli
 180 001e DEBF      		out __SP_H__,r29
 181 0020 0FBE      		out __SREG__,__tmp_reg__
 182 0022 CDBF      		out __SP_L__,r28
 183               	/* prologue: function */
 184               	/* frame size = 20 */
 185 0024 9F83      		std Y+7,r25
 186 0026 8E83      		std Y+6,r24
 187 0028 7987      		std Y+9,r23
 188 002a 6887      		std Y+8,r22
 189 002c 5B87      		std Y+11,r21
 190 002e 4A87      		std Y+10,r20
 191 0030 3D87      		std Y+13,r19
 192 0032 2C87      		std Y+12,r18
 193 0034 0E87      		std Y+14,r16
 194 0036 F88A      		std Y+16,r15
 195 0038 EF86      		std Y+15,r14
 196 003a DA8A      		std Y+18,r13
 197 003c C98A      		std Y+17,r12
 198 003e BC8A      		std Y+20,r11
 199 0040 AB8A      		std Y+19,r10
 488:../../FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xReturn;
 489:../../FreeRTOS/Source/tasks.c **** tskTCB * pxNewTCB;
 490:../../FreeRTOS/Source/tasks.c **** 
 491:../../FreeRTOS/Source/tasks.c **** 	configASSERT( pxTaskCode );
 492:../../FreeRTOS/Source/tasks.c **** 	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
 493:../../FreeRTOS/Source/tasks.c **** 
 494:../../FreeRTOS/Source/tasks.c **** 	/* Allocate the memory required by the TCB and stack for the new task,
 495:../../FreeRTOS/Source/tasks.c **** 	checking that the allocation was successful. */
 496:../../FreeRTOS/Source/tasks.c **** 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 201               	.LM1:
 202 0042 8A85      		ldd r24,Y+10
 203 0044 9B85      		ldd r25,Y+11
 204 0046 2989      		ldd r18,Y+17
 205 0048 3A89      		ldd r19,Y+18
 206 004a B901      		movw r22,r18
 207 004c 0E94 0000 		call prvAllocateTCBAndStack
 208 0050 9C83      		std Y+4,r25
 209 0052 8B83      		std Y+3,r24
 497:../../FreeRTOS/Source/tasks.c **** 
 498:../../FreeRTOS/Source/tasks.c **** 	if( pxNewTCB != NULL )
 211               	.LM2:
 212 0054 8B81      		ldd r24,Y+3
 213 0056 9C81      		ldd r25,Y+4
 214 0058 0097      		sbiw r24,0
 215 005a 01F4      		brne .+2
 216 005c 00C0      		rjmp .L2
 217               	.LBB2:
 499:../../FreeRTOS/Source/tasks.c **** 	{
 500:../../FreeRTOS/Source/tasks.c **** 		portSTACK_TYPE *pxTopOfStack;
 501:../../FreeRTOS/Source/tasks.c **** 
 502:../../FreeRTOS/Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 503:../../FreeRTOS/Source/tasks.c **** 			/* Should the task be created in privileged mode? */
 504:../../FreeRTOS/Source/tasks.c **** 			portBASE_TYPE xRunPrivileged;
 505:../../FreeRTOS/Source/tasks.c **** 			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 506:../../FreeRTOS/Source/tasks.c **** 			{
 507:../../FreeRTOS/Source/tasks.c **** 				xRunPrivileged = pdTRUE;
 508:../../FreeRTOS/Source/tasks.c **** 			}
 509:../../FreeRTOS/Source/tasks.c **** 			else
 510:../../FreeRTOS/Source/tasks.c **** 			{
 511:../../FreeRTOS/Source/tasks.c **** 				xRunPrivileged = pdFALSE;
 512:../../FreeRTOS/Source/tasks.c **** 			}
 513:../../FreeRTOS/Source/tasks.c **** 			uxPriority &= ~portPRIVILEGE_BIT;
 514:../../FreeRTOS/Source/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS == 1 */
 515:../../FreeRTOS/Source/tasks.c **** 
 516:../../FreeRTOS/Source/tasks.c **** 		/* Calculate the top of stack address.  This depends on whether the
 517:../../FreeRTOS/Source/tasks.c **** 		stack grows from high memory to low (as per the 80x86) or visa versa.
 518:../../FreeRTOS/Source/tasks.c **** 		portSTACK_GROWTH is used to make the result positive or negative as
 519:../../FreeRTOS/Source/tasks.c **** 		required by the port. */
 520:../../FreeRTOS/Source/tasks.c **** 		#if( portSTACK_GROWTH < 0 )
 521:../../FreeRTOS/Source/tasks.c **** 		{
 522:../../FreeRTOS/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 219               	.LM3:
 220 005e EB81      		ldd r30,Y+3
 221 0060 FC81      		ldd r31,Y+4
 222 0062 2789      		ldd r18,Z+23
 223 0064 308D      		ldd r19,Z+24
 224 0066 8A85      		ldd r24,Y+10
 225 0068 9B85      		ldd r25,Y+11
 226 006a 0197      		sbiw r24,1
 227 006c 820F      		add r24,r18
 228 006e 931F      		adc r25,r19
 229 0070 9A83      		std Y+2,r25
 230 0072 8983      		std Y+1,r24
 523:../../FreeRTOS/Source/tasks.c **** 			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINT
 524:../../FreeRTOS/Source/tasks.c **** 
 525:../../FreeRTOS/Source/tasks.c **** 			/* Check the alignment of the calculated top of stack is correct. */
 526:../../FreeRTOS/Source/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) =
 527:../../FreeRTOS/Source/tasks.c **** 		}
 528:../../FreeRTOS/Source/tasks.c **** 		#else
 529:../../FreeRTOS/Source/tasks.c **** 		{
 530:../../FreeRTOS/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack;
 531:../../FreeRTOS/Source/tasks.c **** 
 532:../../FreeRTOS/Source/tasks.c **** 			/* Check the alignment of the stack buffer is correct. */
 533:../../FreeRTOS/Source/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxNewTCB->pxStack & ( unsigned long ) portBYTE_ALIGNMENT_MAS
 534:../../FreeRTOS/Source/tasks.c **** 
 535:../../FreeRTOS/Source/tasks.c **** 			/* If we want to use stack checking on architectures that use
 536:../../FreeRTOS/Source/tasks.c **** 			a positive stack growth direction then we also need to store the
 537:../../FreeRTOS/Source/tasks.c **** 			other extreme of the stack space. */
 538:../../FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 539:../../FreeRTOS/Source/tasks.c **** 		}
 540:../../FreeRTOS/Source/tasks.c **** 		#endif
 541:../../FreeRTOS/Source/tasks.c **** 
 542:../../FreeRTOS/Source/tasks.c **** 		/* Setup the newly allocated TCB with the initial state of the task. */
 543:../../FreeRTOS/Source/tasks.c **** 		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 232               	.LM4:
 233 0074 8B81      		ldd r24,Y+3
 234 0076 9C81      		ldd r25,Y+4
 235 0078 2885      		ldd r18,Y+8
 236 007a 3985      		ldd r19,Y+9
 237 007c EB89      		ldd r30,Y+19
 238 007e FC89      		ldd r31,Y+20
 239 0080 AA85      		ldd r26,Y+10
 240 0082 BB85      		ldd r27,Y+11
 241 0084 B901      		movw r22,r18
 242 0086 4E85      		ldd r20,Y+14
 243 0088 9F01      		movw r18,r30
 244 008a 8D01      		movw r16,r26
 245 008c 0E94 0000 		call prvInitialiseTCBVariables
 544:../../FreeRTOS/Source/tasks.c **** 
 545:../../FreeRTOS/Source/tasks.c **** 		/* Initialize the TCB stack to look as if the task was already running,
 546:../../FreeRTOS/Source/tasks.c **** 		but had been interrupted by the scheduler.  The return address is set
 547:../../FreeRTOS/Source/tasks.c **** 		to the start of the task function. Once the stack has been initialised
 548:../../FreeRTOS/Source/tasks.c **** 		the	top of stack variable is updated. */
 549:../../FreeRTOS/Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 550:../../FreeRTOS/Source/tasks.c **** 		{
 551:../../FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
 552:../../FreeRTOS/Source/tasks.c **** 		}
 553:../../FreeRTOS/Source/tasks.c **** 		#else
 554:../../FreeRTOS/Source/tasks.c **** 		{
 555:../../FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 247               	.LM5:
 248 0090 8981      		ldd r24,Y+1
 249 0092 9A81      		ldd r25,Y+2
 250 0094 2E81      		ldd r18,Y+6
 251 0096 3F81      		ldd r19,Y+7
 252 0098 4C85      		ldd r20,Y+12
 253 009a 5D85      		ldd r21,Y+13
 254 009c B901      		movw r22,r18
 255 009e 0E94 0000 		call pxPortInitialiseStack
 256 00a2 EB81      		ldd r30,Y+3
 257 00a4 FC81      		ldd r31,Y+4
 258 00a6 9183      		std Z+1,r25
 259 00a8 8083      		st Z,r24
 556:../../FreeRTOS/Source/tasks.c **** 		}
 557:../../FreeRTOS/Source/tasks.c **** 		#endif
 558:../../FreeRTOS/Source/tasks.c **** 
 559:../../FreeRTOS/Source/tasks.c **** 		/* Check the alignment of the initialised stack. */
 560:../../FreeRTOS/Source/tasks.c **** 		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long
 561:../../FreeRTOS/Source/tasks.c **** 
 562:../../FreeRTOS/Source/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 261               	.LM6:
 262 00aa 8F85      		ldd r24,Y+15
 263 00ac 9889      		ldd r25,Y+16
 264 00ae 0097      		sbiw r24,0
 265 00b0 01F0      		breq .L3
 563:../../FreeRTOS/Source/tasks.c **** 		{
 564:../../FreeRTOS/Source/tasks.c **** 			/* Pass the TCB out - in an anonymous way.  The calling function/
 565:../../FreeRTOS/Source/tasks.c **** 			task can use this as a handle to delete the task later if
 566:../../FreeRTOS/Source/tasks.c **** 			required.*/
 567:../../FreeRTOS/Source/tasks.c **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 267               	.LM7:
 268 00b2 EF85      		ldd r30,Y+15
 269 00b4 F889      		ldd r31,Y+16
 270 00b6 8B81      		ldd r24,Y+3
 271 00b8 9C81      		ldd r25,Y+4
 272 00ba 9183      		std Z+1,r25
 273 00bc 8083      		st Z,r24
 274               	.L3:
 568:../../FreeRTOS/Source/tasks.c **** 		}
 569:../../FreeRTOS/Source/tasks.c **** 
 570:../../FreeRTOS/Source/tasks.c **** 		/* We are going to manipulate the task queues to add this task to a
 571:../../FreeRTOS/Source/tasks.c **** 		ready list, so must make sure no interrupts occur. */
 572:../../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 276               	.LM8:
 277               	/* #APP */
 278               	 ;  572 "../../FreeRTOS/Source/tasks.c" 1
 279 00be 0FB6      		in		__tmp_reg__, __SREG__
 280               	 ;  0 "" 2
 281               	 ;  572 "../../FreeRTOS/Source/tasks.c" 1
 282 00c0 F894      		cli
 283               	 ;  0 "" 2
 284               	 ;  572 "../../FreeRTOS/Source/tasks.c" 1
 285 00c2 0F92      		push	__tmp_reg__
 286               	 ;  0 "" 2
 573:../../FreeRTOS/Source/tasks.c **** 		{
 574:../../FreeRTOS/Source/tasks.c **** 			uxCurrentNumberOfTasks++;
 288               	.LM9:
 289               	/* #NOAPP */
 290 00c4 8091 0000 		lds r24,uxCurrentNumberOfTasks
 291 00c8 8F5F      		subi r24,lo8(-(1))
 292 00ca 8093 0000 		sts uxCurrentNumberOfTasks,r24
 575:../../FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB == NULL )
 294               	.LM10:
 295 00ce 8091 0000 		lds r24,pxCurrentTCB
 296 00d2 9091 0000 		lds r25,(pxCurrentTCB)+1
 297 00d6 0097      		sbiw r24,0
 298 00d8 01F4      		brne .L4
 576:../../FreeRTOS/Source/tasks.c **** 			{
 577:../../FreeRTOS/Source/tasks.c **** 				/* There are no other tasks, or all the other tasks are in
 578:../../FreeRTOS/Source/tasks.c **** 				the suspended state - make this the current task. */
 579:../../FreeRTOS/Source/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 300               	.LM11:
 301 00da 8B81      		ldd r24,Y+3
 302 00dc 9C81      		ldd r25,Y+4
 303 00de 9093 0000 		sts (pxCurrentTCB)+1,r25
 304 00e2 8093 0000 		sts pxCurrentTCB,r24
 580:../../FreeRTOS/Source/tasks.c **** 
 581:../../FreeRTOS/Source/tasks.c **** 				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 306               	.LM12:
 307 00e6 8091 0000 		lds r24,uxCurrentNumberOfTasks
 308 00ea 8130      		cpi r24,lo8(1)
 309 00ec 01F4      		brne .L6
 582:../../FreeRTOS/Source/tasks.c **** 				{
 583:../../FreeRTOS/Source/tasks.c **** 					/* This is the first task to be created so do the preliminary
 584:../../FreeRTOS/Source/tasks.c **** 					initialisation required.  We will not recover if this call
 585:../../FreeRTOS/Source/tasks.c **** 					fails, but we will report the failure. */
 586:../../FreeRTOS/Source/tasks.c **** 					prvInitialiseTaskLists();
 311               	.LM13:
 312 00ee 0E94 0000 		call prvInitialiseTaskLists
 313 00f2 00C0      		rjmp .L6
 314               	.L4:
 587:../../FreeRTOS/Source/tasks.c **** 				}
 588:../../FreeRTOS/Source/tasks.c **** 			}
 589:../../FreeRTOS/Source/tasks.c **** 			else
 590:../../FreeRTOS/Source/tasks.c **** 			{
 591:../../FreeRTOS/Source/tasks.c **** 				/* If the scheduler is not already running, make this task the
 592:../../FreeRTOS/Source/tasks.c **** 				current task if it is the highest priority task to be created
 593:../../FreeRTOS/Source/tasks.c **** 				so far. */
 594:../../FreeRTOS/Source/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 316               	.LM14:
 317 00f4 8091 0000 		lds r24,xSchedulerRunning
 318 00f8 8823      		tst r24
 319 00fa 01F4      		brne .L6
 595:../../FreeRTOS/Source/tasks.c **** 				{
 596:../../FreeRTOS/Source/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 321               	.LM15:
 322 00fc E091 0000 		lds r30,pxCurrentTCB
 323 0100 F091 0000 		lds r31,(pxCurrentTCB)+1
 324 0104 9689      		ldd r25,Z+22
 325 0106 8E85      		ldd r24,Y+14
 326 0108 8917      		cp r24,r25
 327 010a 00F0      		brlo .L6
 597:../../FreeRTOS/Source/tasks.c **** 					{
 598:../../FreeRTOS/Source/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 329               	.LM16:
 330 010c 8B81      		ldd r24,Y+3
 331 010e 9C81      		ldd r25,Y+4
 332 0110 9093 0000 		sts (pxCurrentTCB)+1,r25
 333 0114 8093 0000 		sts pxCurrentTCB,r24
 334               	.L6:
 599:../../FreeRTOS/Source/tasks.c **** 					}
 600:../../FreeRTOS/Source/tasks.c **** 				}
 601:../../FreeRTOS/Source/tasks.c **** 			}
 602:../../FreeRTOS/Source/tasks.c **** 
 603:../../FreeRTOS/Source/tasks.c **** 			/* Remember the top priority to make context switching faster.  Use
 604:../../FreeRTOS/Source/tasks.c **** 			the priority in pxNewTCB as this has been capped to a valid value. */
 605:../../FreeRTOS/Source/tasks.c **** 			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 336               	.LM17:
 337 0118 EB81      		ldd r30,Y+3
 338 011a FC81      		ldd r31,Y+4
 339 011c 9689      		ldd r25,Z+22
 340 011e 8091 0000 		lds r24,uxTopUsedPriority
 341 0122 8917      		cp r24,r25
 342 0124 00F4      		brsh .L7
 606:../../FreeRTOS/Source/tasks.c **** 			{
 607:../../FreeRTOS/Source/tasks.c **** 				uxTopUsedPriority = pxNewTCB->uxPriority;
 344               	.LM18:
 345 0126 EB81      		ldd r30,Y+3
 346 0128 FC81      		ldd r31,Y+4
 347 012a 8689      		ldd r24,Z+22
 348 012c 8093 0000 		sts uxTopUsedPriority,r24
 349               	.L7:
 608:../../FreeRTOS/Source/tasks.c **** 			}
 609:../../FreeRTOS/Source/tasks.c **** 
 610:../../FreeRTOS/Source/tasks.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 611:../../FreeRTOS/Source/tasks.c **** 			{
 612:../../FreeRTOS/Source/tasks.c **** 				/* Add a counter into the TCB for tracing only. */
 613:../../FreeRTOS/Source/tasks.c **** 				pxNewTCB->uxTCBNumber = uxTaskNumber;
 614:../../FreeRTOS/Source/tasks.c **** 			}
 615:../../FreeRTOS/Source/tasks.c **** 			#endif
 616:../../FreeRTOS/Source/tasks.c **** 			uxTaskNumber++;
 351               	.LM19:
 352 0130 8091 0000 		lds r24,uxTaskNumber
 353 0134 8F5F      		subi r24,lo8(-(1))
 354 0136 8093 0000 		sts uxTaskNumber,r24
 617:../../FreeRTOS/Source/tasks.c **** 
 618:../../FreeRTOS/Source/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 356               	.LM20:
 357 013a EB81      		ldd r30,Y+3
 358 013c FC81      		ldd r31,Y+4
 359 013e 9689      		ldd r25,Z+22
 360 0140 8091 0000 		lds r24,uxTopReadyPriority
 361 0144 8917      		cp r24,r25
 362 0146 00F4      		brsh .L8
 363 0148 EB81      		ldd r30,Y+3
 364 014a FC81      		ldd r31,Y+4
 365 014c 8689      		ldd r24,Z+22
 366 014e 8093 0000 		sts uxTopReadyPriority,r24
 367               	.L8:
 368 0152 EB81      		ldd r30,Y+3
 369 0154 FC81      		ldd r31,Y+4
 370 0156 8689      		ldd r24,Z+22
 371 0158 282F      		mov r18,r24
 372 015a 30E0      		ldi r19,lo8(0)
 373 015c C901      		movw r24,r18
 374 015e 880F      		lsl r24
 375 0160 991F      		rol r25
 376 0162 880F      		lsl r24
 377 0164 991F      		rol r25
 378 0166 880F      		lsl r24
 379 0168 991F      		rol r25
 380 016a 820F      		add r24,r18
 381 016c 931F      		adc r25,r19
 382 016e AC01      		movw r20,r24
 383 0170 4050      		subi r20,lo8(-(pxReadyTasksLists))
 384 0172 5040      		sbci r21,hi8(-(pxReadyTasksLists))
 385 0174 8B81      		ldd r24,Y+3
 386 0176 9C81      		ldd r25,Y+4
 387 0178 9C01      		movw r18,r24
 388 017a 2E5F      		subi r18,lo8(-(2))
 389 017c 3F4F      		sbci r19,hi8(-(2))
 390 017e CA01      		movw r24,r20
 391 0180 B901      		movw r22,r18
 392 0182 0E94 0000 		call vListInsertEnd
 619:../../FreeRTOS/Source/tasks.c **** 
 620:../../FreeRTOS/Source/tasks.c **** 			xReturn = pdPASS;
 394               	.LM21:
 395 0186 81E0      		ldi r24,lo8(1)
 396 0188 8D83      		std Y+5,r24
 621:../../FreeRTOS/Source/tasks.c **** 			portSETUP_TCB( pxNewTCB );
 622:../../FreeRTOS/Source/tasks.c **** 			traceTASK_CREATE( pxNewTCB );
 623:../../FreeRTOS/Source/tasks.c **** 		}
 624:../../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 398               	.LM22:
 399               	/* #APP */
 400               	 ;  624 "../../FreeRTOS/Source/tasks.c" 1
 401 018a 0F90      		pop		__tmp_reg__
 402               	 ;  0 "" 2
 403               	 ;  624 "../../FreeRTOS/Source/tasks.c" 1
 404 018c 0FBE      		out		__SREG__, __tmp_reg__
 405               	 ;  0 "" 2
 406               	/* #NOAPP */
 407 018e 00C0      		rjmp .L9
 408               	.L2:
 409               	.LBE2:
 625:../../FreeRTOS/Source/tasks.c **** 	}
 626:../../FreeRTOS/Source/tasks.c **** 	else
 627:../../FreeRTOS/Source/tasks.c **** 	{
 628:../../FreeRTOS/Source/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 411               	.LM23:
 412 0190 8FEF      		ldi r24,lo8(-1)
 413 0192 8D83      		std Y+5,r24
 414               	.L9:
 629:../../FreeRTOS/Source/tasks.c **** 		traceTASK_CREATE_FAILED();
 630:../../FreeRTOS/Source/tasks.c **** 	}
 631:../../FreeRTOS/Source/tasks.c **** 
 632:../../FreeRTOS/Source/tasks.c **** 	if( xReturn == pdPASS )
 416               	.LM24:
 417 0194 8D81      		ldd r24,Y+5
 418 0196 8130      		cpi r24,lo8(1)
 419 0198 01F4      		brne .L10
 633:../../FreeRTOS/Source/tasks.c **** 	{
 634:../../FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 421               	.LM25:
 422 019a 8091 0000 		lds r24,xSchedulerRunning
 423 019e 8823      		tst r24
 424 01a0 01F0      		breq .L10
 635:../../FreeRTOS/Source/tasks.c **** 		{
 636:../../FreeRTOS/Source/tasks.c **** 			/* If the created task is of a higher priority than the current task
 637:../../FreeRTOS/Source/tasks.c **** 			then it should run now. */
 638:../../FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 426               	.LM26:
 427 01a2 E091 0000 		lds r30,pxCurrentTCB
 428 01a6 F091 0000 		lds r31,(pxCurrentTCB)+1
 429 01aa 9689      		ldd r25,Z+22
 430 01ac 8E85      		ldd r24,Y+14
 431 01ae 9817      		cp r25,r24
 432 01b0 00F4      		brsh .L10
 639:../../FreeRTOS/Source/tasks.c **** 			{
 640:../../FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 434               	.LM27:
 435 01b2 0E94 0000 		call vPortYield
 436               	.L10:
 641:../../FreeRTOS/Source/tasks.c **** 			}
 642:../../FreeRTOS/Source/tasks.c **** 		}
 643:../../FreeRTOS/Source/tasks.c **** 	}
 644:../../FreeRTOS/Source/tasks.c **** 
 645:../../FreeRTOS/Source/tasks.c **** 	return xReturn;
 438               	.LM28:
 439 01b6 8D81      		ldd r24,Y+5
 440               	/* epilogue start */
 646:../../FreeRTOS/Source/tasks.c **** }
 442               	.LM29:
 443 01b8 6496      		adiw r28,20
 444 01ba 0FB6      		in __tmp_reg__,__SREG__
 445 01bc F894      		cli
 446 01be DEBF      		out __SP_H__,r29
 447 01c0 0FBE      		out __SREG__,__tmp_reg__
 448 01c2 CDBF      		out __SP_L__,r28
 449 01c4 CF91      		pop r28
 450 01c6 DF91      		pop r29
 451 01c8 1F91      		pop r17
 452 01ca 0F91      		pop r16
 453 01cc FF90      		pop r15
 454 01ce EF90      		pop r14
 455 01d0 DF90      		pop r13
 456 01d2 CF90      		pop r12
 457 01d4 BF90      		pop r11
 458 01d6 AF90      		pop r10
 459 01d8 0895      		ret
 468               	.Lscope1:
 470               		.stabd	78,0,0
 474               	.global	vTaskDelayUntil
 476               	vTaskDelayUntil:
 477               		.stabd	46,0,0
 647:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 648:../../FreeRTOS/Source/tasks.c **** 
 649:../../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 650:../../FreeRTOS/Source/tasks.c **** 
 651:../../FreeRTOS/Source/tasks.c **** 	void vTaskDelete( xTaskHandle pxTaskToDelete )
 652:../../FreeRTOS/Source/tasks.c **** 	{
 653:../../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 654:../../FreeRTOS/Source/tasks.c **** 
 655:../../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 656:../../FreeRTOS/Source/tasks.c **** 		{
 657:../../FreeRTOS/Source/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 658:../../FreeRTOS/Source/tasks.c **** 			deleted. */
 659:../../FreeRTOS/Source/tasks.c **** 			if( pxTaskToDelete == pxCurrentTCB )
 660:../../FreeRTOS/Source/tasks.c **** 			{
 661:../../FreeRTOS/Source/tasks.c **** 				pxTaskToDelete = NULL;
 662:../../FreeRTOS/Source/tasks.c **** 			}
 663:../../FreeRTOS/Source/tasks.c **** 
 664:../../FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are deleting ourselves. */
 665:../../FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
 666:../../FreeRTOS/Source/tasks.c **** 
 667:../../FreeRTOS/Source/tasks.c **** 			/* Remove task from the ready list and place in the	termination list.
 668:../../FreeRTOS/Source/tasks.c **** 			This will stop the task from be scheduled.  The idle task will check
 669:../../FreeRTOS/Source/tasks.c **** 			the termination list and free up any memory allocated by the
 670:../../FreeRTOS/Source/tasks.c **** 			scheduler for the TCB and stack. */
 671:../../FreeRTOS/Source/tasks.c **** 			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
 672:../../FreeRTOS/Source/tasks.c **** 			{
 673:../../FreeRTOS/Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 674:../../FreeRTOS/Source/tasks.c **** 			}
 675:../../FreeRTOS/Source/tasks.c **** 
 676:../../FreeRTOS/Source/tasks.c **** 			/* Is the task waiting on an event also? */
 677:../../FreeRTOS/Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 678:../../FreeRTOS/Source/tasks.c **** 			{
 679:../../FreeRTOS/Source/tasks.c **** 				uxListRemove( &( pxTCB->xEventListItem ) );
 680:../../FreeRTOS/Source/tasks.c **** 			}
 681:../../FreeRTOS/Source/tasks.c **** 
 682:../../FreeRTOS/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 683:../../FreeRTOS/Source/tasks.c **** 
 684:../../FreeRTOS/Source/tasks.c **** 			/* Increment the ucTasksDeleted variable so the idle task knows
 685:../../FreeRTOS/Source/tasks.c **** 			there is a task that has been deleted and that it should therefore
 686:../../FreeRTOS/Source/tasks.c **** 			check the xTasksWaitingTermination list. */
 687:../../FreeRTOS/Source/tasks.c **** 			++uxTasksDeleted;
 688:../../FreeRTOS/Source/tasks.c **** 
 689:../../FreeRTOS/Source/tasks.c **** 			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
 690:../../FreeRTOS/Source/tasks.c **** 			can detect that the task lists need re-generating. */
 691:../../FreeRTOS/Source/tasks.c **** 			uxTaskNumber++;
 692:../../FreeRTOS/Source/tasks.c **** 
 693:../../FreeRTOS/Source/tasks.c **** 			traceTASK_DELETE( pxTCB );
 694:../../FreeRTOS/Source/tasks.c **** 		}
 695:../../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 696:../../FreeRTOS/Source/tasks.c **** 
 697:../../FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if we have just deleted the current task. */
 698:../../FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 699:../../FreeRTOS/Source/tasks.c **** 		{
 700:../../FreeRTOS/Source/tasks.c **** 			if( ( void * ) pxTaskToDelete == NULL )
 701:../../FreeRTOS/Source/tasks.c **** 			{
 702:../../FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 703:../../FreeRTOS/Source/tasks.c **** 			}
 704:../../FreeRTOS/Source/tasks.c **** 		}
 705:../../FreeRTOS/Source/tasks.c **** 	}
 706:../../FreeRTOS/Source/tasks.c **** 
 707:../../FreeRTOS/Source/tasks.c **** #endif
 708:../../FreeRTOS/Source/tasks.c **** 
 709:../../FreeRTOS/Source/tasks.c **** 
 710:../../FreeRTOS/Source/tasks.c **** 
 711:../../FreeRTOS/Source/tasks.c **** 
 712:../../FreeRTOS/Source/tasks.c **** 
 713:../../FreeRTOS/Source/tasks.c **** 
 714:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
 715:../../FreeRTOS/Source/tasks.c ****  * TASK CONTROL API documented in task.h
 716:../../FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
 717:../../FreeRTOS/Source/tasks.c **** 
 718:../../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
 719:../../FreeRTOS/Source/tasks.c **** 
 720:../../FreeRTOS/Source/tasks.c **** 	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
 721:../../FreeRTOS/Source/tasks.c **** 	{
 479               	.LM30:
 480               	.LFBB2:
 481 01da DF93      		push r29
 482 01dc CF93      		push r28
 483 01de CDB7      		in r28,__SP_L__
 484 01e0 DEB7      		in r29,__SP_H__
 485 01e2 2897      		sbiw r28,8
 486 01e4 0FB6      		in __tmp_reg__,__SREG__
 487 01e6 F894      		cli
 488 01e8 DEBF      		out __SP_H__,r29
 489 01ea 0FBE      		out __SREG__,__tmp_reg__
 490 01ec CDBF      		out __SP_L__,r28
 491               	/* prologue: function */
 492               	/* frame size = 8 */
 493 01ee 9E83      		std Y+6,r25
 494 01f0 8D83      		std Y+5,r24
 495 01f2 7887      		std Y+8,r23
 496 01f4 6F83      		std Y+7,r22
 722:../../FreeRTOS/Source/tasks.c **** 	portTickType xTimeToWake;
 723:../../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 498               	.LM31:
 499 01f6 1982      		std Y+1,__zero_reg__
 724:../../FreeRTOS/Source/tasks.c **** 
 725:../../FreeRTOS/Source/tasks.c **** 		configASSERT( pxPreviousWakeTime );
 726:../../FreeRTOS/Source/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
 727:../../FreeRTOS/Source/tasks.c **** 
 728:../../FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
 501               	.LM32:
 502 01f8 0E94 0000 		call vTaskSuspendAll
 729:../../FreeRTOS/Source/tasks.c **** 		{
 730:../../FreeRTOS/Source/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
 731:../../FreeRTOS/Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 504               	.LM33:
 505 01fc ED81      		ldd r30,Y+5
 506 01fe FE81      		ldd r31,Y+6
 507 0200 2081      		ld r18,Z
 508 0202 3181      		ldd r19,Z+1
 509 0204 8F81      		ldd r24,Y+7
 510 0206 9885      		ldd r25,Y+8
 511 0208 820F      		add r24,r18
 512 020a 931F      		adc r25,r19
 513 020c 9C83      		std Y+4,r25
 514 020e 8B83      		std Y+3,r24
 732:../../FreeRTOS/Source/tasks.c **** 
 733:../../FreeRTOS/Source/tasks.c **** 			if( xTickCount < *pxPreviousWakeTime )
 516               	.LM34:
 517 0210 ED81      		ldd r30,Y+5
 518 0212 FE81      		ldd r31,Y+6
 519 0214 2081      		ld r18,Z
 520 0216 3181      		ldd r19,Z+1
 521 0218 8091 0000 		lds r24,xTickCount
 522 021c 9091 0000 		lds r25,(xTickCount)+1
 523 0220 8217      		cp r24,r18
 524 0222 9307      		cpc r25,r19
 525 0224 00F4      		brsh .L13
 734:../../FreeRTOS/Source/tasks.c **** 			{
 735:../../FreeRTOS/Source/tasks.c **** 				/* The tick count has overflowed since this function was
 736:../../FreeRTOS/Source/tasks.c **** 				lasted called.  In this case the only time we should ever
 737:../../FreeRTOS/Source/tasks.c **** 				actually delay is if the wake time has also	overflowed,
 738:../../FreeRTOS/Source/tasks.c **** 				and the wake time is greater than the tick time.  When this
 739:../../FreeRTOS/Source/tasks.c **** 				is the case it is as if neither time had overflowed. */
 740:../../FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 527               	.LM35:
 528 0226 ED81      		ldd r30,Y+5
 529 0228 FE81      		ldd r31,Y+6
 530 022a 2081      		ld r18,Z
 531 022c 3181      		ldd r19,Z+1
 532 022e 8B81      		ldd r24,Y+3
 533 0230 9C81      		ldd r25,Y+4
 534 0232 8217      		cp r24,r18
 535 0234 9307      		cpc r25,r19
 536 0236 00F4      		brsh .L15
 537 0238 2091 0000 		lds r18,xTickCount
 538 023c 3091 0000 		lds r19,(xTickCount)+1
 539 0240 8B81      		ldd r24,Y+3
 540 0242 9C81      		ldd r25,Y+4
 541 0244 2817      		cp r18,r24
 542 0246 3907      		cpc r19,r25
 543 0248 00F4      		brsh .L15
 741:../../FreeRTOS/Source/tasks.c **** 				{
 742:../../FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 545               	.LM36:
 546 024a 81E0      		ldi r24,lo8(1)
 547 024c 8983      		std Y+1,r24
 548 024e 00C0      		rjmp .L15
 549               	.L13:
 743:../../FreeRTOS/Source/tasks.c **** 				}
 744:../../FreeRTOS/Source/tasks.c **** 			}
 745:../../FreeRTOS/Source/tasks.c **** 			else
 746:../../FreeRTOS/Source/tasks.c **** 			{
 747:../../FreeRTOS/Source/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
 748:../../FreeRTOS/Source/tasks.c **** 				delay if either the wake time has overflowed, and/or the
 749:../../FreeRTOS/Source/tasks.c **** 				tick time is less than the wake time. */
 750:../../FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 551               	.LM37:
 552 0250 ED81      		ldd r30,Y+5
 553 0252 FE81      		ldd r31,Y+6
 554 0254 2081      		ld r18,Z
 555 0256 3181      		ldd r19,Z+1
 556 0258 8B81      		ldd r24,Y+3
 557 025a 9C81      		ldd r25,Y+4
 558 025c 8217      		cp r24,r18
 559 025e 9307      		cpc r25,r19
 560 0260 00F0      		brlo .L16
 561 0262 2091 0000 		lds r18,xTickCount
 562 0266 3091 0000 		lds r19,(xTickCount)+1
 563 026a 8B81      		ldd r24,Y+3
 564 026c 9C81      		ldd r25,Y+4
 565 026e 2817      		cp r18,r24
 566 0270 3907      		cpc r19,r25
 567 0272 00F4      		brsh .L15
 568               	.L16:
 751:../../FreeRTOS/Source/tasks.c **** 				{
 752:../../FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 570               	.LM38:
 571 0274 81E0      		ldi r24,lo8(1)
 572 0276 8983      		std Y+1,r24
 573               	.L15:
 753:../../FreeRTOS/Source/tasks.c **** 				}
 754:../../FreeRTOS/Source/tasks.c **** 			}
 755:../../FreeRTOS/Source/tasks.c **** 
 756:../../FreeRTOS/Source/tasks.c **** 			/* Update the wake time ready for the next call. */
 757:../../FreeRTOS/Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 575               	.LM39:
 576 0278 ED81      		ldd r30,Y+5
 577 027a FE81      		ldd r31,Y+6
 578 027c 8B81      		ldd r24,Y+3
 579 027e 9C81      		ldd r25,Y+4
 580 0280 9183      		std Z+1,r25
 581 0282 8083      		st Z,r24
 758:../../FreeRTOS/Source/tasks.c **** 
 759:../../FreeRTOS/Source/tasks.c **** 			if( xShouldDelay != pdFALSE )
 583               	.LM40:
 584 0284 8981      		ldd r24,Y+1
 585 0286 8823      		tst r24
 586 0288 01F0      		breq .L17
 760:../../FreeRTOS/Source/tasks.c **** 			{
 761:../../FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY_UNTIL();
 762:../../FreeRTOS/Source/tasks.c **** 
 763:../../FreeRTOS/Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 764:../../FreeRTOS/Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 765:../../FreeRTOS/Source/tasks.c **** 				both lists. */
 766:../../FreeRTOS/Source/tasks.c **** 				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
 588               	.LM41:
 589 028a 8091 0000 		lds r24,pxCurrentTCB
 590 028e 9091 0000 		lds r25,(pxCurrentTCB)+1
 591 0292 0296      		adiw r24,2
 592 0294 0E94 0000 		call uxListRemove
 767:../../FreeRTOS/Source/tasks.c **** 				{
 768:../../FreeRTOS/Source/tasks.c **** 					/* The current task must be in a ready list, so there is
 769:../../FreeRTOS/Source/tasks.c **** 					no need to check, and the port reset macro can be called
 770:../../FreeRTOS/Source/tasks.c **** 					directly. */
 771:../../FreeRTOS/Source/tasks.c **** 					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 772:../../FreeRTOS/Source/tasks.c **** 				}
 773:../../FreeRTOS/Source/tasks.c **** 
 774:../../FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 594               	.LM42:
 595 0298 8B81      		ldd r24,Y+3
 596 029a 9C81      		ldd r25,Y+4
 597 029c 0E94 0000 		call prvAddCurrentTaskToDelayedList
 598               	.L17:
 775:../../FreeRTOS/Source/tasks.c **** 			}
 776:../../FreeRTOS/Source/tasks.c **** 		}
 777:../../FreeRTOS/Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 600               	.LM43:
 601 02a0 0E94 0000 		call xTaskResumeAll
 602 02a4 8A83      		std Y+2,r24
 778:../../FreeRTOS/Source/tasks.c **** 
 779:../../FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 780:../../FreeRTOS/Source/tasks.c **** 		have put ourselves to sleep. */
 781:../../FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 604               	.LM44:
 605 02a6 8A81      		ldd r24,Y+2
 606 02a8 8823      		tst r24
 607 02aa 01F4      		brne .L19
 782:../../FreeRTOS/Source/tasks.c **** 		{
 783:../../FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
 609               	.LM45:
 610 02ac 0E94 0000 		call vPortYield
 611               	.L19:
 612               	/* epilogue start */
 784:../../FreeRTOS/Source/tasks.c **** 		}
 785:../../FreeRTOS/Source/tasks.c **** 	}
 614               	.LM46:
 615 02b0 2896      		adiw r28,8
 616 02b2 0FB6      		in __tmp_reg__,__SREG__
 617 02b4 F894      		cli
 618 02b6 DEBF      		out __SP_H__,r29
 619 02b8 0FBE      		out __SREG__,__tmp_reg__
 620 02ba CDBF      		out __SP_L__,r28
 621 02bc CF91      		pop r28
 622 02be DF91      		pop r29
 623 02c0 0895      		ret
 630               	.Lscope2:
 632               		.stabd	78,0,0
 635               	.global	vTaskDelay
 637               	vTaskDelay:
 638               		.stabd	46,0,0
 786:../../FreeRTOS/Source/tasks.c **** 
 787:../../FreeRTOS/Source/tasks.c **** #endif
 788:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 789:../../FreeRTOS/Source/tasks.c **** 
 790:../../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
 791:../../FreeRTOS/Source/tasks.c **** 
 792:../../FreeRTOS/Source/tasks.c **** 	void vTaskDelay( portTickType xTicksToDelay )
 793:../../FreeRTOS/Source/tasks.c **** 	{
 640               	.LM47:
 641               	.LFBB3:
 642 02c2 DF93      		push r29
 643 02c4 CF93      		push r28
 644 02c6 00D0      		rcall .
 645 02c8 0F92      		push __tmp_reg__
 646 02ca 0F92      		push __tmp_reg__
 647 02cc CDB7      		in r28,__SP_L__
 648 02ce DEB7      		in r29,__SP_H__
 649               	/* prologue: function */
 650               	/* frame size = 5 */
 651 02d0 9D83      		std Y+5,r25
 652 02d2 8C83      		std Y+4,r24
 794:../../FreeRTOS/Source/tasks.c **** 	portTickType xTimeToWake;
 795:../../FreeRTOS/Source/tasks.c **** 	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 654               	.LM48:
 655 02d4 1982      		std Y+1,__zero_reg__
 796:../../FreeRTOS/Source/tasks.c **** 
 797:../../FreeRTOS/Source/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
 798:../../FreeRTOS/Source/tasks.c **** 		if( xTicksToDelay > ( portTickType ) 0U )
 657               	.LM49:
 658 02d6 8C81      		ldd r24,Y+4
 659 02d8 9D81      		ldd r25,Y+5
 660 02da 0097      		sbiw r24,0
 661 02dc 01F0      		breq .L21
 799:../../FreeRTOS/Source/tasks.c **** 		{
 800:../../FreeRTOS/Source/tasks.c **** 			vTaskSuspendAll();
 663               	.LM50:
 664 02de 0E94 0000 		call vTaskSuspendAll
 801:../../FreeRTOS/Source/tasks.c **** 			{
 802:../../FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY();
 803:../../FreeRTOS/Source/tasks.c **** 
 804:../../FreeRTOS/Source/tasks.c **** 				/* A task that is removed from the event list while the
 805:../../FreeRTOS/Source/tasks.c **** 				scheduler is suspended will not get placed in the ready
 806:../../FreeRTOS/Source/tasks.c **** 				list or removed from the blocked list until the scheduler
 807:../../FreeRTOS/Source/tasks.c **** 				is resumed.
 808:../../FreeRTOS/Source/tasks.c **** 
 809:../../FreeRTOS/Source/tasks.c **** 				This task cannot be in an event list as it is the currently
 810:../../FreeRTOS/Source/tasks.c **** 				executing task. */
 811:../../FreeRTOS/Source/tasks.c **** 
 812:../../FreeRTOS/Source/tasks.c **** 				/* Calculate the time to wake - this may overflow but this is
 813:../../FreeRTOS/Source/tasks.c **** 				not a problem. */
 814:../../FreeRTOS/Source/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 666               	.LM51:
 667 02e2 2091 0000 		lds r18,xTickCount
 668 02e6 3091 0000 		lds r19,(xTickCount)+1
 669 02ea 8C81      		ldd r24,Y+4
 670 02ec 9D81      		ldd r25,Y+5
 671 02ee 820F      		add r24,r18
 672 02f0 931F      		adc r25,r19
 673 02f2 9B83      		std Y+3,r25
 674 02f4 8A83      		std Y+2,r24
 815:../../FreeRTOS/Source/tasks.c **** 
 816:../../FreeRTOS/Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 817:../../FreeRTOS/Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 818:../../FreeRTOS/Source/tasks.c **** 				both lists. */
 819:../../FreeRTOS/Source/tasks.c **** 				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
 676               	.LM52:
 677 02f6 8091 0000 		lds r24,pxCurrentTCB
 678 02fa 9091 0000 		lds r25,(pxCurrentTCB)+1
 679 02fe 0296      		adiw r24,2
 680 0300 0E94 0000 		call uxListRemove
 820:../../FreeRTOS/Source/tasks.c **** 				{
 821:../../FreeRTOS/Source/tasks.c **** 					/* The current task must be in a ready list, so there is
 822:../../FreeRTOS/Source/tasks.c **** 					no need to check, and the port reset macro can be called
 823:../../FreeRTOS/Source/tasks.c **** 					directly. */
 824:../../FreeRTOS/Source/tasks.c **** 					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 825:../../FreeRTOS/Source/tasks.c **** 				}
 826:../../FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 682               	.LM53:
 683 0304 8A81      		ldd r24,Y+2
 684 0306 9B81      		ldd r25,Y+3
 685 0308 0E94 0000 		call prvAddCurrentTaskToDelayedList
 827:../../FreeRTOS/Source/tasks.c **** 			}
 828:../../FreeRTOS/Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 687               	.LM54:
 688 030c 0E94 0000 		call xTaskResumeAll
 689 0310 8983      		std Y+1,r24
 690               	.L21:
 829:../../FreeRTOS/Source/tasks.c **** 		}
 830:../../FreeRTOS/Source/tasks.c **** 
 831:../../FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 832:../../FreeRTOS/Source/tasks.c **** 		have put ourselves to sleep. */
 833:../../FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 692               	.LM55:
 693 0312 8981      		ldd r24,Y+1
 694 0314 8823      		tst r24
 695 0316 01F4      		brne .L23
 834:../../FreeRTOS/Source/tasks.c **** 		{
 835:../../FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
 697               	.LM56:
 698 0318 0E94 0000 		call vPortYield
 699               	.L23:
 700               	/* epilogue start */
 836:../../FreeRTOS/Source/tasks.c **** 		}
 837:../../FreeRTOS/Source/tasks.c **** 	}
 702               	.LM57:
 703 031c 0F90      		pop __tmp_reg__
 704 031e 0F90      		pop __tmp_reg__
 705 0320 0F90      		pop __tmp_reg__
 706 0322 0F90      		pop __tmp_reg__
 707 0324 0F90      		pop __tmp_reg__
 708 0326 CF91      		pop r28
 709 0328 DF91      		pop r29
 710 032a 0895      		ret
 716               	.Lscope3:
 718               		.stabd	78,0,0
 721               	.global	vTaskSuspend
 723               	vTaskSuspend:
 724               		.stabd	46,0,0
 838:../../FreeRTOS/Source/tasks.c **** 
 839:../../FreeRTOS/Source/tasks.c **** #endif
 840:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 841:../../FreeRTOS/Source/tasks.c **** 
 842:../../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_eTaskStateGet == 1 )
 843:../../FreeRTOS/Source/tasks.c **** 
 844:../../FreeRTOS/Source/tasks.c **** 	eTaskState eTaskStateGet( xTaskHandle pxTask )
 845:../../FreeRTOS/Source/tasks.c **** 	{
 846:../../FreeRTOS/Source/tasks.c **** 	eTaskState eReturn;
 847:../../FreeRTOS/Source/tasks.c **** 	xList *pxStateList;
 848:../../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 849:../../FreeRTOS/Source/tasks.c **** 
 850:../../FreeRTOS/Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTask;
 851:../../FreeRTOS/Source/tasks.c **** 
 852:../../FreeRTOS/Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
 853:../../FreeRTOS/Source/tasks.c **** 		{
 854:../../FreeRTOS/Source/tasks.c **** 			/* The task calling this function is querying its own state. */
 855:../../FreeRTOS/Source/tasks.c **** 			eReturn = eRunning;
 856:../../FreeRTOS/Source/tasks.c **** 		}
 857:../../FreeRTOS/Source/tasks.c **** 		else
 858:../../FreeRTOS/Source/tasks.c **** 		{
 859:../../FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
 860:../../FreeRTOS/Source/tasks.c **** 			{
 861:../../FreeRTOS/Source/tasks.c **** 				pxStateList = ( xList * ) listLIST_ITEM_CONTAINER( &( pxTCB->xGenericListItem ) );
 862:../../FreeRTOS/Source/tasks.c **** 			}
 863:../../FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
 864:../../FreeRTOS/Source/tasks.c **** 
 865:../../FreeRTOS/Source/tasks.c **** 			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
 866:../../FreeRTOS/Source/tasks.c **** 			{
 867:../../FreeRTOS/Source/tasks.c **** 				/* The task being queried is referenced from one of the Blocked
 868:../../FreeRTOS/Source/tasks.c **** 				lists. */
 869:../../FreeRTOS/Source/tasks.c **** 				eReturn = eBlocked;
 870:../../FreeRTOS/Source/tasks.c **** 			}
 871:../../FreeRTOS/Source/tasks.c **** 
 872:../../FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
 873:../../FreeRTOS/Source/tasks.c **** 				else if( pxStateList == &xSuspendedTaskList )
 874:../../FreeRTOS/Source/tasks.c **** 				{
 875:../../FreeRTOS/Source/tasks.c **** 					/* The task being queried is referenced from the suspended
 876:../../FreeRTOS/Source/tasks.c **** 					list. */
 877:../../FreeRTOS/Source/tasks.c **** 					eReturn = eSuspended;
 878:../../FreeRTOS/Source/tasks.c **** 				}
 879:../../FreeRTOS/Source/tasks.c **** 			#endif
 880:../../FreeRTOS/Source/tasks.c **** 
 881:../../FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
 882:../../FreeRTOS/Source/tasks.c **** 				else if( pxStateList == &xTasksWaitingTermination )
 883:../../FreeRTOS/Source/tasks.c **** 				{
 884:../../FreeRTOS/Source/tasks.c **** 					/* The task being queried is referenced from the deleted
 885:../../FreeRTOS/Source/tasks.c **** 					tasks list. */
 886:../../FreeRTOS/Source/tasks.c **** 					eReturn = eDeleted;
 887:../../FreeRTOS/Source/tasks.c **** 				}
 888:../../FreeRTOS/Source/tasks.c **** 			#endif
 889:../../FreeRTOS/Source/tasks.c **** 
 890:../../FreeRTOS/Source/tasks.c **** 			else
 891:../../FreeRTOS/Source/tasks.c **** 			{
 892:../../FreeRTOS/Source/tasks.c **** 				/* If the task is not in any other state, it must be in the
 893:../../FreeRTOS/Source/tasks.c **** 				Ready (including pending ready) state. */
 894:../../FreeRTOS/Source/tasks.c **** 				eReturn = eReady;
 895:../../FreeRTOS/Source/tasks.c **** 			}
 896:../../FreeRTOS/Source/tasks.c **** 		}
 897:../../FreeRTOS/Source/tasks.c **** 
 898:../../FreeRTOS/Source/tasks.c **** 		return eReturn;
 899:../../FreeRTOS/Source/tasks.c **** 	}
 900:../../FreeRTOS/Source/tasks.c **** 
 901:../../FreeRTOS/Source/tasks.c **** #endif
 902:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 903:../../FreeRTOS/Source/tasks.c **** 
 904:../../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
 905:../../FreeRTOS/Source/tasks.c **** 
 906:../../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
 907:../../FreeRTOS/Source/tasks.c **** 	{
 908:../../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 909:../../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
 910:../../FreeRTOS/Source/tasks.c **** 
 911:../../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 912:../../FreeRTOS/Source/tasks.c **** 		{
 913:../../FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are changing the
 914:../../FreeRTOS/Source/tasks.c **** 			priority of the calling function. */
 915:../../FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 916:../../FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 917:../../FreeRTOS/Source/tasks.c **** 		}
 918:../../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 919:../../FreeRTOS/Source/tasks.c **** 
 920:../../FreeRTOS/Source/tasks.c **** 		return uxReturn;
 921:../../FreeRTOS/Source/tasks.c **** 	}
 922:../../FreeRTOS/Source/tasks.c **** 
 923:../../FreeRTOS/Source/tasks.c **** #endif
 924:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 925:../../FreeRTOS/Source/tasks.c **** 
 926:../../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
 927:../../FreeRTOS/Source/tasks.c **** 
 928:../../FreeRTOS/Source/tasks.c **** 	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
 929:../../FreeRTOS/Source/tasks.c **** 	{
 930:../../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 931:../../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxCurrentPriority, uxPriorityUsedOnEntry;
 932:../../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 933:../../FreeRTOS/Source/tasks.c **** 
 934:../../FreeRTOS/Source/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 935:../../FreeRTOS/Source/tasks.c **** 
 936:../../FreeRTOS/Source/tasks.c **** 		/* Ensure the new priority is valid. */
 937:../../FreeRTOS/Source/tasks.c **** 		if( uxNewPriority >= configMAX_PRIORITIES )
 938:../../FreeRTOS/Source/tasks.c **** 		{
 939:../../FreeRTOS/Source/tasks.c **** 			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 940:../../FreeRTOS/Source/tasks.c **** 		}
 941:../../FreeRTOS/Source/tasks.c **** 
 942:../../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 943:../../FreeRTOS/Source/tasks.c **** 		{
 944:../../FreeRTOS/Source/tasks.c **** 			if( pxTask == pxCurrentTCB )
 945:../../FreeRTOS/Source/tasks.c **** 			{
 946:../../FreeRTOS/Source/tasks.c **** 				pxTask = NULL;
 947:../../FreeRTOS/Source/tasks.c **** 			}
 948:../../FreeRTOS/Source/tasks.c **** 
 949:../../FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are changing the
 950:../../FreeRTOS/Source/tasks.c **** 			priority of the calling function. */
 951:../../FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 952:../../FreeRTOS/Source/tasks.c **** 
 953:../../FreeRTOS/Source/tasks.c **** 			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
 954:../../FreeRTOS/Source/tasks.c **** 
 955:../../FreeRTOS/Source/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
 956:../../FreeRTOS/Source/tasks.c **** 			{
 957:../../FreeRTOS/Source/tasks.c **** 				uxCurrentPriority = pxTCB->uxBasePriority;
 958:../../FreeRTOS/Source/tasks.c **** 			}
 959:../../FreeRTOS/Source/tasks.c **** 			#else
 960:../../FreeRTOS/Source/tasks.c **** 			{
 961:../../FreeRTOS/Source/tasks.c **** 				uxCurrentPriority = pxTCB->uxPriority;
 962:../../FreeRTOS/Source/tasks.c **** 			}
 963:../../FreeRTOS/Source/tasks.c **** 			#endif
 964:../../FreeRTOS/Source/tasks.c **** 
 965:../../FreeRTOS/Source/tasks.c **** 			if( uxCurrentPriority != uxNewPriority )
 966:../../FreeRTOS/Source/tasks.c **** 			{
 967:../../FreeRTOS/Source/tasks.c **** 				/* The priority change may have readied a task of higher
 968:../../FreeRTOS/Source/tasks.c **** 				priority than the calling task. */
 969:../../FreeRTOS/Source/tasks.c **** 				if( uxNewPriority > uxCurrentPriority )
 970:../../FreeRTOS/Source/tasks.c **** 				{
 971:../../FreeRTOS/Source/tasks.c **** 					if( pxTask != NULL )
 972:../../FreeRTOS/Source/tasks.c **** 					{
 973:../../FreeRTOS/Source/tasks.c **** 						/* The priority of another task is being raised.  If we
 974:../../FreeRTOS/Source/tasks.c **** 						were raising the priority of the currently running task
 975:../../FreeRTOS/Source/tasks.c **** 						there would be no need to switch as it must have already
 976:../../FreeRTOS/Source/tasks.c **** 						been the highest priority task. */
 977:../../FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
 978:../../FreeRTOS/Source/tasks.c **** 					}
 979:../../FreeRTOS/Source/tasks.c **** 				}
 980:../../FreeRTOS/Source/tasks.c **** 				else if( pxTask == NULL )
 981:../../FreeRTOS/Source/tasks.c **** 				{
 982:../../FreeRTOS/Source/tasks.c **** 					/* Setting our own priority down means there may now be another
 983:../../FreeRTOS/Source/tasks.c **** 					task of higher priority that is ready to execute. */
 984:../../FreeRTOS/Source/tasks.c **** 					xYieldRequired = pdTRUE;
 985:../../FreeRTOS/Source/tasks.c **** 				}
 986:../../FreeRTOS/Source/tasks.c **** 
 987:../../FreeRTOS/Source/tasks.c **** 				/* Remember the ready list the task might be referenced from
 988:../../FreeRTOS/Source/tasks.c **** 				before its uxPriority member is changed so the
 989:../../FreeRTOS/Source/tasks.c **** 				taskRESET_READY_PRIORITY() macro can function correctly. */
 990:../../FreeRTOS/Source/tasks.c **** 				uxPriorityUsedOnEntry = pxTCB->uxPriority;
 991:../../FreeRTOS/Source/tasks.c **** 
 992:../../FreeRTOS/Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
 993:../../FreeRTOS/Source/tasks.c **** 				{
 994:../../FreeRTOS/Source/tasks.c **** 					/* Only change the priority being used if the task is not
 995:../../FreeRTOS/Source/tasks.c **** 					currently using an inherited priority. */
 996:../../FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 997:../../FreeRTOS/Source/tasks.c **** 					{
 998:../../FreeRTOS/Source/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
 999:../../FreeRTOS/Source/tasks.c **** 					}
1000:../../FreeRTOS/Source/tasks.c **** 
1001:../../FreeRTOS/Source/tasks.c **** 					/* The base priority gets set whatever. */
1002:../../FreeRTOS/Source/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
1003:../../FreeRTOS/Source/tasks.c **** 				}
1004:../../FreeRTOS/Source/tasks.c **** 				#else
1005:../../FreeRTOS/Source/tasks.c **** 				{
1006:../../FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
1007:../../FreeRTOS/Source/tasks.c **** 				}
1008:../../FreeRTOS/Source/tasks.c **** 				#endif
1009:../../FreeRTOS/Source/tasks.c **** 
1010:../../FreeRTOS/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) 
1011:../../FreeRTOS/Source/tasks.c **** 
1012:../../FreeRTOS/Source/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
1013:../../FreeRTOS/Source/tasks.c **** 				nothing more than change it's priority variable. However, if
1014:../../FreeRTOS/Source/tasks.c **** 				the task is in a ready list it needs to be removed and placed
1015:../../FreeRTOS/Source/tasks.c **** 				in the queue appropriate to its new priority. */
1016:../../FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericLis
1017:../../FreeRTOS/Source/tasks.c **** 				{
1018:../../FreeRTOS/Source/tasks.c **** 					/* The task is currently in its ready list - remove before adding
1019:../../FreeRTOS/Source/tasks.c **** 					it to it's new ready list.  As we are in a critical section we
1020:../../FreeRTOS/Source/tasks.c **** 					can do this even if the scheduler is suspended. */
1021:../../FreeRTOS/Source/tasks.c **** 					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
1022:../../FreeRTOS/Source/tasks.c **** 					{
1023:../../FreeRTOS/Source/tasks.c **** 						taskRESET_READY_PRIORITY( uxPriorityUsedOnEntry );
1024:../../FreeRTOS/Source/tasks.c **** 					}
1025:../../FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
1026:../../FreeRTOS/Source/tasks.c **** 				}
1027:../../FreeRTOS/Source/tasks.c **** 
1028:../../FreeRTOS/Source/tasks.c **** 				if( xYieldRequired == pdTRUE )
1029:../../FreeRTOS/Source/tasks.c **** 				{
1030:../../FreeRTOS/Source/tasks.c **** 					portYIELD_WITHIN_API();
1031:../../FreeRTOS/Source/tasks.c **** 				}
1032:../../FreeRTOS/Source/tasks.c **** 			}
1033:../../FreeRTOS/Source/tasks.c **** 		}
1034:../../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1035:../../FreeRTOS/Source/tasks.c **** 
1036:../../FreeRTOS/Source/tasks.c **** 		/* Remove compiler warning about unused parameter when the port
1037:../../FreeRTOS/Source/tasks.c **** 		optimised task selection is not being used. */
1038:../../FreeRTOS/Source/tasks.c **** 		( void ) uxPriorityUsedOnEntry;
1039:../../FreeRTOS/Source/tasks.c **** 	}
1040:../../FreeRTOS/Source/tasks.c **** 
1041:../../FreeRTOS/Source/tasks.c **** #endif
1042:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1043:../../FreeRTOS/Source/tasks.c **** 
1044:../../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1045:../../FreeRTOS/Source/tasks.c **** 
1046:../../FreeRTOS/Source/tasks.c **** 	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
1047:../../FreeRTOS/Source/tasks.c **** 	{
 726               	.LM58:
 727               	.LFBB4:
 728 032c DF93      		push r29
 729 032e CF93      		push r28
 730 0330 00D0      		rcall .
 731 0332 00D0      		rcall .
 732 0334 CDB7      		in r28,__SP_L__
 733 0336 DEB7      		in r29,__SP_H__
 734               	/* prologue: function */
 735               	/* frame size = 6 */
 736 0338 9C83      		std Y+4,r25
 737 033a 8B83      		std Y+3,r24
1048:../../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
1049:../../FreeRTOS/Source/tasks.c **** 
1050:../../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 739               	.LM59:
 740               	/* #APP */
 741               	 ;  1050 "../../FreeRTOS/Source/tasks.c" 1
 742 033c 0FB6      		in		__tmp_reg__, __SREG__
 743               	 ;  0 "" 2
 744               	 ;  1050 "../../FreeRTOS/Source/tasks.c" 1
 745 033e F894      		cli
 746               	 ;  0 "" 2
 747               	 ;  1050 "../../FreeRTOS/Source/tasks.c" 1
 748 0340 0F92      		push	__tmp_reg__
 749               	 ;  0 "" 2
1051:../../FreeRTOS/Source/tasks.c **** 		{
1052:../../FreeRTOS/Source/tasks.c **** 			/* Ensure a yield is performed if the current task is being
1053:../../FreeRTOS/Source/tasks.c **** 			suspended. */
1054:../../FreeRTOS/Source/tasks.c **** 			if( pxTaskToSuspend == pxCurrentTCB )
 751               	.LM60:
 752               	/* #NOAPP */
 753 0342 2091 0000 		lds r18,pxCurrentTCB
 754 0346 3091 0000 		lds r19,(pxCurrentTCB)+1
 755 034a 8B81      		ldd r24,Y+3
 756 034c 9C81      		ldd r25,Y+4
 757 034e 8217      		cp r24,r18
 758 0350 9307      		cpc r25,r19
 759 0352 01F4      		brne .L25
1055:../../FreeRTOS/Source/tasks.c **** 			{
1056:../../FreeRTOS/Source/tasks.c **** 				pxTaskToSuspend = NULL;
 761               	.LM61:
 762 0354 1C82      		std Y+4,__zero_reg__
 763 0356 1B82      		std Y+3,__zero_reg__
 764               	.L25:
1057:../../FreeRTOS/Source/tasks.c **** 			}
1058:../../FreeRTOS/Source/tasks.c **** 
1059:../../FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are suspending ourselves. */
1060:../../FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 766               	.LM62:
 767 0358 8B81      		ldd r24,Y+3
 768 035a 9C81      		ldd r25,Y+4
 769 035c 0097      		sbiw r24,0
 770 035e 01F4      		brne .L26
 771 0360 8091 0000 		lds r24,pxCurrentTCB
 772 0364 9091 0000 		lds r25,(pxCurrentTCB)+1
 773 0368 9E83      		std Y+6,r25
 774 036a 8D83      		std Y+5,r24
 775 036c 00C0      		rjmp .L27
 776               	.L26:
 777 036e 8B81      		ldd r24,Y+3
 778 0370 9C81      		ldd r25,Y+4
 779 0372 9E83      		std Y+6,r25
 780 0374 8D83      		std Y+5,r24
 781               	.L27:
 782 0376 8D81      		ldd r24,Y+5
 783 0378 9E81      		ldd r25,Y+6
 784 037a 9A83      		std Y+2,r25
 785 037c 8983      		std Y+1,r24
1061:../../FreeRTOS/Source/tasks.c **** 
1062:../../FreeRTOS/Source/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
1063:../../FreeRTOS/Source/tasks.c **** 
1064:../../FreeRTOS/Source/tasks.c **** 			/* Remove task from the ready/delayed list and place in the	suspended list. */
1065:../../FreeRTOS/Source/tasks.c **** 			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
 787               	.LM63:
 788 037e 8981      		ldd r24,Y+1
 789 0380 9A81      		ldd r25,Y+2
 790 0382 0296      		adiw r24,2
 791 0384 0E94 0000 		call uxListRemove
1066:../../FreeRTOS/Source/tasks.c **** 			{
1067:../../FreeRTOS/Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1068:../../FreeRTOS/Source/tasks.c **** 			}
1069:../../FreeRTOS/Source/tasks.c **** 
1070:../../FreeRTOS/Source/tasks.c **** 			/* Is the task waiting on an event also? */
1071:../../FreeRTOS/Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 793               	.LM64:
 794 0388 E981      		ldd r30,Y+1
 795 038a FA81      		ldd r31,Y+2
 796 038c 8489      		ldd r24,Z+20
 797 038e 9589      		ldd r25,Z+21
 798 0390 0097      		sbiw r24,0
 799 0392 01F0      		breq .L28
1072:../../FreeRTOS/Source/tasks.c **** 			{
1073:../../FreeRTOS/Source/tasks.c **** 				uxListRemove( &( pxTCB->xEventListItem ) );
 801               	.LM65:
 802 0394 8981      		ldd r24,Y+1
 803 0396 9A81      		ldd r25,Y+2
 804 0398 0C96      		adiw r24,12
 805 039a 0E94 0000 		call uxListRemove
 806               	.L28:
1074:../../FreeRTOS/Source/tasks.c **** 			}
1075:../../FreeRTOS/Source/tasks.c **** 
1076:../../FreeRTOS/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 808               	.LM66:
 809 039e 8981      		ldd r24,Y+1
 810 03a0 9A81      		ldd r25,Y+2
 811 03a2 9C01      		movw r18,r24
 812 03a4 2E5F      		subi r18,lo8(-(2))
 813 03a6 3F4F      		sbci r19,hi8(-(2))
 814 03a8 80E0      		ldi r24,lo8(xSuspendedTaskList)
 815 03aa 90E0      		ldi r25,hi8(xSuspendedTaskList)
 816 03ac B901      		movw r22,r18
 817 03ae 0E94 0000 		call vListInsertEnd
1077:../../FreeRTOS/Source/tasks.c **** 		}
1078:../../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 819               	.LM67:
 820               	/* #APP */
 821               	 ;  1078 "../../FreeRTOS/Source/tasks.c" 1
 822 03b2 0F90      		pop		__tmp_reg__
 823               	 ;  0 "" 2
 824               	 ;  1078 "../../FreeRTOS/Source/tasks.c" 1
 825 03b4 0FBE      		out		__SREG__, __tmp_reg__
 826               	 ;  0 "" 2
1079:../../FreeRTOS/Source/tasks.c **** 
1080:../../FreeRTOS/Source/tasks.c **** 		if( ( void * ) pxTaskToSuspend == NULL )
 828               	.LM68:
 829               	/* #NOAPP */
 830 03b6 8B81      		ldd r24,Y+3
 831 03b8 9C81      		ldd r25,Y+4
 832 03ba 0097      		sbiw r24,0
 833 03bc 01F4      		brne .L32
1081:../../FreeRTOS/Source/tasks.c **** 		{
1082:../../FreeRTOS/Source/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
 835               	.LM69:
 836 03be 8091 0000 		lds r24,xSchedulerRunning
 837 03c2 8823      		tst r24
 838 03c4 01F0      		breq .L30
1083:../../FreeRTOS/Source/tasks.c **** 			{
1084:../../FreeRTOS/Source/tasks.c **** 				/* We have just suspended the current task. */
1085:../../FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 840               	.LM70:
 841 03c6 0E94 0000 		call vPortYield
 842 03ca 00C0      		rjmp .L32
 843               	.L30:
1086:../../FreeRTOS/Source/tasks.c **** 			}
1087:../../FreeRTOS/Source/tasks.c **** 			else
1088:../../FreeRTOS/Source/tasks.c **** 			{
1089:../../FreeRTOS/Source/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
1090:../../FreeRTOS/Source/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
1091:../../FreeRTOS/Source/tasks.c **** 				must be adjusted to point to a different task. */
1092:../../FreeRTOS/Source/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 845               	.LM71:
 846 03cc 9091 0000 		lds r25,xSuspendedTaskList
 847 03d0 8091 0000 		lds r24,uxCurrentNumberOfTasks
 848 03d4 9817      		cp r25,r24
 849 03d6 01F4      		brne .L31
1093:../../FreeRTOS/Source/tasks.c **** 				{
1094:../../FreeRTOS/Source/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
1095:../../FreeRTOS/Source/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
1096:../../FreeRTOS/Source/tasks.c **** 					be set to point to it no matter what its relative priority
1097:../../FreeRTOS/Source/tasks.c **** 					is. */
1098:../../FreeRTOS/Source/tasks.c **** 					pxCurrentTCB = NULL;
 851               	.LM72:
 852 03d8 1092 0000 		sts (pxCurrentTCB)+1,__zero_reg__
 853 03dc 1092 0000 		sts pxCurrentTCB,__zero_reg__
 854 03e0 00C0      		rjmp .L32
 855               	.L31:
1099:../../FreeRTOS/Source/tasks.c **** 				}
1100:../../FreeRTOS/Source/tasks.c **** 				else
1101:../../FreeRTOS/Source/tasks.c **** 				{
1102:../../FreeRTOS/Source/tasks.c **** 					vTaskSwitchContext();
 857               	.LM73:
 858 03e2 0E94 0000 		call vTaskSwitchContext
 859               	.L32:
 860               	/* epilogue start */
1103:../../FreeRTOS/Source/tasks.c **** 				}
1104:../../FreeRTOS/Source/tasks.c **** 			}
1105:../../FreeRTOS/Source/tasks.c **** 		}
1106:../../FreeRTOS/Source/tasks.c **** 	}
 862               	.LM74:
 863 03e6 2696      		adiw r28,6
 864 03e8 0FB6      		in __tmp_reg__,__SREG__
 865 03ea F894      		cli
 866 03ec DEBF      		out __SP_H__,r29
 867 03ee 0FBE      		out __SREG__,__tmp_reg__
 868 03f0 CDBF      		out __SP_L__,r28
 869 03f2 CF91      		pop r28
 870 03f4 DF91      		pop r29
 871 03f6 0895      		ret
 876               	.Lscope4:
 878               		.stabd	78,0,0
 881               	.global	xTaskIsTaskSuspended
 883               	xTaskIsTaskSuspended:
 884               		.stabd	46,0,0
1107:../../FreeRTOS/Source/tasks.c **** 
1108:../../FreeRTOS/Source/tasks.c **** #endif
1109:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1110:../../FreeRTOS/Source/tasks.c **** 
1111:../../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1112:../../FreeRTOS/Source/tasks.c **** 
1113:../../FreeRTOS/Source/tasks.c **** 	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
1114:../../FreeRTOS/Source/tasks.c **** 	{
 886               	.LM75:
 887               	.LFBB5:
 888 03f8 DF93      		push r29
 889 03fa CF93      		push r28
 890 03fc 00D0      		rcall .
 891 03fe 0F92      		push __tmp_reg__
 892 0400 0F92      		push __tmp_reg__
 893 0402 CDB7      		in r28,__SP_L__
 894 0404 DEB7      		in r29,__SP_H__
 895               	/* prologue: function */
 896               	/* frame size = 5 */
 897 0406 9D83      		std Y+5,r25
 898 0408 8C83      		std Y+4,r24
1115:../../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xReturn = pdFALSE;
 900               	.LM76:
 901 040a 1B82      		std Y+3,__zero_reg__
1116:../../FreeRTOS/Source/tasks.c **** 	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
 903               	.LM77:
 904 040c 8C81      		ldd r24,Y+4
 905 040e 9D81      		ldd r25,Y+5
 906 0410 9A83      		std Y+2,r25
 907 0412 8983      		std Y+1,r24
1117:../../FreeRTOS/Source/tasks.c **** 
1118:../../FreeRTOS/Source/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
1119:../../FreeRTOS/Source/tasks.c **** 		configASSERT( xTask );
1120:../../FreeRTOS/Source/tasks.c **** 
1121:../../FreeRTOS/Source/tasks.c **** 		/* Is the task we are attempting to resume actually in the
1122:../../FreeRTOS/Source/tasks.c **** 		suspended list? */
1123:../../FreeRTOS/Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 909               	.LM78:
 910 0414 E981      		ldd r30,Y+1
 911 0416 FA81      		ldd r31,Y+2
 912 0418 8285      		ldd r24,Z+10
 913 041a 9385      		ldd r25,Z+11
 914 041c 20E0      		ldi r18,hi8(xSuspendedTaskList)
 915 041e 8030      		cpi r24,lo8(xSuspendedTaskList)
 916 0420 9207      		cpc r25,r18
 917 0422 01F4      		brne .L34
1124:../../FreeRTOS/Source/tasks.c **** 		{
1125:../../FreeRTOS/Source/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
1126:../../FreeRTOS/Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
 919               	.LM79:
 920 0424 E981      		ldd r30,Y+1
 921 0426 FA81      		ldd r31,Y+2
 922 0428 8489      		ldd r24,Z+20
 923 042a 9589      		ldd r25,Z+21
 924 042c 20E0      		ldi r18,hi8(xPendingReadyList)
 925 042e 8030      		cpi r24,lo8(xPendingReadyList)
 926 0430 9207      		cpc r25,r18
 927 0432 01F0      		breq .L34
1127:../../FreeRTOS/Source/tasks.c **** 			{
1128:../../FreeRTOS/Source/tasks.c **** 				/* Is it in the suspended list because it is in the
1129:../../FreeRTOS/Source/tasks.c **** 				Suspended state?  It is possible to be in the suspended
1130:../../FreeRTOS/Source/tasks.c **** 				list because it is blocked on a task with no timeout
1131:../../FreeRTOS/Source/tasks.c **** 				specified. */
1132:../../FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
 929               	.LM80:
 930 0434 E981      		ldd r30,Y+1
 931 0436 FA81      		ldd r31,Y+2
 932 0438 8489      		ldd r24,Z+20
 933 043a 9589      		ldd r25,Z+21
 934 043c 0097      		sbiw r24,0
 935 043e 01F4      		brne .L34
1133:../../FreeRTOS/Source/tasks.c **** 				{
1134:../../FreeRTOS/Source/tasks.c **** 					xReturn = pdTRUE;
 937               	.LM81:
 938 0440 81E0      		ldi r24,lo8(1)
 939 0442 8B83      		std Y+3,r24
 940               	.L34:
1135:../../FreeRTOS/Source/tasks.c **** 				}
1136:../../FreeRTOS/Source/tasks.c **** 			}
1137:../../FreeRTOS/Source/tasks.c **** 		}
1138:../../FreeRTOS/Source/tasks.c **** 
1139:../../FreeRTOS/Source/tasks.c **** 		return xReturn;
 942               	.LM82:
 943 0444 8B81      		ldd r24,Y+3
 944               	/* epilogue start */
1140:../../FreeRTOS/Source/tasks.c **** 	}
 946               	.LM83:
 947 0446 0F90      		pop __tmp_reg__
 948 0448 0F90      		pop __tmp_reg__
 949 044a 0F90      		pop __tmp_reg__
 950 044c 0F90      		pop __tmp_reg__
 951 044e 0F90      		pop __tmp_reg__
 952 0450 CF91      		pop r28
 953 0452 DF91      		pop r29
 954 0454 0895      		ret
 960               	.Lscope5:
 962               		.stabd	78,0,0
 965               	.global	vTaskResume
 967               	vTaskResume:
 968               		.stabd	46,0,0
1141:../../FreeRTOS/Source/tasks.c **** 
1142:../../FreeRTOS/Source/tasks.c **** #endif
1143:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1144:../../FreeRTOS/Source/tasks.c **** 
1145:../../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1146:../../FreeRTOS/Source/tasks.c **** 
1147:../../FreeRTOS/Source/tasks.c **** 	void vTaskResume( xTaskHandle pxTaskToResume )
1148:../../FreeRTOS/Source/tasks.c **** 	{
 970               	.LM84:
 971               	.LFBB6:
 972 0456 DF93      		push r29
 973 0458 CF93      		push r28
 974 045a 00D0      		rcall .
 975 045c 0F92      		push __tmp_reg__
 976 045e CDB7      		in r28,__SP_L__
 977 0460 DEB7      		in r29,__SP_H__
 978               	/* prologue: function */
 979               	/* frame size = 4 */
 980 0462 9C83      		std Y+4,r25
 981 0464 8B83      		std Y+3,r24
1149:../../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
1150:../../FreeRTOS/Source/tasks.c **** 
1151:../../FreeRTOS/Source/tasks.c **** 		/* It does not make sense to resume the calling task. */
1152:../../FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskToResume );
1153:../../FreeRTOS/Source/tasks.c **** 
1154:../../FreeRTOS/Source/tasks.c **** 		/* Remove the task from whichever list it is currently in, and place
1155:../../FreeRTOS/Source/tasks.c **** 		it in the ready list. */
1156:../../FreeRTOS/Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 983               	.LM85:
 984 0466 8B81      		ldd r24,Y+3
 985 0468 9C81      		ldd r25,Y+4
 986 046a 9A83      		std Y+2,r25
 987 046c 8983      		std Y+1,r24
1157:../../FreeRTOS/Source/tasks.c **** 
1158:../../FreeRTOS/Source/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
1159:../../FreeRTOS/Source/tasks.c **** 		currently executing task. */
1160:../../FreeRTOS/Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 989               	.LM86:
 990 046e 8981      		ldd r24,Y+1
 991 0470 9A81      		ldd r25,Y+2
 992 0472 0097      		sbiw r24,0
 993 0474 01F4      		brne .+2
 994 0476 00C0      		rjmp .L40
 995 0478 2091 0000 		lds r18,pxCurrentTCB
 996 047c 3091 0000 		lds r19,(pxCurrentTCB)+1
 997 0480 8981      		ldd r24,Y+1
 998 0482 9A81      		ldd r25,Y+2
 999 0484 8217      		cp r24,r18
 1000 0486 9307      		cpc r25,r19
 1001 0488 01F4      		brne .+2
 1002 048a 00C0      		rjmp .L40
1161:../../FreeRTOS/Source/tasks.c **** 		{
1162:../../FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
 1004               	.LM87:
 1005               	/* #APP */
 1006               	 ;  1162 "../../FreeRTOS/Source/tasks.c" 1
 1007 048c 0FB6      		in		__tmp_reg__, __SREG__
 1008               	 ;  0 "" 2
 1009               	 ;  1162 "../../FreeRTOS/Source/tasks.c" 1
 1010 048e F894      		cli
 1011               	 ;  0 "" 2
 1012               	 ;  1162 "../../FreeRTOS/Source/tasks.c" 1
 1013 0490 0F92      		push	__tmp_reg__
 1014               	 ;  0 "" 2
1163:../../FreeRTOS/Source/tasks.c **** 			{
1164:../../FreeRTOS/Source/tasks.c **** 				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1016               	.LM88:
 1017               	/* #NOAPP */
 1018 0492 8981      		ldd r24,Y+1
 1019 0494 9A81      		ldd r25,Y+2
 1020 0496 0E94 0000 		call xTaskIsTaskSuspended
 1021 049a 8130      		cpi r24,lo8(1)
 1022 049c 01F4      		brne .L38
1165:../../FreeRTOS/Source/tasks.c **** 				{
1166:../../FreeRTOS/Source/tasks.c **** 					traceTASK_RESUME( pxTCB );
1167:../../FreeRTOS/Source/tasks.c **** 
1168:../../FreeRTOS/Source/tasks.c **** 					/* As we are in a critical section we can access the ready
1169:../../FreeRTOS/Source/tasks.c **** 					lists even if the scheduler is suspended. */
1170:../../FreeRTOS/Source/tasks.c **** 					uxListRemove(  &( pxTCB->xGenericListItem ) );
 1024               	.LM89:
 1025 049e 8981      		ldd r24,Y+1
 1026 04a0 9A81      		ldd r25,Y+2
 1027 04a2 0296      		adiw r24,2
 1028 04a4 0E94 0000 		call uxListRemove
1171:../../FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1030               	.LM90:
 1031 04a8 E981      		ldd r30,Y+1
 1032 04aa FA81      		ldd r31,Y+2
 1033 04ac 9689      		ldd r25,Z+22
 1034 04ae 8091 0000 		lds r24,uxTopReadyPriority
 1035 04b2 8917      		cp r24,r25
 1036 04b4 00F4      		brsh .L39
 1037 04b6 E981      		ldd r30,Y+1
 1038 04b8 FA81      		ldd r31,Y+2
 1039 04ba 8689      		ldd r24,Z+22
 1040 04bc 8093 0000 		sts uxTopReadyPriority,r24
 1041               	.L39:
 1042 04c0 E981      		ldd r30,Y+1
 1043 04c2 FA81      		ldd r31,Y+2
 1044 04c4 8689      		ldd r24,Z+22
 1045 04c6 282F      		mov r18,r24
 1046 04c8 30E0      		ldi r19,lo8(0)
 1047 04ca C901      		movw r24,r18
 1048 04cc 880F      		lsl r24
 1049 04ce 991F      		rol r25
 1050 04d0 880F      		lsl r24
 1051 04d2 991F      		rol r25
 1052 04d4 880F      		lsl r24
 1053 04d6 991F      		rol r25
 1054 04d8 820F      		add r24,r18
 1055 04da 931F      		adc r25,r19
 1056 04dc AC01      		movw r20,r24
 1057 04de 4050      		subi r20,lo8(-(pxReadyTasksLists))
 1058 04e0 5040      		sbci r21,hi8(-(pxReadyTasksLists))
 1059 04e2 8981      		ldd r24,Y+1
 1060 04e4 9A81      		ldd r25,Y+2
 1061 04e6 9C01      		movw r18,r24
 1062 04e8 2E5F      		subi r18,lo8(-(2))
 1063 04ea 3F4F      		sbci r19,hi8(-(2))
 1064 04ec CA01      		movw r24,r20
 1065 04ee B901      		movw r22,r18
 1066 04f0 0E94 0000 		call vListInsertEnd
1172:../../FreeRTOS/Source/tasks.c **** 
1173:../../FreeRTOS/Source/tasks.c **** 					/* We may have just resumed a higher priority task. */
1174:../../FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1068               	.LM91:
 1069 04f4 E981      		ldd r30,Y+1
 1070 04f6 FA81      		ldd r31,Y+2
 1071 04f8 9689      		ldd r25,Z+22
 1072 04fa E091 0000 		lds r30,pxCurrentTCB
 1073 04fe F091 0000 		lds r31,(pxCurrentTCB)+1
 1074 0502 8689      		ldd r24,Z+22
 1075 0504 9817      		cp r25,r24
 1076 0506 00F0      		brlo .L38
1175:../../FreeRTOS/Source/tasks.c **** 					{
1176:../../FreeRTOS/Source/tasks.c **** 						/* This yield may not cause the task just resumed to run, but
1177:../../FreeRTOS/Source/tasks.c **** 						will leave the lists in the correct state for the next yield. */
1178:../../FreeRTOS/Source/tasks.c **** 						portYIELD_WITHIN_API();
 1078               	.LM92:
 1079 0508 0E94 0000 		call vPortYield
 1080               	.L38:
1179:../../FreeRTOS/Source/tasks.c **** 					}
1180:../../FreeRTOS/Source/tasks.c **** 				}
1181:../../FreeRTOS/Source/tasks.c **** 			}
1182:../../FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
 1082               	.LM93:
 1083               	/* #APP */
 1084               	 ;  1182 "../../FreeRTOS/Source/tasks.c" 1
 1085 050c 0F90      		pop		__tmp_reg__
 1086               	 ;  0 "" 2
 1087               	 ;  1182 "../../FreeRTOS/Source/tasks.c" 1
 1088 050e 0FBE      		out		__SREG__, __tmp_reg__
 1089               	 ;  0 "" 2
 1090               	/* #NOAPP */
 1091               	.L40:
 1092               	/* epilogue start */
1183:../../FreeRTOS/Source/tasks.c **** 		}
1184:../../FreeRTOS/Source/tasks.c **** 	}
 1094               	.LM94:
 1095 0510 0F90      		pop __tmp_reg__
 1096 0512 0F90      		pop __tmp_reg__
 1097 0514 0F90      		pop __tmp_reg__
 1098 0516 0F90      		pop __tmp_reg__
 1099 0518 CF91      		pop r28
 1100 051a DF91      		pop r29
 1101 051c 0895      		ret
 1106               	.Lscope6:
 1108               		.stabd	78,0,0
 1111               	.global	xTaskResumeFromISR
 1113               	xTaskResumeFromISR:
 1114               		.stabd	46,0,0
1185:../../FreeRTOS/Source/tasks.c **** 
1186:../../FreeRTOS/Source/tasks.c **** #endif
1187:../../FreeRTOS/Source/tasks.c **** 
1188:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1189:../../FreeRTOS/Source/tasks.c **** 
1190:../../FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1191:../../FreeRTOS/Source/tasks.c **** 
1192:../../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
1193:../../FreeRTOS/Source/tasks.c **** 	{
 1116               	.LM95:
 1117               	.LFBB7:
 1118 051e DF93      		push r29
 1119 0520 CF93      		push r28
 1120 0522 00D0      		rcall .
 1121 0524 00D0      		rcall .
 1122 0526 CDB7      		in r28,__SP_L__
 1123 0528 DEB7      		in r29,__SP_H__
 1124               	/* prologue: function */
 1125               	/* frame size = 6 */
 1126 052a 9E83      		std Y+6,r25
 1127 052c 8D83      		std Y+5,r24
1194:../../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 1129               	.LM96:
 1130 052e 1C82      		std Y+4,__zero_reg__
1195:../../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
1196:../../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxSavedInterruptStatus;
1197:../../FreeRTOS/Source/tasks.c **** 
1198:../../FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskToResume );
1199:../../FreeRTOS/Source/tasks.c **** 
1200:../../FreeRTOS/Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 1132               	.LM97:
 1133 0530 8D81      		ldd r24,Y+5
 1134 0532 9E81      		ldd r25,Y+6
 1135 0534 9B83      		std Y+3,r25
 1136 0536 8A83      		std Y+2,r24
1201:../../FreeRTOS/Source/tasks.c **** 
1202:../../FreeRTOS/Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1138               	.LM98:
 1139 0538 1982      		std Y+1,__zero_reg__
1203:../../FreeRTOS/Source/tasks.c **** 		{
1204:../../FreeRTOS/Source/tasks.c **** 			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1141               	.LM99:
 1142 053a 8A81      		ldd r24,Y+2
 1143 053c 9B81      		ldd r25,Y+3
 1144 053e 0E94 0000 		call xTaskIsTaskSuspended
 1145 0542 8130      		cpi r24,lo8(1)
 1146 0544 01F0      		breq .+2
 1147 0546 00C0      		rjmp .L42
1205:../../FreeRTOS/Source/tasks.c **** 			{
1206:../../FreeRTOS/Source/tasks.c **** 				traceTASK_RESUME_FROM_ISR( pxTCB );
1207:../../FreeRTOS/Source/tasks.c **** 
1208:../../FreeRTOS/Source/tasks.c **** 				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1149               	.LM100:
 1150 0548 8091 0000 		lds r24,uxSchedulerSuspended
 1151 054c 8823      		tst r24
 1152 054e 01F4      		brne .L43
1209:../../FreeRTOS/Source/tasks.c **** 				{
1210:../../FreeRTOS/Source/tasks.c **** 					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
 1154               	.LM101:
 1155 0550 EA81      		ldd r30,Y+2
 1156 0552 FB81      		ldd r31,Y+3
 1157 0554 9689      		ldd r25,Z+22
 1158 0556 E091 0000 		lds r30,pxCurrentTCB
 1159 055a F091 0000 		lds r31,(pxCurrentTCB)+1
 1160 055e 8689      		ldd r24,Z+22
 1161 0560 1C82      		std Y+4,__zero_reg__
 1162 0562 9817      		cp r25,r24
 1163 0564 00F0      		brlo .L44
 1164 0566 81E0      		ldi r24,lo8(1)
 1165 0568 8C83      		std Y+4,r24
 1166               	.L44:
1211:../../FreeRTOS/Source/tasks.c **** 					uxListRemove(  &( pxTCB->xGenericListItem ) );
 1168               	.LM102:
 1169 056a 8A81      		ldd r24,Y+2
 1170 056c 9B81      		ldd r25,Y+3
 1171 056e 0296      		adiw r24,2
 1172 0570 0E94 0000 		call uxListRemove
1212:../../FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1174               	.LM103:
 1175 0574 EA81      		ldd r30,Y+2
 1176 0576 FB81      		ldd r31,Y+3
 1177 0578 9689      		ldd r25,Z+22
 1178 057a 8091 0000 		lds r24,uxTopReadyPriority
 1179 057e 8917      		cp r24,r25
 1180 0580 00F4      		brsh .L45
 1181 0582 EA81      		ldd r30,Y+2
 1182 0584 FB81      		ldd r31,Y+3
 1183 0586 8689      		ldd r24,Z+22
 1184 0588 8093 0000 		sts uxTopReadyPriority,r24
 1185               	.L45:
 1186 058c EA81      		ldd r30,Y+2
 1187 058e FB81      		ldd r31,Y+3
 1188 0590 8689      		ldd r24,Z+22
 1189 0592 282F      		mov r18,r24
 1190 0594 30E0      		ldi r19,lo8(0)
 1191 0596 C901      		movw r24,r18
 1192 0598 880F      		lsl r24
 1193 059a 991F      		rol r25
 1194 059c 880F      		lsl r24
 1195 059e 991F      		rol r25
 1196 05a0 880F      		lsl r24
 1197 05a2 991F      		rol r25
 1198 05a4 820F      		add r24,r18
 1199 05a6 931F      		adc r25,r19
 1200 05a8 AC01      		movw r20,r24
 1201 05aa 4050      		subi r20,lo8(-(pxReadyTasksLists))
 1202 05ac 5040      		sbci r21,hi8(-(pxReadyTasksLists))
 1203 05ae 8A81      		ldd r24,Y+2
 1204 05b0 9B81      		ldd r25,Y+3
 1205 05b2 9C01      		movw r18,r24
 1206 05b4 2E5F      		subi r18,lo8(-(2))
 1207 05b6 3F4F      		sbci r19,hi8(-(2))
 1208 05b8 CA01      		movw r24,r20
 1209 05ba B901      		movw r22,r18
 1210 05bc 0E94 0000 		call vListInsertEnd
 1211 05c0 00C0      		rjmp .L42
 1212               	.L43:
1213:../../FreeRTOS/Source/tasks.c **** 				}
1214:../../FreeRTOS/Source/tasks.c **** 				else
1215:../../FreeRTOS/Source/tasks.c **** 				{
1216:../../FreeRTOS/Source/tasks.c **** 					/* We cannot access the delayed or ready lists, so will hold this
1217:../../FreeRTOS/Source/tasks.c **** 					task pending until the scheduler is resumed, at which point a
1218:../../FreeRTOS/Source/tasks.c **** 					yield will be performed if necessary. */
1219:../../FreeRTOS/Source/tasks.c **** 					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 1214               	.LM104:
 1215 05c2 8A81      		ldd r24,Y+2
 1216 05c4 9B81      		ldd r25,Y+3
 1217 05c6 9C01      		movw r18,r24
 1218 05c8 245F      		subi r18,lo8(-(12))
 1219 05ca 3F4F      		sbci r19,hi8(-(12))
 1220 05cc 80E0      		ldi r24,lo8(xPendingReadyList)
 1221 05ce 90E0      		ldi r25,hi8(xPendingReadyList)
 1222 05d0 B901      		movw r22,r18
 1223 05d2 0E94 0000 		call vListInsertEnd
 1224               	.L42:
1220:../../FreeRTOS/Source/tasks.c **** 				}
1221:../../FreeRTOS/Source/tasks.c **** 			}
1222:../../FreeRTOS/Source/tasks.c **** 		}
1223:../../FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1224:../../FreeRTOS/Source/tasks.c **** 
1225:../../FreeRTOS/Source/tasks.c **** 		return xYieldRequired;
 1226               	.LM105:
 1227 05d6 8C81      		ldd r24,Y+4
 1228               	/* epilogue start */
1226:../../FreeRTOS/Source/tasks.c **** 	}
 1230               	.LM106:
 1231 05d8 2696      		adiw r28,6
 1232 05da 0FB6      		in __tmp_reg__,__SREG__
 1233 05dc F894      		cli
 1234 05de DEBF      		out __SP_H__,r29
 1235 05e0 0FBE      		out __SREG__,__tmp_reg__
 1236 05e2 CDBF      		out __SP_L__,r28
 1237 05e4 CF91      		pop r28
 1238 05e6 DF91      		pop r29
 1239 05e8 0895      		ret
 1246               	.Lscope7:
 1248               		.stabd	78,0,0
 1249               		.data
 1250               	.LC0:
 1251 0002 4944 4C45 		.string	"IDLE"
 1251      00
 1252               		.text
 1254               	.global	vTaskStartScheduler
 1256               	vTaskStartScheduler:
 1257               		.stabd	46,0,0
1227:../../FreeRTOS/Source/tasks.c **** 
1228:../../FreeRTOS/Source/tasks.c **** #endif
1229:../../FreeRTOS/Source/tasks.c **** 
1230:../../FreeRTOS/Source/tasks.c **** 
1231:../../FreeRTOS/Source/tasks.c **** 
1232:../../FreeRTOS/Source/tasks.c **** 
1233:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
1234:../../FreeRTOS/Source/tasks.c ****  * PUBLIC SCHEDULER CONTROL documented in task.h
1235:../../FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
1236:../../FreeRTOS/Source/tasks.c **** 
1237:../../FreeRTOS/Source/tasks.c **** 
1238:../../FreeRTOS/Source/tasks.c **** void vTaskStartScheduler( void )
1239:../../FreeRTOS/Source/tasks.c **** {
 1259               	.LM107:
 1260               	.LFBB8:
 1261 05ea AF92      		push r10
 1262 05ec BF92      		push r11
 1263 05ee CF92      		push r12
 1264 05f0 DF92      		push r13
 1265 05f2 EF92      		push r14
 1266 05f4 FF92      		push r15
 1267 05f6 0F93      		push r16
 1268 05f8 DF93      		push r29
 1269 05fa CF93      		push r28
 1270 05fc 0F92      		push __tmp_reg__
 1271 05fe CDB7      		in r28,__SP_L__
 1272 0600 DEB7      		in r29,__SP_H__
 1273               	/* prologue: function */
 1274               	/* frame size = 1 */
1240:../../FreeRTOS/Source/tasks.c **** portBASE_TYPE xReturn;
1241:../../FreeRTOS/Source/tasks.c **** 
1242:../../FreeRTOS/Source/tasks.c **** 	/* Add the idle task at the lowest priority. */
1243:../../FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1244:../../FreeRTOS/Source/tasks.c **** 	{
1245:../../FreeRTOS/Source/tasks.c **** 		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
1246:../../FreeRTOS/Source/tasks.c **** 		be returned by the xTaskGetIdleTaskHandle() function. */
1247:../../FreeRTOS/Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
1248:../../FreeRTOS/Source/tasks.c **** 	}
1249:../../FreeRTOS/Source/tasks.c **** 	#else
1250:../../FreeRTOS/Source/tasks.c **** 	{
1251:../../FreeRTOS/Source/tasks.c **** 		/* Create the idle task without storing its handle. */
1252:../../FreeRTOS/Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
 1276               	.LM108:
 1277 0602 80E0      		ldi r24,lo8(gs(prvIdleTask))
 1278 0604 90E0      		ldi r25,hi8(gs(prvIdleTask))
 1279 0606 20E0      		ldi r18,lo8(.LC0)
 1280 0608 30E0      		ldi r19,hi8(.LC0)
 1281 060a B901      		movw r22,r18
 1282 060c 45E5      		ldi r20,lo8(85)
 1283 060e 50E0      		ldi r21,hi8(85)
 1284 0610 20E0      		ldi r18,lo8(0)
 1285 0612 30E0      		ldi r19,hi8(0)
 1286 0614 00E0      		ldi r16,lo8(0)
 1287 0616 EE24      		clr r14
 1288 0618 FF24      		clr r15
 1289 061a CC24      		clr r12
 1290 061c DD24      		clr r13
 1291 061e AA24      		clr r10
 1292 0620 BB24      		clr r11
 1293 0622 0E94 0000 		call xTaskGenericCreate
 1294 0626 8983      		std Y+1,r24
1253:../../FreeRTOS/Source/tasks.c **** 	}
1254:../../FreeRTOS/Source/tasks.c **** 	#endif
1255:../../FreeRTOS/Source/tasks.c **** 
1256:../../FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
1257:../../FreeRTOS/Source/tasks.c **** 	{
1258:../../FreeRTOS/Source/tasks.c **** 		if( xReturn == pdPASS )
1259:../../FreeRTOS/Source/tasks.c **** 		{
1260:../../FreeRTOS/Source/tasks.c **** 			xReturn = xTimerCreateTimerTask();
1261:../../FreeRTOS/Source/tasks.c **** 		}
1262:../../FreeRTOS/Source/tasks.c **** 	}
1263:../../FreeRTOS/Source/tasks.c **** 	#endif
1264:../../FreeRTOS/Source/tasks.c **** 
1265:../../FreeRTOS/Source/tasks.c **** 	if( xReturn == pdPASS )
 1296               	.LM109:
 1297 0628 8981      		ldd r24,Y+1
 1298 062a 8130      		cpi r24,lo8(1)
 1299 062c 01F4      		brne .L49
1266:../../FreeRTOS/Source/tasks.c **** 	{
1267:../../FreeRTOS/Source/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1268:../../FreeRTOS/Source/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1269:../../FreeRTOS/Source/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1270:../../FreeRTOS/Source/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1271:../../FreeRTOS/Source/tasks.c **** 		starts to run.
1272:../../FreeRTOS/Source/tasks.c **** 
1273:../../FreeRTOS/Source/tasks.c **** 		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
1274:../../FreeRTOS/Source/tasks.c **** 		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
1275:../../FreeRTOS/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
 1301               	.LM110:
 1302               	/* #APP */
 1303               	 ;  1275 "../../FreeRTOS/Source/tasks.c" 1
 1304 062e F894      		cli
 1305               	 ;  0 "" 2
1276:../../FreeRTOS/Source/tasks.c **** 
1277:../../FreeRTOS/Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
 1307               	.LM111:
 1308               	/* #NOAPP */
 1309 0630 81E0      		ldi r24,lo8(1)
 1310 0632 8093 0000 		sts xSchedulerRunning,r24
1278:../../FreeRTOS/Source/tasks.c **** 		xTickCount = ( portTickType ) 0U;
 1312               	.LM112:
 1313 0636 1092 0000 		sts (xTickCount)+1,__zero_reg__
 1314 063a 1092 0000 		sts xTickCount,__zero_reg__
1279:../../FreeRTOS/Source/tasks.c **** 
1280:../../FreeRTOS/Source/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1281:../../FreeRTOS/Source/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
1282:../../FreeRTOS/Source/tasks.c **** 		the run time counter time base. */
1283:../../FreeRTOS/Source/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1284:../../FreeRTOS/Source/tasks.c **** 
1285:../../FreeRTOS/Source/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
1286:../../FreeRTOS/Source/tasks.c **** 		portable interface. */
1287:../../FreeRTOS/Source/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
 1316               	.LM113:
 1317 063e 0E94 0000 		call xPortStartScheduler
 1318               	.L49:
 1319               	/* epilogue start */
1288:../../FreeRTOS/Source/tasks.c **** 		{
1289:../../FreeRTOS/Source/tasks.c **** 			/* Should not reach here as if the scheduler is running the
1290:../../FreeRTOS/Source/tasks.c **** 			function will not return. */
1291:../../FreeRTOS/Source/tasks.c **** 		}
1292:../../FreeRTOS/Source/tasks.c **** 		else
1293:../../FreeRTOS/Source/tasks.c **** 		{
1294:../../FreeRTOS/Source/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1295:../../FreeRTOS/Source/tasks.c **** 		}
1296:../../FreeRTOS/Source/tasks.c **** 	}
1297:../../FreeRTOS/Source/tasks.c **** 
1298:../../FreeRTOS/Source/tasks.c **** 	/* This line will only be reached if the kernel could not be started. */
1299:../../FreeRTOS/Source/tasks.c **** 	configASSERT( xReturn );
1300:../../FreeRTOS/Source/tasks.c **** }
 1321               	.LM114:
 1322 0642 0F90      		pop __tmp_reg__
 1323 0644 CF91      		pop r28
 1324 0646 DF91      		pop r29
 1325 0648 0F91      		pop r16
 1326 064a FF90      		pop r15
 1327 064c EF90      		pop r14
 1328 064e DF90      		pop r13
 1329 0650 CF90      		pop r12
 1330 0652 BF90      		pop r11
 1331 0654 AF90      		pop r10
 1332 0656 0895      		ret
 1337               	.Lscope8:
 1339               		.stabd	78,0,0
 1341               	.global	vTaskEndScheduler
 1343               	vTaskEndScheduler:
 1344               		.stabd	46,0,0
1301:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1302:../../FreeRTOS/Source/tasks.c **** 
1303:../../FreeRTOS/Source/tasks.c **** void vTaskEndScheduler( void )
1304:../../FreeRTOS/Source/tasks.c **** {
 1346               	.LM115:
 1347               	.LFBB9:
 1348 0658 DF93      		push r29
 1349 065a CF93      		push r28
 1350 065c CDB7      		in r28,__SP_L__
 1351 065e DEB7      		in r29,__SP_H__
 1352               	/* prologue: function */
 1353               	/* frame size = 0 */
1305:../../FreeRTOS/Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
1306:../../FreeRTOS/Source/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
1307:../../FreeRTOS/Source/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
1308:../../FreeRTOS/Source/tasks.c **** 	portDISABLE_INTERRUPTS();
 1355               	.LM116:
 1356               	/* #APP */
 1357               	 ;  1308 "../../FreeRTOS/Source/tasks.c" 1
 1358 0660 F894      		cli
 1359               	 ;  0 "" 2
1309:../../FreeRTOS/Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
 1361               	.LM117:
 1362               	/* #NOAPP */
 1363 0662 1092 0000 		sts xSchedulerRunning,__zero_reg__
1310:../../FreeRTOS/Source/tasks.c **** 	vPortEndScheduler();
 1365               	.LM118:
 1366 0666 0E94 0000 		call vPortEndScheduler
 1367               	/* epilogue start */
1311:../../FreeRTOS/Source/tasks.c **** }
 1369               	.LM119:
 1370 066a CF91      		pop r28
 1371 066c DF91      		pop r29
 1372 066e 0895      		ret
 1374               	.Lscope9:
 1376               		.stabd	78,0,0
 1378               	.global	vTaskSuspendAll
 1380               	vTaskSuspendAll:
 1381               		.stabd	46,0,0
1312:../../FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1313:../../FreeRTOS/Source/tasks.c **** 
1314:../../FreeRTOS/Source/tasks.c **** void vTaskSuspendAll( void )
1315:../../FreeRTOS/Source/tasks.c **** {
 1383               	.LM120:
 1384               	.LFBB10:
 1385 0670 DF93      		push r29
 1386 0672 CF93      		push r28
 1387 0674 CDB7      		in r28,__SP_L__
 1388 0676 DEB7      		in r29,__SP_H__
 1389               	/* prologue: function */
 1390               	/* frame size = 0 */
1316:../../FreeRTOS/Source/tasks.c **** 	/* A critical section is not required as the variable is of type
1317:../../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE. */
1318:../../FreeRTOS/Source/tasks.c **** 	++uxSchedulerSuspended;
 1392               	.LM121:
 1393 0678 8091 0000 		lds r24,uxSchedulerSuspended
 1394 067c 8F5F      		subi r24,lo8(-(1))
 1395 067e 8093 0000 		sts uxSchedulerSuspended,r24
 1396               	/* epilogue start */
1319:../../FreeRTOS/Source/tasks.c **** }
 1398               	.LM122:
 1399 0682 CF91      		pop r28
 1400 0684 DF91      		pop r29
 1401 0686 0895      		ret
 1403               	.Lscope10:
 1405               		.stabd	78,0,0
 1407               	.global	xTaskResumeAll
 1409               	xTaskResumeAll:
 1410               		.stabd	46,0,0
1320:../../FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1321:../../FreeRTOS/Source/tasks.c **** 
1322:../../FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
1323:../../FreeRTOS/Source/tasks.c **** 
1324:../../FreeRTOS/Source/tasks.c **** 	portTickType prvGetExpectedIdleTime( void )
1325:../../FreeRTOS/Source/tasks.c **** 	{
1326:../../FreeRTOS/Source/tasks.c **** 	portTickType xReturn;
1327:../../FreeRTOS/Source/tasks.c **** 
1328:../../FreeRTOS/Source/tasks.c **** 		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
1329:../../FreeRTOS/Source/tasks.c **** 		{
1330:../../FreeRTOS/Source/tasks.c **** 			xReturn = 0;
1331:../../FreeRTOS/Source/tasks.c **** 		}
1332:../../FreeRTOS/Source/tasks.c **** 		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
1333:../../FreeRTOS/Source/tasks.c **** 		{
1334:../../FreeRTOS/Source/tasks.c **** 			/* There are other idle priority tasks in the ready state.  If
1335:../../FreeRTOS/Source/tasks.c **** 			time slicing is used then the very next tick interrupt must be
1336:../../FreeRTOS/Source/tasks.c **** 			processed. */
1337:../../FreeRTOS/Source/tasks.c **** 			xReturn = 0;
1338:../../FreeRTOS/Source/tasks.c **** 		}
1339:../../FreeRTOS/Source/tasks.c **** 		else
1340:../../FreeRTOS/Source/tasks.c **** 		{
1341:../../FreeRTOS/Source/tasks.c **** 			xReturn = xNextTaskUnblockTime - xTickCount;
1342:../../FreeRTOS/Source/tasks.c **** 		}
1343:../../FreeRTOS/Source/tasks.c **** 
1344:../../FreeRTOS/Source/tasks.c **** 		return xReturn;
1345:../../FreeRTOS/Source/tasks.c **** 	}
1346:../../FreeRTOS/Source/tasks.c **** 
1347:../../FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE != 0  */
1348:../../FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1349:../../FreeRTOS/Source/tasks.c **** 
1350:../../FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xTaskResumeAll( void )
1351:../../FreeRTOS/Source/tasks.c **** {
 1412               	.LM123:
 1413               	.LFBB11:
 1414 0688 DF93      		push r29
 1415 068a CF93      		push r28
 1416 068c 00D0      		rcall .
 1417 068e 0F92      		push __tmp_reg__
 1418 0690 CDB7      		in r28,__SP_L__
 1419 0692 DEB7      		in r29,__SP_H__
 1420               	/* prologue: function */
 1421               	/* frame size = 4 */
1352:../../FreeRTOS/Source/tasks.c **** register tskTCB *pxTCB;
1353:../../FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 1423               	.LM124:
 1424 0694 1A82      		std Y+2,__zero_reg__
1354:../../FreeRTOS/Source/tasks.c **** 
1355:../../FreeRTOS/Source/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
1356:../../FreeRTOS/Source/tasks.c **** 	previous call to vTaskSuspendAll(). */
1357:../../FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended );
1358:../../FreeRTOS/Source/tasks.c **** 
1359:../../FreeRTOS/Source/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
1360:../../FreeRTOS/Source/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
1361:../../FreeRTOS/Source/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
1362:../../FreeRTOS/Source/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
1363:../../FreeRTOS/Source/tasks.c **** 	tasks from this list into their appropriate ready list. */
1364:../../FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
 1426               	.LM125:
 1427               	/* #APP */
 1428               	 ;  1364 "../../FreeRTOS/Source/tasks.c" 1
 1429 0696 0FB6      		in		__tmp_reg__, __SREG__
 1430               	 ;  0 "" 2
 1431               	 ;  1364 "../../FreeRTOS/Source/tasks.c" 1
 1432 0698 F894      		cli
 1433               	 ;  0 "" 2
 1434               	 ;  1364 "../../FreeRTOS/Source/tasks.c" 1
 1435 069a 0F92      		push	__tmp_reg__
 1436               	 ;  0 "" 2
1365:../../FreeRTOS/Source/tasks.c **** 	{
1366:../../FreeRTOS/Source/tasks.c **** 		--uxSchedulerSuspended;
 1438               	.LM126:
 1439               	/* #NOAPP */
 1440 069c 8091 0000 		lds r24,uxSchedulerSuspended
 1441 06a0 8150      		subi r24,lo8(-(-1))
 1442 06a2 8093 0000 		sts uxSchedulerSuspended,r24
1367:../../FreeRTOS/Source/tasks.c **** 
1368:../../FreeRTOS/Source/tasks.c **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1444               	.LM127:
 1445 06a6 8091 0000 		lds r24,uxSchedulerSuspended
 1446 06aa 8823      		tst r24
 1447 06ac 01F0      		breq .+2
 1448 06ae 00C0      		rjmp .L55
1369:../../FreeRTOS/Source/tasks.c **** 		{
1370:../../FreeRTOS/Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
 1450               	.LM128:
 1451 06b0 8091 0000 		lds r24,uxCurrentNumberOfTasks
 1452 06b4 8823      		tst r24
 1453 06b6 01F4      		brne .+2
 1454 06b8 00C0      		rjmp .L55
 1455               	.LBB3:
1371:../../FreeRTOS/Source/tasks.c **** 			{
1372:../../FreeRTOS/Source/tasks.c **** 				portBASE_TYPE xYieldRequired = pdFALSE;
 1457               	.LM129:
 1458 06ba 1982      		std Y+1,__zero_reg__
 1459 06bc 00C0      		rjmp .L56
 1460               	.L58:
1373:../../FreeRTOS/Source/tasks.c **** 
1374:../../FreeRTOS/Source/tasks.c **** 				/* Move any readied tasks from the pending list into the
1375:../../FreeRTOS/Source/tasks.c **** 				appropriate ready list. */
1376:../../FreeRTOS/Source/tasks.c **** 				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
1377:../../FreeRTOS/Source/tasks.c **** 				{
1378:../../FreeRTOS/Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
 1462               	.LM130:
 1463 06be E091 0000 		lds r30,xPendingReadyList+5
 1464 06c2 F091 0000 		lds r31,(xPendingReadyList+5)+1
 1465 06c6 8681      		ldd r24,Z+6
 1466 06c8 9781      		ldd r25,Z+7
 1467 06ca 9C83      		std Y+4,r25
 1468 06cc 8B83      		std Y+3,r24
1379:../../FreeRTOS/Source/tasks.c **** 					uxListRemove( &( pxTCB->xEventListItem ) );
 1470               	.LM131:
 1471 06ce 8B81      		ldd r24,Y+3
 1472 06d0 9C81      		ldd r25,Y+4
 1473 06d2 0C96      		adiw r24,12
 1474 06d4 0E94 0000 		call uxListRemove
1380:../../FreeRTOS/Source/tasks.c **** 					uxListRemove( &( pxTCB->xGenericListItem ) );
 1476               	.LM132:
 1477 06d8 8B81      		ldd r24,Y+3
 1478 06da 9C81      		ldd r25,Y+4
 1479 06dc 0296      		adiw r24,2
 1480 06de 0E94 0000 		call uxListRemove
1381:../../FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1482               	.LM133:
 1483 06e2 EB81      		ldd r30,Y+3
 1484 06e4 FC81      		ldd r31,Y+4
 1485 06e6 9689      		ldd r25,Z+22
 1486 06e8 8091 0000 		lds r24,uxTopReadyPriority
 1487 06ec 8917      		cp r24,r25
 1488 06ee 00F4      		brsh .L57
 1489 06f0 EB81      		ldd r30,Y+3
 1490 06f2 FC81      		ldd r31,Y+4
 1491 06f4 8689      		ldd r24,Z+22
 1492 06f6 8093 0000 		sts uxTopReadyPriority,r24
 1493               	.L57:
 1494 06fa EB81      		ldd r30,Y+3
 1495 06fc FC81      		ldd r31,Y+4
 1496 06fe 8689      		ldd r24,Z+22
 1497 0700 282F      		mov r18,r24
 1498 0702 30E0      		ldi r19,lo8(0)
 1499 0704 C901      		movw r24,r18
 1500 0706 880F      		lsl r24
 1501 0708 991F      		rol r25
 1502 070a 880F      		lsl r24
 1503 070c 991F      		rol r25
 1504 070e 880F      		lsl r24
 1505 0710 991F      		rol r25
 1506 0712 820F      		add r24,r18
 1507 0714 931F      		adc r25,r19
 1508 0716 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1509 0718 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1510 071a 2B81      		ldd r18,Y+3
 1511 071c 3C81      		ldd r19,Y+4
 1512 071e 2E5F      		subi r18,lo8(-(2))
 1513 0720 3F4F      		sbci r19,hi8(-(2))
 1514 0722 B901      		movw r22,r18
 1515 0724 0E94 0000 		call vListInsertEnd
1382:../../FreeRTOS/Source/tasks.c **** 
1383:../../FreeRTOS/Source/tasks.c **** 					/* If we have moved a task that has a priority higher than
1384:../../FreeRTOS/Source/tasks.c **** 					the current task then we should yield. */
1385:../../FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1517               	.LM134:
 1518 0728 EB81      		ldd r30,Y+3
 1519 072a FC81      		ldd r31,Y+4
 1520 072c 9689      		ldd r25,Z+22
 1521 072e E091 0000 		lds r30,pxCurrentTCB
 1522 0732 F091 0000 		lds r31,(pxCurrentTCB)+1
 1523 0736 8689      		ldd r24,Z+22
 1524 0738 9817      		cp r25,r24
 1525 073a 00F0      		brlo .L56
1386:../../FreeRTOS/Source/tasks.c **** 					{
1387:../../FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
 1527               	.LM135:
 1528 073c 81E0      		ldi r24,lo8(1)
 1529 073e 8983      		std Y+1,r24
 1530               	.L56:
1376:../../FreeRTOS/Source/tasks.c **** 				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 1532               	.LM136:
 1533 0740 8091 0000 		lds r24,xPendingReadyList
 1534 0744 8823      		tst r24
 1535 0746 01F0      		breq .+2
 1536 0748 00C0      		rjmp .L58
1388:../../FreeRTOS/Source/tasks.c **** 					}
1389:../../FreeRTOS/Source/tasks.c **** 				}
1390:../../FreeRTOS/Source/tasks.c **** 
1391:../../FreeRTOS/Source/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
1392:../../FreeRTOS/Source/tasks.c **** 				they should be processed now.  This ensures the tick count does not
1393:../../FreeRTOS/Source/tasks.c **** 				slip, and that any delayed tasks are resumed at the correct time. */
1394:../../FreeRTOS/Source/tasks.c **** 				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 1538               	.LM137:
 1539 074a 8091 0000 		lds r24,uxMissedTicks
 1540 074e 8823      		tst r24
 1541 0750 01F0      		breq .L59
 1542 0752 00C0      		rjmp .L60
 1543               	.L61:
1395:../../FreeRTOS/Source/tasks.c **** 				{
1396:../../FreeRTOS/Source/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
1397:../../FreeRTOS/Source/tasks.c **** 					{
1398:../../FreeRTOS/Source/tasks.c **** 						vTaskIncrementTick();
 1545               	.LM138:
 1546 0754 0E94 0000 		call vTaskIncrementTick
1399:../../FreeRTOS/Source/tasks.c **** 						--uxMissedTicks;
 1548               	.LM139:
 1549 0758 8091 0000 		lds r24,uxMissedTicks
 1550 075c 8150      		subi r24,lo8(-(-1))
 1551 075e 8093 0000 		sts uxMissedTicks,r24
 1552               	.L60:
1396:../../FreeRTOS/Source/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 1554               	.LM140:
 1555 0762 8091 0000 		lds r24,uxMissedTicks
 1556 0766 8823      		tst r24
 1557 0768 01F4      		brne .L61
1400:../../FreeRTOS/Source/tasks.c **** 					}
1401:../../FreeRTOS/Source/tasks.c **** 
1402:../../FreeRTOS/Source/tasks.c **** 					/* As we have processed some ticks it is appropriate to yield
1403:../../FreeRTOS/Source/tasks.c **** 					to ensure the highest priority task that is ready to run is
1404:../../FreeRTOS/Source/tasks.c **** 					the task actually running. */
1405:../../FreeRTOS/Source/tasks.c **** 					#if configUSE_PREEMPTION == 1
1406:../../FreeRTOS/Source/tasks.c **** 					{
1407:../../FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
 1559               	.LM141:
 1560 076a 81E0      		ldi r24,lo8(1)
 1561 076c 8983      		std Y+1,r24
 1562               	.L59:
1408:../../FreeRTOS/Source/tasks.c **** 					}
1409:../../FreeRTOS/Source/tasks.c **** 					#endif
1410:../../FreeRTOS/Source/tasks.c **** 				}
1411:../../FreeRTOS/Source/tasks.c **** 
1412:../../FreeRTOS/Source/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 1564               	.LM142:
 1565 076e 8981      		ldd r24,Y+1
 1566 0770 8130      		cpi r24,lo8(1)
 1567 0772 01F0      		breq .L62
 1568 0774 8091 0000 		lds r24,xMissedYield
 1569 0778 8130      		cpi r24,lo8(1)
 1570 077a 01F4      		brne .L55
 1571               	.L62:
1413:../../FreeRTOS/Source/tasks.c **** 				{
1414:../../FreeRTOS/Source/tasks.c **** 					xAlreadyYielded = pdTRUE;
 1573               	.LM143:
 1574 077c 81E0      		ldi r24,lo8(1)
 1575 077e 8A83      		std Y+2,r24
1415:../../FreeRTOS/Source/tasks.c **** 					xMissedYield = pdFALSE;
 1577               	.LM144:
 1578 0780 1092 0000 		sts xMissedYield,__zero_reg__
1416:../../FreeRTOS/Source/tasks.c **** 					portYIELD_WITHIN_API();
 1580               	.LM145:
 1581 0784 0E94 0000 		call vPortYield
 1582               	.L55:
 1583               	.LBE3:
1417:../../FreeRTOS/Source/tasks.c **** 				}
1418:../../FreeRTOS/Source/tasks.c **** 			}
1419:../../FreeRTOS/Source/tasks.c **** 		}
1420:../../FreeRTOS/Source/tasks.c **** 	}
1421:../../FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
 1585               	.LM146:
 1586               	/* #APP */
 1587               	 ;  1421 "../../FreeRTOS/Source/tasks.c" 1
 1588 0788 0F90      		pop		__tmp_reg__
 1589               	 ;  0 "" 2
 1590               	 ;  1421 "../../FreeRTOS/Source/tasks.c" 1
 1591 078a 0FBE      		out		__SREG__, __tmp_reg__
 1592               	 ;  0 "" 2
1422:../../FreeRTOS/Source/tasks.c **** 
1423:../../FreeRTOS/Source/tasks.c **** 	return xAlreadyYielded;
 1594               	.LM147:
 1595               	/* #NOAPP */
 1596 078c 8A81      		ldd r24,Y+2
 1597               	/* epilogue start */
1424:../../FreeRTOS/Source/tasks.c **** }
 1599               	.LM148:
 1600 078e 0F90      		pop __tmp_reg__
 1601 0790 0F90      		pop __tmp_reg__
 1602 0792 0F90      		pop __tmp_reg__
 1603 0794 0F90      		pop __tmp_reg__
 1604 0796 CF91      		pop r28
 1605 0798 DF91      		pop r29
 1606 079a 0895      		ret
 1615               	.Lscope11:
 1617               		.stabd	78,0,0
 1619               	.global	xTaskGetTickCount
 1621               	xTaskGetTickCount:
 1622               		.stabd	46,0,0
1425:../../FreeRTOS/Source/tasks.c **** 
1426:../../FreeRTOS/Source/tasks.c **** 
1427:../../FreeRTOS/Source/tasks.c **** 
1428:../../FreeRTOS/Source/tasks.c **** 
1429:../../FreeRTOS/Source/tasks.c **** 
1430:../../FreeRTOS/Source/tasks.c **** 
1431:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
1432:../../FreeRTOS/Source/tasks.c ****  * PUBLIC TASK UTILITIES documented in task.h
1433:../../FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
1434:../../FreeRTOS/Source/tasks.c **** 
1435:../../FreeRTOS/Source/tasks.c **** 
1436:../../FreeRTOS/Source/tasks.c **** 
1437:../../FreeRTOS/Source/tasks.c **** portTickType xTaskGetTickCount( void )
1438:../../FreeRTOS/Source/tasks.c **** {
 1624               	.LM149:
 1625               	.LFBB12:
 1626 079c DF93      		push r29
 1627 079e CF93      		push r28
 1628 07a0 0F92      		push __tmp_reg__
 1629 07a2 0F92      		push __tmp_reg__
 1630 07a4 CDB7      		in r28,__SP_L__
 1631 07a6 DEB7      		in r29,__SP_H__
 1632               	/* prologue: function */
 1633               	/* frame size = 2 */
1439:../../FreeRTOS/Source/tasks.c **** portTickType xTicks;
1440:../../FreeRTOS/Source/tasks.c **** 
1441:../../FreeRTOS/Source/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
1442:../../FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
 1635               	.LM150:
 1636               	/* #APP */
 1637               	 ;  1442 "../../FreeRTOS/Source/tasks.c" 1
 1638 07a8 0FB6      		in		__tmp_reg__, __SREG__
 1639               	 ;  0 "" 2
 1640               	 ;  1442 "../../FreeRTOS/Source/tasks.c" 1
 1641 07aa F894      		cli
 1642               	 ;  0 "" 2
 1643               	 ;  1442 "../../FreeRTOS/Source/tasks.c" 1
 1644 07ac 0F92      		push	__tmp_reg__
 1645               	 ;  0 "" 2
1443:../../FreeRTOS/Source/tasks.c **** 	{
1444:../../FreeRTOS/Source/tasks.c **** 		xTicks = xTickCount;
 1647               	.LM151:
 1648               	/* #NOAPP */
 1649 07ae 8091 0000 		lds r24,xTickCount
 1650 07b2 9091 0000 		lds r25,(xTickCount)+1
 1651 07b6 9A83      		std Y+2,r25
 1652 07b8 8983      		std Y+1,r24
1445:../../FreeRTOS/Source/tasks.c **** 	}
1446:../../FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
 1654               	.LM152:
 1655               	/* #APP */
 1656               	 ;  1446 "../../FreeRTOS/Source/tasks.c" 1
 1657 07ba 0F90      		pop		__tmp_reg__
 1658               	 ;  0 "" 2
 1659               	 ;  1446 "../../FreeRTOS/Source/tasks.c" 1
 1660 07bc 0FBE      		out		__SREG__, __tmp_reg__
 1661               	 ;  0 "" 2
1447:../../FreeRTOS/Source/tasks.c **** 
1448:../../FreeRTOS/Source/tasks.c **** 	return xTicks;
 1663               	.LM153:
 1664               	/* #NOAPP */
 1665 07be 8981      		ldd r24,Y+1
 1666 07c0 9A81      		ldd r25,Y+2
 1667               	/* epilogue start */
1449:../../FreeRTOS/Source/tasks.c **** }
 1669               	.LM154:
 1670 07c2 0F90      		pop __tmp_reg__
 1671 07c4 0F90      		pop __tmp_reg__
 1672 07c6 CF91      		pop r28
 1673 07c8 DF91      		pop r29
 1674 07ca 0895      		ret
 1679               	.Lscope12:
 1681               		.stabd	78,0,0
 1683               	.global	xTaskGetTickCountFromISR
 1685               	xTaskGetTickCountFromISR:
 1686               		.stabd	46,0,0
1450:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1451:../../FreeRTOS/Source/tasks.c **** 
1452:../../FreeRTOS/Source/tasks.c **** portTickType xTaskGetTickCountFromISR( void )
1453:../../FreeRTOS/Source/tasks.c **** {
 1688               	.LM155:
 1689               	.LFBB13:
 1690 07cc DF93      		push r29
 1691 07ce CF93      		push r28
 1692 07d0 00D0      		rcall .
 1693 07d2 CDB7      		in r28,__SP_L__
 1694 07d4 DEB7      		in r29,__SP_H__
 1695               	/* prologue: function */
 1696               	/* frame size = 3 */
1454:../../FreeRTOS/Source/tasks.c **** portTickType xReturn;
1455:../../FreeRTOS/Source/tasks.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1456:../../FreeRTOS/Source/tasks.c **** 
1457:../../FreeRTOS/Source/tasks.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1698               	.LM156:
 1699 07d6 1982      		std Y+1,__zero_reg__
1458:../../FreeRTOS/Source/tasks.c **** 	xReturn = xTickCount;
 1701               	.LM157:
 1702 07d8 8091 0000 		lds r24,xTickCount
 1703 07dc 9091 0000 		lds r25,(xTickCount)+1
 1704 07e0 9B83      		std Y+3,r25
 1705 07e2 8A83      		std Y+2,r24
1459:../../FreeRTOS/Source/tasks.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1460:../../FreeRTOS/Source/tasks.c **** 
1461:../../FreeRTOS/Source/tasks.c **** 	return xReturn;
 1707               	.LM158:
 1708 07e4 8A81      		ldd r24,Y+2
 1709 07e6 9B81      		ldd r25,Y+3
 1710               	/* epilogue start */
1462:../../FreeRTOS/Source/tasks.c **** }
 1712               	.LM159:
 1713 07e8 0F90      		pop __tmp_reg__
 1714 07ea 0F90      		pop __tmp_reg__
 1715 07ec 0F90      		pop __tmp_reg__
 1716 07ee CF91      		pop r28
 1717 07f0 DF91      		pop r29
 1718 07f2 0895      		ret
 1724               	.Lscope13:
 1726               		.stabd	78,0,0
 1728               	.global	uxTaskGetNumberOfTasks
 1730               	uxTaskGetNumberOfTasks:
 1731               		.stabd	46,0,0
1463:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1464:../../FreeRTOS/Source/tasks.c **** 
1465:../../FreeRTOS/Source/tasks.c **** unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
1466:../../FreeRTOS/Source/tasks.c **** {
 1733               	.LM160:
 1734               	.LFBB14:
 1735 07f4 DF93      		push r29
 1736 07f6 CF93      		push r28
 1737 07f8 CDB7      		in r28,__SP_L__
 1738 07fa DEB7      		in r29,__SP_H__
 1739               	/* prologue: function */
 1740               	/* frame size = 0 */
1467:../../FreeRTOS/Source/tasks.c **** 	/* A critical section is not required because the variables are of type
1468:../../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE. */
1469:../../FreeRTOS/Source/tasks.c **** 	return uxCurrentNumberOfTasks;
 1742               	.LM161:
 1743 07fc 8091 0000 		lds r24,uxCurrentNumberOfTasks
 1744               	/* epilogue start */
1470:../../FreeRTOS/Source/tasks.c **** }
 1746               	.LM162:
 1747 0800 CF91      		pop r28
 1748 0802 DF91      		pop r29
 1749 0804 0895      		ret
 1751               	.Lscope14:
 1753               		.stabd	78,0,0
 1755               	.global	vTaskIncrementTick
 1757               	vTaskIncrementTick:
 1758               		.stabd	46,0,0
1471:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1472:../../FreeRTOS/Source/tasks.c **** 
1473:../../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_pcTaskGetTaskName == 1 )
1474:../../FreeRTOS/Source/tasks.c **** 
1475:../../FreeRTOS/Source/tasks.c **** 	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
1476:../../FreeRTOS/Source/tasks.c **** 	{
1477:../../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
1478:../../FreeRTOS/Source/tasks.c **** 
1479:../../FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then the name of the calling task is being queried. */
1480:../../FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
1481:../../FreeRTOS/Source/tasks.c **** 		configASSERT( pxTCB );
1482:../../FreeRTOS/Source/tasks.c **** 		return &( pxTCB->pcTaskName[ 0 ] );
1483:../../FreeRTOS/Source/tasks.c **** 	}
1484:../../FreeRTOS/Source/tasks.c **** 
1485:../../FreeRTOS/Source/tasks.c **** #endif
1486:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1487:../../FreeRTOS/Source/tasks.c **** 
1488:../../FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1489:../../FreeRTOS/Source/tasks.c **** 
1490:../../FreeRTOS/Source/tasks.c **** 	void vTaskList( signed char *pcWriteBuffer )
1491:../../FreeRTOS/Source/tasks.c **** 	{
1492:../../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1493:../../FreeRTOS/Source/tasks.c **** 
1494:../../FreeRTOS/Source/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1495:../../FreeRTOS/Source/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1496:../../FreeRTOS/Source/tasks.c **** 
1497:../../FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
1498:../../FreeRTOS/Source/tasks.c **** 		{
1499:../../FreeRTOS/Source/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB and
1500:../../FreeRTOS/Source/tasks.c **** 			report the task name, state and stack high water mark. */
1501:../../FreeRTOS/Source/tasks.c **** 
1502:../../FreeRTOS/Source/tasks.c **** 			*pcWriteBuffer = ( signed char ) 0x00;
1503:../../FreeRTOS/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1504:../../FreeRTOS/Source/tasks.c **** 
1505:../../FreeRTOS/Source/tasks.c **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
1506:../../FreeRTOS/Source/tasks.c **** 
1507:../../FreeRTOS/Source/tasks.c **** 			do
1508:../../FreeRTOS/Source/tasks.c **** 			{
1509:../../FreeRTOS/Source/tasks.c **** 				uxQueue--;
1510:../../FreeRTOS/Source/tasks.c **** 
1511:../../FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
1512:../../FreeRTOS/Source/tasks.c **** 				{
1513:../../FreeRTOS/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tsk
1514:../../FreeRTOS/Source/tasks.c **** 				}
1515:../../FreeRTOS/Source/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1516:../../FreeRTOS/Source/tasks.c **** 
1517:../../FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
1518:../../FreeRTOS/Source/tasks.c **** 			{
1519:../../FreeRTOS/Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
1520:../../FreeRTOS/Source/tasks.c **** 			}
1521:../../FreeRTOS/Source/tasks.c **** 
1522:../../FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
1523:../../FreeRTOS/Source/tasks.c **** 			{
1524:../../FreeRTOS/Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_C
1525:../../FreeRTOS/Source/tasks.c **** 			}
1526:../../FreeRTOS/Source/tasks.c **** 
1527:../../FreeRTOS/Source/tasks.c **** 			#if( INCLUDE_vTaskDelete == 1 )
1528:../../FreeRTOS/Source/tasks.c **** 			{
1529:../../FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
1530:../../FreeRTOS/Source/tasks.c **** 				{
1531:../../FreeRTOS/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, &xTasksWaitingTermination, tskDELETED_CHAR );
1532:../../FreeRTOS/Source/tasks.c **** 				}
1533:../../FreeRTOS/Source/tasks.c **** 			}
1534:../../FreeRTOS/Source/tasks.c **** 			#endif
1535:../../FreeRTOS/Source/tasks.c **** 
1536:../../FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1537:../../FreeRTOS/Source/tasks.c **** 			{
1538:../../FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
1539:../../FreeRTOS/Source/tasks.c **** 				{
1540:../../FreeRTOS/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, &xSuspendedTaskList, tskSUSPENDED_CHAR );
1541:../../FreeRTOS/Source/tasks.c **** 				}
1542:../../FreeRTOS/Source/tasks.c **** 			}
1543:../../FreeRTOS/Source/tasks.c **** 			#endif
1544:../../FreeRTOS/Source/tasks.c **** 		}
1545:../../FreeRTOS/Source/tasks.c **** 		xTaskResumeAll();
1546:../../FreeRTOS/Source/tasks.c **** 	}
1547:../../FreeRTOS/Source/tasks.c **** 
1548:../../FreeRTOS/Source/tasks.c **** #endif
1549:../../FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1550:../../FreeRTOS/Source/tasks.c **** 
1551:../../FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
1552:../../FreeRTOS/Source/tasks.c **** 
1553:../../FreeRTOS/Source/tasks.c **** 	void vTaskGetRunTimeStats( signed char *pcWriteBuffer )
1554:../../FreeRTOS/Source/tasks.c **** 	{
1555:../../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1556:../../FreeRTOS/Source/tasks.c **** 	unsigned long ulTotalRunTime;
1557:../../FreeRTOS/Source/tasks.c **** 
1558:../../FreeRTOS/Source/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1559:../../FreeRTOS/Source/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1560:../../FreeRTOS/Source/tasks.c **** 
1561:../../FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
1562:../../FreeRTOS/Source/tasks.c **** 		{
1563:../../FreeRTOS/Source/tasks.c **** 			#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1564:../../FreeRTOS/Source/tasks.c **** 				portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
1565:../../FreeRTOS/Source/tasks.c **** 			#else
1566:../../FreeRTOS/Source/tasks.c **** 				ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1567:../../FreeRTOS/Source/tasks.c **** 			#endif
1568:../../FreeRTOS/Source/tasks.c **** 
1569:../../FreeRTOS/Source/tasks.c **** 			/* Divide ulTotalRunTime by 100 to make the percentage caluclations
1570:../../FreeRTOS/Source/tasks.c **** 			simpler in the prvGenerateRunTimeStatsForTasksInList() function. */
1571:../../FreeRTOS/Source/tasks.c **** 			ulTotalRunTime /= 100UL;
1572:../../FreeRTOS/Source/tasks.c **** 
1573:../../FreeRTOS/Source/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB,
1574:../../FreeRTOS/Source/tasks.c **** 			generating a table of run timer percentages in the provided
1575:../../FreeRTOS/Source/tasks.c **** 			buffer. */
1576:../../FreeRTOS/Source/tasks.c **** 
1577:../../FreeRTOS/Source/tasks.c **** 			*pcWriteBuffer = ( signed char ) 0x00;
1578:../../FreeRTOS/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1579:../../FreeRTOS/Source/tasks.c **** 
1580:../../FreeRTOS/Source/tasks.c **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
1581:../../FreeRTOS/Source/tasks.c **** 
1582:../../FreeRTOS/Source/tasks.c **** 			do
1583:../../FreeRTOS/Source/tasks.c **** 			{
1584:../../FreeRTOS/Source/tasks.c **** 				uxQueue--;
1585:../../FreeRTOS/Source/tasks.c **** 
1586:../../FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
1587:../../FreeRTOS/Source/tasks.c **** 				{
1588:../../FreeRTOS/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueu
1589:../../FreeRTOS/Source/tasks.c **** 				}
1590:../../FreeRTOS/Source/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1591:../../FreeRTOS/Source/tasks.c **** 
1592:../../FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
1593:../../FreeRTOS/Source/tasks.c **** 			{
1594:../../FreeRTOS/Source/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, ulTotalRun
1595:../../FreeRTOS/Source/tasks.c **** 			}
1596:../../FreeRTOS/Source/tasks.c **** 
1597:../../FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
1598:../../FreeRTOS/Source/tasks.c **** 			{
1599:../../FreeRTOS/Source/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, ul
1600:../../FreeRTOS/Source/tasks.c **** 			}
1601:../../FreeRTOS/Source/tasks.c **** 
1602:../../FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1603:../../FreeRTOS/Source/tasks.c **** 			{
1604:../../FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
1605:../../FreeRTOS/Source/tasks.c **** 				{
1606:../../FreeRTOS/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xTasksWaitingTermination, ulTotalRunTim
1607:../../FreeRTOS/Source/tasks.c **** 				}
1608:../../FreeRTOS/Source/tasks.c **** 			}
1609:../../FreeRTOS/Source/tasks.c **** 			#endif
1610:../../FreeRTOS/Source/tasks.c **** 
1611:../../FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1612:../../FreeRTOS/Source/tasks.c **** 			{
1613:../../FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
1614:../../FreeRTOS/Source/tasks.c **** 				{
1615:../../FreeRTOS/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xSuspendedTaskList, ulTotalRunTime );
1616:../../FreeRTOS/Source/tasks.c **** 				}
1617:../../FreeRTOS/Source/tasks.c **** 			}
1618:../../FreeRTOS/Source/tasks.c **** 			#endif
1619:../../FreeRTOS/Source/tasks.c **** 		}
1620:../../FreeRTOS/Source/tasks.c **** 		xTaskResumeAll();
1621:../../FreeRTOS/Source/tasks.c **** 	}
1622:../../FreeRTOS/Source/tasks.c **** 
1623:../../FreeRTOS/Source/tasks.c **** #endif
1624:../../FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1625:../../FreeRTOS/Source/tasks.c **** 
1626:../../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1627:../../FreeRTOS/Source/tasks.c **** 
1628:../../FreeRTOS/Source/tasks.c **** 	xTaskHandle xTaskGetIdleTaskHandle( void )
1629:../../FreeRTOS/Source/tasks.c **** 	{
1630:../../FreeRTOS/Source/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
1631:../../FreeRTOS/Source/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
1632:../../FreeRTOS/Source/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
1633:../../FreeRTOS/Source/tasks.c **** 		return xIdleTaskHandle;
1634:../../FreeRTOS/Source/tasks.c **** 	}
1635:../../FreeRTOS/Source/tasks.c **** 
1636:../../FreeRTOS/Source/tasks.c **** #endif
1637:../../FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1638:../../FreeRTOS/Source/tasks.c **** 
1639:../../FreeRTOS/Source/tasks.c **** /* This conditional compilation should use inequality to 0, not equality to 1.
1640:../../FreeRTOS/Source/tasks.c **** This is to ensure vTaskStepTick() is available when user defined low power mode
1641:../../FreeRTOS/Source/tasks.c **** implementations require configUSE_TICKLESS_IDLE to be set to a value other than
1642:../../FreeRTOS/Source/tasks.c **** 1. */
1643:../../FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
1644:../../FreeRTOS/Source/tasks.c **** 
1645:../../FreeRTOS/Source/tasks.c **** 	void vTaskStepTick( portTickType xTicksToJump )
1646:../../FreeRTOS/Source/tasks.c **** 	{
1647:../../FreeRTOS/Source/tasks.c **** 		configASSERT( xTicksToJump <= xNextTaskUnblockTime );
1648:../../FreeRTOS/Source/tasks.c **** 		xTickCount += xTicksToJump;
1649:../../FreeRTOS/Source/tasks.c **** 	}
1650:../../FreeRTOS/Source/tasks.c **** 
1651:../../FreeRTOS/Source/tasks.c **** #endif
1652:../../FreeRTOS/Source/tasks.c **** 
1653:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
1654:../../FreeRTOS/Source/tasks.c ****  * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
1655:../../FreeRTOS/Source/tasks.c ****  * documented in task.h
1656:../../FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
1657:../../FreeRTOS/Source/tasks.c **** 
1658:../../FreeRTOS/Source/tasks.c **** void vTaskIncrementTick( void )
1659:../../FreeRTOS/Source/tasks.c **** {
 1760               	.LM163:
 1761               	.LFBB15:
 1762 0806 DF93      		push r29
 1763 0808 CF93      		push r28
 1764 080a 00D0      		rcall .
 1765 080c 00D0      		rcall .
 1766 080e CDB7      		in r28,__SP_L__
 1767 0810 DEB7      		in r29,__SP_H__
 1768               	/* prologue: function */
 1769               	/* frame size = 6 */
1660:../../FreeRTOS/Source/tasks.c **** tskTCB * pxTCB;
1661:../../FreeRTOS/Source/tasks.c **** 
1662:../../FreeRTOS/Source/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
1663:../../FreeRTOS/Source/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
1664:../../FreeRTOS/Source/tasks.c **** 	tasks to be unblocked. */
1665:../../FreeRTOS/Source/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
1666:../../FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1771               	.LM164:
 1772 0812 8091 0000 		lds r24,uxSchedulerSuspended
 1773 0816 8823      		tst r24
 1774 0818 01F0      		breq .+2
 1775 081a 00C0      		rjmp .L71
1667:../../FreeRTOS/Source/tasks.c **** 	{
1668:../../FreeRTOS/Source/tasks.c **** 		++xTickCount;
 1777               	.LM165:
 1778 081c 8091 0000 		lds r24,xTickCount
 1779 0820 9091 0000 		lds r25,(xTickCount)+1
 1780 0824 0196      		adiw r24,1
 1781 0826 9093 0000 		sts (xTickCount)+1,r25
 1782 082a 8093 0000 		sts xTickCount,r24
1669:../../FreeRTOS/Source/tasks.c **** 		if( xTickCount == ( portTickType ) 0U )
 1784               	.LM166:
 1785 082e 8091 0000 		lds r24,xTickCount
 1786 0832 9091 0000 		lds r25,(xTickCount)+1
 1787 0836 0097      		sbiw r24,0
 1788 0838 01F4      		brne .L72
 1789               	.LBB4:
1670:../../FreeRTOS/Source/tasks.c **** 		{
1671:../../FreeRTOS/Source/tasks.c **** 			xList *pxTemp;
1672:../../FreeRTOS/Source/tasks.c **** 
1673:../../FreeRTOS/Source/tasks.c **** 			/* Tick count has overflowed so we need to swap the delay lists.
1674:../../FreeRTOS/Source/tasks.c **** 			If there are any items in pxDelayedTaskList here then there is
1675:../../FreeRTOS/Source/tasks.c **** 			an error! */
1676:../../FreeRTOS/Source/tasks.c **** 			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
1677:../../FreeRTOS/Source/tasks.c **** 
1678:../../FreeRTOS/Source/tasks.c **** 			pxTemp = pxDelayedTaskList;
 1791               	.LM167:
 1792 083a 8091 0000 		lds r24,pxDelayedTaskList
 1793 083e 9091 0000 		lds r25,(pxDelayedTaskList)+1
 1794 0842 9C83      		std Y+4,r25
 1795 0844 8B83      		std Y+3,r24
1679:../../FreeRTOS/Source/tasks.c **** 			pxDelayedTaskList = pxOverflowDelayedTaskList;
 1797               	.LM168:
 1798 0846 8091 0000 		lds r24,pxOverflowDelayedTaskList
 1799 084a 9091 0000 		lds r25,(pxOverflowDelayedTaskList)+1
 1800 084e 9093 0000 		sts (pxDelayedTaskList)+1,r25
 1801 0852 8093 0000 		sts pxDelayedTaskList,r24
1680:../../FreeRTOS/Source/tasks.c **** 			pxOverflowDelayedTaskList = pxTemp;
 1803               	.LM169:
 1804 0856 8B81      		ldd r24,Y+3
 1805 0858 9C81      		ldd r25,Y+4
 1806 085a 9093 0000 		sts (pxOverflowDelayedTaskList)+1,r25
 1807 085e 8093 0000 		sts pxOverflowDelayedTaskList,r24
1681:../../FreeRTOS/Source/tasks.c **** 			xNumOfOverflows++;
 1809               	.LM170:
 1810 0862 8091 0000 		lds r24,xNumOfOverflows
 1811 0866 8F5F      		subi r24,lo8(-(1))
 1812 0868 8093 0000 		sts xNumOfOverflows,r24
1682:../../FreeRTOS/Source/tasks.c **** 
1683:../../FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 1814               	.LM171:
 1815 086c E091 0000 		lds r30,pxDelayedTaskList
 1816 0870 F091 0000 		lds r31,(pxDelayedTaskList)+1
 1817 0874 8081      		ld r24,Z
 1818 0876 8823      		tst r24
 1819 0878 01F4      		brne .L73
1684:../../FreeRTOS/Source/tasks.c **** 			{
1685:../../FreeRTOS/Source/tasks.c **** 				/* The new current delayed list is empty.  Set
1686:../../FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime to the maximum possible value so it is
1687:../../FreeRTOS/Source/tasks.c **** 				extremely unlikely that the
1688:../../FreeRTOS/Source/tasks.c **** 				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
1689:../../FreeRTOS/Source/tasks.c **** 				there is an item in the delayed list. */
1690:../../FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime = portMAX_DELAY;
 1821               	.LM172:
 1822 087a 8FEF      		ldi r24,lo8(-1)
 1823 087c 9FEF      		ldi r25,hi8(-1)
 1824 087e 9093 0000 		sts (xNextTaskUnblockTime)+1,r25
 1825 0882 8093 0000 		sts xNextTaskUnblockTime,r24
 1826 0886 00C0      		rjmp .L72
 1827               	.L73:
1691:../../FreeRTOS/Source/tasks.c **** 			}
1692:../../FreeRTOS/Source/tasks.c **** 			else
1693:../../FreeRTOS/Source/tasks.c **** 			{
1694:../../FreeRTOS/Source/tasks.c **** 				/* The new current delayed list is not empty, get the value of
1695:../../FreeRTOS/Source/tasks.c **** 				the item at the head of the delayed list.  This is the time at
1696:../../FreeRTOS/Source/tasks.c **** 				which the task at the head of the delayed list should be removed
1697:../../FreeRTOS/Source/tasks.c **** 				from the Blocked state. */
1698:../../FreeRTOS/Source/tasks.c **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 1829               	.LM173:
 1830 0888 E091 0000 		lds r30,pxDelayedTaskList
 1831 088c F091 0000 		lds r31,(pxDelayedTaskList)+1
 1832 0890 0580      		ldd __tmp_reg__,Z+5
 1833 0892 F681      		ldd r31,Z+6
 1834 0894 E02D      		mov r30,__tmp_reg__
 1835 0896 8681      		ldd r24,Z+6
 1836 0898 9781      		ldd r25,Z+7
 1837 089a 9E83      		std Y+6,r25
 1838 089c 8D83      		std Y+5,r24
1699:../../FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 1840               	.LM174:
 1841 089e ED81      		ldd r30,Y+5
 1842 08a0 FE81      		ldd r31,Y+6
 1843 08a2 8281      		ldd r24,Z+2
 1844 08a4 9381      		ldd r25,Z+3
 1845 08a6 9093 0000 		sts (xNextTaskUnblockTime)+1,r25
 1846 08aa 8093 0000 		sts xNextTaskUnblockTime,r24
 1847               	.L72:
 1848               	.LBE4:
 1849               	.LBB5:
1700:../../FreeRTOS/Source/tasks.c **** 			}
1701:../../FreeRTOS/Source/tasks.c **** 		}
1702:../../FreeRTOS/Source/tasks.c **** 
1703:../../FreeRTOS/Source/tasks.c **** 		/* See if this tick has made a timeout expire. */
1704:../../FreeRTOS/Source/tasks.c **** 		prvCheckDelayedTasks();
 1851               	.LM175:
 1852 08ae 2091 0000 		lds r18,xTickCount
 1853 08b2 3091 0000 		lds r19,(xTickCount)+1
 1854 08b6 8091 0000 		lds r24,xNextTaskUnblockTime
 1855 08ba 9091 0000 		lds r25,(xNextTaskUnblockTime)+1
 1856 08be 2817      		cp r18,r24
 1857 08c0 3907      		cpc r19,r25
 1858 08c2 00F4      		brsh .+2
 1859 08c4 00C0      		rjmp .L81
 1860               	.L79:
 1861 08c6 E091 0000 		lds r30,pxDelayedTaskList
 1862 08ca F091 0000 		lds r31,(pxDelayedTaskList)+1
 1863 08ce 8081      		ld r24,Z
 1864 08d0 8823      		tst r24
 1865 08d2 01F4      		brne .L75
 1866 08d4 8FEF      		ldi r24,lo8(-1)
 1867 08d6 9FEF      		ldi r25,hi8(-1)
 1868 08d8 9093 0000 		sts (xNextTaskUnblockTime)+1,r25
 1869 08dc 8093 0000 		sts xNextTaskUnblockTime,r24
 1870 08e0 00C0      		rjmp .L81
 1871               	.L75:
 1872 08e2 E091 0000 		lds r30,pxDelayedTaskList
 1873 08e6 F091 0000 		lds r31,(pxDelayedTaskList)+1
 1874 08ea 0580      		ldd __tmp_reg__,Z+5
 1875 08ec F681      		ldd r31,Z+6
 1876 08ee E02D      		mov r30,__tmp_reg__
 1877 08f0 8681      		ldd r24,Z+6
 1878 08f2 9781      		ldd r25,Z+7
 1879 08f4 9E83      		std Y+6,r25
 1880 08f6 8D83      		std Y+5,r24
 1881 08f8 ED81      		ldd r30,Y+5
 1882 08fa FE81      		ldd r31,Y+6
 1883 08fc 8281      		ldd r24,Z+2
 1884 08fe 9381      		ldd r25,Z+3
 1885 0900 9A83      		std Y+2,r25
 1886 0902 8983      		std Y+1,r24
 1887 0904 2091 0000 		lds r18,xTickCount
 1888 0908 3091 0000 		lds r19,(xTickCount)+1
 1889 090c 8981      		ldd r24,Y+1
 1890 090e 9A81      		ldd r25,Y+2
 1891 0910 2817      		cp r18,r24
 1892 0912 3907      		cpc r19,r25
 1893 0914 00F4      		brsh .L76
 1894 0916 8981      		ldd r24,Y+1
 1895 0918 9A81      		ldd r25,Y+2
 1896 091a 9093 0000 		sts (xNextTaskUnblockTime)+1,r25
 1897 091e 8093 0000 		sts xNextTaskUnblockTime,r24
 1898 0922 00C0      		rjmp .L81
 1899               	.L76:
 1900 0924 8D81      		ldd r24,Y+5
 1901 0926 9E81      		ldd r25,Y+6
 1902 0928 0296      		adiw r24,2
 1903 092a 0E94 0000 		call uxListRemove
 1904 092e ED81      		ldd r30,Y+5
 1905 0930 FE81      		ldd r31,Y+6
 1906 0932 8489      		ldd r24,Z+20
 1907 0934 9589      		ldd r25,Z+21
 1908 0936 0097      		sbiw r24,0
 1909 0938 01F0      		breq .L77
 1910 093a 8D81      		ldd r24,Y+5
 1911 093c 9E81      		ldd r25,Y+6
 1912 093e 0C96      		adiw r24,12
 1913 0940 0E94 0000 		call uxListRemove
 1914               	.L77:
 1915 0944 ED81      		ldd r30,Y+5
 1916 0946 FE81      		ldd r31,Y+6
 1917 0948 9689      		ldd r25,Z+22
 1918 094a 8091 0000 		lds r24,uxTopReadyPriority
 1919 094e 8917      		cp r24,r25
 1920 0950 00F4      		brsh .L78
 1921 0952 ED81      		ldd r30,Y+5
 1922 0954 FE81      		ldd r31,Y+6
 1923 0956 8689      		ldd r24,Z+22
 1924 0958 8093 0000 		sts uxTopReadyPriority,r24
 1925               	.L78:
 1926 095c ED81      		ldd r30,Y+5
 1927 095e FE81      		ldd r31,Y+6
 1928 0960 8689      		ldd r24,Z+22
 1929 0962 282F      		mov r18,r24
 1930 0964 30E0      		ldi r19,lo8(0)
 1931 0966 C901      		movw r24,r18
 1932 0968 880F      		lsl r24
 1933 096a 991F      		rol r25
 1934 096c 880F      		lsl r24
 1935 096e 991F      		rol r25
 1936 0970 880F      		lsl r24
 1937 0972 991F      		rol r25
 1938 0974 820F      		add r24,r18
 1939 0976 931F      		adc r25,r19
 1940 0978 AC01      		movw r20,r24
 1941 097a 4050      		subi r20,lo8(-(pxReadyTasksLists))
 1942 097c 5040      		sbci r21,hi8(-(pxReadyTasksLists))
 1943 097e 8D81      		ldd r24,Y+5
 1944 0980 9E81      		ldd r25,Y+6
 1945 0982 9C01      		movw r18,r24
 1946 0984 2E5F      		subi r18,lo8(-(2))
 1947 0986 3F4F      		sbci r19,hi8(-(2))
 1948 0988 CA01      		movw r24,r20
 1949 098a B901      		movw r22,r18
 1950 098c 0E94 0000 		call vListInsertEnd
 1951 0990 00C0      		rjmp .L79
 1952               	.L71:
 1953               	.LBE5:
1705:../../FreeRTOS/Source/tasks.c **** 	}
1706:../../FreeRTOS/Source/tasks.c **** 	else
1707:../../FreeRTOS/Source/tasks.c **** 	{
1708:../../FreeRTOS/Source/tasks.c **** 		++uxMissedTicks;
 1955               	.LM176:
 1956 0992 8091 0000 		lds r24,uxMissedTicks
 1957 0996 8F5F      		subi r24,lo8(-(1))
 1958 0998 8093 0000 		sts uxMissedTicks,r24
 1959               	.L81:
 1960               	/* epilogue start */
1709:../../FreeRTOS/Source/tasks.c **** 
1710:../../FreeRTOS/Source/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
1711:../../FreeRTOS/Source/tasks.c **** 		scheduler is locked. */
1712:../../FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
1713:../../FreeRTOS/Source/tasks.c **** 		{
1714:../../FreeRTOS/Source/tasks.c **** 			vApplicationTickHook();
1715:../../FreeRTOS/Source/tasks.c **** 		}
1716:../../FreeRTOS/Source/tasks.c **** 		#endif
1717:../../FreeRTOS/Source/tasks.c **** 	}
1718:../../FreeRTOS/Source/tasks.c **** 
1719:../../FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TICK_HOOK == 1 )
1720:../../FreeRTOS/Source/tasks.c **** 	{
1721:../../FreeRTOS/Source/tasks.c **** 		/* Guard against the tick hook being called when the missed tick
1722:../../FreeRTOS/Source/tasks.c **** 		count is being unwound (when the scheduler is being unlocked. */
1723:../../FreeRTOS/Source/tasks.c **** 		if( uxMissedTicks == ( unsigned portBASE_TYPE ) 0U )
1724:../../FreeRTOS/Source/tasks.c **** 		{
1725:../../FreeRTOS/Source/tasks.c **** 			vApplicationTickHook();
1726:../../FreeRTOS/Source/tasks.c **** 		}
1727:../../FreeRTOS/Source/tasks.c **** 	}
1728:../../FreeRTOS/Source/tasks.c **** 	#endif
1729:../../FreeRTOS/Source/tasks.c **** }
 1962               	.LM177:
 1963 099c 2696      		adiw r28,6
 1964 099e 0FB6      		in __tmp_reg__,__SREG__
 1965 09a0 F894      		cli
 1966 09a2 DEBF      		out __SP_H__,r29
 1967 09a4 0FBE      		out __SREG__,__tmp_reg__
 1968 09a6 CDBF      		out __SP_L__,r28
 1969 09a8 CF91      		pop r28
 1970 09aa DF91      		pop r29
 1971 09ac 0895      		ret
 1982               	.Lscope15:
 1984               		.stabd	78,0,0
 1986               	.global	vTaskSwitchContext
 1988               	vTaskSwitchContext:
 1989               		.stabd	46,0,0
1730:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1731:../../FreeRTOS/Source/tasks.c **** 
1732:../../FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1733:../../FreeRTOS/Source/tasks.c **** 
1734:../../FreeRTOS/Source/tasks.c **** 	void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction )
1735:../../FreeRTOS/Source/tasks.c **** 	{
1736:../../FreeRTOS/Source/tasks.c **** 	tskTCB *xTCB;
1737:../../FreeRTOS/Source/tasks.c **** 
1738:../../FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1739:../../FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
1740:../../FreeRTOS/Source/tasks.c **** 		{
1741:../../FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1742:../../FreeRTOS/Source/tasks.c **** 		}
1743:../../FreeRTOS/Source/tasks.c **** 		else
1744:../../FreeRTOS/Source/tasks.c **** 		{
1745:../../FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1746:../../FreeRTOS/Source/tasks.c **** 		}
1747:../../FreeRTOS/Source/tasks.c **** 
1748:../../FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1749:../../FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
1750:../../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1751:../../FreeRTOS/Source/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
1752:../../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1753:../../FreeRTOS/Source/tasks.c **** 	}
1754:../../FreeRTOS/Source/tasks.c **** 
1755:../../FreeRTOS/Source/tasks.c **** #endif
1756:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1757:../../FreeRTOS/Source/tasks.c **** 
1758:../../FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1759:../../FreeRTOS/Source/tasks.c **** 
1760:../../FreeRTOS/Source/tasks.c **** 	pdTASK_HOOK_CODE xTaskGetApplicationTaskTag( xTaskHandle xTask )
1761:../../FreeRTOS/Source/tasks.c **** 	{
1762:../../FreeRTOS/Source/tasks.c **** 	tskTCB *xTCB;
1763:../../FreeRTOS/Source/tasks.c **** 	pdTASK_HOOK_CODE xReturn;
1764:../../FreeRTOS/Source/tasks.c **** 
1765:../../FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1766:../../FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
1767:../../FreeRTOS/Source/tasks.c **** 		{
1768:../../FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1769:../../FreeRTOS/Source/tasks.c **** 		}
1770:../../FreeRTOS/Source/tasks.c **** 		else
1771:../../FreeRTOS/Source/tasks.c **** 		{
1772:../../FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1773:../../FreeRTOS/Source/tasks.c **** 		}
1774:../../FreeRTOS/Source/tasks.c **** 
1775:../../FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1776:../../FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
1777:../../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1778:../../FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag;
1779:../../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1780:../../FreeRTOS/Source/tasks.c **** 
1781:../../FreeRTOS/Source/tasks.c **** 		return xReturn;
1782:../../FreeRTOS/Source/tasks.c **** 	}
1783:../../FreeRTOS/Source/tasks.c **** 
1784:../../FreeRTOS/Source/tasks.c **** #endif
1785:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1786:../../FreeRTOS/Source/tasks.c **** 
1787:../../FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1788:../../FreeRTOS/Source/tasks.c **** 
1789:../../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter )
1790:../../FreeRTOS/Source/tasks.c **** 	{
1791:../../FreeRTOS/Source/tasks.c **** 	tskTCB *xTCB;
1792:../../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xReturn;
1793:../../FreeRTOS/Source/tasks.c **** 
1794:../../FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
1795:../../FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
1796:../../FreeRTOS/Source/tasks.c **** 		{
1797:../../FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1798:../../FreeRTOS/Source/tasks.c **** 		}
1799:../../FreeRTOS/Source/tasks.c **** 		else
1800:../../FreeRTOS/Source/tasks.c **** 		{
1801:../../FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1802:../../FreeRTOS/Source/tasks.c **** 		}
1803:../../FreeRTOS/Source/tasks.c **** 
1804:../../FreeRTOS/Source/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
1805:../../FreeRTOS/Source/tasks.c **** 		{
1806:../../FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
1807:../../FreeRTOS/Source/tasks.c **** 		}
1808:../../FreeRTOS/Source/tasks.c **** 		else
1809:../../FreeRTOS/Source/tasks.c **** 		{
1810:../../FreeRTOS/Source/tasks.c **** 			xReturn = pdFAIL;
1811:../../FreeRTOS/Source/tasks.c **** 		}
1812:../../FreeRTOS/Source/tasks.c **** 
1813:../../FreeRTOS/Source/tasks.c **** 		return xReturn;
1814:../../FreeRTOS/Source/tasks.c **** 	}
1815:../../FreeRTOS/Source/tasks.c **** 
1816:../../FreeRTOS/Source/tasks.c **** #endif
1817:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1818:../../FreeRTOS/Source/tasks.c **** 
1819:../../FreeRTOS/Source/tasks.c **** void vTaskSwitchContext( void )
1820:../../FreeRTOS/Source/tasks.c **** {
 1991               	.LM178:
 1992               	.LFBB16:
 1993 09ae DF93      		push r29
 1994 09b0 CF93      		push r28
 1995 09b2 0F92      		push __tmp_reg__
 1996 09b4 0F92      		push __tmp_reg__
 1997 09b6 CDB7      		in r28,__SP_L__
 1998 09b8 DEB7      		in r29,__SP_H__
 1999               	/* prologue: function */
 2000               	/* frame size = 2 */
1821:../../FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 2002               	.LM179:
 2003 09ba 8091 0000 		lds r24,uxSchedulerSuspended
 2004 09be 8823      		tst r24
 2005 09c0 01F0      		breq .L83
1822:../../FreeRTOS/Source/tasks.c **** 	{
1823:../../FreeRTOS/Source/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
1824:../../FreeRTOS/Source/tasks.c **** 		switch. */
1825:../../FreeRTOS/Source/tasks.c **** 		xMissedYield = pdTRUE;
 2007               	.LM180:
 2008 09c2 81E0      		ldi r24,lo8(1)
 2009 09c4 8093 0000 		sts xMissedYield,r24
 2010 09c8 00C0      		rjmp .L89
 2011               	.L83:
1826:../../FreeRTOS/Source/tasks.c **** 	}
1827:../../FreeRTOS/Source/tasks.c **** 	else
1828:../../FreeRTOS/Source/tasks.c **** 	{
1829:../../FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
1830:../../FreeRTOS/Source/tasks.c **** 
1831:../../FreeRTOS/Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
1832:../../FreeRTOS/Source/tasks.c **** 		{
1833:../../FreeRTOS/Source/tasks.c **** 			unsigned long ulTempCounter;
1834:../../FreeRTOS/Source/tasks.c **** 
1835:../../FreeRTOS/Source/tasks.c **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1836:../../FreeRTOS/Source/tasks.c **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTempCounter );
1837:../../FreeRTOS/Source/tasks.c **** 				#else
1838:../../FreeRTOS/Source/tasks.c **** 					ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
1839:../../FreeRTOS/Source/tasks.c **** 				#endif
1840:../../FreeRTOS/Source/tasks.c **** 
1841:../../FreeRTOS/Source/tasks.c **** 				/* Add the amount of time the task has been running to the accumulated
1842:../../FreeRTOS/Source/tasks.c **** 				time so far.  The time the task started running was stored in
1843:../../FreeRTOS/Source/tasks.c **** 				ulTaskSwitchedInTime.  Note that there is no overflow protection here
1844:../../FreeRTOS/Source/tasks.c **** 				so count values are only valid until the timer overflows.  Generally
1845:../../FreeRTOS/Source/tasks.c **** 				this will be about 1 hour assuming a 1uS timer increment. */
1846:../../FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
1847:../../FreeRTOS/Source/tasks.c **** 				ulTaskSwitchedInTime = ulTempCounter;
1848:../../FreeRTOS/Source/tasks.c **** 		}
1849:../../FreeRTOS/Source/tasks.c **** 		#endif
1850:../../FreeRTOS/Source/tasks.c **** 
1851:../../FreeRTOS/Source/tasks.c **** 		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
 2013               	.LM181:
 2014 09ca E091 0000 		lds r30,pxCurrentTCB
 2015 09ce F091 0000 		lds r31,(pxCurrentTCB)+1
 2016 09d2 2081      		ld r18,Z
 2017 09d4 3181      		ldd r19,Z+1
 2018 09d6 E091 0000 		lds r30,pxCurrentTCB
 2019 09da F091 0000 		lds r31,(pxCurrentTCB)+1
 2020 09de 8789      		ldd r24,Z+23
 2021 09e0 908D      		ldd r25,Z+24
 2022 09e2 8217      		cp r24,r18
 2023 09e4 9307      		cpc r25,r19
 2024 09e6 00F0      		brlo .L86
 2025 09e8 8091 0000 		lds r24,pxCurrentTCB
 2026 09ec 9091 0000 		lds r25,(pxCurrentTCB)+1
 2027 09f0 2091 0000 		lds r18,pxCurrentTCB
 2028 09f4 3091 0000 		lds r19,(pxCurrentTCB)+1
 2029 09f8 275E      		subi r18,lo8(-(25))
 2030 09fa 3F4F      		sbci r19,hi8(-(25))
 2031 09fc B901      		movw r22,r18
 2032 09fe 0E94 0000 		call vApplicationStackOverflowHook
 2033               	.L87:
1852:../../FreeRTOS/Source/tasks.c **** 		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
1853:../../FreeRTOS/Source/tasks.c **** 
1854:../../FreeRTOS/Source/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
 2035               	.LM182:
 2036 0a02 8091 0000 		lds r24,uxTopReadyPriority
 2037 0a06 8150      		subi r24,lo8(-(-1))
 2038 0a08 8093 0000 		sts uxTopReadyPriority,r24
 2039               	.L86:
 2040 0a0c 8091 0000 		lds r24,uxTopReadyPriority
 2041 0a10 282F      		mov r18,r24
 2042 0a12 30E0      		ldi r19,lo8(0)
 2043 0a14 C901      		movw r24,r18
 2044 0a16 880F      		lsl r24
 2045 0a18 991F      		rol r25
 2046 0a1a 880F      		lsl r24
 2047 0a1c 991F      		rol r25
 2048 0a1e 880F      		lsl r24
 2049 0a20 991F      		rol r25
 2050 0a22 820F      		add r24,r18
 2051 0a24 931F      		adc r25,r19
 2052 0a26 FC01      		movw r30,r24
 2053 0a28 E050      		subi r30,lo8(-(pxReadyTasksLists))
 2054 0a2a F040      		sbci r31,hi8(-(pxReadyTasksLists))
 2055 0a2c 8081      		ld r24,Z
 2056 0a2e 8823      		tst r24
 2057 0a30 01F0      		breq .L87
 2058               	.LBB6:
 2059 0a32 8091 0000 		lds r24,uxTopReadyPriority
 2060 0a36 282F      		mov r18,r24
 2061 0a38 30E0      		ldi r19,lo8(0)
 2062 0a3a C901      		movw r24,r18
 2063 0a3c 880F      		lsl r24
 2064 0a3e 991F      		rol r25
 2065 0a40 880F      		lsl r24
 2066 0a42 991F      		rol r25
 2067 0a44 880F      		lsl r24
 2068 0a46 991F      		rol r25
 2069 0a48 820F      		add r24,r18
 2070 0a4a 931F      		adc r25,r19
 2071 0a4c 8050      		subi r24,lo8(-(pxReadyTasksLists))
 2072 0a4e 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 2073 0a50 9A83      		std Y+2,r25
 2074 0a52 8983      		std Y+1,r24
 2075 0a54 E981      		ldd r30,Y+1
 2076 0a56 FA81      		ldd r31,Y+2
 2077 0a58 0180      		ldd __tmp_reg__,Z+1
 2078 0a5a F281      		ldd r31,Z+2
 2079 0a5c E02D      		mov r30,__tmp_reg__
 2080 0a5e 8281      		ldd r24,Z+2
 2081 0a60 9381      		ldd r25,Z+3
 2082 0a62 E981      		ldd r30,Y+1
 2083 0a64 FA81      		ldd r31,Y+2
 2084 0a66 9283      		std Z+2,r25
 2085 0a68 8183      		std Z+1,r24
 2086 0a6a E981      		ldd r30,Y+1
 2087 0a6c FA81      		ldd r31,Y+2
 2088 0a6e 2181      		ldd r18,Z+1
 2089 0a70 3281      		ldd r19,Z+2
 2090 0a72 8981      		ldd r24,Y+1
 2091 0a74 9A81      		ldd r25,Y+2
 2092 0a76 0396      		adiw r24,3
 2093 0a78 2817      		cp r18,r24
 2094 0a7a 3907      		cpc r19,r25
 2095 0a7c 01F4      		brne .L88
 2096 0a7e E981      		ldd r30,Y+1
 2097 0a80 FA81      		ldd r31,Y+2
 2098 0a82 0180      		ldd __tmp_reg__,Z+1
 2099 0a84 F281      		ldd r31,Z+2
 2100 0a86 E02D      		mov r30,__tmp_reg__
 2101 0a88 8281      		ldd r24,Z+2
 2102 0a8a 9381      		ldd r25,Z+3
 2103 0a8c E981      		ldd r30,Y+1
 2104 0a8e FA81      		ldd r31,Y+2
 2105 0a90 9283      		std Z+2,r25
 2106 0a92 8183      		std Z+1,r24
 2107               	.L88:
 2108 0a94 E981      		ldd r30,Y+1
 2109 0a96 FA81      		ldd r31,Y+2
 2110 0a98 0180      		ldd __tmp_reg__,Z+1
 2111 0a9a F281      		ldd r31,Z+2
 2112 0a9c E02D      		mov r30,__tmp_reg__
 2113 0a9e 8681      		ldd r24,Z+6
 2114 0aa0 9781      		ldd r25,Z+7
 2115 0aa2 9093 0000 		sts (pxCurrentTCB)+1,r25
 2116 0aa6 8093 0000 		sts pxCurrentTCB,r24
 2117               	.L89:
 2118               	/* epilogue start */
 2119               	.LBE6:
1855:../../FreeRTOS/Source/tasks.c **** 
1856:../../FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
1857:../../FreeRTOS/Source/tasks.c **** 	}
1858:../../FreeRTOS/Source/tasks.c **** }
 2121               	.LM183:
 2122 0aaa 0F90      		pop __tmp_reg__
 2123 0aac 0F90      		pop __tmp_reg__
 2124 0aae CF91      		pop r28
 2125 0ab0 DF91      		pop r29
 2126 0ab2 0895      		ret
 2131               	.Lscope16:
 2133               		.stabd	78,0,0
 2137               	.global	vTaskPlaceOnEventList
 2139               	vTaskPlaceOnEventList:
 2140               		.stabd	46,0,0
1859:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1860:../../FreeRTOS/Source/tasks.c **** 
1861:../../FreeRTOS/Source/tasks.c **** void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
1862:../../FreeRTOS/Source/tasks.c **** {
 2142               	.LM184:
 2143               	.LFBB17:
 2144 0ab4 DF93      		push r29
 2145 0ab6 CF93      		push r28
 2146 0ab8 00D0      		rcall .
 2147 0aba 00D0      		rcall .
 2148 0abc CDB7      		in r28,__SP_L__
 2149 0abe DEB7      		in r29,__SP_H__
 2150               	/* prologue: function */
 2151               	/* frame size = 6 */
 2152 0ac0 9C83      		std Y+4,r25
 2153 0ac2 8B83      		std Y+3,r24
 2154 0ac4 7E83      		std Y+6,r23
 2155 0ac6 6D83      		std Y+5,r22
1863:../../FreeRTOS/Source/tasks.c **** portTickType xTimeToWake;
1864:../../FreeRTOS/Source/tasks.c **** 
1865:../../FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
1866:../../FreeRTOS/Source/tasks.c **** 
1867:../../FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1868:../../FreeRTOS/Source/tasks.c **** 	SCHEDULER SUSPENDED. */
1869:../../FreeRTOS/Source/tasks.c **** 
1870:../../FreeRTOS/Source/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
1871:../../FreeRTOS/Source/tasks.c **** 	This is placed in the list in priority order so the highest priority task
1872:../../FreeRTOS/Source/tasks.c **** 	is the first to be woken by the event. */
1873:../../FreeRTOS/Source/tasks.c **** 	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 2157               	.LM185:
 2158 0ac8 4B81      		ldd r20,Y+3
 2159 0aca 5C81      		ldd r21,Y+4
 2160 0acc 8091 0000 		lds r24,pxCurrentTCB
 2161 0ad0 9091 0000 		lds r25,(pxCurrentTCB)+1
 2162 0ad4 9C01      		movw r18,r24
 2163 0ad6 245F      		subi r18,lo8(-(12))
 2164 0ad8 3F4F      		sbci r19,hi8(-(12))
 2165 0ada CA01      		movw r24,r20
 2166 0adc B901      		movw r22,r18
 2167 0ade 0E94 0000 		call vListInsert
1874:../../FreeRTOS/Source/tasks.c **** 
1875:../../FreeRTOS/Source/tasks.c **** 	/* We must remove ourselves from the ready list before adding ourselves
1876:../../FreeRTOS/Source/tasks.c **** 	to the blocked list as the same list item is used for both lists.  We have
1877:../../FreeRTOS/Source/tasks.c **** 	exclusive access to the ready lists as the scheduler is locked. */
1878:../../FreeRTOS/Source/tasks.c **** 	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
 2169               	.LM186:
 2170 0ae2 8091 0000 		lds r24,pxCurrentTCB
 2171 0ae6 9091 0000 		lds r25,(pxCurrentTCB)+1
 2172 0aea 0296      		adiw r24,2
 2173 0aec 0E94 0000 		call uxListRemove
1879:../../FreeRTOS/Source/tasks.c **** 	{
1880:../../FreeRTOS/Source/tasks.c **** 		/* The current task must be in a ready list, so there is no need to
1881:../../FreeRTOS/Source/tasks.c **** 		check, and the port reset macro can be called directly. */
1882:../../FreeRTOS/Source/tasks.c **** 		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
1883:../../FreeRTOS/Source/tasks.c **** 	}
1884:../../FreeRTOS/Source/tasks.c **** 
1885:../../FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
1886:../../FreeRTOS/Source/tasks.c **** 	{
1887:../../FreeRTOS/Source/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
 2175               	.LM187:
 2176 0af0 8D81      		ldd r24,Y+5
 2177 0af2 9E81      		ldd r25,Y+6
 2178 0af4 2FEF      		ldi r18,hi8(-1)
 2179 0af6 8F3F      		cpi r24,lo8(-1)
 2180 0af8 9207      		cpc r25,r18
 2181 0afa 01F4      		brne .L91
1888:../../FreeRTOS/Source/tasks.c **** 		{
1889:../../FreeRTOS/Source/tasks.c **** 			/* Add ourselves to the suspended task list instead of a delayed task
1890:../../FreeRTOS/Source/tasks.c **** 			list to ensure we are not woken by a timing event.  We will block
1891:../../FreeRTOS/Source/tasks.c **** 			indefinitely. */
1892:../../FreeRTOS/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListIt
 2183               	.LM188:
 2184 0afc 8091 0000 		lds r24,pxCurrentTCB
 2185 0b00 9091 0000 		lds r25,(pxCurrentTCB)+1
 2186 0b04 9C01      		movw r18,r24
 2187 0b06 2E5F      		subi r18,lo8(-(2))
 2188 0b08 3F4F      		sbci r19,hi8(-(2))
 2189 0b0a 80E0      		ldi r24,lo8(xSuspendedTaskList)
 2190 0b0c 90E0      		ldi r25,hi8(xSuspendedTaskList)
 2191 0b0e B901      		movw r22,r18
 2192 0b10 0E94 0000 		call vListInsertEnd
 2193 0b14 00C0      		rjmp .L93
 2194               	.L91:
1893:../../FreeRTOS/Source/tasks.c **** 		}
1894:../../FreeRTOS/Source/tasks.c **** 		else
1895:../../FreeRTOS/Source/tasks.c **** 		{
1896:../../FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1897:../../FreeRTOS/Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1898:../../FreeRTOS/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
 2196               	.LM189:
 2197 0b16 2091 0000 		lds r18,xTickCount
 2198 0b1a 3091 0000 		lds r19,(xTickCount)+1
 2199 0b1e 8D81      		ldd r24,Y+5
 2200 0b20 9E81      		ldd r25,Y+6
 2201 0b22 820F      		add r24,r18
 2202 0b24 931F      		adc r25,r19
 2203 0b26 9A83      		std Y+2,r25
 2204 0b28 8983      		std Y+1,r24
1899:../../FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 2206               	.LM190:
 2207 0b2a 8981      		ldd r24,Y+1
 2208 0b2c 9A81      		ldd r25,Y+2
 2209 0b2e 0E94 0000 		call prvAddCurrentTaskToDelayedList
 2210               	.L93:
 2211               	/* epilogue start */
1900:../../FreeRTOS/Source/tasks.c **** 		}
1901:../../FreeRTOS/Source/tasks.c **** 	}
1902:../../FreeRTOS/Source/tasks.c **** 	#else
1903:../../FreeRTOS/Source/tasks.c **** 	{
1904:../../FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1905:../../FreeRTOS/Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1906:../../FreeRTOS/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1907:../../FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
1908:../../FreeRTOS/Source/tasks.c **** 	}
1909:../../FreeRTOS/Source/tasks.c **** 	#endif
1910:../../FreeRTOS/Source/tasks.c **** }
 2213               	.LM191:
 2214 0b32 2696      		adiw r28,6
 2215 0b34 0FB6      		in __tmp_reg__,__SREG__
 2216 0b36 F894      		cli
 2217 0b38 DEBF      		out __SP_H__,r29
 2218 0b3a 0FBE      		out __SREG__,__tmp_reg__
 2219 0b3c CDBF      		out __SP_L__,r28
 2220 0b3e CF91      		pop r28
 2221 0b40 DF91      		pop r29
 2222 0b42 0895      		ret
 2227               	.Lscope17:
 2229               		.stabd	78,0,0
 2232               	.global	xTaskRemoveFromEventList
 2234               	xTaskRemoveFromEventList:
 2235               		.stabd	46,0,0
1911:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1912:../../FreeRTOS/Source/tasks.c **** 
1913:../../FreeRTOS/Source/tasks.c **** #if configUSE_TIMERS == 1
1914:../../FreeRTOS/Source/tasks.c **** 
1915:../../FreeRTOS/Source/tasks.c **** 	void vTaskPlaceOnEventListRestricted( const xList * const pxEventList, portTickType xTicksToWait )
1916:../../FreeRTOS/Source/tasks.c **** 	{
1917:../../FreeRTOS/Source/tasks.c **** 	portTickType xTimeToWake;
1918:../../FreeRTOS/Source/tasks.c **** 
1919:../../FreeRTOS/Source/tasks.c **** 		configASSERT( pxEventList );
1920:../../FreeRTOS/Source/tasks.c **** 
1921:../../FreeRTOS/Source/tasks.c **** 		/* This function should not be called by application code hence the
1922:../../FreeRTOS/Source/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
1923:../../FreeRTOS/Source/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
1924:../../FreeRTOS/Source/tasks.c **** 		it should be called from a critical section. */
1925:../../FreeRTOS/Source/tasks.c **** 
1926:../../FreeRTOS/Source/tasks.c **** 
1927:../../FreeRTOS/Source/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
1928:../../FreeRTOS/Source/tasks.c **** 		In this case it is assume that this is the only task that is going to
1929:../../FreeRTOS/Source/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
1930:../../FreeRTOS/Source/tasks.c **** 		can be used in place of vListInsert. */
1931:../../FreeRTOS/Source/tasks.c **** 		vListInsertEnd( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
1932:../../FreeRTOS/Source/tasks.c **** 
1933:../../FreeRTOS/Source/tasks.c **** 		/* We must remove this task from the ready list before adding it to the
1934:../../FreeRTOS/Source/tasks.c **** 		blocked list as the same list item is used for both lists.  This
1935:../../FreeRTOS/Source/tasks.c **** 		function is called form a critical section. */
1936:../../FreeRTOS/Source/tasks.c **** 		if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
1937:../../FreeRTOS/Source/tasks.c **** 		{
1938:../../FreeRTOS/Source/tasks.c **** 			/* The current task must be in a ready list, so there is no need to
1939:../../FreeRTOS/Source/tasks.c **** 			check, and the port reset macro can be called directly. */
1940:../../FreeRTOS/Source/tasks.c **** 			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
1941:../../FreeRTOS/Source/tasks.c **** 		}
1942:../../FreeRTOS/Source/tasks.c **** 
1943:../../FreeRTOS/Source/tasks.c **** 		/* Calculate the time at which the task should be woken if the event does
1944:../../FreeRTOS/Source/tasks.c **** 		not occur.  This may overflow but this doesn't matter. */
1945:../../FreeRTOS/Source/tasks.c **** 		xTimeToWake = xTickCount + xTicksToWait;
1946:../../FreeRTOS/Source/tasks.c **** 
1947:../../FreeRTOS/Source/tasks.c **** 		traceTASK_DELAY_UNTIL();
1948:../../FreeRTOS/Source/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTimeToWake );
1949:../../FreeRTOS/Source/tasks.c **** 	}
1950:../../FreeRTOS/Source/tasks.c **** 
1951:../../FreeRTOS/Source/tasks.c **** #endif /* configUSE_TIMERS */
1952:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1953:../../FreeRTOS/Source/tasks.c **** 
1954:../../FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
1955:../../FreeRTOS/Source/tasks.c **** {
 2237               	.LM192:
 2238               	.LFBB18:
 2239 0b44 DF93      		push r29
 2240 0b46 CF93      		push r28
 2241 0b48 00D0      		rcall .
 2242 0b4a 0F92      		push __tmp_reg__
 2243 0b4c 0F92      		push __tmp_reg__
 2244 0b4e CDB7      		in r28,__SP_L__
 2245 0b50 DEB7      		in r29,__SP_H__
 2246               	/* prologue: function */
 2247               	/* frame size = 5 */
 2248 0b52 9D83      		std Y+5,r25
 2249 0b54 8C83      		std Y+4,r24
1956:../../FreeRTOS/Source/tasks.c **** tskTCB *pxUnblockedTCB;
1957:../../FreeRTOS/Source/tasks.c **** portBASE_TYPE xReturn;
1958:../../FreeRTOS/Source/tasks.c **** 
1959:../../FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1960:../../FreeRTOS/Source/tasks.c **** 	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
1961:../../FreeRTOS/Source/tasks.c **** 
1962:../../FreeRTOS/Source/tasks.c **** 	/* The event list is sorted in priority order, so we can remove the
1963:../../FreeRTOS/Source/tasks.c **** 	first in the list, remove the TCB from the delayed list, and add
1964:../../FreeRTOS/Source/tasks.c **** 	it to the ready list.
1965:../../FreeRTOS/Source/tasks.c **** 
1966:../../FreeRTOS/Source/tasks.c **** 	If an event is for a queue that is locked then this function will never
1967:../../FreeRTOS/Source/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
1968:../../FreeRTOS/Source/tasks.c **** 	means we can always expect exclusive access to the event list here.
1969:../../FreeRTOS/Source/tasks.c **** 
1970:../../FreeRTOS/Source/tasks.c **** 	This function assumes that a check has already been made to ensure that
1971:../../FreeRTOS/Source/tasks.c **** 	pxEventList is not empty. */
1972:../../FreeRTOS/Source/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 2251               	.LM193:
 2252 0b56 EC81      		ldd r30,Y+4
 2253 0b58 FD81      		ldd r31,Y+5
 2254 0b5a 0580      		ldd __tmp_reg__,Z+5
 2255 0b5c F681      		ldd r31,Z+6
 2256 0b5e E02D      		mov r30,__tmp_reg__
 2257 0b60 8681      		ldd r24,Z+6
 2258 0b62 9781      		ldd r25,Z+7
 2259 0b64 9B83      		std Y+3,r25
 2260 0b66 8A83      		std Y+2,r24
1973:../../FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
1974:../../FreeRTOS/Source/tasks.c **** 	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 2262               	.LM194:
 2263 0b68 8A81      		ldd r24,Y+2
 2264 0b6a 9B81      		ldd r25,Y+3
 2265 0b6c 0C96      		adiw r24,12
 2266 0b6e 0E94 0000 		call uxListRemove
1975:../../FreeRTOS/Source/tasks.c **** 
1976:../../FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 2268               	.LM195:
 2269 0b72 8091 0000 		lds r24,uxSchedulerSuspended
 2270 0b76 8823      		tst r24
 2271 0b78 01F4      		brne .L95
1977:../../FreeRTOS/Source/tasks.c **** 	{
1978:../../FreeRTOS/Source/tasks.c **** 		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 2273               	.LM196:
 2274 0b7a 8A81      		ldd r24,Y+2
 2275 0b7c 9B81      		ldd r25,Y+3
 2276 0b7e 0296      		adiw r24,2
 2277 0b80 0E94 0000 		call uxListRemove
1979:../../FreeRTOS/Source/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
 2279               	.LM197:
 2280 0b84 EA81      		ldd r30,Y+2
 2281 0b86 FB81      		ldd r31,Y+3
 2282 0b88 9689      		ldd r25,Z+22
 2283 0b8a 8091 0000 		lds r24,uxTopReadyPriority
 2284 0b8e 8917      		cp r24,r25
 2285 0b90 00F4      		brsh .L96
 2286 0b92 EA81      		ldd r30,Y+2
 2287 0b94 FB81      		ldd r31,Y+3
 2288 0b96 8689      		ldd r24,Z+22
 2289 0b98 8093 0000 		sts uxTopReadyPriority,r24
 2290               	.L96:
 2291 0b9c EA81      		ldd r30,Y+2
 2292 0b9e FB81      		ldd r31,Y+3
 2293 0ba0 8689      		ldd r24,Z+22
 2294 0ba2 282F      		mov r18,r24
 2295 0ba4 30E0      		ldi r19,lo8(0)
 2296 0ba6 C901      		movw r24,r18
 2297 0ba8 880F      		lsl r24
 2298 0baa 991F      		rol r25
 2299 0bac 880F      		lsl r24
 2300 0bae 991F      		rol r25
 2301 0bb0 880F      		lsl r24
 2302 0bb2 991F      		rol r25
 2303 0bb4 820F      		add r24,r18
 2304 0bb6 931F      		adc r25,r19
 2305 0bb8 AC01      		movw r20,r24
 2306 0bba 4050      		subi r20,lo8(-(pxReadyTasksLists))
 2307 0bbc 5040      		sbci r21,hi8(-(pxReadyTasksLists))
 2308 0bbe 8A81      		ldd r24,Y+2
 2309 0bc0 9B81      		ldd r25,Y+3
 2310 0bc2 9C01      		movw r18,r24
 2311 0bc4 2E5F      		subi r18,lo8(-(2))
 2312 0bc6 3F4F      		sbci r19,hi8(-(2))
 2313 0bc8 CA01      		movw r24,r20
 2314 0bca B901      		movw r22,r18
 2315 0bcc 0E94 0000 		call vListInsertEnd
 2316 0bd0 00C0      		rjmp .L97
 2317               	.L95:
1980:../../FreeRTOS/Source/tasks.c **** 	}
1981:../../FreeRTOS/Source/tasks.c **** 	else
1982:../../FreeRTOS/Source/tasks.c **** 	{
1983:../../FreeRTOS/Source/tasks.c **** 		/* We cannot access the delayed or ready lists, so will hold this
1984:../../FreeRTOS/Source/tasks.c **** 		task pending until the scheduler is resumed. */
1985:../../FreeRTOS/Source/tasks.c **** 		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 2319               	.LM198:
 2320 0bd2 8A81      		ldd r24,Y+2
 2321 0bd4 9B81      		ldd r25,Y+3
 2322 0bd6 9C01      		movw r18,r24
 2323 0bd8 245F      		subi r18,lo8(-(12))
 2324 0bda 3F4F      		sbci r19,hi8(-(12))
 2325 0bdc 80E0      		ldi r24,lo8(xPendingReadyList)
 2326 0bde 90E0      		ldi r25,hi8(xPendingReadyList)
 2327 0be0 B901      		movw r22,r18
 2328 0be2 0E94 0000 		call vListInsertEnd
 2329               	.L97:
1986:../../FreeRTOS/Source/tasks.c **** 	}
1987:../../FreeRTOS/Source/tasks.c **** 
1988:../../FreeRTOS/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2331               	.LM199:
 2332 0be6 EA81      		ldd r30,Y+2
 2333 0be8 FB81      		ldd r31,Y+3
 2334 0bea 9689      		ldd r25,Z+22
 2335 0bec E091 0000 		lds r30,pxCurrentTCB
 2336 0bf0 F091 0000 		lds r31,(pxCurrentTCB)+1
 2337 0bf4 8689      		ldd r24,Z+22
 2338 0bf6 9817      		cp r25,r24
 2339 0bf8 00F0      		brlo .L98
1989:../../FreeRTOS/Source/tasks.c **** 	{
1990:../../FreeRTOS/Source/tasks.c **** 		/* Return true if the task removed from the event list has
1991:../../FreeRTOS/Source/tasks.c **** 		a higher priority than the calling task.  This allows
1992:../../FreeRTOS/Source/tasks.c **** 		the calling task to know if it should force a context
1993:../../FreeRTOS/Source/tasks.c **** 		switch now. */
1994:../../FreeRTOS/Source/tasks.c **** 		xReturn = pdTRUE;
 2341               	.LM200:
 2342 0bfa 81E0      		ldi r24,lo8(1)
 2343 0bfc 8983      		std Y+1,r24
 2344 0bfe 00C0      		rjmp .L99
 2345               	.L98:
1995:../../FreeRTOS/Source/tasks.c **** 	}
1996:../../FreeRTOS/Source/tasks.c **** 	else
1997:../../FreeRTOS/Source/tasks.c **** 	{
1998:../../FreeRTOS/Source/tasks.c **** 		xReturn = pdFALSE;
 2347               	.LM201:
 2348 0c00 1982      		std Y+1,__zero_reg__
 2349               	.L99:
1999:../../FreeRTOS/Source/tasks.c **** 	}
2000:../../FreeRTOS/Source/tasks.c **** 
2001:../../FreeRTOS/Source/tasks.c **** 	return xReturn;
 2351               	.LM202:
 2352 0c02 8981      		ldd r24,Y+1
 2353               	/* epilogue start */
2002:../../FreeRTOS/Source/tasks.c **** }
 2355               	.LM203:
 2356 0c04 0F90      		pop __tmp_reg__
 2357 0c06 0F90      		pop __tmp_reg__
 2358 0c08 0F90      		pop __tmp_reg__
 2359 0c0a 0F90      		pop __tmp_reg__
 2360 0c0c 0F90      		pop __tmp_reg__
 2361 0c0e CF91      		pop r28
 2362 0c10 DF91      		pop r29
 2363 0c12 0895      		ret
 2369               	.Lscope18:
 2371               		.stabd	78,0,0
 2374               	.global	vTaskSetTimeOutState
 2376               	vTaskSetTimeOutState:
 2377               		.stabd	46,0,0
2003:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2004:../../FreeRTOS/Source/tasks.c **** 
2005:../../FreeRTOS/Source/tasks.c **** void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
2006:../../FreeRTOS/Source/tasks.c **** {
 2379               	.LM204:
 2380               	.LFBB19:
 2381 0c14 DF93      		push r29
 2382 0c16 CF93      		push r28
 2383 0c18 0F92      		push __tmp_reg__
 2384 0c1a 0F92      		push __tmp_reg__
 2385 0c1c CDB7      		in r28,__SP_L__
 2386 0c1e DEB7      		in r29,__SP_H__
 2387               	/* prologue: function */
 2388               	/* frame size = 2 */
 2389 0c20 9A83      		std Y+2,r25
 2390 0c22 8983      		std Y+1,r24
2007:../../FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
2008:../../FreeRTOS/Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 2392               	.LM205:
 2393 0c24 8091 0000 		lds r24,xNumOfOverflows
 2394 0c28 E981      		ldd r30,Y+1
 2395 0c2a FA81      		ldd r31,Y+2
 2396 0c2c 8083      		st Z,r24
2009:../../FreeRTOS/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 2398               	.LM206:
 2399 0c2e 8091 0000 		lds r24,xTickCount
 2400 0c32 9091 0000 		lds r25,(xTickCount)+1
 2401 0c36 E981      		ldd r30,Y+1
 2402 0c38 FA81      		ldd r31,Y+2
 2403 0c3a 9283      		std Z+2,r25
 2404 0c3c 8183      		std Z+1,r24
 2405               	/* epilogue start */
2010:../../FreeRTOS/Source/tasks.c **** }
 2407               	.LM207:
 2408 0c3e 0F90      		pop __tmp_reg__
 2409 0c40 0F90      		pop __tmp_reg__
 2410 0c42 CF91      		pop r28
 2411 0c44 DF91      		pop r29
 2412 0c46 0895      		ret
 2414               	.Lscope19:
 2416               		.stabd	78,0,0
 2420               	.global	xTaskCheckForTimeOut
 2422               	xTaskCheckForTimeOut:
 2423               		.stabd	46,0,0
2011:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2012:../../FreeRTOS/Source/tasks.c **** 
2013:../../FreeRTOS/Source/tasks.c **** portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToW
2014:../../FreeRTOS/Source/tasks.c **** {
 2425               	.LM208:
 2426               	.LFBB20:
 2427 0c48 DF93      		push r29
 2428 0c4a CF93      		push r28
 2429 0c4c 00D0      		rcall .
 2430 0c4e 0F92      		push __tmp_reg__
 2431 0c50 0F92      		push __tmp_reg__
 2432 0c52 CDB7      		in r28,__SP_L__
 2433 0c54 DEB7      		in r29,__SP_H__
 2434               	/* prologue: function */
 2435               	/* frame size = 5 */
 2436 0c56 9B83      		std Y+3,r25
 2437 0c58 8A83      		std Y+2,r24
 2438 0c5a 7D83      		std Y+5,r23
 2439 0c5c 6C83      		std Y+4,r22
2015:../../FreeRTOS/Source/tasks.c **** portBASE_TYPE xReturn;
2016:../../FreeRTOS/Source/tasks.c **** 
2017:../../FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
2018:../../FreeRTOS/Source/tasks.c **** 	configASSERT( pxTicksToWait );
2019:../../FreeRTOS/Source/tasks.c **** 
2020:../../FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
 2441               	.LM209:
 2442               	/* #APP */
 2443               	 ;  2020 "../../FreeRTOS/Source/tasks.c" 1
 2444 0c5e 0FB6      		in		__tmp_reg__, __SREG__
 2445               	 ;  0 "" 2
 2446               	 ;  2020 "../../FreeRTOS/Source/tasks.c" 1
 2447 0c60 F894      		cli
 2448               	 ;  0 "" 2
 2449               	 ;  2020 "../../FreeRTOS/Source/tasks.c" 1
 2450 0c62 0F92      		push	__tmp_reg__
 2451               	 ;  0 "" 2
2021:../../FreeRTOS/Source/tasks.c **** 	{
2022:../../FreeRTOS/Source/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
2023:../../FreeRTOS/Source/tasks.c **** 			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
2024:../../FreeRTOS/Source/tasks.c **** 			the maximum block time then the task should block indefinitely, and
2025:../../FreeRTOS/Source/tasks.c **** 			therefore never time out. */
2026:../../FreeRTOS/Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
 2453               	.LM210:
 2454               	/* #NOAPP */
 2455 0c64 EC81      		ldd r30,Y+4
 2456 0c66 FD81      		ldd r31,Y+5
 2457 0c68 8081      		ld r24,Z
 2458 0c6a 9181      		ldd r25,Z+1
 2459 0c6c 2FEF      		ldi r18,hi8(-1)
 2460 0c6e 8F3F      		cpi r24,lo8(-1)
 2461 0c70 9207      		cpc r25,r18
 2462 0c72 01F4      		brne .L104
2027:../../FreeRTOS/Source/tasks.c **** 			{
2028:../../FreeRTOS/Source/tasks.c **** 				xReturn = pdFALSE;
 2464               	.LM211:
 2465 0c74 1982      		std Y+1,__zero_reg__
 2466 0c76 00C0      		rjmp .L105
 2467               	.L104:
2029:../../FreeRTOS/Source/tasks.c **** 			}
2030:../../FreeRTOS/Source/tasks.c **** 			else /* We are not blocking indefinitely, perform the checks below. */
2031:../../FreeRTOS/Source/tasks.c **** 		#endif
2032:../../FreeRTOS/Source/tasks.c **** 
2033:../../FreeRTOS/Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
 2469               	.LM212:
 2470 0c78 EA81      		ldd r30,Y+2
 2471 0c7a FB81      		ldd r31,Y+3
 2472 0c7c 9081      		ld r25,Z
 2473 0c7e 8091 0000 		lds r24,xNumOfOverflows
 2474 0c82 9817      		cp r25,r24
 2475 0c84 01F0      		breq .L106
 2476 0c86 EA81      		ldd r30,Y+2
 2477 0c88 FB81      		ldd r31,Y+3
 2478 0c8a 2181      		ldd r18,Z+1
 2479 0c8c 3281      		ldd r19,Z+2
 2480 0c8e 8091 0000 		lds r24,xTickCount
 2481 0c92 9091 0000 		lds r25,(xTickCount)+1
 2482 0c96 8217      		cp r24,r18
 2483 0c98 9307      		cpc r25,r19
 2484 0c9a 00F0      		brlo .L106
2034:../../FreeRTOS/Source/tasks.c **** 		{
2035:../../FreeRTOS/Source/tasks.c **** 			/* The tick count is greater than the time at which vTaskSetTimeout()
2036:../../FreeRTOS/Source/tasks.c **** 			was called, but has also overflowed since vTaskSetTimeOut() was called.
2037:../../FreeRTOS/Source/tasks.c **** 			It must have wrapped all the way around and gone past us again. This
2038:../../FreeRTOS/Source/tasks.c **** 			passed since vTaskSetTimeout() was called. */
2039:../../FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
 2486               	.LM213:
 2487 0c9c 81E0      		ldi r24,lo8(1)
 2488 0c9e 8983      		std Y+1,r24
 2489 0ca0 00C0      		rjmp .L105
 2490               	.L106:
2040:../../FreeRTOS/Source/tasks.c **** 		}
2041:../../FreeRTOS/Source/tasks.c **** 		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEn
 2492               	.LM214:
 2493 0ca2 2091 0000 		lds r18,xTickCount
 2494 0ca6 3091 0000 		lds r19,(xTickCount)+1
 2495 0caa EA81      		ldd r30,Y+2
 2496 0cac FB81      		ldd r31,Y+3
 2497 0cae 8181      		ldd r24,Z+1
 2498 0cb0 9281      		ldd r25,Z+2
 2499 0cb2 281B      		sub r18,r24
 2500 0cb4 390B      		sbc r19,r25
 2501 0cb6 EC81      		ldd r30,Y+4
 2502 0cb8 FD81      		ldd r31,Y+5
 2503 0cba 8081      		ld r24,Z
 2504 0cbc 9181      		ldd r25,Z+1
 2505 0cbe 2817      		cp r18,r24
 2506 0cc0 3907      		cpc r19,r25
 2507 0cc2 00F4      		brsh .L107
2042:../../FreeRTOS/Source/tasks.c **** 		{
2043:../../FreeRTOS/Source/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
2044:../../FreeRTOS/Source/tasks.c **** 			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
 2509               	.LM215:
 2510 0cc4 EC81      		ldd r30,Y+4
 2511 0cc6 FD81      		ldd r31,Y+5
 2512 0cc8 4081      		ld r20,Z
 2513 0cca 5181      		ldd r21,Z+1
 2514 0ccc EA81      		ldd r30,Y+2
 2515 0cce FB81      		ldd r31,Y+3
 2516 0cd0 2181      		ldd r18,Z+1
 2517 0cd2 3281      		ldd r19,Z+2
 2518 0cd4 8091 0000 		lds r24,xTickCount
 2519 0cd8 9091 0000 		lds r25,(xTickCount)+1
 2520 0cdc B901      		movw r22,r18
 2521 0cde 681B      		sub r22,r24
 2522 0ce0 790B      		sbc r23,r25
 2523 0ce2 CB01      		movw r24,r22
 2524 0ce4 840F      		add r24,r20
 2525 0ce6 951F      		adc r25,r21
 2526 0ce8 EC81      		ldd r30,Y+4
 2527 0cea FD81      		ldd r31,Y+5
 2528 0cec 9183      		std Z+1,r25
 2529 0cee 8083      		st Z,r24
2045:../../FreeRTOS/Source/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 2531               	.LM216:
 2532 0cf0 8A81      		ldd r24,Y+2
 2533 0cf2 9B81      		ldd r25,Y+3
 2534 0cf4 0E94 0000 		call vTaskSetTimeOutState
2046:../../FreeRTOS/Source/tasks.c **** 			xReturn = pdFALSE;
 2536               	.LM217:
 2537 0cf8 1982      		std Y+1,__zero_reg__
 2538 0cfa 00C0      		rjmp .L105
 2539               	.L107:
2047:../../FreeRTOS/Source/tasks.c **** 		}
2048:../../FreeRTOS/Source/tasks.c **** 		else
2049:../../FreeRTOS/Source/tasks.c **** 		{
2050:../../FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
 2541               	.LM218:
 2542 0cfc 81E0      		ldi r24,lo8(1)
 2543 0cfe 8983      		std Y+1,r24
 2544               	.L105:
2051:../../FreeRTOS/Source/tasks.c **** 		}
2052:../../FreeRTOS/Source/tasks.c **** 	}
2053:../../FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
 2546               	.LM219:
 2547               	/* #APP */
 2548               	 ;  2053 "../../FreeRTOS/Source/tasks.c" 1
 2549 0d00 0F90      		pop		__tmp_reg__
 2550               	 ;  0 "" 2
 2551               	 ;  2053 "../../FreeRTOS/Source/tasks.c" 1
 2552 0d02 0FBE      		out		__SREG__, __tmp_reg__
 2553               	 ;  0 "" 2
2054:../../FreeRTOS/Source/tasks.c **** 
2055:../../FreeRTOS/Source/tasks.c **** 	return xReturn;
 2555               	.LM220:
 2556               	/* #NOAPP */
 2557 0d04 8981      		ldd r24,Y+1
 2558               	/* epilogue start */
2056:../../FreeRTOS/Source/tasks.c **** }
 2560               	.LM221:
 2561 0d06 0F90      		pop __tmp_reg__
 2562 0d08 0F90      		pop __tmp_reg__
 2563 0d0a 0F90      		pop __tmp_reg__
 2564 0d0c 0F90      		pop __tmp_reg__
 2565 0d0e 0F90      		pop __tmp_reg__
 2566 0d10 CF91      		pop r28
 2567 0d12 DF91      		pop r29
 2568 0d14 0895      		ret
 2573               	.Lscope20:
 2575               		.stabd	78,0,0
 2577               	.global	vTaskMissedYield
 2579               	vTaskMissedYield:
 2580               		.stabd	46,0,0
2057:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2058:../../FreeRTOS/Source/tasks.c **** 
2059:../../FreeRTOS/Source/tasks.c **** void vTaskMissedYield( void )
2060:../../FreeRTOS/Source/tasks.c **** {
 2582               	.LM222:
 2583               	.LFBB21:
 2584 0d16 DF93      		push r29
 2585 0d18 CF93      		push r28
 2586 0d1a CDB7      		in r28,__SP_L__
 2587 0d1c DEB7      		in r29,__SP_H__
 2588               	/* prologue: function */
 2589               	/* frame size = 0 */
2061:../../FreeRTOS/Source/tasks.c **** 	xMissedYield = pdTRUE;
 2591               	.LM223:
 2592 0d1e 81E0      		ldi r24,lo8(1)
 2593 0d20 8093 0000 		sts xMissedYield,r24
 2594               	/* epilogue start */
2062:../../FreeRTOS/Source/tasks.c **** }
 2596               	.LM224:
 2597 0d24 CF91      		pop r28
 2598 0d26 DF91      		pop r29
 2599 0d28 0895      		ret
 2601               	.Lscope21:
 2603               		.stabd	78,0,0
 2607               	prvIdleTask:
 2608               		.stabd	46,0,0
2063:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2064:../../FreeRTOS/Source/tasks.c **** 
2065:../../FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2066:../../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetTaskNumber( xTaskHandle xTask )
2067:../../FreeRTOS/Source/tasks.c **** 	{
2068:../../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
2069:../../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
2070:../../FreeRTOS/Source/tasks.c **** 
2071:../../FreeRTOS/Source/tasks.c **** 		if( xTask != NULL )
2072:../../FreeRTOS/Source/tasks.c **** 		{
2073:../../FreeRTOS/Source/tasks.c **** 			pxTCB = ( tskTCB * ) xTask;
2074:../../FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxTaskNumber;
2075:../../FreeRTOS/Source/tasks.c **** 		}
2076:../../FreeRTOS/Source/tasks.c **** 		else
2077:../../FreeRTOS/Source/tasks.c **** 		{
2078:../../FreeRTOS/Source/tasks.c **** 			uxReturn = 0U;
2079:../../FreeRTOS/Source/tasks.c **** 		}
2080:../../FreeRTOS/Source/tasks.c **** 
2081:../../FreeRTOS/Source/tasks.c **** 		return uxReturn;
2082:../../FreeRTOS/Source/tasks.c **** 	}
2083:../../FreeRTOS/Source/tasks.c **** #endif
2084:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2085:../../FreeRTOS/Source/tasks.c **** 
2086:../../FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2087:../../FreeRTOS/Source/tasks.c **** 	void vTaskSetTaskNumber( xTaskHandle xTask, unsigned portBASE_TYPE uxHandle )
2088:../../FreeRTOS/Source/tasks.c **** 	{
2089:../../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
2090:../../FreeRTOS/Source/tasks.c **** 
2091:../../FreeRTOS/Source/tasks.c **** 		if( xTask != NULL )
2092:../../FreeRTOS/Source/tasks.c **** 		{
2093:../../FreeRTOS/Source/tasks.c **** 			pxTCB = ( tskTCB * ) xTask;
2094:../../FreeRTOS/Source/tasks.c **** 			pxTCB->uxTaskNumber = uxHandle;
2095:../../FreeRTOS/Source/tasks.c **** 		}
2096:../../FreeRTOS/Source/tasks.c **** 	}
2097:../../FreeRTOS/Source/tasks.c **** #endif
2098:../../FreeRTOS/Source/tasks.c **** 
2099:../../FreeRTOS/Source/tasks.c **** 
2100:../../FreeRTOS/Source/tasks.c **** /*
2101:../../FreeRTOS/Source/tasks.c ****  * -----------------------------------------------------------
2102:../../FreeRTOS/Source/tasks.c ****  * The Idle task.
2103:../../FreeRTOS/Source/tasks.c ****  * ----------------------------------------------------------
2104:../../FreeRTOS/Source/tasks.c ****  *
2105:../../FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
2106:../../FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
2107:../../FreeRTOS/Source/tasks.c ****  *
2108:../../FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
2109:../../FreeRTOS/Source/tasks.c ****  *
2110:../../FreeRTOS/Source/tasks.c ****  */
2111:../../FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
2112:../../FreeRTOS/Source/tasks.c **** {
 2610               	.LM225:
 2611               	.LFBB22:
 2612 0d2a DF93      		push r29
 2613 0d2c CF93      		push r28
 2614 0d2e 0F92      		push __tmp_reg__
 2615 0d30 0F92      		push __tmp_reg__
 2616 0d32 CDB7      		in r28,__SP_L__
 2617 0d34 DEB7      		in r29,__SP_H__
 2618               	/* prologue: function */
 2619               	/* frame size = 2 */
 2620 0d36 9A83      		std Y+2,r25
 2621 0d38 8983      		std Y+1,r24
 2622               	.L113:
2113:../../FreeRTOS/Source/tasks.c **** 	/* Stop warnings. */
2114:../../FreeRTOS/Source/tasks.c **** 	( void ) pvParameters;
2115:../../FreeRTOS/Source/tasks.c **** 
2116:../../FreeRTOS/Source/tasks.c **** 	for( ;; )
2117:../../FreeRTOS/Source/tasks.c **** 	{
2118:../../FreeRTOS/Source/tasks.c **** 		/* See if any tasks have been deleted. */
2119:../../FreeRTOS/Source/tasks.c **** 		prvCheckTasksWaitingTermination();
 2624               	.LM226:
 2625 0d3a 0E94 0000 		call prvCheckTasksWaitingTermination
2120:../../FreeRTOS/Source/tasks.c **** 
2121:../../FreeRTOS/Source/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
2122:../../FreeRTOS/Source/tasks.c **** 		{
2123:../../FreeRTOS/Source/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
2124:../../FreeRTOS/Source/tasks.c **** 			see if any other task has become available.  If we are using
2125:../../FreeRTOS/Source/tasks.c **** 			preemption we don't need to do this as any task becoming available
2126:../../FreeRTOS/Source/tasks.c **** 			will automatically get the processor anyway. */
2127:../../FreeRTOS/Source/tasks.c **** 			taskYIELD();
2128:../../FreeRTOS/Source/tasks.c **** 		}
2129:../../FreeRTOS/Source/tasks.c **** 		#endif
2130:../../FreeRTOS/Source/tasks.c **** 
2131:../../FreeRTOS/Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
2132:../../FreeRTOS/Source/tasks.c **** 		{
2133:../../FreeRTOS/Source/tasks.c **** 			/* When using preemption tasks of equal priority will be
2134:../../FreeRTOS/Source/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
2135:../../FreeRTOS/Source/tasks.c **** 			to run then the idle task should yield before the end of the
2136:../../FreeRTOS/Source/tasks.c **** 			timeslice.
2137:../../FreeRTOS/Source/tasks.c **** 
2138:../../FreeRTOS/Source/tasks.c **** 			A critical region is not required here as we are just reading from
2139:../../FreeRTOS/Source/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
2140:../../FreeRTOS/Source/tasks.c **** 			the ready list at the idle priority contains more than one task
2141:../../FreeRTOS/Source/tasks.c **** 			then a task other than the idle task is ready to execute. */
2142:../../FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_
 2627               	.LM227:
 2628 0d3e 8091 0000 		lds r24,pxReadyTasksLists
 2629 0d42 8230      		cpi r24,lo8(2)
 2630 0d44 00F0      		brlo .L113
2143:../../FreeRTOS/Source/tasks.c **** 			{
2144:../../FreeRTOS/Source/tasks.c **** 				taskYIELD();
 2632               	.LM228:
 2633 0d46 0E94 0000 		call vPortYield
 2634 0d4a 00C0      		rjmp .L113
 2636               	.Lscope22:
 2638               		.stabd	78,0,0
 2646               	prvInitialiseTCBVariables:
 2647               		.stabd	46,0,0
2145:../../FreeRTOS/Source/tasks.c **** 			}
2146:../../FreeRTOS/Source/tasks.c **** 		}
2147:../../FreeRTOS/Source/tasks.c **** 		#endif
2148:../../FreeRTOS/Source/tasks.c **** 
2149:../../FreeRTOS/Source/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
2150:../../FreeRTOS/Source/tasks.c **** 		{
2151:../../FreeRTOS/Source/tasks.c **** 			extern void vApplicationIdleHook( void );
2152:../../FreeRTOS/Source/tasks.c **** 
2153:../../FreeRTOS/Source/tasks.c **** 			/* Call the user defined function from within the idle task.  This
2154:../../FreeRTOS/Source/tasks.c **** 			allows the application designer to add background functionality
2155:../../FreeRTOS/Source/tasks.c **** 			without the overhead of a separate task.
2156:../../FreeRTOS/Source/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
2157:../../FreeRTOS/Source/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
2158:../../FreeRTOS/Source/tasks.c **** 			vApplicationIdleHook();
2159:../../FreeRTOS/Source/tasks.c **** 		}
2160:../../FreeRTOS/Source/tasks.c **** 		#endif
2161:../../FreeRTOS/Source/tasks.c **** 
2162:../../FreeRTOS/Source/tasks.c **** 		/* This conditional compilation should use inequality to 0, not equality
2163:../../FreeRTOS/Source/tasks.c **** 		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
2164:../../FreeRTOS/Source/tasks.c **** 		user defined low power mode	implementations require
2165:../../FreeRTOS/Source/tasks.c **** 		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
2166:../../FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICKLESS_IDLE != 0 )
2167:../../FreeRTOS/Source/tasks.c **** 		{
2168:../../FreeRTOS/Source/tasks.c **** 		portTickType xExpectedIdleTime;
2169:../../FreeRTOS/Source/tasks.c **** 		/* If the expected idle time is 1 then the idle time would end at
2170:../../FreeRTOS/Source/tasks.c **** 		the end of the current time slice.  The idle time must be at least
2171:../../FreeRTOS/Source/tasks.c **** 		2 to ensure any pended ticks between this point and the tick being
2172:../../FreeRTOS/Source/tasks.c **** 		stopped can be legitimately stepped over when the tick suppression
2173:../../FreeRTOS/Source/tasks.c **** 		routines returns. */
2174:../../FreeRTOS/Source/tasks.c **** 		const portTickType xMinimumExpectedIdleTime = ( portTickType ) 2;
2175:../../FreeRTOS/Source/tasks.c **** 
2176:../../FreeRTOS/Source/tasks.c **** 			/* It is not desirable to suspend then resume the scheduler on
2177:../../FreeRTOS/Source/tasks.c **** 			each iteration of the idle task.  Therefore, a preliminary
2178:../../FreeRTOS/Source/tasks.c **** 			test of the expected idle time is performed without the
2179:../../FreeRTOS/Source/tasks.c **** 			scheduler suspended.  The result here is not necessarily
2180:../../FreeRTOS/Source/tasks.c **** 			valid. */
2181:../../FreeRTOS/Source/tasks.c **** 			xExpectedIdleTime = prvGetExpectedIdleTime();
2182:../../FreeRTOS/Source/tasks.c **** 
2183:../../FreeRTOS/Source/tasks.c **** 			if( xExpectedIdleTime >= xMinimumExpectedIdleTime )
2184:../../FreeRTOS/Source/tasks.c **** 			{
2185:../../FreeRTOS/Source/tasks.c **** 				vTaskSuspendAll();
2186:../../FreeRTOS/Source/tasks.c **** 				{
2187:../../FreeRTOS/Source/tasks.c **** 					/* Now the scheduler is suspended, the expected idle
2188:../../FreeRTOS/Source/tasks.c **** 					time can be sampled again, and this time its value can
2189:../../FreeRTOS/Source/tasks.c **** 					be used. */
2190:../../FreeRTOS/Source/tasks.c **** 					configASSERT( xNextTaskUnblockTime >= xTickCount );
2191:../../FreeRTOS/Source/tasks.c **** 					xExpectedIdleTime = prvGetExpectedIdleTime();
2192:../../FreeRTOS/Source/tasks.c **** 
2193:../../FreeRTOS/Source/tasks.c **** 					if( xExpectedIdleTime >= xMinimumExpectedIdleTime )
2194:../../FreeRTOS/Source/tasks.c **** 					{
2195:../../FreeRTOS/Source/tasks.c **** 						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
2196:../../FreeRTOS/Source/tasks.c **** 					}
2197:../../FreeRTOS/Source/tasks.c **** 				}
2198:../../FreeRTOS/Source/tasks.c **** 				xTaskResumeAll();
2199:../../FreeRTOS/Source/tasks.c **** 			}
2200:../../FreeRTOS/Source/tasks.c **** 		}
2201:../../FreeRTOS/Source/tasks.c **** 		#endif
2202:../../FreeRTOS/Source/tasks.c **** 	}
2203:../../FreeRTOS/Source/tasks.c **** } /*lint !e715 pvParameters is not accessed but all task functions require the same prototype. */
2204:../../FreeRTOS/Source/tasks.c **** 
2205:../../FreeRTOS/Source/tasks.c **** 
2206:../../FreeRTOS/Source/tasks.c **** 
2207:../../FreeRTOS/Source/tasks.c **** 
2208:../../FreeRTOS/Source/tasks.c **** 
2209:../../FreeRTOS/Source/tasks.c **** 
2210:../../FreeRTOS/Source/tasks.c **** 
2211:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
2212:../../FreeRTOS/Source/tasks.c ****  * File private functions documented at the top of the file.
2213:../../FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
2214:../../FreeRTOS/Source/tasks.c **** 
2215:../../FreeRTOS/Source/tasks.c **** 
2216:../../FreeRTOS/Source/tasks.c **** 
2217:../../FreeRTOS/Source/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
2218:../../FreeRTOS/Source/tasks.c **** {
 2649               	.LM229:
 2650               	.LFBB23:
 2651 0d4c 0F93      		push r16
 2652 0d4e 1F93      		push r17
 2653 0d50 DF93      		push r29
 2654 0d52 CF93      		push r28
 2655 0d54 CDB7      		in r28,__SP_L__
 2656 0d56 DEB7      		in r29,__SP_H__
 2657 0d58 2997      		sbiw r28,9
 2658 0d5a 0FB6      		in __tmp_reg__,__SREG__
 2659 0d5c F894      		cli
 2660 0d5e DEBF      		out __SP_H__,r29
 2661 0d60 0FBE      		out __SREG__,__tmp_reg__
 2662 0d62 CDBF      		out __SP_L__,r28
 2663               	/* prologue: function */
 2664               	/* frame size = 9 */
 2665 0d64 9A83      		std Y+2,r25
 2666 0d66 8983      		std Y+1,r24
 2667 0d68 7C83      		std Y+4,r23
 2668 0d6a 6B83      		std Y+3,r22
 2669 0d6c 4D83      		std Y+5,r20
 2670 0d6e 3F83      		std Y+7,r19
 2671 0d70 2E83      		std Y+6,r18
 2672 0d72 1987      		std Y+9,r17
 2673 0d74 0887      		std Y+8,r16
2219:../../FreeRTOS/Source/tasks.c **** 	/* Store the function name in the TCB. */
2220:../../FreeRTOS/Source/tasks.c **** 	#if configMAX_TASK_NAME_LEN > 1
2221:../../FreeRTOS/Source/tasks.c **** 	{
2222:../../FreeRTOS/Source/tasks.c **** 		/* Don't bring strncpy into the build unnecessarily. */
2223:../../FreeRTOS/Source/tasks.c **** 		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK
 2675               	.LM230:
 2676 0d76 8981      		ldd r24,Y+1
 2677 0d78 9A81      		ldd r25,Y+2
 2678 0d7a 4996      		adiw r24,25
 2679 0d7c 2B81      		ldd r18,Y+3
 2680 0d7e 3C81      		ldd r19,Y+4
 2681 0d80 B901      		movw r22,r18
 2682 0d82 40E1      		ldi r20,lo8(16)
 2683 0d84 50E0      		ldi r21,hi8(16)
 2684 0d86 0E94 0000 		call strncpy
2224:../../FreeRTOS/Source/tasks.c **** 	}
2225:../../FreeRTOS/Source/tasks.c **** 	#endif
2226:../../FreeRTOS/Source/tasks.c **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed 
 2686               	.LM231:
 2687 0d8a E981      		ldd r30,Y+1
 2688 0d8c FA81      		ldd r31,Y+2
 2689 0d8e 10A6      		std Z+40,__zero_reg__
2227:../../FreeRTOS/Source/tasks.c **** 
2228:../../FreeRTOS/Source/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
2229:../../FreeRTOS/Source/tasks.c **** 	remove the privilege bit if one is present. */
2230:../../FreeRTOS/Source/tasks.c **** 	if( uxPriority >= configMAX_PRIORITIES )
 2691               	.LM232:
 2692 0d90 8D81      		ldd r24,Y+5
 2693 0d92 8430      		cpi r24,lo8(4)
 2694 0d94 00F0      		brlo .L116
2231:../../FreeRTOS/Source/tasks.c **** 	{
2232:../../FreeRTOS/Source/tasks.c **** 		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 2696               	.LM233:
 2697 0d96 83E0      		ldi r24,lo8(3)
 2698 0d98 8D83      		std Y+5,r24
 2699               	.L116:
2233:../../FreeRTOS/Source/tasks.c **** 	}
2234:../../FreeRTOS/Source/tasks.c **** 
2235:../../FreeRTOS/Source/tasks.c **** 	pxTCB->uxPriority = uxPriority;
 2701               	.LM234:
 2702 0d9a E981      		ldd r30,Y+1
 2703 0d9c FA81      		ldd r31,Y+2
 2704 0d9e 8D81      		ldd r24,Y+5
 2705 0da0 868B      		std Z+22,r24
2236:../../FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
2237:../../FreeRTOS/Source/tasks.c **** 	{
2238:../../FreeRTOS/Source/tasks.c **** 		pxTCB->uxBasePriority = uxPriority;
 2707               	.LM235:
 2708 0da2 E981      		ldd r30,Y+1
 2709 0da4 FA81      		ldd r31,Y+2
 2710 0da6 8D81      		ldd r24,Y+5
 2711 0da8 81A7      		std Z+41,r24
2239:../../FreeRTOS/Source/tasks.c **** 	}
2240:../../FreeRTOS/Source/tasks.c **** 	#endif
2241:../../FreeRTOS/Source/tasks.c **** 
2242:../../FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 2713               	.LM236:
 2714 0daa 8981      		ldd r24,Y+1
 2715 0dac 9A81      		ldd r25,Y+2
 2716 0dae 0296      		adiw r24,2
 2717 0db0 0E94 0000 		call vListInitialiseItem
2243:../../FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 2719               	.LM237:
 2720 0db4 8981      		ldd r24,Y+1
 2721 0db6 9A81      		ldd r25,Y+2
 2722 0db8 0C96      		adiw r24,12
 2723 0dba 0E94 0000 		call vListInitialiseItem
2244:../../FreeRTOS/Source/tasks.c **** 
2245:../../FreeRTOS/Source/tasks.c **** 	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
2246:../../FreeRTOS/Source/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
2247:../../FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 2725               	.LM238:
 2726 0dbe E981      		ldd r30,Y+1
 2727 0dc0 FA81      		ldd r31,Y+2
 2728 0dc2 8981      		ldd r24,Y+1
 2729 0dc4 9A81      		ldd r25,Y+2
 2730 0dc6 9187      		std Z+9,r25
 2731 0dc8 8087      		std Z+8,r24
2248:../../FreeRTOS/Source/tasks.c **** 
2249:../../FreeRTOS/Source/tasks.c **** 	/* Event lists are always in priority order. */
2250:../../FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPri
 2733               	.LM239:
 2734 0dca 8D81      		ldd r24,Y+5
 2735 0dcc 282F      		mov r18,r24
 2736 0dce 30E0      		ldi r19,lo8(0)
 2737 0dd0 84E0      		ldi r24,lo8(4)
 2738 0dd2 90E0      		ldi r25,hi8(4)
 2739 0dd4 821B      		sub r24,r18
 2740 0dd6 930B      		sbc r25,r19
 2741 0dd8 E981      		ldd r30,Y+1
 2742 0dda FA81      		ldd r31,Y+2
 2743 0ddc 9587      		std Z+13,r25
 2744 0dde 8487      		std Z+12,r24
2251:../../FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 2746               	.LM240:
 2747 0de0 E981      		ldd r30,Y+1
 2748 0de2 FA81      		ldd r31,Y+2
 2749 0de4 8981      		ldd r24,Y+1
 2750 0de6 9A81      		ldd r25,Y+2
 2751 0de8 938B      		std Z+19,r25
 2752 0dea 828B      		std Z+18,r24
 2753               	/* epilogue start */
2252:../../FreeRTOS/Source/tasks.c **** 
2253:../../FreeRTOS/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
2254:../../FreeRTOS/Source/tasks.c **** 	{
2255:../../FreeRTOS/Source/tasks.c **** 		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0U;
2256:../../FreeRTOS/Source/tasks.c **** 	}
2257:../../FreeRTOS/Source/tasks.c **** 	#endif
2258:../../FreeRTOS/Source/tasks.c **** 
2259:../../FreeRTOS/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
2260:../../FreeRTOS/Source/tasks.c **** 	{
2261:../../FreeRTOS/Source/tasks.c **** 		pxTCB->pxTaskTag = NULL;
2262:../../FreeRTOS/Source/tasks.c **** 	}
2263:../../FreeRTOS/Source/tasks.c **** 	#endif
2264:../../FreeRTOS/Source/tasks.c **** 
2265:../../FreeRTOS/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
2266:../../FreeRTOS/Source/tasks.c **** 	{
2267:../../FreeRTOS/Source/tasks.c **** 		pxTCB->ulRunTimeCounter = 0UL;
2268:../../FreeRTOS/Source/tasks.c **** 	}
2269:../../FreeRTOS/Source/tasks.c **** 	#endif
2270:../../FreeRTOS/Source/tasks.c **** 
2271:../../FreeRTOS/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
2272:../../FreeRTOS/Source/tasks.c **** 	{
2273:../../FreeRTOS/Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
2274:../../FreeRTOS/Source/tasks.c **** 	}
2275:../../FreeRTOS/Source/tasks.c **** 	#else
2276:../../FreeRTOS/Source/tasks.c **** 	{
2277:../../FreeRTOS/Source/tasks.c **** 		( void ) xRegions;
2278:../../FreeRTOS/Source/tasks.c **** 		( void ) usStackDepth;
2279:../../FreeRTOS/Source/tasks.c **** 	}
2280:../../FreeRTOS/Source/tasks.c **** 	#endif
2281:../../FreeRTOS/Source/tasks.c **** }
 2755               	.LM241:
 2756 0dec 2996      		adiw r28,9
 2757 0dee 0FB6      		in __tmp_reg__,__SREG__
 2758 0df0 F894      		cli
 2759 0df2 DEBF      		out __SP_H__,r29
 2760 0df4 0FBE      		out __SREG__,__tmp_reg__
 2761 0df6 CDBF      		out __SP_L__,r28
 2762 0df8 CF91      		pop r28
 2763 0dfa DF91      		pop r29
 2764 0dfc 1F91      		pop r17
 2765 0dfe 0F91      		pop r16
 2766 0e00 0895      		ret
 2768               	.Lscope23:
 2770               		.stabd	78,0,0
 2773               	prvInitialiseTaskLists:
 2774               		.stabd	46,0,0
2282:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2283:../../FreeRTOS/Source/tasks.c **** 
2284:../../FreeRTOS/Source/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
2285:../../FreeRTOS/Source/tasks.c **** 
2286:../../FreeRTOS/Source/tasks.c **** 	void vTaskAllocateMPURegions( xTaskHandle xTaskToModify, const xMemoryRegion * const xRegions )
2287:../../FreeRTOS/Source/tasks.c **** 	{
2288:../../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
2289:../../FreeRTOS/Source/tasks.c **** 
2290:../../FreeRTOS/Source/tasks.c **** 		if( xTaskToModify == pxCurrentTCB )
2291:../../FreeRTOS/Source/tasks.c **** 		{
2292:../../FreeRTOS/Source/tasks.c **** 			xTaskToModify = NULL;
2293:../../FreeRTOS/Source/tasks.c **** 		}
2294:../../FreeRTOS/Source/tasks.c **** 
2295:../../FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then we are deleting ourselves. */
2296:../../FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
2297:../../FreeRTOS/Source/tasks.c **** 
2298:../../FreeRTOS/Source/tasks.c ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
2299:../../FreeRTOS/Source/tasks.c **** 	}
2300:../../FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
2301:../../FreeRTOS/Source/tasks.c **** #endif
2302:../../FreeRTOS/Source/tasks.c **** 
2303:../../FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void )
2304:../../FreeRTOS/Source/tasks.c **** {
 2776               	.LM242:
 2777               	.LFBB24:
 2778 0e02 DF93      		push r29
 2779 0e04 CF93      		push r28
 2780 0e06 0F92      		push __tmp_reg__
 2781 0e08 CDB7      		in r28,__SP_L__
 2782 0e0a DEB7      		in r29,__SP_H__
 2783               	/* prologue: function */
 2784               	/* frame size = 1 */
2305:../../FreeRTOS/Source/tasks.c **** unsigned portBASE_TYPE uxPriority;
2306:../../FreeRTOS/Source/tasks.c **** 
2307:../../FreeRTOS/Source/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 2786               	.LM243:
 2787 0e0c 1982      		std Y+1,__zero_reg__
 2788 0e0e 00C0      		rjmp .L119
 2789               	.L120:
2308:../../FreeRTOS/Source/tasks.c **** 	{
2309:../../FreeRTOS/Source/tasks.c **** 		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 2791               	.LM244:
 2792 0e10 8981      		ldd r24,Y+1
 2793 0e12 282F      		mov r18,r24
 2794 0e14 30E0      		ldi r19,lo8(0)
 2795 0e16 C901      		movw r24,r18
 2796 0e18 880F      		lsl r24
 2797 0e1a 991F      		rol r25
 2798 0e1c 880F      		lsl r24
 2799 0e1e 991F      		rol r25
 2800 0e20 880F      		lsl r24
 2801 0e22 991F      		rol r25
 2802 0e24 820F      		add r24,r18
 2803 0e26 931F      		adc r25,r19
 2804 0e28 8050      		subi r24,lo8(-(pxReadyTasksLists))
 2805 0e2a 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 2806 0e2c 0E94 0000 		call vListInitialise
2307:../../FreeRTOS/Source/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 2808               	.LM245:
 2809 0e30 8981      		ldd r24,Y+1
 2810 0e32 8F5F      		subi r24,lo8(-(1))
 2811 0e34 8983      		std Y+1,r24
 2812               	.L119:
 2813 0e36 8981      		ldd r24,Y+1
 2814 0e38 8430      		cpi r24,lo8(4)
 2815 0e3a 00F0      		brlo .L120
2310:../../FreeRTOS/Source/tasks.c **** 	}
2311:../../FreeRTOS/Source/tasks.c **** 
2312:../../FreeRTOS/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 2817               	.LM246:
 2818 0e3c 80E0      		ldi r24,lo8(xDelayedTaskList1)
 2819 0e3e 90E0      		ldi r25,hi8(xDelayedTaskList1)
 2820 0e40 0E94 0000 		call vListInitialise
2313:../../FreeRTOS/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 2822               	.LM247:
 2823 0e44 80E0      		ldi r24,lo8(xDelayedTaskList2)
 2824 0e46 90E0      		ldi r25,hi8(xDelayedTaskList2)
 2825 0e48 0E94 0000 		call vListInitialise
2314:../../FreeRTOS/Source/tasks.c **** 	vListInitialise( ( xList * ) &xPendingReadyList );
 2827               	.LM248:
 2828 0e4c 80E0      		ldi r24,lo8(xPendingReadyList)
 2829 0e4e 90E0      		ldi r25,hi8(xPendingReadyList)
 2830 0e50 0E94 0000 		call vListInitialise
2315:../../FreeRTOS/Source/tasks.c **** 
2316:../../FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2317:../../FreeRTOS/Source/tasks.c **** 	{
2318:../../FreeRTOS/Source/tasks.c **** 		vListInitialise( ( xList * ) &xTasksWaitingTermination );
2319:../../FreeRTOS/Source/tasks.c **** 	}
2320:../../FreeRTOS/Source/tasks.c **** 	#endif
2321:../../FreeRTOS/Source/tasks.c **** 
2322:../../FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
2323:../../FreeRTOS/Source/tasks.c **** 	{
2324:../../FreeRTOS/Source/tasks.c **** 		vListInitialise( ( xList * ) &xSuspendedTaskList );
 2832               	.LM249:
 2833 0e54 80E0      		ldi r24,lo8(xSuspendedTaskList)
 2834 0e56 90E0      		ldi r25,hi8(xSuspendedTaskList)
 2835 0e58 0E94 0000 		call vListInitialise
2325:../../FreeRTOS/Source/tasks.c **** 	}
2326:../../FreeRTOS/Source/tasks.c **** 	#endif
2327:../../FreeRTOS/Source/tasks.c **** 
2328:../../FreeRTOS/Source/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
2329:../../FreeRTOS/Source/tasks.c **** 	using list2. */
2330:../../FreeRTOS/Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
 2837               	.LM250:
 2838 0e5c 80E0      		ldi r24,lo8(xDelayedTaskList1)
 2839 0e5e 90E0      		ldi r25,hi8(xDelayedTaskList1)
 2840 0e60 9093 0000 		sts (pxDelayedTaskList)+1,r25
 2841 0e64 8093 0000 		sts pxDelayedTaskList,r24
2331:../../FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 2843               	.LM251:
 2844 0e68 80E0      		ldi r24,lo8(xDelayedTaskList2)
 2845 0e6a 90E0      		ldi r25,hi8(xDelayedTaskList2)
 2846 0e6c 9093 0000 		sts (pxOverflowDelayedTaskList)+1,r25
 2847 0e70 8093 0000 		sts pxOverflowDelayedTaskList,r24
 2848               	/* epilogue start */
2332:../../FreeRTOS/Source/tasks.c **** }
 2850               	.LM252:
 2851 0e74 0F90      		pop __tmp_reg__
 2852 0e76 CF91      		pop r28
 2853 0e78 DF91      		pop r29
 2854 0e7a 0895      		ret
 2859               	.Lscope24:
 2861               		.stabd	78,0,0
 2864               	prvCheckTasksWaitingTermination:
 2865               		.stabd	46,0,0
2333:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2334:../../FreeRTOS/Source/tasks.c **** 
2335:../../FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void )
2336:../../FreeRTOS/Source/tasks.c **** {
 2867               	.LM253:
 2868               	.LFBB25:
 2869 0e7c DF93      		push r29
 2870 0e7e CF93      		push r28
 2871 0e80 CDB7      		in r28,__SP_L__
 2872 0e82 DEB7      		in r29,__SP_H__
 2873               	/* prologue: function */
 2874               	/* frame size = 0 */
 2875               	/* epilogue start */
2337:../../FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2338:../../FreeRTOS/Source/tasks.c **** 	{
2339:../../FreeRTOS/Source/tasks.c **** 		portBASE_TYPE xListIsEmpty;
2340:../../FreeRTOS/Source/tasks.c **** 
2341:../../FreeRTOS/Source/tasks.c **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
2342:../../FreeRTOS/Source/tasks.c **** 		too often in the idle task. */
2343:../../FreeRTOS/Source/tasks.c **** 		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
2344:../../FreeRTOS/Source/tasks.c **** 		{
2345:../../FreeRTOS/Source/tasks.c **** 			vTaskSuspendAll();
2346:../../FreeRTOS/Source/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
2347:../../FreeRTOS/Source/tasks.c **** 			xTaskResumeAll();
2348:../../FreeRTOS/Source/tasks.c **** 
2349:../../FreeRTOS/Source/tasks.c **** 			if( xListIsEmpty == pdFALSE )
2350:../../FreeRTOS/Source/tasks.c **** 			{
2351:../../FreeRTOS/Source/tasks.c **** 				tskTCB *pxTCB;
2352:../../FreeRTOS/Source/tasks.c **** 
2353:../../FreeRTOS/Source/tasks.c **** 				taskENTER_CRITICAL();
2354:../../FreeRTOS/Source/tasks.c **** 				{
2355:../../FreeRTOS/Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
2356:../../FreeRTOS/Source/tasks.c **** 					uxListRemove( &( pxTCB->xGenericListItem ) );
2357:../../FreeRTOS/Source/tasks.c **** 					--uxCurrentNumberOfTasks;
2358:../../FreeRTOS/Source/tasks.c **** 					--uxTasksDeleted;
2359:../../FreeRTOS/Source/tasks.c **** 				}
2360:../../FreeRTOS/Source/tasks.c **** 				taskEXIT_CRITICAL();
2361:../../FreeRTOS/Source/tasks.c **** 
2362:../../FreeRTOS/Source/tasks.c **** 				prvDeleteTCB( pxTCB );
2363:../../FreeRTOS/Source/tasks.c **** 			}
2364:../../FreeRTOS/Source/tasks.c **** 		}
2365:../../FreeRTOS/Source/tasks.c **** 	}
2366:../../FreeRTOS/Source/tasks.c **** 	#endif
2367:../../FreeRTOS/Source/tasks.c **** }
 2877               	.LM254:
 2878 0e84 CF91      		pop r28
 2879 0e86 DF91      		pop r29
 2880 0e88 0895      		ret
 2882               	.Lscope25:
 2884               		.stabd	78,0,0
 2888               	prvAddCurrentTaskToDelayedList:
 2889               		.stabd	46,0,0
2368:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2369:../../FreeRTOS/Source/tasks.c **** 
2370:../../FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
2371:../../FreeRTOS/Source/tasks.c **** {
 2891               	.LM255:
 2892               	.LFBB26:
 2893 0e8a DF93      		push r29
 2894 0e8c CF93      		push r28
 2895 0e8e 0F92      		push __tmp_reg__
 2896 0e90 0F92      		push __tmp_reg__
 2897 0e92 CDB7      		in r28,__SP_L__
 2898 0e94 DEB7      		in r29,__SP_H__
 2899               	/* prologue: function */
 2900               	/* frame size = 2 */
 2901 0e96 9A83      		std Y+2,r25
 2902 0e98 8983      		std Y+1,r24
2372:../../FreeRTOS/Source/tasks.c **** 	/* The list item will be inserted in wake time order. */
2373:../../FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 2904               	.LM256:
 2905 0e9a E091 0000 		lds r30,pxCurrentTCB
 2906 0e9e F091 0000 		lds r31,(pxCurrentTCB)+1
 2907 0ea2 8981      		ldd r24,Y+1
 2908 0ea4 9A81      		ldd r25,Y+2
 2909 0ea6 9383      		std Z+3,r25
 2910 0ea8 8283      		std Z+2,r24
2374:../../FreeRTOS/Source/tasks.c **** 
2375:../../FreeRTOS/Source/tasks.c **** 	if( xTimeToWake < xTickCount )
 2912               	.LM257:
 2913 0eaa 2091 0000 		lds r18,xTickCount
 2914 0eae 3091 0000 		lds r19,(xTickCount)+1
 2915 0eb2 8981      		ldd r24,Y+1
 2916 0eb4 9A81      		ldd r25,Y+2
 2917 0eb6 8217      		cp r24,r18
 2918 0eb8 9307      		cpc r25,r19
 2919 0eba 00F4      		brsh .L125
2376:../../FreeRTOS/Source/tasks.c **** 	{
2377:../../FreeRTOS/Source/tasks.c **** 		/* Wake time has overflowed.  Place this item in the overflow list. */
2378:../../FreeRTOS/Source/tasks.c **** 		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericList
 2921               	.LM258:
 2922 0ebc 8091 0000 		lds r24,pxOverflowDelayedTaskList
 2923 0ec0 9091 0000 		lds r25,(pxOverflowDelayedTaskList)+1
 2924 0ec4 2091 0000 		lds r18,pxCurrentTCB
 2925 0ec8 3091 0000 		lds r19,(pxCurrentTCB)+1
 2926 0ecc 2E5F      		subi r18,lo8(-(2))
 2927 0ece 3F4F      		sbci r19,hi8(-(2))
 2928 0ed0 B901      		movw r22,r18
 2929 0ed2 0E94 0000 		call vListInsert
 2930 0ed6 00C0      		rjmp .L127
 2931               	.L125:
2379:../../FreeRTOS/Source/tasks.c **** 	}
2380:../../FreeRTOS/Source/tasks.c **** 	else
2381:../../FreeRTOS/Source/tasks.c **** 	{
2382:../../FreeRTOS/Source/tasks.c **** 		/* The wake time has not overflowed, so we can use the current block list. */
2383:../../FreeRTOS/Source/tasks.c **** 		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) )
 2933               	.LM259:
 2934 0ed8 4091 0000 		lds r20,pxDelayedTaskList
 2935 0edc 5091 0000 		lds r21,(pxDelayedTaskList)+1
 2936 0ee0 8091 0000 		lds r24,pxCurrentTCB
 2937 0ee4 9091 0000 		lds r25,(pxCurrentTCB)+1
 2938 0ee8 9C01      		movw r18,r24
 2939 0eea 2E5F      		subi r18,lo8(-(2))
 2940 0eec 3F4F      		sbci r19,hi8(-(2))
 2941 0eee CA01      		movw r24,r20
 2942 0ef0 B901      		movw r22,r18
 2943 0ef2 0E94 0000 		call vListInsert
2384:../../FreeRTOS/Source/tasks.c **** 
2385:../../FreeRTOS/Source/tasks.c **** 		/* If the task entering the blocked state was placed at the head of the
2386:../../FreeRTOS/Source/tasks.c **** 		list of blocked tasks then xNextTaskUnblockTime needs to be updated
2387:../../FreeRTOS/Source/tasks.c **** 		too. */
2388:../../FreeRTOS/Source/tasks.c **** 		if( xTimeToWake < xNextTaskUnblockTime )
 2945               	.LM260:
 2946 0ef6 2091 0000 		lds r18,xNextTaskUnblockTime
 2947 0efa 3091 0000 		lds r19,(xNextTaskUnblockTime)+1
 2948 0efe 8981      		ldd r24,Y+1
 2949 0f00 9A81      		ldd r25,Y+2
 2950 0f02 8217      		cp r24,r18
 2951 0f04 9307      		cpc r25,r19
 2952 0f06 00F4      		brsh .L127
2389:../../FreeRTOS/Source/tasks.c **** 		{
2390:../../FreeRTOS/Source/tasks.c **** 			xNextTaskUnblockTime = xTimeToWake;
 2954               	.LM261:
 2955 0f08 8981      		ldd r24,Y+1
 2956 0f0a 9A81      		ldd r25,Y+2
 2957 0f0c 9093 0000 		sts (xNextTaskUnblockTime)+1,r25
 2958 0f10 8093 0000 		sts xNextTaskUnblockTime,r24
 2959               	.L127:
 2960               	/* epilogue start */
2391:../../FreeRTOS/Source/tasks.c **** 		}
2392:../../FreeRTOS/Source/tasks.c **** 	}
2393:../../FreeRTOS/Source/tasks.c **** }
 2962               	.LM262:
 2963 0f14 0F90      		pop __tmp_reg__
 2964 0f16 0F90      		pop __tmp_reg__
 2965 0f18 CF91      		pop r28
 2966 0f1a DF91      		pop r29
 2967 0f1c 0895      		ret
 2969               	.Lscope26:
 2971               		.stabd	78,0,0
 2976               	prvAllocateTCBAndStack:
 2977               		.stabd	46,0,0
2394:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2395:../../FreeRTOS/Source/tasks.c **** 
2396:../../FreeRTOS/Source/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
2397:../../FreeRTOS/Source/tasks.c **** {
 2979               	.LM263:
 2980               	.LFBB27:
 2981 0f1e DF93      		push r29
 2982 0f20 CF93      		push r28
 2983 0f22 CDB7      		in r28,__SP_L__
 2984 0f24 DEB7      		in r29,__SP_H__
 2985 0f26 2897      		sbiw r28,8
 2986 0f28 0FB6      		in __tmp_reg__,__SREG__
 2987 0f2a F894      		cli
 2988 0f2c DEBF      		out __SP_H__,r29
 2989 0f2e 0FBE      		out __SREG__,__tmp_reg__
 2990 0f30 CDBF      		out __SP_L__,r28
 2991               	/* prologue: function */
 2992               	/* frame size = 8 */
 2993 0f32 9C83      		std Y+4,r25
 2994 0f34 8B83      		std Y+3,r24
 2995 0f36 7E83      		std Y+6,r23
 2996 0f38 6D83      		std Y+5,r22
2398:../../FreeRTOS/Source/tasks.c **** tskTCB *pxNewTCB;
2399:../../FreeRTOS/Source/tasks.c **** 
2400:../../FreeRTOS/Source/tasks.c **** 	/* Allocate space for the TCB.  Where the memory comes from depends on
2401:../../FreeRTOS/Source/tasks.c **** 	the implementation of the port malloc function. */
2402:../../FreeRTOS/Source/tasks.c **** 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 2998               	.LM264:
 2999 0f3a 8AE2      		ldi r24,lo8(42)
 3000 0f3c 90E0      		ldi r25,hi8(42)
 3001 0f3e 0E94 0000 		call pvPortMalloc
 3002 0f42 9A83      		std Y+2,r25
 3003 0f44 8983      		std Y+1,r24
2403:../../FreeRTOS/Source/tasks.c **** 
2404:../../FreeRTOS/Source/tasks.c **** 	if( pxNewTCB != NULL )
 3005               	.LM265:
 3006 0f46 8981      		ldd r24,Y+1
 3007 0f48 9A81      		ldd r25,Y+2
 3008 0f4a 0097      		sbiw r24,0
 3009 0f4c 01F0      		breq .L129
2405:../../FreeRTOS/Source/tasks.c **** 	{
2406:../../FreeRTOS/Source/tasks.c **** 		/* Allocate space for the stack used by the task being created.
2407:../../FreeRTOS/Source/tasks.c **** 		The base of the stack memory stored in the TCB so the task can
2408:../../FreeRTOS/Source/tasks.c **** 		be deleted later if required. */
2409:../../FreeRTOS/Source/tasks.c **** 		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * size
 3011               	.LM266:
 3012 0f4e 8D81      		ldd r24,Y+5
 3013 0f50 9E81      		ldd r25,Y+6
 3014 0f52 0097      		sbiw r24,0
 3015 0f54 01F4      		brne .L130
 3016 0f56 8B81      		ldd r24,Y+3
 3017 0f58 9C81      		ldd r25,Y+4
 3018 0f5a 0E94 0000 		call pvPortMalloc
 3019 0f5e 9887      		std Y+8,r25
 3020 0f60 8F83      		std Y+7,r24
 3021 0f62 00C0      		rjmp .L131
 3022               	.L130:
 3023 0f64 8D81      		ldd r24,Y+5
 3024 0f66 9E81      		ldd r25,Y+6
 3025 0f68 9887      		std Y+8,r25
 3026 0f6a 8F83      		std Y+7,r24
 3027               	.L131:
 3028 0f6c E981      		ldd r30,Y+1
 3029 0f6e FA81      		ldd r31,Y+2
 3030 0f70 8F81      		ldd r24,Y+7
 3031 0f72 9885      		ldd r25,Y+8
 3032 0f74 908F      		std Z+24,r25
 3033 0f76 878B      		std Z+23,r24
2410:../../FreeRTOS/Source/tasks.c **** 
2411:../../FreeRTOS/Source/tasks.c **** 		if( pxNewTCB->pxStack == NULL )
 3035               	.LM267:
 3036 0f78 E981      		ldd r30,Y+1
 3037 0f7a FA81      		ldd r31,Y+2
 3038 0f7c 8789      		ldd r24,Z+23
 3039 0f7e 908D      		ldd r25,Z+24
 3040 0f80 0097      		sbiw r24,0
 3041 0f82 01F4      		brne .L132
2412:../../FreeRTOS/Source/tasks.c **** 		{
2413:../../FreeRTOS/Source/tasks.c **** 			/* Could not allocate the stack.  Delete the allocated TCB. */
2414:../../FreeRTOS/Source/tasks.c **** 			vPortFree( pxNewTCB );
 3043               	.LM268:
 3044 0f84 8981      		ldd r24,Y+1
 3045 0f86 9A81      		ldd r25,Y+2
 3046 0f88 0E94 0000 		call vPortFree
2415:../../FreeRTOS/Source/tasks.c **** 			pxNewTCB = NULL;
 3048               	.LM269:
 3049 0f8c 1A82      		std Y+2,__zero_reg__
 3050 0f8e 1982      		std Y+1,__zero_reg__
 3051 0f90 00C0      		rjmp .L129
 3052               	.L132:
2416:../../FreeRTOS/Source/tasks.c **** 		}
2417:../../FreeRTOS/Source/tasks.c **** 		else
2418:../../FreeRTOS/Source/tasks.c **** 		{
2419:../../FreeRTOS/Source/tasks.c **** 			/* Just to help debugging. */
2420:../../FreeRTOS/Source/tasks.c **** 			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTA
 3054               	.LM270:
 3055 0f92 E981      		ldd r30,Y+1
 3056 0f94 FA81      		ldd r31,Y+2
 3057 0f96 8789      		ldd r24,Z+23
 3058 0f98 908D      		ldd r25,Z+24
 3059 0f9a 2B81      		ldd r18,Y+3
 3060 0f9c 3C81      		ldd r19,Y+4
 3061 0f9e 65EA      		ldi r22,lo8(165)
 3062 0fa0 70E0      		ldi r23,hi8(165)
 3063 0fa2 A901      		movw r20,r18
 3064 0fa4 0E94 0000 		call memset
 3065               	.L129:
2421:../../FreeRTOS/Source/tasks.c **** 		}
2422:../../FreeRTOS/Source/tasks.c **** 	}
2423:../../FreeRTOS/Source/tasks.c **** 
2424:../../FreeRTOS/Source/tasks.c **** 	return pxNewTCB;
 3067               	.LM271:
 3068 0fa8 8981      		ldd r24,Y+1
 3069 0faa 9A81      		ldd r25,Y+2
 3070               	/* epilogue start */
2425:../../FreeRTOS/Source/tasks.c **** }
 3072               	.LM272:
 3073 0fac 2896      		adiw r28,8
 3074 0fae 0FB6      		in __tmp_reg__,__SREG__
 3075 0fb0 F894      		cli
 3076 0fb2 DEBF      		out __SP_H__,r29
 3077 0fb4 0FBE      		out __SREG__,__tmp_reg__
 3078 0fb6 CDBF      		out __SP_L__,r28
 3079 0fb8 CF91      		pop r28
 3080 0fba DF91      		pop r29
 3081 0fbc 0895      		ret
 3086               	.Lscope27:
 3088               		.stabd	78,0,0
 3092               	usTaskCheckFreeStackSpace:
 3093               		.stabd	46,0,0
2426:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2427:../../FreeRTOS/Source/tasks.c **** 
2428:../../FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2429:../../FreeRTOS/Source/tasks.c **** 
2430:../../FreeRTOS/Source/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
2431:../../FreeRTOS/Source/tasks.c **** 	{
2432:../../FreeRTOS/Source/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2433:../../FreeRTOS/Source/tasks.c **** 	unsigned short usStackRemaining;
2434:../../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static char pcStatusString[ configMAX_TASK_NAME_LEN + 30 ];
2435:../../FreeRTOS/Source/tasks.c **** 
2436:../../FreeRTOS/Source/tasks.c **** 		/* Write the details of all the TCB's in pxList into the buffer. */
2437:../../FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2438:../../FreeRTOS/Source/tasks.c **** 		do
2439:../../FreeRTOS/Source/tasks.c **** 		{
2440:../../FreeRTOS/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2441:../../FreeRTOS/Source/tasks.c **** 			#if ( portSTACK_GROWTH > 0 )
2442:../../FreeRTOS/Source/tasks.c **** 			{
2443:../../FreeRTOS/Source/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
2444:../../FreeRTOS/Source/tasks.c **** 			}
2445:../../FreeRTOS/Source/tasks.c **** 			#else
2446:../../FreeRTOS/Source/tasks.c **** 			{
2447:../../FreeRTOS/Source/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
2448:../../FreeRTOS/Source/tasks.c **** 			}
2449:../../FreeRTOS/Source/tasks.c **** 			#endif
2450:../../FreeRTOS/Source/tasks.c **** 
2451:../../FreeRTOS/Source/tasks.c **** 			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, 
2452:../../FreeRTOS/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
2453:../../FreeRTOS/Source/tasks.c **** 
2454:../../FreeRTOS/Source/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
2455:../../FreeRTOS/Source/tasks.c **** 	}
2456:../../FreeRTOS/Source/tasks.c **** 
2457:../../FreeRTOS/Source/tasks.c **** #endif
2458:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2459:../../FreeRTOS/Source/tasks.c **** 
2460:../../FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
2461:../../FreeRTOS/Source/tasks.c **** 
2462:../../FreeRTOS/Source/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
2463:../../FreeRTOS/Source/tasks.c **** 	{
2464:../../FreeRTOS/Source/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2465:../../FreeRTOS/Source/tasks.c **** 	unsigned long ulStatsAsPercentage;
2466:../../FreeRTOS/Source/tasks.c **** 
2467:../../FreeRTOS/Source/tasks.c **** 		/* Write the run time stats of all the TCB's in pxList into the buffer. */
2468:../../FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2469:../../FreeRTOS/Source/tasks.c **** 		do
2470:../../FreeRTOS/Source/tasks.c **** 		{
2471:../../FreeRTOS/Source/tasks.c **** 			/* Get next TCB in from the list. */
2472:../../FreeRTOS/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2473:../../FreeRTOS/Source/tasks.c **** 
2474:../../FreeRTOS/Source/tasks.c **** 			/* Divide by zero check. */
2475:../../FreeRTOS/Source/tasks.c **** 			if( ulTotalRunTime > 0UL )
2476:../../FreeRTOS/Source/tasks.c **** 			{
2477:../../FreeRTOS/Source/tasks.c **** 				/* Has the task run at all? */
2478:../../FreeRTOS/Source/tasks.c **** 				if( pxNextTCB->ulRunTimeCounter == 0UL )
2479:../../FreeRTOS/Source/tasks.c **** 				{
2480:../../FreeRTOS/Source/tasks.c **** 					/* The task has used no CPU time at all. */
2481:../../FreeRTOS/Source/tasks.c **** 					sprintf( pcStatsString, ( char * ) "%s\t\t0\t\t0%%\r\n", pxNextTCB->pcTaskName );
2482:../../FreeRTOS/Source/tasks.c **** 				}
2483:../../FreeRTOS/Source/tasks.c **** 				else
2484:../../FreeRTOS/Source/tasks.c **** 				{
2485:../../FreeRTOS/Source/tasks.c **** 					/* What percentage of the total run time has the task used?
2486:../../FreeRTOS/Source/tasks.c **** 					This will always be rounded down to the nearest integer.
2487:../../FreeRTOS/Source/tasks.c **** 					ulTotalRunTime has already been divided by 100. */
2488:../../FreeRTOS/Source/tasks.c **** 					ulStatsAsPercentage = pxNextTCB->ulRunTimeCounter / ulTotalRunTime;
2489:../../FreeRTOS/Source/tasks.c **** 
2490:../../FreeRTOS/Source/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
2491:../../FreeRTOS/Source/tasks.c **** 					{
2492:../../FreeRTOS/Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2493:../../FreeRTOS/Source/tasks.c **** 						{
2494:../../FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t%lu%%\r\n", pxNextTCB->pcTaskName, pxNextTC
2495:../../FreeRTOS/Source/tasks.c **** 						}
2496:../../FreeRTOS/Source/tasks.c **** 						#else
2497:../../FreeRTOS/Source/tasks.c **** 						{
2498:../../FreeRTOS/Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
2499:../../FreeRTOS/Source/tasks.c **** 							printf() library can be used. */
2500:../../FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t%u%%\r\n", pxNextTCB->pcTaskName, ( unsigned
2501:../../FreeRTOS/Source/tasks.c **** 						}
2502:../../FreeRTOS/Source/tasks.c **** 						#endif
2503:../../FreeRTOS/Source/tasks.c **** 					}
2504:../../FreeRTOS/Source/tasks.c **** 					else
2505:../../FreeRTOS/Source/tasks.c **** 					{
2506:../../FreeRTOS/Source/tasks.c **** 						/* If the percentage is zero here then the task has
2507:../../FreeRTOS/Source/tasks.c **** 						consumed less than 1% of the total run time. */
2508:../../FreeRTOS/Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2509:../../FreeRTOS/Source/tasks.c **** 						{
2510:../../FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t<1%%\r\n", pxNextTCB->pcTaskName, pxNextTCB
2511:../../FreeRTOS/Source/tasks.c **** 						}
2512:../../FreeRTOS/Source/tasks.c **** 						#else
2513:../../FreeRTOS/Source/tasks.c **** 						{
2514:../../FreeRTOS/Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
2515:../../FreeRTOS/Source/tasks.c **** 							printf() library can be used. */
2516:../../FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t<1%%\r\n", pxNextTCB->pcTaskName, ( unsigned
2517:../../FreeRTOS/Source/tasks.c **** 						}
2518:../../FreeRTOS/Source/tasks.c **** 						#endif
2519:../../FreeRTOS/Source/tasks.c **** 					}
2520:../../FreeRTOS/Source/tasks.c **** 				}
2521:../../FreeRTOS/Source/tasks.c **** 
2522:../../FreeRTOS/Source/tasks.c **** 				strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatsString );
2523:../../FreeRTOS/Source/tasks.c **** 			}
2524:../../FreeRTOS/Source/tasks.c **** 
2525:../../FreeRTOS/Source/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
2526:../../FreeRTOS/Source/tasks.c **** 	}
2527:../../FreeRTOS/Source/tasks.c **** 
2528:../../FreeRTOS/Source/tasks.c **** #endif
2529:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2530:../../FreeRTOS/Source/tasks.c **** 
2531:../../FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
2532:../../FreeRTOS/Source/tasks.c **** 
2533:../../FreeRTOS/Source/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
2534:../../FreeRTOS/Source/tasks.c **** 	{
 3095               	.LM273:
 3096               	.LFBB28:
 3097 0fbe DF93      		push r29
 3098 0fc0 CF93      		push r28
 3099 0fc2 00D0      		rcall .
 3100 0fc4 0F92      		push __tmp_reg__
 3101 0fc6 CDB7      		in r28,__SP_L__
 3102 0fc8 DEB7      		in r29,__SP_H__
 3103               	/* prologue: function */
 3104               	/* frame size = 4 */
 3105 0fca 9A83      		std Y+2,r25
 3106 0fcc 8983      		std Y+1,r24
2535:../../FreeRTOS/Source/tasks.c **** 	register unsigned short usCount = 0U;
 3108               	.LM274:
 3109 0fce 1C82      		std Y+4,__zero_reg__
 3110 0fd0 1B82      		std Y+3,__zero_reg__
 3111 0fd2 00C0      		rjmp .L135
 3112               	.L136:
2536:../../FreeRTOS/Source/tasks.c **** 
2537:../../FreeRTOS/Source/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
2538:../../FreeRTOS/Source/tasks.c **** 		{
2539:../../FreeRTOS/Source/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
 3114               	.LM275:
 3115 0fd4 8981      		ldd r24,Y+1
 3116 0fd6 9A81      		ldd r25,Y+2
 3117 0fd8 0196      		adiw r24,1
 3118 0fda 9A83      		std Y+2,r25
 3119 0fdc 8983      		std Y+1,r24
2540:../../FreeRTOS/Source/tasks.c **** 			usCount++;
 3121               	.LM276:
 3122 0fde 8B81      		ldd r24,Y+3
 3123 0fe0 9C81      		ldd r25,Y+4
 3124 0fe2 0196      		adiw r24,1
 3125 0fe4 9C83      		std Y+4,r25
 3126 0fe6 8B83      		std Y+3,r24
 3127               	.L135:
2537:../../FreeRTOS/Source/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
 3129               	.LM277:
 3130 0fe8 E981      		ldd r30,Y+1
 3131 0fea FA81      		ldd r31,Y+2
 3132 0fec 8081      		ld r24,Z
 3133 0fee 853A      		cpi r24,lo8(-91)
 3134 0ff0 01F0      		breq .L136
2541:../../FreeRTOS/Source/tasks.c **** 		}
2542:../../FreeRTOS/Source/tasks.c **** 
2543:../../FreeRTOS/Source/tasks.c **** 		usCount /= sizeof( portSTACK_TYPE );
2544:../../FreeRTOS/Source/tasks.c **** 
2545:../../FreeRTOS/Source/tasks.c **** 		return usCount;
 3136               	.LM278:
 3137 0ff2 8B81      		ldd r24,Y+3
 3138 0ff4 9C81      		ldd r25,Y+4
 3139               	/* epilogue start */
2546:../../FreeRTOS/Source/tasks.c **** 	}
 3141               	.LM279:
 3142 0ff6 0F90      		pop __tmp_reg__
 3143 0ff8 0F90      		pop __tmp_reg__
 3144 0ffa 0F90      		pop __tmp_reg__
 3145 0ffc 0F90      		pop __tmp_reg__
 3146 0ffe CF91      		pop r28
 3147 1000 DF91      		pop r29
 3148 1002 0895      		ret
 3153               	.Lscope28:
 3155               		.stabd	78,0,0
 3158               	.global	uxTaskGetStackHighWaterMark
 3160               	uxTaskGetStackHighWaterMark:
 3161               		.stabd	46,0,0
2547:../../FreeRTOS/Source/tasks.c **** 
2548:../../FreeRTOS/Source/tasks.c **** #endif
2549:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2550:../../FreeRTOS/Source/tasks.c **** 
2551:../../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
2552:../../FreeRTOS/Source/tasks.c **** 
2553:../../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
2554:../../FreeRTOS/Source/tasks.c **** 	{
 3163               	.LM280:
 3164               	.LFBB29:
 3165 1004 DF93      		push r29
 3166 1006 CF93      		push r28
 3167 1008 CDB7      		in r28,__SP_L__
 3168 100a DEB7      		in r29,__SP_H__
 3169 100c 2997      		sbiw r28,9
 3170 100e 0FB6      		in __tmp_reg__,__SREG__
 3171 1010 F894      		cli
 3172 1012 DEBF      		out __SP_H__,r29
 3173 1014 0FBE      		out __SREG__,__tmp_reg__
 3174 1016 CDBF      		out __SP_L__,r28
 3175               	/* prologue: function */
 3176               	/* frame size = 9 */
 3177 1018 9F83      		std Y+7,r25
 3178 101a 8E83      		std Y+6,r24
2555:../../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
2556:../../FreeRTOS/Source/tasks.c **** 	unsigned char *pcEndOfStack;
2557:../../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
2558:../../FreeRTOS/Source/tasks.c **** 
2559:../../FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
 3180               	.LM281:
 3181 101c 8E81      		ldd r24,Y+6
 3182 101e 9F81      		ldd r25,Y+7
 3183 1020 0097      		sbiw r24,0
 3184 1022 01F4      		brne .L139
 3185 1024 8091 0000 		lds r24,pxCurrentTCB
 3186 1028 9091 0000 		lds r25,(pxCurrentTCB)+1
 3187 102c 9987      		std Y+9,r25
 3188 102e 8887      		std Y+8,r24
 3189 1030 00C0      		rjmp .L140
 3190               	.L139:
 3191 1032 8E81      		ldd r24,Y+6
 3192 1034 9F81      		ldd r25,Y+7
 3193 1036 9987      		std Y+9,r25
 3194 1038 8887      		std Y+8,r24
 3195               	.L140:
 3196 103a 8885      		ldd r24,Y+8
 3197 103c 9985      		ldd r25,Y+9
 3198 103e 9D83      		std Y+5,r25
 3199 1040 8C83      		std Y+4,r24
2560:../../FreeRTOS/Source/tasks.c **** 
2561:../../FreeRTOS/Source/tasks.c **** 		#if portSTACK_GROWTH < 0
2562:../../FreeRTOS/Source/tasks.c **** 		{
2563:../../FreeRTOS/Source/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
 3201               	.LM282:
 3202 1042 EC81      		ldd r30,Y+4
 3203 1044 FD81      		ldd r31,Y+5
 3204 1046 8789      		ldd r24,Z+23
 3205 1048 908D      		ldd r25,Z+24
 3206 104a 9B83      		std Y+3,r25
 3207 104c 8A83      		std Y+2,r24
2564:../../FreeRTOS/Source/tasks.c **** 		}
2565:../../FreeRTOS/Source/tasks.c **** 		#else
2566:../../FreeRTOS/Source/tasks.c **** 		{
2567:../../FreeRTOS/Source/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
2568:../../FreeRTOS/Source/tasks.c **** 		}
2569:../../FreeRTOS/Source/tasks.c **** 		#endif
2570:../../FreeRTOS/Source/tasks.c **** 
2571:../../FreeRTOS/Source/tasks.c **** 		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
 3209               	.LM283:
 3210 104e 8A81      		ldd r24,Y+2
 3211 1050 9B81      		ldd r25,Y+3
 3212 1052 0E94 0000 		call usTaskCheckFreeStackSpace
 3213 1056 8983      		std Y+1,r24
2572:../../FreeRTOS/Source/tasks.c **** 
2573:../../FreeRTOS/Source/tasks.c **** 		return uxReturn;
 3215               	.LM284:
 3216 1058 8981      		ldd r24,Y+1
 3217               	/* epilogue start */
2574:../../FreeRTOS/Source/tasks.c **** 	}
 3219               	.LM285:
 3220 105a 2996      		adiw r28,9
 3221 105c 0FB6      		in __tmp_reg__,__SREG__
 3222 105e F894      		cli
 3223 1060 DEBF      		out __SP_H__,r29
 3224 1062 0FBE      		out __SREG__,__tmp_reg__
 3225 1064 CDBF      		out __SP_L__,r28
 3226 1066 CF91      		pop r28
 3227 1068 DF91      		pop r29
 3228 106a 0895      		ret
 3235               	.Lscope29:
 3237               		.stabd	78,0,0
 3239               	.global	xTaskGetCurrentTaskHandle
 3241               	xTaskGetCurrentTaskHandle:
 3242               		.stabd	46,0,0
2575:../../FreeRTOS/Source/tasks.c **** 
2576:../../FreeRTOS/Source/tasks.c **** #endif
2577:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2578:../../FreeRTOS/Source/tasks.c **** 
2579:../../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
2580:../../FreeRTOS/Source/tasks.c **** 
2581:../../FreeRTOS/Source/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB )
2582:../../FreeRTOS/Source/tasks.c **** 	{
2583:../../FreeRTOS/Source/tasks.c **** 		/* This call is required specifically for the TriCore port.  It must be
2584:../../FreeRTOS/Source/tasks.c **** 		above the vPortFree() calls.  The call is also used by ports/demos that
2585:../../FreeRTOS/Source/tasks.c **** 		want to allocate and clean RAM statically. */
2586:../../FreeRTOS/Source/tasks.c **** 		portCLEAN_UP_TCB( pxTCB );
2587:../../FreeRTOS/Source/tasks.c **** 
2588:../../FreeRTOS/Source/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up to
2589:../../FreeRTOS/Source/tasks.c **** 		the task to free any memory allocated at the application level. */
2590:../../FreeRTOS/Source/tasks.c **** 		vPortFreeAligned( pxTCB->pxStack );
2591:../../FreeRTOS/Source/tasks.c **** 		vPortFree( pxTCB );
2592:../../FreeRTOS/Source/tasks.c **** 	}
2593:../../FreeRTOS/Source/tasks.c **** 
2594:../../FreeRTOS/Source/tasks.c **** #endif
2595:../../FreeRTOS/Source/tasks.c **** 
2596:../../FreeRTOS/Source/tasks.c **** 
2597:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2598:../../FreeRTOS/Source/tasks.c **** 
2599:../../FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
2600:../../FreeRTOS/Source/tasks.c **** 
2601:../../FreeRTOS/Source/tasks.c **** 	xTaskHandle xTaskGetCurrentTaskHandle( void )
2602:../../FreeRTOS/Source/tasks.c **** 	{
 3244               	.LM286:
 3245               	.LFBB30:
 3246 106c DF93      		push r29
 3247 106e CF93      		push r28
 3248 1070 0F92      		push __tmp_reg__
 3249 1072 0F92      		push __tmp_reg__
 3250 1074 CDB7      		in r28,__SP_L__
 3251 1076 DEB7      		in r29,__SP_H__
 3252               	/* prologue: function */
 3253               	/* frame size = 2 */
2603:../../FreeRTOS/Source/tasks.c **** 	xTaskHandle xReturn;
2604:../../FreeRTOS/Source/tasks.c **** 
2605:../../FreeRTOS/Source/tasks.c **** 		/* A critical section is not required as this is not called from
2606:../../FreeRTOS/Source/tasks.c **** 		an interrupt and the current TCB will always be the same for any
2607:../../FreeRTOS/Source/tasks.c **** 		individual execution thread. */
2608:../../FreeRTOS/Source/tasks.c **** 		xReturn = pxCurrentTCB;
 3255               	.LM287:
 3256 1078 8091 0000 		lds r24,pxCurrentTCB
 3257 107c 9091 0000 		lds r25,(pxCurrentTCB)+1
 3258 1080 9A83      		std Y+2,r25
 3259 1082 8983      		std Y+1,r24
2609:../../FreeRTOS/Source/tasks.c **** 
2610:../../FreeRTOS/Source/tasks.c **** 		return xReturn;
 3261               	.LM288:
 3262 1084 8981      		ldd r24,Y+1
 3263 1086 9A81      		ldd r25,Y+2
 3264               	/* epilogue start */
2611:../../FreeRTOS/Source/tasks.c **** 	}
 3266               	.LM289:
 3267 1088 0F90      		pop __tmp_reg__
 3268 108a 0F90      		pop __tmp_reg__
 3269 108c CF91      		pop r28
 3270 108e DF91      		pop r29
 3271 1090 0895      		ret
 3276               	.Lscope30:
 3278               		.stabd	78,0,0
 3281               	.global	vTaskPriorityInherit
 3283               	vTaskPriorityInherit:
 3284               		.stabd	46,0,0
2612:../../FreeRTOS/Source/tasks.c **** 
2613:../../FreeRTOS/Source/tasks.c **** #endif
2614:../../FreeRTOS/Source/tasks.c **** 
2615:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2616:../../FreeRTOS/Source/tasks.c **** 
2617:../../FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
2618:../../FreeRTOS/Source/tasks.c **** 
2619:../../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xTaskGetSchedulerState( void )
2620:../../FreeRTOS/Source/tasks.c **** 	{
2621:../../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xReturn;
2622:../../FreeRTOS/Source/tasks.c **** 
2623:../../FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
2624:../../FreeRTOS/Source/tasks.c **** 		{
2625:../../FreeRTOS/Source/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
2626:../../FreeRTOS/Source/tasks.c **** 		}
2627:../../FreeRTOS/Source/tasks.c **** 		else
2628:../../FreeRTOS/Source/tasks.c **** 		{
2629:../../FreeRTOS/Source/tasks.c **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
2630:../../FreeRTOS/Source/tasks.c **** 			{
2631:../../FreeRTOS/Source/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
2632:../../FreeRTOS/Source/tasks.c **** 			}
2633:../../FreeRTOS/Source/tasks.c **** 			else
2634:../../FreeRTOS/Source/tasks.c **** 			{
2635:../../FreeRTOS/Source/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
2636:../../FreeRTOS/Source/tasks.c **** 			}
2637:../../FreeRTOS/Source/tasks.c **** 		}
2638:../../FreeRTOS/Source/tasks.c **** 
2639:../../FreeRTOS/Source/tasks.c **** 		return xReturn;
2640:../../FreeRTOS/Source/tasks.c **** 	}
2641:../../FreeRTOS/Source/tasks.c **** 
2642:../../FreeRTOS/Source/tasks.c **** #endif
2643:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2644:../../FreeRTOS/Source/tasks.c **** 
2645:../../FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
2646:../../FreeRTOS/Source/tasks.c **** 
2647:../../FreeRTOS/Source/tasks.c **** 	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
2648:../../FreeRTOS/Source/tasks.c **** 	{
 3286               	.LM290:
 3287               	.LFBB31:
 3288 1092 DF93      		push r29
 3289 1094 CF93      		push r28
 3290 1096 00D0      		rcall .
 3291 1098 0F92      		push __tmp_reg__
 3292 109a CDB7      		in r28,__SP_L__
 3293 109c DEB7      		in r29,__SP_H__
 3294               	/* prologue: function */
 3295               	/* frame size = 4 */
 3296 109e 9C83      		std Y+4,r25
 3297 10a0 8B83      		std Y+3,r24
2649:../../FreeRTOS/Source/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 3299               	.LM291:
 3300 10a2 8B81      		ldd r24,Y+3
 3301 10a4 9C81      		ldd r25,Y+4
 3302 10a6 9A83      		std Y+2,r25
 3303 10a8 8983      		std Y+1,r24
2650:../../FreeRTOS/Source/tasks.c **** 
2651:../../FreeRTOS/Source/tasks.c **** 		/* If the mutex was given back by an interrupt while the queue was
2652:../../FreeRTOS/Source/tasks.c **** 		locked then the mutex holder might now be NULL. */
2653:../../FreeRTOS/Source/tasks.c **** 		if( pxMutexHolder != NULL )
 3305               	.LM292:
 3306 10aa 8B81      		ldd r24,Y+3
 3307 10ac 9C81      		ldd r25,Y+4
 3308 10ae 0097      		sbiw r24,0
 3309 10b0 01F4      		brne .+2
 3310 10b2 00C0      		rjmp .L148
2654:../../FreeRTOS/Source/tasks.c **** 		{
2655:../../FreeRTOS/Source/tasks.c **** 			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 3312               	.LM293:
 3313 10b4 E981      		ldd r30,Y+1
 3314 10b6 FA81      		ldd r31,Y+2
 3315 10b8 9689      		ldd r25,Z+22
 3316 10ba E091 0000 		lds r30,pxCurrentTCB
 3317 10be F091 0000 		lds r31,(pxCurrentTCB)+1
 3318 10c2 8689      		ldd r24,Z+22
 3319 10c4 9817      		cp r25,r24
 3320 10c6 00F0      		brlo .+2
 3321 10c8 00C0      		rjmp .L148
2656:../../FreeRTOS/Source/tasks.c **** 			{
2657:../../FreeRTOS/Source/tasks.c **** 				/* Adjust the mutex holder state to account for its new priority. */
2658:../../FreeRTOS/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) px
 3323               	.LM294:
 3324 10ca E091 0000 		lds r30,pxCurrentTCB
 3325 10ce F091 0000 		lds r31,(pxCurrentTCB)+1
 3326 10d2 8689      		ldd r24,Z+22
 3327 10d4 282F      		mov r18,r24
 3328 10d6 30E0      		ldi r19,lo8(0)
 3329 10d8 84E0      		ldi r24,lo8(4)
 3330 10da 90E0      		ldi r25,hi8(4)
 3331 10dc 821B      		sub r24,r18
 3332 10de 930B      		sbc r25,r19
 3333 10e0 E981      		ldd r30,Y+1
 3334 10e2 FA81      		ldd r31,Y+2
 3335 10e4 9587      		std Z+13,r25
 3336 10e6 8487      		std Z+12,r24
2659:../../FreeRTOS/Source/tasks.c **** 
2660:../../FreeRTOS/Source/tasks.c **** 				/* If the task being modified is in the ready state it will need to
2661:../../FreeRTOS/Source/tasks.c **** 				be moved into a new list. */
2662:../../FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericLis
 3338               	.LM295:
 3339 10e8 E981      		ldd r30,Y+1
 3340 10ea FA81      		ldd r31,Y+2
 3341 10ec 4285      		ldd r20,Z+10
 3342 10ee 5385      		ldd r21,Z+11
 3343 10f0 E981      		ldd r30,Y+1
 3344 10f2 FA81      		ldd r31,Y+2
 3345 10f4 8689      		ldd r24,Z+22
 3346 10f6 282F      		mov r18,r24
 3347 10f8 30E0      		ldi r19,lo8(0)
 3348 10fa C901      		movw r24,r18
 3349 10fc 880F      		lsl r24
 3350 10fe 991F      		rol r25
 3351 1100 880F      		lsl r24
 3352 1102 991F      		rol r25
 3353 1104 880F      		lsl r24
 3354 1106 991F      		rol r25
 3355 1108 820F      		add r24,r18
 3356 110a 931F      		adc r25,r19
 3357 110c 8050      		subi r24,lo8(-(pxReadyTasksLists))
 3358 110e 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 3359 1110 4817      		cp r20,r24
 3360 1112 5907      		cpc r21,r25
 3361 1114 01F4      		brne .L146
2663:../../FreeRTOS/Source/tasks.c **** 				{
2664:../../FreeRTOS/Source/tasks.c **** 					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
 3363               	.LM296:
 3364 1116 8981      		ldd r24,Y+1
 3365 1118 9A81      		ldd r25,Y+2
 3366 111a 0296      		adiw r24,2
 3367 111c 0E94 0000 		call uxListRemove
2665:../../FreeRTOS/Source/tasks.c **** 					{
2666:../../FreeRTOS/Source/tasks.c **** 						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
2667:../../FreeRTOS/Source/tasks.c **** 					}
2668:../../FreeRTOS/Source/tasks.c **** 
2669:../../FreeRTOS/Source/tasks.c **** 					/* Inherit the priority before being moved into the new list. */
2670:../../FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 3369               	.LM297:
 3370 1120 E091 0000 		lds r30,pxCurrentTCB
 3371 1124 F091 0000 		lds r31,(pxCurrentTCB)+1
 3372 1128 8689      		ldd r24,Z+22
 3373 112a E981      		ldd r30,Y+1
 3374 112c FA81      		ldd r31,Y+2
 3375 112e 868B      		std Z+22,r24
2671:../../FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 3377               	.LM298:
 3378 1130 E981      		ldd r30,Y+1
 3379 1132 FA81      		ldd r31,Y+2
 3380 1134 9689      		ldd r25,Z+22
 3381 1136 8091 0000 		lds r24,uxTopReadyPriority
 3382 113a 8917      		cp r24,r25
 3383 113c 00F4      		brsh .L147
 3384 113e E981      		ldd r30,Y+1
 3385 1140 FA81      		ldd r31,Y+2
 3386 1142 8689      		ldd r24,Z+22
 3387 1144 8093 0000 		sts uxTopReadyPriority,r24
 3388               	.L147:
 3389 1148 E981      		ldd r30,Y+1
 3390 114a FA81      		ldd r31,Y+2
 3391 114c 8689      		ldd r24,Z+22
 3392 114e 282F      		mov r18,r24
 3393 1150 30E0      		ldi r19,lo8(0)
 3394 1152 C901      		movw r24,r18
 3395 1154 880F      		lsl r24
 3396 1156 991F      		rol r25
 3397 1158 880F      		lsl r24
 3398 115a 991F      		rol r25
 3399 115c 880F      		lsl r24
 3400 115e 991F      		rol r25
 3401 1160 820F      		add r24,r18
 3402 1162 931F      		adc r25,r19
 3403 1164 AC01      		movw r20,r24
 3404 1166 4050      		subi r20,lo8(-(pxReadyTasksLists))
 3405 1168 5040      		sbci r21,hi8(-(pxReadyTasksLists))
 3406 116a 8981      		ldd r24,Y+1
 3407 116c 9A81      		ldd r25,Y+2
 3408 116e 9C01      		movw r18,r24
 3409 1170 2E5F      		subi r18,lo8(-(2))
 3410 1172 3F4F      		sbci r19,hi8(-(2))
 3411 1174 CA01      		movw r24,r20
 3412 1176 B901      		movw r22,r18
 3413 1178 0E94 0000 		call vListInsertEnd
 3414 117c 00C0      		rjmp .L148
 3415               	.L146:
2672:../../FreeRTOS/Source/tasks.c **** 				}
2673:../../FreeRTOS/Source/tasks.c **** 				else
2674:../../FreeRTOS/Source/tasks.c **** 				{
2675:../../FreeRTOS/Source/tasks.c **** 					/* Just inherit the priority. */
2676:../../FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 3417               	.LM299:
 3418 117e E091 0000 		lds r30,pxCurrentTCB
 3419 1182 F091 0000 		lds r31,(pxCurrentTCB)+1
 3420 1186 8689      		ldd r24,Z+22
 3421 1188 E981      		ldd r30,Y+1
 3422 118a FA81      		ldd r31,Y+2
 3423 118c 868B      		std Z+22,r24
 3424               	.L148:
 3425               	/* epilogue start */
2677:../../FreeRTOS/Source/tasks.c **** 				}
2678:../../FreeRTOS/Source/tasks.c **** 
2679:../../FreeRTOS/Source/tasks.c **** 				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
2680:../../FreeRTOS/Source/tasks.c **** 			}
2681:../../FreeRTOS/Source/tasks.c **** 		}
2682:../../FreeRTOS/Source/tasks.c **** 	}
 3427               	.LM300:
 3428 118e 0F90      		pop __tmp_reg__
 3429 1190 0F90      		pop __tmp_reg__
 3430 1192 0F90      		pop __tmp_reg__
 3431 1194 0F90      		pop __tmp_reg__
 3432 1196 CF91      		pop r28
 3433 1198 DF91      		pop r29
 3434 119a 0895      		ret
 3439               	.Lscope31:
 3441               		.stabd	78,0,0
 3444               	.global	vTaskPriorityDisinherit
 3446               	vTaskPriorityDisinherit:
 3447               		.stabd	46,0,0
2683:../../FreeRTOS/Source/tasks.c **** 
2684:../../FreeRTOS/Source/tasks.c **** #endif
2685:../../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2686:../../FreeRTOS/Source/tasks.c **** 
2687:../../FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
2688:../../FreeRTOS/Source/tasks.c **** 
2689:../../FreeRTOS/Source/tasks.c **** 	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
2690:../../FreeRTOS/Source/tasks.c **** 	{
 3449               	.LM301:
 3450               	.LFBB32:
 3451 119c DF93      		push r29
 3452 119e CF93      		push r28
 3453 11a0 00D0      		rcall .
 3454 11a2 0F92      		push __tmp_reg__
 3455 11a4 CDB7      		in r28,__SP_L__
 3456 11a6 DEB7      		in r29,__SP_H__
 3457               	/* prologue: function */
 3458               	/* frame size = 4 */
 3459 11a8 9C83      		std Y+4,r25
 3460 11aa 8B83      		std Y+3,r24
2691:../../FreeRTOS/Source/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 3462               	.LM302:
 3463 11ac 8B81      		ldd r24,Y+3
 3464 11ae 9C81      		ldd r25,Y+4
 3465 11b0 9A83      		std Y+2,r25
 3466 11b2 8983      		std Y+1,r24
2692:../../FreeRTOS/Source/tasks.c **** 
2693:../../FreeRTOS/Source/tasks.c **** 		if( pxMutexHolder != NULL )
 3468               	.LM303:
 3469 11b4 8B81      		ldd r24,Y+3
 3470 11b6 9C81      		ldd r25,Y+4
 3471 11b8 0097      		sbiw r24,0
 3472 11ba 01F4      		brne .+2
 3473 11bc 00C0      		rjmp .L152
2694:../../FreeRTOS/Source/tasks.c **** 		{
2695:../../FreeRTOS/Source/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 3475               	.LM304:
 3476 11be E981      		ldd r30,Y+1
 3477 11c0 FA81      		ldd r31,Y+2
 3478 11c2 9689      		ldd r25,Z+22
 3479 11c4 E981      		ldd r30,Y+1
 3480 11c6 FA81      		ldd r31,Y+2
 3481 11c8 81A5      		ldd r24,Z+41
 3482 11ca 9817      		cp r25,r24
 3483 11cc 01F4      		brne .+2
 3484 11ce 00C0      		rjmp .L152
2696:../../FreeRTOS/Source/tasks.c **** 			{
2697:../../FreeRTOS/Source/tasks.c **** 				/* We must be the running task to be able to give the mutex back.
2698:../../FreeRTOS/Source/tasks.c **** 				Remove ourselves from the ready list we currently appear in. */
2699:../../FreeRTOS/Source/tasks.c **** 				if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
 3486               	.LM305:
 3487 11d0 8981      		ldd r24,Y+1
 3488 11d2 9A81      		ldd r25,Y+2
 3489 11d4 0296      		adiw r24,2
 3490 11d6 0E94 0000 		call uxListRemove
2700:../../FreeRTOS/Source/tasks.c **** 				{
2701:../../FreeRTOS/Source/tasks.c **** 					taskRESET_READY_PRIORITY( pxTCB->uxPriority );
2702:../../FreeRTOS/Source/tasks.c **** 				}
2703:../../FreeRTOS/Source/tasks.c **** 
2704:../../FreeRTOS/Source/tasks.c **** 				/* Disinherit the priority before adding the task into the new
2705:../../FreeRTOS/Source/tasks.c **** 				ready list. */
2706:../../FreeRTOS/Source/tasks.c **** 				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
2707:../../FreeRTOS/Source/tasks.c **** 				pxTCB->uxPriority = pxTCB->uxBasePriority;
 3492               	.LM306:
 3493 11da E981      		ldd r30,Y+1
 3494 11dc FA81      		ldd r31,Y+2
 3495 11de 81A5      		ldd r24,Z+41
 3496 11e0 E981      		ldd r30,Y+1
 3497 11e2 FA81      		ldd r31,Y+2
 3498 11e4 868B      		std Z+22,r24
2708:../../FreeRTOS/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) px
 3500               	.LM307:
 3501 11e6 E981      		ldd r30,Y+1
 3502 11e8 FA81      		ldd r31,Y+2
 3503 11ea 8689      		ldd r24,Z+22
 3504 11ec 282F      		mov r18,r24
 3505 11ee 30E0      		ldi r19,lo8(0)
 3506 11f0 84E0      		ldi r24,lo8(4)
 3507 11f2 90E0      		ldi r25,hi8(4)
 3508 11f4 821B      		sub r24,r18
 3509 11f6 930B      		sbc r25,r19
 3510 11f8 E981      		ldd r30,Y+1
 3511 11fa FA81      		ldd r31,Y+2
 3512 11fc 9587      		std Z+13,r25
 3513 11fe 8487      		std Z+12,r24
2709:../../FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 3515               	.LM308:
 3516 1200 E981      		ldd r30,Y+1
 3517 1202 FA81      		ldd r31,Y+2
 3518 1204 9689      		ldd r25,Z+22
 3519 1206 8091 0000 		lds r24,uxTopReadyPriority
 3520 120a 8917      		cp r24,r25
 3521 120c 00F4      		brsh .L151
 3522 120e E981      		ldd r30,Y+1
 3523 1210 FA81      		ldd r31,Y+2
 3524 1212 8689      		ldd r24,Z+22
 3525 1214 8093 0000 		sts uxTopReadyPriority,r24
 3526               	.L151:
 3527 1218 E981      		ldd r30,Y+1
 3528 121a FA81      		ldd r31,Y+2
 3529 121c 8689      		ldd r24,Z+22
 3530 121e 282F      		mov r18,r24
 3531 1220 30E0      		ldi r19,lo8(0)
 3532 1222 C901      		movw r24,r18
 3533 1224 880F      		lsl r24
 3534 1226 991F      		rol r25
 3535 1228 880F      		lsl r24
 3536 122a 991F      		rol r25
 3537 122c 880F      		lsl r24
 3538 122e 991F      		rol r25
 3539 1230 820F      		add r24,r18
 3540 1232 931F      		adc r25,r19
 3541 1234 AC01      		movw r20,r24
 3542 1236 4050      		subi r20,lo8(-(pxReadyTasksLists))
 3543 1238 5040      		sbci r21,hi8(-(pxReadyTasksLists))
 3544 123a 8981      		ldd r24,Y+1
 3545 123c 9A81      		ldd r25,Y+2
 3546 123e 9C01      		movw r18,r24
 3547 1240 2E5F      		subi r18,lo8(-(2))
 3548 1242 3F4F      		sbci r19,hi8(-(2))
 3549 1244 CA01      		movw r24,r20
 3550 1246 B901      		movw r22,r18
 3551 1248 0E94 0000 		call vListInsertEnd
 3552               	.L152:
 3553               	/* epilogue start */
2710:../../FreeRTOS/Source/tasks.c **** 			}
2711:../../FreeRTOS/Source/tasks.c **** 		}
2712:../../FreeRTOS/Source/tasks.c **** 	}
 3555               	.LM309:
 3556 124c 0F90      		pop __tmp_reg__
 3557 124e 0F90      		pop __tmp_reg__
 3558 1250 0F90      		pop __tmp_reg__
 3559 1252 0F90      		pop __tmp_reg__
 3560 1254 CF91      		pop r28
 3561 1256 DF91      		pop r29
 3562 1258 0895      		ret
 3567               	.Lscope32:
 3569               		.stabd	78,0,0
 3570               		.lcomm pxReadyTasksLists,36
 3571               		.lcomm xDelayedTaskList1,9
 3572               		.lcomm xDelayedTaskList2,9
 3573               		.lcomm pxDelayedTaskList,2
 3574               		.lcomm pxOverflowDelayedTaskList,2
 3575               		.lcomm xPendingReadyList,9
 3576               		.lcomm xSuspendedTaskList,9
 3597               	.Letext0:
 3598               	.global __do_copy_data
 3599               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 tasks.c
     /tmp/ccEvrZjz.s:2      *ABS*:0000003f __SREG__
     /tmp/ccEvrZjz.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccEvrZjz.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccEvrZjz.s:5      *ABS*:00000034 __CCP__
     /tmp/ccEvrZjz.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccEvrZjz.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccEvrZjz.s:131    .bss:00000000 pxCurrentTCB
                             .bss:00000002 uxCurrentNumberOfTasks
     /tmp/ccEvrZjz.s:133    .bss:00000003 xTickCount
     /tmp/ccEvrZjz.s:134    .bss:00000005 uxTopUsedPriority
     /tmp/ccEvrZjz.s:135    .bss:00000006 uxTopReadyPriority
     /tmp/ccEvrZjz.s:136    .bss:00000007 xSchedulerRunning
     /tmp/ccEvrZjz.s:137    .bss:00000008 uxSchedulerSuspended
     /tmp/ccEvrZjz.s:138    .bss:00000009 uxMissedTicks
     /tmp/ccEvrZjz.s:139    .bss:0000000a xMissedYield
     /tmp/ccEvrZjz.s:140    .bss:0000000b xNumOfOverflows
     /tmp/ccEvrZjz.s:141    .bss:0000000c uxTaskNumber
     /tmp/ccEvrZjz.s:146    .data:00000000 xNextTaskUnblockTime
     /tmp/ccEvrZjz.s:160    .text:00000000 xTaskGenericCreate
     /tmp/ccEvrZjz.s:2976   .text:00000f1e prvAllocateTCBAndStack
     /tmp/ccEvrZjz.s:2646   .text:00000d4c prvInitialiseTCBVariables
     /tmp/ccEvrZjz.s:2773   .text:00000e02 prvInitialiseTaskLists
     /tmp/ccEvrZjz.s:142    .bss:0000000d pxReadyTasksLists
     /tmp/ccEvrZjz.s:476    .text:000001da vTaskDelayUntil
     /tmp/ccEvrZjz.s:1380   .text:00000670 vTaskSuspendAll
     /tmp/ccEvrZjz.s:2888   .text:00000e8a prvAddCurrentTaskToDelayedList
     /tmp/ccEvrZjz.s:1409   .text:00000688 xTaskResumeAll
     /tmp/ccEvrZjz.s:637    .text:000002c2 vTaskDelay
     /tmp/ccEvrZjz.s:723    .text:0000032c vTaskSuspend
     /tmp/ccEvrZjz.s:3575   .bss:00000050 xSuspendedTaskList
     /tmp/ccEvrZjz.s:1988   .text:000009ae vTaskSwitchContext
     /tmp/ccEvrZjz.s:883    .text:000003f8 xTaskIsTaskSuspended
     /tmp/ccEvrZjz.s:3574   .bss:00000047 xPendingReadyList
     /tmp/ccEvrZjz.s:967    .text:00000456 vTaskResume
     /tmp/ccEvrZjz.s:1113   .text:0000051e xTaskResumeFromISR
     /tmp/ccEvrZjz.s:1256   .text:000005ea vTaskStartScheduler
     /tmp/ccEvrZjz.s:2607   .text:00000d2a prvIdleTask
     /tmp/ccEvrZjz.s:1343   .text:00000658 vTaskEndScheduler
     /tmp/ccEvrZjz.s:1757   .text:00000806 vTaskIncrementTick
     /tmp/ccEvrZjz.s:1621   .text:0000079c xTaskGetTickCount
     /tmp/ccEvrZjz.s:1685   .text:000007cc xTaskGetTickCountFromISR
     /tmp/ccEvrZjz.s:1730   .text:000007f4 uxTaskGetNumberOfTasks
     /tmp/ccEvrZjz.s:3572   .bss:00000043 pxDelayedTaskList
     /tmp/ccEvrZjz.s:3573   .bss:00000045 pxOverflowDelayedTaskList
     /tmp/ccEvrZjz.s:2139   .text:00000ab4 vTaskPlaceOnEventList
     /tmp/ccEvrZjz.s:2234   .text:00000b44 xTaskRemoveFromEventList
     /tmp/ccEvrZjz.s:2376   .text:00000c14 vTaskSetTimeOutState
     /tmp/ccEvrZjz.s:2422   .text:00000c48 xTaskCheckForTimeOut
     /tmp/ccEvrZjz.s:2579   .text:00000d16 vTaskMissedYield
     /tmp/ccEvrZjz.s:2864   .text:00000e7c prvCheckTasksWaitingTermination
     /tmp/ccEvrZjz.s:3570   .bss:00000031 xDelayedTaskList1
     /tmp/ccEvrZjz.s:3571   .bss:0000003a xDelayedTaskList2
     /tmp/ccEvrZjz.s:3092   .text:00000fbe usTaskCheckFreeStackSpace
     /tmp/ccEvrZjz.s:3160   .text:00001004 uxTaskGetStackHighWaterMark
     /tmp/ccEvrZjz.s:3241   .text:0000106c xTaskGetCurrentTaskHandle
     /tmp/ccEvrZjz.s:3283   .text:00001092 vTaskPriorityInherit
     /tmp/ccEvrZjz.s:3446   .text:0000119c vTaskPriorityDisinherit

UNDEFINED SYMBOLS
pxPortInitialiseStack
vListInsertEnd
vPortYield
uxListRemove
xPortStartScheduler
vPortEndScheduler
vApplicationStackOverflowHook
vListInsert
strncpy
vListInitialiseItem
vListInitialise
pvPortMalloc
vPortFree
memset
__do_copy_data
__do_clear_bss
