
FirstProject.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000e  00800200  00001e40  00001ed4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001e40  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001895  0080020e  0080020e  00001ee2  2**0
                  ALLOC
  3 .stab         000008a0  00000000  00000000  00001ee4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000001ac  00000000  00000000  00002784  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  00002930  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000024ce  00000000  00000000  00002a70  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000a0d  00000000  00000000  00004f3e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000df6  00000000  00000000  0000594b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000804  00000000  00000000  00006744  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000f0f  00000000  00000000  00006f48  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002328  00000000  00000000  00007e57  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000a8  00000000  00000000  0000a17f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 72 00 	jmp	0xe4	; 0xe4 <__ctors_end>
       4:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
       8:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
       c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      10:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      14:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      18:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      1c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      20:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      24:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      28:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      2c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      30:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      34:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      38:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      3c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      40:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      44:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      48:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      4c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      50:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      54:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      58:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      5c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      60:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      64:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      68:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      6c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      70:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      74:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      78:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      7c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      80:	0c 94 7f 05 	jmp	0xafe	; 0xafe <__vector_32>
      84:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      88:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      8c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      90:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      94:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      98:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      9c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      a0:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      a4:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      a8:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      ac:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      b0:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      b4:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      b8:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      bc:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      c0:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      c4:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      c8:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      cc:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      d0:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      d4:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      d8:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      dc:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      e0:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	12 e0       	ldi	r17, 0x02	; 2
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	e0 e4       	ldi	r30, 0x40	; 64
      fc:	fe e1       	ldi	r31, 0x1E	; 30
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	ae 30       	cpi	r26, 0x0E	; 14
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>
     10e:	1b be       	out	0x3b, r1	; 59

00000110 <__do_clear_bss>:
     110:	1a e1       	ldi	r17, 0x1A	; 26
     112:	ae e0       	ldi	r26, 0x0E	; 14
     114:	b2 e0       	ldi	r27, 0x02	; 2
     116:	01 c0       	rjmp	.+2      	; 0x11a <.do_clear_bss_start>

00000118 <.do_clear_bss_loop>:
     118:	1d 92       	st	X+, r1

0000011a <.do_clear_bss_start>:
     11a:	a3 3a       	cpi	r26, 0xA3	; 163
     11c:	b1 07       	cpc	r27, r17
     11e:	e1 f7       	brne	.-8      	; 0x118 <.do_clear_bss_loop>
     120:	0e 94 c3 02 	call	0x586	; 0x586 <main>
     124:	0c 94 1e 0f 	jmp	0x1e3c	; 0x1e3c <_exit>

00000128 <__bad_interrupt>:
     128:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000012c <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     12c:	af 92       	push	r10
     12e:	bf 92       	push	r11
     130:	cf 92       	push	r12
     132:	df 92       	push	r13
     134:	ef 92       	push	r14
     136:	ff 92       	push	r15
     138:	0f 93       	push	r16
     13a:	1f 93       	push	r17
     13c:	cf 93       	push	r28
     13e:	df 93       	push	r29
     140:	6c 01       	movw	r12, r24
     142:	e6 2e       	mov	r14, r22
     144:	f4 2e       	mov	r15, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     146:	8a e1       	ldi	r24, 0x1A	; 26
     148:	90 e0       	ldi	r25, 0x00	; 0
     14a:	0e 94 0b 03 	call	0x616	; 0x616 <pvPortMalloc>
     14e:	8c 01       	movw	r16, r24
	if( pxCoRoutine )
     150:	00 97       	sbiw	r24, 0x00	; 0
     152:	09 f4       	brne	.+2      	; 0x156 <xCoRoutineCreate+0x2a>
     154:	62 c0       	rjmp	.+196    	; 0x21a <xCoRoutineCreate+0xee>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     156:	80 91 0e 02 	lds	r24, 0x020E
     15a:	90 91 0f 02 	lds	r25, 0x020F
     15e:	00 97       	sbiw	r24, 0x00	; 0
     160:	39 f5       	brne	.+78     	; 0x1b0 <xCoRoutineCreate+0x84>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     162:	10 93 0f 02 	sts	0x020F, r17
     166:	00 93 0e 02 	sts	0x020E, r16
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     16a:	c1 e1       	ldi	r28, 0x11	; 17
     16c:	d2 e0       	ldi	r29, 0x02	; 2
     16e:	ce 01       	movw	r24, r28
     170:	0e 94 43 03 	call	0x686	; 0x686 <vListInitialise>
     174:	ce 01       	movw	r24, r28
     176:	09 96       	adiw	r24, 0x09	; 9
     178:	0e 94 43 03 	call	0x686	; 0x686 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
     17c:	c3 e2       	ldi	r28, 0x23	; 35
     17e:	d2 e0       	ldi	r29, 0x02	; 2
     180:	ce 01       	movw	r24, r28
     182:	0e 94 43 03 	call	0x686	; 0x686 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
     186:	0f 2e       	mov	r0, r31
     188:	fc e2       	ldi	r31, 0x2C	; 44
     18a:	af 2e       	mov	r10, r31
     18c:	f2 e0       	ldi	r31, 0x02	; 2
     18e:	bf 2e       	mov	r11, r31
     190:	f0 2d       	mov	r31, r0
     192:	c5 01       	movw	r24, r10
     194:	0e 94 43 03 	call	0x686	; 0x686 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
     198:	85 e3       	ldi	r24, 0x35	; 53
     19a:	92 e0       	ldi	r25, 0x02	; 2
     19c:	0e 94 43 03 	call	0x686	; 0x686 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     1a0:	d0 93 3f 02 	sts	0x023F, r29
     1a4:	c0 93 3e 02 	sts	0x023E, r28
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     1a8:	b0 92 41 02 	sts	0x0241, r11
     1ac:	a0 92 40 02 	sts	0x0240, r10
     1b0:	ce 2d       	mov	r28, r14
     1b2:	e1 10       	cpse	r14, r1
     1b4:	c1 e0       	ldi	r28, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     1b6:	f8 01       	movw	r30, r16
     1b8:	11 8e       	std	Z+25, r1	; 0x19
     1ba:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     1bc:	c6 8b       	std	Z+22, r28	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     1be:	f7 8a       	std	Z+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     1c0:	c1 92       	st	Z+, r12
     1c2:	d1 92       	st	Z+, r13
     1c4:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     1c6:	cf 01       	movw	r24, r30
     1c8:	0e 94 51 03 	call	0x6a2	; 0x6a2 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     1cc:	c8 01       	movw	r24, r16
     1ce:	0c 96       	adiw	r24, 0x0c	; 12
     1d0:	0e 94 51 03 	call	0x6a2	; 0x6a2 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     1d4:	f8 01       	movw	r30, r16
     1d6:	11 87       	std	Z+9, r17	; 0x09
     1d8:	00 87       	std	Z+8, r16	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     1da:	13 8b       	std	Z+19, r17	; 0x13
     1dc:	02 8b       	std	Z+18, r16	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     1de:	84 e0       	ldi	r24, 0x04	; 4
     1e0:	90 e0       	ldi	r25, 0x00	; 0
     1e2:	8c 1b       	sub	r24, r28
     1e4:	91 09       	sbc	r25, r1
     1e6:	95 87       	std	Z+13, r25	; 0x0d
     1e8:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     1ea:	86 89       	ldd	r24, Z+22	; 0x16
     1ec:	90 91 10 02 	lds	r25, 0x0210
     1f0:	98 17       	cp	r25, r24
     1f2:	10 f4       	brcc	.+4      	; 0x1f8 <xCoRoutineCreate+0xcc>
     1f4:	80 93 10 02 	sts	0x0210, r24
     1f8:	90 e0       	ldi	r25, 0x00	; 0
     1fa:	9c 01       	movw	r18, r24
     1fc:	22 0f       	add	r18, r18
     1fe:	33 1f       	adc	r19, r19
     200:	22 0f       	add	r18, r18
     202:	33 1f       	adc	r19, r19
     204:	22 0f       	add	r18, r18
     206:	33 1f       	adc	r19, r19
     208:	82 0f       	add	r24, r18
     20a:	93 1f       	adc	r25, r19
     20c:	8f 5e       	subi	r24, 0xEF	; 239
     20e:	9d 4f       	sbci	r25, 0xFD	; 253
     210:	b7 01       	movw	r22, r14
     212:	0e 94 55 03 	call	0x6aa	; 0x6aa <vListInsertEnd>

		xReturn = pdPASS;
     216:	81 e0       	ldi	r24, 0x01	; 1
     218:	01 c0       	rjmp	.+2      	; 0x21c <xCoRoutineCreate+0xf0>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     21a:	8f ef       	ldi	r24, 0xFF	; 255
	}
	
	return xReturn;	
}
     21c:	df 91       	pop	r29
     21e:	cf 91       	pop	r28
     220:	1f 91       	pop	r17
     222:	0f 91       	pop	r16
     224:	ff 90       	pop	r15
     226:	ef 90       	pop	r14
     228:	df 90       	pop	r13
     22a:	cf 90       	pop	r12
     22c:	bf 90       	pop	r11
     22e:	af 90       	pop	r10
     230:	08 95       	ret

00000232 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     232:	0f 93       	push	r16
     234:	1f 93       	push	r17
     236:	cf 93       	push	r28
     238:	df 93       	push	r29
     23a:	8b 01       	movw	r16, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     23c:	c0 91 42 02 	lds	r28, 0x0242
     240:	d0 91 43 02 	lds	r29, 0x0243
     244:	c8 0f       	add	r28, r24
     246:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     248:	80 91 0e 02 	lds	r24, 0x020E
     24c:	90 91 0f 02 	lds	r25, 0x020F
     250:	02 96       	adiw	r24, 0x02	; 2
     252:	0e 94 bb 03 	call	0x776	; 0x776 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     256:	e0 91 0e 02 	lds	r30, 0x020E
     25a:	f0 91 0f 02 	lds	r31, 0x020F
     25e:	d3 83       	std	Z+3, r29	; 0x03
     260:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     262:	80 91 42 02 	lds	r24, 0x0242
     266:	90 91 43 02 	lds	r25, 0x0243
     26a:	c8 17       	cp	r28, r24
     26c:	d9 07       	cpc	r29, r25
     26e:	50 f4       	brcc	.+20     	; 0x284 <vCoRoutineAddToDelayedList+0x52>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     270:	bf 01       	movw	r22, r30
     272:	6e 5f       	subi	r22, 0xFE	; 254
     274:	7f 4f       	sbci	r23, 0xFF	; 255
     276:	80 91 40 02 	lds	r24, 0x0240
     27a:	90 91 41 02 	lds	r25, 0x0241
     27e:	0e 94 7e 03 	call	0x6fc	; 0x6fc <vListInsert>
     282:	09 c0       	rjmp	.+18     	; 0x296 <vCoRoutineAddToDelayedList+0x64>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     284:	bf 01       	movw	r22, r30
     286:	6e 5f       	subi	r22, 0xFE	; 254
     288:	7f 4f       	sbci	r23, 0xFF	; 255
     28a:	80 91 3e 02 	lds	r24, 0x023E
     28e:	90 91 3f 02 	lds	r25, 0x023F
     292:	0e 94 7e 03 	call	0x6fc	; 0x6fc <vListInsert>
	}

	if( pxEventList )
     296:	01 15       	cp	r16, r1
     298:	11 05       	cpc	r17, r1
     29a:	49 f0       	breq	.+18     	; 0x2ae <vCoRoutineAddToDelayedList+0x7c>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     29c:	60 91 0e 02 	lds	r22, 0x020E
     2a0:	70 91 0f 02 	lds	r23, 0x020F
     2a4:	64 5f       	subi	r22, 0xF4	; 244
     2a6:	7f 4f       	sbci	r23, 0xFF	; 255
     2a8:	c8 01       	movw	r24, r16
     2aa:	0e 94 7e 03 	call	0x6fc	; 0x6fc <vListInsert>
	}
}
     2ae:	df 91       	pop	r29
     2b0:	cf 91       	pop	r28
     2b2:	1f 91       	pop	r17
     2b4:	0f 91       	pop	r16
     2b6:	08 95       	ret

000002b8 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     2b8:	cf 92       	push	r12
     2ba:	df 92       	push	r13
     2bc:	ef 92       	push	r14
     2be:	ff 92       	push	r15
     2c0:	0f 93       	push	r16
     2c2:	1f 93       	push	r17
     2c4:	cf 93       	push	r28
     2c6:	df 93       	push	r29
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     2c8:	80 91 35 02 	lds	r24, 0x0235
     2cc:	88 23       	and	r24, r24
     2ce:	b9 f1       	breq	.+110    	; 0x33e <vCoRoutineSchedule+0x86>
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     2d0:	0f 2e       	mov	r0, r31
     2d2:	fa e3       	ldi	r31, 0x3A	; 58
     2d4:	ef 2e       	mov	r14, r31
     2d6:	f2 e0       	ldi	r31, 0x02	; 2
     2d8:	ff 2e       	mov	r15, r31
     2da:	f0 2d       	mov	r31, r0
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     2dc:	0f 2e       	mov	r0, r31
     2de:	f5 e3       	ldi	r31, 0x35	; 53
     2e0:	cf 2e       	mov	r12, r31
     2e2:	f2 e0       	ldi	r31, 0x02	; 2
     2e4:	df 2e       	mov	r13, r31
     2e6:	f0 2d       	mov	r31, r0
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     2e8:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     2ea:	d7 01       	movw	r26, r14
     2ec:	ed 91       	ld	r30, X+
     2ee:	fc 91       	ld	r31, X
     2f0:	c6 81       	ldd	r28, Z+6	; 0x06
     2f2:	d7 81       	ldd	r29, Z+7	; 0x07
			uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     2f4:	ce 01       	movw	r24, r28
     2f6:	0c 96       	adiw	r24, 0x0c	; 12
     2f8:	0e 94 bb 03 	call	0x776	; 0x776 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
     2fc:	78 94       	sei

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     2fe:	8e 01       	movw	r16, r28
     300:	0e 5f       	subi	r16, 0xFE	; 254
     302:	1f 4f       	sbci	r17, 0xFF	; 255
     304:	c8 01       	movw	r24, r16
     306:	0e 94 bb 03 	call	0x776	; 0x776 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     30a:	8e 89       	ldd	r24, Y+22	; 0x16
     30c:	90 91 10 02 	lds	r25, 0x0210
     310:	98 17       	cp	r25, r24
     312:	10 f4       	brcc	.+4      	; 0x318 <vCoRoutineSchedule+0x60>
     314:	80 93 10 02 	sts	0x0210, r24
     318:	90 e0       	ldi	r25, 0x00	; 0
     31a:	9c 01       	movw	r18, r24
     31c:	22 0f       	add	r18, r18
     31e:	33 1f       	adc	r19, r19
     320:	22 0f       	add	r18, r18
     322:	33 1f       	adc	r19, r19
     324:	22 0f       	add	r18, r18
     326:	33 1f       	adc	r19, r19
     328:	82 0f       	add	r24, r18
     32a:	93 1f       	adc	r25, r19
     32c:	8f 5e       	subi	r24, 0xEF	; 239
     32e:	9d 4f       	sbci	r25, 0xFD	; 253
     330:	b8 01       	movw	r22, r16
     332:	0e 94 55 03 	call	0x6aa	; 0x6aa <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     336:	f6 01       	movw	r30, r12
     338:	80 81       	ld	r24, Z
     33a:	88 23       	and	r24, r24
     33c:	a9 f6       	brne	.-86     	; 0x2e8 <vCoRoutineSchedule+0x30>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     33e:	0e 94 12 0b 	call	0x1624	; 0x1624 <xTaskGetTickCount>
     342:	20 91 44 02 	lds	r18, 0x0244
     346:	30 91 45 02 	lds	r19, 0x0245
     34a:	82 1b       	sub	r24, r18
     34c:	93 0b       	sbc	r25, r19
     34e:	90 93 47 02 	sts	0x0247, r25
     352:	80 93 46 02 	sts	0x0246, r24
     356:	74 c0       	rjmp	.+232    	; 0x440 <vCoRoutineSchedule+0x188>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     358:	20 91 42 02 	lds	r18, 0x0242
     35c:	30 91 43 02 	lds	r19, 0x0243
     360:	2f 5f       	subi	r18, 0xFF	; 255
     362:	3f 4f       	sbci	r19, 0xFF	; 255
     364:	30 93 43 02 	sts	0x0243, r19
     368:	20 93 42 02 	sts	0x0242, r18
		xPassedTicks--;
     36c:	01 97       	sbiw	r24, 0x01	; 1
     36e:	90 93 47 02 	sts	0x0247, r25
     372:	80 93 46 02 	sts	0x0246, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     376:	21 15       	cp	r18, r1
     378:	31 05       	cpc	r19, r1
     37a:	81 f4       	brne	.+32     	; 0x39c <vCoRoutineSchedule+0xe4>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     37c:	80 91 3e 02 	lds	r24, 0x023E
     380:	90 91 3f 02 	lds	r25, 0x023F
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     384:	20 91 40 02 	lds	r18, 0x0240
     388:	30 91 41 02 	lds	r19, 0x0241
     38c:	30 93 3f 02 	sts	0x023F, r19
     390:	20 93 3e 02 	sts	0x023E, r18
			pxOverflowDelayedCoRoutineList = pxTemp;
     394:	90 93 41 02 	sts	0x0241, r25
     398:	80 93 40 02 	sts	0x0240, r24
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     39c:	e0 91 3e 02 	lds	r30, 0x023E
     3a0:	f0 91 3f 02 	lds	r31, 0x023F
     3a4:	80 81       	ld	r24, Z
     3a6:	88 23       	and	r24, r24
     3a8:	09 f4       	brne	.+2      	; 0x3ac <vCoRoutineSchedule+0xf4>
     3aa:	4a c0       	rjmp	.+148    	; 0x440 <vCoRoutineSchedule+0x188>
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     3ac:	05 80       	ldd	r0, Z+5	; 0x05
     3ae:	f6 81       	ldd	r31, Z+6	; 0x06
     3b0:	e0 2d       	mov	r30, r0
     3b2:	c6 81       	ldd	r28, Z+6	; 0x06
     3b4:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     3b6:	2a 81       	ldd	r18, Y+2	; 0x02
     3b8:	3b 81       	ldd	r19, Y+3	; 0x03
     3ba:	80 91 42 02 	lds	r24, 0x0242
     3be:	90 91 43 02 	lds	r25, 0x0243
     3c2:	82 17       	cp	r24, r18
     3c4:	93 07       	cpc	r25, r19
     3c6:	78 f4       	brcc	.+30     	; 0x3e6 <vCoRoutineSchedule+0x12e>
     3c8:	3b c0       	rjmp	.+118    	; 0x440 <vCoRoutineSchedule+0x188>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     3ca:	05 80       	ldd	r0, Z+5	; 0x05
     3cc:	f6 81       	ldd	r31, Z+6	; 0x06
     3ce:	e0 2d       	mov	r30, r0
     3d0:	c6 81       	ldd	r28, Z+6	; 0x06
     3d2:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     3d4:	2a 81       	ldd	r18, Y+2	; 0x02
     3d6:	3b 81       	ldd	r19, Y+3	; 0x03
     3d8:	80 91 42 02 	lds	r24, 0x0242
     3dc:	90 91 43 02 	lds	r25, 0x0243
     3e0:	82 17       	cp	r24, r18
     3e2:	93 07       	cpc	r25, r19
     3e4:	68 f1       	brcs	.+90     	; 0x440 <vCoRoutineSchedule+0x188>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     3e6:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				uxListRemove( &( pxCRCB->xGenericListItem ) );											
     3e8:	8e 01       	movw	r16, r28
     3ea:	0e 5f       	subi	r16, 0xFE	; 254
     3ec:	1f 4f       	sbci	r17, 0xFF	; 255
     3ee:	c8 01       	movw	r24, r16
     3f0:	0e 94 bb 03 	call	0x776	; 0x776 <uxListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     3f4:	8c 89       	ldd	r24, Y+20	; 0x14
     3f6:	9d 89       	ldd	r25, Y+21	; 0x15
     3f8:	00 97       	sbiw	r24, 0x00	; 0
     3fa:	21 f0       	breq	.+8      	; 0x404 <vCoRoutineSchedule+0x14c>
				{															
					uxListRemove( &( pxCRCB->xEventListItem ) );											
     3fc:	ce 01       	movw	r24, r28
     3fe:	0c 96       	adiw	r24, 0x0c	; 12
     400:	0e 94 bb 03 	call	0x776	; 0x776 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     404:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     406:	8e 89       	ldd	r24, Y+22	; 0x16
     408:	90 91 10 02 	lds	r25, 0x0210
     40c:	98 17       	cp	r25, r24
     40e:	10 f4       	brcc	.+4      	; 0x414 <vCoRoutineSchedule+0x15c>
     410:	80 93 10 02 	sts	0x0210, r24
     414:	90 e0       	ldi	r25, 0x00	; 0
     416:	9c 01       	movw	r18, r24
     418:	22 0f       	add	r18, r18
     41a:	33 1f       	adc	r19, r19
     41c:	22 0f       	add	r18, r18
     41e:	33 1f       	adc	r19, r19
     420:	22 0f       	add	r18, r18
     422:	33 1f       	adc	r19, r19
     424:	82 0f       	add	r24, r18
     426:	93 1f       	adc	r25, r19
     428:	8f 5e       	subi	r24, 0xEF	; 239
     42a:	9d 4f       	sbci	r25, 0xFD	; 253
     42c:	b8 01       	movw	r22, r16
     42e:	0e 94 55 03 	call	0x6aa	; 0x6aa <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     432:	e0 91 3e 02 	lds	r30, 0x023E
     436:	f0 91 3f 02 	lds	r31, 0x023F
     43a:	80 81       	ld	r24, Z
     43c:	88 23       	and	r24, r24
     43e:	29 f6       	brne	.-118    	; 0x3ca <vCoRoutineSchedule+0x112>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     440:	80 91 46 02 	lds	r24, 0x0246
     444:	90 91 47 02 	lds	r25, 0x0247
     448:	00 97       	sbiw	r24, 0x00	; 0
     44a:	09 f0       	breq	.+2      	; 0x44e <vCoRoutineSchedule+0x196>
     44c:	85 cf       	rjmp	.-246    	; 0x358 <vCoRoutineSchedule+0xa0>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     44e:	80 91 42 02 	lds	r24, 0x0242
     452:	90 91 43 02 	lds	r25, 0x0243
     456:	90 93 45 02 	sts	0x0245, r25
     45a:	80 93 44 02 	sts	0x0244, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     45e:	20 91 10 02 	lds	r18, 0x0210
     462:	82 2f       	mov	r24, r18
     464:	90 e0       	ldi	r25, 0x00	; 0
     466:	fc 01       	movw	r30, r24
     468:	ee 0f       	add	r30, r30
     46a:	ff 1f       	adc	r31, r31
     46c:	ee 0f       	add	r30, r30
     46e:	ff 1f       	adc	r31, r31
     470:	ee 0f       	add	r30, r30
     472:	ff 1f       	adc	r31, r31
     474:	e8 0f       	add	r30, r24
     476:	f9 1f       	adc	r31, r25
     478:	ef 5e       	subi	r30, 0xEF	; 239
     47a:	fd 4f       	sbci	r31, 0xFD	; 253
     47c:	30 81       	ld	r19, Z
     47e:	33 23       	and	r19, r19
     480:	d9 f4       	brne	.+54     	; 0x4b8 <vCoRoutineSchedule+0x200>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     482:	22 23       	and	r18, r18
     484:	31 f4       	brne	.+12     	; 0x492 <vCoRoutineSchedule+0x1da>
     486:	47 c0       	rjmp	.+142    	; 0x516 <vCoRoutineSchedule+0x25e>
     488:	22 23       	and	r18, r18
     48a:	19 f4       	brne	.+6      	; 0x492 <vCoRoutineSchedule+0x1da>
     48c:	20 93 10 02 	sts	0x0210, r18
     490:	42 c0       	rjmp	.+132    	; 0x516 <vCoRoutineSchedule+0x25e>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     492:	21 50       	subi	r18, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     494:	82 2f       	mov	r24, r18
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	fc 01       	movw	r30, r24
     49a:	ee 0f       	add	r30, r30
     49c:	ff 1f       	adc	r31, r31
     49e:	ee 0f       	add	r30, r30
     4a0:	ff 1f       	adc	r31, r31
     4a2:	ee 0f       	add	r30, r30
     4a4:	ff 1f       	adc	r31, r31
     4a6:	e8 0f       	add	r30, r24
     4a8:	f9 1f       	adc	r31, r25
     4aa:	ef 5e       	subi	r30, 0xEF	; 239
     4ac:	fd 4f       	sbci	r31, 0xFD	; 253
     4ae:	30 81       	ld	r19, Z
     4b0:	33 23       	and	r19, r19
     4b2:	51 f3       	breq	.-44     	; 0x488 <vCoRoutineSchedule+0x1d0>
     4b4:	20 93 10 02 	sts	0x0210, r18
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     4b8:	fc 01       	movw	r30, r24
     4ba:	ee 0f       	add	r30, r30
     4bc:	ff 1f       	adc	r31, r31
     4be:	ee 0f       	add	r30, r30
     4c0:	ff 1f       	adc	r31, r31
     4c2:	ee 0f       	add	r30, r30
     4c4:	ff 1f       	adc	r31, r31
     4c6:	8e 0f       	add	r24, r30
     4c8:	9f 1f       	adc	r25, r31
     4ca:	fc 01       	movw	r30, r24
     4cc:	ef 5e       	subi	r30, 0xEF	; 239
     4ce:	fd 4f       	sbci	r31, 0xFD	; 253
     4d0:	a1 81       	ldd	r26, Z+1	; 0x01
     4d2:	b2 81       	ldd	r27, Z+2	; 0x02
     4d4:	12 96       	adiw	r26, 0x02	; 2
     4d6:	0d 90       	ld	r0, X+
     4d8:	bc 91       	ld	r27, X
     4da:	a0 2d       	mov	r26, r0
     4dc:	b2 83       	std	Z+2, r27	; 0x02
     4de:	a1 83       	std	Z+1, r26	; 0x01
     4e0:	cf 01       	movw	r24, r30
     4e2:	03 96       	adiw	r24, 0x03	; 3
     4e4:	a8 17       	cp	r26, r24
     4e6:	b9 07       	cpc	r27, r25
     4e8:	31 f4       	brne	.+12     	; 0x4f6 <vCoRoutineSchedule+0x23e>
     4ea:	12 96       	adiw	r26, 0x02	; 2
     4ec:	8d 91       	ld	r24, X+
     4ee:	9c 91       	ld	r25, X
     4f0:	13 97       	sbiw	r26, 0x03	; 3
     4f2:	92 83       	std	Z+2, r25	; 0x02
     4f4:	81 83       	std	Z+1, r24	; 0x01
     4f6:	01 80       	ldd	r0, Z+1	; 0x01
     4f8:	f2 81       	ldd	r31, Z+2	; 0x02
     4fa:	e0 2d       	mov	r30, r0
     4fc:	a6 81       	ldd	r26, Z+6	; 0x06
     4fe:	b7 81       	ldd	r27, Z+7	; 0x07
     500:	b0 93 0f 02 	sts	0x020F, r27
     504:	a0 93 0e 02 	sts	0x020E, r26

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     508:	ed 91       	ld	r30, X+
     50a:	fc 91       	ld	r31, X
     50c:	11 97       	sbiw	r26, 0x01	; 1
     50e:	cd 01       	movw	r24, r26
     510:	57 96       	adiw	r26, 0x17	; 23
     512:	6c 91       	ld	r22, X
     514:	19 95       	eicall

	return;
}
     516:	df 91       	pop	r29
     518:	cf 91       	pop	r28
     51a:	1f 91       	pop	r17
     51c:	0f 91       	pop	r16
     51e:	ff 90       	pop	r15
     520:	ef 90       	pop	r14
     522:	df 90       	pop	r13
     524:	cf 90       	pop	r12
     526:	08 95       	ret

00000528 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     528:	0f 93       	push	r16
     52a:	1f 93       	push	r17
     52c:	cf 93       	push	r28
     52e:	df 93       	push	r29
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     530:	dc 01       	movw	r26, r24
     532:	15 96       	adiw	r26, 0x05	; 5
     534:	ed 91       	ld	r30, X+
     536:	fc 91       	ld	r31, X
     538:	16 97       	sbiw	r26, 0x06	; 6
     53a:	06 81       	ldd	r16, Z+6	; 0x06
     53c:	17 81       	ldd	r17, Z+7	; 0x07
	uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     53e:	e8 01       	movw	r28, r16
     540:	2c 96       	adiw	r28, 0x0c	; 12
     542:	ce 01       	movw	r24, r28
     544:	0e 94 bb 03 	call	0x776	; 0x776 <uxListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     548:	85 e3       	ldi	r24, 0x35	; 53
     54a:	92 e0       	ldi	r25, 0x02	; 2
     54c:	be 01       	movw	r22, r28
     54e:	0e 94 55 03 	call	0x6aa	; 0x6aa <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     552:	e0 91 0e 02 	lds	r30, 0x020E
     556:	f0 91 0f 02 	lds	r31, 0x020F
	{
		xReturn = pdTRUE;
     55a:	81 e0       	ldi	r24, 0x01	; 1
     55c:	d8 01       	movw	r26, r16
     55e:	56 96       	adiw	r26, 0x16	; 22
     560:	2c 91       	ld	r18, X
     562:	56 97       	sbiw	r26, 0x16	; 22
     564:	96 89       	ldd	r25, Z+22	; 0x16
     566:	29 17       	cp	r18, r25
     568:	08 f4       	brcc	.+2      	; 0x56c <xCoRoutineRemoveFromEventList+0x44>
     56a:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     56c:	df 91       	pop	r29
     56e:	cf 91       	pop	r28
     570:	1f 91       	pop	r17
     572:	0f 91       	pop	r16
     574:	08 95       	ret

00000576 <vTaskFunction_1>:
}
/*-----------------------------------------------------------*/


void vTaskFunction_1(void *pvParameters)
{
     576:	fc 01       	movw	r30, r24
   uint8_t *val = (unsigned char *) pvParameters; 

   for (;;)  {
      PORTB = *val; 
     578:	80 81       	ld	r24, Z
     57a:	85 b9       	out	0x05, r24	; 5
     57c:	fd cf       	rjmp	.-6      	; 0x578 <vTaskFunction_1+0x2>

0000057e <vIO_init>:


void vIO_init(void) 
{
    //- set PortB as output
	DDRB = 0xFF; 
     57e:	8f ef       	ldi	r24, 0xFF	; 255
     580:	84 b9       	out	0x04, r24	; 4
    PORTB = 0xFF; 
     582:	85 b9       	out	0x05, r24	; 5
}
     584:	08 95       	ret

00000586 <main>:
void vIO_init(void); 

/*-----------------------------------------------------------*/

int main( void )
{  	
     586:	8f 92       	push	r8
     588:	9f 92       	push	r9
     58a:	af 92       	push	r10
     58c:	bf 92       	push	r11
     58e:	cf 92       	push	r12
     590:	df 92       	push	r13
     592:	ef 92       	push	r14
     594:	ff 92       	push	r15
     596:	0f 93       	push	r16
     598:	cf 93       	push	r28
     59a:	df 93       	push	r29
     59c:	0f 92       	push	r0
     59e:	0f 92       	push	r0
     5a0:	cd b7       	in	r28, 0x3d	; 61
     5a2:	de b7       	in	r29, 0x3e	; 62
    //- wimpy variable defs
	uint8_t val[2] = {0x3F, 0xFE}; 
     5a4:	8f e3       	ldi	r24, 0x3F	; 63
     5a6:	89 83       	std	Y+1, r24	; 0x01
     5a8:	8e ef       	ldi	r24, 0xFE	; 254
     5aa:	8a 83       	std	Y+2, r24	; 0x02
	//- avoid pesky warnings... 
	val0 = val + 0;  
	val1 = val + 1;  

    //- init IO with goodness
	vIO_init(); 
     5ac:	0e 94 bf 02 	call	0x57e	; 0x57e <vIO_init>


	//- Create a task
	xTaskCreate( (pdTASK_CODE) vTaskFunction_1, (signed char *) "T0", configMINIMAL_STACK_SIZE, 
     5b0:	0f 2e       	mov	r0, r31
     5b2:	fb eb       	ldi	r31, 0xBB	; 187
     5b4:	8f 2e       	mov	r8, r31
     5b6:	f2 e0       	ldi	r31, 0x02	; 2
     5b8:	9f 2e       	mov	r9, r31
     5ba:	f0 2d       	mov	r31, r0
     5bc:	c4 01       	movw	r24, r8
     5be:	60 e0       	ldi	r22, 0x00	; 0
     5c0:	72 e0       	ldi	r23, 0x02	; 2
     5c2:	45 e5       	ldi	r20, 0x55	; 85
     5c4:	50 e0       	ldi	r21, 0x00	; 0
     5c6:	9e 01       	movw	r18, r28
     5c8:	2e 5f       	subi	r18, 0xFE	; 254
     5ca:	3f 4f       	sbci	r19, 0xFF	; 255
     5cc:	01 e0       	ldi	r16, 0x01	; 1
     5ce:	ee 24       	eor	r14, r14
     5d0:	ff 24       	eor	r15, r15
     5d2:	cc 24       	eor	r12, r12
     5d4:	dd 24       	eor	r13, r13
     5d6:	aa 24       	eor	r10, r10
     5d8:	bb 24       	eor	r11, r11
     5da:	0e 94 20 09 	call	0x1240	; 0x1240 <xTaskGenericCreate>
	             (void *) val1, 1, NULL );

	//- Create a task
	xTaskCreate( (pdTASK_CODE) vTaskFunction_1, (signed char *) "xT0", configMINIMAL_STACK_SIZE, 
     5de:	c4 01       	movw	r24, r8
     5e0:	63 e0       	ldi	r22, 0x03	; 3
     5e2:	72 e0       	ldi	r23, 0x02	; 2
     5e4:	45 e5       	ldi	r20, 0x55	; 85
     5e6:	50 e0       	ldi	r21, 0x00	; 0
     5e8:	9e 01       	movw	r18, r28
     5ea:	2f 5f       	subi	r18, 0xFF	; 255
     5ec:	3f 4f       	sbci	r19, 0xFF	; 255
     5ee:	0e 94 20 09 	call	0x1240	; 0x1240 <xTaskGenericCreate>
	             (void *) val0, 1, NULL );

    //- kick off the scheduler
	vTaskStartScheduler();
     5f2:	0e 94 db 0a 	call	0x15b6	; 0x15b6 <vTaskStartScheduler>

	return 0;
}
     5f6:	80 e0       	ldi	r24, 0x00	; 0
     5f8:	90 e0       	ldi	r25, 0x00	; 0
     5fa:	0f 90       	pop	r0
     5fc:	0f 90       	pop	r0
     5fe:	df 91       	pop	r29
     600:	cf 91       	pop	r28
     602:	0f 91       	pop	r16
     604:	ff 90       	pop	r15
     606:	ef 90       	pop	r14
     608:	df 90       	pop	r13
     60a:	cf 90       	pop	r12
     60c:	bf 90       	pop	r11
     60e:	af 90       	pop	r10
     610:	9f 90       	pop	r9
     612:	8f 90       	pop	r8
     614:	08 95       	ret

00000616 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     616:	0f 93       	push	r16
     618:	1f 93       	push	r17
     61a:	cf 93       	push	r28
     61c:	df 93       	push	r29
     61e:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     620:	0e 94 0c 0b 	call	0x1618	; 0x1618 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     624:	00 91 48 02 	lds	r16, 0x0248
     628:	10 91 49 02 	lds	r17, 0x0249
     62c:	c0 0f       	add	r28, r16
     62e:	d1 1f       	adc	r29, r17
     630:	88 e1       	ldi	r24, 0x18	; 24
     632:	c0 30       	cpi	r28, 0x00	; 0
     634:	d8 07       	cpc	r29, r24
     636:	50 f4       	brcc	.+20     	; 0x64c <pvPortMalloc+0x36>
     638:	0c 17       	cp	r16, r28
     63a:	1d 07       	cpc	r17, r29
     63c:	50 f4       	brcc	.+20     	; 0x652 <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     63e:	06 5b       	subi	r16, 0xB6	; 182
     640:	1d 4f       	sbci	r17, 0xFD	; 253
			xNextFreeByte += xWantedSize;
     642:	d0 93 49 02 	sts	0x0249, r29
     646:	c0 93 48 02 	sts	0x0248, r28
     64a:	05 c0       	rjmp	.+10     	; 0x656 <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     64c:	00 e0       	ldi	r16, 0x00	; 0
     64e:	10 e0       	ldi	r17, 0x00	; 0
     650:	02 c0       	rjmp	.+4      	; 0x656 <pvPortMalloc+0x40>
     652:	00 e0       	ldi	r16, 0x00	; 0
     654:	10 e0       	ldi	r17, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;
		}
	}
	xTaskResumeAll();
     656:	0e 94 ea 0b 	call	0x17d4	; 0x17d4 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     65a:	80 2f       	mov	r24, r16
     65c:	91 2f       	mov	r25, r17
     65e:	df 91       	pop	r29
     660:	cf 91       	pop	r28
     662:	1f 91       	pop	r17
     664:	0f 91       	pop	r16
     666:	08 95       	ret

00000668 <vPortFree>:
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
     668:	08 95       	ret

0000066a <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     66a:	10 92 49 02 	sts	0x0249, r1
     66e:	10 92 48 02 	sts	0x0248, r1
}
     672:	08 95       	ret

00000674 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
     674:	20 91 48 02 	lds	r18, 0x0248
     678:	30 91 49 02 	lds	r19, 0x0249
     67c:	80 e0       	ldi	r24, 0x00	; 0
     67e:	98 e1       	ldi	r25, 0x18	; 24
     680:	82 1b       	sub	r24, r18
     682:	93 0b       	sbc	r25, r19
}
     684:	08 95       	ret

00000686 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     686:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     688:	03 96       	adiw	r24, 0x03	; 3
     68a:	92 83       	std	Z+2, r25	; 0x02
     68c:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     68e:	2f ef       	ldi	r18, 0xFF	; 255
     690:	3f ef       	ldi	r19, 0xFF	; 255
     692:	34 83       	std	Z+4, r19	; 0x04
     694:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     696:	96 83       	std	Z+6, r25	; 0x06
     698:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     69a:	90 87       	std	Z+8, r25	; 0x08
     69c:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     69e:	10 82       	st	Z, r1
}
     6a0:	08 95       	ret

000006a2 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     6a2:	fc 01       	movw	r30, r24
     6a4:	11 86       	std	Z+9, r1	; 0x09
     6a6:	10 86       	std	Z+8, r1	; 0x08
}
     6a8:	08 95       	ret

000006aa <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     6aa:	cf 93       	push	r28
     6ac:	df 93       	push	r29
     6ae:	ec 01       	movw	r28, r24
     6b0:	fb 01       	movw	r30, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     6b2:	89 81       	ldd	r24, Y+1	; 0x01
     6b4:	9a 81       	ldd	r25, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     6b6:	dc 01       	movw	r26, r24
     6b8:	12 96       	adiw	r26, 0x02	; 2
     6ba:	2d 91       	ld	r18, X+
     6bc:	3c 91       	ld	r19, X
     6be:	13 97       	sbiw	r26, 0x03	; 3
     6c0:	33 83       	std	Z+3, r19	; 0x03
     6c2:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
     6c4:	29 81       	ldd	r18, Y+1	; 0x01
     6c6:	3a 81       	ldd	r19, Y+2	; 0x02
     6c8:	35 83       	std	Z+5, r19	; 0x05
     6ca:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     6cc:	12 96       	adiw	r26, 0x02	; 2
     6ce:	2d 91       	ld	r18, X+
     6d0:	3c 91       	ld	r19, X
     6d2:	13 97       	sbiw	r26, 0x03	; 3
     6d4:	d9 01       	movw	r26, r18
     6d6:	15 96       	adiw	r26, 0x05	; 5
     6d8:	7c 93       	st	X, r23
     6da:	6e 93       	st	-X, r22
     6dc:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     6de:	dc 01       	movw	r26, r24
     6e0:	13 96       	adiw	r26, 0x03	; 3
     6e2:	7c 93       	st	X, r23
     6e4:	6e 93       	st	-X, r22
     6e6:	12 97       	sbiw	r26, 0x02	; 2
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     6e8:	7a 83       	std	Y+2, r23	; 0x02
     6ea:	69 83       	std	Y+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     6ec:	d1 87       	std	Z+9, r29	; 0x09
     6ee:	c0 87       	std	Z+8, r28	; 0x08

	( pxList->uxNumberOfItems )++;
     6f0:	88 81       	ld	r24, Y
     6f2:	8f 5f       	subi	r24, 0xFF	; 255
     6f4:	88 83       	st	Y, r24
}
     6f6:	df 91       	pop	r29
     6f8:	cf 91       	pop	r28
     6fa:	08 95       	ret

000006fc <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     6fc:	cf 93       	push	r28
     6fe:	df 93       	push	r29
     700:	ac 01       	movw	r20, r24
     702:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     704:	28 81       	ld	r18, Y
     706:	39 81       	ldd	r19, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     708:	8f ef       	ldi	r24, 0xFF	; 255
     70a:	2f 3f       	cpi	r18, 0xFF	; 255
     70c:	38 07       	cpc	r19, r24
     70e:	21 f4       	brne	.+8      	; 0x718 <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     710:	fa 01       	movw	r30, r20
     712:	a7 81       	ldd	r26, Z+7	; 0x07
     714:	b0 85       	ldd	r27, Z+8	; 0x08
     716:	18 c0       	rjmp	.+48     	; 0x748 <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     718:	da 01       	movw	r26, r20
     71a:	13 96       	adiw	r26, 0x03	; 3
     71c:	fa 01       	movw	r30, r20
     71e:	85 81       	ldd	r24, Z+5	; 0x05
     720:	96 81       	ldd	r25, Z+6	; 0x06
     722:	fc 01       	movw	r30, r24
     724:	80 81       	ld	r24, Z
     726:	91 81       	ldd	r25, Z+1	; 0x01
     728:	28 17       	cp	r18, r24
     72a:	39 07       	cpc	r19, r25
     72c:	68 f0       	brcs	.+26     	; 0x748 <vListInsert+0x4c>
     72e:	12 96       	adiw	r26, 0x02	; 2
     730:	0d 90       	ld	r0, X+
     732:	bc 91       	ld	r27, X
     734:	a0 2d       	mov	r26, r0
     736:	12 96       	adiw	r26, 0x02	; 2
     738:	ed 91       	ld	r30, X+
     73a:	fc 91       	ld	r31, X
     73c:	13 97       	sbiw	r26, 0x03	; 3
     73e:	80 81       	ld	r24, Z
     740:	91 81       	ldd	r25, Z+1	; 0x01
     742:	28 17       	cp	r18, r24
     744:	39 07       	cpc	r19, r25
     746:	98 f7       	brcc	.-26     	; 0x72e <vListInsert+0x32>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     748:	12 96       	adiw	r26, 0x02	; 2
     74a:	ed 91       	ld	r30, X+
     74c:	fc 91       	ld	r31, X
     74e:	13 97       	sbiw	r26, 0x03	; 3
     750:	fb 83       	std	Y+3, r31	; 0x03
     752:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     754:	d5 83       	std	Z+5, r29	; 0x05
     756:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     758:	bd 83       	std	Y+5, r27	; 0x05
     75a:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     75c:	13 96       	adiw	r26, 0x03	; 3
     75e:	dc 93       	st	X, r29
     760:	ce 93       	st	-X, r28
     762:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     764:	59 87       	std	Y+9, r21	; 0x09
     766:	48 87       	std	Y+8, r20	; 0x08

	( pxList->uxNumberOfItems )++;
     768:	fa 01       	movw	r30, r20
     76a:	80 81       	ld	r24, Z
     76c:	8f 5f       	subi	r24, 0xFF	; 255
     76e:	80 83       	st	Z, r24
}
     770:	df 91       	pop	r29
     772:	cf 91       	pop	r28
     774:	08 95       	ret

00000776 <uxListRemove>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
{
     776:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     778:	a2 81       	ldd	r26, Z+2	; 0x02
     77a:	b3 81       	ldd	r27, Z+3	; 0x03
     77c:	84 81       	ldd	r24, Z+4	; 0x04
     77e:	95 81       	ldd	r25, Z+5	; 0x05
     780:	15 96       	adiw	r26, 0x05	; 5
     782:	9c 93       	st	X, r25
     784:	8e 93       	st	-X, r24
     786:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     788:	a4 81       	ldd	r26, Z+4	; 0x04
     78a:	b5 81       	ldd	r27, Z+5	; 0x05
     78c:	82 81       	ldd	r24, Z+2	; 0x02
     78e:	93 81       	ldd	r25, Z+3	; 0x03
     790:	13 96       	adiw	r26, 0x03	; 3
     792:	9c 93       	st	X, r25
     794:	8e 93       	st	-X, r24
     796:	12 97       	sbiw	r26, 0x02	; 2

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     798:	a0 85       	ldd	r26, Z+8	; 0x08
     79a:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     79c:	11 96       	adiw	r26, 0x01	; 1
     79e:	8d 91       	ld	r24, X+
     7a0:	9c 91       	ld	r25, X
     7a2:	12 97       	sbiw	r26, 0x02	; 2
     7a4:	8e 17       	cp	r24, r30
     7a6:	9f 07       	cpc	r25, r31
     7a8:	31 f4       	brne	.+12     	; 0x7b6 <uxListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     7aa:	84 81       	ldd	r24, Z+4	; 0x04
     7ac:	95 81       	ldd	r25, Z+5	; 0x05
     7ae:	12 96       	adiw	r26, 0x02	; 2
     7b0:	9c 93       	st	X, r25
     7b2:	8e 93       	st	-X, r24
     7b4:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     7b6:	11 86       	std	Z+9, r1	; 0x09
     7b8:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     7ba:	8c 91       	ld	r24, X
     7bc:	81 50       	subi	r24, 0x01	; 1
     7be:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
     7c0:	8c 91       	ld	r24, X
}
     7c2:	08 95       	ret

000007c4 <pxPortInitialiseStack>:
#endif

	/* Place a few bytes of known values on the bottom of the stack.
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     7c4:	21 e1       	ldi	r18, 0x11	; 17
     7c6:	fc 01       	movw	r30, r24
     7c8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     7ca:	31 97       	sbiw	r30, 0x01	; 1
     7cc:	32 e2       	ldi	r19, 0x22	; 34
     7ce:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     7d0:	fc 01       	movw	r30, r24
     7d2:	32 97       	sbiw	r30, 0x02	; 2
     7d4:	a3 e3       	ldi	r26, 0x33	; 51
     7d6:	a0 83       	st	Z, r26
	 *
	 * In order to do this properly, we would need to get a full 3-byte pointer to
	 * pxCode.  That requires a change to GCC.  Not likely to happen any time soon.
	 */
	usAddress = ( unsigned portSHORT ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
     7d8:	fc 01       	movw	r30, r24
     7da:	33 97       	sbiw	r30, 0x03	; 3
     7dc:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
     7de:	fc 01       	movw	r30, r24
     7e0:	34 97       	sbiw	r30, 0x04	; 4
     7e2:	70 83       	st	Z, r23
	pxTopOfStack--;

	*pxTopOfStack = 0;
     7e4:	fc 01       	movw	r30, r24
     7e6:	35 97       	sbiw	r30, 0x05	; 5
     7e8:	10 82       	st	Z, r1

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
     7ea:	fc 01       	movw	r30, r24
     7ec:	36 97       	sbiw	r30, 0x06	; 6
     7ee:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     7f0:	fc 01       	movw	r30, r24
     7f2:	37 97       	sbiw	r30, 0x07	; 7
     7f4:	60 e8       	ldi	r22, 0x80	; 128
     7f6:	60 83       	st	Z, r22
#if defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

	/* If we have an ATmega256x, we are also saving the RAMPZ and EIND registers.
	 * We should default those to 0.
	 */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* EIND */
     7f8:	fc 01       	movw	r30, r24
     7fa:	38 97       	sbiw	r30, 0x08	; 8
     7fc:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* RAMPZ */
     7fe:	fc 01       	movw	r30, r24
     800:	39 97       	sbiw	r30, 0x09	; 9
     802:	10 82       	st	Z, r1
	pxTopOfStack--;

#endif

	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
     804:	fc 01       	movw	r30, r24
     806:	3a 97       	sbiw	r30, 0x0a	; 10
     808:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
     80a:	fc 01       	movw	r30, r24
     80c:	3b 97       	sbiw	r30, 0x0b	; 11
     80e:	62 e0       	ldi	r22, 0x02	; 2
     810:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
     812:	fc 01       	movw	r30, r24
     814:	3c 97       	sbiw	r30, 0x0c	; 12
     816:	63 e0       	ldi	r22, 0x03	; 3
     818:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
     81a:	fc 01       	movw	r30, r24
     81c:	3d 97       	sbiw	r30, 0x0d	; 13
     81e:	64 e0       	ldi	r22, 0x04	; 4
     820:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
     822:	fc 01       	movw	r30, r24
     824:	3e 97       	sbiw	r30, 0x0e	; 14
     826:	65 e0       	ldi	r22, 0x05	; 5
     828:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
     82a:	fc 01       	movw	r30, r24
     82c:	3f 97       	sbiw	r30, 0x0f	; 15
     82e:	66 e0       	ldi	r22, 0x06	; 6
     830:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
     832:	fc 01       	movw	r30, r24
     834:	70 97       	sbiw	r30, 0x10	; 16
     836:	67 e0       	ldi	r22, 0x07	; 7
     838:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
     83a:	fc 01       	movw	r30, r24
     83c:	71 97       	sbiw	r30, 0x11	; 17
     83e:	68 e0       	ldi	r22, 0x08	; 8
     840:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
     842:	fc 01       	movw	r30, r24
     844:	72 97       	sbiw	r30, 0x12	; 18
     846:	69 e0       	ldi	r22, 0x09	; 9
     848:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
     84a:	fc 01       	movw	r30, r24
     84c:	73 97       	sbiw	r30, 0x13	; 19
     84e:	60 e1       	ldi	r22, 0x10	; 16
     850:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
     852:	fc 01       	movw	r30, r24
     854:	74 97       	sbiw	r30, 0x14	; 20
     856:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
     858:	fc 01       	movw	r30, r24
     85a:	75 97       	sbiw	r30, 0x15	; 21
     85c:	22 e1       	ldi	r18, 0x12	; 18
     85e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
     860:	fc 01       	movw	r30, r24
     862:	76 97       	sbiw	r30, 0x16	; 22
     864:	23 e1       	ldi	r18, 0x13	; 19
     866:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
     868:	fc 01       	movw	r30, r24
     86a:	77 97       	sbiw	r30, 0x17	; 23
     86c:	24 e1       	ldi	r18, 0x14	; 20
     86e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
     870:	fc 01       	movw	r30, r24
     872:	78 97       	sbiw	r30, 0x18	; 24
     874:	25 e1       	ldi	r18, 0x15	; 21
     876:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
     878:	fc 01       	movw	r30, r24
     87a:	79 97       	sbiw	r30, 0x19	; 25
     87c:	26 e1       	ldi	r18, 0x16	; 22
     87e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
     880:	fc 01       	movw	r30, r24
     882:	7a 97       	sbiw	r30, 0x1a	; 26
     884:	27 e1       	ldi	r18, 0x17	; 23
     886:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
     888:	fc 01       	movw	r30, r24
     88a:	7b 97       	sbiw	r30, 0x1b	; 27
     88c:	28 e1       	ldi	r18, 0x18	; 24
     88e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
     890:	fc 01       	movw	r30, r24
     892:	7c 97       	sbiw	r30, 0x1c	; 28
     894:	29 e1       	ldi	r18, 0x19	; 25
     896:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
     898:	fc 01       	movw	r30, r24
     89a:	7d 97       	sbiw	r30, 0x1d	; 29
     89c:	20 e2       	ldi	r18, 0x20	; 32
     89e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
     8a0:	fc 01       	movw	r30, r24
     8a2:	7e 97       	sbiw	r30, 0x1e	; 30
     8a4:	21 e2       	ldi	r18, 0x21	; 33
     8a6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
     8a8:	fc 01       	movw	r30, r24
     8aa:	7f 97       	sbiw	r30, 0x1f	; 31
     8ac:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
     8ae:	fc 01       	movw	r30, r24
     8b0:	b0 97       	sbiw	r30, 0x20	; 32
     8b2:	23 e2       	ldi	r18, 0x23	; 35
     8b4:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     8b6:	fc 01       	movw	r30, r24
     8b8:	b1 97       	sbiw	r30, 0x21	; 33
     8ba:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     8bc:	fc 01       	movw	r30, r24
     8be:	b2 97       	sbiw	r30, 0x22	; 34
     8c0:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
     8c2:	fc 01       	movw	r30, r24
     8c4:	b3 97       	sbiw	r30, 0x23	; 35
     8c6:	26 e2       	ldi	r18, 0x26	; 38
     8c8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
     8ca:	fc 01       	movw	r30, r24
     8cc:	b4 97       	sbiw	r30, 0x24	; 36
     8ce:	27 e2       	ldi	r18, 0x27	; 39
     8d0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
     8d2:	fc 01       	movw	r30, r24
     8d4:	b5 97       	sbiw	r30, 0x25	; 37
     8d6:	28 e2       	ldi	r18, 0x28	; 40
     8d8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
     8da:	fc 01       	movw	r30, r24
     8dc:	b6 97       	sbiw	r30, 0x26	; 38
     8de:	29 e2       	ldi	r18, 0x29	; 41
     8e0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
     8e2:	fc 01       	movw	r30, r24
     8e4:	b7 97       	sbiw	r30, 0x27	; 39
     8e6:	20 e3       	ldi	r18, 0x30	; 48
     8e8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
     8ea:	fc 01       	movw	r30, r24
     8ec:	b8 97       	sbiw	r30, 0x28	; 40
     8ee:	21 e3       	ldi	r18, 0x31	; 49
     8f0:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     8f2:	89 97       	sbiw	r24, 0x29	; 41
}
     8f4:	08 95       	ret

000008f6 <xPortStartScheduler>:
    // the HiByte is only needed, if a 16 Bit counter is being utilized
#ifdef portOCRH

    ulCompareMatch >>= 8;
    ucHighByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
    portOCRH = ucHighByte;
     8f6:	81 e0       	ldi	r24, 0x01	; 1
     8f8:	80 93 99 00 	sts	0x0099, r24

#endif

    portOCRL = ucLowByte;
     8fc:	83 ef       	ldi	r24, 0xF3	; 243
     8fe:	80 93 98 00 	sts	0x0098, r24
	portTCCRb = ucLowByte;

#elif defined( portUSE_TIMER3 )
	/* Setup clock source and compare match behaviour. Assuming  640 / 1280 /1281 / 1284p / 2560 / 2561 (with Timer3) */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	portTCCRb = ucLowByte;
     902:	8b e0       	ldi	r24, 0x0B	; 11
     904:	80 93 91 00 	sts	0x0091, r24
#endif

    /* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
    ucLowByte = portTIMSK;
     908:	e1 e7       	ldi	r30, 0x71	; 113
     90a:	f0 e0       	ldi	r31, 0x00	; 0
     90c:	80 81       	ld	r24, Z
    ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     90e:	82 60       	ori	r24, 0x02	; 2
    portTIMSK = ucLowByte;
     910:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     912:	a0 91 4a 1a 	lds	r26, 0x1A4A
     916:	b0 91 4b 1a 	lds	r27, 0x1A4B
     91a:	cd 91       	ld	r28, X+
     91c:	cd bf       	out	0x3d, r28	; 61
     91e:	dd 91       	ld	r29, X+
     920:	de bf       	out	0x3e, r29	; 62
     922:	ff 91       	pop	r31
     924:	ef 91       	pop	r30
     926:	df 91       	pop	r29
     928:	cf 91       	pop	r28
     92a:	bf 91       	pop	r27
     92c:	af 91       	pop	r26
     92e:	9f 91       	pop	r25
     930:	8f 91       	pop	r24
     932:	7f 91       	pop	r23
     934:	6f 91       	pop	r22
     936:	5f 91       	pop	r21
     938:	4f 91       	pop	r20
     93a:	3f 91       	pop	r19
     93c:	2f 91       	pop	r18
     93e:	1f 91       	pop	r17
     940:	0f 91       	pop	r16
     942:	ff 90       	pop	r15
     944:	ef 90       	pop	r14
     946:	df 90       	pop	r13
     948:	cf 90       	pop	r12
     94a:	bf 90       	pop	r11
     94c:	af 90       	pop	r10
     94e:	9f 90       	pop	r9
     950:	8f 90       	pop	r8
     952:	7f 90       	pop	r7
     954:	6f 90       	pop	r6
     956:	5f 90       	pop	r5
     958:	4f 90       	pop	r4
     95a:	3f 90       	pop	r3
     95c:	2f 90       	pop	r2
     95e:	1f 90       	pop	r1
     960:	0f 90       	pop	r0
     962:	0c be       	out	0x3c, r0	; 60
     964:	0f 90       	pop	r0
     966:	0b be       	out	0x3b, r0	; 59
     968:	0f 90       	pop	r0
     96a:	0f be       	out	0x3f, r0	; 63
     96c:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     96e:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     970:	81 e0       	ldi	r24, 0x01	; 1
     972:	08 95       	ret

00000974 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     974:	08 95       	ret

00000976 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     976:	0f 92       	push	r0
     978:	0f b6       	in	r0, 0x3f	; 63
     97a:	f8 94       	cli
     97c:	0f 92       	push	r0
     97e:	0b b6       	in	r0, 0x3b	; 59
     980:	0f 92       	push	r0
     982:	0c b6       	in	r0, 0x3c	; 60
     984:	0f 92       	push	r0
     986:	1f 92       	push	r1
     988:	11 24       	eor	r1, r1
     98a:	2f 92       	push	r2
     98c:	3f 92       	push	r3
     98e:	4f 92       	push	r4
     990:	5f 92       	push	r5
     992:	6f 92       	push	r6
     994:	7f 92       	push	r7
     996:	8f 92       	push	r8
     998:	9f 92       	push	r9
     99a:	af 92       	push	r10
     99c:	bf 92       	push	r11
     99e:	cf 92       	push	r12
     9a0:	df 92       	push	r13
     9a2:	ef 92       	push	r14
     9a4:	ff 92       	push	r15
     9a6:	0f 93       	push	r16
     9a8:	1f 93       	push	r17
     9aa:	2f 93       	push	r18
     9ac:	3f 93       	push	r19
     9ae:	4f 93       	push	r20
     9b0:	5f 93       	push	r21
     9b2:	6f 93       	push	r22
     9b4:	7f 93       	push	r23
     9b6:	8f 93       	push	r24
     9b8:	9f 93       	push	r25
     9ba:	af 93       	push	r26
     9bc:	bf 93       	push	r27
     9be:	cf 93       	push	r28
     9c0:	df 93       	push	r29
     9c2:	ef 93       	push	r30
     9c4:	ff 93       	push	r31
     9c6:	a0 91 4a 1a 	lds	r26, 0x1A4A
     9ca:	b0 91 4b 1a 	lds	r27, 0x1A4B
     9ce:	0d b6       	in	r0, 0x3d	; 61
     9d0:	0d 92       	st	X+, r0
     9d2:	0e b6       	in	r0, 0x3e	; 62
     9d4:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     9d6:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     9da:	a0 91 4a 1a 	lds	r26, 0x1A4A
     9de:	b0 91 4b 1a 	lds	r27, 0x1A4B
     9e2:	cd 91       	ld	r28, X+
     9e4:	cd bf       	out	0x3d, r28	; 61
     9e6:	dd 91       	ld	r29, X+
     9e8:	de bf       	out	0x3e, r29	; 62
     9ea:	ff 91       	pop	r31
     9ec:	ef 91       	pop	r30
     9ee:	df 91       	pop	r29
     9f0:	cf 91       	pop	r28
     9f2:	bf 91       	pop	r27
     9f4:	af 91       	pop	r26
     9f6:	9f 91       	pop	r25
     9f8:	8f 91       	pop	r24
     9fa:	7f 91       	pop	r23
     9fc:	6f 91       	pop	r22
     9fe:	5f 91       	pop	r21
     a00:	4f 91       	pop	r20
     a02:	3f 91       	pop	r19
     a04:	2f 91       	pop	r18
     a06:	1f 91       	pop	r17
     a08:	0f 91       	pop	r16
     a0a:	ff 90       	pop	r15
     a0c:	ef 90       	pop	r14
     a0e:	df 90       	pop	r13
     a10:	cf 90       	pop	r12
     a12:	bf 90       	pop	r11
     a14:	af 90       	pop	r10
     a16:	9f 90       	pop	r9
     a18:	8f 90       	pop	r8
     a1a:	7f 90       	pop	r7
     a1c:	6f 90       	pop	r6
     a1e:	5f 90       	pop	r5
     a20:	4f 90       	pop	r4
     a22:	3f 90       	pop	r3
     a24:	2f 90       	pop	r2
     a26:	1f 90       	pop	r1
     a28:	0f 90       	pop	r0
     a2a:	0c be       	out	0x3c, r0	; 60
     a2c:	0f 90       	pop	r0
     a2e:	0b be       	out	0x3b, r0	; 59
     a30:	0f 90       	pop	r0
     a32:	0f be       	out	0x3f, r0	; 63
     a34:	0f 90       	pop	r0

	asm volatile ( "ret" );
     a36:	08 95       	ret

00000a38 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     a38:	0f 92       	push	r0
     a3a:	0f b6       	in	r0, 0x3f	; 63
     a3c:	f8 94       	cli
     a3e:	0f 92       	push	r0
     a40:	0b b6       	in	r0, 0x3b	; 59
     a42:	0f 92       	push	r0
     a44:	0c b6       	in	r0, 0x3c	; 60
     a46:	0f 92       	push	r0
     a48:	1f 92       	push	r1
     a4a:	11 24       	eor	r1, r1
     a4c:	2f 92       	push	r2
     a4e:	3f 92       	push	r3
     a50:	4f 92       	push	r4
     a52:	5f 92       	push	r5
     a54:	6f 92       	push	r6
     a56:	7f 92       	push	r7
     a58:	8f 92       	push	r8
     a5a:	9f 92       	push	r9
     a5c:	af 92       	push	r10
     a5e:	bf 92       	push	r11
     a60:	cf 92       	push	r12
     a62:	df 92       	push	r13
     a64:	ef 92       	push	r14
     a66:	ff 92       	push	r15
     a68:	0f 93       	push	r16
     a6a:	1f 93       	push	r17
     a6c:	2f 93       	push	r18
     a6e:	3f 93       	push	r19
     a70:	4f 93       	push	r20
     a72:	5f 93       	push	r21
     a74:	6f 93       	push	r22
     a76:	7f 93       	push	r23
     a78:	8f 93       	push	r24
     a7a:	9f 93       	push	r25
     a7c:	af 93       	push	r26
     a7e:	bf 93       	push	r27
     a80:	cf 93       	push	r28
     a82:	df 93       	push	r29
     a84:	ef 93       	push	r30
     a86:	ff 93       	push	r31
     a88:	a0 91 4a 1a 	lds	r26, 0x1A4A
     a8c:	b0 91 4b 1a 	lds	r27, 0x1A4B
     a90:	0d b6       	in	r0, 0x3d	; 61
     a92:	0d 92       	st	X+, r0
     a94:	0e b6       	in	r0, 0x3e	; 62
     a96:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     a98:	0e 94 24 0b 	call	0x1648	; 0x1648 <vTaskIncrementTick>
	vTaskSwitchContext();
     a9c:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     aa0:	a0 91 4a 1a 	lds	r26, 0x1A4A
     aa4:	b0 91 4b 1a 	lds	r27, 0x1A4B
     aa8:	cd 91       	ld	r28, X+
     aaa:	cd bf       	out	0x3d, r28	; 61
     aac:	dd 91       	ld	r29, X+
     aae:	de bf       	out	0x3e, r29	; 62
     ab0:	ff 91       	pop	r31
     ab2:	ef 91       	pop	r30
     ab4:	df 91       	pop	r29
     ab6:	cf 91       	pop	r28
     ab8:	bf 91       	pop	r27
     aba:	af 91       	pop	r26
     abc:	9f 91       	pop	r25
     abe:	8f 91       	pop	r24
     ac0:	7f 91       	pop	r23
     ac2:	6f 91       	pop	r22
     ac4:	5f 91       	pop	r21
     ac6:	4f 91       	pop	r20
     ac8:	3f 91       	pop	r19
     aca:	2f 91       	pop	r18
     acc:	1f 91       	pop	r17
     ace:	0f 91       	pop	r16
     ad0:	ff 90       	pop	r15
     ad2:	ef 90       	pop	r14
     ad4:	df 90       	pop	r13
     ad6:	cf 90       	pop	r12
     ad8:	bf 90       	pop	r11
     ada:	af 90       	pop	r10
     adc:	9f 90       	pop	r9
     ade:	8f 90       	pop	r8
     ae0:	7f 90       	pop	r7
     ae2:	6f 90       	pop	r6
     ae4:	5f 90       	pop	r5
     ae6:	4f 90       	pop	r4
     ae8:	3f 90       	pop	r3
     aea:	2f 90       	pop	r2
     aec:	1f 90       	pop	r1
     aee:	0f 90       	pop	r0
     af0:	0c be       	out	0x3c, r0	; 60
     af2:	0f 90       	pop	r0
     af4:	0b be       	out	0x3b, r0	; 59
     af6:	0f 90       	pop	r0
     af8:	0f be       	out	0x3f, r0	; 63
     afa:	0f 90       	pop	r0

	asm volatile ( "ret" );
     afc:	08 95       	ret

00000afe <__vector_32>:

	#elif defined( portUSE_TIMER3 )
		#warning "Timer3 used for PRE-EMPTIVE scheduler."
		ISR(TIMER3_COMPA_vect, ISR_NAKED)
		{
			vPortYieldFromTick();
     afe:	0e 94 1c 05 	call	0xa38	; 0xa38 <vPortYieldFromTick>
			asm volatile ( "reti" );
     b02:	18 95       	reti

00000b04 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
     b04:	cf 93       	push	r28
     b06:	df 93       	push	r29
     b08:	dc 01       	movw	r26, r24
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
     b0a:	cd 91       	ld	r28, X+
     b0c:	dc 91       	ld	r29, X
     b0e:	11 97       	sbiw	r26, 0x01	; 1
     b10:	20 97       	sbiw	r28, 0x00	; 0
     b12:	21 f1       	breq	.+72     	; 0xb5c <prvCopyDataFromQueue+0x58>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
     b14:	5c 96       	adiw	r26, 0x1c	; 28
     b16:	4c 91       	ld	r20, X
     b18:	5c 97       	sbiw	r26, 0x1c	; 28
     b1a:	16 96       	adiw	r26, 0x06	; 6
     b1c:	2d 91       	ld	r18, X+
     b1e:	3c 91       	ld	r19, X
     b20:	17 97       	sbiw	r26, 0x07	; 7
     b22:	24 0f       	add	r18, r20
     b24:	31 1d       	adc	r19, r1
     b26:	17 96       	adiw	r26, 0x07	; 7
     b28:	3c 93       	st	X, r19
     b2a:	2e 93       	st	-X, r18
     b2c:	16 97       	sbiw	r26, 0x06	; 6
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
     b2e:	12 96       	adiw	r26, 0x02	; 2
     b30:	ed 91       	ld	r30, X+
     b32:	fc 91       	ld	r31, X
     b34:	13 97       	sbiw	r26, 0x03	; 3
     b36:	2e 17       	cp	r18, r30
     b38:	3f 07       	cpc	r19, r31
     b3a:	20 f0       	brcs	.+8      	; 0xb44 <prvCopyDataFromQueue+0x40>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
     b3c:	17 96       	adiw	r26, 0x07	; 7
     b3e:	dc 93       	st	X, r29
     b40:	ce 93       	st	-X, r28
     b42:	16 97       	sbiw	r26, 0x06	; 6
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
     b44:	16 96       	adiw	r26, 0x06	; 6
     b46:	3c 91       	ld	r19, X
     b48:	16 97       	sbiw	r26, 0x06	; 6
     b4a:	17 96       	adiw	r26, 0x07	; 7
     b4c:	2c 91       	ld	r18, X
     b4e:	86 2f       	mov	r24, r22
     b50:	97 2f       	mov	r25, r23
     b52:	63 2f       	mov	r22, r19
     b54:	72 2f       	mov	r23, r18
     b56:	50 e0       	ldi	r21, 0x00	; 0
     b58:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <memcpy>
	}
}
     b5c:	df 91       	pop	r29
     b5e:	cf 91       	pop	r28
     b60:	08 95       	ret

00000b62 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
     b62:	0f 93       	push	r16
     b64:	1f 93       	push	r17
     b66:	cf 93       	push	r28
     b68:	df 93       	push	r29
     b6a:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     b6c:	0f b6       	in	r0, 0x3f	; 63
     b6e:	f8 94       	cli
     b70:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     b72:	8e 8d       	ldd	r24, Y+30	; 0x1e
     b74:	18 16       	cp	r1, r24
     b76:	c4 f4       	brge	.+48     	; 0xba8 <prvUnlockQueue+0x46>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     b78:	89 89       	ldd	r24, Y+17	; 0x11
     b7a:	88 23       	and	r24, r24
     b7c:	29 f4       	brne	.+10     	; 0xb88 <prvUnlockQueue+0x26>
     b7e:	14 c0       	rjmp	.+40     	; 0xba8 <prvUnlockQueue+0x46>
     b80:	89 89       	ldd	r24, Y+17	; 0x11
     b82:	88 23       	and	r24, r24
     b84:	21 f4       	brne	.+8      	; 0xb8e <prvUnlockQueue+0x2c>
     b86:	10 c0       	rjmp	.+32     	; 0xba8 <prvUnlockQueue+0x46>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     b88:	8e 01       	movw	r16, r28
     b8a:	0f 5e       	subi	r16, 0xEF	; 239
     b8c:	1f 4f       	sbci	r17, 0xFF	; 255
     b8e:	c8 01       	movw	r24, r16
     b90:	0e 94 bd 0d 	call	0x1b7a	; 0x1b7a <xTaskRemoveFromEventList>
     b94:	88 23       	and	r24, r24
     b96:	11 f0       	breq	.+4      	; 0xb9c <prvUnlockQueue+0x3a>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
     b98:	0e 94 4e 0e 	call	0x1c9c	; 0x1c9c <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
     b9c:	8e 8d       	ldd	r24, Y+30	; 0x1e
     b9e:	81 50       	subi	r24, 0x01	; 1
     ba0:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     ba2:	8e 8d       	ldd	r24, Y+30	; 0x1e
     ba4:	18 16       	cp	r1, r24
     ba6:	64 f3       	brlt	.-40     	; 0xb80 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
     ba8:	8f ef       	ldi	r24, 0xFF	; 255
     baa:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     bac:	0f 90       	pop	r0
     bae:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     bb0:	0f b6       	in	r0, 0x3f	; 63
     bb2:	f8 94       	cli
     bb4:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     bb6:	8d 8d       	ldd	r24, Y+29	; 0x1d
     bb8:	18 16       	cp	r1, r24
     bba:	c4 f4       	brge	.+48     	; 0xbec <prvUnlockQueue+0x8a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     bbc:	88 85       	ldd	r24, Y+8	; 0x08
     bbe:	88 23       	and	r24, r24
     bc0:	29 f4       	brne	.+10     	; 0xbcc <prvUnlockQueue+0x6a>
     bc2:	14 c0       	rjmp	.+40     	; 0xbec <prvUnlockQueue+0x8a>
     bc4:	88 85       	ldd	r24, Y+8	; 0x08
     bc6:	88 23       	and	r24, r24
     bc8:	21 f4       	brne	.+8      	; 0xbd2 <prvUnlockQueue+0x70>
     bca:	10 c0       	rjmp	.+32     	; 0xbec <prvUnlockQueue+0x8a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     bcc:	8e 01       	movw	r16, r28
     bce:	08 5f       	subi	r16, 0xF8	; 248
     bd0:	1f 4f       	sbci	r17, 0xFF	; 255
     bd2:	c8 01       	movw	r24, r16
     bd4:	0e 94 bd 0d 	call	0x1b7a	; 0x1b7a <xTaskRemoveFromEventList>
     bd8:	88 23       	and	r24, r24
     bda:	11 f0       	breq	.+4      	; 0xbe0 <prvUnlockQueue+0x7e>
				{
					vTaskMissedYield();
     bdc:	0e 94 4e 0e 	call	0x1c9c	; 0x1c9c <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
     be0:	8d 8d       	ldd	r24, Y+29	; 0x1d
     be2:	81 50       	subi	r24, 0x01	; 1
     be4:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     be6:	8d 8d       	ldd	r24, Y+29	; 0x1d
     be8:	18 16       	cp	r1, r24
     bea:	64 f3       	brlt	.-40     	; 0xbc4 <prvUnlockQueue+0x62>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
     bec:	8f ef       	ldi	r24, 0xFF	; 255
     bee:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     bf0:	0f 90       	pop	r0
     bf2:	0f be       	out	0x3f, r0	; 63
}
     bf4:	df 91       	pop	r29
     bf6:	cf 91       	pop	r28
     bf8:	1f 91       	pop	r17
     bfa:	0f 91       	pop	r16
     bfc:	08 95       	ret

00000bfe <prvCopyDataToQueue>:

#endif
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
     bfe:	cf 93       	push	r28
     c00:	df 93       	push	r29
     c02:	ec 01       	movw	r28, r24
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
     c04:	2c 8d       	ldd	r18, Y+28	; 0x1c
     c06:	22 23       	and	r18, r18
     c08:	59 f4       	brne	.+22     	; 0xc20 <prvCopyDataToQueue+0x22>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     c0a:	88 81       	ld	r24, Y
     c0c:	99 81       	ldd	r25, Y+1	; 0x01
     c0e:	00 97       	sbiw	r24, 0x00	; 0
     c10:	e1 f5       	brne	.+120    	; 0xc8a <prvCopyDataToQueue+0x8c>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
     c12:	8a 81       	ldd	r24, Y+2	; 0x02
     c14:	9b 81       	ldd	r25, Y+3	; 0x03
     c16:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
     c1a:	1b 82       	std	Y+3, r1	; 0x03
     c1c:	1a 82       	std	Y+2, r1	; 0x02
     c1e:	35 c0       	rjmp	.+106    	; 0xc8a <prvCopyDataToQueue+0x8c>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
     c20:	44 23       	and	r20, r20
     c22:	b9 f4       	brne	.+46     	; 0xc52 <prvCopyDataToQueue+0x54>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     c24:	8c 81       	ldd	r24, Y+4	; 0x04
     c26:	9d 81       	ldd	r25, Y+5	; 0x05
     c28:	42 2f       	mov	r20, r18
     c2a:	50 e0       	ldi	r21, 0x00	; 0
     c2c:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     c30:	2c 8d       	ldd	r18, Y+28	; 0x1c
     c32:	8c 81       	ldd	r24, Y+4	; 0x04
     c34:	9d 81       	ldd	r25, Y+5	; 0x05
     c36:	82 0f       	add	r24, r18
     c38:	91 1d       	adc	r25, r1
     c3a:	9d 83       	std	Y+5, r25	; 0x05
     c3c:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
     c3e:	2a 81       	ldd	r18, Y+2	; 0x02
     c40:	3b 81       	ldd	r19, Y+3	; 0x03
     c42:	82 17       	cp	r24, r18
     c44:	93 07       	cpc	r25, r19
     c46:	08 f1       	brcs	.+66     	; 0xc8a <prvCopyDataToQueue+0x8c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     c48:	88 81       	ld	r24, Y
     c4a:	99 81       	ldd	r25, Y+1	; 0x01
     c4c:	9d 83       	std	Y+5, r25	; 0x05
     c4e:	8c 83       	std	Y+4, r24	; 0x04
     c50:	1c c0       	rjmp	.+56     	; 0xc8a <prvCopyDataToQueue+0x8c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     c52:	8e 81       	ldd	r24, Y+6	; 0x06
     c54:	9f 81       	ldd	r25, Y+7	; 0x07
     c56:	42 2f       	mov	r20, r18
     c58:	50 e0       	ldi	r21, 0x00	; 0
     c5a:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
     c5e:	4c 8d       	ldd	r20, Y+28	; 0x1c
     c60:	50 e0       	ldi	r21, 0x00	; 0
     c62:	50 95       	com	r21
     c64:	41 95       	neg	r20
     c66:	5f 4f       	sbci	r21, 0xFF	; 255
     c68:	8e 81       	ldd	r24, Y+6	; 0x06
     c6a:	9f 81       	ldd	r25, Y+7	; 0x07
     c6c:	84 0f       	add	r24, r20
     c6e:	95 1f       	adc	r25, r21
     c70:	9f 83       	std	Y+7, r25	; 0x07
     c72:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
     c74:	28 81       	ld	r18, Y
     c76:	39 81       	ldd	r19, Y+1	; 0x01
     c78:	82 17       	cp	r24, r18
     c7a:	93 07       	cpc	r25, r19
     c7c:	30 f4       	brcc	.+12     	; 0xc8a <prvCopyDataToQueue+0x8c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     c7e:	8a 81       	ldd	r24, Y+2	; 0x02
     c80:	9b 81       	ldd	r25, Y+3	; 0x03
     c82:	48 0f       	add	r20, r24
     c84:	59 1f       	adc	r21, r25
     c86:	5f 83       	std	Y+7, r21	; 0x07
     c88:	4e 83       	std	Y+6, r20	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
     c8a:	8a 8d       	ldd	r24, Y+26	; 0x1a
     c8c:	8f 5f       	subi	r24, 0xFF	; 255
     c8e:	8a 8f       	std	Y+26, r24	; 0x1a
}
     c90:	df 91       	pop	r29
     c92:	cf 91       	pop	r28
     c94:	08 95       	ret

00000c96 <xQueueGenericReset>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle pxQueue, portBASE_TYPE xNewQueue )
{
     c96:	cf 93       	push	r28
     c98:	df 93       	push	r29
     c9a:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     c9c:	0f b6       	in	r0, 0x3f	; 63
     c9e:	f8 94       	cli
     ca0:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     ca2:	48 81       	ld	r20, Y
     ca4:	59 81       	ldd	r21, Y+1	; 0x01
     ca6:	2b 8d       	ldd	r18, Y+27	; 0x1b
     ca8:	30 e0       	ldi	r19, 0x00	; 0
     caa:	ec 8d       	ldd	r30, Y+28	; 0x1c
     cac:	f0 e0       	ldi	r31, 0x00	; 0
     cae:	2e 9f       	mul	r18, r30
     cb0:	c0 01       	movw	r24, r0
     cb2:	2f 9f       	mul	r18, r31
     cb4:	90 0d       	add	r25, r0
     cb6:	3e 9f       	mul	r19, r30
     cb8:	90 0d       	add	r25, r0
     cba:	11 24       	eor	r1, r1
     cbc:	84 0f       	add	r24, r20
     cbe:	95 1f       	adc	r25, r21
     cc0:	9b 83       	std	Y+3, r25	; 0x03
     cc2:	8a 83       	std	Y+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
     cc4:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
     cc6:	5d 83       	std	Y+5, r21	; 0x05
     cc8:	4c 83       	std	Y+4, r20	; 0x04
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
     cca:	c9 01       	movw	r24, r18
     ccc:	01 97       	sbiw	r24, 0x01	; 1
     cce:	e8 9f       	mul	r30, r24
     cd0:	90 01       	movw	r18, r0
     cd2:	e9 9f       	mul	r30, r25
     cd4:	30 0d       	add	r19, r0
     cd6:	f8 9f       	mul	r31, r24
     cd8:	30 0d       	add	r19, r0
     cda:	11 24       	eor	r1, r1
     cdc:	24 0f       	add	r18, r20
     cde:	35 1f       	adc	r19, r21
     ce0:	3f 83       	std	Y+7, r19	; 0x07
     ce2:	2e 83       	std	Y+6, r18	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
     ce4:	8f ef       	ldi	r24, 0xFF	; 255
     ce6:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
     ce8:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
     cea:	66 23       	and	r22, r22
     cec:	61 f4       	brne	.+24     	; 0xd06 <xQueueGenericReset+0x70>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to	write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     cee:	88 85       	ldd	r24, Y+8	; 0x08
     cf0:	88 23       	and	r24, r24
     cf2:	89 f0       	breq	.+34     	; 0xd16 <xQueueGenericReset+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     cf4:	ce 01       	movw	r24, r28
     cf6:	08 96       	adiw	r24, 0x08	; 8
     cf8:	0e 94 bd 0d 	call	0x1b7a	; 0x1b7a <xTaskRemoveFromEventList>
     cfc:	81 30       	cpi	r24, 0x01	; 1
     cfe:	59 f4       	brne	.+22     	; 0xd16 <xQueueGenericReset+0x80>
				{
					portYIELD_WITHIN_API();
     d00:	0e 94 bb 04 	call	0x976	; 0x976 <vPortYield>
     d04:	08 c0       	rjmp	.+16     	; 0xd16 <xQueueGenericReset+0x80>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     d06:	ce 01       	movw	r24, r28
     d08:	08 96       	adiw	r24, 0x08	; 8
     d0a:	0e 94 43 03 	call	0x686	; 0x686 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     d0e:	ce 01       	movw	r24, r28
     d10:	41 96       	adiw	r24, 0x11	; 17
     d12:	0e 94 43 03 	call	0x686	; 0x686 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
     d16:	0f 90       	pop	r0
     d18:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
     d1a:	81 e0       	ldi	r24, 0x01	; 1
     d1c:	df 91       	pop	r29
     d1e:	cf 91       	pop	r28
     d20:	08 95       	ret

00000d22 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
     d22:	0f 93       	push	r16
     d24:	1f 93       	push	r17
     d26:	cf 93       	push	r28
     d28:	df 93       	push	r29
     d2a:	18 2f       	mov	r17, r24
     d2c:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
     d2e:	88 23       	and	r24, r24
     d30:	f9 f0       	breq	.+62     	; 0xd70 <xQueueGenericCreate+0x4e>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
     d32:	8f e1       	ldi	r24, 0x1F	; 31
     d34:	90 e0       	ldi	r25, 0x00	; 0
     d36:	0e 94 0b 03 	call	0x616	; 0x616 <pvPortMalloc>
     d3a:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
     d3c:	00 97       	sbiw	r24, 0x00	; 0
     d3e:	d9 f0       	breq	.+54     	; 0xd76 <xQueueGenericCreate+0x54>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
     d40:	01 9f       	mul	r16, r17
     d42:	c0 01       	movw	r24, r0
     d44:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
     d46:	01 96       	adiw	r24, 0x01	; 1
     d48:	0e 94 0b 03 	call	0x616	; 0x616 <pvPortMalloc>
     d4c:	99 83       	std	Y+1, r25	; 0x01
     d4e:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
     d50:	00 97       	sbiw	r24, 0x00	; 0
     d52:	41 f0       	breq	.+16     	; 0xd64 <xQueueGenericCreate+0x42>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
     d54:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
     d56:	0c 8f       	std	Y+28, r16	; 0x1c
				xQueueGenericReset( pxNewQueue, pdTRUE );
     d58:	ce 01       	movw	r24, r28
     d5a:	61 e0       	ldi	r22, 0x01	; 1
     d5c:	0e 94 4b 06 	call	0xc96	; 0xc96 <xQueueGenericReset>
					pxNewQueue->ucQueueType = ucQueueType;
				}
				#endif /* configUSE_TRACE_FACILITY */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
     d60:	ce 01       	movw	r24, r28
     d62:	0b c0       	rjmp	.+22     	; 0xd7a <xQueueGenericCreate+0x58>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
     d64:	ce 01       	movw	r24, r28
     d66:	0e 94 34 03 	call	0x668	; 0x668 <vPortFree>

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
     d6a:	80 e0       	ldi	r24, 0x00	; 0
     d6c:	90 e0       	ldi	r25, 0x00	; 0
     d6e:	05 c0       	rjmp	.+10     	; 0xd7a <xQueueGenericCreate+0x58>
     d70:	80 e0       	ldi	r24, 0x00	; 0
     d72:	90 e0       	ldi	r25, 0x00	; 0
     d74:	02 c0       	rjmp	.+4      	; 0xd7a <xQueueGenericCreate+0x58>
     d76:	80 e0       	ldi	r24, 0x00	; 0
     d78:	90 e0       	ldi	r25, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
     d7a:	df 91       	pop	r29
     d7c:	cf 91       	pop	r28
     d7e:	1f 91       	pop	r17
     d80:	0f 91       	pop	r16
     d82:	08 95       	ret

00000d84 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
     d84:	8f 92       	push	r8
     d86:	9f 92       	push	r9
     d88:	bf 92       	push	r11
     d8a:	cf 92       	push	r12
     d8c:	df 92       	push	r13
     d8e:	ef 92       	push	r14
     d90:	ff 92       	push	r15
     d92:	0f 93       	push	r16
     d94:	1f 93       	push	r17
     d96:	cf 93       	push	r28
     d98:	df 93       	push	r29
     d9a:	00 d0       	rcall	.+0      	; 0xd9c <xQueueGenericSend+0x18>
     d9c:	0f 92       	push	r0
     d9e:	0f 92       	push	r0
     da0:	cd b7       	in	r28, 0x3d	; 61
     da2:	de b7       	in	r29, 0x3e	; 62
     da4:	8c 01       	movw	r16, r24
     da6:	4b 01       	movw	r8, r22
     da8:	5d 83       	std	Y+5, r21	; 0x05
     daa:	4c 83       	std	Y+4, r20	; 0x04
     dac:	b2 2e       	mov	r11, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
     dae:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     db0:	ee 24       	eor	r14, r14
     db2:	e3 94       	inc	r14
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     db4:	cc 24       	eor	r12, r12
     db6:	dd 24       	eor	r13, r13
     db8:	68 94       	set
     dba:	c3 f8       	bld	r12, 3
     dbc:	c8 0e       	add	r12, r24
     dbe:	d9 1e       	adc	r13, r25
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     dc0:	0f b6       	in	r0, 0x3f	; 63
     dc2:	f8 94       	cli
     dc4:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     dc6:	f8 01       	movw	r30, r16
     dc8:	92 8d       	ldd	r25, Z+26	; 0x1a
     dca:	83 8d       	ldd	r24, Z+27	; 0x1b
     dcc:	98 17       	cp	r25, r24
     dce:	a8 f4       	brcc	.+42     	; 0xdfa <xQueueGenericSend+0x76>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     dd0:	c8 01       	movw	r24, r16
     dd2:	b4 01       	movw	r22, r8
     dd4:	4b 2d       	mov	r20, r11
     dd6:	0e 94 ff 05 	call	0xbfe	; 0xbfe <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     dda:	f8 01       	movw	r30, r16
     ddc:	81 89       	ldd	r24, Z+17	; 0x11
     dde:	88 23       	and	r24, r24
     de0:	41 f0       	breq	.+16     	; 0xdf2 <xQueueGenericSend+0x6e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
     de2:	c8 01       	movw	r24, r16
     de4:	41 96       	adiw	r24, 0x11	; 17
     de6:	0e 94 bd 0d 	call	0x1b7a	; 0x1b7a <xTaskRemoveFromEventList>
     dea:	81 30       	cpi	r24, 0x01	; 1
     dec:	11 f4       	brne	.+4      	; 0xdf2 <xQueueGenericSend+0x6e>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
     dee:	0e 94 bb 04 	call	0x976	; 0x976 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
     df2:	0f 90       	pop	r0
     df4:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
     df6:	81 e0       	ldi	r24, 0x01	; 1
     df8:	52 c0       	rjmp	.+164    	; 0xe9e <xQueueGenericSend+0x11a>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     dfa:	8c 81       	ldd	r24, Y+4	; 0x04
     dfc:	9d 81       	ldd	r25, Y+5	; 0x05
     dfe:	00 97       	sbiw	r24, 0x00	; 0
     e00:	21 f4       	brne	.+8      	; 0xe0a <xQueueGenericSend+0x86>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     e02:	0f 90       	pop	r0
     e04:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
     e06:	80 e0       	ldi	r24, 0x00	; 0
     e08:	4a c0       	rjmp	.+148    	; 0xe9e <xQueueGenericSend+0x11a>
				}
				else if( xEntryTimeSet == pdFALSE )
     e0a:	ff 20       	and	r15, r15
     e0c:	29 f4       	brne	.+10     	; 0xe18 <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     e0e:	ce 01       	movw	r24, r28
     e10:	01 96       	adiw	r24, 0x01	; 1
     e12:	0e 94 05 0e 	call	0x1c0a	; 0x1c0a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     e16:	fe 2c       	mov	r15, r14
				}
			}
		}
		taskEXIT_CRITICAL();
     e18:	0f 90       	pop	r0
     e1a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     e1c:	0e 94 0c 0b 	call	0x1618	; 0x1618 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     e20:	0f b6       	in	r0, 0x3f	; 63
     e22:	f8 94       	cli
     e24:	0f 92       	push	r0
     e26:	f8 01       	movw	r30, r16
     e28:	85 8d       	ldd	r24, Z+29	; 0x1d
     e2a:	8f 3f       	cpi	r24, 0xFF	; 255
     e2c:	09 f4       	brne	.+2      	; 0xe30 <xQueueGenericSend+0xac>
     e2e:	15 8e       	std	Z+29, r1	; 0x1d
     e30:	f8 01       	movw	r30, r16
     e32:	86 8d       	ldd	r24, Z+30	; 0x1e
     e34:	8f 3f       	cpi	r24, 0xFF	; 255
     e36:	09 f4       	brne	.+2      	; 0xe3a <xQueueGenericSend+0xb6>
     e38:	16 8e       	std	Z+30, r1	; 0x1e
     e3a:	0f 90       	pop	r0
     e3c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     e3e:	ce 01       	movw	r24, r28
     e40:	01 96       	adiw	r24, 0x01	; 1
     e42:	be 01       	movw	r22, r28
     e44:	6c 5f       	subi	r22, 0xFC	; 252
     e46:	7f 4f       	sbci	r23, 0xFF	; 255
     e48:	0e 94 10 0e 	call	0x1c20	; 0x1c20 <xTaskCheckForTimeOut>
     e4c:	88 23       	and	r24, r24
     e4e:	09 f5       	brne	.+66     	; 0xe92 <xQueueGenericSend+0x10e>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     e50:	0f b6       	in	r0, 0x3f	; 63
     e52:	f8 94       	cli
     e54:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
     e56:	f8 01       	movw	r30, r16
     e58:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     e5a:	0f 90       	pop	r0
     e5c:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
     e5e:	f8 01       	movw	r30, r16
     e60:	83 8d       	ldd	r24, Z+27	; 0x1b
     e62:	98 17       	cp	r25, r24
     e64:	81 f4       	brne	.+32     	; 0xe86 <xQueueGenericSend+0x102>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     e66:	6c 81       	ldd	r22, Y+4	; 0x04
     e68:	7d 81       	ldd	r23, Y+5	; 0x05
     e6a:	c6 01       	movw	r24, r12
     e6c:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
     e70:	c8 01       	movw	r24, r16
     e72:	0e 94 b1 05 	call	0xb62	; 0xb62 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
     e76:	0e 94 ea 0b 	call	0x17d4	; 0x17d4 <xTaskResumeAll>
     e7a:	88 23       	and	r24, r24
     e7c:	09 f0       	breq	.+2      	; 0xe80 <xQueueGenericSend+0xfc>
     e7e:	a0 cf       	rjmp	.-192    	; 0xdc0 <xQueueGenericSend+0x3c>
				{
					portYIELD_WITHIN_API();
     e80:	0e 94 bb 04 	call	0x976	; 0x976 <vPortYield>
     e84:	9d cf       	rjmp	.-198    	; 0xdc0 <xQueueGenericSend+0x3c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     e86:	c8 01       	movw	r24, r16
     e88:	0e 94 b1 05 	call	0xb62	; 0xb62 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     e8c:	0e 94 ea 0b 	call	0x17d4	; 0x17d4 <xTaskResumeAll>
     e90:	97 cf       	rjmp	.-210    	; 0xdc0 <xQueueGenericSend+0x3c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
     e92:	c8 01       	movw	r24, r16
     e94:	0e 94 b1 05 	call	0xb62	; 0xb62 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     e98:	0e 94 ea 0b 	call	0x17d4	; 0x17d4 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
     e9c:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     e9e:	0f 90       	pop	r0
     ea0:	0f 90       	pop	r0
     ea2:	0f 90       	pop	r0
     ea4:	0f 90       	pop	r0
     ea6:	0f 90       	pop	r0
     ea8:	df 91       	pop	r29
     eaa:	cf 91       	pop	r28
     eac:	1f 91       	pop	r17
     eae:	0f 91       	pop	r16
     eb0:	ff 90       	pop	r15
     eb2:	ef 90       	pop	r14
     eb4:	df 90       	pop	r13
     eb6:	cf 90       	pop	r12
     eb8:	bf 90       	pop	r11
     eba:	9f 90       	pop	r9
     ebc:	8f 90       	pop	r8
     ebe:	08 95       	ret

00000ec0 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
	{
     ec0:	cf 93       	push	r28
     ec2:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
     ec4:	8f e1       	ldi	r24, 0x1F	; 31
     ec6:	90 e0       	ldi	r25, 0x00	; 0
     ec8:	0e 94 0b 03 	call	0x616	; 0x616 <pvPortMalloc>
     ecc:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
     ece:	00 97       	sbiw	r24, 0x00	; 0
     ed0:	f9 f0       	breq	.+62     	; 0xf10 <xQueueCreateMutex+0x50>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
     ed2:	1b 82       	std	Y+3, r1	; 0x03
     ed4:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
     ed6:	19 82       	std	Y+1, r1	; 0x01
     ed8:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
     eda:	1d 82       	std	Y+5, r1	; 0x05
     edc:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->pcReadFrom = NULL;
     ede:	1f 82       	std	Y+7, r1	; 0x07
     ee0:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
     ee2:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
     ee4:	81 e0       	ldi	r24, 0x01	; 1
     ee6:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
     ee8:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
     eea:	8f ef       	ldi	r24, 0xFF	; 255
     eec:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
     eee:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->ucQueueType = ucQueueType;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
     ef0:	ce 01       	movw	r24, r28
     ef2:	08 96       	adiw	r24, 0x08	; 8
     ef4:	0e 94 43 03 	call	0x686	; 0x686 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
     ef8:	ce 01       	movw	r24, r28
     efa:	41 96       	adiw	r24, 0x11	; 17
     efc:	0e 94 43 03 	call	0x686	; 0x686 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
     f00:	ce 01       	movw	r24, r28
     f02:	60 e0       	ldi	r22, 0x00	; 0
     f04:	70 e0       	ldi	r23, 0x00	; 0
     f06:	40 e0       	ldi	r20, 0x00	; 0
     f08:	50 e0       	ldi	r21, 0x00	; 0
     f0a:	20 e0       	ldi	r18, 0x00	; 0
     f0c:	0e 94 c2 06 	call	0xd84	; 0xd84 <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
     f10:	8c 2f       	mov	r24, r28
     f12:	9d 2f       	mov	r25, r29
     f14:	df 91       	pop	r29
     f16:	cf 91       	pop	r28
     f18:	08 95       	ret

00000f1a <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
     f1a:	0f 93       	push	r16
     f1c:	1f 93       	push	r17
     f1e:	cf 93       	push	r28
     f20:	df 93       	push	r29
     f22:	ec 01       	movw	r28, r24
     f24:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     f26:	9a 8d       	ldd	r25, Y+26	; 0x1a
     f28:	8b 8d       	ldd	r24, Y+27	; 0x1b
     f2a:	98 17       	cp	r25, r24
     f2c:	e0 f4       	brcc	.+56     	; 0xf66 <xQueueGenericSendFromISR+0x4c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     f2e:	ce 01       	movw	r24, r28
     f30:	42 2f       	mov	r20, r18
     f32:	0e 94 ff 05 	call	0xbfe	; 0xbfe <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
     f36:	8e 8d       	ldd	r24, Y+30	; 0x1e
     f38:	8f 3f       	cpi	r24, 0xFF	; 255
     f3a:	81 f4       	brne	.+32     	; 0xf5c <xQueueGenericSendFromISR+0x42>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     f3c:	89 89       	ldd	r24, Y+17	; 0x11
     f3e:	88 23       	and	r24, r24
     f40:	a1 f0       	breq	.+40     	; 0xf6a <xQueueGenericSendFromISR+0x50>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     f42:	ce 01       	movw	r24, r28
     f44:	41 96       	adiw	r24, 0x11	; 17
     f46:	0e 94 bd 0d 	call	0x1b7a	; 0x1b7a <xTaskRemoveFromEventList>
     f4a:	88 23       	and	r24, r24
     f4c:	81 f0       	breq	.+32     	; 0xf6e <xQueueGenericSendFromISR+0x54>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						if( pxHigherPriorityTaskWoken != NULL )
     f4e:	01 15       	cp	r16, r1
     f50:	11 05       	cpc	r17, r1
     f52:	79 f0       	breq	.+30     	; 0xf72 <xQueueGenericSendFromISR+0x58>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
     f54:	81 e0       	ldi	r24, 0x01	; 1
     f56:	f8 01       	movw	r30, r16
     f58:	80 83       	st	Z, r24
     f5a:	0c c0       	rjmp	.+24     	; 0xf74 <xQueueGenericSendFromISR+0x5a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
     f5c:	8e 8d       	ldd	r24, Y+30	; 0x1e
     f5e:	8f 5f       	subi	r24, 0xFF	; 255
     f60:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
     f62:	81 e0       	ldi	r24, 0x01	; 1
     f64:	07 c0       	rjmp	.+14     	; 0xf74 <xQueueGenericSendFromISR+0x5a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
     f66:	80 e0       	ldi	r24, 0x00	; 0
     f68:	05 c0       	rjmp	.+10     	; 0xf74 <xQueueGenericSendFromISR+0x5a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
     f6a:	81 e0       	ldi	r24, 0x01	; 1
     f6c:	03 c0       	rjmp	.+6      	; 0xf74 <xQueueGenericSendFromISR+0x5a>
     f6e:	81 e0       	ldi	r24, 0x01	; 1
     f70:	01 c0       	rjmp	.+2      	; 0xf74 <xQueueGenericSendFromISR+0x5a>
     f72:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     f74:	df 91       	pop	r29
     f76:	cf 91       	pop	r28
     f78:	1f 91       	pop	r17
     f7a:	0f 91       	pop	r16
     f7c:	08 95       	ret

00000f7e <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
     f7e:	8f 92       	push	r8
     f80:	9f 92       	push	r9
     f82:	bf 92       	push	r11
     f84:	cf 92       	push	r12
     f86:	df 92       	push	r13
     f88:	ef 92       	push	r14
     f8a:	ff 92       	push	r15
     f8c:	0f 93       	push	r16
     f8e:	1f 93       	push	r17
     f90:	cf 93       	push	r28
     f92:	df 93       	push	r29
     f94:	00 d0       	rcall	.+0      	; 0xf96 <xQueueGenericReceive+0x18>
     f96:	0f 92       	push	r0
     f98:	0f 92       	push	r0
     f9a:	cd b7       	in	r28, 0x3d	; 61
     f9c:	de b7       	in	r29, 0x3e	; 62
     f9e:	8c 01       	movw	r16, r24
     fa0:	4b 01       	movw	r8, r22
     fa2:	5d 83       	std	Y+5, r21	; 0x05
     fa4:	4c 83       	std	Y+4, r20	; 0x04
     fa6:	b2 2e       	mov	r11, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
     fa8:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     faa:	ee 24       	eor	r14, r14
     fac:	e3 94       	inc	r14
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     fae:	0f 2e       	mov	r0, r31
     fb0:	f1 e1       	ldi	r31, 0x11	; 17
     fb2:	cf 2e       	mov	r12, r31
     fb4:	dd 24       	eor	r13, r13
     fb6:	f0 2d       	mov	r31, r0
     fb8:	c8 0e       	add	r12, r24
     fba:	d9 1e       	adc	r13, r25
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     fbc:	0f b6       	in	r0, 0x3f	; 63
     fbe:	f8 94       	cli
     fc0:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     fc2:	f8 01       	movw	r30, r16
     fc4:	82 8d       	ldd	r24, Z+26	; 0x1a
     fc6:	88 23       	and	r24, r24
     fc8:	a1 f1       	breq	.+104    	; 0x1032 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
     fca:	e6 80       	ldd	r14, Z+6	; 0x06
     fcc:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     fce:	c8 01       	movw	r24, r16
     fd0:	b4 01       	movw	r22, r8
     fd2:	0e 94 82 05 	call	0xb04	; 0xb04 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     fd6:	bb 20       	and	r11, r11
     fd8:	d1 f4       	brne	.+52     	; 0x100e <xQueueGenericReceive+0x90>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
     fda:	f8 01       	movw	r30, r16
     fdc:	82 8d       	ldd	r24, Z+26	; 0x1a
     fde:	81 50       	subi	r24, 0x01	; 1
     fe0:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     fe2:	80 81       	ld	r24, Z
     fe4:	91 81       	ldd	r25, Z+1	; 0x01
     fe6:	00 97       	sbiw	r24, 0x00	; 0
     fe8:	29 f4       	brne	.+10     	; 0xff4 <xQueueGenericReceive+0x76>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
     fea:	0e 94 6b 0e 	call	0x1cd6	; 0x1cd6 <xTaskGetCurrentTaskHandle>
     fee:	f8 01       	movw	r30, r16
     ff0:	93 83       	std	Z+3, r25	; 0x03
     ff2:	82 83       	std	Z+2, r24	; 0x02
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     ff4:	f8 01       	movw	r30, r16
     ff6:	80 85       	ldd	r24, Z+8	; 0x08
     ff8:	88 23       	and	r24, r24
     ffa:	b9 f0       	breq	.+46     	; 0x102a <xQueueGenericReceive+0xac>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     ffc:	c8 01       	movw	r24, r16
     ffe:	08 96       	adiw	r24, 0x08	; 8
    1000:	0e 94 bd 0d 	call	0x1b7a	; 0x1b7a <xTaskRemoveFromEventList>
    1004:	81 30       	cpi	r24, 0x01	; 1
    1006:	89 f4       	brne	.+34     	; 0x102a <xQueueGenericReceive+0xac>
						{
							portYIELD_WITHIN_API();
    1008:	0e 94 bb 04 	call	0x976	; 0x976 <vPortYield>
    100c:	0e c0       	rjmp	.+28     	; 0x102a <xQueueGenericReceive+0xac>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    100e:	f8 01       	movw	r30, r16
    1010:	f7 82       	std	Z+7, r15	; 0x07
    1012:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1014:	81 89       	ldd	r24, Z+17	; 0x11
    1016:	88 23       	and	r24, r24
    1018:	41 f0       	breq	.+16     	; 0x102a <xQueueGenericReceive+0xac>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    101a:	c8 01       	movw	r24, r16
    101c:	41 96       	adiw	r24, 0x11	; 17
    101e:	0e 94 bd 0d 	call	0x1b7a	; 0x1b7a <xTaskRemoveFromEventList>
    1022:	88 23       	and	r24, r24
    1024:	11 f0       	breq	.+4      	; 0x102a <xQueueGenericReceive+0xac>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1026:	0e 94 bb 04 	call	0x976	; 0x976 <vPortYield>
						}
					}
				}

				taskEXIT_CRITICAL();
    102a:	0f 90       	pop	r0
    102c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    102e:	81 e0       	ldi	r24, 0x01	; 1
    1030:	5f c0       	rjmp	.+190    	; 0x10f0 <xQueueGenericReceive+0x172>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1032:	8c 81       	ldd	r24, Y+4	; 0x04
    1034:	9d 81       	ldd	r25, Y+5	; 0x05
    1036:	00 97       	sbiw	r24, 0x00	; 0
    1038:	21 f4       	brne	.+8      	; 0x1042 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    103a:	0f 90       	pop	r0
    103c:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    103e:	80 e0       	ldi	r24, 0x00	; 0
    1040:	57 c0       	rjmp	.+174    	; 0x10f0 <xQueueGenericReceive+0x172>
				}
				else if( xEntryTimeSet == pdFALSE )
    1042:	ff 20       	and	r15, r15
    1044:	29 f4       	brne	.+10     	; 0x1050 <xQueueGenericReceive+0xd2>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1046:	ce 01       	movw	r24, r28
    1048:	01 96       	adiw	r24, 0x01	; 1
    104a:	0e 94 05 0e 	call	0x1c0a	; 0x1c0a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    104e:	fe 2c       	mov	r15, r14
				}
			}
		}
		taskEXIT_CRITICAL();
    1050:	0f 90       	pop	r0
    1052:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1054:	0e 94 0c 0b 	call	0x1618	; 0x1618 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1058:	0f b6       	in	r0, 0x3f	; 63
    105a:	f8 94       	cli
    105c:	0f 92       	push	r0
    105e:	f8 01       	movw	r30, r16
    1060:	85 8d       	ldd	r24, Z+29	; 0x1d
    1062:	8f 3f       	cpi	r24, 0xFF	; 255
    1064:	09 f4       	brne	.+2      	; 0x1068 <xQueueGenericReceive+0xea>
    1066:	15 8e       	std	Z+29, r1	; 0x1d
    1068:	f8 01       	movw	r30, r16
    106a:	86 8d       	ldd	r24, Z+30	; 0x1e
    106c:	8f 3f       	cpi	r24, 0xFF	; 255
    106e:	09 f4       	brne	.+2      	; 0x1072 <xQueueGenericReceive+0xf4>
    1070:	16 8e       	std	Z+30, r1	; 0x1e
    1072:	0f 90       	pop	r0
    1074:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1076:	ce 01       	movw	r24, r28
    1078:	01 96       	adiw	r24, 0x01	; 1
    107a:	be 01       	movw	r22, r28
    107c:	6c 5f       	subi	r22, 0xFC	; 252
    107e:	7f 4f       	sbci	r23, 0xFF	; 255
    1080:	0e 94 10 0e 	call	0x1c20	; 0x1c20 <xTaskCheckForTimeOut>
    1084:	88 23       	and	r24, r24
    1086:	71 f5       	brne	.+92     	; 0x10e4 <xQueueGenericReceive+0x166>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1088:	0f b6       	in	r0, 0x3f	; 63
    108a:	f8 94       	cli
    108c:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    108e:	f8 01       	movw	r30, r16
    1090:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    1092:	0f 90       	pop	r0
    1094:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1096:	88 23       	and	r24, r24
    1098:	f9 f4       	brne	.+62     	; 0x10d8 <xQueueGenericReceive+0x15a>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    109a:	f8 01       	movw	r30, r16
    109c:	80 81       	ld	r24, Z
    109e:	91 81       	ldd	r25, Z+1	; 0x01
    10a0:	00 97       	sbiw	r24, 0x00	; 0
    10a2:	51 f4       	brne	.+20     	; 0x10b8 <xQueueGenericReceive+0x13a>
					{
						portENTER_CRITICAL();
    10a4:	0f b6       	in	r0, 0x3f	; 63
    10a6:	f8 94       	cli
    10a8:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    10aa:	f8 01       	movw	r30, r16
    10ac:	82 81       	ldd	r24, Z+2	; 0x02
    10ae:	93 81       	ldd	r25, Z+3	; 0x03
    10b0:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    10b4:	0f 90       	pop	r0
    10b6:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    10b8:	6c 81       	ldd	r22, Y+4	; 0x04
    10ba:	7d 81       	ldd	r23, Y+5	; 0x05
    10bc:	c6 01       	movw	r24, r12
    10be:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    10c2:	c8 01       	movw	r24, r16
    10c4:	0e 94 b1 05 	call	0xb62	; 0xb62 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    10c8:	0e 94 ea 0b 	call	0x17d4	; 0x17d4 <xTaskResumeAll>
    10cc:	88 23       	and	r24, r24
    10ce:	09 f0       	breq	.+2      	; 0x10d2 <xQueueGenericReceive+0x154>
    10d0:	75 cf       	rjmp	.-278    	; 0xfbc <xQueueGenericReceive+0x3e>
				{
					portYIELD_WITHIN_API();
    10d2:	0e 94 bb 04 	call	0x976	; 0x976 <vPortYield>
    10d6:	72 cf       	rjmp	.-284    	; 0xfbc <xQueueGenericReceive+0x3e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    10d8:	c8 01       	movw	r24, r16
    10da:	0e 94 b1 05 	call	0xb62	; 0xb62 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    10de:	0e 94 ea 0b 	call	0x17d4	; 0x17d4 <xTaskResumeAll>
    10e2:	6c cf       	rjmp	.-296    	; 0xfbc <xQueueGenericReceive+0x3e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    10e4:	c8 01       	movw	r24, r16
    10e6:	0e 94 b1 05 	call	0xb62	; 0xb62 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    10ea:	0e 94 ea 0b 	call	0x17d4	; 0x17d4 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    10ee:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    10f0:	0f 90       	pop	r0
    10f2:	0f 90       	pop	r0
    10f4:	0f 90       	pop	r0
    10f6:	0f 90       	pop	r0
    10f8:	0f 90       	pop	r0
    10fa:	df 91       	pop	r29
    10fc:	cf 91       	pop	r28
    10fe:	1f 91       	pop	r17
    1100:	0f 91       	pop	r16
    1102:	ff 90       	pop	r15
    1104:	ef 90       	pop	r14
    1106:	df 90       	pop	r13
    1108:	cf 90       	pop	r12
    110a:	bf 90       	pop	r11
    110c:	9f 90       	pop	r9
    110e:	8f 90       	pop	r8
    1110:	08 95       	ret

00001112 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
{
    1112:	0f 93       	push	r16
    1114:	1f 93       	push	r17
    1116:	cf 93       	push	r28
    1118:	df 93       	push	r29
    111a:	ec 01       	movw	r28, r24
    111c:	8a 01       	movw	r16, r20
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    111e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1120:	88 23       	and	r24, r24
    1122:	f1 f0       	breq	.+60     	; 0x1160 <xQueueReceiveFromISR+0x4e>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1124:	ce 01       	movw	r24, r28
    1126:	0e 94 82 05 	call	0xb04	; 0xb04 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    112a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    112c:	81 50       	subi	r24, 0x01	; 1
    112e:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1130:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1132:	8f 3f       	cpi	r24, 0xFF	; 255
    1134:	81 f4       	brne	.+32     	; 0x1156 <xQueueReceiveFromISR+0x44>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1136:	88 85       	ldd	r24, Y+8	; 0x08
    1138:	88 23       	and	r24, r24
    113a:	a1 f0       	breq	.+40     	; 0x1164 <xQueueReceiveFromISR+0x52>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    113c:	ce 01       	movw	r24, r28
    113e:	08 96       	adiw	r24, 0x08	; 8
    1140:	0e 94 bd 0d 	call	0x1b7a	; 0x1b7a <xTaskRemoveFromEventList>
    1144:	88 23       	and	r24, r24
    1146:	81 f0       	breq	.+32     	; 0x1168 <xQueueReceiveFromISR+0x56>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1148:	01 15       	cp	r16, r1
    114a:	11 05       	cpc	r17, r1
    114c:	79 f0       	breq	.+30     	; 0x116c <xQueueReceiveFromISR+0x5a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    114e:	81 e0       	ldi	r24, 0x01	; 1
    1150:	f8 01       	movw	r30, r16
    1152:	80 83       	st	Z, r24
    1154:	0c c0       	rjmp	.+24     	; 0x116e <xQueueReceiveFromISR+0x5c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1156:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1158:	8f 5f       	subi	r24, 0xFF	; 255
    115a:	8d 8f       	std	Y+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    115c:	81 e0       	ldi	r24, 0x01	; 1
    115e:	07 c0       	rjmp	.+14     	; 0x116e <xQueueReceiveFromISR+0x5c>
		}
		else
		{
			xReturn = pdFAIL;
    1160:	80 e0       	ldi	r24, 0x00	; 0
    1162:	05 c0       	rjmp	.+10     	; 0x116e <xQueueReceiveFromISR+0x5c>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    1164:	81 e0       	ldi	r24, 0x01	; 1
    1166:	03 c0       	rjmp	.+6      	; 0x116e <xQueueReceiveFromISR+0x5c>
    1168:	81 e0       	ldi	r24, 0x01	; 1
    116a:	01 c0       	rjmp	.+2      	; 0x116e <xQueueReceiveFromISR+0x5c>
    116c:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    116e:	df 91       	pop	r29
    1170:	cf 91       	pop	r28
    1172:	1f 91       	pop	r17
    1174:	0f 91       	pop	r16
    1176:	08 95       	ret

00001178 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1178:	0f b6       	in	r0, 0x3f	; 63
    117a:	f8 94       	cli
    117c:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    117e:	fc 01       	movw	r30, r24
    1180:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    1182:	0f 90       	pop	r0
    1184:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1186:	08 95       	ret

00001188 <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    1188:	fc 01       	movw	r30, r24
    118a:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    118c:	08 95       	ret

0000118e <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    118e:	cf 93       	push	r28
    1190:	df 93       	push	r29
    1192:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    1194:	88 81       	ld	r24, Y
    1196:	99 81       	ldd	r25, Y+1	; 0x01
    1198:	0e 94 34 03 	call	0x668	; 0x668 <vPortFree>
	vPortFree( pxQueue );
    119c:	ce 01       	movw	r24, r28
    119e:	0e 94 34 03 	call	0x668	; 0x668 <vPortFree>
}
    11a2:	df 91       	pop	r29
    11a4:	cf 91       	pop	r28
    11a6:	08 95       	ret

000011a8 <xQueueIsQueueEmptyFromISR>:
signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    11a8:	fc 01       	movw	r30, r24
    11aa:	92 8d       	ldd	r25, Z+26	; 0x1a
    11ac:	81 e0       	ldi	r24, 0x01	; 1
    11ae:	91 11       	cpse	r25, r1
    11b0:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    11b2:	08 95       	ret

000011b4 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    11b4:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    11b6:	22 8d       	ldd	r18, Z+26	; 0x1a
    11b8:	81 e0       	ldi	r24, 0x01	; 1
    11ba:	93 8d       	ldd	r25, Z+27	; 0x1b
    11bc:	29 13       	cpse	r18, r25
    11be:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    11c0:	08 95       	ret

000011c2 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    11c2:	cf 93       	push	r28
    11c4:	df 93       	push	r29
    11c6:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    11c8:	e0 91 4a 1a 	lds	r30, 0x1A4A
    11cc:	f0 91 4b 1a 	lds	r31, 0x1A4B
    11d0:	93 83       	std	Z+3, r25	; 0x03
    11d2:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    11d4:	80 91 52 1a 	lds	r24, 0x1A52
    11d8:	90 91 53 1a 	lds	r25, 0x1A53
    11dc:	c8 17       	cp	r28, r24
    11de:	d9 07       	cpc	r29, r25
    11e0:	68 f4       	brcc	.+26     	; 0x11fc <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    11e2:	80 91 55 1a 	lds	r24, 0x1A55
    11e6:	90 91 56 1a 	lds	r25, 0x1A56
    11ea:	60 91 4a 1a 	lds	r22, 0x1A4A
    11ee:	70 91 4b 1a 	lds	r23, 0x1A4B
    11f2:	6e 5f       	subi	r22, 0xFE	; 254
    11f4:	7f 4f       	sbci	r23, 0xFF	; 255
    11f6:	0e 94 7e 03 	call	0x6fc	; 0x6fc <vListInsert>
    11fa:	17 c0       	rjmp	.+46     	; 0x122a <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    11fc:	80 91 57 1a 	lds	r24, 0x1A57
    1200:	90 91 58 1a 	lds	r25, 0x1A58
    1204:	60 91 4a 1a 	lds	r22, 0x1A4A
    1208:	70 91 4b 1a 	lds	r23, 0x1A4B
    120c:	6e 5f       	subi	r22, 0xFE	; 254
    120e:	7f 4f       	sbci	r23, 0xFF	; 255
    1210:	0e 94 7e 03 	call	0x6fc	; 0x6fc <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    1214:	80 91 0c 02 	lds	r24, 0x020C
    1218:	90 91 0d 02 	lds	r25, 0x020D
    121c:	c8 17       	cp	r28, r24
    121e:	d9 07       	cpc	r29, r25
    1220:	20 f4       	brcc	.+8      	; 0x122a <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
    1222:	d0 93 0d 02 	sts	0x020D, r29
    1226:	c0 93 0c 02 	sts	0x020C, r28
		}
	}
}
    122a:	df 91       	pop	r29
    122c:	cf 91       	pop	r28
    122e:	08 95       	ret

00001230 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    1230:	cb e5       	ldi	r28, 0x5B	; 91
    1232:	da e1       	ldi	r29, 0x1A	; 26
    1234:	88 81       	ld	r24, Y
    1236:	82 30       	cpi	r24, 0x02	; 2
    1238:	e8 f3       	brcs	.-6      	; 0x1234 <prvIdleTask+0x4>
			{
				taskYIELD();
    123a:	0e 94 bb 04 	call	0x976	; 0x976 <vPortYield>
    123e:	fa cf       	rjmp	.-12     	; 0x1234 <prvIdleTask+0x4>

00001240 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    1240:	4f 92       	push	r4
    1242:	5f 92       	push	r5
    1244:	6f 92       	push	r6
    1246:	7f 92       	push	r7
    1248:	8f 92       	push	r8
    124a:	9f 92       	push	r9
    124c:	bf 92       	push	r11
    124e:	cf 92       	push	r12
    1250:	df 92       	push	r13
    1252:	ef 92       	push	r14
    1254:	ff 92       	push	r15
    1256:	0f 93       	push	r16
    1258:	1f 93       	push	r17
    125a:	cf 93       	push	r28
    125c:	df 93       	push	r29
    125e:	2c 01       	movw	r4, r24
    1260:	4b 01       	movw	r8, r22
    1262:	ea 01       	movw	r28, r20
    1264:	39 01       	movw	r6, r18
    1266:	b0 2e       	mov	r11, r16
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    1268:	8a e2       	ldi	r24, 0x2A	; 42
    126a:	90 e0       	ldi	r25, 0x00	; 0
    126c:	0e 94 0b 03 	call	0x616	; 0x616 <pvPortMalloc>
    1270:	8c 01       	movw	r16, r24

	if( pxNewTCB != NULL )
    1272:	00 97       	sbiw	r24, 0x00	; 0
    1274:	09 f4       	brne	.+2      	; 0x1278 <xTaskGenericCreate+0x38>
    1276:	e3 c0       	rjmp	.+454    	; 0x143e <xTaskGenericCreate+0x1fe>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    1278:	c1 14       	cp	r12, r1
    127a:	d1 04       	cpc	r13, r1
    127c:	09 f0       	breq	.+2      	; 0x1280 <xTaskGenericCreate+0x40>
    127e:	f4 c0       	rjmp	.+488    	; 0x1468 <xTaskGenericCreate+0x228>
    1280:	ce 01       	movw	r24, r28
    1282:	0e 94 0b 03 	call	0x616	; 0x616 <pvPortMalloc>
    1286:	6c 01       	movw	r12, r24
    1288:	f8 01       	movw	r30, r16
    128a:	90 8f       	std	Z+24, r25	; 0x18
    128c:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    128e:	00 97       	sbiw	r24, 0x00	; 0
    1290:	29 f4       	brne	.+10     	; 0x129c <xTaskGenericCreate+0x5c>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    1292:	c8 01       	movw	r24, r16
    1294:	0e 94 34 03 	call	0x668	; 0x668 <vPortFree>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1298:	8f ef       	ldi	r24, 0xFF	; 255
    129a:	d6 c0       	rjmp	.+428    	; 0x1448 <xTaskGenericCreate+0x208>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    129c:	c6 01       	movw	r24, r12
    129e:	65 ea       	ldi	r22, 0xA5	; 165
    12a0:	70 e0       	ldi	r23, 0x00	; 0
    12a2:	ae 01       	movw	r20, r28
    12a4:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    12a8:	9e 01       	movw	r18, r28
    12aa:	21 50       	subi	r18, 0x01	; 1
    12ac:	30 40       	sbci	r19, 0x00	; 0
    12ae:	f8 01       	movw	r30, r16
    12b0:	87 89       	ldd	r24, Z+23	; 0x17
    12b2:	90 8d       	ldd	r25, Z+24	; 0x18
    12b4:	6c 01       	movw	r12, r24
    12b6:	c2 0e       	add	r12, r18
    12b8:	d3 1e       	adc	r13, r19
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    12ba:	c8 01       	movw	r24, r16
    12bc:	49 96       	adiw	r24, 0x19	; 25
    12be:	b4 01       	movw	r22, r8
    12c0:	40 e1       	ldi	r20, 0x10	; 16
    12c2:	50 e0       	ldi	r21, 0x00	; 0
    12c4:	0e 94 0f 0f 	call	0x1e1e	; 0x1e1e <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    12c8:	f8 01       	movw	r30, r16
    12ca:	10 a6       	lds	r17, 0xb0
    12cc:	cb 2d       	mov	r28, r11
    12ce:	f3 e0       	ldi	r31, 0x03	; 3
    12d0:	fb 15       	cp	r31, r11
    12d2:	08 f4       	brcc	.+2      	; 0x12d6 <xTaskGenericCreate+0x96>
    12d4:	c3 e0       	ldi	r28, 0x03	; 3
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
    12d6:	f8 01       	movw	r30, r16
    12d8:	c6 8b       	std	Z+22, r28	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    12da:	c1 a7       	lds	r28, 0x71
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    12dc:	88 24       	eor	r8, r8
    12de:	99 24       	eor	r9, r9
    12e0:	68 94       	set
    12e2:	81 f8       	bld	r8, 1
    12e4:	80 0e       	add	r8, r16
    12e6:	91 1e       	adc	r9, r17
    12e8:	c4 01       	movw	r24, r8
    12ea:	0e 94 51 03 	call	0x6a2	; 0x6a2 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    12ee:	c8 01       	movw	r24, r16
    12f0:	0c 96       	adiw	r24, 0x0c	; 12
    12f2:	0e 94 51 03 	call	0x6a2	; 0x6a2 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    12f6:	f8 01       	movw	r30, r16
    12f8:	11 87       	std	Z+9, r17	; 0x09
    12fa:	00 87       	std	Z+8, r16	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    12fc:	84 e0       	ldi	r24, 0x04	; 4
    12fe:	90 e0       	ldi	r25, 0x00	; 0
    1300:	8c 1b       	sub	r24, r28
    1302:	91 09       	sbc	r25, r1
    1304:	95 87       	std	Z+13, r25	; 0x0d
    1306:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    1308:	13 8b       	std	Z+19, r17	; 0x13
    130a:	02 8b       	std	Z+18, r16	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    130c:	c6 01       	movw	r24, r12
    130e:	b2 01       	movw	r22, r4
    1310:	a3 01       	movw	r20, r6
    1312:	0e 94 e2 03 	call	0x7c4	; 0x7c4 <pxPortInitialiseStack>
    1316:	f8 01       	movw	r30, r16
    1318:	91 83       	std	Z+1, r25	; 0x01
    131a:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    131c:	e1 14       	cp	r14, r1
    131e:	f1 04       	cpc	r15, r1
    1320:	19 f0       	breq	.+6      	; 0x1328 <xTaskGenericCreate+0xe8>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    1322:	f7 01       	movw	r30, r14
    1324:	11 83       	std	Z+1, r17	; 0x01
    1326:	00 83       	st	Z, r16
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    1328:	0f b6       	in	r0, 0x3f	; 63
    132a:	f8 94       	cli
    132c:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    132e:	80 91 54 1a 	lds	r24, 0x1A54
    1332:	8f 5f       	subi	r24, 0xFF	; 255
    1334:	80 93 54 1a 	sts	0x1A54, r24
			if( pxCurrentTCB == NULL )
    1338:	80 91 4a 1a 	lds	r24, 0x1A4A
    133c:	90 91 4b 1a 	lds	r25, 0x1A4B
    1340:	00 97       	sbiw	r24, 0x00	; 0
    1342:	d9 f5       	brne	.+118    	; 0x13ba <xTaskGenericCreate+0x17a>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    1344:	10 93 4b 1a 	sts	0x1A4B, r17
    1348:	00 93 4a 1a 	sts	0x1A4A, r16

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    134c:	80 91 54 1a 	lds	r24, 0x1A54
    1350:	81 30       	cpi	r24, 0x01	; 1
    1352:	09 f0       	breq	.+2      	; 0x1356 <xTaskGenericCreate+0x116>
    1354:	41 c0       	rjmp	.+130    	; 0x13d8 <xTaskGenericCreate+0x198>
    1356:	c0 e0       	ldi	r28, 0x00	; 0
    1358:	d0 e0       	ldi	r29, 0x00	; 0
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    135a:	ce 01       	movw	r24, r28
    135c:	88 0f       	add	r24, r24
    135e:	99 1f       	adc	r25, r25
    1360:	88 0f       	add	r24, r24
    1362:	99 1f       	adc	r25, r25
    1364:	88 0f       	add	r24, r24
    1366:	99 1f       	adc	r25, r25
    1368:	8c 0f       	add	r24, r28
    136a:	9d 1f       	adc	r25, r29
    136c:	85 5a       	subi	r24, 0xA5	; 165
    136e:	95 4e       	sbci	r25, 0xE5	; 229
    1370:	0e 94 43 03 	call	0x686	; 0x686 <vListInitialise>
    1374:	21 96       	adiw	r28, 0x01	; 1

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    1376:	c4 30       	cpi	r28, 0x04	; 4
    1378:	d1 05       	cpc	r29, r1
    137a:	79 f7       	brne	.-34     	; 0x135a <xTaskGenericCreate+0x11a>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    137c:	cf e7       	ldi	r28, 0x7F	; 127
    137e:	da e1       	ldi	r29, 0x1A	; 26
    1380:	ce 01       	movw	r24, r28
    1382:	0e 94 43 03 	call	0x686	; 0x686 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    1386:	0f 2e       	mov	r0, r31
    1388:	f8 e8       	ldi	r31, 0x88	; 136
    138a:	ef 2e       	mov	r14, r31
    138c:	fa e1       	ldi	r31, 0x1A	; 26
    138e:	ff 2e       	mov	r15, r31
    1390:	f0 2d       	mov	r31, r0
    1392:	c7 01       	movw	r24, r14
    1394:	0e 94 43 03 	call	0x686	; 0x686 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    1398:	81 e9       	ldi	r24, 0x91	; 145
    139a:	9a e1       	ldi	r25, 0x1A	; 26
    139c:	0e 94 43 03 	call	0x686	; 0x686 <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
    13a0:	8a e9       	ldi	r24, 0x9A	; 154
    13a2:	9a e1       	ldi	r25, 0x1A	; 26
    13a4:	0e 94 43 03 	call	0x686	; 0x686 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    13a8:	d0 93 58 1a 	sts	0x1A58, r29
    13ac:	c0 93 57 1a 	sts	0x1A57, r28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    13b0:	f0 92 56 1a 	sts	0x1A56, r15
    13b4:	e0 92 55 1a 	sts	0x1A55, r14
    13b8:	0f c0       	rjmp	.+30     	; 0x13d8 <xTaskGenericCreate+0x198>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    13ba:	80 91 50 1a 	lds	r24, 0x1A50
    13be:	88 23       	and	r24, r24
    13c0:	59 f4       	brne	.+22     	; 0x13d8 <xTaskGenericCreate+0x198>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    13c2:	e0 91 4a 1a 	lds	r30, 0x1A4A
    13c6:	f0 91 4b 1a 	lds	r31, 0x1A4B
    13ca:	86 89       	ldd	r24, Z+22	; 0x16
    13cc:	b8 16       	cp	r11, r24
    13ce:	20 f0       	brcs	.+8      	; 0x13d8 <xTaskGenericCreate+0x198>
					{
						pxCurrentTCB = pxNewTCB;
    13d0:	10 93 4b 1a 	sts	0x1A4B, r17
    13d4:	00 93 4a 1a 	sts	0x1A4A, r16
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    13d8:	f8 01       	movw	r30, r16
    13da:	86 89       	ldd	r24, Z+22	; 0x16
    13dc:	90 91 59 1a 	lds	r25, 0x1A59
    13e0:	98 17       	cp	r25, r24
    13e2:	10 f4       	brcc	.+4      	; 0x13e8 <xTaskGenericCreate+0x1a8>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    13e4:	80 93 59 1a 	sts	0x1A59, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    13e8:	90 91 5a 1a 	lds	r25, 0x1A5A
    13ec:	9f 5f       	subi	r25, 0xFF	; 255
    13ee:	90 93 5a 1a 	sts	0x1A5A, r25

			prvAddTaskToReadyQueue( pxNewTCB );
    13f2:	90 91 51 1a 	lds	r25, 0x1A51
    13f6:	98 17       	cp	r25, r24
    13f8:	10 f4       	brcc	.+4      	; 0x13fe <xTaskGenericCreate+0x1be>
    13fa:	80 93 51 1a 	sts	0x1A51, r24
    13fe:	90 e0       	ldi	r25, 0x00	; 0
    1400:	9c 01       	movw	r18, r24
    1402:	22 0f       	add	r18, r18
    1404:	33 1f       	adc	r19, r19
    1406:	22 0f       	add	r18, r18
    1408:	33 1f       	adc	r19, r19
    140a:	22 0f       	add	r18, r18
    140c:	33 1f       	adc	r19, r19
    140e:	82 0f       	add	r24, r18
    1410:	93 1f       	adc	r25, r19
    1412:	85 5a       	subi	r24, 0xA5	; 165
    1414:	95 4e       	sbci	r25, 0xE5	; 229
    1416:	b4 01       	movw	r22, r8
    1418:	0e 94 55 03 	call	0x6aa	; 0x6aa <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    141c:	0f 90       	pop	r0
    141e:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    1420:	80 91 50 1a 	lds	r24, 0x1A50
    1424:	88 23       	and	r24, r24
    1426:	69 f0       	breq	.+26     	; 0x1442 <xTaskGenericCreate+0x202>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1428:	e0 91 4a 1a 	lds	r30, 0x1A4A
    142c:	f0 91 4b 1a 	lds	r31, 0x1A4B
    1430:	86 89       	ldd	r24, Z+22	; 0x16
    1432:	8b 15       	cp	r24, r11
    1434:	40 f4       	brcc	.+16     	; 0x1446 <xTaskGenericCreate+0x206>
			{
				portYIELD_WITHIN_API();
    1436:	0e 94 bb 04 	call	0x976	; 0x976 <vPortYield>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    143a:	81 e0       	ldi	r24, 0x01	; 1
    143c:	05 c0       	rjmp	.+10     	; 0x1448 <xTaskGenericCreate+0x208>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    143e:	8f ef       	ldi	r24, 0xFF	; 255
    1440:	03 c0       	rjmp	.+6      	; 0x1448 <xTaskGenericCreate+0x208>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    1442:	81 e0       	ldi	r24, 0x01	; 1
    1444:	01 c0       	rjmp	.+2      	; 0x1448 <xTaskGenericCreate+0x208>
    1446:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    1448:	df 91       	pop	r29
    144a:	cf 91       	pop	r28
    144c:	1f 91       	pop	r17
    144e:	0f 91       	pop	r16
    1450:	ff 90       	pop	r15
    1452:	ef 90       	pop	r14
    1454:	df 90       	pop	r13
    1456:	cf 90       	pop	r12
    1458:	bf 90       	pop	r11
    145a:	9f 90       	pop	r9
    145c:	8f 90       	pop	r8
    145e:	7f 90       	pop	r7
    1460:	6f 90       	pop	r6
    1462:	5f 90       	pop	r5
    1464:	4f 90       	pop	r4
    1466:	08 95       	ret
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    1468:	fc 01       	movw	r30, r24
    146a:	d0 8e       	std	Z+24, r13	; 0x18
    146c:	c7 8a       	std	Z+23, r12	; 0x17
    146e:	16 cf       	rjmp	.-468    	; 0x129c <xTaskGenericCreate+0x5c>

00001470 <xTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
    1470:	fc 01       	movw	r30, r24
		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    1472:	82 85       	ldd	r24, Z+10	; 0x0a
    1474:	93 85       	ldd	r25, Z+11	; 0x0b
    1476:	2a e1       	ldi	r18, 0x1A	; 26
    1478:	8a 39       	cpi	r24, 0x9A	; 154
    147a:	92 07       	cpc	r25, r18
    147c:	61 f4       	brne	.+24     	; 0x1496 <xTaskIsTaskSuspended+0x26>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
    147e:	24 89       	ldd	r18, Z+20	; 0x14
    1480:	35 89       	ldd	r19, Z+21	; 0x15
    1482:	8a e1       	ldi	r24, 0x1A	; 26
    1484:	21 39       	cpi	r18, 0x91	; 145
    1486:	38 07       	cpc	r19, r24
    1488:	41 f0       	breq	.+16     	; 0x149a <xTaskIsTaskSuspended+0x2a>

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
	portBASE_TYPE xReturn = pdFALSE;
    148a:	81 e0       	ldi	r24, 0x01	; 1
    148c:	21 15       	cp	r18, r1
    148e:	31 05       	cpc	r19, r1
    1490:	29 f0       	breq	.+10     	; 0x149c <xTaskIsTaskSuspended+0x2c>
    1492:	80 e0       	ldi	r24, 0x00	; 0
    1494:	08 95       	ret
    1496:	80 e0       	ldi	r24, 0x00	; 0
    1498:	08 95       	ret
    149a:	80 e0       	ldi	r24, 0x00	; 0
				}
			}
		}

		return xReturn;
	}
    149c:	08 95       	ret

0000149e <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
    149e:	0f 93       	push	r16
    14a0:	1f 93       	push	r17
    14a2:	cf 93       	push	r28
    14a4:	df 93       	push	r29
    14a6:	ec 01       	movw	r28, r24
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    14a8:	00 97       	sbiw	r24, 0x00	; 0
    14aa:	b9 f1       	breq	.+110    	; 0x151a <vTaskResume+0x7c>
    14ac:	80 91 4a 1a 	lds	r24, 0x1A4A
    14b0:	90 91 4b 1a 	lds	r25, 0x1A4B
    14b4:	c8 17       	cp	r28, r24
    14b6:	d9 07       	cpc	r29, r25
    14b8:	81 f1       	breq	.+96     	; 0x151a <vTaskResume+0x7c>
		{
			taskENTER_CRITICAL();
    14ba:	0f b6       	in	r0, 0x3f	; 63
    14bc:	f8 94       	cli
    14be:	0f 92       	push	r0
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    14c0:	ce 01       	movw	r24, r28
    14c2:	0e 94 38 0a 	call	0x1470	; 0x1470 <xTaskIsTaskSuspended>
    14c6:	81 30       	cpi	r24, 0x01	; 1
    14c8:	31 f5       	brne	.+76     	; 0x1516 <vTaskResume+0x78>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					uxListRemove(  &( pxTCB->xGenericListItem ) );
    14ca:	8e 01       	movw	r16, r28
    14cc:	0e 5f       	subi	r16, 0xFE	; 254
    14ce:	1f 4f       	sbci	r17, 0xFF	; 255
    14d0:	c8 01       	movw	r24, r16
    14d2:	0e 94 bb 03 	call	0x776	; 0x776 <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    14d6:	8e 89       	ldd	r24, Y+22	; 0x16
    14d8:	90 91 51 1a 	lds	r25, 0x1A51
    14dc:	98 17       	cp	r25, r24
    14de:	10 f4       	brcc	.+4      	; 0x14e4 <vTaskResume+0x46>
    14e0:	80 93 51 1a 	sts	0x1A51, r24
    14e4:	90 e0       	ldi	r25, 0x00	; 0
    14e6:	9c 01       	movw	r18, r24
    14e8:	22 0f       	add	r18, r18
    14ea:	33 1f       	adc	r19, r19
    14ec:	22 0f       	add	r18, r18
    14ee:	33 1f       	adc	r19, r19
    14f0:	22 0f       	add	r18, r18
    14f2:	33 1f       	adc	r19, r19
    14f4:	82 0f       	add	r24, r18
    14f6:	93 1f       	adc	r25, r19
    14f8:	85 5a       	subi	r24, 0xA5	; 165
    14fa:	95 4e       	sbci	r25, 0xE5	; 229
    14fc:	b8 01       	movw	r22, r16
    14fe:	0e 94 55 03 	call	0x6aa	; 0x6aa <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1502:	e0 91 4a 1a 	lds	r30, 0x1A4A
    1506:	f0 91 4b 1a 	lds	r31, 0x1A4B
    150a:	9e 89       	ldd	r25, Y+22	; 0x16
    150c:	86 89       	ldd	r24, Z+22	; 0x16
    150e:	98 17       	cp	r25, r24
    1510:	10 f0       	brcs	.+4      	; 0x1516 <vTaskResume+0x78>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
    1512:	0e 94 bb 04 	call	0x976	; 0x976 <vPortYield>
					}
				}
			}
			taskEXIT_CRITICAL();
    1516:	0f 90       	pop	r0
    1518:	0f be       	out	0x3f, r0	; 63
		}
	}
    151a:	df 91       	pop	r29
    151c:	cf 91       	pop	r28
    151e:	1f 91       	pop	r17
    1520:	0f 91       	pop	r16
    1522:	08 95       	ret

00001524 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
    1524:	ef 92       	push	r14
    1526:	ff 92       	push	r15
    1528:	1f 93       	push	r17
    152a:	cf 93       	push	r28
    152c:	df 93       	push	r29
    152e:	ec 01       	movw	r28, r24

		pxTCB = ( tskTCB * ) pxTaskToResume;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    1530:	0e 94 38 0a 	call	0x1470	; 0x1470 <xTaskIsTaskSuspended>
    1534:	81 30       	cpi	r24, 0x01	; 1
    1536:	b9 f5       	brne	.+110    	; 0x15a6 <xTaskResumeFromISR+0x82>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1538:	80 91 4f 1a 	lds	r24, 0x1A4F
    153c:	88 23       	and	r24, r24
    153e:	51 f5       	brne	.+84     	; 0x1594 <xTaskResumeFromISR+0x70>
				{
					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
    1540:	e0 91 4a 1a 	lds	r30, 0x1A4A
    1544:	f0 91 4b 1a 	lds	r31, 0x1A4B
    1548:	11 e0       	ldi	r17, 0x01	; 1
    154a:	9e 89       	ldd	r25, Y+22	; 0x16
    154c:	86 89       	ldd	r24, Z+22	; 0x16
    154e:	98 17       	cp	r25, r24
    1550:	08 f4       	brcc	.+2      	; 0x1554 <xTaskResumeFromISR+0x30>
    1552:	10 e0       	ldi	r17, 0x00	; 0
					uxListRemove(  &( pxTCB->xGenericListItem ) );
    1554:	ee 24       	eor	r14, r14
    1556:	ff 24       	eor	r15, r15
    1558:	68 94       	set
    155a:	e1 f8       	bld	r14, 1
    155c:	ec 0e       	add	r14, r28
    155e:	fd 1e       	adc	r15, r29
    1560:	c7 01       	movw	r24, r14
    1562:	0e 94 bb 03 	call	0x776	; 0x776 <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1566:	8e 89       	ldd	r24, Y+22	; 0x16
    1568:	90 91 51 1a 	lds	r25, 0x1A51
    156c:	98 17       	cp	r25, r24
    156e:	10 f4       	brcc	.+4      	; 0x1574 <xTaskResumeFromISR+0x50>
    1570:	80 93 51 1a 	sts	0x1A51, r24
    1574:	90 e0       	ldi	r25, 0x00	; 0
    1576:	9c 01       	movw	r18, r24
    1578:	22 0f       	add	r18, r18
    157a:	33 1f       	adc	r19, r19
    157c:	22 0f       	add	r18, r18
    157e:	33 1f       	adc	r19, r19
    1580:	22 0f       	add	r18, r18
    1582:	33 1f       	adc	r19, r19
    1584:	82 0f       	add	r24, r18
    1586:	93 1f       	adc	r25, r19
    1588:	85 5a       	subi	r24, 0xA5	; 165
    158a:	95 4e       	sbci	r25, 0xE5	; 229
    158c:	b7 01       	movw	r22, r14
    158e:	0e 94 55 03 	call	0x6aa	; 0x6aa <vListInsertEnd>
    1592:	0a c0       	rjmp	.+20     	; 0x15a8 <xTaskResumeFromISR+0x84>
				else
				{
					/* We cannot access the delayed or ready lists, so will hold this
					task pending until the scheduler is resumed, at which point a
					yield will be performed if necessary. */
					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1594:	be 01       	movw	r22, r28
    1596:	64 5f       	subi	r22, 0xF4	; 244
    1598:	7f 4f       	sbci	r23, 0xFF	; 255
    159a:	81 e9       	ldi	r24, 0x91	; 145
    159c:	9a e1       	ldi	r25, 0x1A	; 26
    159e:	0e 94 55 03 	call	0x6aa	; 0x6aa <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
	portBASE_TYPE xYieldRequired = pdFALSE;
    15a2:	10 e0       	ldi	r17, 0x00	; 0
    15a4:	01 c0       	rjmp	.+2      	; 0x15a8 <xTaskResumeFromISR+0x84>
    15a6:	10 e0       	ldi	r17, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
	}
    15a8:	81 2f       	mov	r24, r17
    15aa:	df 91       	pop	r29
    15ac:	cf 91       	pop	r28
    15ae:	1f 91       	pop	r17
    15b0:	ff 90       	pop	r15
    15b2:	ef 90       	pop	r14
    15b4:	08 95       	ret

000015b6 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    15b6:	af 92       	push	r10
    15b8:	bf 92       	push	r11
    15ba:	cf 92       	push	r12
    15bc:	df 92       	push	r13
    15be:	ef 92       	push	r14
    15c0:	ff 92       	push	r15
    15c2:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    15c4:	88 e1       	ldi	r24, 0x18	; 24
    15c6:	99 e0       	ldi	r25, 0x09	; 9
    15c8:	67 e0       	ldi	r22, 0x07	; 7
    15ca:	72 e0       	ldi	r23, 0x02	; 2
    15cc:	45 e5       	ldi	r20, 0x55	; 85
    15ce:	50 e0       	ldi	r21, 0x00	; 0
    15d0:	20 e0       	ldi	r18, 0x00	; 0
    15d2:	30 e0       	ldi	r19, 0x00	; 0
    15d4:	00 e0       	ldi	r16, 0x00	; 0
    15d6:	ee 24       	eor	r14, r14
    15d8:	ff 24       	eor	r15, r15
    15da:	cc 24       	eor	r12, r12
    15dc:	dd 24       	eor	r13, r13
    15de:	aa 24       	eor	r10, r10
    15e0:	bb 24       	eor	r11, r11
    15e2:	0e 94 20 09 	call	0x1240	; 0x1240 <xTaskGenericCreate>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    15e6:	81 30       	cpi	r24, 0x01	; 1
    15e8:	49 f4       	brne	.+18     	; 0x15fc <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    15ea:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    15ec:	80 93 50 1a 	sts	0x1A50, r24
		xTickCount = ( portTickType ) 0U;
    15f0:	10 92 53 1a 	sts	0x1A53, r1
    15f4:	10 92 52 1a 	sts	0x1A52, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    15f8:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    15fc:	0f 91       	pop	r16
    15fe:	ff 90       	pop	r15
    1600:	ef 90       	pop	r14
    1602:	df 90       	pop	r13
    1604:	cf 90       	pop	r12
    1606:	bf 90       	pop	r11
    1608:	af 90       	pop	r10
    160a:	08 95       	ret

0000160c <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    160c:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    160e:	10 92 50 1a 	sts	0x1A50, r1
	vPortEndScheduler();
    1612:	0e 94 ba 04 	call	0x974	; 0x974 <vPortEndScheduler>
}
    1616:	08 95       	ret

00001618 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    1618:	80 91 4f 1a 	lds	r24, 0x1A4F
    161c:	8f 5f       	subi	r24, 0xFF	; 255
    161e:	80 93 4f 1a 	sts	0x1A4F, r24
}
    1622:	08 95       	ret

00001624 <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    1624:	0f b6       	in	r0, 0x3f	; 63
    1626:	f8 94       	cli
    1628:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    162a:	80 91 52 1a 	lds	r24, 0x1A52
    162e:	90 91 53 1a 	lds	r25, 0x1A53
	}
	taskEXIT_CRITICAL();
    1632:	0f 90       	pop	r0
    1634:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    1636:	08 95       	ret

00001638 <xTaskGetTickCountFromISR>:
{
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	xReturn = xTickCount;
    1638:	80 91 52 1a 	lds	r24, 0x1A52
    163c:	90 91 53 1a 	lds	r25, 0x1A53
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1640:	08 95       	ret

00001642 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    1642:	80 91 54 1a 	lds	r24, 0x1A54
}
    1646:	08 95       	ret

00001648 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    1648:	0f 93       	push	r16
    164a:	1f 93       	push	r17
    164c:	cf 93       	push	r28
    164e:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1650:	80 91 4f 1a 	lds	r24, 0x1A4F
    1654:	88 23       	and	r24, r24
    1656:	09 f0       	breq	.+2      	; 0x165a <vTaskIncrementTick+0x12>
    1658:	b3 c0       	rjmp	.+358    	; 0x17c0 <vTaskIncrementTick+0x178>
	{
		++xTickCount;
    165a:	80 91 52 1a 	lds	r24, 0x1A52
    165e:	90 91 53 1a 	lds	r25, 0x1A53
    1662:	01 96       	adiw	r24, 0x01	; 1
    1664:	90 93 53 1a 	sts	0x1A53, r25
    1668:	80 93 52 1a 	sts	0x1A52, r24
		if( xTickCount == ( portTickType ) 0U )
    166c:	80 91 52 1a 	lds	r24, 0x1A52
    1670:	90 91 53 1a 	lds	r25, 0x1A53
    1674:	00 97       	sbiw	r24, 0x00	; 0
    1676:	99 f5       	brne	.+102    	; 0x16de <vTaskIncrementTick+0x96>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
    1678:	80 91 57 1a 	lds	r24, 0x1A57
    167c:	90 91 58 1a 	lds	r25, 0x1A58
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    1680:	20 91 55 1a 	lds	r18, 0x1A55
    1684:	30 91 56 1a 	lds	r19, 0x1A56
    1688:	30 93 58 1a 	sts	0x1A58, r19
    168c:	20 93 57 1a 	sts	0x1A57, r18
			pxOverflowDelayedTaskList = pxTemp;
    1690:	90 93 56 1a 	sts	0x1A56, r25
    1694:	80 93 55 1a 	sts	0x1A55, r24
			xNumOfOverflows++;
    1698:	80 91 4c 1a 	lds	r24, 0x1A4C
    169c:	8f 5f       	subi	r24, 0xFF	; 255
    169e:	80 93 4c 1a 	sts	0x1A4C, r24

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    16a2:	e0 91 57 1a 	lds	r30, 0x1A57
    16a6:	f0 91 58 1a 	lds	r31, 0x1A58
    16aa:	80 81       	ld	r24, Z
    16ac:	88 23       	and	r24, r24
    16ae:	39 f4       	brne	.+14     	; 0x16be <vTaskIncrementTick+0x76>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    16b0:	8f ef       	ldi	r24, 0xFF	; 255
    16b2:	9f ef       	ldi	r25, 0xFF	; 255
    16b4:	90 93 0d 02 	sts	0x020D, r25
    16b8:	80 93 0c 02 	sts	0x020C, r24
    16bc:	10 c0       	rjmp	.+32     	; 0x16de <vTaskIncrementTick+0x96>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    16be:	e0 91 57 1a 	lds	r30, 0x1A57
    16c2:	f0 91 58 1a 	lds	r31, 0x1A58
    16c6:	05 80       	ldd	r0, Z+5	; 0x05
    16c8:	f6 81       	ldd	r31, Z+6	; 0x06
    16ca:	e0 2d       	mov	r30, r0
    16cc:	06 80       	ldd	r0, Z+6	; 0x06
    16ce:	f7 81       	ldd	r31, Z+7	; 0x07
    16d0:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    16d2:	82 81       	ldd	r24, Z+2	; 0x02
    16d4:	93 81       	ldd	r25, Z+3	; 0x03
    16d6:	90 93 0d 02 	sts	0x020D, r25
    16da:	80 93 0c 02 	sts	0x020C, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    16de:	20 91 52 1a 	lds	r18, 0x1A52
    16e2:	30 91 53 1a 	lds	r19, 0x1A53
    16e6:	80 91 0c 02 	lds	r24, 0x020C
    16ea:	90 91 0d 02 	lds	r25, 0x020D
    16ee:	28 17       	cp	r18, r24
    16f0:	39 07       	cpc	r19, r25
    16f2:	08 f4       	brcc	.+2      	; 0x16f6 <vTaskIncrementTick+0xae>
    16f4:	6a c0       	rjmp	.+212    	; 0x17ca <vTaskIncrementTick+0x182>
    16f6:	e0 91 57 1a 	lds	r30, 0x1A57
    16fa:	f0 91 58 1a 	lds	r31, 0x1A58
    16fe:	80 81       	ld	r24, Z
    1700:	88 23       	and	r24, r24
    1702:	99 f0       	breq	.+38     	; 0x172a <vTaskIncrementTick+0xe2>
    1704:	e0 91 57 1a 	lds	r30, 0x1A57
    1708:	f0 91 58 1a 	lds	r31, 0x1A58
    170c:	05 80       	ldd	r0, Z+5	; 0x05
    170e:	f6 81       	ldd	r31, Z+6	; 0x06
    1710:	e0 2d       	mov	r30, r0
    1712:	c6 81       	ldd	r28, Z+6	; 0x06
    1714:	d7 81       	ldd	r29, Z+7	; 0x07
    1716:	8a 81       	ldd	r24, Y+2	; 0x02
    1718:	9b 81       	ldd	r25, Y+3	; 0x03
    171a:	20 91 52 1a 	lds	r18, 0x1A52
    171e:	30 91 53 1a 	lds	r19, 0x1A53
    1722:	28 17       	cp	r18, r24
    1724:	39 07       	cpc	r19, r25
    1726:	f8 f4       	brcc	.+62     	; 0x1766 <vTaskIncrementTick+0x11e>
    1728:	19 c0       	rjmp	.+50     	; 0x175c <vTaskIncrementTick+0x114>
    172a:	8f ef       	ldi	r24, 0xFF	; 255
    172c:	9f ef       	ldi	r25, 0xFF	; 255
    172e:	90 93 0d 02 	sts	0x020D, r25
    1732:	80 93 0c 02 	sts	0x020C, r24
    1736:	49 c0       	rjmp	.+146    	; 0x17ca <vTaskIncrementTick+0x182>
    1738:	e0 91 57 1a 	lds	r30, 0x1A57
    173c:	f0 91 58 1a 	lds	r31, 0x1A58
    1740:	05 80       	ldd	r0, Z+5	; 0x05
    1742:	f6 81       	ldd	r31, Z+6	; 0x06
    1744:	e0 2d       	mov	r30, r0
    1746:	c6 81       	ldd	r28, Z+6	; 0x06
    1748:	d7 81       	ldd	r29, Z+7	; 0x07
    174a:	8a 81       	ldd	r24, Y+2	; 0x02
    174c:	9b 81       	ldd	r25, Y+3	; 0x03
    174e:	20 91 52 1a 	lds	r18, 0x1A52
    1752:	30 91 53 1a 	lds	r19, 0x1A53
    1756:	28 17       	cp	r18, r24
    1758:	39 07       	cpc	r19, r25
    175a:	28 f4       	brcc	.+10     	; 0x1766 <vTaskIncrementTick+0x11e>
    175c:	90 93 0d 02 	sts	0x020D, r25
    1760:	80 93 0c 02 	sts	0x020C, r24
    1764:	32 c0       	rjmp	.+100    	; 0x17ca <vTaskIncrementTick+0x182>
    1766:	8e 01       	movw	r16, r28
    1768:	0e 5f       	subi	r16, 0xFE	; 254
    176a:	1f 4f       	sbci	r17, 0xFF	; 255
    176c:	c8 01       	movw	r24, r16
    176e:	0e 94 bb 03 	call	0x776	; 0x776 <uxListRemove>
    1772:	8c 89       	ldd	r24, Y+20	; 0x14
    1774:	9d 89       	ldd	r25, Y+21	; 0x15
    1776:	00 97       	sbiw	r24, 0x00	; 0
    1778:	21 f0       	breq	.+8      	; 0x1782 <vTaskIncrementTick+0x13a>
    177a:	ce 01       	movw	r24, r28
    177c:	0c 96       	adiw	r24, 0x0c	; 12
    177e:	0e 94 bb 03 	call	0x776	; 0x776 <uxListRemove>
    1782:	8e 89       	ldd	r24, Y+22	; 0x16
    1784:	90 91 51 1a 	lds	r25, 0x1A51
    1788:	98 17       	cp	r25, r24
    178a:	10 f4       	brcc	.+4      	; 0x1790 <vTaskIncrementTick+0x148>
    178c:	80 93 51 1a 	sts	0x1A51, r24
    1790:	90 e0       	ldi	r25, 0x00	; 0
    1792:	9c 01       	movw	r18, r24
    1794:	22 0f       	add	r18, r18
    1796:	33 1f       	adc	r19, r19
    1798:	22 0f       	add	r18, r18
    179a:	33 1f       	adc	r19, r19
    179c:	22 0f       	add	r18, r18
    179e:	33 1f       	adc	r19, r19
    17a0:	82 0f       	add	r24, r18
    17a2:	93 1f       	adc	r25, r19
    17a4:	85 5a       	subi	r24, 0xA5	; 165
    17a6:	95 4e       	sbci	r25, 0xE5	; 229
    17a8:	b8 01       	movw	r22, r16
    17aa:	0e 94 55 03 	call	0x6aa	; 0x6aa <vListInsertEnd>
    17ae:	e0 91 57 1a 	lds	r30, 0x1A57
    17b2:	f0 91 58 1a 	lds	r31, 0x1A58
    17b6:	80 81       	ld	r24, Z
    17b8:	88 23       	and	r24, r24
    17ba:	09 f0       	breq	.+2      	; 0x17be <vTaskIncrementTick+0x176>
    17bc:	bd cf       	rjmp	.-134    	; 0x1738 <vTaskIncrementTick+0xf0>
    17be:	b5 cf       	rjmp	.-150    	; 0x172a <vTaskIncrementTick+0xe2>
	}
	else
	{
		++uxMissedTicks;
    17c0:	80 91 4e 1a 	lds	r24, 0x1A4E
    17c4:	8f 5f       	subi	r24, 0xFF	; 255
    17c6:	80 93 4e 1a 	sts	0x1A4E, r24
		{
			vApplicationTickHook();
		}
	}
	#endif
}
    17ca:	df 91       	pop	r29
    17cc:	cf 91       	pop	r28
    17ce:	1f 91       	pop	r17
    17d0:	0f 91       	pop	r16
    17d2:	08 95       	ret

000017d4 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE != 0  */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    17d4:	af 92       	push	r10
    17d6:	bf 92       	push	r11
    17d8:	cf 92       	push	r12
    17da:	df 92       	push	r13
    17dc:	ef 92       	push	r14
    17de:	ff 92       	push	r15
    17e0:	0f 93       	push	r16
    17e2:	1f 93       	push	r17
    17e4:	cf 93       	push	r28
    17e6:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    17e8:	0f b6       	in	r0, 0x3f	; 63
    17ea:	f8 94       	cli
    17ec:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    17ee:	80 91 4f 1a 	lds	r24, 0x1A4F
    17f2:	81 50       	subi	r24, 0x01	; 1
    17f4:	80 93 4f 1a 	sts	0x1A4F, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    17f8:	80 91 4f 1a 	lds	r24, 0x1A4F
    17fc:	88 23       	and	r24, r24
    17fe:	09 f0       	breq	.+2      	; 0x1802 <xTaskResumeAll+0x2e>
    1800:	69 c0       	rjmp	.+210    	; 0x18d4 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    1802:	80 91 54 1a 	lds	r24, 0x1A54
    1806:	88 23       	and	r24, r24
    1808:	81 f5       	brne	.+96     	; 0x186a <xTaskResumeAll+0x96>
    180a:	67 c0       	rjmp	.+206    	; 0x18da <xTaskResumeAll+0x106>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    180c:	d6 01       	movw	r26, r12
    180e:	ed 91       	ld	r30, X+
    1810:	fc 91       	ld	r31, X
    1812:	c6 81       	ldd	r28, Z+6	; 0x06
    1814:	d7 81       	ldd	r29, Z+7	; 0x07
					uxListRemove( &( pxTCB->xEventListItem ) );
    1816:	ce 01       	movw	r24, r28
    1818:	0c 96       	adiw	r24, 0x0c	; 12
    181a:	0e 94 bb 03 	call	0x776	; 0x776 <uxListRemove>
					uxListRemove( &( pxTCB->xGenericListItem ) );
    181e:	8e 01       	movw	r16, r28
    1820:	0e 5f       	subi	r16, 0xFE	; 254
    1822:	1f 4f       	sbci	r17, 0xFF	; 255
    1824:	c8 01       	movw	r24, r16
    1826:	0e 94 bb 03 	call	0x776	; 0x776 <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    182a:	8e 89       	ldd	r24, Y+22	; 0x16
    182c:	90 91 51 1a 	lds	r25, 0x1A51
    1830:	98 17       	cp	r25, r24
    1832:	10 f4       	brcc	.+4      	; 0x1838 <xTaskResumeAll+0x64>
    1834:	80 93 51 1a 	sts	0x1A51, r24
    1838:	90 e0       	ldi	r25, 0x00	; 0
    183a:	9c 01       	movw	r18, r24
    183c:	22 0f       	add	r18, r18
    183e:	33 1f       	adc	r19, r19
    1840:	22 0f       	add	r18, r18
    1842:	33 1f       	adc	r19, r19
    1844:	22 0f       	add	r18, r18
    1846:	33 1f       	adc	r19, r19
    1848:	82 0f       	add	r24, r18
    184a:	93 1f       	adc	r25, r19
    184c:	85 5a       	subi	r24, 0xA5	; 165
    184e:	95 4e       	sbci	r25, 0xE5	; 229
    1850:	b8 01       	movw	r22, r16
    1852:	0e 94 55 03 	call	0x6aa	; 0x6aa <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1856:	e0 91 4a 1a 	lds	r30, 0x1A4A
    185a:	f0 91 4b 1a 	lds	r31, 0x1A4B
    185e:	9e 89       	ldd	r25, Y+22	; 0x16
    1860:	86 89       	ldd	r24, Z+22	; 0x16
    1862:	98 17       	cp	r25, r24
    1864:	88 f0       	brcs	.+34     	; 0x1888 <xTaskResumeAll+0xb4>
					{
						xYieldRequired = pdTRUE;
    1866:	ba 2c       	mov	r11, r10
    1868:	0f c0       	rjmp	.+30     	; 0x1888 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    186a:	bb 24       	eor	r11, r11
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    186c:	0f 2e       	mov	r0, r31
    186e:	f1 e9       	ldi	r31, 0x91	; 145
    1870:	ef 2e       	mov	r14, r31
    1872:	fa e1       	ldi	r31, 0x1A	; 26
    1874:	ff 2e       	mov	r15, r31
    1876:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    1878:	0f 2e       	mov	r0, r31
    187a:	f6 e9       	ldi	r31, 0x96	; 150
    187c:	cf 2e       	mov	r12, r31
    187e:	fa e1       	ldi	r31, 0x1A	; 26
    1880:	df 2e       	mov	r13, r31
    1882:	f0 2d       	mov	r31, r0

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldRequired = pdTRUE;
    1884:	aa 24       	eor	r10, r10
    1886:	a3 94       	inc	r10
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1888:	f7 01       	movw	r30, r14
    188a:	80 81       	ld	r24, Z
    188c:	88 23       	and	r24, r24
    188e:	09 f0       	breq	.+2      	; 0x1892 <xTaskResumeAll+0xbe>
    1890:	bd cf       	rjmp	.-134    	; 0x180c <xTaskResumeAll+0x38>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1892:	80 91 4e 1a 	lds	r24, 0x1A4E
    1896:	88 23       	and	r24, r24
    1898:	81 f0       	breq	.+32     	; 0x18ba <xTaskResumeAll+0xe6>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    189a:	80 91 4e 1a 	lds	r24, 0x1A4E
    189e:	88 23       	and	r24, r24
    18a0:	99 f0       	breq	.+38     	; 0x18c8 <xTaskResumeAll+0xf4>
					{
						vTaskIncrementTick();
    18a2:	0e 94 24 0b 	call	0x1648	; 0x1648 <vTaskIncrementTick>
						--uxMissedTicks;
    18a6:	80 91 4e 1a 	lds	r24, 0x1A4E
    18aa:	81 50       	subi	r24, 0x01	; 1
    18ac:	80 93 4e 1a 	sts	0x1A4E, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    18b0:	80 91 4e 1a 	lds	r24, 0x1A4E
    18b4:	88 23       	and	r24, r24
    18b6:	a9 f7       	brne	.-22     	; 0x18a2 <xTaskResumeAll+0xce>
    18b8:	07 c0       	rjmp	.+14     	; 0x18c8 <xTaskResumeAll+0xf4>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    18ba:	f1 e0       	ldi	r31, 0x01	; 1
    18bc:	bf 16       	cp	r11, r31
    18be:	21 f0       	breq	.+8      	; 0x18c8 <xTaskResumeAll+0xf4>
    18c0:	80 91 4d 1a 	lds	r24, 0x1A4D
    18c4:	81 30       	cpi	r24, 0x01	; 1
    18c6:	41 f4       	brne	.+16     	; 0x18d8 <xTaskResumeAll+0x104>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    18c8:	10 92 4d 1a 	sts	0x1A4D, r1
					portYIELD_WITHIN_API();
    18cc:	0e 94 bb 04 	call	0x976	; 0x976 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    18d0:	81 e0       	ldi	r24, 0x01	; 1
    18d2:	03 c0       	rjmp	.+6      	; 0x18da <xTaskResumeAll+0x106>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    18d4:	80 e0       	ldi	r24, 0x00	; 0
    18d6:	01 c0       	rjmp	.+2      	; 0x18da <xTaskResumeAll+0x106>
    18d8:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    18da:	0f 90       	pop	r0
    18dc:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    18de:	df 91       	pop	r29
    18e0:	cf 91       	pop	r28
    18e2:	1f 91       	pop	r17
    18e4:	0f 91       	pop	r16
    18e6:	ff 90       	pop	r15
    18e8:	ef 90       	pop	r14
    18ea:	df 90       	pop	r13
    18ec:	cf 90       	pop	r12
    18ee:	bf 90       	pop	r11
    18f0:	af 90       	pop	r10
    18f2:	08 95       	ret

000018f4 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    18f4:	cf 93       	push	r28
    18f6:	df 93       	push	r29
    18f8:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    18fa:	00 97       	sbiw	r24, 0x00	; 0
    18fc:	b1 f0       	breq	.+44     	; 0x192a <vTaskDelay+0x36>
		{
			vTaskSuspendAll();
    18fe:	0e 94 0c 0b 	call	0x1618	; 0x1618 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1902:	80 91 52 1a 	lds	r24, 0x1A52
    1906:	90 91 53 1a 	lds	r25, 0x1A53
    190a:	c8 0f       	add	r28, r24
    190c:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    190e:	80 91 4a 1a 	lds	r24, 0x1A4A
    1912:	90 91 4b 1a 	lds	r25, 0x1A4B
    1916:	02 96       	adiw	r24, 0x02	; 2
    1918:	0e 94 bb 03 	call	0x776	; 0x776 <uxListRemove>
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    191c:	ce 01       	movw	r24, r28
    191e:	0e 94 e1 08 	call	0x11c2	; 0x11c2 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1922:	0e 94 ea 0b 	call	0x17d4	; 0x17d4 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1926:	88 23       	and	r24, r24
    1928:	11 f4       	brne	.+4      	; 0x192e <vTaskDelay+0x3a>
		{
			portYIELD_WITHIN_API();
    192a:	0e 94 bb 04 	call	0x976	; 0x976 <vPortYield>
		}
	}
    192e:	df 91       	pop	r29
    1930:	cf 91       	pop	r28
    1932:	08 95       	ret

00001934 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    1934:	0f 93       	push	r16
    1936:	1f 93       	push	r17
    1938:	cf 93       	push	r28
    193a:	df 93       	push	r29
    193c:	8c 01       	movw	r16, r24
    193e:	eb 01       	movw	r28, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    1940:	0e 94 0c 0b 	call	0x1618	; 0x1618 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1944:	f8 01       	movw	r30, r16
    1946:	80 81       	ld	r24, Z
    1948:	91 81       	ldd	r25, Z+1	; 0x01
    194a:	c8 0f       	add	r28, r24
    194c:	d9 1f       	adc	r29, r25

			if( xTickCount < *pxPreviousWakeTime )
    194e:	20 91 52 1a 	lds	r18, 0x1A52
    1952:	30 91 53 1a 	lds	r19, 0x1A53
    1956:	28 17       	cp	r18, r24
    1958:	39 07       	cpc	r19, r25
    195a:	68 f4       	brcc	.+26     	; 0x1976 <vTaskDelayUntil+0x42>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    195c:	c8 17       	cp	r28, r24
    195e:	d9 07       	cpc	r29, r25
    1960:	50 f5       	brcc	.+84     	; 0x19b6 <vTaskDelayUntil+0x82>
    1962:	80 91 52 1a 	lds	r24, 0x1A52
    1966:	90 91 53 1a 	lds	r25, 0x1A53
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    196a:	d1 83       	std	Z+1, r29	; 0x01
    196c:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    196e:	8c 17       	cp	r24, r28
    1970:	9d 07       	cpc	r25, r29
    1972:	b0 f4       	brcc	.+44     	; 0x19a0 <vTaskDelayUntil+0x6c>
    1974:	0b c0       	rjmp	.+22     	; 0x198c <vTaskDelayUntil+0x58>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    1976:	c8 17       	cp	r28, r24
    1978:	d9 07       	cpc	r29, r25
    197a:	c8 f0       	brcs	.+50     	; 0x19ae <vTaskDelayUntil+0x7a>
    197c:	80 91 52 1a 	lds	r24, 0x1A52
    1980:	90 91 53 1a 	lds	r25, 0x1A53
    1984:	8c 17       	cp	r24, r28
    1986:	9d 07       	cpc	r25, r29
    1988:	90 f0       	brcs	.+36     	; 0x19ae <vTaskDelayUntil+0x7a>
    198a:	15 c0       	rjmp	.+42     	; 0x19b6 <vTaskDelayUntil+0x82>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    198c:	80 91 4a 1a 	lds	r24, 0x1A4A
    1990:	90 91 4b 1a 	lds	r25, 0x1A4B
    1994:	02 96       	adiw	r24, 0x02	; 2
    1996:	0e 94 bb 03 	call	0x776	; 0x776 <uxListRemove>
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    199a:	ce 01       	movw	r24, r28
    199c:	0e 94 e1 08 	call	0x11c2	; 0x11c2 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    19a0:	0e 94 ea 0b 	call	0x17d4	; 0x17d4 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    19a4:	88 23       	and	r24, r24
    19a6:	59 f4       	brne	.+22     	; 0x19be <vTaskDelayUntil+0x8a>
		{
			portYIELD_WITHIN_API();
    19a8:	0e 94 bb 04 	call	0x976	; 0x976 <vPortYield>
    19ac:	08 c0       	rjmp	.+16     	; 0x19be <vTaskDelayUntil+0x8a>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    19ae:	f8 01       	movw	r30, r16
    19b0:	d1 83       	std	Z+1, r29	; 0x01
    19b2:	c0 83       	st	Z, r28
    19b4:	eb cf       	rjmp	.-42     	; 0x198c <vTaskDelayUntil+0x58>
    19b6:	f8 01       	movw	r30, r16
    19b8:	d1 83       	std	Z+1, r29	; 0x01
    19ba:	c0 83       	st	Z, r28
    19bc:	f1 cf       	rjmp	.-30     	; 0x19a0 <vTaskDelayUntil+0x6c>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    19be:	df 91       	pop	r29
    19c0:	cf 91       	pop	r28
    19c2:	1f 91       	pop	r17
    19c4:	0f 91       	pop	r16
    19c6:	08 95       	ret

000019c8 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    19c8:	80 91 4f 1a 	lds	r24, 0x1A4F
    19cc:	88 23       	and	r24, r24
    19ce:	99 f4       	brne	.+38     	; 0x19f6 <vTaskSwitchContext+0x2e>

//BB Commented out...
//		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
    19d0:	80 91 51 1a 	lds	r24, 0x1A51
    19d4:	90 e0       	ldi	r25, 0x00	; 0
    19d6:	fc 01       	movw	r30, r24
    19d8:	ee 0f       	add	r30, r30
    19da:	ff 1f       	adc	r31, r31
    19dc:	ee 0f       	add	r30, r30
    19de:	ff 1f       	adc	r31, r31
    19e0:	ee 0f       	add	r30, r30
    19e2:	ff 1f       	adc	r31, r31
    19e4:	8e 0f       	add	r24, r30
    19e6:	9f 1f       	adc	r25, r31
    19e8:	fc 01       	movw	r30, r24
    19ea:	e5 5a       	subi	r30, 0xA5	; 165
    19ec:	f5 4e       	sbci	r31, 0xE5	; 229
    19ee:	80 81       	ld	r24, Z
    19f0:	88 23       	and	r24, r24
    19f2:	29 f0       	breq	.+10     	; 0x19fe <vTaskSwitchContext+0x36>
    19f4:	1b c0       	rjmp	.+54     	; 0x1a2c <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    19f6:	81 e0       	ldi	r24, 0x01	; 1
    19f8:	80 93 4d 1a 	sts	0x1A4D, r24
    19fc:	08 95       	ret

//BB Commented out...
//		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
    19fe:	80 91 51 1a 	lds	r24, 0x1A51
    1a02:	81 50       	subi	r24, 0x01	; 1
    1a04:	80 93 51 1a 	sts	0x1A51, r24
    1a08:	80 91 51 1a 	lds	r24, 0x1A51
    1a0c:	90 e0       	ldi	r25, 0x00	; 0
    1a0e:	fc 01       	movw	r30, r24
    1a10:	ee 0f       	add	r30, r30
    1a12:	ff 1f       	adc	r31, r31
    1a14:	ee 0f       	add	r30, r30
    1a16:	ff 1f       	adc	r31, r31
    1a18:	ee 0f       	add	r30, r30
    1a1a:	ff 1f       	adc	r31, r31
    1a1c:	8e 0f       	add	r24, r30
    1a1e:	9f 1f       	adc	r25, r31
    1a20:	fc 01       	movw	r30, r24
    1a22:	e5 5a       	subi	r30, 0xA5	; 165
    1a24:	f5 4e       	sbci	r31, 0xE5	; 229
    1a26:	80 81       	ld	r24, Z
    1a28:	88 23       	and	r24, r24
    1a2a:	49 f3       	breq	.-46     	; 0x19fe <vTaskSwitchContext+0x36>
    1a2c:	80 91 51 1a 	lds	r24, 0x1A51
    1a30:	90 e0       	ldi	r25, 0x00	; 0
    1a32:	fc 01       	movw	r30, r24
    1a34:	ee 0f       	add	r30, r30
    1a36:	ff 1f       	adc	r31, r31
    1a38:	ee 0f       	add	r30, r30
    1a3a:	ff 1f       	adc	r31, r31
    1a3c:	ee 0f       	add	r30, r30
    1a3e:	ff 1f       	adc	r31, r31
    1a40:	e8 0f       	add	r30, r24
    1a42:	f9 1f       	adc	r31, r25
    1a44:	e5 5a       	subi	r30, 0xA5	; 165
    1a46:	f5 4e       	sbci	r31, 0xE5	; 229
    1a48:	a1 81       	ldd	r26, Z+1	; 0x01
    1a4a:	b2 81       	ldd	r27, Z+2	; 0x02
    1a4c:	12 96       	adiw	r26, 0x02	; 2
    1a4e:	0d 90       	ld	r0, X+
    1a50:	bc 91       	ld	r27, X
    1a52:	a0 2d       	mov	r26, r0
    1a54:	b2 83       	std	Z+2, r27	; 0x02
    1a56:	a1 83       	std	Z+1, r26	; 0x01
    1a58:	cf 01       	movw	r24, r30
    1a5a:	03 96       	adiw	r24, 0x03	; 3
    1a5c:	a8 17       	cp	r26, r24
    1a5e:	b9 07       	cpc	r27, r25
    1a60:	31 f4       	brne	.+12     	; 0x1a6e <vTaskSwitchContext+0xa6>
    1a62:	12 96       	adiw	r26, 0x02	; 2
    1a64:	8d 91       	ld	r24, X+
    1a66:	9c 91       	ld	r25, X
    1a68:	13 97       	sbiw	r26, 0x03	; 3
    1a6a:	92 83       	std	Z+2, r25	; 0x02
    1a6c:	81 83       	std	Z+1, r24	; 0x01
    1a6e:	01 80       	ldd	r0, Z+1	; 0x01
    1a70:	f2 81       	ldd	r31, Z+2	; 0x02
    1a72:	e0 2d       	mov	r30, r0
    1a74:	86 81       	ldd	r24, Z+6	; 0x06
    1a76:	97 81       	ldd	r25, Z+7	; 0x07
    1a78:	90 93 4b 1a 	sts	0x1A4B, r25
    1a7c:	80 93 4a 1a 	sts	0x1A4A, r24
    1a80:	08 95       	ret

00001a82 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
    1a82:	ef 92       	push	r14
    1a84:	ff 92       	push	r15
    1a86:	0f 93       	push	r16
    1a88:	1f 93       	push	r17
    1a8a:	cf 93       	push	r28
    1a8c:	df 93       	push	r29
    1a8e:	7c 01       	movw	r14, r24
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    1a90:	0f b6       	in	r0, 0x3f	; 63
    1a92:	f8 94       	cli
    1a94:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
    1a96:	80 91 4a 1a 	lds	r24, 0x1A4A
    1a9a:	90 91 4b 1a 	lds	r25, 0x1A4B
    1a9e:	e8 16       	cp	r14, r24
    1aa0:	f9 06       	cpc	r15, r25
    1aa2:	21 f0       	breq	.+8      	; 0x1aac <vTaskSuspend+0x2a>
			{
				pxTaskToSuspend = NULL;
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
    1aa4:	e1 14       	cp	r14, r1
    1aa6:	f1 04       	cpc	r15, r1
    1aa8:	41 f4       	brne	.+16     	; 0x1aba <vTaskSuspend+0x38>
    1aaa:	02 c0       	rjmp	.+4      	; 0x1ab0 <vTaskSuspend+0x2e>
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
			{
				pxTaskToSuspend = NULL;
    1aac:	ee 24       	eor	r14, r14
    1aae:	ff 24       	eor	r15, r15
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
    1ab0:	c0 91 4a 1a 	lds	r28, 0x1A4A
    1ab4:	d0 91 4b 1a 	lds	r29, 0x1A4B
    1ab8:	01 c0       	rjmp	.+2      	; 0x1abc <vTaskSuspend+0x3a>
    1aba:	e7 01       	movw	r28, r14

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    1abc:	8e 01       	movw	r16, r28
    1abe:	0e 5f       	subi	r16, 0xFE	; 254
    1ac0:	1f 4f       	sbci	r17, 0xFF	; 255
    1ac2:	c8 01       	movw	r24, r16
    1ac4:	0e 94 bb 03 	call	0x776	; 0x776 <uxListRemove>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
			}

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    1ac8:	8c 89       	ldd	r24, Y+20	; 0x14
    1aca:	9d 89       	ldd	r25, Y+21	; 0x15
    1acc:	00 97       	sbiw	r24, 0x00	; 0
    1ace:	21 f0       	breq	.+8      	; 0x1ad8 <vTaskSuspend+0x56>
			{
				uxListRemove( &( pxTCB->xEventListItem ) );
    1ad0:	ce 01       	movw	r24, r28
    1ad2:	0c 96       	adiw	r24, 0x0c	; 12
    1ad4:	0e 94 bb 03 	call	0x776	; 0x776 <uxListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    1ad8:	8a e9       	ldi	r24, 0x9A	; 154
    1ada:	9a e1       	ldi	r25, 0x1A	; 26
    1adc:	b8 01       	movw	r22, r16
    1ade:	0e 94 55 03 	call	0x6aa	; 0x6aa <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    1ae2:	0f 90       	pop	r0
    1ae4:	0f be       	out	0x3f, r0	; 63

		if( ( void * ) pxTaskToSuspend == NULL )
    1ae6:	e1 14       	cp	r14, r1
    1ae8:	f1 04       	cpc	r15, r1
    1aea:	a1 f4       	brne	.+40     	; 0x1b14 <vTaskSuspend+0x92>
		{
			if( xSchedulerRunning != pdFALSE )
    1aec:	80 91 50 1a 	lds	r24, 0x1A50
    1af0:	88 23       	and	r24, r24
    1af2:	19 f0       	breq	.+6      	; 0x1afa <vTaskSuspend+0x78>
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
    1af4:	0e 94 bb 04 	call	0x976	; 0x976 <vPortYield>
    1af8:	0d c0       	rjmp	.+26     	; 0x1b14 <vTaskSuspend+0x92>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    1afa:	90 91 9a 1a 	lds	r25, 0x1A9A
    1afe:	80 91 54 1a 	lds	r24, 0x1A54
    1b02:	98 17       	cp	r25, r24
    1b04:	29 f4       	brne	.+10     	; 0x1b10 <vTaskSuspend+0x8e>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    1b06:	10 92 4b 1a 	sts	0x1A4B, r1
    1b0a:	10 92 4a 1a 	sts	0x1A4A, r1
    1b0e:	02 c0       	rjmp	.+4      	; 0x1b14 <vTaskSuspend+0x92>
				}
				else
				{
					vTaskSwitchContext();
    1b10:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <vTaskSwitchContext>
				}
			}
		}
	}
    1b14:	df 91       	pop	r29
    1b16:	cf 91       	pop	r28
    1b18:	1f 91       	pop	r17
    1b1a:	0f 91       	pop	r16
    1b1c:	ff 90       	pop	r15
    1b1e:	ef 90       	pop	r14
    1b20:	08 95       	ret

00001b22 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    1b22:	cf 93       	push	r28
    1b24:	df 93       	push	r29
    1b26:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    1b28:	60 91 4a 1a 	lds	r22, 0x1A4A
    1b2c:	70 91 4b 1a 	lds	r23, 0x1A4B
    1b30:	64 5f       	subi	r22, 0xF4	; 244
    1b32:	7f 4f       	sbci	r23, 0xFF	; 255
    1b34:	0e 94 7e 03 	call	0x6fc	; 0x6fc <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    1b38:	80 91 4a 1a 	lds	r24, 0x1A4A
    1b3c:	90 91 4b 1a 	lds	r25, 0x1A4B
    1b40:	02 96       	adiw	r24, 0x02	; 2
    1b42:	0e 94 bb 03 	call	0x776	; 0x776 <uxListRemove>
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    1b46:	8f ef       	ldi	r24, 0xFF	; 255
    1b48:	cf 3f       	cpi	r28, 0xFF	; 255
    1b4a:	d8 07       	cpc	r29, r24
    1b4c:	59 f4       	brne	.+22     	; 0x1b64 <vTaskPlaceOnEventList+0x42>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1b4e:	60 91 4a 1a 	lds	r22, 0x1A4A
    1b52:	70 91 4b 1a 	lds	r23, 0x1A4B
    1b56:	6e 5f       	subi	r22, 0xFE	; 254
    1b58:	7f 4f       	sbci	r23, 0xFF	; 255
    1b5a:	8a e9       	ldi	r24, 0x9A	; 154
    1b5c:	9a e1       	ldi	r25, 0x1A	; 26
    1b5e:	0e 94 55 03 	call	0x6aa	; 0x6aa <vListInsertEnd>
    1b62:	08 c0       	rjmp	.+16     	; 0x1b74 <vTaskPlaceOnEventList+0x52>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    1b64:	80 91 52 1a 	lds	r24, 0x1A52
    1b68:	90 91 53 1a 	lds	r25, 0x1A53
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    1b6c:	8c 0f       	add	r24, r28
    1b6e:	9d 1f       	adc	r25, r29
    1b70:	0e 94 e1 08 	call	0x11c2	; 0x11c2 <prvAddCurrentTaskToDelayedList>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
    1b74:	df 91       	pop	r29
    1b76:	cf 91       	pop	r28
    1b78:	08 95       	ret

00001b7a <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    1b7a:	0f 93       	push	r16
    1b7c:	1f 93       	push	r17
    1b7e:	cf 93       	push	r28
    1b80:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1b82:	dc 01       	movw	r26, r24
    1b84:	15 96       	adiw	r26, 0x05	; 5
    1b86:	ed 91       	ld	r30, X+
    1b88:	fc 91       	ld	r31, X
    1b8a:	16 97       	sbiw	r26, 0x06	; 6
    1b8c:	06 81       	ldd	r16, Z+6	; 0x06
    1b8e:	17 81       	ldd	r17, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1b90:	e8 01       	movw	r28, r16
    1b92:	2c 96       	adiw	r28, 0x0c	; 12
    1b94:	ce 01       	movw	r24, r28
    1b96:	0e 94 bb 03 	call	0x776	; 0x776 <uxListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1b9a:	80 91 4f 1a 	lds	r24, 0x1A4F
    1b9e:	88 23       	and	r24, r24
    1ba0:	e9 f4       	brne	.+58     	; 0x1bdc <xTaskRemoveFromEventList+0x62>
	{
		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    1ba2:	e8 01       	movw	r28, r16
    1ba4:	22 96       	adiw	r28, 0x02	; 2
    1ba6:	ce 01       	movw	r24, r28
    1ba8:	0e 94 bb 03 	call	0x776	; 0x776 <uxListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    1bac:	f8 01       	movw	r30, r16
    1bae:	86 89       	ldd	r24, Z+22	; 0x16
    1bb0:	90 91 51 1a 	lds	r25, 0x1A51
    1bb4:	98 17       	cp	r25, r24
    1bb6:	10 f4       	brcc	.+4      	; 0x1bbc <xTaskRemoveFromEventList+0x42>
    1bb8:	80 93 51 1a 	sts	0x1A51, r24
    1bbc:	90 e0       	ldi	r25, 0x00	; 0
    1bbe:	9c 01       	movw	r18, r24
    1bc0:	22 0f       	add	r18, r18
    1bc2:	33 1f       	adc	r19, r19
    1bc4:	22 0f       	add	r18, r18
    1bc6:	33 1f       	adc	r19, r19
    1bc8:	22 0f       	add	r18, r18
    1bca:	33 1f       	adc	r19, r19
    1bcc:	82 0f       	add	r24, r18
    1bce:	93 1f       	adc	r25, r19
    1bd0:	85 5a       	subi	r24, 0xA5	; 165
    1bd2:	95 4e       	sbci	r25, 0xE5	; 229
    1bd4:	be 01       	movw	r22, r28
    1bd6:	0e 94 55 03 	call	0x6aa	; 0x6aa <vListInsertEnd>
    1bda:	05 c0       	rjmp	.+10     	; 0x1be6 <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1bdc:	81 e9       	ldi	r24, 0x91	; 145
    1bde:	9a e1       	ldi	r25, 0x1A	; 26
    1be0:	be 01       	movw	r22, r28
    1be2:	0e 94 55 03 	call	0x6aa	; 0x6aa <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1be6:	e0 91 4a 1a 	lds	r30, 0x1A4A
    1bea:	f0 91 4b 1a 	lds	r31, 0x1A4B
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1bee:	81 e0       	ldi	r24, 0x01	; 1
    1bf0:	d8 01       	movw	r26, r16
    1bf2:	56 96       	adiw	r26, 0x16	; 22
    1bf4:	2c 91       	ld	r18, X
    1bf6:	56 97       	sbiw	r26, 0x16	; 22
    1bf8:	96 89       	ldd	r25, Z+22	; 0x16
    1bfa:	29 17       	cp	r18, r25
    1bfc:	08 f4       	brcc	.+2      	; 0x1c00 <xTaskRemoveFromEventList+0x86>
    1bfe:	80 e0       	ldi	r24, 0x00	; 0
}
    1c00:	df 91       	pop	r29
    1c02:	cf 91       	pop	r28
    1c04:	1f 91       	pop	r17
    1c06:	0f 91       	pop	r16
    1c08:	08 95       	ret

00001c0a <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    1c0a:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1c0c:	80 91 4c 1a 	lds	r24, 0x1A4C
    1c10:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    1c12:	80 91 52 1a 	lds	r24, 0x1A52
    1c16:	90 91 53 1a 	lds	r25, 0x1A53
    1c1a:	92 83       	std	Z+2, r25	; 0x02
    1c1c:	81 83       	std	Z+1, r24	; 0x01
}
    1c1e:	08 95       	ret

00001c20 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    1c20:	fc 01       	movw	r30, r24
    1c22:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1c24:	0f b6       	in	r0, 0x3f	; 63
    1c26:	f8 94       	cli
    1c28:	0f 92       	push	r0
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    1c2a:	4d 91       	ld	r20, X+
    1c2c:	5c 91       	ld	r21, X
    1c2e:	11 97       	sbiw	r26, 0x01	; 1
    1c30:	6f ef       	ldi	r22, 0xFF	; 255
    1c32:	4f 3f       	cpi	r20, 0xFF	; 255
    1c34:	56 07       	cpc	r21, r22
    1c36:	51 f1       	breq	.+84     	; 0x1c8c <xTaskCheckForTimeOut+0x6c>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    1c38:	80 91 4c 1a 	lds	r24, 0x1A4C
    1c3c:	90 81       	ld	r25, Z
    1c3e:	98 17       	cp	r25, r24
    1c40:	49 f0       	breq	.+18     	; 0x1c54 <xTaskCheckForTimeOut+0x34>
    1c42:	20 91 52 1a 	lds	r18, 0x1A52
    1c46:	30 91 53 1a 	lds	r19, 0x1A53
    1c4a:	81 81       	ldd	r24, Z+1	; 0x01
    1c4c:	92 81       	ldd	r25, Z+2	; 0x02
    1c4e:	28 17       	cp	r18, r24
    1c50:	39 07       	cpc	r19, r25
    1c52:	f0 f4       	brcc	.+60     	; 0x1c90 <xTaskCheckForTimeOut+0x70>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    1c54:	80 91 52 1a 	lds	r24, 0x1A52
    1c58:	90 91 53 1a 	lds	r25, 0x1A53
    1c5c:	21 81       	ldd	r18, Z+1	; 0x01
    1c5e:	32 81       	ldd	r19, Z+2	; 0x02
    1c60:	82 1b       	sub	r24, r18
    1c62:	93 0b       	sbc	r25, r19
    1c64:	84 17       	cp	r24, r20
    1c66:	95 07       	cpc	r25, r21
    1c68:	a8 f4       	brcc	.+42     	; 0x1c94 <xTaskCheckForTimeOut+0x74>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    1c6a:	80 91 52 1a 	lds	r24, 0x1A52
    1c6e:	90 91 53 1a 	lds	r25, 0x1A53
    1c72:	b9 01       	movw	r22, r18
    1c74:	68 1b       	sub	r22, r24
    1c76:	79 0b       	sbc	r23, r25
    1c78:	cb 01       	movw	r24, r22
    1c7a:	84 0f       	add	r24, r20
    1c7c:	95 1f       	adc	r25, r21
    1c7e:	8d 93       	st	X+, r24
    1c80:	9c 93       	st	X, r25
			vTaskSetTimeOutState( pxTimeOut );
    1c82:	cf 01       	movw	r24, r30
    1c84:	0e 94 05 0e 	call	0x1c0a	; 0x1c0a <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    1c88:	80 e0       	ldi	r24, 0x00	; 0
    1c8a:	05 c0       	rjmp	.+10     	; 0x1c96 <xTaskCheckForTimeOut+0x76>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
    1c8c:	80 e0       	ldi	r24, 0x00	; 0
    1c8e:	03 c0       	rjmp	.+6      	; 0x1c96 <xTaskCheckForTimeOut+0x76>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    1c90:	81 e0       	ldi	r24, 0x01	; 1
    1c92:	01 c0       	rjmp	.+2      	; 0x1c96 <xTaskCheckForTimeOut+0x76>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    1c94:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    1c96:	0f 90       	pop	r0
    1c98:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1c9a:	08 95       	ret

00001c9c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    1c9c:	81 e0       	ldi	r24, 0x01	; 1
    1c9e:	80 93 4d 1a 	sts	0x1A4D, r24
}
    1ca2:	08 95       	ret

00001ca4 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    1ca4:	00 97       	sbiw	r24, 0x00	; 0
    1ca6:	29 f4       	brne	.+10     	; 0x1cb2 <uxTaskGetStackHighWaterMark+0xe>
    1ca8:	e0 91 4a 1a 	lds	r30, 0x1A4A
    1cac:	f0 91 4b 1a 	lds	r31, 0x1A4B
    1cb0:	01 c0       	rjmp	.+2      	; 0x1cb4 <uxTaskGetStackHighWaterMark+0x10>
    1cb2:	fc 01       	movw	r30, r24

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    1cb4:	07 88       	ldd	r0, Z+23	; 0x17
    1cb6:	f0 8d       	ldd	r31, Z+24	; 0x18
    1cb8:	e0 2d       	mov	r30, r0

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    1cba:	80 81       	ld	r24, Z
    1cbc:	85 3a       	cpi	r24, 0xA5	; 165
    1cbe:	41 f4       	brne	.+16     	; 0x1cd0 <uxTaskGetStackHighWaterMark+0x2c>
#endif
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
    1cc0:	31 96       	adiw	r30, 0x01	; 1

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    1cc2:	80 e0       	ldi	r24, 0x00	; 0
    1cc4:	90 e0       	ldi	r25, 0x00	; 0

		while( *pucStackByte == tskSTACK_FILL_BYTE )
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    1cc6:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    1cc8:	21 91       	ld	r18, Z+
    1cca:	25 3a       	cpi	r18, 0xA5	; 165
    1ccc:	e1 f3       	breq	.-8      	; 0x1cc6 <uxTaskGetStackHighWaterMark+0x22>
    1cce:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    1cd0:	80 e0       	ldi	r24, 0x00	; 0
    1cd2:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    1cd4:	08 95       	ret

00001cd6 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    1cd6:	80 91 4a 1a 	lds	r24, 0x1A4A
    1cda:	90 91 4b 1a 	lds	r25, 0x1A4B

		return xReturn;
	}
    1cde:	08 95       	ret

00001ce0 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    1ce0:	0f 93       	push	r16
    1ce2:	1f 93       	push	r17
    1ce4:	cf 93       	push	r28
    1ce6:	df 93       	push	r29
    1ce8:	ec 01       	movw	r28, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    1cea:	00 97       	sbiw	r24, 0x00	; 0
    1cec:	09 f4       	brne	.+2      	; 0x1cf0 <vTaskPriorityInherit+0x10>
    1cee:	4d c0       	rjmp	.+154    	; 0x1d8a <vTaskPriorityInherit+0xaa>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    1cf0:	8e 89       	ldd	r24, Y+22	; 0x16
    1cf2:	e0 91 4a 1a 	lds	r30, 0x1A4A
    1cf6:	f0 91 4b 1a 	lds	r31, 0x1A4B
    1cfa:	96 89       	ldd	r25, Z+22	; 0x16
    1cfc:	89 17       	cp	r24, r25
    1cfe:	08 f0       	brcs	.+2      	; 0x1d02 <vTaskPriorityInherit+0x22>
    1d00:	44 c0       	rjmp	.+136    	; 0x1d8a <vTaskPriorityInherit+0xaa>
			{
				/* Adjust the mutex holder state to account for its new priority. */
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    1d02:	e0 91 4a 1a 	lds	r30, 0x1A4A
    1d06:	f0 91 4b 1a 	lds	r31, 0x1A4B
    1d0a:	96 89       	ldd	r25, Z+22	; 0x16
    1d0c:	24 e0       	ldi	r18, 0x04	; 4
    1d0e:	30 e0       	ldi	r19, 0x00	; 0
    1d10:	29 1b       	sub	r18, r25
    1d12:	31 09       	sbc	r19, r1
    1d14:	3d 87       	std	Y+13, r19	; 0x0d
    1d16:	2c 87       	std	Y+12, r18	; 0x0c

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    1d18:	90 e0       	ldi	r25, 0x00	; 0
    1d1a:	9c 01       	movw	r18, r24
    1d1c:	22 0f       	add	r18, r18
    1d1e:	33 1f       	adc	r19, r19
    1d20:	22 0f       	add	r18, r18
    1d22:	33 1f       	adc	r19, r19
    1d24:	22 0f       	add	r18, r18
    1d26:	33 1f       	adc	r19, r19
    1d28:	82 0f       	add	r24, r18
    1d2a:	93 1f       	adc	r25, r19
    1d2c:	85 5a       	subi	r24, 0xA5	; 165
    1d2e:	95 4e       	sbci	r25, 0xE5	; 229
    1d30:	2a 85       	ldd	r18, Y+10	; 0x0a
    1d32:	3b 85       	ldd	r19, Y+11	; 0x0b
    1d34:	28 17       	cp	r18, r24
    1d36:	39 07       	cpc	r19, r25
    1d38:	11 f5       	brne	.+68     	; 0x1d7e <vTaskPriorityInherit+0x9e>
				{
					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    1d3a:	8e 01       	movw	r16, r28
    1d3c:	0e 5f       	subi	r16, 0xFE	; 254
    1d3e:	1f 4f       	sbci	r17, 0xFF	; 255
    1d40:	c8 01       	movw	r24, r16
    1d42:	0e 94 bb 03 	call	0x776	; 0x776 <uxListRemove>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    1d46:	e0 91 4a 1a 	lds	r30, 0x1A4A
    1d4a:	f0 91 4b 1a 	lds	r31, 0x1A4B
    1d4e:	86 89       	ldd	r24, Z+22	; 0x16
    1d50:	8e 8b       	std	Y+22, r24	; 0x16
					prvAddTaskToReadyQueue( pxTCB );
    1d52:	90 91 51 1a 	lds	r25, 0x1A51
    1d56:	98 17       	cp	r25, r24
    1d58:	10 f4       	brcc	.+4      	; 0x1d5e <vTaskPriorityInherit+0x7e>
    1d5a:	80 93 51 1a 	sts	0x1A51, r24
    1d5e:	90 e0       	ldi	r25, 0x00	; 0
    1d60:	9c 01       	movw	r18, r24
    1d62:	22 0f       	add	r18, r18
    1d64:	33 1f       	adc	r19, r19
    1d66:	22 0f       	add	r18, r18
    1d68:	33 1f       	adc	r19, r19
    1d6a:	22 0f       	add	r18, r18
    1d6c:	33 1f       	adc	r19, r19
    1d6e:	82 0f       	add	r24, r18
    1d70:	93 1f       	adc	r25, r19
    1d72:	85 5a       	subi	r24, 0xA5	; 165
    1d74:	95 4e       	sbci	r25, 0xE5	; 229
    1d76:	b8 01       	movw	r22, r16
    1d78:	0e 94 55 03 	call	0x6aa	; 0x6aa <vListInsertEnd>
    1d7c:	06 c0       	rjmp	.+12     	; 0x1d8a <vTaskPriorityInherit+0xaa>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    1d7e:	e0 91 4a 1a 	lds	r30, 0x1A4A
    1d82:	f0 91 4b 1a 	lds	r31, 0x1A4B
    1d86:	86 89       	ldd	r24, Z+22	; 0x16
    1d88:	8e 8b       	std	Y+22, r24	; 0x16
				}

				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
			}
		}
	}
    1d8a:	df 91       	pop	r29
    1d8c:	cf 91       	pop	r28
    1d8e:	1f 91       	pop	r17
    1d90:	0f 91       	pop	r16
    1d92:	08 95       	ret

00001d94 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    1d94:	0f 93       	push	r16
    1d96:	1f 93       	push	r17
    1d98:	cf 93       	push	r28
    1d9a:	df 93       	push	r29
    1d9c:	ec 01       	movw	r28, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    1d9e:	00 97       	sbiw	r24, 0x00	; 0
    1da0:	49 f1       	breq	.+82     	; 0x1df4 <vTaskPriorityDisinherit+0x60>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    1da2:	9e 89       	ldd	r25, Y+22	; 0x16
    1da4:	89 a5       	lds	r24, 0x69
    1da6:	98 17       	cp	r25, r24
    1da8:	29 f1       	breq	.+74     	; 0x1df4 <vTaskPriorityDisinherit+0x60>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    1daa:	8e 01       	movw	r16, r28
    1dac:	0e 5f       	subi	r16, 0xFE	; 254
    1dae:	1f 4f       	sbci	r17, 0xFF	; 255
    1db0:	c8 01       	movw	r24, r16
    1db2:	0e 94 bb 03 	call	0x776	; 0x776 <uxListRemove>
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    1db6:	49 a5       	lds	r20, 0x69
    1db8:	4e 8b       	std	Y+22, r20	; 0x16
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    1dba:	24 2f       	mov	r18, r20
    1dbc:	30 e0       	ldi	r19, 0x00	; 0
    1dbe:	84 e0       	ldi	r24, 0x04	; 4
    1dc0:	90 e0       	ldi	r25, 0x00	; 0
    1dc2:	82 1b       	sub	r24, r18
    1dc4:	93 0b       	sbc	r25, r19
    1dc6:	9d 87       	std	Y+13, r25	; 0x0d
    1dc8:	8c 87       	std	Y+12, r24	; 0x0c
				prvAddTaskToReadyQueue( pxTCB );
    1dca:	80 91 51 1a 	lds	r24, 0x1A51
    1dce:	84 17       	cp	r24, r20
    1dd0:	10 f4       	brcc	.+4      	; 0x1dd6 <vTaskPriorityDisinherit+0x42>
    1dd2:	40 93 51 1a 	sts	0x1A51, r20
    1dd6:	c9 01       	movw	r24, r18
    1dd8:	88 0f       	add	r24, r24
    1dda:	99 1f       	adc	r25, r25
    1ddc:	88 0f       	add	r24, r24
    1dde:	99 1f       	adc	r25, r25
    1de0:	88 0f       	add	r24, r24
    1de2:	99 1f       	adc	r25, r25
    1de4:	28 0f       	add	r18, r24
    1de6:	39 1f       	adc	r19, r25
    1de8:	c9 01       	movw	r24, r18
    1dea:	85 5a       	subi	r24, 0xA5	; 165
    1dec:	95 4e       	sbci	r25, 0xE5	; 229
    1dee:	b8 01       	movw	r22, r16
    1df0:	0e 94 55 03 	call	0x6aa	; 0x6aa <vListInsertEnd>
			}
		}
	}
    1df4:	df 91       	pop	r29
    1df6:	cf 91       	pop	r28
    1df8:	1f 91       	pop	r17
    1dfa:	0f 91       	pop	r16
    1dfc:	08 95       	ret

00001dfe <memcpy>:
    1dfe:	fb 01       	movw	r30, r22
    1e00:	dc 01       	movw	r26, r24
    1e02:	02 c0       	rjmp	.+4      	; 0x1e08 <memcpy+0xa>
    1e04:	01 90       	ld	r0, Z+
    1e06:	0d 92       	st	X+, r0
    1e08:	41 50       	subi	r20, 0x01	; 1
    1e0a:	50 40       	sbci	r21, 0x00	; 0
    1e0c:	d8 f7       	brcc	.-10     	; 0x1e04 <memcpy+0x6>
    1e0e:	08 95       	ret

00001e10 <memset>:
    1e10:	dc 01       	movw	r26, r24
    1e12:	01 c0       	rjmp	.+2      	; 0x1e16 <memset+0x6>
    1e14:	6d 93       	st	X+, r22
    1e16:	41 50       	subi	r20, 0x01	; 1
    1e18:	50 40       	sbci	r21, 0x00	; 0
    1e1a:	e0 f7       	brcc	.-8      	; 0x1e14 <memset+0x4>
    1e1c:	08 95       	ret

00001e1e <strncpy>:
    1e1e:	fb 01       	movw	r30, r22
    1e20:	dc 01       	movw	r26, r24
    1e22:	41 50       	subi	r20, 0x01	; 1
    1e24:	50 40       	sbci	r21, 0x00	; 0
    1e26:	48 f0       	brcs	.+18     	; 0x1e3a <strncpy+0x1c>
    1e28:	01 90       	ld	r0, Z+
    1e2a:	0d 92       	st	X+, r0
    1e2c:	00 20       	and	r0, r0
    1e2e:	c9 f7       	brne	.-14     	; 0x1e22 <strncpy+0x4>
    1e30:	01 c0       	rjmp	.+2      	; 0x1e34 <strncpy+0x16>
    1e32:	1d 92       	st	X+, r1
    1e34:	41 50       	subi	r20, 0x01	; 1
    1e36:	50 40       	sbci	r21, 0x00	; 0
    1e38:	e0 f7       	brcc	.-8      	; 0x1e32 <strncpy+0x14>
    1e3a:	08 95       	ret

00001e3c <_exit>:
    1e3c:	f8 94       	cli

00001e3e <__stop_program>:
    1e3e:	ff cf       	rjmp	.-2      	; 0x1e3e <__stop_program>
