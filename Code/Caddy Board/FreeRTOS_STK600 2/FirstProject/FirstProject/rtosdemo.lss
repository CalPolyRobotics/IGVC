
rtosdemo.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001a  00800200  000039ba  00003a4e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000039ba  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000018b3  0080021a  0080021a  00003a68  2**0
                  ALLOC
  3 .stab         000083dc  00000000  00000000  00003a68  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000039a4  00000000  00000000  0000be44  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  0000f7e8  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__ctors_end>
       4:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
       8:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
       c:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      10:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      14:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      18:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      1c:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      20:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      24:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      28:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      2c:	0c 94 67 1b 	jmp	0x36ce	; 0x36ce <__vector_11>
      30:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      34:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      38:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      3c:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      40:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      44:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      48:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      4c:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      50:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      54:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      58:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      5c:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      60:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      64:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      68:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      6c:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      70:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      74:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      78:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      7c:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      80:	0c 94 36 19 	jmp	0x326c	; 0x326c <__vector_32>
      84:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      88:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      8c:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      90:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      94:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      98:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      9c:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      a0:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      a4:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      a8:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      ac:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      b0:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      b4:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      b8:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      bc:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      c0:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      c4:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      c8:	0c 94 df 01 	jmp	0x3be	; 0x3be <__vector_50>
      cc:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      d0:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      d4:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      d8:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      dc:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>
      e0:	0c 94 9d 00 	jmp	0x13a	; 0x13a <__bad_interrupt>

000000e4 <__trampolines_start>:
      e4:	0c 94 6b 1a 	jmp	0x34d6	; 0x34d6 <vTaskUARTRead>
      e8:	0c 94 21 02 	jmp	0x442	; 0x442 <vTaskFunction_1>
      ec:	0c 94 3f 1a 	jmp	0x347e	; 0x347e <vTaskUARTWrite>
      f0:	0c 94 e4 08 	jmp	0x11c8	; 0x11c8 <prvIdleTask>
      f4:	0c 94 00 1c 	jmp	0x3800	; 0x3800 <vTaskSonar>

000000f8 <__ctors_end>:
      f8:	11 24       	eor	r1, r1
      fa:	1f be       	out	0x3f, r1	; 63
      fc:	cf ef       	ldi	r28, 0xFF	; 255
      fe:	d1 e2       	ldi	r29, 0x21	; 33
     100:	de bf       	out	0x3e, r29	; 62
     102:	cd bf       	out	0x3d, r28	; 61
     104:	00 e0       	ldi	r16, 0x00	; 0
     106:	0c bf       	out	0x3c, r16	; 60

00000108 <__do_copy_data>:
     108:	12 e0       	ldi	r17, 0x02	; 2
     10a:	a0 e0       	ldi	r26, 0x00	; 0
     10c:	b2 e0       	ldi	r27, 0x02	; 2
     10e:	ea eb       	ldi	r30, 0xBA	; 186
     110:	f9 e3       	ldi	r31, 0x39	; 57
     112:	00 e0       	ldi	r16, 0x00	; 0
     114:	0b bf       	out	0x3b, r16	; 59
     116:	02 c0       	rjmp	.+4      	; 0x11c <__do_copy_data+0x14>
     118:	07 90       	elpm	r0, Z+
     11a:	0d 92       	st	X+, r0
     11c:	aa 31       	cpi	r26, 0x1A	; 26
     11e:	b1 07       	cpc	r27, r17
     120:	d9 f7       	brne	.-10     	; 0x118 <__do_copy_data+0x10>

00000122 <__do_clear_bss>:
     122:	1a e1       	ldi	r17, 0x1A	; 26
     124:	aa e1       	ldi	r26, 0x1A	; 26
     126:	b2 e0       	ldi	r27, 0x02	; 2
     128:	01 c0       	rjmp	.+2      	; 0x12c <.do_clear_bss_start>

0000012a <.do_clear_bss_loop>:
     12a:	1d 92       	st	X+, r1

0000012c <.do_clear_bss_start>:
     12c:	ad 3c       	cpi	r26, 0xCD	; 205
     12e:	b1 07       	cpc	r27, r17
     130:	e1 f7       	brne	.-8      	; 0x12a <.do_clear_bss_loop>
     132:	0e 94 af 00 	call	0x15e	; 0x15e <main>
     136:	0c 94 db 1c 	jmp	0x39b6	; 0x39b6 <_exit>

0000013a <__bad_interrupt>:
     13a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000013e <vApplicationTickHook>:
int count = 0;

int sonarTime;

void vApplicationTickHook()
{
     13e:	cf 93       	push	r28
     140:	df 93       	push	r29
     142:	cd b7       	in	r28, 0x3d	; 61
     144:	de b7       	in	r29, 0x3e	; 62
    count++;
     146:	80 91 1a 02 	lds	r24, 0x021A
     14a:	90 91 1b 02 	lds	r25, 0x021B
     14e:	01 96       	adiw	r24, 0x01	; 1
     150:	90 93 1b 02 	sts	0x021B, r25
     154:	80 93 1a 02 	sts	0x021A, r24
}
     158:	df 91       	pop	r29
     15a:	cf 91       	pop	r28
     15c:	08 95       	ret

0000015e <main>:
/*-----------------------------------------------------------*/

int main( void )
{
     15e:	af 92       	push	r10
     160:	bf 92       	push	r11
     162:	cf 92       	push	r12
     164:	df 92       	push	r13
     166:	ef 92       	push	r14
     168:	ff 92       	push	r15
     16a:	0f 93       	push	r16
     16c:	cf 93       	push	r28
     16e:	df 93       	push	r29
     170:	00 d0       	rcall	.+0      	; 0x172 <main+0x14>
     172:	00 d0       	rcall	.+0      	; 0x174 <main+0x16>
     174:	cd b7       	in	r28, 0x3d	; 61
     176:	de b7       	in	r29, 0x3e	; 62
    
    //- wimpy variable defs
	uint8_t val[2] = {0x3F, 0xFE};
     178:	8f e3       	ldi	r24, 0x3F	; 63
     17a:	8d 83       	std	Y+5, r24	; 0x05
     17c:	8e ef       	ldi	r24, 0xFE	; 254
     17e:	8e 83       	std	Y+6, r24	; 0x06
    uint8_t *val0, *val1;
    
	//- avoid pesky warnings...
	val0 = val + 0;
     180:	ce 01       	movw	r24, r28
     182:	05 96       	adiw	r24, 0x05	; 5
     184:	9a 83       	std	Y+2, r25	; 0x02
     186:	89 83       	std	Y+1, r24	; 0x01
	val1 = val + 1;
     188:	ce 01       	movw	r24, r28
     18a:	05 96       	adiw	r24, 0x05	; 5
     18c:	01 96       	adiw	r24, 0x01	; 1
     18e:	9c 83       	std	Y+4, r25	; 0x04
     190:	8b 83       	std	Y+3, r24	; 0x03
    
	DDRD = 0xFF;
     192:	8a e2       	ldi	r24, 0x2A	; 42
     194:	90 e0       	ldi	r25, 0x00	; 0
     196:	2f ef       	ldi	r18, 0xFF	; 255
     198:	fc 01       	movw	r30, r24
     19a:	20 83       	st	Z, r18
	DDRE = 0xFF;
     19c:	8d e2       	ldi	r24, 0x2D	; 45
     19e:	90 e0       	ldi	r25, 0x00	; 0
     1a0:	2f ef       	ldi	r18, 0xFF	; 255
     1a2:	fc 01       	movw	r30, r24
     1a4:	20 83       	st	Z, r18
	DDRK = 0;
     1a6:	87 e0       	ldi	r24, 0x07	; 7
     1a8:	91 e0       	ldi	r25, 0x01	; 1
     1aa:	fc 01       	movw	r30, r24
     1ac:	10 82       	st	Z, r1

	PORTD = 0;
     1ae:	8b e2       	ldi	r24, 0x2B	; 43
     1b0:	90 e0       	ldi	r25, 0x00	; 0
     1b2:	fc 01       	movw	r30, r24
     1b4:	10 82       	st	Z, r1
	PORTE = 0;
     1b6:	8e e2       	ldi	r24, 0x2E	; 46
     1b8:	90 e0       	ldi	r25, 0x00	; 0
     1ba:	fc 01       	movw	r30, r24
     1bc:	10 82       	st	Z, r1
	PORTK = 2;
     1be:	88 e0       	ldi	r24, 0x08	; 8
     1c0:	91 e0       	ldi	r25, 0x01	; 1
     1c2:	22 e0       	ldi	r18, 0x02	; 2
     1c4:	fc 01       	movw	r30, r24
     1c6:	20 83       	st	Z, r18

    //- init IO with goodness
	vIO_init();
     1c8:	0e 94 36 02 	call	0x46c	; 0x46c <vIO_init>

	//- Create a 
	xTaskCreate( (pdTASK_CODE) vTaskFunction_1, (signed char *) "T0", configMINIMAL_STACK_SIZE+1000,
     1cc:	8b 81       	ldd	r24, Y+3	; 0x03
     1ce:	9c 81       	ldd	r25, Y+4	; 0x04
     1d0:	a1 2c       	mov	r10, r1
     1d2:	b1 2c       	mov	r11, r1
     1d4:	c1 2c       	mov	r12, r1
     1d6:	d1 2c       	mov	r13, r1
     1d8:	e1 2c       	mov	r14, r1
     1da:	f1 2c       	mov	r15, r1
     1dc:	01 e0       	ldi	r16, 0x01	; 1
     1de:	9c 01       	movw	r18, r24
     1e0:	4d e3       	ldi	r20, 0x3D	; 61
     1e2:	54 e0       	ldi	r21, 0x04	; 4
     1e4:	62 e0       	ldi	r22, 0x02	; 2
     1e6:	72 e0       	ldi	r23, 0x02	; 2
     1e8:	81 e2       	ldi	r24, 0x21	; 33
     1ea:	92 e0       	ldi	r25, 0x02	; 2
     1ec:	0e 94 47 02 	call	0x48e	; 0x48e <xTaskGenericCreate>
                (void *) val1, 1, NULL );
    
   xTaskCreate( (pdTASK_CODE) vTaskSonar, (signed char *) "T0", configMINIMAL_STACK_SIZE,
     1f0:	8b 81       	ldd	r24, Y+3	; 0x03
     1f2:	9c 81       	ldd	r25, Y+4	; 0x04
     1f4:	a1 2c       	mov	r10, r1
     1f6:	b1 2c       	mov	r11, r1
     1f8:	c1 2c       	mov	r12, r1
     1fa:	d1 2c       	mov	r13, r1
     1fc:	e1 2c       	mov	r14, r1
     1fe:	f1 2c       	mov	r15, r1
     200:	01 e0       	ldi	r16, 0x01	; 1
     202:	9c 01       	movw	r18, r24
     204:	45 e5       	ldi	r20, 0x55	; 85
     206:	50 e0       	ldi	r21, 0x00	; 0
     208:	62 e0       	ldi	r22, 0x02	; 2
     20a:	72 e0       	ldi	r23, 0x02	; 2
     20c:	80 e0       	ldi	r24, 0x00	; 0
     20e:	9c e1       	ldi	r25, 0x1C	; 28
     210:	0e 94 47 02 	call	0x48e	; 0x48e <xTaskGenericCreate>
                (void *) val1, 1, NULL );

   xTaskCreate( (pdTASK_CODE) vTaskUARTWrite, (signed char *) "T0", configMINIMAL_STACK_SIZE,
     214:	8b 81       	ldd	r24, Y+3	; 0x03
     216:	9c 81       	ldd	r25, Y+4	; 0x04
     218:	a1 2c       	mov	r10, r1
     21a:	b1 2c       	mov	r11, r1
     21c:	c1 2c       	mov	r12, r1
     21e:	d1 2c       	mov	r13, r1
     220:	e1 2c       	mov	r14, r1
     222:	f1 2c       	mov	r15, r1
     224:	01 e0       	ldi	r16, 0x01	; 1
     226:	9c 01       	movw	r18, r24
     228:	45 e5       	ldi	r20, 0x55	; 85
     22a:	50 e0       	ldi	r21, 0x00	; 0
     22c:	62 e0       	ldi	r22, 0x02	; 2
     22e:	72 e0       	ldi	r23, 0x02	; 2
     230:	8f e3       	ldi	r24, 0x3F	; 63
     232:	9a e1       	ldi	r25, 0x1A	; 26
     234:	0e 94 47 02 	call	0x48e	; 0x48e <xTaskGenericCreate>
   				(void *) val1, 1, NULL);

   xTaskCreate( (pdTASK_CODE) vTaskUARTRead, (signed char *) "T0", configMINIMAL_STACK_SIZE,
     238:	8b 81       	ldd	r24, Y+3	; 0x03
     23a:	9c 81       	ldd	r25, Y+4	; 0x04
     23c:	a1 2c       	mov	r10, r1
     23e:	b1 2c       	mov	r11, r1
     240:	c1 2c       	mov	r12, r1
     242:	d1 2c       	mov	r13, r1
     244:	e1 2c       	mov	r14, r1
     246:	f1 2c       	mov	r15, r1
     248:	01 e0       	ldi	r16, 0x01	; 1
     24a:	9c 01       	movw	r18, r24
     24c:	45 e5       	ldi	r20, 0x55	; 85
     24e:	50 e0       	ldi	r21, 0x00	; 0
     250:	62 e0       	ldi	r22, 0x02	; 2
     252:	72 e0       	ldi	r23, 0x02	; 2
     254:	8b e6       	ldi	r24, 0x6B	; 107
     256:	9a e1       	ldi	r25, 0x1A	; 26
     258:	0e 94 47 02 	call	0x48e	; 0x48e <xTaskGenericCreate>
   				(void *) val1, 1, NULL);

    
    //- kick off the scheduler
	vTaskStartScheduler();
     25c:	0e 94 46 05 	call	0xa8c	; 0xa8c <vTaskStartScheduler>
    
	return 0;
     260:	80 e0       	ldi	r24, 0x00	; 0
     262:	90 e0       	ldi	r25, 0x00	; 0
}
     264:	26 96       	adiw	r28, 0x06	; 6
     266:	0f b6       	in	r0, 0x3f	; 63
     268:	f8 94       	cli
     26a:	de bf       	out	0x3e, r29	; 62
     26c:	0f be       	out	0x3f, r0	; 63
     26e:	cd bf       	out	0x3d, r28	; 61
     270:	df 91       	pop	r29
     272:	cf 91       	pop	r28
     274:	0f 91       	pop	r16
     276:	ff 90       	pop	r15
     278:	ef 90       	pop	r14
     27a:	df 90       	pop	r13
     27c:	cf 90       	pop	r12
     27e:	bf 90       	pop	r11
     280:	af 90       	pop	r10
     282:	08 95       	ret

00000284 <printHex>:
/*-----------------------------------------------------------*/

void printHex(int i){
     284:	cf 93       	push	r28
     286:	df 93       	push	r29
     288:	cd b7       	in	r28, 0x3d	; 61
     28a:	de b7       	in	r29, 0x3e	; 62
     28c:	62 97       	sbiw	r28, 0x12	; 18
     28e:	0f b6       	in	r0, 0x3f	; 63
     290:	f8 94       	cli
     292:	de bf       	out	0x3e, r29	; 62
     294:	0f be       	out	0x3f, r0	; 63
     296:	cd bf       	out	0x3d, r28	; 61
     298:	9a 8b       	std	Y+18, r25	; 0x12
     29a:	89 8b       	std	Y+17, r24	; 0x11
	char hex[] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
     29c:	20 e1       	ldi	r18, 0x10	; 16
     29e:	e5 e0       	ldi	r30, 0x05	; 5
     2a0:	f2 e0       	ldi	r31, 0x02	; 2
     2a2:	ce 01       	movw	r24, r28
     2a4:	01 96       	adiw	r24, 0x01	; 1
     2a6:	dc 01       	movw	r26, r24
     2a8:	01 90       	ld	r0, Z+
     2aa:	0d 92       	st	X+, r0
     2ac:	2a 95       	dec	r18
     2ae:	e1 f7       	brne	.-8      	; 0x2a8 <printHex+0x24>

	USART_Write(hex[(i&0xF000) >> 12]);
     2b0:	89 89       	ldd	r24, Y+17	; 0x11
     2b2:	9a 89       	ldd	r25, Y+18	; 0x12
     2b4:	89 2f       	mov	r24, r25
     2b6:	99 27       	eor	r25, r25
     2b8:	82 95       	swap	r24
     2ba:	8f 70       	andi	r24, 0x0F	; 15
     2bc:	9e 01       	movw	r18, r28
     2be:	2f 5f       	subi	r18, 0xFF	; 255
     2c0:	3f 4f       	sbci	r19, 0xFF	; 255
     2c2:	82 0f       	add	r24, r18
     2c4:	93 1f       	adc	r25, r19
     2c6:	fc 01       	movw	r30, r24
     2c8:	80 81       	ld	r24, Z
     2ca:	0e 94 a6 19 	call	0x334c	; 0x334c <USART_Write>
	USART_Write(hex[(i&0xF00) >> 8]);
     2ce:	89 89       	ldd	r24, Y+17	; 0x11
     2d0:	9a 89       	ldd	r25, Y+18	; 0x12
     2d2:	88 27       	eor	r24, r24
     2d4:	9f 70       	andi	r25, 0x0F	; 15
     2d6:	89 2f       	mov	r24, r25
     2d8:	99 0f       	add	r25, r25
     2da:	99 0b       	sbc	r25, r25
     2dc:	9e 01       	movw	r18, r28
     2de:	2f 5f       	subi	r18, 0xFF	; 255
     2e0:	3f 4f       	sbci	r19, 0xFF	; 255
     2e2:	82 0f       	add	r24, r18
     2e4:	93 1f       	adc	r25, r19
     2e6:	fc 01       	movw	r30, r24
     2e8:	80 81       	ld	r24, Z
     2ea:	0e 94 a6 19 	call	0x334c	; 0x334c <USART_Write>
	USART_Write(hex[(i&0xF0) >> 4]);
     2ee:	89 89       	ldd	r24, Y+17	; 0x11
     2f0:	9a 89       	ldd	r25, Y+18	; 0x12
     2f2:	80 7f       	andi	r24, 0xF0	; 240
     2f4:	99 27       	eor	r25, r25
     2f6:	95 95       	asr	r25
     2f8:	87 95       	ror	r24
     2fa:	95 95       	asr	r25
     2fc:	87 95       	ror	r24
     2fe:	95 95       	asr	r25
     300:	87 95       	ror	r24
     302:	95 95       	asr	r25
     304:	87 95       	ror	r24
     306:	9e 01       	movw	r18, r28
     308:	2f 5f       	subi	r18, 0xFF	; 255
     30a:	3f 4f       	sbci	r19, 0xFF	; 255
     30c:	82 0f       	add	r24, r18
     30e:	93 1f       	adc	r25, r19
     310:	fc 01       	movw	r30, r24
     312:	80 81       	ld	r24, Z
     314:	0e 94 a6 19 	call	0x334c	; 0x334c <USART_Write>
	USART_Write(hex[i&0xF]);
     318:	89 89       	ldd	r24, Y+17	; 0x11
     31a:	9a 89       	ldd	r25, Y+18	; 0x12
     31c:	8f 70       	andi	r24, 0x0F	; 15
     31e:	99 27       	eor	r25, r25
     320:	9e 01       	movw	r18, r28
     322:	2f 5f       	subi	r18, 0xFF	; 255
     324:	3f 4f       	sbci	r19, 0xFF	; 255
     326:	82 0f       	add	r24, r18
     328:	93 1f       	adc	r25, r19
     32a:	fc 01       	movw	r30, r24
     32c:	80 81       	ld	r24, Z
     32e:	0e 94 a6 19 	call	0x334c	; 0x334c <USART_Write>

}
     332:	62 96       	adiw	r28, 0x12	; 18
     334:	0f b6       	in	r0, 0x3f	; 63
     336:	f8 94       	cli
     338:	de bf       	out	0x3e, r29	; 62
     33a:	0f be       	out	0x3f, r0	; 63
     33c:	cd bf       	out	0x3d, r28	; 61
     33e:	df 91       	pop	r29
     340:	cf 91       	pop	r28
     342:	08 95       	ret

00000344 <printNum>:

void printNum(unsigned char i){
     344:	cf 93       	push	r28
     346:	df 93       	push	r29
     348:	cd b7       	in	r28, 0x3d	; 61
     34a:	de b7       	in	r29, 0x3e	; 62
     34c:	2d 97       	sbiw	r28, 0x0d	; 13
     34e:	0f b6       	in	r0, 0x3f	; 63
     350:	f8 94       	cli
     352:	de bf       	out	0x3e, r29	; 62
     354:	0f be       	out	0x3f, r0	; 63
     356:	cd bf       	out	0x3d, r28	; 61
     358:	8d 87       	std	Y+13, r24	; 0x0d
    
    char str[10];
    memset(str,0,10);
     35a:	ce 01       	movw	r24, r28
     35c:	03 96       	adiw	r24, 0x03	; 3
     35e:	4a e0       	ldi	r20, 0x0A	; 10
     360:	50 e0       	ldi	r21, 0x00	; 0
     362:	60 e0       	ldi	r22, 0x00	; 0
     364:	70 e0       	ldi	r23, 0x00	; 0
     366:	0e 94 80 1c 	call	0x3900	; 0x3900 <memset>
    itoa(i,str,9);
     36a:	8d 85       	ldd	r24, Y+13	; 0x0d
     36c:	88 2f       	mov	r24, r24
     36e:	90 e0       	ldi	r25, 0x00	; 0
     370:	9e 01       	movw	r18, r28
     372:	2d 5f       	subi	r18, 0xFD	; 253
     374:	3f 4f       	sbci	r19, 0xFF	; 255
     376:	49 e0       	ldi	r20, 0x09	; 9
     378:	50 e0       	ldi	r21, 0x00	; 0
     37a:	b9 01       	movw	r22, r18
     37c:	0e 94 96 1c 	call	0x392c	; 0x392c <itoa>
    char * irr = str;
     380:	ce 01       	movw	r24, r28
     382:	03 96       	adiw	r24, 0x03	; 3
     384:	9a 83       	std	Y+2, r25	; 0x02
     386:	89 83       	std	Y+1, r24	; 0x01
    while(*irr){
     388:	0b c0       	rjmp	.+22     	; 0x3a0 <printNum+0x5c>
        USART_Write((unsigned char )*irr);
     38a:	89 81       	ldd	r24, Y+1	; 0x01
     38c:	9a 81       	ldd	r25, Y+2	; 0x02
     38e:	fc 01       	movw	r30, r24
     390:	80 81       	ld	r24, Z
     392:	0e 94 a6 19 	call	0x334c	; 0x334c <USART_Write>
        irr++;
     396:	89 81       	ldd	r24, Y+1	; 0x01
     398:	9a 81       	ldd	r25, Y+2	; 0x02
     39a:	01 96       	adiw	r24, 0x01	; 1
     39c:	9a 83       	std	Y+2, r25	; 0x02
     39e:	89 83       	std	Y+1, r24	; 0x01
    
    char str[10];
    memset(str,0,10);
    itoa(i,str,9);
    char * irr = str;
    while(*irr){
     3a0:	89 81       	ldd	r24, Y+1	; 0x01
     3a2:	9a 81       	ldd	r25, Y+2	; 0x02
     3a4:	fc 01       	movw	r30, r24
     3a6:	80 81       	ld	r24, Z
     3a8:	88 23       	and	r24, r24
     3aa:	79 f7       	brne	.-34     	; 0x38a <printNum+0x46>
        USART_Write((unsigned char )*irr);
        irr++;
    }
    
}
     3ac:	2d 96       	adiw	r28, 0x0d	; 13
     3ae:	0f b6       	in	r0, 0x3f	; 63
     3b0:	f8 94       	cli
     3b2:	de bf       	out	0x3e, r29	; 62
     3b4:	0f be       	out	0x3f, r0	; 63
     3b6:	cd bf       	out	0x3d, r28	; 61
     3b8:	df 91       	pop	r29
     3ba:	cf 91       	pop	r28
     3bc:	08 95       	ret

000003be <__vector_50>:

ISR(TIMER5_OVF_vect){
     3be:	1f 92       	push	r1
     3c0:	0f 92       	push	r0
     3c2:	00 90 5f 00 	lds	r0, 0x005F
     3c6:	0f 92       	push	r0
     3c8:	11 24       	eor	r1, r1
     3ca:	00 90 5b 00 	lds	r0, 0x005B
     3ce:	0f 92       	push	r0
     3d0:	2f 93       	push	r18
     3d2:	3f 93       	push	r19
     3d4:	8f 93       	push	r24
     3d6:	9f 93       	push	r25
     3d8:	ef 93       	push	r30
     3da:	ff 93       	push	r31
     3dc:	cf 93       	push	r28
     3de:	df 93       	push	r29
     3e0:	cd b7       	in	r28, 0x3d	; 61
     3e2:	de b7       	in	r29, 0x3e	; 62

	PORTB ^= 0xFF;
     3e4:	85 e2       	ldi	r24, 0x25	; 37
     3e6:	90 e0       	ldi	r25, 0x00	; 0
     3e8:	25 e2       	ldi	r18, 0x25	; 37
     3ea:	30 e0       	ldi	r19, 0x00	; 0
     3ec:	f9 01       	movw	r30, r18
     3ee:	20 81       	ld	r18, Z
     3f0:	20 95       	com	r18
     3f2:	fc 01       	movw	r30, r24
     3f4:	20 83       	st	Z, r18
	TCNT3L = 0;
     3f6:	84 e9       	ldi	r24, 0x94	; 148
     3f8:	90 e0       	ldi	r25, 0x00	; 0
     3fa:	fc 01       	movw	r30, r24
     3fc:	10 82       	st	Z, r1
	TCNT3H = 0;
     3fe:	85 e9       	ldi	r24, 0x95	; 149
     400:	90 e0       	ldi	r25, 0x00	; 0
     402:	fc 01       	movw	r30, r24
     404:	10 82       	st	Z, r1

}
     406:	df 91       	pop	r29
     408:	cf 91       	pop	r28
     40a:	ff 91       	pop	r31
     40c:	ef 91       	pop	r30
     40e:	9f 91       	pop	r25
     410:	8f 91       	pop	r24
     412:	3f 91       	pop	r19
     414:	2f 91       	pop	r18
     416:	0f 90       	pop	r0
     418:	00 92 5b 00 	sts	0x005B, r0
     41c:	0f 90       	pop	r0
     41e:	00 92 5f 00 	sts	0x005F, r0
     422:	0f 90       	pop	r0
     424:	1f 90       	pop	r1
     426:	18 95       	reti

00000428 <getTimerCount2>:

unsigned int getTimerCount2(){
     428:	cf 93       	push	r28
     42a:	df 93       	push	r29
     42c:	cd b7       	in	r28, 0x3d	; 61
     42e:	de b7       	in	r29, 0x3e	; 62

	//volatile char timerLow = TCNT3L;

	return TCNT0;
     430:	86 e4       	ldi	r24, 0x46	; 70
     432:	90 e0       	ldi	r25, 0x00	; 0
     434:	fc 01       	movw	r30, r24
     436:	80 81       	ld	r24, Z
     438:	88 2f       	mov	r24, r24
     43a:	90 e0       	ldi	r25, 0x00	; 0

}
     43c:	df 91       	pop	r29
     43e:	cf 91       	pop	r28
     440:	08 95       	ret

00000442 <vTaskFunction_1>:

void vTaskFunction_1(void *pvParameters)
{	
     442:	cf 93       	push	r28
     444:	df 93       	push	r29
     446:	1f 92       	push	r1
     448:	1f 92       	push	r1
     44a:	cd b7       	in	r28, 0x3d	; 61
     44c:	de b7       	in	r29, 0x3e	; 62
     44e:	9a 83       	std	Y+2, r25	; 0x02
     450:	89 83       	std	Y+1, r24	; 0x01
    USART_Init(9600, 16000000);
     452:	40 e0       	ldi	r20, 0x00	; 0
     454:	54 e2       	ldi	r21, 0x24	; 36
     456:	64 ef       	ldi	r22, 0xF4	; 244
     458:	70 e0       	ldi	r23, 0x00	; 0
     45a:	80 e8       	ldi	r24, 0x80	; 128
     45c:	95 e2       	ldi	r25, 0x25	; 37
     45e:	0e 94 39 19 	call	0x3272	; 0x3272 <USART_Init>
		//PORTB = 0;
		//USART_AddToQueue('%');
		//USART_TransmitString("Hello World!\n");

		//USART_TransmitString("H\n");
		vTaskDelay(25);
     462:	89 e1       	ldi	r24, 0x19	; 25
     464:	90 e0       	ldi	r25, 0x00	; 0
     466:	0e 94 b4 03 	call	0x768	; 0x768 <vTaskDelay>
	}
     46a:	fb cf       	rjmp	.-10     	; 0x462 <vTaskFunction_1+0x20>

0000046c <vIO_init>:
        // UDR0;
    }
}

void vIO_init(void)
{
     46c:	cf 93       	push	r28
     46e:	df 93       	push	r29
     470:	cd b7       	in	r28, 0x3d	; 61
     472:	de b7       	in	r29, 0x3e	; 62
    //- set PortB as output
	DDRB = 0xFF; 
     474:	84 e2       	ldi	r24, 0x24	; 36
     476:	90 e0       	ldi	r25, 0x00	; 0
     478:	2f ef       	ldi	r18, 0xFF	; 255
     47a:	fc 01       	movw	r30, r24
     47c:	20 83       	st	Z, r18
    PORTB = 0xFF; 
     47e:	85 e2       	ldi	r24, 0x25	; 37
     480:	90 e0       	ldi	r25, 0x00	; 0
     482:	2f ef       	ldi	r18, 0xFF	; 255
     484:	fc 01       	movw	r30, r24
     486:	20 83       	st	Z, r18
}
     488:	df 91       	pop	r29
     48a:	cf 91       	pop	r28
     48c:	08 95       	ret

0000048e <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
     48e:	af 92       	push	r10
     490:	bf 92       	push	r11
     492:	cf 92       	push	r12
     494:	df 92       	push	r13
     496:	ef 92       	push	r14
     498:	ff 92       	push	r15
     49a:	0f 93       	push	r16
     49c:	1f 93       	push	r17
     49e:	cf 93       	push	r28
     4a0:	df 93       	push	r29
     4a2:	cd b7       	in	r28, 0x3d	; 61
     4a4:	de b7       	in	r29, 0x3e	; 62
     4a6:	64 97       	sbiw	r28, 0x14	; 20
     4a8:	0f b6       	in	r0, 0x3f	; 63
     4aa:	f8 94       	cli
     4ac:	de bf       	out	0x3e, r29	; 62
     4ae:	0f be       	out	0x3f, r0	; 63
     4b0:	cd bf       	out	0x3d, r28	; 61
     4b2:	9f 83       	std	Y+7, r25	; 0x07
     4b4:	8e 83       	std	Y+6, r24	; 0x06
     4b6:	79 87       	std	Y+9, r23	; 0x09
     4b8:	68 87       	std	Y+8, r22	; 0x08
     4ba:	5b 87       	std	Y+11, r21	; 0x0b
     4bc:	4a 87       	std	Y+10, r20	; 0x0a
     4be:	3d 87       	std	Y+13, r19	; 0x0d
     4c0:	2c 87       	std	Y+12, r18	; 0x0c
     4c2:	0e 87       	std	Y+14, r16	; 0x0e
     4c4:	f8 8a       	std	Y+16, r15	; 0x10
     4c6:	ef 86       	std	Y+15, r14	; 0x0f
     4c8:	da 8a       	std	Y+18, r13	; 0x12
     4ca:	c9 8a       	std	Y+17, r12	; 0x11
     4cc:	bc 8a       	std	Y+20, r11	; 0x14
     4ce:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
     4d0:	29 89       	ldd	r18, Y+17	; 0x11
     4d2:	3a 89       	ldd	r19, Y+18	; 0x12
     4d4:	8a 85       	ldd	r24, Y+10	; 0x0a
     4d6:	9b 85       	ldd	r25, Y+11	; 0x0b
     4d8:	b9 01       	movw	r22, r18
     4da:	0e 94 e6 09 	call	0x13cc	; 0x13cc <prvAllocateTCBAndStack>
     4de:	9b 83       	std	Y+3, r25	; 0x03
     4e0:	8a 83       	std	Y+2, r24	; 0x02

	if( pxNewTCB != NULL )
     4e2:	8a 81       	ldd	r24, Y+2	; 0x02
     4e4:	9b 81       	ldd	r25, Y+3	; 0x03
     4e6:	00 97       	sbiw	r24, 0x00	; 0
     4e8:	09 f4       	brne	.+2      	; 0x4ec <xTaskGenericCreate+0x5e>
     4ea:	9f c0       	rjmp	.+318    	; 0x62a <xTaskGenericCreate+0x19c>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
     4ec:	8a 81       	ldd	r24, Y+2	; 0x02
     4ee:	9b 81       	ldd	r25, Y+3	; 0x03
     4f0:	fc 01       	movw	r30, r24
     4f2:	27 89       	ldd	r18, Z+23	; 0x17
     4f4:	30 8d       	ldd	r19, Z+24	; 0x18
     4f6:	8a 85       	ldd	r24, Y+10	; 0x0a
     4f8:	9b 85       	ldd	r25, Y+11	; 0x0b
     4fa:	01 97       	sbiw	r24, 0x01	; 1
     4fc:	82 0f       	add	r24, r18
     4fe:	93 1f       	adc	r25, r19
     500:	9d 83       	std	Y+5, r25	; 0x05
     502:	8c 83       	std	Y+4, r24	; 0x04
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
     504:	4a 85       	ldd	r20, Y+10	; 0x0a
     506:	5b 85       	ldd	r21, Y+11	; 0x0b
     508:	2b 89       	ldd	r18, Y+19	; 0x13
     50a:	3c 89       	ldd	r19, Y+20	; 0x14
     50c:	68 85       	ldd	r22, Y+8	; 0x08
     50e:	79 85       	ldd	r23, Y+9	; 0x09
     510:	8a 81       	ldd	r24, Y+2	; 0x02
     512:	9b 81       	ldd	r25, Y+3	; 0x03
     514:	8a 01       	movw	r16, r20
     516:	4e 85       	ldd	r20, Y+14	; 0x0e
     518:	0e 94 f6 08 	call	0x11ec	; 0x11ec <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     51c:	4c 85       	ldd	r20, Y+12	; 0x0c
     51e:	5d 85       	ldd	r21, Y+13	; 0x0d
     520:	2e 81       	ldd	r18, Y+6	; 0x06
     522:	3f 81       	ldd	r19, Y+7	; 0x07
     524:	8c 81       	ldd	r24, Y+4	; 0x04
     526:	9d 81       	ldd	r25, Y+5	; 0x05
     528:	b9 01       	movw	r22, r18
     52a:	0e 94 0e 16 	call	0x2c1c	; 0x2c1c <pxPortInitialiseStack>
     52e:	9c 01       	movw	r18, r24
     530:	8a 81       	ldd	r24, Y+2	; 0x02
     532:	9b 81       	ldd	r25, Y+3	; 0x03
     534:	fc 01       	movw	r30, r24
     536:	31 83       	std	Z+1, r19	; 0x01
     538:	20 83       	st	Z, r18
		#endif

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
     53a:	8f 85       	ldd	r24, Y+15	; 0x0f
     53c:	98 89       	ldd	r25, Y+16	; 0x10
     53e:	00 97       	sbiw	r24, 0x00	; 0
     540:	39 f0       	breq	.+14     	; 0x550 <xTaskGenericCreate+0xc2>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
     542:	8f 85       	ldd	r24, Y+15	; 0x0f
     544:	98 89       	ldd	r25, Y+16	; 0x10
     546:	2a 81       	ldd	r18, Y+2	; 0x02
     548:	3b 81       	ldd	r19, Y+3	; 0x03
     54a:	fc 01       	movw	r30, r24
     54c:	31 83       	std	Z+1, r19	; 0x01
     54e:	20 83       	st	Z, r18
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
     550:	0f b6       	in	r0, 0x3f	; 63
     552:	f8 94       	cli
     554:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
     556:	80 91 6a 02 	lds	r24, 0x026A
     55a:	8f 5f       	subi	r24, 0xFF	; 255
     55c:	80 93 6a 02 	sts	0x026A, r24
			if( pxCurrentTCB == NULL )
     560:	80 91 1c 02 	lds	r24, 0x021C
     564:	90 91 1d 02 	lds	r25, 0x021D
     568:	00 97       	sbiw	r24, 0x00	; 0
     56a:	69 f4       	brne	.+26     	; 0x586 <xTaskGenericCreate+0xf8>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
     56c:	8a 81       	ldd	r24, Y+2	; 0x02
     56e:	9b 81       	ldd	r25, Y+3	; 0x03
     570:	90 93 1d 02 	sts	0x021D, r25
     574:	80 93 1c 02 	sts	0x021C, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
     578:	80 91 6a 02 	lds	r24, 0x026A
     57c:	81 30       	cpi	r24, 0x01	; 1
     57e:	b1 f4       	brne	.+44     	; 0x5ac <xTaskGenericCreate+0x11e>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
     580:	0e 94 57 09 	call	0x12ae	; 0x12ae <prvInitialiseTaskLists>
     584:	13 c0       	rjmp	.+38     	; 0x5ac <xTaskGenericCreate+0x11e>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
     586:	80 91 6f 02 	lds	r24, 0x026F
     58a:	88 23       	and	r24, r24
     58c:	79 f4       	brne	.+30     	; 0x5ac <xTaskGenericCreate+0x11e>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
     58e:	80 91 1c 02 	lds	r24, 0x021C
     592:	90 91 1d 02 	lds	r25, 0x021D
     596:	fc 01       	movw	r30, r24
     598:	96 89       	ldd	r25, Z+22	; 0x16
     59a:	8e 85       	ldd	r24, Y+14	; 0x0e
     59c:	89 17       	cp	r24, r25
     59e:	30 f0       	brcs	.+12     	; 0x5ac <xTaskGenericCreate+0x11e>
					{
						pxCurrentTCB = pxNewTCB;
     5a0:	8a 81       	ldd	r24, Y+2	; 0x02
     5a2:	9b 81       	ldd	r25, Y+3	; 0x03
     5a4:	90 93 1d 02 	sts	0x021D, r25
     5a8:	80 93 1c 02 	sts	0x021C, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
     5ac:	8a 81       	ldd	r24, Y+2	; 0x02
     5ae:	9b 81       	ldd	r25, Y+3	; 0x03
     5b0:	fc 01       	movw	r30, r24
     5b2:	96 89       	ldd	r25, Z+22	; 0x16
     5b4:	80 91 6d 02 	lds	r24, 0x026D
     5b8:	89 17       	cp	r24, r25
     5ba:	30 f4       	brcc	.+12     	; 0x5c8 <xTaskGenericCreate+0x13a>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
     5bc:	8a 81       	ldd	r24, Y+2	; 0x02
     5be:	9b 81       	ldd	r25, Y+3	; 0x03
     5c0:	fc 01       	movw	r30, r24
     5c2:	86 89       	ldd	r24, Z+22	; 0x16
     5c4:	80 93 6d 02 	sts	0x026D, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
     5c8:	80 91 74 02 	lds	r24, 0x0274
     5cc:	8f 5f       	subi	r24, 0xFF	; 255
     5ce:	80 93 74 02 	sts	0x0274, r24

			prvAddTaskToReadyQueue( pxNewTCB );
     5d2:	8a 81       	ldd	r24, Y+2	; 0x02
     5d4:	9b 81       	ldd	r25, Y+3	; 0x03
     5d6:	fc 01       	movw	r30, r24
     5d8:	96 89       	ldd	r25, Z+22	; 0x16
     5da:	80 91 6e 02 	lds	r24, 0x026E
     5de:	89 17       	cp	r24, r25
     5e0:	30 f4       	brcc	.+12     	; 0x5ee <xTaskGenericCreate+0x160>
     5e2:	8a 81       	ldd	r24, Y+2	; 0x02
     5e4:	9b 81       	ldd	r25, Y+3	; 0x03
     5e6:	fc 01       	movw	r30, r24
     5e8:	86 89       	ldd	r24, Z+22	; 0x16
     5ea:	80 93 6e 02 	sts	0x026E, r24
     5ee:	8a 81       	ldd	r24, Y+2	; 0x02
     5f0:	9b 81       	ldd	r25, Y+3	; 0x03
     5f2:	ac 01       	movw	r20, r24
     5f4:	4e 5f       	subi	r20, 0xFE	; 254
     5f6:	5f 4f       	sbci	r21, 0xFF	; 255
     5f8:	8a 81       	ldd	r24, Y+2	; 0x02
     5fa:	9b 81       	ldd	r25, Y+3	; 0x03
     5fc:	fc 01       	movw	r30, r24
     5fe:	86 89       	ldd	r24, Z+22	; 0x16
     600:	28 2f       	mov	r18, r24
     602:	30 e0       	ldi	r19, 0x00	; 0
     604:	c9 01       	movw	r24, r18
     606:	88 0f       	add	r24, r24
     608:	99 1f       	adc	r25, r25
     60a:	88 0f       	add	r24, r24
     60c:	99 1f       	adc	r25, r25
     60e:	88 0f       	add	r24, r24
     610:	99 1f       	adc	r25, r25
     612:	82 0f       	add	r24, r18
     614:	93 1f       	adc	r25, r19
     616:	82 5e       	subi	r24, 0xE2	; 226
     618:	9d 4f       	sbci	r25, 0xFD	; 253
     61a:	ba 01       	movw	r22, r20
     61c:	0e 94 80 11 	call	0x2300	; 0x2300 <vListInsertEnd>

			xReturn = pdPASS;
     620:	81 e0       	ldi	r24, 0x01	; 1
     622:	89 83       	std	Y+1, r24	; 0x01
			portSETUP_TCB( pxNewTCB );
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
     624:	0f 90       	pop	r0
     626:	0f be       	out	0x3f, r0	; 63
     628:	02 c0       	rjmp	.+4      	; 0x62e <xTaskGenericCreate+0x1a0>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     62a:	8f ef       	ldi	r24, 0xFF	; 255
     62c:	89 83       	std	Y+1, r24	; 0x01
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
     62e:	89 81       	ldd	r24, Y+1	; 0x01
     630:	81 30       	cpi	r24, 0x01	; 1
     632:	79 f4       	brne	.+30     	; 0x652 <xTaskGenericCreate+0x1c4>
	{
		if( xSchedulerRunning != pdFALSE )
     634:	80 91 6f 02 	lds	r24, 0x026F
     638:	88 23       	and	r24, r24
     63a:	59 f0       	breq	.+22     	; 0x652 <xTaskGenericCreate+0x1c4>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
     63c:	80 91 1c 02 	lds	r24, 0x021C
     640:	90 91 1d 02 	lds	r25, 0x021D
     644:	fc 01       	movw	r30, r24
     646:	96 89       	ldd	r25, Z+22	; 0x16
     648:	8e 85       	ldd	r24, Y+14	; 0x0e
     64a:	98 17       	cp	r25, r24
     64c:	10 f4       	brcc	.+4      	; 0x652 <xTaskGenericCreate+0x1c4>
			{
				portYIELD_WITHIN_API();
     64e:	0e 94 12 18 	call	0x3024	; 0x3024 <vPortYield>
			}
		}
	}

	return xReturn;
     652:	89 81       	ldd	r24, Y+1	; 0x01
}
     654:	64 96       	adiw	r28, 0x14	; 20
     656:	0f b6       	in	r0, 0x3f	; 63
     658:	f8 94       	cli
     65a:	de bf       	out	0x3e, r29	; 62
     65c:	0f be       	out	0x3f, r0	; 63
     65e:	cd bf       	out	0x3d, r28	; 61
     660:	df 91       	pop	r29
     662:	cf 91       	pop	r28
     664:	1f 91       	pop	r17
     666:	0f 91       	pop	r16
     668:	ff 90       	pop	r15
     66a:	ef 90       	pop	r14
     66c:	df 90       	pop	r13
     66e:	cf 90       	pop	r12
     670:	bf 90       	pop	r11
     672:	af 90       	pop	r10
     674:	08 95       	ret

00000676 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
     676:	cf 93       	push	r28
     678:	df 93       	push	r29
     67a:	cd b7       	in	r28, 0x3d	; 61
     67c:	de b7       	in	r29, 0x3e	; 62
     67e:	28 97       	sbiw	r28, 0x08	; 8
     680:	0f b6       	in	r0, 0x3f	; 63
     682:	f8 94       	cli
     684:	de bf       	out	0x3e, r29	; 62
     686:	0f be       	out	0x3f, r0	; 63
     688:	cd bf       	out	0x3d, r28	; 61
     68a:	9e 83       	std	Y+6, r25	; 0x06
     68c:	8d 83       	std	Y+5, r24	; 0x05
     68e:	78 87       	std	Y+8, r23	; 0x08
     690:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
     692:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
     694:	0e 94 88 05 	call	0xb10	; 0xb10 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     698:	8d 81       	ldd	r24, Y+5	; 0x05
     69a:	9e 81       	ldd	r25, Y+6	; 0x06
     69c:	fc 01       	movw	r30, r24
     69e:	20 81       	ld	r18, Z
     6a0:	31 81       	ldd	r19, Z+1	; 0x01
     6a2:	8f 81       	ldd	r24, Y+7	; 0x07
     6a4:	98 85       	ldd	r25, Y+8	; 0x08
     6a6:	82 0f       	add	r24, r18
     6a8:	93 1f       	adc	r25, r19
     6aa:	9b 83       	std	Y+3, r25	; 0x03
     6ac:	8a 83       	std	Y+2, r24	; 0x02

			if( xTickCount < *pxPreviousWakeTime )
     6ae:	8d 81       	ldd	r24, Y+5	; 0x05
     6b0:	9e 81       	ldd	r25, Y+6	; 0x06
     6b2:	fc 01       	movw	r30, r24
     6b4:	20 81       	ld	r18, Z
     6b6:	31 81       	ldd	r19, Z+1	; 0x01
     6b8:	80 91 6b 02 	lds	r24, 0x026B
     6bc:	90 91 6c 02 	lds	r25, 0x026C
     6c0:	82 17       	cp	r24, r18
     6c2:	93 07       	cpc	r25, r19
     6c4:	b0 f4       	brcc	.+44     	; 0x6f2 <vTaskDelayUntil+0x7c>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
     6c6:	8d 81       	ldd	r24, Y+5	; 0x05
     6c8:	9e 81       	ldd	r25, Y+6	; 0x06
     6ca:	fc 01       	movw	r30, r24
     6cc:	20 81       	ld	r18, Z
     6ce:	31 81       	ldd	r19, Z+1	; 0x01
     6d0:	8a 81       	ldd	r24, Y+2	; 0x02
     6d2:	9b 81       	ldd	r25, Y+3	; 0x03
     6d4:	82 17       	cp	r24, r18
     6d6:	93 07       	cpc	r25, r19
     6d8:	08 f5       	brcc	.+66     	; 0x71c <vTaskDelayUntil+0xa6>
     6da:	80 91 6b 02 	lds	r24, 0x026B
     6de:	90 91 6c 02 	lds	r25, 0x026C
     6e2:	2a 81       	ldd	r18, Y+2	; 0x02
     6e4:	3b 81       	ldd	r19, Y+3	; 0x03
     6e6:	82 17       	cp	r24, r18
     6e8:	93 07       	cpc	r25, r19
     6ea:	c0 f4       	brcc	.+48     	; 0x71c <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
     6ec:	81 e0       	ldi	r24, 0x01	; 1
     6ee:	89 83       	std	Y+1, r24	; 0x01
     6f0:	15 c0       	rjmp	.+42     	; 0x71c <vTaskDelayUntil+0xa6>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
     6f2:	8d 81       	ldd	r24, Y+5	; 0x05
     6f4:	9e 81       	ldd	r25, Y+6	; 0x06
     6f6:	fc 01       	movw	r30, r24
     6f8:	20 81       	ld	r18, Z
     6fa:	31 81       	ldd	r19, Z+1	; 0x01
     6fc:	8a 81       	ldd	r24, Y+2	; 0x02
     6fe:	9b 81       	ldd	r25, Y+3	; 0x03
     700:	82 17       	cp	r24, r18
     702:	93 07       	cpc	r25, r19
     704:	48 f0       	brcs	.+18     	; 0x718 <vTaskDelayUntil+0xa2>
     706:	80 91 6b 02 	lds	r24, 0x026B
     70a:	90 91 6c 02 	lds	r25, 0x026C
     70e:	2a 81       	ldd	r18, Y+2	; 0x02
     710:	3b 81       	ldd	r19, Y+3	; 0x03
     712:	82 17       	cp	r24, r18
     714:	93 07       	cpc	r25, r19
     716:	10 f4       	brcc	.+4      	; 0x71c <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
     718:	81 e0       	ldi	r24, 0x01	; 1
     71a:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     71c:	8d 81       	ldd	r24, Y+5	; 0x05
     71e:	9e 81       	ldd	r25, Y+6	; 0x06
     720:	2a 81       	ldd	r18, Y+2	; 0x02
     722:	3b 81       	ldd	r19, Y+3	; 0x03
     724:	fc 01       	movw	r30, r24
     726:	31 83       	std	Z+1, r19	; 0x01
     728:	20 83       	st	Z, r18

			if( xShouldDelay != pdFALSE )
     72a:	89 81       	ldd	r24, Y+1	; 0x01
     72c:	88 23       	and	r24, r24
     72e:	59 f0       	breq	.+22     	; 0x746 <vTaskDelayUntil+0xd0>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
     730:	80 91 1c 02 	lds	r24, 0x021C
     734:	90 91 1d 02 	lds	r25, 0x021D
     738:	02 96       	adiw	r24, 0x02	; 2
     73a:	0e 94 50 12 	call	0x24a0	; 0x24a0 <uxListRemove>
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
     73e:	8a 81       	ldd	r24, Y+2	; 0x02
     740:	9b 81       	ldd	r25, Y+3	; 0x03
     742:	0e 94 9b 09 	call	0x1336	; 0x1336 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     746:	0e 94 94 05 	call	0xb28	; 0xb28 <xTaskResumeAll>
     74a:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     74c:	8c 81       	ldd	r24, Y+4	; 0x04
     74e:	88 23       	and	r24, r24
     750:	11 f4       	brne	.+4      	; 0x756 <vTaskDelayUntil+0xe0>
		{
			portYIELD_WITHIN_API();
     752:	0e 94 12 18 	call	0x3024	; 0x3024 <vPortYield>
		}
	}
     756:	28 96       	adiw	r28, 0x08	; 8
     758:	0f b6       	in	r0, 0x3f	; 63
     75a:	f8 94       	cli
     75c:	de bf       	out	0x3e, r29	; 62
     75e:	0f be       	out	0x3f, r0	; 63
     760:	cd bf       	out	0x3d, r28	; 61
     762:	df 91       	pop	r29
     764:	cf 91       	pop	r28
     766:	08 95       	ret

00000768 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
     768:	cf 93       	push	r28
     76a:	df 93       	push	r29
     76c:	00 d0       	rcall	.+0      	; 0x76e <vTaskDelay+0x6>
     76e:	1f 92       	push	r1
     770:	1f 92       	push	r1
     772:	cd b7       	in	r28, 0x3d	; 61
     774:	de b7       	in	r29, 0x3e	; 62
     776:	9d 83       	std	Y+5, r25	; 0x05
     778:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
     77a:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
     77c:	8c 81       	ldd	r24, Y+4	; 0x04
     77e:	9d 81       	ldd	r25, Y+5	; 0x05
     780:	00 97       	sbiw	r24, 0x00	; 0
     782:	d1 f0       	breq	.+52     	; 0x7b8 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
     784:	0e 94 88 05 	call	0xb10	; 0xb10 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
     788:	20 91 6b 02 	lds	r18, 0x026B
     78c:	30 91 6c 02 	lds	r19, 0x026C
     790:	8c 81       	ldd	r24, Y+4	; 0x04
     792:	9d 81       	ldd	r25, Y+5	; 0x05
     794:	82 0f       	add	r24, r18
     796:	93 1f       	adc	r25, r19
     798:	9b 83       	std	Y+3, r25	; 0x03
     79a:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
     79c:	80 91 1c 02 	lds	r24, 0x021C
     7a0:	90 91 1d 02 	lds	r25, 0x021D
     7a4:	02 96       	adiw	r24, 0x02	; 2
     7a6:	0e 94 50 12 	call	0x24a0	; 0x24a0 <uxListRemove>
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
     7aa:	8a 81       	ldd	r24, Y+2	; 0x02
     7ac:	9b 81       	ldd	r25, Y+3	; 0x03
     7ae:	0e 94 9b 09 	call	0x1336	; 0x1336 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     7b2:	0e 94 94 05 	call	0xb28	; 0xb28 <xTaskResumeAll>
     7b6:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     7b8:	89 81       	ldd	r24, Y+1	; 0x01
     7ba:	88 23       	and	r24, r24
     7bc:	11 f4       	brne	.+4      	; 0x7c2 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
     7be:	0e 94 12 18 	call	0x3024	; 0x3024 <vPortYield>
		}
	}
     7c2:	0f 90       	pop	r0
     7c4:	0f 90       	pop	r0
     7c6:	0f 90       	pop	r0
     7c8:	0f 90       	pop	r0
     7ca:	0f 90       	pop	r0
     7cc:	df 91       	pop	r29
     7ce:	cf 91       	pop	r28
     7d0:	08 95       	ret

000007d2 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
     7d2:	cf 93       	push	r28
     7d4:	df 93       	push	r29
     7d6:	00 d0       	rcall	.+0      	; 0x7d8 <vTaskSuspend+0x6>
     7d8:	1f 92       	push	r1
     7da:	cd b7       	in	r28, 0x3d	; 61
     7dc:	de b7       	in	r29, 0x3e	; 62
     7de:	9c 83       	std	Y+4, r25	; 0x04
     7e0:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
     7e2:	0f b6       	in	r0, 0x3f	; 63
     7e4:	f8 94       	cli
     7e6:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
     7e8:	80 91 1c 02 	lds	r24, 0x021C
     7ec:	90 91 1d 02 	lds	r25, 0x021D
     7f0:	2b 81       	ldd	r18, Y+3	; 0x03
     7f2:	3c 81       	ldd	r19, Y+4	; 0x04
     7f4:	28 17       	cp	r18, r24
     7f6:	39 07       	cpc	r19, r25
     7f8:	11 f4       	brne	.+4      	; 0x7fe <vTaskSuspend+0x2c>
			{
				pxTaskToSuspend = NULL;
     7fa:	1c 82       	std	Y+4, r1	; 0x04
     7fc:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
     7fe:	8b 81       	ldd	r24, Y+3	; 0x03
     800:	9c 81       	ldd	r25, Y+4	; 0x04
     802:	00 97       	sbiw	r24, 0x00	; 0
     804:	29 f4       	brne	.+10     	; 0x810 <vTaskSuspend+0x3e>
     806:	80 91 1c 02 	lds	r24, 0x021C
     80a:	90 91 1d 02 	lds	r25, 0x021D
     80e:	02 c0       	rjmp	.+4      	; 0x814 <vTaskSuspend+0x42>
     810:	8b 81       	ldd	r24, Y+3	; 0x03
     812:	9c 81       	ldd	r25, Y+4	; 0x04
     814:	9a 83       	std	Y+2, r25	; 0x02
     816:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
     818:	89 81       	ldd	r24, Y+1	; 0x01
     81a:	9a 81       	ldd	r25, Y+2	; 0x02
     81c:	02 96       	adiw	r24, 0x02	; 2
     81e:	0e 94 50 12 	call	0x24a0	; 0x24a0 <uxListRemove>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
			}

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
     822:	89 81       	ldd	r24, Y+1	; 0x01
     824:	9a 81       	ldd	r25, Y+2	; 0x02
     826:	fc 01       	movw	r30, r24
     828:	84 89       	ldd	r24, Z+20	; 0x14
     82a:	95 89       	ldd	r25, Z+21	; 0x15
     82c:	00 97       	sbiw	r24, 0x00	; 0
     82e:	29 f0       	breq	.+10     	; 0x83a <vTaskSuspend+0x68>
			{
				uxListRemove( &( pxTCB->xEventListItem ) );
     830:	89 81       	ldd	r24, Y+1	; 0x01
     832:	9a 81       	ldd	r25, Y+2	; 0x02
     834:	0c 96       	adiw	r24, 0x0c	; 12
     836:	0e 94 50 12 	call	0x24a0	; 0x24a0 <uxListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
     83a:	89 81       	ldd	r24, Y+1	; 0x01
     83c:	9a 81       	ldd	r25, Y+2	; 0x02
     83e:	02 96       	adiw	r24, 0x02	; 2
     840:	bc 01       	movw	r22, r24
     842:	81 e6       	ldi	r24, 0x61	; 97
     844:	92 e0       	ldi	r25, 0x02	; 2
     846:	0e 94 80 11 	call	0x2300	; 0x2300 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
     84a:	0f 90       	pop	r0
     84c:	0f be       	out	0x3f, r0	; 63

		if( ( void * ) pxTaskToSuspend == NULL )
     84e:	8b 81       	ldd	r24, Y+3	; 0x03
     850:	9c 81       	ldd	r25, Y+4	; 0x04
     852:	00 97       	sbiw	r24, 0x00	; 0
     854:	a1 f4       	brne	.+40     	; 0x87e <vTaskSuspend+0xac>
		{
			if( xSchedulerRunning != pdFALSE )
     856:	80 91 6f 02 	lds	r24, 0x026F
     85a:	88 23       	and	r24, r24
     85c:	19 f0       	breq	.+6      	; 0x864 <vTaskSuspend+0x92>
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
     85e:	0e 94 12 18 	call	0x3024	; 0x3024 <vPortYield>
     862:	0d c0       	rjmp	.+26     	; 0x87e <vTaskSuspend+0xac>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
     864:	90 91 61 02 	lds	r25, 0x0261
     868:	80 91 6a 02 	lds	r24, 0x026A
     86c:	98 17       	cp	r25, r24
     86e:	29 f4       	brne	.+10     	; 0x87a <vTaskSuspend+0xa8>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
     870:	10 92 1d 02 	sts	0x021D, r1
     874:	10 92 1c 02 	sts	0x021C, r1
     878:	02 c0       	rjmp	.+4      	; 0x87e <vTaskSuspend+0xac>
				}
				else
				{
					vTaskSwitchContext();
     87a:	0e 94 32 07 	call	0xe64	; 0xe64 <vTaskSwitchContext>
				}
			}
		}
	}
     87e:	0f 90       	pop	r0
     880:	0f 90       	pop	r0
     882:	0f 90       	pop	r0
     884:	0f 90       	pop	r0
     886:	df 91       	pop	r29
     888:	cf 91       	pop	r28
     88a:	08 95       	ret

0000088c <xTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
     88c:	cf 93       	push	r28
     88e:	df 93       	push	r29
     890:	00 d0       	rcall	.+0      	; 0x892 <xTaskIsTaskSuspended+0x6>
     892:	1f 92       	push	r1
     894:	1f 92       	push	r1
     896:	cd b7       	in	r28, 0x3d	; 61
     898:	de b7       	in	r29, 0x3e	; 62
     89a:	9d 83       	std	Y+5, r25	; 0x05
     89c:	8c 83       	std	Y+4, r24	; 0x04
	portBASE_TYPE xReturn = pdFALSE;
     89e:	19 82       	std	Y+1, r1	; 0x01
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
     8a0:	8c 81       	ldd	r24, Y+4	; 0x04
     8a2:	9d 81       	ldd	r25, Y+5	; 0x05
     8a4:	9b 83       	std	Y+3, r25	; 0x03
     8a6:	8a 83       	std	Y+2, r24	; 0x02
		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
     8a8:	8a 81       	ldd	r24, Y+2	; 0x02
     8aa:	9b 81       	ldd	r25, Y+3	; 0x03
     8ac:	fc 01       	movw	r30, r24
     8ae:	82 85       	ldd	r24, Z+10	; 0x0a
     8b0:	93 85       	ldd	r25, Z+11	; 0x0b
     8b2:	f2 e0       	ldi	r31, 0x02	; 2
     8b4:	81 36       	cpi	r24, 0x61	; 97
     8b6:	9f 07       	cpc	r25, r31
     8b8:	91 f4       	brne	.+36     	; 0x8de <xTaskIsTaskSuspended+0x52>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
     8ba:	8a 81       	ldd	r24, Y+2	; 0x02
     8bc:	9b 81       	ldd	r25, Y+3	; 0x03
     8be:	fc 01       	movw	r30, r24
     8c0:	84 89       	ldd	r24, Z+20	; 0x14
     8c2:	95 89       	ldd	r25, Z+21	; 0x15
     8c4:	f2 e0       	ldi	r31, 0x02	; 2
     8c6:	88 35       	cpi	r24, 0x58	; 88
     8c8:	9f 07       	cpc	r25, r31
     8ca:	49 f0       	breq	.+18     	; 0x8de <xTaskIsTaskSuspended+0x52>
			{
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
     8cc:	8a 81       	ldd	r24, Y+2	; 0x02
     8ce:	9b 81       	ldd	r25, Y+3	; 0x03
     8d0:	fc 01       	movw	r30, r24
     8d2:	84 89       	ldd	r24, Z+20	; 0x14
     8d4:	95 89       	ldd	r25, Z+21	; 0x15
     8d6:	00 97       	sbiw	r24, 0x00	; 0
     8d8:	11 f4       	brne	.+4      	; 0x8de <xTaskIsTaskSuspended+0x52>
				{
					xReturn = pdTRUE;
     8da:	81 e0       	ldi	r24, 0x01	; 1
     8dc:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}

		return xReturn;
     8de:	89 81       	ldd	r24, Y+1	; 0x01
	}
     8e0:	0f 90       	pop	r0
     8e2:	0f 90       	pop	r0
     8e4:	0f 90       	pop	r0
     8e6:	0f 90       	pop	r0
     8e8:	0f 90       	pop	r0
     8ea:	df 91       	pop	r29
     8ec:	cf 91       	pop	r28
     8ee:	08 95       	ret

000008f0 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
     8f0:	cf 93       	push	r28
     8f2:	df 93       	push	r29
     8f4:	00 d0       	rcall	.+0      	; 0x8f6 <vTaskResume+0x6>
     8f6:	1f 92       	push	r1
     8f8:	cd b7       	in	r28, 0x3d	; 61
     8fa:	de b7       	in	r29, 0x3e	; 62
     8fc:	9c 83       	std	Y+4, r25	; 0x04
     8fe:	8b 83       	std	Y+3, r24	; 0x03
		/* It does not make sense to resume the calling task. */
		configASSERT( pxTaskToResume );

		/* Remove the task from whichever list it is currently in, and place
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;
     900:	8b 81       	ldd	r24, Y+3	; 0x03
     902:	9c 81       	ldd	r25, Y+4	; 0x04
     904:	9a 83       	std	Y+2, r25	; 0x02
     906:	89 83       	std	Y+1, r24	; 0x01

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
     908:	89 81       	ldd	r24, Y+1	; 0x01
     90a:	9a 81       	ldd	r25, Y+2	; 0x02
     90c:	00 97       	sbiw	r24, 0x00	; 0
     90e:	09 f4       	brne	.+2      	; 0x912 <vTaskResume+0x22>
     910:	4f c0       	rjmp	.+158    	; 0x9b0 <vTaskResume+0xc0>
     912:	80 91 1c 02 	lds	r24, 0x021C
     916:	90 91 1d 02 	lds	r25, 0x021D
     91a:	29 81       	ldd	r18, Y+1	; 0x01
     91c:	3a 81       	ldd	r19, Y+2	; 0x02
     91e:	28 17       	cp	r18, r24
     920:	39 07       	cpc	r19, r25
     922:	09 f4       	brne	.+2      	; 0x926 <vTaskResume+0x36>
     924:	45 c0       	rjmp	.+138    	; 0x9b0 <vTaskResume+0xc0>
		{
			taskENTER_CRITICAL();
     926:	0f b6       	in	r0, 0x3f	; 63
     928:	f8 94       	cli
     92a:	0f 92       	push	r0
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
     92c:	89 81       	ldd	r24, Y+1	; 0x01
     92e:	9a 81       	ldd	r25, Y+2	; 0x02
     930:	0e 94 46 04 	call	0x88c	; 0x88c <xTaskIsTaskSuspended>
     934:	81 30       	cpi	r24, 0x01	; 1
     936:	d1 f5       	brne	.+116    	; 0x9ac <vTaskResume+0xbc>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					uxListRemove(  &( pxTCB->xGenericListItem ) );
     938:	89 81       	ldd	r24, Y+1	; 0x01
     93a:	9a 81       	ldd	r25, Y+2	; 0x02
     93c:	02 96       	adiw	r24, 0x02	; 2
     93e:	0e 94 50 12 	call	0x24a0	; 0x24a0 <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
     942:	89 81       	ldd	r24, Y+1	; 0x01
     944:	9a 81       	ldd	r25, Y+2	; 0x02
     946:	fc 01       	movw	r30, r24
     948:	96 89       	ldd	r25, Z+22	; 0x16
     94a:	80 91 6e 02 	lds	r24, 0x026E
     94e:	89 17       	cp	r24, r25
     950:	30 f4       	brcc	.+12     	; 0x95e <vTaskResume+0x6e>
     952:	89 81       	ldd	r24, Y+1	; 0x01
     954:	9a 81       	ldd	r25, Y+2	; 0x02
     956:	fc 01       	movw	r30, r24
     958:	86 89       	ldd	r24, Z+22	; 0x16
     95a:	80 93 6e 02 	sts	0x026E, r24
     95e:	89 81       	ldd	r24, Y+1	; 0x01
     960:	9a 81       	ldd	r25, Y+2	; 0x02
     962:	ac 01       	movw	r20, r24
     964:	4e 5f       	subi	r20, 0xFE	; 254
     966:	5f 4f       	sbci	r21, 0xFF	; 255
     968:	89 81       	ldd	r24, Y+1	; 0x01
     96a:	9a 81       	ldd	r25, Y+2	; 0x02
     96c:	fc 01       	movw	r30, r24
     96e:	86 89       	ldd	r24, Z+22	; 0x16
     970:	28 2f       	mov	r18, r24
     972:	30 e0       	ldi	r19, 0x00	; 0
     974:	c9 01       	movw	r24, r18
     976:	88 0f       	add	r24, r24
     978:	99 1f       	adc	r25, r25
     97a:	88 0f       	add	r24, r24
     97c:	99 1f       	adc	r25, r25
     97e:	88 0f       	add	r24, r24
     980:	99 1f       	adc	r25, r25
     982:	82 0f       	add	r24, r18
     984:	93 1f       	adc	r25, r19
     986:	82 5e       	subi	r24, 0xE2	; 226
     988:	9d 4f       	sbci	r25, 0xFD	; 253
     98a:	ba 01       	movw	r22, r20
     98c:	0e 94 80 11 	call	0x2300	; 0x2300 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     990:	89 81       	ldd	r24, Y+1	; 0x01
     992:	9a 81       	ldd	r25, Y+2	; 0x02
     994:	fc 01       	movw	r30, r24
     996:	26 89       	ldd	r18, Z+22	; 0x16
     998:	80 91 1c 02 	lds	r24, 0x021C
     99c:	90 91 1d 02 	lds	r25, 0x021D
     9a0:	fc 01       	movw	r30, r24
     9a2:	86 89       	ldd	r24, Z+22	; 0x16
     9a4:	28 17       	cp	r18, r24
     9a6:	10 f0       	brcs	.+4      	; 0x9ac <vTaskResume+0xbc>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
     9a8:	0e 94 12 18 	call	0x3024	; 0x3024 <vPortYield>
					}
				}
			}
			taskEXIT_CRITICAL();
     9ac:	0f 90       	pop	r0
     9ae:	0f be       	out	0x3f, r0	; 63
		}
	}
     9b0:	0f 90       	pop	r0
     9b2:	0f 90       	pop	r0
     9b4:	0f 90       	pop	r0
     9b6:	0f 90       	pop	r0
     9b8:	df 91       	pop	r29
     9ba:	cf 91       	pop	r28
     9bc:	08 95       	ret

000009be <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
     9be:	cf 93       	push	r28
     9c0:	df 93       	push	r29
     9c2:	00 d0       	rcall	.+0      	; 0x9c4 <xTaskResumeFromISR+0x6>
     9c4:	00 d0       	rcall	.+0      	; 0x9c6 <xTaskResumeFromISR+0x8>
     9c6:	cd b7       	in	r28, 0x3d	; 61
     9c8:	de b7       	in	r29, 0x3e	; 62
     9ca:	9e 83       	std	Y+6, r25	; 0x06
     9cc:	8d 83       	std	Y+5, r24	; 0x05
	portBASE_TYPE xYieldRequired = pdFALSE;
     9ce:	19 82       	std	Y+1, r1	; 0x01
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxSavedInterruptStatus;

		configASSERT( pxTaskToResume );

		pxTCB = ( tskTCB * ) pxTaskToResume;
     9d0:	8d 81       	ldd	r24, Y+5	; 0x05
     9d2:	9e 81       	ldd	r25, Y+6	; 0x06
     9d4:	9b 83       	std	Y+3, r25	; 0x03
     9d6:	8a 83       	std	Y+2, r24	; 0x02

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     9d8:	1c 82       	std	Y+4, r1	; 0x04
		{
			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
     9da:	8a 81       	ldd	r24, Y+2	; 0x02
     9dc:	9b 81       	ldd	r25, Y+3	; 0x03
     9de:	0e 94 46 04 	call	0x88c	; 0x88c <xTaskIsTaskSuspended>
     9e2:	81 30       	cpi	r24, 0x01	; 1
     9e4:	09 f0       	breq	.+2      	; 0x9e8 <xTaskResumeFromISR+0x2a>
     9e6:	48 c0       	rjmp	.+144    	; 0xa78 <xTaskResumeFromISR+0xba>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     9e8:	80 91 70 02 	lds	r24, 0x0270
     9ec:	88 23       	and	r24, r24
     9ee:	e1 f5       	brne	.+120    	; 0xa68 <xTaskResumeFromISR+0xaa>
				{
					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
     9f0:	8a 81       	ldd	r24, Y+2	; 0x02
     9f2:	9b 81       	ldd	r25, Y+3	; 0x03
     9f4:	fc 01       	movw	r30, r24
     9f6:	26 89       	ldd	r18, Z+22	; 0x16
     9f8:	80 91 1c 02 	lds	r24, 0x021C
     9fc:	90 91 1d 02 	lds	r25, 0x021D
     a00:	fc 01       	movw	r30, r24
     a02:	96 89       	ldd	r25, Z+22	; 0x16
     a04:	81 e0       	ldi	r24, 0x01	; 1
     a06:	29 17       	cp	r18, r25
     a08:	08 f4       	brcc	.+2      	; 0xa0c <xTaskResumeFromISR+0x4e>
     a0a:	80 e0       	ldi	r24, 0x00	; 0
     a0c:	89 83       	std	Y+1, r24	; 0x01
					uxListRemove(  &( pxTCB->xGenericListItem ) );
     a0e:	8a 81       	ldd	r24, Y+2	; 0x02
     a10:	9b 81       	ldd	r25, Y+3	; 0x03
     a12:	02 96       	adiw	r24, 0x02	; 2
     a14:	0e 94 50 12 	call	0x24a0	; 0x24a0 <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
     a18:	8a 81       	ldd	r24, Y+2	; 0x02
     a1a:	9b 81       	ldd	r25, Y+3	; 0x03
     a1c:	fc 01       	movw	r30, r24
     a1e:	96 89       	ldd	r25, Z+22	; 0x16
     a20:	80 91 6e 02 	lds	r24, 0x026E
     a24:	89 17       	cp	r24, r25
     a26:	30 f4       	brcc	.+12     	; 0xa34 <xTaskResumeFromISR+0x76>
     a28:	8a 81       	ldd	r24, Y+2	; 0x02
     a2a:	9b 81       	ldd	r25, Y+3	; 0x03
     a2c:	fc 01       	movw	r30, r24
     a2e:	86 89       	ldd	r24, Z+22	; 0x16
     a30:	80 93 6e 02 	sts	0x026E, r24
     a34:	8a 81       	ldd	r24, Y+2	; 0x02
     a36:	9b 81       	ldd	r25, Y+3	; 0x03
     a38:	ac 01       	movw	r20, r24
     a3a:	4e 5f       	subi	r20, 0xFE	; 254
     a3c:	5f 4f       	sbci	r21, 0xFF	; 255
     a3e:	8a 81       	ldd	r24, Y+2	; 0x02
     a40:	9b 81       	ldd	r25, Y+3	; 0x03
     a42:	fc 01       	movw	r30, r24
     a44:	86 89       	ldd	r24, Z+22	; 0x16
     a46:	28 2f       	mov	r18, r24
     a48:	30 e0       	ldi	r19, 0x00	; 0
     a4a:	c9 01       	movw	r24, r18
     a4c:	88 0f       	add	r24, r24
     a4e:	99 1f       	adc	r25, r25
     a50:	88 0f       	add	r24, r24
     a52:	99 1f       	adc	r25, r25
     a54:	88 0f       	add	r24, r24
     a56:	99 1f       	adc	r25, r25
     a58:	82 0f       	add	r24, r18
     a5a:	93 1f       	adc	r25, r19
     a5c:	82 5e       	subi	r24, 0xE2	; 226
     a5e:	9d 4f       	sbci	r25, 0xFD	; 253
     a60:	ba 01       	movw	r22, r20
     a62:	0e 94 80 11 	call	0x2300	; 0x2300 <vListInsertEnd>
     a66:	08 c0       	rjmp	.+16     	; 0xa78 <xTaskResumeFromISR+0xba>
				else
				{
					/* We cannot access the delayed or ready lists, so will hold this
					task pending until the scheduler is resumed, at which point a
					yield will be performed if necessary. */
					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
     a68:	8a 81       	ldd	r24, Y+2	; 0x02
     a6a:	9b 81       	ldd	r25, Y+3	; 0x03
     a6c:	0c 96       	adiw	r24, 0x0c	; 12
     a6e:	bc 01       	movw	r22, r24
     a70:	88 e5       	ldi	r24, 0x58	; 88
     a72:	92 e0       	ldi	r25, 0x02	; 2
     a74:	0e 94 80 11 	call	0x2300	; 0x2300 <vListInsertEnd>
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
     a78:	89 81       	ldd	r24, Y+1	; 0x01
	}
     a7a:	26 96       	adiw	r28, 0x06	; 6
     a7c:	0f b6       	in	r0, 0x3f	; 63
     a7e:	f8 94       	cli
     a80:	de bf       	out	0x3e, r29	; 62
     a82:	0f be       	out	0x3f, r0	; 63
     a84:	cd bf       	out	0x3d, r28	; 61
     a86:	df 91       	pop	r29
     a88:	cf 91       	pop	r28
     a8a:	08 95       	ret

00000a8c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
     a8c:	af 92       	push	r10
     a8e:	bf 92       	push	r11
     a90:	cf 92       	push	r12
     a92:	df 92       	push	r13
     a94:	ef 92       	push	r14
     a96:	ff 92       	push	r15
     a98:	0f 93       	push	r16
     a9a:	cf 93       	push	r28
     a9c:	df 93       	push	r29
     a9e:	1f 92       	push	r1
     aa0:	cd b7       	in	r28, 0x3d	; 61
     aa2:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
     aa4:	a1 2c       	mov	r10, r1
     aa6:	b1 2c       	mov	r11, r1
     aa8:	c1 2c       	mov	r12, r1
     aaa:	d1 2c       	mov	r13, r1
     aac:	e1 2c       	mov	r14, r1
     aae:	f1 2c       	mov	r15, r1
     ab0:	00 e0       	ldi	r16, 0x00	; 0
     ab2:	20 e0       	ldi	r18, 0x00	; 0
     ab4:	30 e0       	ldi	r19, 0x00	; 0
     ab6:	45 e5       	ldi	r20, 0x55	; 85
     ab8:	50 e0       	ldi	r21, 0x00	; 0
     aba:	65 e1       	ldi	r22, 0x15	; 21
     abc:	72 e0       	ldi	r23, 0x02	; 2
     abe:	84 ee       	ldi	r24, 0xE4	; 228
     ac0:	98 e0       	ldi	r25, 0x08	; 8
     ac2:	0e 94 47 02 	call	0x48e	; 0x48e <xTaskGenericCreate>
     ac6:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
     ac8:	89 81       	ldd	r24, Y+1	; 0x01
     aca:	81 30       	cpi	r24, 0x01	; 1
     acc:	51 f4       	brne	.+20     	; 0xae2 <vTaskStartScheduler+0x56>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
     ace:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
     ad0:	81 e0       	ldi	r24, 0x01	; 1
     ad2:	80 93 6f 02 	sts	0x026F, r24
		xTickCount = ( portTickType ) 0U;
     ad6:	10 92 6c 02 	sts	0x026C, r1
     ada:	10 92 6b 02 	sts	0x026B, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     ade:	0e 94 d2 17 	call	0x2fa4	; 0x2fa4 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
     ae2:	0f 90       	pop	r0
     ae4:	df 91       	pop	r29
     ae6:	cf 91       	pop	r28
     ae8:	0f 91       	pop	r16
     aea:	ff 90       	pop	r15
     aec:	ef 90       	pop	r14
     aee:	df 90       	pop	r13
     af0:	cf 90       	pop	r12
     af2:	bf 90       	pop	r11
     af4:	af 90       	pop	r10
     af6:	08 95       	ret

00000af8 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
     af8:	cf 93       	push	r28
     afa:	df 93       	push	r29
     afc:	cd b7       	in	r28, 0x3d	; 61
     afe:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
     b00:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
     b02:	10 92 6f 02 	sts	0x026F, r1
	vPortEndScheduler();
     b06:	0e 94 0b 18 	call	0x3016	; 0x3016 <vPortEndScheduler>
}
     b0a:	df 91       	pop	r29
     b0c:	cf 91       	pop	r28
     b0e:	08 95       	ret

00000b10 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
     b10:	cf 93       	push	r28
     b12:	df 93       	push	r29
     b14:	cd b7       	in	r28, 0x3d	; 61
     b16:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
     b18:	80 91 70 02 	lds	r24, 0x0270
     b1c:	8f 5f       	subi	r24, 0xFF	; 255
     b1e:	80 93 70 02 	sts	0x0270, r24
}
     b22:	df 91       	pop	r29
     b24:	cf 91       	pop	r28
     b26:	08 95       	ret

00000b28 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE != 0  */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
     b28:	0f 93       	push	r16
     b2a:	1f 93       	push	r17
     b2c:	cf 93       	push	r28
     b2e:	df 93       	push	r29
     b30:	1f 92       	push	r1
     b32:	1f 92       	push	r1
     b34:	cd b7       	in	r28, 0x3d	; 61
     b36:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
     b38:	19 82       	std	Y+1, r1	; 0x01
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     b3a:	0f b6       	in	r0, 0x3f	; 63
     b3c:	f8 94       	cli
     b3e:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     b40:	80 91 70 02 	lds	r24, 0x0270
     b44:	81 50       	subi	r24, 0x01	; 1
     b46:	80 93 70 02 	sts	0x0270, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     b4a:	80 91 70 02 	lds	r24, 0x0270
     b4e:	88 23       	and	r24, r24
     b50:	09 f0       	breq	.+2      	; 0xb54 <xTaskResumeAll+0x2c>
     b52:	64 c0       	rjmp	.+200    	; 0xc1c <xTaskResumeAll+0xf4>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
     b54:	80 91 6a 02 	lds	r24, 0x026A
     b58:	88 23       	and	r24, r24
     b5a:	09 f4       	brne	.+2      	; 0xb5e <xTaskResumeAll+0x36>
     b5c:	5f c0       	rjmp	.+190    	; 0xc1c <xTaskResumeAll+0xf4>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
     b5e:	1a 82       	std	Y+2, r1	; 0x02

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
     b60:	3a c0       	rjmp	.+116    	; 0xbd6 <xTaskResumeAll+0xae>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
     b62:	80 91 5d 02 	lds	r24, 0x025D
     b66:	90 91 5e 02 	lds	r25, 0x025E
     b6a:	fc 01       	movw	r30, r24
     b6c:	06 81       	ldd	r16, Z+6	; 0x06
     b6e:	17 81       	ldd	r17, Z+7	; 0x07
					uxListRemove( &( pxTCB->xEventListItem ) );
     b70:	c8 01       	movw	r24, r16
     b72:	0c 96       	adiw	r24, 0x0c	; 12
     b74:	0e 94 50 12 	call	0x24a0	; 0x24a0 <uxListRemove>
					uxListRemove( &( pxTCB->xGenericListItem ) );
     b78:	c8 01       	movw	r24, r16
     b7a:	02 96       	adiw	r24, 0x02	; 2
     b7c:	0e 94 50 12 	call	0x24a0	; 0x24a0 <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
     b80:	f8 01       	movw	r30, r16
     b82:	96 89       	ldd	r25, Z+22	; 0x16
     b84:	80 91 6e 02 	lds	r24, 0x026E
     b88:	89 17       	cp	r24, r25
     b8a:	20 f4       	brcc	.+8      	; 0xb94 <xTaskResumeAll+0x6c>
     b8c:	f8 01       	movw	r30, r16
     b8e:	86 89       	ldd	r24, Z+22	; 0x16
     b90:	80 93 6e 02 	sts	0x026E, r24
     b94:	a8 01       	movw	r20, r16
     b96:	4e 5f       	subi	r20, 0xFE	; 254
     b98:	5f 4f       	sbci	r21, 0xFF	; 255
     b9a:	f8 01       	movw	r30, r16
     b9c:	86 89       	ldd	r24, Z+22	; 0x16
     b9e:	28 2f       	mov	r18, r24
     ba0:	30 e0       	ldi	r19, 0x00	; 0
     ba2:	c9 01       	movw	r24, r18
     ba4:	88 0f       	add	r24, r24
     ba6:	99 1f       	adc	r25, r25
     ba8:	88 0f       	add	r24, r24
     baa:	99 1f       	adc	r25, r25
     bac:	88 0f       	add	r24, r24
     bae:	99 1f       	adc	r25, r25
     bb0:	82 0f       	add	r24, r18
     bb2:	93 1f       	adc	r25, r19
     bb4:	82 5e       	subi	r24, 0xE2	; 226
     bb6:	9d 4f       	sbci	r25, 0xFD	; 253
     bb8:	ba 01       	movw	r22, r20
     bba:	0e 94 80 11 	call	0x2300	; 0x2300 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     bbe:	f8 01       	movw	r30, r16
     bc0:	26 89       	ldd	r18, Z+22	; 0x16
     bc2:	80 91 1c 02 	lds	r24, 0x021C
     bc6:	90 91 1d 02 	lds	r25, 0x021D
     bca:	fc 01       	movw	r30, r24
     bcc:	86 89       	ldd	r24, Z+22	; 0x16
     bce:	28 17       	cp	r18, r24
     bd0:	10 f0       	brcs	.+4      	; 0xbd6 <xTaskResumeAll+0xae>
					{
						xYieldRequired = pdTRUE;
     bd2:	81 e0       	ldi	r24, 0x01	; 1
     bd4:	8a 83       	std	Y+2, r24	; 0x02
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
     bd6:	80 91 58 02 	lds	r24, 0x0258
     bda:	88 23       	and	r24, r24
     bdc:	11 f6       	brne	.-124    	; 0xb62 <xTaskResumeAll+0x3a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
     bde:	80 91 71 02 	lds	r24, 0x0271
     be2:	88 23       	and	r24, r24
     be4:	71 f0       	breq	.+28     	; 0xc02 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
     be6:	07 c0       	rjmp	.+14     	; 0xbf6 <xTaskResumeAll+0xce>
					{
						vTaskIncrementTick();
     be8:	0e 94 4d 06 	call	0xc9a	; 0xc9a <vTaskIncrementTick>
						--uxMissedTicks;
     bec:	80 91 71 02 	lds	r24, 0x0271
     bf0:	81 50       	subi	r24, 0x01	; 1
     bf2:	80 93 71 02 	sts	0x0271, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
     bf6:	80 91 71 02 	lds	r24, 0x0271
     bfa:	88 23       	and	r24, r24
     bfc:	a9 f7       	brne	.-22     	; 0xbe8 <xTaskResumeAll+0xc0>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
     bfe:	81 e0       	ldi	r24, 0x01	; 1
     c00:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
     c02:	8a 81       	ldd	r24, Y+2	; 0x02
     c04:	81 30       	cpi	r24, 0x01	; 1
     c06:	21 f0       	breq	.+8      	; 0xc10 <xTaskResumeAll+0xe8>
     c08:	80 91 72 02 	lds	r24, 0x0272
     c0c:	81 30       	cpi	r24, 0x01	; 1
     c0e:	31 f4       	brne	.+12     	; 0xc1c <xTaskResumeAll+0xf4>
				{
					xAlreadyYielded = pdTRUE;
     c10:	81 e0       	ldi	r24, 0x01	; 1
     c12:	89 83       	std	Y+1, r24	; 0x01
					xMissedYield = pdFALSE;
     c14:	10 92 72 02 	sts	0x0272, r1
					portYIELD_WITHIN_API();
     c18:	0e 94 12 18 	call	0x3024	; 0x3024 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
     c1c:	0f 90       	pop	r0
     c1e:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
     c20:	89 81       	ldd	r24, Y+1	; 0x01
}
     c22:	0f 90       	pop	r0
     c24:	0f 90       	pop	r0
     c26:	df 91       	pop	r29
     c28:	cf 91       	pop	r28
     c2a:	1f 91       	pop	r17
     c2c:	0f 91       	pop	r16
     c2e:	08 95       	ret

00000c30 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
     c30:	cf 93       	push	r28
     c32:	df 93       	push	r29
     c34:	1f 92       	push	r1
     c36:	1f 92       	push	r1
     c38:	cd b7       	in	r28, 0x3d	; 61
     c3a:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
     c3c:	0f b6       	in	r0, 0x3f	; 63
     c3e:	f8 94       	cli
     c40:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     c42:	80 91 6b 02 	lds	r24, 0x026B
     c46:	90 91 6c 02 	lds	r25, 0x026C
     c4a:	9a 83       	std	Y+2, r25	; 0x02
     c4c:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
     c4e:	0f 90       	pop	r0
     c50:	0f be       	out	0x3f, r0	; 63

	return xTicks;
     c52:	89 81       	ldd	r24, Y+1	; 0x01
     c54:	9a 81       	ldd	r25, Y+2	; 0x02
}
     c56:	0f 90       	pop	r0
     c58:	0f 90       	pop	r0
     c5a:	df 91       	pop	r29
     c5c:	cf 91       	pop	r28
     c5e:	08 95       	ret

00000c60 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
     c60:	cf 93       	push	r28
     c62:	df 93       	push	r29
     c64:	00 d0       	rcall	.+0      	; 0xc66 <xTaskGetTickCountFromISR+0x6>
     c66:	cd b7       	in	r28, 0x3d	; 61
     c68:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     c6a:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
     c6c:	80 91 6b 02 	lds	r24, 0x026B
     c70:	90 91 6c 02 	lds	r25, 0x026C
     c74:	9b 83       	std	Y+3, r25	; 0x03
     c76:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
     c78:	8a 81       	ldd	r24, Y+2	; 0x02
     c7a:	9b 81       	ldd	r25, Y+3	; 0x03
}
     c7c:	0f 90       	pop	r0
     c7e:	0f 90       	pop	r0
     c80:	0f 90       	pop	r0
     c82:	df 91       	pop	r29
     c84:	cf 91       	pop	r28
     c86:	08 95       	ret

00000c88 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
     c88:	cf 93       	push	r28
     c8a:	df 93       	push	r29
     c8c:	cd b7       	in	r28, 0x3d	; 61
     c8e:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
     c90:	80 91 6a 02 	lds	r24, 0x026A
}
     c94:	df 91       	pop	r29
     c96:	cf 91       	pop	r28
     c98:	08 95       	ret

00000c9a <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
     c9a:	cf 93       	push	r28
     c9c:	df 93       	push	r29
     c9e:	00 d0       	rcall	.+0      	; 0xca0 <vTaskIncrementTick+0x6>
     ca0:	00 d0       	rcall	.+0      	; 0xca2 <vTaskIncrementTick+0x8>
     ca2:	cd b7       	in	r28, 0x3d	; 61
     ca4:	de b7       	in	r29, 0x3e	; 62

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     ca6:	80 91 70 02 	lds	r24, 0x0270
     caa:	88 23       	and	r24, r24
     cac:	09 f0       	breq	.+2      	; 0xcb0 <vTaskIncrementTick+0x16>
     cae:	c4 c0       	rjmp	.+392    	; 0xe38 <vTaskIncrementTick+0x19e>
	{
		++xTickCount;
     cb0:	80 91 6b 02 	lds	r24, 0x026B
     cb4:	90 91 6c 02 	lds	r25, 0x026C
     cb8:	01 96       	adiw	r24, 0x01	; 1
     cba:	90 93 6c 02 	sts	0x026C, r25
     cbe:	80 93 6b 02 	sts	0x026B, r24
		if( xTickCount == ( portTickType ) 0U )
     cc2:	80 91 6b 02 	lds	r24, 0x026B
     cc6:	90 91 6c 02 	lds	r25, 0x026C
     cca:	00 97       	sbiw	r24, 0x00	; 0
     ccc:	e9 f5       	brne	.+122    	; 0xd48 <vTaskIncrementTick+0xae>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
     cce:	80 91 54 02 	lds	r24, 0x0254
     cd2:	90 91 55 02 	lds	r25, 0x0255
     cd6:	9a 83       	std	Y+2, r25	; 0x02
     cd8:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedTaskList = pxOverflowDelayedTaskList;
     cda:	80 91 56 02 	lds	r24, 0x0256
     cde:	90 91 57 02 	lds	r25, 0x0257
     ce2:	90 93 55 02 	sts	0x0255, r25
     ce6:	80 93 54 02 	sts	0x0254, r24
			pxOverflowDelayedTaskList = pxTemp;
     cea:	89 81       	ldd	r24, Y+1	; 0x01
     cec:	9a 81       	ldd	r25, Y+2	; 0x02
     cee:	90 93 57 02 	sts	0x0257, r25
     cf2:	80 93 56 02 	sts	0x0256, r24
			xNumOfOverflows++;
     cf6:	80 91 73 02 	lds	r24, 0x0273
     cfa:	8f 5f       	subi	r24, 0xFF	; 255
     cfc:	80 93 73 02 	sts	0x0273, r24

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     d00:	80 91 54 02 	lds	r24, 0x0254
     d04:	90 91 55 02 	lds	r25, 0x0255
     d08:	fc 01       	movw	r30, r24
     d0a:	80 81       	ld	r24, Z
     d0c:	88 23       	and	r24, r24
     d0e:	39 f4       	brne	.+14     	; 0xd1e <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
     d10:	8f ef       	ldi	r24, 0xFF	; 255
     d12:	9f ef       	ldi	r25, 0xFF	; 255
     d14:	90 93 01 02 	sts	0x0201, r25
     d18:	80 93 00 02 	sts	0x0200, r24
     d1c:	15 c0       	rjmp	.+42     	; 0xd48 <vTaskIncrementTick+0xae>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     d1e:	80 91 54 02 	lds	r24, 0x0254
     d22:	90 91 55 02 	lds	r25, 0x0255
     d26:	fc 01       	movw	r30, r24
     d28:	85 81       	ldd	r24, Z+5	; 0x05
     d2a:	96 81       	ldd	r25, Z+6	; 0x06
     d2c:	fc 01       	movw	r30, r24
     d2e:	86 81       	ldd	r24, Z+6	; 0x06
     d30:	97 81       	ldd	r25, Z+7	; 0x07
     d32:	9c 83       	std	Y+4, r25	; 0x04
     d34:	8b 83       	std	Y+3, r24	; 0x03
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
     d36:	8b 81       	ldd	r24, Y+3	; 0x03
     d38:	9c 81       	ldd	r25, Y+4	; 0x04
     d3a:	fc 01       	movw	r30, r24
     d3c:	82 81       	ldd	r24, Z+2	; 0x02
     d3e:	93 81       	ldd	r25, Z+3	; 0x03
     d40:	90 93 01 02 	sts	0x0201, r25
     d44:	80 93 00 02 	sts	0x0200, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
     d48:	20 91 6b 02 	lds	r18, 0x026B
     d4c:	30 91 6c 02 	lds	r19, 0x026C
     d50:	80 91 00 02 	lds	r24, 0x0200
     d54:	90 91 01 02 	lds	r25, 0x0201
     d58:	28 17       	cp	r18, r24
     d5a:	39 07       	cpc	r19, r25
     d5c:	08 f4       	brcc	.+2      	; 0xd60 <vTaskIncrementTick+0xc6>
     d5e:	6b c0       	rjmp	.+214    	; 0xe36 <vTaskIncrementTick+0x19c>
     d60:	80 91 54 02 	lds	r24, 0x0254
     d64:	90 91 55 02 	lds	r25, 0x0255
     d68:	fc 01       	movw	r30, r24
     d6a:	80 81       	ld	r24, Z
     d6c:	88 23       	and	r24, r24
     d6e:	39 f4       	brne	.+14     	; 0xd7e <vTaskIncrementTick+0xe4>
     d70:	8f ef       	ldi	r24, 0xFF	; 255
     d72:	9f ef       	ldi	r25, 0xFF	; 255
     d74:	90 93 01 02 	sts	0x0201, r25
     d78:	80 93 00 02 	sts	0x0200, r24
     d7c:	5c c0       	rjmp	.+184    	; 0xe36 <vTaskIncrementTick+0x19c>
     d7e:	80 91 54 02 	lds	r24, 0x0254
     d82:	90 91 55 02 	lds	r25, 0x0255
     d86:	fc 01       	movw	r30, r24
     d88:	85 81       	ldd	r24, Z+5	; 0x05
     d8a:	96 81       	ldd	r25, Z+6	; 0x06
     d8c:	fc 01       	movw	r30, r24
     d8e:	86 81       	ldd	r24, Z+6	; 0x06
     d90:	97 81       	ldd	r25, Z+7	; 0x07
     d92:	9c 83       	std	Y+4, r25	; 0x04
     d94:	8b 83       	std	Y+3, r24	; 0x03
     d96:	8b 81       	ldd	r24, Y+3	; 0x03
     d98:	9c 81       	ldd	r25, Y+4	; 0x04
     d9a:	fc 01       	movw	r30, r24
     d9c:	82 81       	ldd	r24, Z+2	; 0x02
     d9e:	93 81       	ldd	r25, Z+3	; 0x03
     da0:	9e 83       	std	Y+6, r25	; 0x06
     da2:	8d 83       	std	Y+5, r24	; 0x05
     da4:	20 91 6b 02 	lds	r18, 0x026B
     da8:	30 91 6c 02 	lds	r19, 0x026C
     dac:	8d 81       	ldd	r24, Y+5	; 0x05
     dae:	9e 81       	ldd	r25, Y+6	; 0x06
     db0:	28 17       	cp	r18, r24
     db2:	39 07       	cpc	r19, r25
     db4:	38 f4       	brcc	.+14     	; 0xdc4 <vTaskIncrementTick+0x12a>
     db6:	8d 81       	ldd	r24, Y+5	; 0x05
     db8:	9e 81       	ldd	r25, Y+6	; 0x06
     dba:	90 93 01 02 	sts	0x0201, r25
     dbe:	80 93 00 02 	sts	0x0200, r24
     dc2:	39 c0       	rjmp	.+114    	; 0xe36 <vTaskIncrementTick+0x19c>
     dc4:	8b 81       	ldd	r24, Y+3	; 0x03
     dc6:	9c 81       	ldd	r25, Y+4	; 0x04
     dc8:	02 96       	adiw	r24, 0x02	; 2
     dca:	0e 94 50 12 	call	0x24a0	; 0x24a0 <uxListRemove>
     dce:	8b 81       	ldd	r24, Y+3	; 0x03
     dd0:	9c 81       	ldd	r25, Y+4	; 0x04
     dd2:	fc 01       	movw	r30, r24
     dd4:	84 89       	ldd	r24, Z+20	; 0x14
     dd6:	95 89       	ldd	r25, Z+21	; 0x15
     dd8:	00 97       	sbiw	r24, 0x00	; 0
     dda:	29 f0       	breq	.+10     	; 0xde6 <vTaskIncrementTick+0x14c>
     ddc:	8b 81       	ldd	r24, Y+3	; 0x03
     dde:	9c 81       	ldd	r25, Y+4	; 0x04
     de0:	0c 96       	adiw	r24, 0x0c	; 12
     de2:	0e 94 50 12 	call	0x24a0	; 0x24a0 <uxListRemove>
     de6:	8b 81       	ldd	r24, Y+3	; 0x03
     de8:	9c 81       	ldd	r25, Y+4	; 0x04
     dea:	fc 01       	movw	r30, r24
     dec:	96 89       	ldd	r25, Z+22	; 0x16
     dee:	80 91 6e 02 	lds	r24, 0x026E
     df2:	89 17       	cp	r24, r25
     df4:	30 f4       	brcc	.+12     	; 0xe02 <vTaskIncrementTick+0x168>
     df6:	8b 81       	ldd	r24, Y+3	; 0x03
     df8:	9c 81       	ldd	r25, Y+4	; 0x04
     dfa:	fc 01       	movw	r30, r24
     dfc:	86 89       	ldd	r24, Z+22	; 0x16
     dfe:	80 93 6e 02 	sts	0x026E, r24
     e02:	8b 81       	ldd	r24, Y+3	; 0x03
     e04:	9c 81       	ldd	r25, Y+4	; 0x04
     e06:	ac 01       	movw	r20, r24
     e08:	4e 5f       	subi	r20, 0xFE	; 254
     e0a:	5f 4f       	sbci	r21, 0xFF	; 255
     e0c:	8b 81       	ldd	r24, Y+3	; 0x03
     e0e:	9c 81       	ldd	r25, Y+4	; 0x04
     e10:	fc 01       	movw	r30, r24
     e12:	86 89       	ldd	r24, Z+22	; 0x16
     e14:	28 2f       	mov	r18, r24
     e16:	30 e0       	ldi	r19, 0x00	; 0
     e18:	c9 01       	movw	r24, r18
     e1a:	88 0f       	add	r24, r24
     e1c:	99 1f       	adc	r25, r25
     e1e:	88 0f       	add	r24, r24
     e20:	99 1f       	adc	r25, r25
     e22:	88 0f       	add	r24, r24
     e24:	99 1f       	adc	r25, r25
     e26:	82 0f       	add	r24, r18
     e28:	93 1f       	adc	r25, r19
     e2a:	82 5e       	subi	r24, 0xE2	; 226
     e2c:	9d 4f       	sbci	r25, 0xFD	; 253
     e2e:	ba 01       	movw	r22, r20
     e30:	0e 94 80 11 	call	0x2300	; 0x2300 <vListInsertEnd>
     e34:	95 cf       	rjmp	.-214    	; 0xd60 <vTaskIncrementTick+0xc6>
     e36:	07 c0       	rjmp	.+14     	; 0xe46 <vTaskIncrementTick+0x1ac>
	}
	else
	{
		++uxMissedTicks;
     e38:	80 91 71 02 	lds	r24, 0x0271
     e3c:	8f 5f       	subi	r24, 0xFF	; 255
     e3e:	80 93 71 02 	sts	0x0271, r24

		/* The tick hook gets called at regular intervals, even if the
		scheduler is locked. */
		#if ( configUSE_TICK_HOOK == 1 )
		{
			vApplicationTickHook();
     e42:	0e 94 9f 00 	call	0x13e	; 0x13e <vApplicationTickHook>

	#if ( configUSE_TICK_HOOK == 1 )
	{
		/* Guard against the tick hook being called when the missed tick
		count is being unwound (when the scheduler is being unlocked. */
		if( uxMissedTicks == ( unsigned portBASE_TYPE ) 0U )
     e46:	80 91 71 02 	lds	r24, 0x0271
     e4a:	88 23       	and	r24, r24
     e4c:	11 f4       	brne	.+4      	; 0xe52 <vTaskIncrementTick+0x1b8>
		{
			vApplicationTickHook();
     e4e:	0e 94 9f 00 	call	0x13e	; 0x13e <vApplicationTickHook>
		}
	}
	#endif
}
     e52:	26 96       	adiw	r28, 0x06	; 6
     e54:	0f b6       	in	r0, 0x3f	; 63
     e56:	f8 94       	cli
     e58:	de bf       	out	0x3e, r29	; 62
     e5a:	0f be       	out	0x3f, r0	; 63
     e5c:	cd bf       	out	0x3d, r28	; 61
     e5e:	df 91       	pop	r29
     e60:	cf 91       	pop	r28
     e62:	08 95       	ret

00000e64 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
     e64:	cf 93       	push	r28
     e66:	df 93       	push	r29
     e68:	1f 92       	push	r1
     e6a:	1f 92       	push	r1
     e6c:	cd b7       	in	r28, 0x3d	; 61
     e6e:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
     e70:	80 91 70 02 	lds	r24, 0x0270
     e74:	88 23       	and	r24, r24
     e76:	21 f0       	breq	.+8      	; 0xe80 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
     e78:	81 e0       	ldi	r24, 0x01	; 1
     e7a:	80 93 72 02 	sts	0x0272, r24
     e7e:	5b c0       	rjmp	.+182    	; 0xf36 <vTaskSwitchContext+0xd2>

//BB Commented out...
//		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
     e80:	05 c0       	rjmp	.+10     	; 0xe8c <vTaskSwitchContext+0x28>
     e82:	80 91 6e 02 	lds	r24, 0x026E
     e86:	81 50       	subi	r24, 0x01	; 1
     e88:	80 93 6e 02 	sts	0x026E, r24
     e8c:	80 91 6e 02 	lds	r24, 0x026E
     e90:	28 2f       	mov	r18, r24
     e92:	30 e0       	ldi	r19, 0x00	; 0
     e94:	c9 01       	movw	r24, r18
     e96:	88 0f       	add	r24, r24
     e98:	99 1f       	adc	r25, r25
     e9a:	88 0f       	add	r24, r24
     e9c:	99 1f       	adc	r25, r25
     e9e:	88 0f       	add	r24, r24
     ea0:	99 1f       	adc	r25, r25
     ea2:	82 0f       	add	r24, r18
     ea4:	93 1f       	adc	r25, r19
     ea6:	82 5e       	subi	r24, 0xE2	; 226
     ea8:	9d 4f       	sbci	r25, 0xFD	; 253
     eaa:	fc 01       	movw	r30, r24
     eac:	80 81       	ld	r24, Z
     eae:	88 23       	and	r24, r24
     eb0:	41 f3       	breq	.-48     	; 0xe82 <vTaskSwitchContext+0x1e>
     eb2:	80 91 6e 02 	lds	r24, 0x026E
     eb6:	28 2f       	mov	r18, r24
     eb8:	30 e0       	ldi	r19, 0x00	; 0
     eba:	c9 01       	movw	r24, r18
     ebc:	88 0f       	add	r24, r24
     ebe:	99 1f       	adc	r25, r25
     ec0:	88 0f       	add	r24, r24
     ec2:	99 1f       	adc	r25, r25
     ec4:	88 0f       	add	r24, r24
     ec6:	99 1f       	adc	r25, r25
     ec8:	82 0f       	add	r24, r18
     eca:	93 1f       	adc	r25, r19
     ecc:	82 5e       	subi	r24, 0xE2	; 226
     ece:	9d 4f       	sbci	r25, 0xFD	; 253
     ed0:	9a 83       	std	Y+2, r25	; 0x02
     ed2:	89 83       	std	Y+1, r24	; 0x01
     ed4:	89 81       	ldd	r24, Y+1	; 0x01
     ed6:	9a 81       	ldd	r25, Y+2	; 0x02
     ed8:	fc 01       	movw	r30, r24
     eda:	81 81       	ldd	r24, Z+1	; 0x01
     edc:	92 81       	ldd	r25, Z+2	; 0x02
     ede:	fc 01       	movw	r30, r24
     ee0:	22 81       	ldd	r18, Z+2	; 0x02
     ee2:	33 81       	ldd	r19, Z+3	; 0x03
     ee4:	89 81       	ldd	r24, Y+1	; 0x01
     ee6:	9a 81       	ldd	r25, Y+2	; 0x02
     ee8:	fc 01       	movw	r30, r24
     eea:	32 83       	std	Z+2, r19	; 0x02
     eec:	21 83       	std	Z+1, r18	; 0x01
     eee:	89 81       	ldd	r24, Y+1	; 0x01
     ef0:	9a 81       	ldd	r25, Y+2	; 0x02
     ef2:	fc 01       	movw	r30, r24
     ef4:	21 81       	ldd	r18, Z+1	; 0x01
     ef6:	32 81       	ldd	r19, Z+2	; 0x02
     ef8:	89 81       	ldd	r24, Y+1	; 0x01
     efa:	9a 81       	ldd	r25, Y+2	; 0x02
     efc:	03 96       	adiw	r24, 0x03	; 3
     efe:	28 17       	cp	r18, r24
     f00:	39 07       	cpc	r19, r25
     f02:	69 f4       	brne	.+26     	; 0xf1e <vTaskSwitchContext+0xba>
     f04:	89 81       	ldd	r24, Y+1	; 0x01
     f06:	9a 81       	ldd	r25, Y+2	; 0x02
     f08:	fc 01       	movw	r30, r24
     f0a:	81 81       	ldd	r24, Z+1	; 0x01
     f0c:	92 81       	ldd	r25, Z+2	; 0x02
     f0e:	fc 01       	movw	r30, r24
     f10:	22 81       	ldd	r18, Z+2	; 0x02
     f12:	33 81       	ldd	r19, Z+3	; 0x03
     f14:	89 81       	ldd	r24, Y+1	; 0x01
     f16:	9a 81       	ldd	r25, Y+2	; 0x02
     f18:	fc 01       	movw	r30, r24
     f1a:	32 83       	std	Z+2, r19	; 0x02
     f1c:	21 83       	std	Z+1, r18	; 0x01
     f1e:	89 81       	ldd	r24, Y+1	; 0x01
     f20:	9a 81       	ldd	r25, Y+2	; 0x02
     f22:	fc 01       	movw	r30, r24
     f24:	81 81       	ldd	r24, Z+1	; 0x01
     f26:	92 81       	ldd	r25, Z+2	; 0x02
     f28:	fc 01       	movw	r30, r24
     f2a:	86 81       	ldd	r24, Z+6	; 0x06
     f2c:	97 81       	ldd	r25, Z+7	; 0x07
     f2e:	90 93 1d 02 	sts	0x021D, r25
     f32:	80 93 1c 02 	sts	0x021C, r24

		traceTASK_SWITCHED_IN();
	}
}
     f36:	0f 90       	pop	r0
     f38:	0f 90       	pop	r0
     f3a:	df 91       	pop	r29
     f3c:	cf 91       	pop	r28
     f3e:	08 95       	ret

00000f40 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
     f40:	cf 93       	push	r28
     f42:	df 93       	push	r29
     f44:	00 d0       	rcall	.+0      	; 0xf46 <vTaskPlaceOnEventList+0x6>
     f46:	00 d0       	rcall	.+0      	; 0xf48 <vTaskPlaceOnEventList+0x8>
     f48:	cd b7       	in	r28, 0x3d	; 61
     f4a:	de b7       	in	r29, 0x3e	; 62
     f4c:	9c 83       	std	Y+4, r25	; 0x04
     f4e:	8b 83       	std	Y+3, r24	; 0x03
     f50:	7e 83       	std	Y+6, r23	; 0x06
     f52:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
     f54:	80 91 1c 02 	lds	r24, 0x021C
     f58:	90 91 1d 02 	lds	r25, 0x021D
     f5c:	9c 01       	movw	r18, r24
     f5e:	24 5f       	subi	r18, 0xF4	; 244
     f60:	3f 4f       	sbci	r19, 0xFF	; 255
     f62:	8b 81       	ldd	r24, Y+3	; 0x03
     f64:	9c 81       	ldd	r25, Y+4	; 0x04
     f66:	b9 01       	movw	r22, r18
     f68:	0e 94 d7 11 	call	0x23ae	; 0x23ae <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
     f6c:	80 91 1c 02 	lds	r24, 0x021C
     f70:	90 91 1d 02 	lds	r25, 0x021D
     f74:	02 96       	adiw	r24, 0x02	; 2
     f76:	0e 94 50 12 	call	0x24a0	; 0x24a0 <uxListRemove>
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
     f7a:	8d 81       	ldd	r24, Y+5	; 0x05
     f7c:	9e 81       	ldd	r25, Y+6	; 0x06
     f7e:	8f 3f       	cpi	r24, 0xFF	; 255
     f80:	2f ef       	ldi	r18, 0xFF	; 255
     f82:	92 07       	cpc	r25, r18
     f84:	59 f4       	brne	.+22     	; 0xf9c <vTaskPlaceOnEventList+0x5c>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
     f86:	80 91 1c 02 	lds	r24, 0x021C
     f8a:	90 91 1d 02 	lds	r25, 0x021D
     f8e:	02 96       	adiw	r24, 0x02	; 2
     f90:	bc 01       	movw	r22, r24
     f92:	81 e6       	ldi	r24, 0x61	; 97
     f94:	92 e0       	ldi	r25, 0x02	; 2
     f96:	0e 94 80 11 	call	0x2300	; 0x2300 <vListInsertEnd>
     f9a:	0e c0       	rjmp	.+28     	; 0xfb8 <vTaskPlaceOnEventList+0x78>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
     f9c:	20 91 6b 02 	lds	r18, 0x026B
     fa0:	30 91 6c 02 	lds	r19, 0x026C
     fa4:	8d 81       	ldd	r24, Y+5	; 0x05
     fa6:	9e 81       	ldd	r25, Y+6	; 0x06
     fa8:	82 0f       	add	r24, r18
     faa:	93 1f       	adc	r25, r19
     fac:	9a 83       	std	Y+2, r25	; 0x02
     fae:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
     fb0:	89 81       	ldd	r24, Y+1	; 0x01
     fb2:	9a 81       	ldd	r25, Y+2	; 0x02
     fb4:	0e 94 9b 09 	call	0x1336	; 0x1336 <prvAddCurrentTaskToDelayedList>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
     fb8:	26 96       	adiw	r28, 0x06	; 6
     fba:	0f b6       	in	r0, 0x3f	; 63
     fbc:	f8 94       	cli
     fbe:	de bf       	out	0x3e, r29	; 62
     fc0:	0f be       	out	0x3f, r0	; 63
     fc2:	cd bf       	out	0x3d, r28	; 61
     fc4:	df 91       	pop	r29
     fc6:	cf 91       	pop	r28
     fc8:	08 95       	ret

00000fca <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
     fca:	cf 93       	push	r28
     fcc:	df 93       	push	r29
     fce:	00 d0       	rcall	.+0      	; 0xfd0 <xTaskRemoveFromEventList+0x6>
     fd0:	1f 92       	push	r1
     fd2:	1f 92       	push	r1
     fd4:	cd b7       	in	r28, 0x3d	; 61
     fd6:	de b7       	in	r29, 0x3e	; 62
     fd8:	9d 83       	std	Y+5, r25	; 0x05
     fda:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     fdc:	8c 81       	ldd	r24, Y+4	; 0x04
     fde:	9d 81       	ldd	r25, Y+5	; 0x05
     fe0:	fc 01       	movw	r30, r24
     fe2:	85 81       	ldd	r24, Z+5	; 0x05
     fe4:	96 81       	ldd	r25, Z+6	; 0x06
     fe6:	fc 01       	movw	r30, r24
     fe8:	86 81       	ldd	r24, Z+6	; 0x06
     fea:	97 81       	ldd	r25, Z+7	; 0x07
     fec:	9b 83       	std	Y+3, r25	; 0x03
     fee:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
     ff0:	8a 81       	ldd	r24, Y+2	; 0x02
     ff2:	9b 81       	ldd	r25, Y+3	; 0x03
     ff4:	0c 96       	adiw	r24, 0x0c	; 12
     ff6:	0e 94 50 12 	call	0x24a0	; 0x24a0 <uxListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     ffa:	80 91 70 02 	lds	r24, 0x0270
     ffe:	88 23       	and	r24, r24
    1000:	69 f5       	brne	.+90     	; 0x105c <xTaskRemoveFromEventList+0x92>
	{
		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    1002:	8a 81       	ldd	r24, Y+2	; 0x02
    1004:	9b 81       	ldd	r25, Y+3	; 0x03
    1006:	02 96       	adiw	r24, 0x02	; 2
    1008:	0e 94 50 12 	call	0x24a0	; 0x24a0 <uxListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    100c:	8a 81       	ldd	r24, Y+2	; 0x02
    100e:	9b 81       	ldd	r25, Y+3	; 0x03
    1010:	fc 01       	movw	r30, r24
    1012:	96 89       	ldd	r25, Z+22	; 0x16
    1014:	80 91 6e 02 	lds	r24, 0x026E
    1018:	89 17       	cp	r24, r25
    101a:	30 f4       	brcc	.+12     	; 0x1028 <xTaskRemoveFromEventList+0x5e>
    101c:	8a 81       	ldd	r24, Y+2	; 0x02
    101e:	9b 81       	ldd	r25, Y+3	; 0x03
    1020:	fc 01       	movw	r30, r24
    1022:	86 89       	ldd	r24, Z+22	; 0x16
    1024:	80 93 6e 02 	sts	0x026E, r24
    1028:	8a 81       	ldd	r24, Y+2	; 0x02
    102a:	9b 81       	ldd	r25, Y+3	; 0x03
    102c:	ac 01       	movw	r20, r24
    102e:	4e 5f       	subi	r20, 0xFE	; 254
    1030:	5f 4f       	sbci	r21, 0xFF	; 255
    1032:	8a 81       	ldd	r24, Y+2	; 0x02
    1034:	9b 81       	ldd	r25, Y+3	; 0x03
    1036:	fc 01       	movw	r30, r24
    1038:	86 89       	ldd	r24, Z+22	; 0x16
    103a:	28 2f       	mov	r18, r24
    103c:	30 e0       	ldi	r19, 0x00	; 0
    103e:	c9 01       	movw	r24, r18
    1040:	88 0f       	add	r24, r24
    1042:	99 1f       	adc	r25, r25
    1044:	88 0f       	add	r24, r24
    1046:	99 1f       	adc	r25, r25
    1048:	88 0f       	add	r24, r24
    104a:	99 1f       	adc	r25, r25
    104c:	82 0f       	add	r24, r18
    104e:	93 1f       	adc	r25, r19
    1050:	82 5e       	subi	r24, 0xE2	; 226
    1052:	9d 4f       	sbci	r25, 0xFD	; 253
    1054:	ba 01       	movw	r22, r20
    1056:	0e 94 80 11 	call	0x2300	; 0x2300 <vListInsertEnd>
    105a:	08 c0       	rjmp	.+16     	; 0x106c <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    105c:	8a 81       	ldd	r24, Y+2	; 0x02
    105e:	9b 81       	ldd	r25, Y+3	; 0x03
    1060:	0c 96       	adiw	r24, 0x0c	; 12
    1062:	bc 01       	movw	r22, r24
    1064:	88 e5       	ldi	r24, 0x58	; 88
    1066:	92 e0       	ldi	r25, 0x02	; 2
    1068:	0e 94 80 11 	call	0x2300	; 0x2300 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    106c:	8a 81       	ldd	r24, Y+2	; 0x02
    106e:	9b 81       	ldd	r25, Y+3	; 0x03
    1070:	fc 01       	movw	r30, r24
    1072:	26 89       	ldd	r18, Z+22	; 0x16
    1074:	80 91 1c 02 	lds	r24, 0x021C
    1078:	90 91 1d 02 	lds	r25, 0x021D
    107c:	fc 01       	movw	r30, r24
    107e:	86 89       	ldd	r24, Z+22	; 0x16
    1080:	28 17       	cp	r18, r24
    1082:	18 f0       	brcs	.+6      	; 0x108a <xTaskRemoveFromEventList+0xc0>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    1084:	81 e0       	ldi	r24, 0x01	; 1
    1086:	89 83       	std	Y+1, r24	; 0x01
    1088:	01 c0       	rjmp	.+2      	; 0x108c <xTaskRemoveFromEventList+0xc2>
	}
	else
	{
		xReturn = pdFALSE;
    108a:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    108c:	89 81       	ldd	r24, Y+1	; 0x01
}
    108e:	0f 90       	pop	r0
    1090:	0f 90       	pop	r0
    1092:	0f 90       	pop	r0
    1094:	0f 90       	pop	r0
    1096:	0f 90       	pop	r0
    1098:	df 91       	pop	r29
    109a:	cf 91       	pop	r28
    109c:	08 95       	ret

0000109e <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    109e:	cf 93       	push	r28
    10a0:	df 93       	push	r29
    10a2:	1f 92       	push	r1
    10a4:	1f 92       	push	r1
    10a6:	cd b7       	in	r28, 0x3d	; 61
    10a8:	de b7       	in	r29, 0x3e	; 62
    10aa:	9a 83       	std	Y+2, r25	; 0x02
    10ac:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    10ae:	20 91 73 02 	lds	r18, 0x0273
    10b2:	89 81       	ldd	r24, Y+1	; 0x01
    10b4:	9a 81       	ldd	r25, Y+2	; 0x02
    10b6:	fc 01       	movw	r30, r24
    10b8:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    10ba:	20 91 6b 02 	lds	r18, 0x026B
    10be:	30 91 6c 02 	lds	r19, 0x026C
    10c2:	89 81       	ldd	r24, Y+1	; 0x01
    10c4:	9a 81       	ldd	r25, Y+2	; 0x02
    10c6:	fc 01       	movw	r30, r24
    10c8:	32 83       	std	Z+2, r19	; 0x02
    10ca:	21 83       	std	Z+1, r18	; 0x01
}
    10cc:	0f 90       	pop	r0
    10ce:	0f 90       	pop	r0
    10d0:	df 91       	pop	r29
    10d2:	cf 91       	pop	r28
    10d4:	08 95       	ret

000010d6 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    10d6:	cf 93       	push	r28
    10d8:	df 93       	push	r29
    10da:	00 d0       	rcall	.+0      	; 0x10dc <xTaskCheckForTimeOut+0x6>
    10dc:	1f 92       	push	r1
    10de:	1f 92       	push	r1
    10e0:	cd b7       	in	r28, 0x3d	; 61
    10e2:	de b7       	in	r29, 0x3e	; 62
    10e4:	9b 83       	std	Y+3, r25	; 0x03
    10e6:	8a 83       	std	Y+2, r24	; 0x02
    10e8:	7d 83       	std	Y+5, r23	; 0x05
    10ea:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    10ec:	0f b6       	in	r0, 0x3f	; 63
    10ee:	f8 94       	cli
    10f0:	0f 92       	push	r0
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    10f2:	8c 81       	ldd	r24, Y+4	; 0x04
    10f4:	9d 81       	ldd	r25, Y+5	; 0x05
    10f6:	fc 01       	movw	r30, r24
    10f8:	80 81       	ld	r24, Z
    10fa:	91 81       	ldd	r25, Z+1	; 0x01
    10fc:	8f 3f       	cpi	r24, 0xFF	; 255
    10fe:	ff ef       	ldi	r31, 0xFF	; 255
    1100:	9f 07       	cpc	r25, r31
    1102:	11 f4       	brne	.+4      	; 0x1108 <xTaskCheckForTimeOut+0x32>
			{
				xReturn = pdFALSE;
    1104:	19 82       	std	Y+1, r1	; 0x01
    1106:	4b c0       	rjmp	.+150    	; 0x119e <xTaskCheckForTimeOut+0xc8>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    1108:	8a 81       	ldd	r24, Y+2	; 0x02
    110a:	9b 81       	ldd	r25, Y+3	; 0x03
    110c:	fc 01       	movw	r30, r24
    110e:	90 81       	ld	r25, Z
    1110:	80 91 73 02 	lds	r24, 0x0273
    1114:	98 17       	cp	r25, r24
    1116:	79 f0       	breq	.+30     	; 0x1136 <xTaskCheckForTimeOut+0x60>
    1118:	8a 81       	ldd	r24, Y+2	; 0x02
    111a:	9b 81       	ldd	r25, Y+3	; 0x03
    111c:	fc 01       	movw	r30, r24
    111e:	21 81       	ldd	r18, Z+1	; 0x01
    1120:	32 81       	ldd	r19, Z+2	; 0x02
    1122:	80 91 6b 02 	lds	r24, 0x026B
    1126:	90 91 6c 02 	lds	r25, 0x026C
    112a:	82 17       	cp	r24, r18
    112c:	93 07       	cpc	r25, r19
    112e:	18 f0       	brcs	.+6      	; 0x1136 <xTaskCheckForTimeOut+0x60>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    1130:	81 e0       	ldi	r24, 0x01	; 1
    1132:	89 83       	std	Y+1, r24	; 0x01
    1134:	34 c0       	rjmp	.+104    	; 0x119e <xTaskCheckForTimeOut+0xc8>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    1136:	20 91 6b 02 	lds	r18, 0x026B
    113a:	30 91 6c 02 	lds	r19, 0x026C
    113e:	8a 81       	ldd	r24, Y+2	; 0x02
    1140:	9b 81       	ldd	r25, Y+3	; 0x03
    1142:	fc 01       	movw	r30, r24
    1144:	81 81       	ldd	r24, Z+1	; 0x01
    1146:	92 81       	ldd	r25, Z+2	; 0x02
    1148:	28 1b       	sub	r18, r24
    114a:	39 0b       	sbc	r19, r25
    114c:	8c 81       	ldd	r24, Y+4	; 0x04
    114e:	9d 81       	ldd	r25, Y+5	; 0x05
    1150:	fc 01       	movw	r30, r24
    1152:	80 81       	ld	r24, Z
    1154:	91 81       	ldd	r25, Z+1	; 0x01
    1156:	28 17       	cp	r18, r24
    1158:	39 07       	cpc	r19, r25
    115a:	f8 f4       	brcc	.+62     	; 0x119a <xTaskCheckForTimeOut+0xc4>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    115c:	8c 81       	ldd	r24, Y+4	; 0x04
    115e:	9d 81       	ldd	r25, Y+5	; 0x05
    1160:	fc 01       	movw	r30, r24
    1162:	20 81       	ld	r18, Z
    1164:	31 81       	ldd	r19, Z+1	; 0x01
    1166:	8a 81       	ldd	r24, Y+2	; 0x02
    1168:	9b 81       	ldd	r25, Y+3	; 0x03
    116a:	fc 01       	movw	r30, r24
    116c:	41 81       	ldd	r20, Z+1	; 0x01
    116e:	52 81       	ldd	r21, Z+2	; 0x02
    1170:	80 91 6b 02 	lds	r24, 0x026B
    1174:	90 91 6c 02 	lds	r25, 0x026C
    1178:	ba 01       	movw	r22, r20
    117a:	68 1b       	sub	r22, r24
    117c:	79 0b       	sbc	r23, r25
    117e:	cb 01       	movw	r24, r22
    1180:	28 0f       	add	r18, r24
    1182:	39 1f       	adc	r19, r25
    1184:	8c 81       	ldd	r24, Y+4	; 0x04
    1186:	9d 81       	ldd	r25, Y+5	; 0x05
    1188:	fc 01       	movw	r30, r24
    118a:	31 83       	std	Z+1, r19	; 0x01
    118c:	20 83       	st	Z, r18
			vTaskSetTimeOutState( pxTimeOut );
    118e:	8a 81       	ldd	r24, Y+2	; 0x02
    1190:	9b 81       	ldd	r25, Y+3	; 0x03
    1192:	0e 94 4f 08 	call	0x109e	; 0x109e <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    1196:	19 82       	std	Y+1, r1	; 0x01
    1198:	02 c0       	rjmp	.+4      	; 0x119e <xTaskCheckForTimeOut+0xc8>
		}
		else
		{
			xReturn = pdTRUE;
    119a:	81 e0       	ldi	r24, 0x01	; 1
    119c:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    119e:	0f 90       	pop	r0
    11a0:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    11a2:	89 81       	ldd	r24, Y+1	; 0x01
}
    11a4:	0f 90       	pop	r0
    11a6:	0f 90       	pop	r0
    11a8:	0f 90       	pop	r0
    11aa:	0f 90       	pop	r0
    11ac:	0f 90       	pop	r0
    11ae:	df 91       	pop	r29
    11b0:	cf 91       	pop	r28
    11b2:	08 95       	ret

000011b4 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    11b4:	cf 93       	push	r28
    11b6:	df 93       	push	r29
    11b8:	cd b7       	in	r28, 0x3d	; 61
    11ba:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    11bc:	81 e0       	ldi	r24, 0x01	; 1
    11be:	80 93 72 02 	sts	0x0272, r24
}
    11c2:	df 91       	pop	r29
    11c4:	cf 91       	pop	r28
    11c6:	08 95       	ret

000011c8 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    11c8:	cf 93       	push	r28
    11ca:	df 93       	push	r29
    11cc:	1f 92       	push	r1
    11ce:	1f 92       	push	r1
    11d0:	cd b7       	in	r28, 0x3d	; 61
    11d2:	de b7       	in	r29, 0x3e	; 62
    11d4:	9a 83       	std	Y+2, r25	; 0x02
    11d6:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    11d8:	0e 94 94 09 	call	0x1328	; 0x1328 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    11dc:	80 91 1e 02 	lds	r24, 0x021E
    11e0:	82 30       	cpi	r24, 0x02	; 2
    11e2:	18 f0       	brcs	.+6      	; 0x11ea <prvIdleTask+0x22>
			{
				taskYIELD();
    11e4:	0e 94 12 18 	call	0x3024	; 0x3024 <vPortYield>
				}
				xTaskResumeAll();
			}
		}
		#endif
	}
    11e8:	f7 cf       	rjmp	.-18     	; 0x11d8 <prvIdleTask+0x10>
    11ea:	f6 cf       	rjmp	.-20     	; 0x11d8 <prvIdleTask+0x10>

000011ec <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    11ec:	0f 93       	push	r16
    11ee:	1f 93       	push	r17
    11f0:	cf 93       	push	r28
    11f2:	df 93       	push	r29
    11f4:	cd b7       	in	r28, 0x3d	; 61
    11f6:	de b7       	in	r29, 0x3e	; 62
    11f8:	29 97       	sbiw	r28, 0x09	; 9
    11fa:	0f b6       	in	r0, 0x3f	; 63
    11fc:	f8 94       	cli
    11fe:	de bf       	out	0x3e, r29	; 62
    1200:	0f be       	out	0x3f, r0	; 63
    1202:	cd bf       	out	0x3d, r28	; 61
    1204:	9a 83       	std	Y+2, r25	; 0x02
    1206:	89 83       	std	Y+1, r24	; 0x01
    1208:	7c 83       	std	Y+4, r23	; 0x04
    120a:	6b 83       	std	Y+3, r22	; 0x03
    120c:	4d 83       	std	Y+5, r20	; 0x05
    120e:	3f 83       	std	Y+7, r19	; 0x07
    1210:	2e 83       	std	Y+6, r18	; 0x06
    1212:	19 87       	std	Y+9, r17	; 0x09
    1214:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    1216:	89 81       	ldd	r24, Y+1	; 0x01
    1218:	9a 81       	ldd	r25, Y+2	; 0x02
    121a:	49 96       	adiw	r24, 0x19	; 25
    121c:	2b 81       	ldd	r18, Y+3	; 0x03
    121e:	3c 81       	ldd	r19, Y+4	; 0x04
    1220:	40 e1       	ldi	r20, 0x10	; 16
    1222:	50 e0       	ldi	r21, 0x00	; 0
    1224:	b9 01       	movw	r22, r18
    1226:	0e 94 87 1c 	call	0x390e	; 0x390e <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    122a:	89 81       	ldd	r24, Y+1	; 0x01
    122c:	9a 81       	ldd	r25, Y+2	; 0x02
    122e:	fc 01       	movw	r30, r24
    1230:	10 a6       	std	Z+40, r1	; 0x28

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    1232:	8d 81       	ldd	r24, Y+5	; 0x05
    1234:	84 30       	cpi	r24, 0x04	; 4
    1236:	10 f0       	brcs	.+4      	; 0x123c <prvInitialiseTCBVariables+0x50>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    1238:	83 e0       	ldi	r24, 0x03	; 3
    123a:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    123c:	89 81       	ldd	r24, Y+1	; 0x01
    123e:	9a 81       	ldd	r25, Y+2	; 0x02
    1240:	2d 81       	ldd	r18, Y+5	; 0x05
    1242:	fc 01       	movw	r30, r24
    1244:	26 8b       	std	Z+22, r18	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    1246:	89 81       	ldd	r24, Y+1	; 0x01
    1248:	9a 81       	ldd	r25, Y+2	; 0x02
    124a:	2d 81       	ldd	r18, Y+5	; 0x05
    124c:	fc 01       	movw	r30, r24
    124e:	21 a7       	std	Z+41, r18	; 0x29
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    1250:	89 81       	ldd	r24, Y+1	; 0x01
    1252:	9a 81       	ldd	r25, Y+2	; 0x02
    1254:	02 96       	adiw	r24, 0x02	; 2
    1256:	0e 94 6e 11 	call	0x22dc	; 0x22dc <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    125a:	89 81       	ldd	r24, Y+1	; 0x01
    125c:	9a 81       	ldd	r25, Y+2	; 0x02
    125e:	0c 96       	adiw	r24, 0x0c	; 12
    1260:	0e 94 6e 11 	call	0x22dc	; 0x22dc <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    1264:	89 81       	ldd	r24, Y+1	; 0x01
    1266:	9a 81       	ldd	r25, Y+2	; 0x02
    1268:	29 81       	ldd	r18, Y+1	; 0x01
    126a:	3a 81       	ldd	r19, Y+2	; 0x02
    126c:	fc 01       	movw	r30, r24
    126e:	31 87       	std	Z+9, r19	; 0x09
    1270:	20 87       	std	Z+8, r18	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    1272:	8d 81       	ldd	r24, Y+5	; 0x05
    1274:	88 2f       	mov	r24, r24
    1276:	90 e0       	ldi	r25, 0x00	; 0
    1278:	24 e0       	ldi	r18, 0x04	; 4
    127a:	30 e0       	ldi	r19, 0x00	; 0
    127c:	28 1b       	sub	r18, r24
    127e:	39 0b       	sbc	r19, r25
    1280:	89 81       	ldd	r24, Y+1	; 0x01
    1282:	9a 81       	ldd	r25, Y+2	; 0x02
    1284:	fc 01       	movw	r30, r24
    1286:	35 87       	std	Z+13, r19	; 0x0d
    1288:	24 87       	std	Z+12, r18	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    128a:	89 81       	ldd	r24, Y+1	; 0x01
    128c:	9a 81       	ldd	r25, Y+2	; 0x02
    128e:	29 81       	ldd	r18, Y+1	; 0x01
    1290:	3a 81       	ldd	r19, Y+2	; 0x02
    1292:	fc 01       	movw	r30, r24
    1294:	33 8b       	std	Z+19, r19	; 0x13
    1296:	22 8b       	std	Z+18, r18	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    1298:	29 96       	adiw	r28, 0x09	; 9
    129a:	0f b6       	in	r0, 0x3f	; 63
    129c:	f8 94       	cli
    129e:	de bf       	out	0x3e, r29	; 62
    12a0:	0f be       	out	0x3f, r0	; 63
    12a2:	cd bf       	out	0x3d, r28	; 61
    12a4:	df 91       	pop	r29
    12a6:	cf 91       	pop	r28
    12a8:	1f 91       	pop	r17
    12aa:	0f 91       	pop	r16
    12ac:	08 95       	ret

000012ae <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    12ae:	cf 93       	push	r28
    12b0:	df 93       	push	r29
    12b2:	1f 92       	push	r1
    12b4:	cd b7       	in	r28, 0x3d	; 61
    12b6:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    12b8:	19 82       	std	Y+1, r1	; 0x01
    12ba:	13 c0       	rjmp	.+38     	; 0x12e2 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    12bc:	89 81       	ldd	r24, Y+1	; 0x01
    12be:	28 2f       	mov	r18, r24
    12c0:	30 e0       	ldi	r19, 0x00	; 0
    12c2:	c9 01       	movw	r24, r18
    12c4:	88 0f       	add	r24, r24
    12c6:	99 1f       	adc	r25, r25
    12c8:	88 0f       	add	r24, r24
    12ca:	99 1f       	adc	r25, r25
    12cc:	88 0f       	add	r24, r24
    12ce:	99 1f       	adc	r25, r25
    12d0:	82 0f       	add	r24, r18
    12d2:	93 1f       	adc	r25, r19
    12d4:	82 5e       	subi	r24, 0xE2	; 226
    12d6:	9d 4f       	sbci	r25, 0xFD	; 253
    12d8:	0e 94 38 11 	call	0x2270	; 0x2270 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    12dc:	89 81       	ldd	r24, Y+1	; 0x01
    12de:	8f 5f       	subi	r24, 0xFF	; 255
    12e0:	89 83       	std	Y+1, r24	; 0x01
    12e2:	89 81       	ldd	r24, Y+1	; 0x01
    12e4:	84 30       	cpi	r24, 0x04	; 4
    12e6:	50 f3       	brcs	.-44     	; 0x12bc <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    12e8:	82 e4       	ldi	r24, 0x42	; 66
    12ea:	92 e0       	ldi	r25, 0x02	; 2
    12ec:	0e 94 38 11 	call	0x2270	; 0x2270 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    12f0:	8b e4       	ldi	r24, 0x4B	; 75
    12f2:	92 e0       	ldi	r25, 0x02	; 2
    12f4:	0e 94 38 11 	call	0x2270	; 0x2270 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    12f8:	88 e5       	ldi	r24, 0x58	; 88
    12fa:	92 e0       	ldi	r25, 0x02	; 2
    12fc:	0e 94 38 11 	call	0x2270	; 0x2270 <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
    1300:	81 e6       	ldi	r24, 0x61	; 97
    1302:	92 e0       	ldi	r25, 0x02	; 2
    1304:	0e 94 38 11 	call	0x2270	; 0x2270 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1308:	82 e4       	ldi	r24, 0x42	; 66
    130a:	92 e0       	ldi	r25, 0x02	; 2
    130c:	90 93 55 02 	sts	0x0255, r25
    1310:	80 93 54 02 	sts	0x0254, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1314:	8b e4       	ldi	r24, 0x4B	; 75
    1316:	92 e0       	ldi	r25, 0x02	; 2
    1318:	90 93 57 02 	sts	0x0257, r25
    131c:	80 93 56 02 	sts	0x0256, r24
}
    1320:	0f 90       	pop	r0
    1322:	df 91       	pop	r29
    1324:	cf 91       	pop	r28
    1326:	08 95       	ret

00001328 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    1328:	cf 93       	push	r28
    132a:	df 93       	push	r29
    132c:	cd b7       	in	r28, 0x3d	; 61
    132e:	de b7       	in	r29, 0x3e	; 62
				prvDeleteTCB( pxTCB );
			}
		}
	}
	#endif
}
    1330:	df 91       	pop	r29
    1332:	cf 91       	pop	r28
    1334:	08 95       	ret

00001336 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    1336:	cf 93       	push	r28
    1338:	df 93       	push	r29
    133a:	1f 92       	push	r1
    133c:	1f 92       	push	r1
    133e:	cd b7       	in	r28, 0x3d	; 61
    1340:	de b7       	in	r29, 0x3e	; 62
    1342:	9a 83       	std	Y+2, r25	; 0x02
    1344:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1346:	80 91 1c 02 	lds	r24, 0x021C
    134a:	90 91 1d 02 	lds	r25, 0x021D
    134e:	29 81       	ldd	r18, Y+1	; 0x01
    1350:	3a 81       	ldd	r19, Y+2	; 0x02
    1352:	fc 01       	movw	r30, r24
    1354:	33 83       	std	Z+3, r19	; 0x03
    1356:	22 83       	std	Z+2, r18	; 0x02

	if( xTimeToWake < xTickCount )
    1358:	80 91 6b 02 	lds	r24, 0x026B
    135c:	90 91 6c 02 	lds	r25, 0x026C
    1360:	29 81       	ldd	r18, Y+1	; 0x01
    1362:	3a 81       	ldd	r19, Y+2	; 0x02
    1364:	28 17       	cp	r18, r24
    1366:	39 07       	cpc	r19, r25
    1368:	78 f4       	brcc	.+30     	; 0x1388 <prvAddCurrentTaskToDelayedList+0x52>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    136a:	80 91 1c 02 	lds	r24, 0x021C
    136e:	90 91 1d 02 	lds	r25, 0x021D
    1372:	9c 01       	movw	r18, r24
    1374:	2e 5f       	subi	r18, 0xFE	; 254
    1376:	3f 4f       	sbci	r19, 0xFF	; 255
    1378:	80 91 56 02 	lds	r24, 0x0256
    137c:	90 91 57 02 	lds	r25, 0x0257
    1380:	b9 01       	movw	r22, r18
    1382:	0e 94 d7 11 	call	0x23ae	; 0x23ae <vListInsert>
    1386:	1d c0       	rjmp	.+58     	; 0x13c2 <prvAddCurrentTaskToDelayedList+0x8c>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1388:	80 91 1c 02 	lds	r24, 0x021C
    138c:	90 91 1d 02 	lds	r25, 0x021D
    1390:	9c 01       	movw	r18, r24
    1392:	2e 5f       	subi	r18, 0xFE	; 254
    1394:	3f 4f       	sbci	r19, 0xFF	; 255
    1396:	80 91 54 02 	lds	r24, 0x0254
    139a:	90 91 55 02 	lds	r25, 0x0255
    139e:	b9 01       	movw	r22, r18
    13a0:	0e 94 d7 11 	call	0x23ae	; 0x23ae <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    13a4:	80 91 00 02 	lds	r24, 0x0200
    13a8:	90 91 01 02 	lds	r25, 0x0201
    13ac:	29 81       	ldd	r18, Y+1	; 0x01
    13ae:	3a 81       	ldd	r19, Y+2	; 0x02
    13b0:	28 17       	cp	r18, r24
    13b2:	39 07       	cpc	r19, r25
    13b4:	30 f4       	brcc	.+12     	; 0x13c2 <prvAddCurrentTaskToDelayedList+0x8c>
		{
			xNextTaskUnblockTime = xTimeToWake;
    13b6:	89 81       	ldd	r24, Y+1	; 0x01
    13b8:	9a 81       	ldd	r25, Y+2	; 0x02
    13ba:	90 93 01 02 	sts	0x0201, r25
    13be:	80 93 00 02 	sts	0x0200, r24
		}
	}
}
    13c2:	0f 90       	pop	r0
    13c4:	0f 90       	pop	r0
    13c6:	df 91       	pop	r29
    13c8:	cf 91       	pop	r28
    13ca:	08 95       	ret

000013cc <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    13cc:	cf 93       	push	r28
    13ce:	df 93       	push	r29
    13d0:	00 d0       	rcall	.+0      	; 0x13d2 <prvAllocateTCBAndStack+0x6>
    13d2:	00 d0       	rcall	.+0      	; 0x13d4 <prvAllocateTCBAndStack+0x8>
    13d4:	cd b7       	in	r28, 0x3d	; 61
    13d6:	de b7       	in	r29, 0x3e	; 62
    13d8:	9c 83       	std	Y+4, r25	; 0x04
    13da:	8b 83       	std	Y+3, r24	; 0x03
    13dc:	7e 83       	std	Y+6, r23	; 0x06
    13de:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    13e0:	8a e2       	ldi	r24, 0x2A	; 42
    13e2:	90 e0       	ldi	r25, 0x00	; 0
    13e4:	0e 94 9f 15 	call	0x2b3e	; 0x2b3e <pvPortMalloc>
    13e8:	9a 83       	std	Y+2, r25	; 0x02
    13ea:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    13ec:	89 81       	ldd	r24, Y+1	; 0x01
    13ee:	9a 81       	ldd	r25, Y+2	; 0x02
    13f0:	00 97       	sbiw	r24, 0x00	; 0
    13f2:	51 f1       	breq	.+84     	; 0x1448 <prvAllocateTCBAndStack+0x7c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    13f4:	8d 81       	ldd	r24, Y+5	; 0x05
    13f6:	9e 81       	ldd	r25, Y+6	; 0x06
    13f8:	00 97       	sbiw	r24, 0x00	; 0
    13fa:	29 f4       	brne	.+10     	; 0x1406 <prvAllocateTCBAndStack+0x3a>
    13fc:	8b 81       	ldd	r24, Y+3	; 0x03
    13fe:	9c 81       	ldd	r25, Y+4	; 0x04
    1400:	0e 94 9f 15 	call	0x2b3e	; 0x2b3e <pvPortMalloc>
    1404:	02 c0       	rjmp	.+4      	; 0x140a <prvAllocateTCBAndStack+0x3e>
    1406:	8d 81       	ldd	r24, Y+5	; 0x05
    1408:	9e 81       	ldd	r25, Y+6	; 0x06
    140a:	29 81       	ldd	r18, Y+1	; 0x01
    140c:	3a 81       	ldd	r19, Y+2	; 0x02
    140e:	f9 01       	movw	r30, r18
    1410:	90 8f       	std	Z+24, r25	; 0x18
    1412:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    1414:	89 81       	ldd	r24, Y+1	; 0x01
    1416:	9a 81       	ldd	r25, Y+2	; 0x02
    1418:	fc 01       	movw	r30, r24
    141a:	87 89       	ldd	r24, Z+23	; 0x17
    141c:	90 8d       	ldd	r25, Z+24	; 0x18
    141e:	00 97       	sbiw	r24, 0x00	; 0
    1420:	39 f4       	brne	.+14     	; 0x1430 <prvAllocateTCBAndStack+0x64>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    1422:	89 81       	ldd	r24, Y+1	; 0x01
    1424:	9a 81       	ldd	r25, Y+2	; 0x02
    1426:	0e 94 e5 15 	call	0x2bca	; 0x2bca <vPortFree>
			pxNewTCB = NULL;
    142a:	1a 82       	std	Y+2, r1	; 0x02
    142c:	19 82       	std	Y+1, r1	; 0x01
    142e:	0c c0       	rjmp	.+24     	; 0x1448 <prvAllocateTCBAndStack+0x7c>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    1430:	89 81       	ldd	r24, Y+1	; 0x01
    1432:	9a 81       	ldd	r25, Y+2	; 0x02
    1434:	fc 01       	movw	r30, r24
    1436:	87 89       	ldd	r24, Z+23	; 0x17
    1438:	90 8d       	ldd	r25, Z+24	; 0x18
    143a:	2b 81       	ldd	r18, Y+3	; 0x03
    143c:	3c 81       	ldd	r19, Y+4	; 0x04
    143e:	a9 01       	movw	r20, r18
    1440:	65 ea       	ldi	r22, 0xA5	; 165
    1442:	70 e0       	ldi	r23, 0x00	; 0
    1444:	0e 94 80 1c 	call	0x3900	; 0x3900 <memset>
		}
	}

	return pxNewTCB;
    1448:	89 81       	ldd	r24, Y+1	; 0x01
    144a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    144c:	26 96       	adiw	r28, 0x06	; 6
    144e:	0f b6       	in	r0, 0x3f	; 63
    1450:	f8 94       	cli
    1452:	de bf       	out	0x3e, r29	; 62
    1454:	0f be       	out	0x3f, r0	; 63
    1456:	cd bf       	out	0x3d, r28	; 61
    1458:	df 91       	pop	r29
    145a:	cf 91       	pop	r28
    145c:	08 95       	ret

0000145e <usTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
    145e:	0f 93       	push	r16
    1460:	1f 93       	push	r17
    1462:	cf 93       	push	r28
    1464:	df 93       	push	r29
    1466:	1f 92       	push	r1
    1468:	1f 92       	push	r1
    146a:	cd b7       	in	r28, 0x3d	; 61
    146c:	de b7       	in	r29, 0x3e	; 62
    146e:	9a 83       	std	Y+2, r25	; 0x02
    1470:	89 83       	std	Y+1, r24	; 0x01
	register unsigned short usCount = 0U;
    1472:	00 e0       	ldi	r16, 0x00	; 0
    1474:	10 e0       	ldi	r17, 0x00	; 0

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    1476:	09 c0       	rjmp	.+18     	; 0x148a <usTaskCheckFreeStackSpace+0x2c>
		{
			pucStackByte -= portSTACK_GROWTH;
    1478:	89 81       	ldd	r24, Y+1	; 0x01
    147a:	9a 81       	ldd	r25, Y+2	; 0x02
    147c:	01 96       	adiw	r24, 0x01	; 1
    147e:	9a 83       	std	Y+2, r25	; 0x02
    1480:	89 83       	std	Y+1, r24	; 0x01
			usCount++;
    1482:	c8 01       	movw	r24, r16
    1484:	8c 01       	movw	r16, r24
    1486:	0f 5f       	subi	r16, 0xFF	; 255
    1488:	1f 4f       	sbci	r17, 0xFF	; 255

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    148a:	89 81       	ldd	r24, Y+1	; 0x01
    148c:	9a 81       	ldd	r25, Y+2	; 0x02
    148e:	fc 01       	movw	r30, r24
    1490:	80 81       	ld	r24, Z
    1492:	85 3a       	cpi	r24, 0xA5	; 165
    1494:	89 f3       	breq	.-30     	; 0x1478 <usTaskCheckFreeStackSpace+0x1a>
			usCount++;
		}

		usCount /= sizeof( portSTACK_TYPE );

		return usCount;
    1496:	c8 01       	movw	r24, r16
	}
    1498:	0f 90       	pop	r0
    149a:	0f 90       	pop	r0
    149c:	df 91       	pop	r29
    149e:	cf 91       	pop	r28
    14a0:	1f 91       	pop	r17
    14a2:	0f 91       	pop	r16
    14a4:	08 95       	ret

000014a6 <uxTaskGetStackHighWaterMark>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
	{
    14a6:	cf 93       	push	r28
    14a8:	df 93       	push	r29
    14aa:	cd b7       	in	r28, 0x3d	; 61
    14ac:	de b7       	in	r29, 0x3e	; 62
    14ae:	27 97       	sbiw	r28, 0x07	; 7
    14b0:	0f b6       	in	r0, 0x3f	; 63
    14b2:	f8 94       	cli
    14b4:	de bf       	out	0x3e, r29	; 62
    14b6:	0f be       	out	0x3f, r0	; 63
    14b8:	cd bf       	out	0x3d, r28	; 61
    14ba:	9f 83       	std	Y+7, r25	; 0x07
    14bc:	8e 83       	std	Y+6, r24	; 0x06
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    14be:	8e 81       	ldd	r24, Y+6	; 0x06
    14c0:	9f 81       	ldd	r25, Y+7	; 0x07
    14c2:	00 97       	sbiw	r24, 0x00	; 0
    14c4:	29 f4       	brne	.+10     	; 0x14d0 <uxTaskGetStackHighWaterMark+0x2a>
    14c6:	80 91 1c 02 	lds	r24, 0x021C
    14ca:	90 91 1d 02 	lds	r25, 0x021D
    14ce:	02 c0       	rjmp	.+4      	; 0x14d4 <uxTaskGetStackHighWaterMark+0x2e>
    14d0:	8e 81       	ldd	r24, Y+6	; 0x06
    14d2:	9f 81       	ldd	r25, Y+7	; 0x07
    14d4:	9a 83       	std	Y+2, r25	; 0x02
    14d6:	89 83       	std	Y+1, r24	; 0x01

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    14d8:	89 81       	ldd	r24, Y+1	; 0x01
    14da:	9a 81       	ldd	r25, Y+2	; 0x02
    14dc:	fc 01       	movw	r30, r24
    14de:	87 89       	ldd	r24, Z+23	; 0x17
    14e0:	90 8d       	ldd	r25, Z+24	; 0x18
    14e2:	9c 83       	std	Y+4, r25	; 0x04
    14e4:	8b 83       	std	Y+3, r24	; 0x03
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
		}
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
    14e6:	8b 81       	ldd	r24, Y+3	; 0x03
    14e8:	9c 81       	ldd	r25, Y+4	; 0x04
    14ea:	0e 94 2f 0a 	call	0x145e	; 0x145e <usTaskCheckFreeStackSpace>
    14ee:	8d 83       	std	Y+5, r24	; 0x05

		return uxReturn;
    14f0:	8d 81       	ldd	r24, Y+5	; 0x05
	}
    14f2:	27 96       	adiw	r28, 0x07	; 7
    14f4:	0f b6       	in	r0, 0x3f	; 63
    14f6:	f8 94       	cli
    14f8:	de bf       	out	0x3e, r29	; 62
    14fa:	0f be       	out	0x3f, r0	; 63
    14fc:	cd bf       	out	0x3d, r28	; 61
    14fe:	df 91       	pop	r29
    1500:	cf 91       	pop	r28
    1502:	08 95       	ret

00001504 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	xTaskHandle xTaskGetCurrentTaskHandle( void )
	{
    1504:	cf 93       	push	r28
    1506:	df 93       	push	r29
    1508:	1f 92       	push	r1
    150a:	1f 92       	push	r1
    150c:	cd b7       	in	r28, 0x3d	; 61
    150e:	de b7       	in	r29, 0x3e	; 62
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    1510:	80 91 1c 02 	lds	r24, 0x021C
    1514:	90 91 1d 02 	lds	r25, 0x021D
    1518:	9a 83       	std	Y+2, r25	; 0x02
    151a:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    151c:	89 81       	ldd	r24, Y+1	; 0x01
    151e:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    1520:	0f 90       	pop	r0
    1522:	0f 90       	pop	r0
    1524:	df 91       	pop	r29
    1526:	cf 91       	pop	r28
    1528:	08 95       	ret

0000152a <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    152a:	cf 93       	push	r28
    152c:	df 93       	push	r29
    152e:	00 d0       	rcall	.+0      	; 0x1530 <vTaskPriorityInherit+0x6>
    1530:	1f 92       	push	r1
    1532:	cd b7       	in	r28, 0x3d	; 61
    1534:	de b7       	in	r29, 0x3e	; 62
    1536:	9c 83       	std	Y+4, r25	; 0x04
    1538:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
    153a:	8b 81       	ldd	r24, Y+3	; 0x03
    153c:	9c 81       	ldd	r25, Y+4	; 0x04
    153e:	9a 83       	std	Y+2, r25	; 0x02
    1540:	89 83       	std	Y+1, r24	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    1542:	8b 81       	ldd	r24, Y+3	; 0x03
    1544:	9c 81       	ldd	r25, Y+4	; 0x04
    1546:	00 97       	sbiw	r24, 0x00	; 0
    1548:	09 f4       	brne	.+2      	; 0x154c <vTaskPriorityInherit+0x22>
    154a:	78 c0       	rjmp	.+240    	; 0x163c <vTaskPriorityInherit+0x112>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    154c:	89 81       	ldd	r24, Y+1	; 0x01
    154e:	9a 81       	ldd	r25, Y+2	; 0x02
    1550:	fc 01       	movw	r30, r24
    1552:	26 89       	ldd	r18, Z+22	; 0x16
    1554:	80 91 1c 02 	lds	r24, 0x021C
    1558:	90 91 1d 02 	lds	r25, 0x021D
    155c:	fc 01       	movw	r30, r24
    155e:	86 89       	ldd	r24, Z+22	; 0x16
    1560:	28 17       	cp	r18, r24
    1562:	08 f0       	brcs	.+2      	; 0x1566 <vTaskPriorityInherit+0x3c>
    1564:	6b c0       	rjmp	.+214    	; 0x163c <vTaskPriorityInherit+0x112>
			{
				/* Adjust the mutex holder state to account for its new priority. */
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    1566:	80 91 1c 02 	lds	r24, 0x021C
    156a:	90 91 1d 02 	lds	r25, 0x021D
    156e:	fc 01       	movw	r30, r24
    1570:	86 89       	ldd	r24, Z+22	; 0x16
    1572:	88 2f       	mov	r24, r24
    1574:	90 e0       	ldi	r25, 0x00	; 0
    1576:	24 e0       	ldi	r18, 0x04	; 4
    1578:	30 e0       	ldi	r19, 0x00	; 0
    157a:	28 1b       	sub	r18, r24
    157c:	39 0b       	sbc	r19, r25
    157e:	89 81       	ldd	r24, Y+1	; 0x01
    1580:	9a 81       	ldd	r25, Y+2	; 0x02
    1582:	fc 01       	movw	r30, r24
    1584:	35 87       	std	Z+13, r19	; 0x0d
    1586:	24 87       	std	Z+12, r18	; 0x0c

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    1588:	89 81       	ldd	r24, Y+1	; 0x01
    158a:	9a 81       	ldd	r25, Y+2	; 0x02
    158c:	fc 01       	movw	r30, r24
    158e:	42 85       	ldd	r20, Z+10	; 0x0a
    1590:	53 85       	ldd	r21, Z+11	; 0x0b
    1592:	89 81       	ldd	r24, Y+1	; 0x01
    1594:	9a 81       	ldd	r25, Y+2	; 0x02
    1596:	fc 01       	movw	r30, r24
    1598:	86 89       	ldd	r24, Z+22	; 0x16
    159a:	28 2f       	mov	r18, r24
    159c:	30 e0       	ldi	r19, 0x00	; 0
    159e:	c9 01       	movw	r24, r18
    15a0:	88 0f       	add	r24, r24
    15a2:	99 1f       	adc	r25, r25
    15a4:	88 0f       	add	r24, r24
    15a6:	99 1f       	adc	r25, r25
    15a8:	88 0f       	add	r24, r24
    15aa:	99 1f       	adc	r25, r25
    15ac:	82 0f       	add	r24, r18
    15ae:	93 1f       	adc	r25, r19
    15b0:	82 5e       	subi	r24, 0xE2	; 226
    15b2:	9d 4f       	sbci	r25, 0xFD	; 253
    15b4:	48 17       	cp	r20, r24
    15b6:	59 07       	cpc	r21, r25
    15b8:	b9 f5       	brne	.+110    	; 0x1628 <vTaskPriorityInherit+0xfe>
				{
					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    15ba:	89 81       	ldd	r24, Y+1	; 0x01
    15bc:	9a 81       	ldd	r25, Y+2	; 0x02
    15be:	02 96       	adiw	r24, 0x02	; 2
    15c0:	0e 94 50 12 	call	0x24a0	; 0x24a0 <uxListRemove>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    15c4:	80 91 1c 02 	lds	r24, 0x021C
    15c8:	90 91 1d 02 	lds	r25, 0x021D
    15cc:	fc 01       	movw	r30, r24
    15ce:	26 89       	ldd	r18, Z+22	; 0x16
    15d0:	89 81       	ldd	r24, Y+1	; 0x01
    15d2:	9a 81       	ldd	r25, Y+2	; 0x02
    15d4:	fc 01       	movw	r30, r24
    15d6:	26 8b       	std	Z+22, r18	; 0x16
					prvAddTaskToReadyQueue( pxTCB );
    15d8:	89 81       	ldd	r24, Y+1	; 0x01
    15da:	9a 81       	ldd	r25, Y+2	; 0x02
    15dc:	fc 01       	movw	r30, r24
    15de:	96 89       	ldd	r25, Z+22	; 0x16
    15e0:	80 91 6e 02 	lds	r24, 0x026E
    15e4:	89 17       	cp	r24, r25
    15e6:	30 f4       	brcc	.+12     	; 0x15f4 <vTaskPriorityInherit+0xca>
    15e8:	89 81       	ldd	r24, Y+1	; 0x01
    15ea:	9a 81       	ldd	r25, Y+2	; 0x02
    15ec:	fc 01       	movw	r30, r24
    15ee:	86 89       	ldd	r24, Z+22	; 0x16
    15f0:	80 93 6e 02 	sts	0x026E, r24
    15f4:	89 81       	ldd	r24, Y+1	; 0x01
    15f6:	9a 81       	ldd	r25, Y+2	; 0x02
    15f8:	ac 01       	movw	r20, r24
    15fa:	4e 5f       	subi	r20, 0xFE	; 254
    15fc:	5f 4f       	sbci	r21, 0xFF	; 255
    15fe:	89 81       	ldd	r24, Y+1	; 0x01
    1600:	9a 81       	ldd	r25, Y+2	; 0x02
    1602:	fc 01       	movw	r30, r24
    1604:	86 89       	ldd	r24, Z+22	; 0x16
    1606:	28 2f       	mov	r18, r24
    1608:	30 e0       	ldi	r19, 0x00	; 0
    160a:	c9 01       	movw	r24, r18
    160c:	88 0f       	add	r24, r24
    160e:	99 1f       	adc	r25, r25
    1610:	88 0f       	add	r24, r24
    1612:	99 1f       	adc	r25, r25
    1614:	88 0f       	add	r24, r24
    1616:	99 1f       	adc	r25, r25
    1618:	82 0f       	add	r24, r18
    161a:	93 1f       	adc	r25, r19
    161c:	82 5e       	subi	r24, 0xE2	; 226
    161e:	9d 4f       	sbci	r25, 0xFD	; 253
    1620:	ba 01       	movw	r22, r20
    1622:	0e 94 80 11 	call	0x2300	; 0x2300 <vListInsertEnd>
    1626:	0a c0       	rjmp	.+20     	; 0x163c <vTaskPriorityInherit+0x112>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    1628:	80 91 1c 02 	lds	r24, 0x021C
    162c:	90 91 1d 02 	lds	r25, 0x021D
    1630:	fc 01       	movw	r30, r24
    1632:	26 89       	ldd	r18, Z+22	; 0x16
    1634:	89 81       	ldd	r24, Y+1	; 0x01
    1636:	9a 81       	ldd	r25, Y+2	; 0x02
    1638:	fc 01       	movw	r30, r24
    163a:	26 8b       	std	Z+22, r18	; 0x16
				}

				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
			}
		}
	}
    163c:	0f 90       	pop	r0
    163e:	0f 90       	pop	r0
    1640:	0f 90       	pop	r0
    1642:	0f 90       	pop	r0
    1644:	df 91       	pop	r29
    1646:	cf 91       	pop	r28
    1648:	08 95       	ret

0000164a <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    164a:	cf 93       	push	r28
    164c:	df 93       	push	r29
    164e:	00 d0       	rcall	.+0      	; 0x1650 <vTaskPriorityDisinherit+0x6>
    1650:	1f 92       	push	r1
    1652:	cd b7       	in	r28, 0x3d	; 61
    1654:	de b7       	in	r29, 0x3e	; 62
    1656:	9c 83       	std	Y+4, r25	; 0x04
    1658:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
    165a:	8b 81       	ldd	r24, Y+3	; 0x03
    165c:	9c 81       	ldd	r25, Y+4	; 0x04
    165e:	9a 83       	std	Y+2, r25	; 0x02
    1660:	89 83       	std	Y+1, r24	; 0x01

		if( pxMutexHolder != NULL )
    1662:	8b 81       	ldd	r24, Y+3	; 0x03
    1664:	9c 81       	ldd	r25, Y+4	; 0x04
    1666:	00 97       	sbiw	r24, 0x00	; 0
    1668:	09 f4       	brne	.+2      	; 0x166c <vTaskPriorityDisinherit+0x22>
    166a:	4e c0       	rjmp	.+156    	; 0x1708 <vTaskPriorityDisinherit+0xbe>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    166c:	89 81       	ldd	r24, Y+1	; 0x01
    166e:	9a 81       	ldd	r25, Y+2	; 0x02
    1670:	fc 01       	movw	r30, r24
    1672:	26 89       	ldd	r18, Z+22	; 0x16
    1674:	89 81       	ldd	r24, Y+1	; 0x01
    1676:	9a 81       	ldd	r25, Y+2	; 0x02
    1678:	fc 01       	movw	r30, r24
    167a:	81 a5       	ldd	r24, Z+41	; 0x29
    167c:	28 17       	cp	r18, r24
    167e:	09 f4       	brne	.+2      	; 0x1682 <vTaskPriorityDisinherit+0x38>
    1680:	43 c0       	rjmp	.+134    	; 0x1708 <vTaskPriorityDisinherit+0xbe>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    1682:	89 81       	ldd	r24, Y+1	; 0x01
    1684:	9a 81       	ldd	r25, Y+2	; 0x02
    1686:	02 96       	adiw	r24, 0x02	; 2
    1688:	0e 94 50 12 	call	0x24a0	; 0x24a0 <uxListRemove>
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    168c:	89 81       	ldd	r24, Y+1	; 0x01
    168e:	9a 81       	ldd	r25, Y+2	; 0x02
    1690:	fc 01       	movw	r30, r24
    1692:	21 a5       	ldd	r18, Z+41	; 0x29
    1694:	89 81       	ldd	r24, Y+1	; 0x01
    1696:	9a 81       	ldd	r25, Y+2	; 0x02
    1698:	fc 01       	movw	r30, r24
    169a:	26 8b       	std	Z+22, r18	; 0x16
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    169c:	89 81       	ldd	r24, Y+1	; 0x01
    169e:	9a 81       	ldd	r25, Y+2	; 0x02
    16a0:	fc 01       	movw	r30, r24
    16a2:	86 89       	ldd	r24, Z+22	; 0x16
    16a4:	88 2f       	mov	r24, r24
    16a6:	90 e0       	ldi	r25, 0x00	; 0
    16a8:	24 e0       	ldi	r18, 0x04	; 4
    16aa:	30 e0       	ldi	r19, 0x00	; 0
    16ac:	28 1b       	sub	r18, r24
    16ae:	39 0b       	sbc	r19, r25
    16b0:	89 81       	ldd	r24, Y+1	; 0x01
    16b2:	9a 81       	ldd	r25, Y+2	; 0x02
    16b4:	fc 01       	movw	r30, r24
    16b6:	35 87       	std	Z+13, r19	; 0x0d
    16b8:	24 87       	std	Z+12, r18	; 0x0c
				prvAddTaskToReadyQueue( pxTCB );
    16ba:	89 81       	ldd	r24, Y+1	; 0x01
    16bc:	9a 81       	ldd	r25, Y+2	; 0x02
    16be:	fc 01       	movw	r30, r24
    16c0:	96 89       	ldd	r25, Z+22	; 0x16
    16c2:	80 91 6e 02 	lds	r24, 0x026E
    16c6:	89 17       	cp	r24, r25
    16c8:	30 f4       	brcc	.+12     	; 0x16d6 <vTaskPriorityDisinherit+0x8c>
    16ca:	89 81       	ldd	r24, Y+1	; 0x01
    16cc:	9a 81       	ldd	r25, Y+2	; 0x02
    16ce:	fc 01       	movw	r30, r24
    16d0:	86 89       	ldd	r24, Z+22	; 0x16
    16d2:	80 93 6e 02 	sts	0x026E, r24
    16d6:	89 81       	ldd	r24, Y+1	; 0x01
    16d8:	9a 81       	ldd	r25, Y+2	; 0x02
    16da:	ac 01       	movw	r20, r24
    16dc:	4e 5f       	subi	r20, 0xFE	; 254
    16de:	5f 4f       	sbci	r21, 0xFF	; 255
    16e0:	89 81       	ldd	r24, Y+1	; 0x01
    16e2:	9a 81       	ldd	r25, Y+2	; 0x02
    16e4:	fc 01       	movw	r30, r24
    16e6:	86 89       	ldd	r24, Z+22	; 0x16
    16e8:	28 2f       	mov	r18, r24
    16ea:	30 e0       	ldi	r19, 0x00	; 0
    16ec:	c9 01       	movw	r24, r18
    16ee:	88 0f       	add	r24, r24
    16f0:	99 1f       	adc	r25, r25
    16f2:	88 0f       	add	r24, r24
    16f4:	99 1f       	adc	r25, r25
    16f6:	88 0f       	add	r24, r24
    16f8:	99 1f       	adc	r25, r25
    16fa:	82 0f       	add	r24, r18
    16fc:	93 1f       	adc	r25, r19
    16fe:	82 5e       	subi	r24, 0xE2	; 226
    1700:	9d 4f       	sbci	r25, 0xFD	; 253
    1702:	ba 01       	movw	r22, r20
    1704:	0e 94 80 11 	call	0x2300	; 0x2300 <vListInsertEnd>
			}
		}
	}
    1708:	0f 90       	pop	r0
    170a:	0f 90       	pop	r0
    170c:	0f 90       	pop	r0
    170e:	0f 90       	pop	r0
    1710:	df 91       	pop	r29
    1712:	cf 91       	pop	r28
    1714:	08 95       	ret

00001716 <xQueueGenericReset>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle pxQueue, portBASE_TYPE xNewQueue )
{
    1716:	cf 93       	push	r28
    1718:	df 93       	push	r29
    171a:	00 d0       	rcall	.+0      	; 0x171c <xQueueGenericReset+0x6>
    171c:	cd b7       	in	r28, 0x3d	; 61
    171e:	de b7       	in	r29, 0x3e	; 62
    1720:	9a 83       	std	Y+2, r25	; 0x02
    1722:	89 83       	std	Y+1, r24	; 0x01
    1724:	6b 83       	std	Y+3, r22	; 0x03
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1726:	0f b6       	in	r0, 0x3f	; 63
    1728:	f8 94       	cli
    172a:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    172c:	89 81       	ldd	r24, Y+1	; 0x01
    172e:	9a 81       	ldd	r25, Y+2	; 0x02
    1730:	fc 01       	movw	r30, r24
    1732:	20 81       	ld	r18, Z
    1734:	31 81       	ldd	r19, Z+1	; 0x01
    1736:	89 81       	ldd	r24, Y+1	; 0x01
    1738:	9a 81       	ldd	r25, Y+2	; 0x02
    173a:	fc 01       	movw	r30, r24
    173c:	83 8d       	ldd	r24, Z+27	; 0x1b
    173e:	68 2f       	mov	r22, r24
    1740:	70 e0       	ldi	r23, 0x00	; 0
    1742:	89 81       	ldd	r24, Y+1	; 0x01
    1744:	9a 81       	ldd	r25, Y+2	; 0x02
    1746:	fc 01       	movw	r30, r24
    1748:	84 8d       	ldd	r24, Z+28	; 0x1c
    174a:	48 2f       	mov	r20, r24
    174c:	50 e0       	ldi	r21, 0x00	; 0
    174e:	64 9f       	mul	r22, r20
    1750:	c0 01       	movw	r24, r0
    1752:	65 9f       	mul	r22, r21
    1754:	90 0d       	add	r25, r0
    1756:	74 9f       	mul	r23, r20
    1758:	90 0d       	add	r25, r0
    175a:	11 24       	eor	r1, r1
    175c:	28 0f       	add	r18, r24
    175e:	39 1f       	adc	r19, r25
    1760:	89 81       	ldd	r24, Y+1	; 0x01
    1762:	9a 81       	ldd	r25, Y+2	; 0x02
    1764:	fc 01       	movw	r30, r24
    1766:	33 83       	std	Z+3, r19	; 0x03
    1768:	22 83       	std	Z+2, r18	; 0x02
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    176a:	89 81       	ldd	r24, Y+1	; 0x01
    176c:	9a 81       	ldd	r25, Y+2	; 0x02
    176e:	fc 01       	movw	r30, r24
    1770:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1772:	89 81       	ldd	r24, Y+1	; 0x01
    1774:	9a 81       	ldd	r25, Y+2	; 0x02
    1776:	fc 01       	movw	r30, r24
    1778:	20 81       	ld	r18, Z
    177a:	31 81       	ldd	r19, Z+1	; 0x01
    177c:	89 81       	ldd	r24, Y+1	; 0x01
    177e:	9a 81       	ldd	r25, Y+2	; 0x02
    1780:	fc 01       	movw	r30, r24
    1782:	35 83       	std	Z+5, r19	; 0x05
    1784:	24 83       	std	Z+4, r18	; 0x04
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
    1786:	89 81       	ldd	r24, Y+1	; 0x01
    1788:	9a 81       	ldd	r25, Y+2	; 0x02
    178a:	fc 01       	movw	r30, r24
    178c:	20 81       	ld	r18, Z
    178e:	31 81       	ldd	r19, Z+1	; 0x01
    1790:	89 81       	ldd	r24, Y+1	; 0x01
    1792:	9a 81       	ldd	r25, Y+2	; 0x02
    1794:	fc 01       	movw	r30, r24
    1796:	83 8d       	ldd	r24, Z+27	; 0x1b
    1798:	88 2f       	mov	r24, r24
    179a:	90 e0       	ldi	r25, 0x00	; 0
    179c:	bc 01       	movw	r22, r24
    179e:	61 50       	subi	r22, 0x01	; 1
    17a0:	71 09       	sbc	r23, r1
    17a2:	89 81       	ldd	r24, Y+1	; 0x01
    17a4:	9a 81       	ldd	r25, Y+2	; 0x02
    17a6:	fc 01       	movw	r30, r24
    17a8:	84 8d       	ldd	r24, Z+28	; 0x1c
    17aa:	48 2f       	mov	r20, r24
    17ac:	50 e0       	ldi	r21, 0x00	; 0
    17ae:	64 9f       	mul	r22, r20
    17b0:	c0 01       	movw	r24, r0
    17b2:	65 9f       	mul	r22, r21
    17b4:	90 0d       	add	r25, r0
    17b6:	74 9f       	mul	r23, r20
    17b8:	90 0d       	add	r25, r0
    17ba:	11 24       	eor	r1, r1
    17bc:	28 0f       	add	r18, r24
    17be:	39 1f       	adc	r19, r25
    17c0:	89 81       	ldd	r24, Y+1	; 0x01
    17c2:	9a 81       	ldd	r25, Y+2	; 0x02
    17c4:	fc 01       	movw	r30, r24
    17c6:	37 83       	std	Z+7, r19	; 0x07
    17c8:	26 83       	std	Z+6, r18	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    17ca:	89 81       	ldd	r24, Y+1	; 0x01
    17cc:	9a 81       	ldd	r25, Y+2	; 0x02
    17ce:	2f ef       	ldi	r18, 0xFF	; 255
    17d0:	fc 01       	movw	r30, r24
    17d2:	25 8f       	std	Z+29, r18	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    17d4:	89 81       	ldd	r24, Y+1	; 0x01
    17d6:	9a 81       	ldd	r25, Y+2	; 0x02
    17d8:	2f ef       	ldi	r18, 0xFF	; 255
    17da:	fc 01       	movw	r30, r24
    17dc:	26 8f       	std	Z+30, r18	; 0x1e

		if( xNewQueue == pdFALSE )
    17de:	8b 81       	ldd	r24, Y+3	; 0x03
    17e0:	88 23       	and	r24, r24
    17e2:	81 f4       	brne	.+32     	; 0x1804 <xQueueGenericReset+0xee>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to	write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    17e4:	89 81       	ldd	r24, Y+1	; 0x01
    17e6:	9a 81       	ldd	r25, Y+2	; 0x02
    17e8:	fc 01       	movw	r30, r24
    17ea:	80 85       	ldd	r24, Z+8	; 0x08
    17ec:	88 23       	and	r24, r24
    17ee:	a1 f0       	breq	.+40     	; 0x1818 <xQueueGenericReset+0x102>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    17f0:	89 81       	ldd	r24, Y+1	; 0x01
    17f2:	9a 81       	ldd	r25, Y+2	; 0x02
    17f4:	08 96       	adiw	r24, 0x08	; 8
    17f6:	0e 94 e5 07 	call	0xfca	; 0xfca <xTaskRemoveFromEventList>
    17fa:	81 30       	cpi	r24, 0x01	; 1
    17fc:	69 f4       	brne	.+26     	; 0x1818 <xQueueGenericReset+0x102>
				{
					portYIELD_WITHIN_API();
    17fe:	0e 94 12 18 	call	0x3024	; 0x3024 <vPortYield>
    1802:	0a c0       	rjmp	.+20     	; 0x1818 <xQueueGenericReset+0x102>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1804:	89 81       	ldd	r24, Y+1	; 0x01
    1806:	9a 81       	ldd	r25, Y+2	; 0x02
    1808:	08 96       	adiw	r24, 0x08	; 8
    180a:	0e 94 38 11 	call	0x2270	; 0x2270 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    180e:	89 81       	ldd	r24, Y+1	; 0x01
    1810:	9a 81       	ldd	r25, Y+2	; 0x02
    1812:	41 96       	adiw	r24, 0x11	; 17
    1814:	0e 94 38 11 	call	0x2270	; 0x2270 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1818:	0f 90       	pop	r0
    181a:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    181c:	81 e0       	ldi	r24, 0x01	; 1
}
    181e:	0f 90       	pop	r0
    1820:	0f 90       	pop	r0
    1822:	0f 90       	pop	r0
    1824:	df 91       	pop	r29
    1826:	cf 91       	pop	r28
    1828:	08 95       	ret

0000182a <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
    182a:	cf 93       	push	r28
    182c:	df 93       	push	r29
    182e:	cd b7       	in	r28, 0x3d	; 61
    1830:	de b7       	in	r29, 0x3e	; 62
    1832:	29 97       	sbiw	r28, 0x09	; 9
    1834:	0f b6       	in	r0, 0x3f	; 63
    1836:	f8 94       	cli
    1838:	de bf       	out	0x3e, r29	; 62
    183a:	0f be       	out	0x3f, r0	; 63
    183c:	cd bf       	out	0x3d, r28	; 61
    183e:	8f 83       	std	Y+7, r24	; 0x07
    1840:	68 87       	std	Y+8, r22	; 0x08
    1842:	49 87       	std	Y+9, r20	; 0x09
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    1844:	1a 82       	std	Y+2, r1	; 0x02
    1846:	19 82       	std	Y+1, r1	; 0x01
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    1848:	8f 81       	ldd	r24, Y+7	; 0x07
    184a:	88 23       	and	r24, r24
    184c:	09 f4       	brne	.+2      	; 0x1850 <xQueueGenericCreate+0x26>
    184e:	43 c0       	rjmp	.+134    	; 0x18d6 <xQueueGenericCreate+0xac>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    1850:	8f e1       	ldi	r24, 0x1F	; 31
    1852:	90 e0       	ldi	r25, 0x00	; 0
    1854:	0e 94 9f 15 	call	0x2b3e	; 0x2b3e <pvPortMalloc>
    1858:	9c 83       	std	Y+4, r25	; 0x04
    185a:	8b 83       	std	Y+3, r24	; 0x03
		if( pxNewQueue != NULL )
    185c:	8b 81       	ldd	r24, Y+3	; 0x03
    185e:	9c 81       	ldd	r25, Y+4	; 0x04
    1860:	00 97       	sbiw	r24, 0x00	; 0
    1862:	c9 f1       	breq	.+114    	; 0x18d6 <xQueueGenericCreate+0xac>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    1864:	8f 81       	ldd	r24, Y+7	; 0x07
    1866:	48 2f       	mov	r20, r24
    1868:	50 e0       	ldi	r21, 0x00	; 0
    186a:	88 85       	ldd	r24, Y+8	; 0x08
    186c:	28 2f       	mov	r18, r24
    186e:	30 e0       	ldi	r19, 0x00	; 0
    1870:	42 9f       	mul	r20, r18
    1872:	c0 01       	movw	r24, r0
    1874:	43 9f       	mul	r20, r19
    1876:	90 0d       	add	r25, r0
    1878:	52 9f       	mul	r21, r18
    187a:	90 0d       	add	r25, r0
    187c:	11 24       	eor	r1, r1
    187e:	01 96       	adiw	r24, 0x01	; 1
    1880:	9e 83       	std	Y+6, r25	; 0x06
    1882:	8d 83       	std	Y+5, r24	; 0x05

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    1884:	8d 81       	ldd	r24, Y+5	; 0x05
    1886:	9e 81       	ldd	r25, Y+6	; 0x06
    1888:	0e 94 9f 15 	call	0x2b3e	; 0x2b3e <pvPortMalloc>
    188c:	9c 01       	movw	r18, r24
    188e:	8b 81       	ldd	r24, Y+3	; 0x03
    1890:	9c 81       	ldd	r25, Y+4	; 0x04
    1892:	fc 01       	movw	r30, r24
    1894:	31 83       	std	Z+1, r19	; 0x01
    1896:	20 83       	st	Z, r18
			if( pxNewQueue->pcHead != NULL )
    1898:	8b 81       	ldd	r24, Y+3	; 0x03
    189a:	9c 81       	ldd	r25, Y+4	; 0x04
    189c:	fc 01       	movw	r30, r24
    189e:	80 81       	ld	r24, Z
    18a0:	91 81       	ldd	r25, Z+1	; 0x01
    18a2:	00 97       	sbiw	r24, 0x00	; 0
    18a4:	a1 f0       	breq	.+40     	; 0x18ce <xQueueGenericCreate+0xa4>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    18a6:	8b 81       	ldd	r24, Y+3	; 0x03
    18a8:	9c 81       	ldd	r25, Y+4	; 0x04
    18aa:	2f 81       	ldd	r18, Y+7	; 0x07
    18ac:	fc 01       	movw	r30, r24
    18ae:	23 8f       	std	Z+27, r18	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    18b0:	8b 81       	ldd	r24, Y+3	; 0x03
    18b2:	9c 81       	ldd	r25, Y+4	; 0x04
    18b4:	28 85       	ldd	r18, Y+8	; 0x08
    18b6:	fc 01       	movw	r30, r24
    18b8:	24 8f       	std	Z+28, r18	; 0x1c
				xQueueGenericReset( pxNewQueue, pdTRUE );
    18ba:	8b 81       	ldd	r24, Y+3	; 0x03
    18bc:	9c 81       	ldd	r25, Y+4	; 0x04
    18be:	61 e0       	ldi	r22, 0x01	; 1
    18c0:	0e 94 8b 0b 	call	0x1716	; 0x1716 <xQueueGenericReset>
					pxNewQueue->ucQueueType = ucQueueType;
				}
				#endif /* configUSE_TRACE_FACILITY */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    18c4:	8b 81       	ldd	r24, Y+3	; 0x03
    18c6:	9c 81       	ldd	r25, Y+4	; 0x04
    18c8:	9a 83       	std	Y+2, r25	; 0x02
    18ca:	89 83       	std	Y+1, r24	; 0x01
    18cc:	04 c0       	rjmp	.+8      	; 0x18d6 <xQueueGenericCreate+0xac>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    18ce:	8b 81       	ldd	r24, Y+3	; 0x03
    18d0:	9c 81       	ldd	r25, Y+4	; 0x04
    18d2:	0e 94 e5 15 	call	0x2bca	; 0x2bca <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    18d6:	89 81       	ldd	r24, Y+1	; 0x01
    18d8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    18da:	29 96       	adiw	r28, 0x09	; 9
    18dc:	0f b6       	in	r0, 0x3f	; 63
    18de:	f8 94       	cli
    18e0:	de bf       	out	0x3e, r29	; 62
    18e2:	0f be       	out	0x3f, r0	; 63
    18e4:	cd bf       	out	0x3d, r28	; 61
    18e6:	df 91       	pop	r29
    18e8:	cf 91       	pop	r28
    18ea:	08 95       	ret

000018ec <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
	{
    18ec:	cf 93       	push	r28
    18ee:	df 93       	push	r29
    18f0:	00 d0       	rcall	.+0      	; 0x18f2 <xQueueCreateMutex+0x6>
    18f2:	cd b7       	in	r28, 0x3d	; 61
    18f4:	de b7       	in	r29, 0x3e	; 62
    18f6:	8b 83       	std	Y+3, r24	; 0x03
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    18f8:	8f e1       	ldi	r24, 0x1F	; 31
    18fa:	90 e0       	ldi	r25, 0x00	; 0
    18fc:	0e 94 9f 15 	call	0x2b3e	; 0x2b3e <pvPortMalloc>
    1900:	9a 83       	std	Y+2, r25	; 0x02
    1902:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    1904:	89 81       	ldd	r24, Y+1	; 0x01
    1906:	9a 81       	ldd	r25, Y+2	; 0x02
    1908:	00 97       	sbiw	r24, 0x00	; 0
    190a:	f1 f1       	breq	.+124    	; 0x1988 <xQueueCreateMutex+0x9c>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    190c:	89 81       	ldd	r24, Y+1	; 0x01
    190e:	9a 81       	ldd	r25, Y+2	; 0x02
    1910:	fc 01       	movw	r30, r24
    1912:	13 82       	std	Z+3, r1	; 0x03
    1914:	12 82       	std	Z+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    1916:	89 81       	ldd	r24, Y+1	; 0x01
    1918:	9a 81       	ldd	r25, Y+2	; 0x02
    191a:	fc 01       	movw	r30, r24
    191c:	11 82       	std	Z+1, r1	; 0x01
    191e:	10 82       	st	Z, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    1920:	89 81       	ldd	r24, Y+1	; 0x01
    1922:	9a 81       	ldd	r25, Y+2	; 0x02
    1924:	fc 01       	movw	r30, r24
    1926:	15 82       	std	Z+5, r1	; 0x05
    1928:	14 82       	std	Z+4, r1	; 0x04
			pxNewQueue->pcReadFrom = NULL;
    192a:	89 81       	ldd	r24, Y+1	; 0x01
    192c:	9a 81       	ldd	r25, Y+2	; 0x02
    192e:	fc 01       	movw	r30, r24
    1930:	17 82       	std	Z+7, r1	; 0x07
    1932:	16 82       	std	Z+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1934:	89 81       	ldd	r24, Y+1	; 0x01
    1936:	9a 81       	ldd	r25, Y+2	; 0x02
    1938:	fc 01       	movw	r30, r24
    193a:	12 8e       	std	Z+26, r1	; 0x1a
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
    193c:	89 81       	ldd	r24, Y+1	; 0x01
    193e:	9a 81       	ldd	r25, Y+2	; 0x02
    1940:	21 e0       	ldi	r18, 0x01	; 1
    1942:	fc 01       	movw	r30, r24
    1944:	23 8f       	std	Z+27, r18	; 0x1b
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
    1946:	89 81       	ldd	r24, Y+1	; 0x01
    1948:	9a 81       	ldd	r25, Y+2	; 0x02
    194a:	fc 01       	movw	r30, r24
    194c:	14 8e       	std	Z+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    194e:	89 81       	ldd	r24, Y+1	; 0x01
    1950:	9a 81       	ldd	r25, Y+2	; 0x02
    1952:	2f ef       	ldi	r18, 0xFF	; 255
    1954:	fc 01       	movw	r30, r24
    1956:	25 8f       	std	Z+29, r18	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    1958:	89 81       	ldd	r24, Y+1	; 0x01
    195a:	9a 81       	ldd	r25, Y+2	; 0x02
    195c:	2f ef       	ldi	r18, 0xFF	; 255
    195e:	fc 01       	movw	r30, r24
    1960:	26 8f       	std	Z+30, r18	; 0x1e
				pxNewQueue->ucQueueType = ucQueueType;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1962:	89 81       	ldd	r24, Y+1	; 0x01
    1964:	9a 81       	ldd	r25, Y+2	; 0x02
    1966:	08 96       	adiw	r24, 0x08	; 8
    1968:	0e 94 38 11 	call	0x2270	; 0x2270 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    196c:	89 81       	ldd	r24, Y+1	; 0x01
    196e:	9a 81       	ldd	r25, Y+2	; 0x02
    1970:	41 96       	adiw	r24, 0x11	; 17
    1972:	0e 94 38 11 	call	0x2270	; 0x2270 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
    1976:	89 81       	ldd	r24, Y+1	; 0x01
    1978:	9a 81       	ldd	r25, Y+2	; 0x02
    197a:	20 e0       	ldi	r18, 0x00	; 0
    197c:	40 e0       	ldi	r20, 0x00	; 0
    197e:	50 e0       	ldi	r21, 0x00	; 0
    1980:	60 e0       	ldi	r22, 0x00	; 0
    1982:	70 e0       	ldi	r23, 0x00	; 0
    1984:	0e 94 cc 0c 	call	0x1998	; 0x1998 <xQueueGenericSend>
		{
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
    1988:	89 81       	ldd	r24, Y+1	; 0x01
    198a:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    198c:	0f 90       	pop	r0
    198e:	0f 90       	pop	r0
    1990:	0f 90       	pop	r0
    1992:	df 91       	pop	r29
    1994:	cf 91       	pop	r28
    1996:	08 95       	ret

00001998 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    1998:	cf 93       	push	r28
    199a:	df 93       	push	r29
    199c:	cd b7       	in	r28, 0x3d	; 61
    199e:	de b7       	in	r29, 0x3e	; 62
    19a0:	2b 97       	sbiw	r28, 0x0b	; 11
    19a2:	0f b6       	in	r0, 0x3f	; 63
    19a4:	f8 94       	cli
    19a6:	de bf       	out	0x3e, r29	; 62
    19a8:	0f be       	out	0x3f, r0	; 63
    19aa:	cd bf       	out	0x3d, r28	; 61
    19ac:	9e 83       	std	Y+6, r25	; 0x06
    19ae:	8d 83       	std	Y+5, r24	; 0x05
    19b0:	78 87       	std	Y+8, r23	; 0x08
    19b2:	6f 83       	std	Y+7, r22	; 0x07
    19b4:	5a 87       	std	Y+10, r21	; 0x0a
    19b6:	49 87       	std	Y+9, r20	; 0x09
    19b8:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    19ba:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    19bc:	0f b6       	in	r0, 0x3f	; 63
    19be:	f8 94       	cli
    19c0:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    19c2:	8d 81       	ldd	r24, Y+5	; 0x05
    19c4:	9e 81       	ldd	r25, Y+6	; 0x06
    19c6:	fc 01       	movw	r30, r24
    19c8:	22 8d       	ldd	r18, Z+26	; 0x1a
    19ca:	8d 81       	ldd	r24, Y+5	; 0x05
    19cc:	9e 81       	ldd	r25, Y+6	; 0x06
    19ce:	fc 01       	movw	r30, r24
    19d0:	83 8d       	ldd	r24, Z+27	; 0x1b
    19d2:	28 17       	cp	r18, r24
    19d4:	d8 f4       	brcc	.+54     	; 0x1a0c <xQueueGenericSend+0x74>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    19d6:	2f 81       	ldd	r18, Y+7	; 0x07
    19d8:	38 85       	ldd	r19, Y+8	; 0x08
    19da:	8d 81       	ldd	r24, Y+5	; 0x05
    19dc:	9e 81       	ldd	r25, Y+6	; 0x06
    19de:	4b 85       	ldd	r20, Y+11	; 0x0b
    19e0:	b9 01       	movw	r22, r18
    19e2:	0e 94 56 0f 	call	0x1eac	; 0x1eac <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    19e6:	8d 81       	ldd	r24, Y+5	; 0x05
    19e8:	9e 81       	ldd	r25, Y+6	; 0x06
    19ea:	fc 01       	movw	r30, r24
    19ec:	81 89       	ldd	r24, Z+17	; 0x11
    19ee:	88 23       	and	r24, r24
    19f0:	49 f0       	breq	.+18     	; 0x1a04 <xQueueGenericSend+0x6c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    19f2:	8d 81       	ldd	r24, Y+5	; 0x05
    19f4:	9e 81       	ldd	r25, Y+6	; 0x06
    19f6:	41 96       	adiw	r24, 0x11	; 17
    19f8:	0e 94 e5 07 	call	0xfca	; 0xfca <xTaskRemoveFromEventList>
    19fc:	81 30       	cpi	r24, 0x01	; 1
    19fe:	11 f4       	brne	.+4      	; 0x1a04 <xQueueGenericSend+0x6c>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    1a00:	0e 94 12 18 	call	0x3024	; 0x3024 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    1a04:	0f 90       	pop	r0
    1a06:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    1a08:	81 e0       	ldi	r24, 0x01	; 1
    1a0a:	61 c0       	rjmp	.+194    	; 0x1ace <xQueueGenericSend+0x136>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1a0c:	89 85       	ldd	r24, Y+9	; 0x09
    1a0e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a10:	00 97       	sbiw	r24, 0x00	; 0
    1a12:	21 f4       	brne	.+8      	; 0x1a1c <xQueueGenericSend+0x84>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1a14:	0f 90       	pop	r0
    1a16:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1a18:	80 e0       	ldi	r24, 0x00	; 0
    1a1a:	59 c0       	rjmp	.+178    	; 0x1ace <xQueueGenericSend+0x136>
				}
				else if( xEntryTimeSet == pdFALSE )
    1a1c:	89 81       	ldd	r24, Y+1	; 0x01
    1a1e:	88 23       	and	r24, r24
    1a20:	31 f4       	brne	.+12     	; 0x1a2e <xQueueGenericSend+0x96>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1a22:	ce 01       	movw	r24, r28
    1a24:	02 96       	adiw	r24, 0x02	; 2
    1a26:	0e 94 4f 08 	call	0x109e	; 0x109e <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1a2a:	81 e0       	ldi	r24, 0x01	; 1
    1a2c:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    1a2e:	0f 90       	pop	r0
    1a30:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1a32:	0e 94 88 05 	call	0xb10	; 0xb10 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1a36:	0f b6       	in	r0, 0x3f	; 63
    1a38:	f8 94       	cli
    1a3a:	0f 92       	push	r0
    1a3c:	8d 81       	ldd	r24, Y+5	; 0x05
    1a3e:	9e 81       	ldd	r25, Y+6	; 0x06
    1a40:	fc 01       	movw	r30, r24
    1a42:	85 8d       	ldd	r24, Z+29	; 0x1d
    1a44:	8f 3f       	cpi	r24, 0xFF	; 255
    1a46:	21 f4       	brne	.+8      	; 0x1a50 <xQueueGenericSend+0xb8>
    1a48:	8d 81       	ldd	r24, Y+5	; 0x05
    1a4a:	9e 81       	ldd	r25, Y+6	; 0x06
    1a4c:	fc 01       	movw	r30, r24
    1a4e:	15 8e       	std	Z+29, r1	; 0x1d
    1a50:	8d 81       	ldd	r24, Y+5	; 0x05
    1a52:	9e 81       	ldd	r25, Y+6	; 0x06
    1a54:	fc 01       	movw	r30, r24
    1a56:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a58:	8f 3f       	cpi	r24, 0xFF	; 255
    1a5a:	21 f4       	brne	.+8      	; 0x1a64 <xQueueGenericSend+0xcc>
    1a5c:	8d 81       	ldd	r24, Y+5	; 0x05
    1a5e:	9e 81       	ldd	r25, Y+6	; 0x06
    1a60:	fc 01       	movw	r30, r24
    1a62:	16 8e       	std	Z+30, r1	; 0x1e
    1a64:	0f 90       	pop	r0
    1a66:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1a68:	9e 01       	movw	r18, r28
    1a6a:	27 5f       	subi	r18, 0xF7	; 247
    1a6c:	3f 4f       	sbci	r19, 0xFF	; 255
    1a6e:	ce 01       	movw	r24, r28
    1a70:	02 96       	adiw	r24, 0x02	; 2
    1a72:	b9 01       	movw	r22, r18
    1a74:	0e 94 6b 08 	call	0x10d6	; 0x10d6 <xTaskCheckForTimeOut>
    1a78:	88 23       	and	r24, r24
    1a7a:	01 f5       	brne	.+64     	; 0x1abc <xQueueGenericSend+0x124>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1a7c:	8d 81       	ldd	r24, Y+5	; 0x05
    1a7e:	9e 81       	ldd	r25, Y+6	; 0x06
    1a80:	0e 94 fd 10 	call	0x21fa	; 0x21fa <prvIsQueueFull>
    1a84:	88 23       	and	r24, r24
    1a86:	99 f0       	breq	.+38     	; 0x1aae <xQueueGenericSend+0x116>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1a88:	29 85       	ldd	r18, Y+9	; 0x09
    1a8a:	3a 85       	ldd	r19, Y+10	; 0x0a
    1a8c:	8d 81       	ldd	r24, Y+5	; 0x05
    1a8e:	9e 81       	ldd	r25, Y+6	; 0x06
    1a90:	08 96       	adiw	r24, 0x08	; 8
    1a92:	b9 01       	movw	r22, r18
    1a94:	0e 94 a0 07 	call	0xf40	; 0xf40 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1a98:	8d 81       	ldd	r24, Y+5	; 0x05
    1a9a:	9e 81       	ldd	r25, Y+6	; 0x06
    1a9c:	0e 94 65 10 	call	0x20ca	; 0x20ca <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1aa0:	0e 94 94 05 	call	0xb28	; 0xb28 <xTaskResumeAll>
    1aa4:	88 23       	and	r24, r24
    1aa6:	91 f4       	brne	.+36     	; 0x1acc <xQueueGenericSend+0x134>
				{
					portYIELD_WITHIN_API();
    1aa8:	0e 94 12 18 	call	0x3024	; 0x3024 <vPortYield>
    1aac:	0f c0       	rjmp	.+30     	; 0x1acc <xQueueGenericSend+0x134>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1aae:	8d 81       	ldd	r24, Y+5	; 0x05
    1ab0:	9e 81       	ldd	r25, Y+6	; 0x06
    1ab2:	0e 94 65 10 	call	0x20ca	; 0x20ca <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1ab6:	0e 94 94 05 	call	0xb28	; 0xb28 <xTaskResumeAll>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
    1aba:	80 cf       	rjmp	.-256    	; 0x19bc <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1abc:	8d 81       	ldd	r24, Y+5	; 0x05
    1abe:	9e 81       	ldd	r25, Y+6	; 0x06
    1ac0:	0e 94 65 10 	call	0x20ca	; 0x20ca <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1ac4:	0e 94 94 05 	call	0xb28	; 0xb28 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1ac8:	80 e0       	ldi	r24, 0x00	; 0
    1aca:	01 c0       	rjmp	.+2      	; 0x1ace <xQueueGenericSend+0x136>
		}
	}
    1acc:	77 cf       	rjmp	.-274    	; 0x19bc <xQueueGenericSend+0x24>
}
    1ace:	2b 96       	adiw	r28, 0x0b	; 11
    1ad0:	0f b6       	in	r0, 0x3f	; 63
    1ad2:	f8 94       	cli
    1ad4:	de bf       	out	0x3e, r29	; 62
    1ad6:	0f be       	out	0x3f, r0	; 63
    1ad8:	cd bf       	out	0x3d, r28	; 61
    1ada:	df 91       	pop	r29
    1adc:	cf 91       	pop	r28
    1ade:	08 95       	ret

00001ae0 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1ae0:	cf 93       	push	r28
    1ae2:	df 93       	push	r29
    1ae4:	cd b7       	in	r28, 0x3d	; 61
    1ae6:	de b7       	in	r29, 0x3e	; 62
    1ae8:	29 97       	sbiw	r28, 0x09	; 9
    1aea:	0f b6       	in	r0, 0x3f	; 63
    1aec:	f8 94       	cli
    1aee:	de bf       	out	0x3e, r29	; 62
    1af0:	0f be       	out	0x3f, r0	; 63
    1af2:	cd bf       	out	0x3d, r28	; 61
    1af4:	9c 83       	std	Y+4, r25	; 0x04
    1af6:	8b 83       	std	Y+3, r24	; 0x03
    1af8:	7e 83       	std	Y+6, r23	; 0x06
    1afa:	6d 83       	std	Y+5, r22	; 0x05
    1afc:	58 87       	std	Y+8, r21	; 0x08
    1afe:	4f 83       	std	Y+7, r20	; 0x07
    1b00:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1b02:	1a 82       	std	Y+2, r1	; 0x02
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1b04:	8b 81       	ldd	r24, Y+3	; 0x03
    1b06:	9c 81       	ldd	r25, Y+4	; 0x04
    1b08:	fc 01       	movw	r30, r24
    1b0a:	22 8d       	ldd	r18, Z+26	; 0x1a
    1b0c:	8b 81       	ldd	r24, Y+3	; 0x03
    1b0e:	9c 81       	ldd	r25, Y+4	; 0x04
    1b10:	fc 01       	movw	r30, r24
    1b12:	83 8d       	ldd	r24, Z+27	; 0x1b
    1b14:	28 17       	cp	r18, r24
    1b16:	90 f5       	brcc	.+100    	; 0x1b7c <xQueueGenericSendFromISR+0x9c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1b18:	2d 81       	ldd	r18, Y+5	; 0x05
    1b1a:	3e 81       	ldd	r19, Y+6	; 0x06
    1b1c:	8b 81       	ldd	r24, Y+3	; 0x03
    1b1e:	9c 81       	ldd	r25, Y+4	; 0x04
    1b20:	49 85       	ldd	r20, Y+9	; 0x09
    1b22:	b9 01       	movw	r22, r18
    1b24:	0e 94 56 0f 	call	0x1eac	; 0x1eac <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1b28:	8b 81       	ldd	r24, Y+3	; 0x03
    1b2a:	9c 81       	ldd	r25, Y+4	; 0x04
    1b2c:	fc 01       	movw	r30, r24
    1b2e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b30:	8f 3f       	cpi	r24, 0xFF	; 255
    1b32:	b9 f4       	brne	.+46     	; 0x1b62 <xQueueGenericSendFromISR+0x82>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b34:	8b 81       	ldd	r24, Y+3	; 0x03
    1b36:	9c 81       	ldd	r25, Y+4	; 0x04
    1b38:	fc 01       	movw	r30, r24
    1b3a:	81 89       	ldd	r24, Z+17	; 0x11
    1b3c:	88 23       	and	r24, r24
    1b3e:	d9 f0       	breq	.+54     	; 0x1b76 <xQueueGenericSendFromISR+0x96>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b40:	8b 81       	ldd	r24, Y+3	; 0x03
    1b42:	9c 81       	ldd	r25, Y+4	; 0x04
    1b44:	41 96       	adiw	r24, 0x11	; 17
    1b46:	0e 94 e5 07 	call	0xfca	; 0xfca <xTaskRemoveFromEventList>
    1b4a:	88 23       	and	r24, r24
    1b4c:	a1 f0       	breq	.+40     	; 0x1b76 <xQueueGenericSendFromISR+0x96>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						if( pxHigherPriorityTaskWoken != NULL )
    1b4e:	8f 81       	ldd	r24, Y+7	; 0x07
    1b50:	98 85       	ldd	r25, Y+8	; 0x08
    1b52:	00 97       	sbiw	r24, 0x00	; 0
    1b54:	81 f0       	breq	.+32     	; 0x1b76 <xQueueGenericSendFromISR+0x96>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1b56:	8f 81       	ldd	r24, Y+7	; 0x07
    1b58:	98 85       	ldd	r25, Y+8	; 0x08
    1b5a:	21 e0       	ldi	r18, 0x01	; 1
    1b5c:	fc 01       	movw	r30, r24
    1b5e:	20 83       	st	Z, r18
    1b60:	0a c0       	rjmp	.+20     	; 0x1b76 <xQueueGenericSendFromISR+0x96>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1b62:	8b 81       	ldd	r24, Y+3	; 0x03
    1b64:	9c 81       	ldd	r25, Y+4	; 0x04
    1b66:	fc 01       	movw	r30, r24
    1b68:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b6a:	21 e0       	ldi	r18, 0x01	; 1
    1b6c:	28 0f       	add	r18, r24
    1b6e:	8b 81       	ldd	r24, Y+3	; 0x03
    1b70:	9c 81       	ldd	r25, Y+4	; 0x04
    1b72:	fc 01       	movw	r30, r24
    1b74:	26 8f       	std	Z+30, r18	; 0x1e
			}

			xReturn = pdPASS;
    1b76:	81 e0       	ldi	r24, 0x01	; 1
    1b78:	89 83       	std	Y+1, r24	; 0x01
    1b7a:	01 c0       	rjmp	.+2      	; 0x1b7e <xQueueGenericSendFromISR+0x9e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1b7c:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1b7e:	89 81       	ldd	r24, Y+1	; 0x01
}
    1b80:	29 96       	adiw	r28, 0x09	; 9
    1b82:	0f b6       	in	r0, 0x3f	; 63
    1b84:	f8 94       	cli
    1b86:	de bf       	out	0x3e, r29	; 62
    1b88:	0f be       	out	0x3f, r0	; 63
    1b8a:	cd bf       	out	0x3d, r28	; 61
    1b8c:	df 91       	pop	r29
    1b8e:	cf 91       	pop	r28
    1b90:	08 95       	ret

00001b92 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1b92:	cf 93       	push	r28
    1b94:	df 93       	push	r29
    1b96:	cd b7       	in	r28, 0x3d	; 61
    1b98:	de b7       	in	r29, 0x3e	; 62
    1b9a:	2d 97       	sbiw	r28, 0x0d	; 13
    1b9c:	0f b6       	in	r0, 0x3f	; 63
    1b9e:	f8 94       	cli
    1ba0:	de bf       	out	0x3e, r29	; 62
    1ba2:	0f be       	out	0x3f, r0	; 63
    1ba4:	cd bf       	out	0x3d, r28	; 61
    1ba6:	98 87       	std	Y+8, r25	; 0x08
    1ba8:	8f 83       	std	Y+7, r24	; 0x07
    1baa:	7a 87       	std	Y+10, r23	; 0x0a
    1bac:	69 87       	std	Y+9, r22	; 0x09
    1bae:	5c 87       	std	Y+12, r21	; 0x0c
    1bb0:	4b 87       	std	Y+11, r20	; 0x0b
    1bb2:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1bb4:	19 82       	std	Y+1, r1	; 0x01
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1bb6:	0f b6       	in	r0, 0x3f	; 63
    1bb8:	f8 94       	cli
    1bba:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1bbc:	8f 81       	ldd	r24, Y+7	; 0x07
    1bbe:	98 85       	ldd	r25, Y+8	; 0x08
    1bc0:	fc 01       	movw	r30, r24
    1bc2:	82 8d       	ldd	r24, Z+26	; 0x1a
    1bc4:	88 23       	and	r24, r24
    1bc6:	09 f4       	brne	.+2      	; 0x1bca <xQueueGenericReceive+0x38>
    1bc8:	54 c0       	rjmp	.+168    	; 0x1c72 <xQueueGenericReceive+0xe0>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1bca:	8f 81       	ldd	r24, Y+7	; 0x07
    1bcc:	98 85       	ldd	r25, Y+8	; 0x08
    1bce:	fc 01       	movw	r30, r24
    1bd0:	86 81       	ldd	r24, Z+6	; 0x06
    1bd2:	97 81       	ldd	r25, Z+7	; 0x07
    1bd4:	9b 83       	std	Y+3, r25	; 0x03
    1bd6:	8a 83       	std	Y+2, r24	; 0x02

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1bd8:	29 85       	ldd	r18, Y+9	; 0x09
    1bda:	3a 85       	ldd	r19, Y+10	; 0x0a
    1bdc:	8f 81       	ldd	r24, Y+7	; 0x07
    1bde:	98 85       	ldd	r25, Y+8	; 0x08
    1be0:	b9 01       	movw	r22, r18
    1be2:	0e 94 14 10 	call	0x2028	; 0x2028 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1be6:	8d 85       	ldd	r24, Y+13	; 0x0d
    1be8:	88 23       	and	r24, r24
    1bea:	49 f5       	brne	.+82     	; 0x1c3e <xQueueGenericReceive+0xac>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1bec:	8f 81       	ldd	r24, Y+7	; 0x07
    1bee:	98 85       	ldd	r25, Y+8	; 0x08
    1bf0:	fc 01       	movw	r30, r24
    1bf2:	82 8d       	ldd	r24, Z+26	; 0x1a
    1bf4:	2f ef       	ldi	r18, 0xFF	; 255
    1bf6:	28 0f       	add	r18, r24
    1bf8:	8f 81       	ldd	r24, Y+7	; 0x07
    1bfa:	98 85       	ldd	r25, Y+8	; 0x08
    1bfc:	fc 01       	movw	r30, r24
    1bfe:	22 8f       	std	Z+26, r18	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1c00:	8f 81       	ldd	r24, Y+7	; 0x07
    1c02:	98 85       	ldd	r25, Y+8	; 0x08
    1c04:	fc 01       	movw	r30, r24
    1c06:	80 81       	ld	r24, Z
    1c08:	91 81       	ldd	r25, Z+1	; 0x01
    1c0a:	00 97       	sbiw	r24, 0x00	; 0
    1c0c:	41 f4       	brne	.+16     	; 0x1c1e <xQueueGenericReceive+0x8c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    1c0e:	0e 94 82 0a 	call	0x1504	; 0x1504 <xTaskGetCurrentTaskHandle>
    1c12:	9c 01       	movw	r18, r24
    1c14:	8f 81       	ldd	r24, Y+7	; 0x07
    1c16:	98 85       	ldd	r25, Y+8	; 0x08
    1c18:	fc 01       	movw	r30, r24
    1c1a:	33 83       	std	Z+3, r19	; 0x03
    1c1c:	22 83       	std	Z+2, r18	; 0x02
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1c1e:	8f 81       	ldd	r24, Y+7	; 0x07
    1c20:	98 85       	ldd	r25, Y+8	; 0x08
    1c22:	fc 01       	movw	r30, r24
    1c24:	80 85       	ldd	r24, Z+8	; 0x08
    1c26:	88 23       	and	r24, r24
    1c28:	01 f1       	breq	.+64     	; 0x1c6a <xQueueGenericReceive+0xd8>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1c2a:	8f 81       	ldd	r24, Y+7	; 0x07
    1c2c:	98 85       	ldd	r25, Y+8	; 0x08
    1c2e:	08 96       	adiw	r24, 0x08	; 8
    1c30:	0e 94 e5 07 	call	0xfca	; 0xfca <xTaskRemoveFromEventList>
    1c34:	81 30       	cpi	r24, 0x01	; 1
    1c36:	c9 f4       	brne	.+50     	; 0x1c6a <xQueueGenericReceive+0xd8>
						{
							portYIELD_WITHIN_API();
    1c38:	0e 94 12 18 	call	0x3024	; 0x3024 <vPortYield>
    1c3c:	16 c0       	rjmp	.+44     	; 0x1c6a <xQueueGenericReceive+0xd8>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1c3e:	8f 81       	ldd	r24, Y+7	; 0x07
    1c40:	98 85       	ldd	r25, Y+8	; 0x08
    1c42:	2a 81       	ldd	r18, Y+2	; 0x02
    1c44:	3b 81       	ldd	r19, Y+3	; 0x03
    1c46:	fc 01       	movw	r30, r24
    1c48:	37 83       	std	Z+7, r19	; 0x07
    1c4a:	26 83       	std	Z+6, r18	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1c4c:	8f 81       	ldd	r24, Y+7	; 0x07
    1c4e:	98 85       	ldd	r25, Y+8	; 0x08
    1c50:	fc 01       	movw	r30, r24
    1c52:	81 89       	ldd	r24, Z+17	; 0x11
    1c54:	88 23       	and	r24, r24
    1c56:	49 f0       	breq	.+18     	; 0x1c6a <xQueueGenericReceive+0xd8>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1c58:	8f 81       	ldd	r24, Y+7	; 0x07
    1c5a:	98 85       	ldd	r25, Y+8	; 0x08
    1c5c:	41 96       	adiw	r24, 0x11	; 17
    1c5e:	0e 94 e5 07 	call	0xfca	; 0xfca <xTaskRemoveFromEventList>
    1c62:	88 23       	and	r24, r24
    1c64:	11 f0       	breq	.+4      	; 0x1c6a <xQueueGenericReceive+0xd8>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1c66:	0e 94 12 18 	call	0x3024	; 0x3024 <vPortYield>
						}
					}
				}

				taskEXIT_CRITICAL();
    1c6a:	0f 90       	pop	r0
    1c6c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1c6e:	81 e0       	ldi	r24, 0x01	; 1
    1c70:	74 c0       	rjmp	.+232    	; 0x1d5a <xQueueGenericReceive+0x1c8>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1c72:	8b 85       	ldd	r24, Y+11	; 0x0b
    1c74:	9c 85       	ldd	r25, Y+12	; 0x0c
    1c76:	00 97       	sbiw	r24, 0x00	; 0
    1c78:	21 f4       	brne	.+8      	; 0x1c82 <xQueueGenericReceive+0xf0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1c7a:	0f 90       	pop	r0
    1c7c:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1c7e:	80 e0       	ldi	r24, 0x00	; 0
    1c80:	6c c0       	rjmp	.+216    	; 0x1d5a <xQueueGenericReceive+0x1c8>
				}
				else if( xEntryTimeSet == pdFALSE )
    1c82:	89 81       	ldd	r24, Y+1	; 0x01
    1c84:	88 23       	and	r24, r24
    1c86:	31 f4       	brne	.+12     	; 0x1c94 <xQueueGenericReceive+0x102>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1c88:	ce 01       	movw	r24, r28
    1c8a:	04 96       	adiw	r24, 0x04	; 4
    1c8c:	0e 94 4f 08 	call	0x109e	; 0x109e <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1c90:	81 e0       	ldi	r24, 0x01	; 1
    1c92:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    1c94:	0f 90       	pop	r0
    1c96:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1c98:	0e 94 88 05 	call	0xb10	; 0xb10 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1c9c:	0f b6       	in	r0, 0x3f	; 63
    1c9e:	f8 94       	cli
    1ca0:	0f 92       	push	r0
    1ca2:	8f 81       	ldd	r24, Y+7	; 0x07
    1ca4:	98 85       	ldd	r25, Y+8	; 0x08
    1ca6:	fc 01       	movw	r30, r24
    1ca8:	85 8d       	ldd	r24, Z+29	; 0x1d
    1caa:	8f 3f       	cpi	r24, 0xFF	; 255
    1cac:	21 f4       	brne	.+8      	; 0x1cb6 <xQueueGenericReceive+0x124>
    1cae:	8f 81       	ldd	r24, Y+7	; 0x07
    1cb0:	98 85       	ldd	r25, Y+8	; 0x08
    1cb2:	fc 01       	movw	r30, r24
    1cb4:	15 8e       	std	Z+29, r1	; 0x1d
    1cb6:	8f 81       	ldd	r24, Y+7	; 0x07
    1cb8:	98 85       	ldd	r25, Y+8	; 0x08
    1cba:	fc 01       	movw	r30, r24
    1cbc:	86 8d       	ldd	r24, Z+30	; 0x1e
    1cbe:	8f 3f       	cpi	r24, 0xFF	; 255
    1cc0:	21 f4       	brne	.+8      	; 0x1cca <xQueueGenericReceive+0x138>
    1cc2:	8f 81       	ldd	r24, Y+7	; 0x07
    1cc4:	98 85       	ldd	r25, Y+8	; 0x08
    1cc6:	fc 01       	movw	r30, r24
    1cc8:	16 8e       	std	Z+30, r1	; 0x1e
    1cca:	0f 90       	pop	r0
    1ccc:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1cce:	9e 01       	movw	r18, r28
    1cd0:	25 5f       	subi	r18, 0xF5	; 245
    1cd2:	3f 4f       	sbci	r19, 0xFF	; 255
    1cd4:	ce 01       	movw	r24, r28
    1cd6:	04 96       	adiw	r24, 0x04	; 4
    1cd8:	b9 01       	movw	r22, r18
    1cda:	0e 94 6b 08 	call	0x10d6	; 0x10d6 <xTaskCheckForTimeOut>
    1cde:	88 23       	and	r24, r24
    1ce0:	99 f5       	brne	.+102    	; 0x1d48 <xQueueGenericReceive+0x1b6>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1ce2:	8f 81       	ldd	r24, Y+7	; 0x07
    1ce4:	98 85       	ldd	r25, Y+8	; 0x08
    1ce6:	0e 94 ca 10 	call	0x2194	; 0x2194 <prvIsQueueEmpty>
    1cea:	88 23       	and	r24, r24
    1cec:	31 f1       	breq	.+76     	; 0x1d3a <xQueueGenericReceive+0x1a8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1cee:	8f 81       	ldd	r24, Y+7	; 0x07
    1cf0:	98 85       	ldd	r25, Y+8	; 0x08
    1cf2:	fc 01       	movw	r30, r24
    1cf4:	80 81       	ld	r24, Z
    1cf6:	91 81       	ldd	r25, Z+1	; 0x01
    1cf8:	00 97       	sbiw	r24, 0x00	; 0
    1cfa:	61 f4       	brne	.+24     	; 0x1d14 <xQueueGenericReceive+0x182>
					{
						portENTER_CRITICAL();
    1cfc:	0f b6       	in	r0, 0x3f	; 63
    1cfe:	f8 94       	cli
    1d00:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1d02:	8f 81       	ldd	r24, Y+7	; 0x07
    1d04:	98 85       	ldd	r25, Y+8	; 0x08
    1d06:	fc 01       	movw	r30, r24
    1d08:	82 81       	ldd	r24, Z+2	; 0x02
    1d0a:	93 81       	ldd	r25, Z+3	; 0x03
    1d0c:	0e 94 95 0a 	call	0x152a	; 0x152a <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    1d10:	0f 90       	pop	r0
    1d12:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1d14:	2b 85       	ldd	r18, Y+11	; 0x0b
    1d16:	3c 85       	ldd	r19, Y+12	; 0x0c
    1d18:	8f 81       	ldd	r24, Y+7	; 0x07
    1d1a:	98 85       	ldd	r25, Y+8	; 0x08
    1d1c:	41 96       	adiw	r24, 0x11	; 17
    1d1e:	b9 01       	movw	r22, r18
    1d20:	0e 94 a0 07 	call	0xf40	; 0xf40 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1d24:	8f 81       	ldd	r24, Y+7	; 0x07
    1d26:	98 85       	ldd	r25, Y+8	; 0x08
    1d28:	0e 94 65 10 	call	0x20ca	; 0x20ca <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1d2c:	0e 94 94 05 	call	0xb28	; 0xb28 <xTaskResumeAll>
    1d30:	88 23       	and	r24, r24
    1d32:	91 f4       	brne	.+36     	; 0x1d58 <xQueueGenericReceive+0x1c6>
				{
					portYIELD_WITHIN_API();
    1d34:	0e 94 12 18 	call	0x3024	; 0x3024 <vPortYield>
    1d38:	0f c0       	rjmp	.+30     	; 0x1d58 <xQueueGenericReceive+0x1c6>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1d3a:	8f 81       	ldd	r24, Y+7	; 0x07
    1d3c:	98 85       	ldd	r25, Y+8	; 0x08
    1d3e:	0e 94 65 10 	call	0x20ca	; 0x20ca <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1d42:	0e 94 94 05 	call	0xb28	; 0xb28 <xTaskResumeAll>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
    1d46:	37 cf       	rjmp	.-402    	; 0x1bb6 <xQueueGenericReceive+0x24>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1d48:	8f 81       	ldd	r24, Y+7	; 0x07
    1d4a:	98 85       	ldd	r25, Y+8	; 0x08
    1d4c:	0e 94 65 10 	call	0x20ca	; 0x20ca <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1d50:	0e 94 94 05 	call	0xb28	; 0xb28 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1d54:	80 e0       	ldi	r24, 0x00	; 0
    1d56:	01 c0       	rjmp	.+2      	; 0x1d5a <xQueueGenericReceive+0x1c8>
		}
	}
    1d58:	2e cf       	rjmp	.-420    	; 0x1bb6 <xQueueGenericReceive+0x24>
}
    1d5a:	2d 96       	adiw	r28, 0x0d	; 13
    1d5c:	0f b6       	in	r0, 0x3f	; 63
    1d5e:	f8 94       	cli
    1d60:	de bf       	out	0x3e, r29	; 62
    1d62:	0f be       	out	0x3f, r0	; 63
    1d64:	cd bf       	out	0x3d, r28	; 61
    1d66:	df 91       	pop	r29
    1d68:	cf 91       	pop	r28
    1d6a:	08 95       	ret

00001d6c <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
{
    1d6c:	cf 93       	push	r28
    1d6e:	df 93       	push	r29
    1d70:	cd b7       	in	r28, 0x3d	; 61
    1d72:	de b7       	in	r29, 0x3e	; 62
    1d74:	28 97       	sbiw	r28, 0x08	; 8
    1d76:	0f b6       	in	r0, 0x3f	; 63
    1d78:	f8 94       	cli
    1d7a:	de bf       	out	0x3e, r29	; 62
    1d7c:	0f be       	out	0x3f, r0	; 63
    1d7e:	cd bf       	out	0x3d, r28	; 61
    1d80:	9c 83       	std	Y+4, r25	; 0x04
    1d82:	8b 83       	std	Y+3, r24	; 0x03
    1d84:	7e 83       	std	Y+6, r23	; 0x06
    1d86:	6d 83       	std	Y+5, r22	; 0x05
    1d88:	58 87       	std	Y+8, r21	; 0x08
    1d8a:	4f 83       	std	Y+7, r20	; 0x07
unsigned portBASE_TYPE uxSavedInterruptStatus;

	configASSERT( pxQueue );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1d8c:	1a 82       	std	Y+2, r1	; 0x02
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1d8e:	8b 81       	ldd	r24, Y+3	; 0x03
    1d90:	9c 81       	ldd	r25, Y+4	; 0x04
    1d92:	fc 01       	movw	r30, r24
    1d94:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d96:	88 23       	and	r24, r24
    1d98:	d9 f1       	breq	.+118    	; 0x1e10 <xQueueReceiveFromISR+0xa4>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1d9a:	2d 81       	ldd	r18, Y+5	; 0x05
    1d9c:	3e 81       	ldd	r19, Y+6	; 0x06
    1d9e:	8b 81       	ldd	r24, Y+3	; 0x03
    1da0:	9c 81       	ldd	r25, Y+4	; 0x04
    1da2:	b9 01       	movw	r22, r18
    1da4:	0e 94 14 10 	call	0x2028	; 0x2028 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1da8:	8b 81       	ldd	r24, Y+3	; 0x03
    1daa:	9c 81       	ldd	r25, Y+4	; 0x04
    1dac:	fc 01       	movw	r30, r24
    1dae:	82 8d       	ldd	r24, Z+26	; 0x1a
    1db0:	2f ef       	ldi	r18, 0xFF	; 255
    1db2:	28 0f       	add	r18, r24
    1db4:	8b 81       	ldd	r24, Y+3	; 0x03
    1db6:	9c 81       	ldd	r25, Y+4	; 0x04
    1db8:	fc 01       	movw	r30, r24
    1dba:	22 8f       	std	Z+26, r18	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1dbc:	8b 81       	ldd	r24, Y+3	; 0x03
    1dbe:	9c 81       	ldd	r25, Y+4	; 0x04
    1dc0:	fc 01       	movw	r30, r24
    1dc2:	85 8d       	ldd	r24, Z+29	; 0x1d
    1dc4:	8f 3f       	cpi	r24, 0xFF	; 255
    1dc6:	b9 f4       	brne	.+46     	; 0x1df6 <xQueueReceiveFromISR+0x8a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1dc8:	8b 81       	ldd	r24, Y+3	; 0x03
    1dca:	9c 81       	ldd	r25, Y+4	; 0x04
    1dcc:	fc 01       	movw	r30, r24
    1dce:	80 85       	ldd	r24, Z+8	; 0x08
    1dd0:	88 23       	and	r24, r24
    1dd2:	d9 f0       	breq	.+54     	; 0x1e0a <xQueueReceiveFromISR+0x9e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1dd4:	8b 81       	ldd	r24, Y+3	; 0x03
    1dd6:	9c 81       	ldd	r25, Y+4	; 0x04
    1dd8:	08 96       	adiw	r24, 0x08	; 8
    1dda:	0e 94 e5 07 	call	0xfca	; 0xfca <xTaskRemoveFromEventList>
    1dde:	88 23       	and	r24, r24
    1de0:	a1 f0       	breq	.+40     	; 0x1e0a <xQueueReceiveFromISR+0x9e>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1de2:	8f 81       	ldd	r24, Y+7	; 0x07
    1de4:	98 85       	ldd	r25, Y+8	; 0x08
    1de6:	00 97       	sbiw	r24, 0x00	; 0
    1de8:	81 f0       	breq	.+32     	; 0x1e0a <xQueueReceiveFromISR+0x9e>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1dea:	8f 81       	ldd	r24, Y+7	; 0x07
    1dec:	98 85       	ldd	r25, Y+8	; 0x08
    1dee:	21 e0       	ldi	r18, 0x01	; 1
    1df0:	fc 01       	movw	r30, r24
    1df2:	20 83       	st	Z, r18
    1df4:	0a c0       	rjmp	.+20     	; 0x1e0a <xQueueReceiveFromISR+0x9e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1df6:	8b 81       	ldd	r24, Y+3	; 0x03
    1df8:	9c 81       	ldd	r25, Y+4	; 0x04
    1dfa:	fc 01       	movw	r30, r24
    1dfc:	85 8d       	ldd	r24, Z+29	; 0x1d
    1dfe:	21 e0       	ldi	r18, 0x01	; 1
    1e00:	28 0f       	add	r18, r24
    1e02:	8b 81       	ldd	r24, Y+3	; 0x03
    1e04:	9c 81       	ldd	r25, Y+4	; 0x04
    1e06:	fc 01       	movw	r30, r24
    1e08:	25 8f       	std	Z+29, r18	; 0x1d
			}

			xReturn = pdPASS;
    1e0a:	81 e0       	ldi	r24, 0x01	; 1
    1e0c:	89 83       	std	Y+1, r24	; 0x01
    1e0e:	01 c0       	rjmp	.+2      	; 0x1e12 <xQueueReceiveFromISR+0xa6>
		}
		else
		{
			xReturn = pdFAIL;
    1e10:	19 82       	std	Y+1, r1	; 0x01
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1e12:	89 81       	ldd	r24, Y+1	; 0x01
}
    1e14:	28 96       	adiw	r28, 0x08	; 8
    1e16:	0f b6       	in	r0, 0x3f	; 63
    1e18:	f8 94       	cli
    1e1a:	de bf       	out	0x3e, r29	; 62
    1e1c:	0f be       	out	0x3f, r0	; 63
    1e1e:	cd bf       	out	0x3d, r28	; 61
    1e20:	df 91       	pop	r29
    1e22:	cf 91       	pop	r28
    1e24:	08 95       	ret

00001e26 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    1e26:	cf 93       	push	r28
    1e28:	df 93       	push	r29
    1e2a:	00 d0       	rcall	.+0      	; 0x1e2c <uxQueueMessagesWaiting+0x6>
    1e2c:	cd b7       	in	r28, 0x3d	; 61
    1e2e:	de b7       	in	r29, 0x3e	; 62
    1e30:	9b 83       	std	Y+3, r25	; 0x03
    1e32:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1e34:	0f b6       	in	r0, 0x3f	; 63
    1e36:	f8 94       	cli
    1e38:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1e3a:	8a 81       	ldd	r24, Y+2	; 0x02
    1e3c:	9b 81       	ldd	r25, Y+3	; 0x03
    1e3e:	fc 01       	movw	r30, r24
    1e40:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e42:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1e44:	0f 90       	pop	r0
    1e46:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1e48:	89 81       	ldd	r24, Y+1	; 0x01
}
    1e4a:	0f 90       	pop	r0
    1e4c:	0f 90       	pop	r0
    1e4e:	0f 90       	pop	r0
    1e50:	df 91       	pop	r29
    1e52:	cf 91       	pop	r28
    1e54:	08 95       	ret

00001e56 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    1e56:	cf 93       	push	r28
    1e58:	df 93       	push	r29
    1e5a:	00 d0       	rcall	.+0      	; 0x1e5c <uxQueueMessagesWaitingFromISR+0x6>
    1e5c:	cd b7       	in	r28, 0x3d	; 61
    1e5e:	de b7       	in	r29, 0x3e	; 62
    1e60:	9b 83       	std	Y+3, r25	; 0x03
    1e62:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    1e64:	8a 81       	ldd	r24, Y+2	; 0x02
    1e66:	9b 81       	ldd	r25, Y+3	; 0x03
    1e68:	fc 01       	movw	r30, r24
    1e6a:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e6c:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    1e6e:	89 81       	ldd	r24, Y+1	; 0x01
}
    1e70:	0f 90       	pop	r0
    1e72:	0f 90       	pop	r0
    1e74:	0f 90       	pop	r0
    1e76:	df 91       	pop	r29
    1e78:	cf 91       	pop	r28
    1e7a:	08 95       	ret

00001e7c <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    1e7c:	cf 93       	push	r28
    1e7e:	df 93       	push	r29
    1e80:	1f 92       	push	r1
    1e82:	1f 92       	push	r1
    1e84:	cd b7       	in	r28, 0x3d	; 61
    1e86:	de b7       	in	r29, 0x3e	; 62
    1e88:	9a 83       	std	Y+2, r25	; 0x02
    1e8a:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    1e8c:	89 81       	ldd	r24, Y+1	; 0x01
    1e8e:	9a 81       	ldd	r25, Y+2	; 0x02
    1e90:	fc 01       	movw	r30, r24
    1e92:	80 81       	ld	r24, Z
    1e94:	91 81       	ldd	r25, Z+1	; 0x01
    1e96:	0e 94 e5 15 	call	0x2bca	; 0x2bca <vPortFree>
	vPortFree( pxQueue );
    1e9a:	89 81       	ldd	r24, Y+1	; 0x01
    1e9c:	9a 81       	ldd	r25, Y+2	; 0x02
    1e9e:	0e 94 e5 15 	call	0x2bca	; 0x2bca <vPortFree>
}
    1ea2:	0f 90       	pop	r0
    1ea4:	0f 90       	pop	r0
    1ea6:	df 91       	pop	r29
    1ea8:	cf 91       	pop	r28
    1eaa:	08 95       	ret

00001eac <prvCopyDataToQueue>:

#endif
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    1eac:	cf 93       	push	r28
    1eae:	df 93       	push	r29
    1eb0:	00 d0       	rcall	.+0      	; 0x1eb2 <prvCopyDataToQueue+0x6>
    1eb2:	1f 92       	push	r1
    1eb4:	1f 92       	push	r1
    1eb6:	cd b7       	in	r28, 0x3d	; 61
    1eb8:	de b7       	in	r29, 0x3e	; 62
    1eba:	9a 83       	std	Y+2, r25	; 0x02
    1ebc:	89 83       	std	Y+1, r24	; 0x01
    1ebe:	7c 83       	std	Y+4, r23	; 0x04
    1ec0:	6b 83       	std	Y+3, r22	; 0x03
    1ec2:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    1ec4:	89 81       	ldd	r24, Y+1	; 0x01
    1ec6:	9a 81       	ldd	r25, Y+2	; 0x02
    1ec8:	fc 01       	movw	r30, r24
    1eca:	84 8d       	ldd	r24, Z+28	; 0x1c
    1ecc:	88 23       	and	r24, r24
    1ece:	a9 f4       	brne	.+42     	; 0x1efa <prvCopyDataToQueue+0x4e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1ed0:	89 81       	ldd	r24, Y+1	; 0x01
    1ed2:	9a 81       	ldd	r25, Y+2	; 0x02
    1ed4:	fc 01       	movw	r30, r24
    1ed6:	80 81       	ld	r24, Z
    1ed8:	91 81       	ldd	r25, Z+1	; 0x01
    1eda:	00 97       	sbiw	r24, 0x00	; 0
    1edc:	09 f0       	breq	.+2      	; 0x1ee0 <prvCopyDataToQueue+0x34>
    1ede:	92 c0       	rjmp	.+292    	; 0x2004 <prvCopyDataToQueue+0x158>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    1ee0:	89 81       	ldd	r24, Y+1	; 0x01
    1ee2:	9a 81       	ldd	r25, Y+2	; 0x02
    1ee4:	fc 01       	movw	r30, r24
    1ee6:	82 81       	ldd	r24, Z+2	; 0x02
    1ee8:	93 81       	ldd	r25, Z+3	; 0x03
    1eea:	0e 94 25 0b 	call	0x164a	; 0x164a <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    1eee:	89 81       	ldd	r24, Y+1	; 0x01
    1ef0:	9a 81       	ldd	r25, Y+2	; 0x02
    1ef2:	fc 01       	movw	r30, r24
    1ef4:	13 82       	std	Z+3, r1	; 0x03
    1ef6:	12 82       	std	Z+2, r1	; 0x02
    1ef8:	85 c0       	rjmp	.+266    	; 0x2004 <prvCopyDataToQueue+0x158>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    1efa:	8d 81       	ldd	r24, Y+5	; 0x05
    1efc:	88 23       	and	r24, r24
    1efe:	d9 f5       	brne	.+118    	; 0x1f76 <prvCopyDataToQueue+0xca>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1f00:	89 81       	ldd	r24, Y+1	; 0x01
    1f02:	9a 81       	ldd	r25, Y+2	; 0x02
    1f04:	fc 01       	movw	r30, r24
    1f06:	84 8d       	ldd	r24, Z+28	; 0x1c
    1f08:	48 2f       	mov	r20, r24
    1f0a:	50 e0       	ldi	r21, 0x00	; 0
    1f0c:	89 81       	ldd	r24, Y+1	; 0x01
    1f0e:	9a 81       	ldd	r25, Y+2	; 0x02
    1f10:	fc 01       	movw	r30, r24
    1f12:	84 81       	ldd	r24, Z+4	; 0x04
    1f14:	95 81       	ldd	r25, Z+5	; 0x05
    1f16:	2b 81       	ldd	r18, Y+3	; 0x03
    1f18:	3c 81       	ldd	r19, Y+4	; 0x04
    1f1a:	b9 01       	movw	r22, r18
    1f1c:	0e 94 77 1c 	call	0x38ee	; 0x38ee <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1f20:	89 81       	ldd	r24, Y+1	; 0x01
    1f22:	9a 81       	ldd	r25, Y+2	; 0x02
    1f24:	fc 01       	movw	r30, r24
    1f26:	24 81       	ldd	r18, Z+4	; 0x04
    1f28:	35 81       	ldd	r19, Z+5	; 0x05
    1f2a:	89 81       	ldd	r24, Y+1	; 0x01
    1f2c:	9a 81       	ldd	r25, Y+2	; 0x02
    1f2e:	fc 01       	movw	r30, r24
    1f30:	84 8d       	ldd	r24, Z+28	; 0x1c
    1f32:	88 2f       	mov	r24, r24
    1f34:	90 e0       	ldi	r25, 0x00	; 0
    1f36:	28 0f       	add	r18, r24
    1f38:	39 1f       	adc	r19, r25
    1f3a:	89 81       	ldd	r24, Y+1	; 0x01
    1f3c:	9a 81       	ldd	r25, Y+2	; 0x02
    1f3e:	fc 01       	movw	r30, r24
    1f40:	35 83       	std	Z+5, r19	; 0x05
    1f42:	24 83       	std	Z+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    1f44:	89 81       	ldd	r24, Y+1	; 0x01
    1f46:	9a 81       	ldd	r25, Y+2	; 0x02
    1f48:	fc 01       	movw	r30, r24
    1f4a:	24 81       	ldd	r18, Z+4	; 0x04
    1f4c:	35 81       	ldd	r19, Z+5	; 0x05
    1f4e:	89 81       	ldd	r24, Y+1	; 0x01
    1f50:	9a 81       	ldd	r25, Y+2	; 0x02
    1f52:	fc 01       	movw	r30, r24
    1f54:	82 81       	ldd	r24, Z+2	; 0x02
    1f56:	93 81       	ldd	r25, Z+3	; 0x03
    1f58:	28 17       	cp	r18, r24
    1f5a:	39 07       	cpc	r19, r25
    1f5c:	08 f4       	brcc	.+2      	; 0x1f60 <prvCopyDataToQueue+0xb4>
    1f5e:	52 c0       	rjmp	.+164    	; 0x2004 <prvCopyDataToQueue+0x158>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1f60:	89 81       	ldd	r24, Y+1	; 0x01
    1f62:	9a 81       	ldd	r25, Y+2	; 0x02
    1f64:	fc 01       	movw	r30, r24
    1f66:	20 81       	ld	r18, Z
    1f68:	31 81       	ldd	r19, Z+1	; 0x01
    1f6a:	89 81       	ldd	r24, Y+1	; 0x01
    1f6c:	9a 81       	ldd	r25, Y+2	; 0x02
    1f6e:	fc 01       	movw	r30, r24
    1f70:	35 83       	std	Z+5, r19	; 0x05
    1f72:	24 83       	std	Z+4, r18	; 0x04
    1f74:	47 c0       	rjmp	.+142    	; 0x2004 <prvCopyDataToQueue+0x158>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1f76:	89 81       	ldd	r24, Y+1	; 0x01
    1f78:	9a 81       	ldd	r25, Y+2	; 0x02
    1f7a:	fc 01       	movw	r30, r24
    1f7c:	84 8d       	ldd	r24, Z+28	; 0x1c
    1f7e:	48 2f       	mov	r20, r24
    1f80:	50 e0       	ldi	r21, 0x00	; 0
    1f82:	89 81       	ldd	r24, Y+1	; 0x01
    1f84:	9a 81       	ldd	r25, Y+2	; 0x02
    1f86:	fc 01       	movw	r30, r24
    1f88:	86 81       	ldd	r24, Z+6	; 0x06
    1f8a:	97 81       	ldd	r25, Z+7	; 0x07
    1f8c:	2b 81       	ldd	r18, Y+3	; 0x03
    1f8e:	3c 81       	ldd	r19, Y+4	; 0x04
    1f90:	b9 01       	movw	r22, r18
    1f92:	0e 94 77 1c 	call	0x38ee	; 0x38ee <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    1f96:	89 81       	ldd	r24, Y+1	; 0x01
    1f98:	9a 81       	ldd	r25, Y+2	; 0x02
    1f9a:	fc 01       	movw	r30, r24
    1f9c:	26 81       	ldd	r18, Z+6	; 0x06
    1f9e:	37 81       	ldd	r19, Z+7	; 0x07
    1fa0:	89 81       	ldd	r24, Y+1	; 0x01
    1fa2:	9a 81       	ldd	r25, Y+2	; 0x02
    1fa4:	fc 01       	movw	r30, r24
    1fa6:	84 8d       	ldd	r24, Z+28	; 0x1c
    1fa8:	88 2f       	mov	r24, r24
    1faa:	90 e0       	ldi	r25, 0x00	; 0
    1fac:	91 95       	neg	r25
    1fae:	81 95       	neg	r24
    1fb0:	91 09       	sbc	r25, r1
    1fb2:	28 0f       	add	r18, r24
    1fb4:	39 1f       	adc	r19, r25
    1fb6:	89 81       	ldd	r24, Y+1	; 0x01
    1fb8:	9a 81       	ldd	r25, Y+2	; 0x02
    1fba:	fc 01       	movw	r30, r24
    1fbc:	37 83       	std	Z+7, r19	; 0x07
    1fbe:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    1fc0:	89 81       	ldd	r24, Y+1	; 0x01
    1fc2:	9a 81       	ldd	r25, Y+2	; 0x02
    1fc4:	fc 01       	movw	r30, r24
    1fc6:	26 81       	ldd	r18, Z+6	; 0x06
    1fc8:	37 81       	ldd	r19, Z+7	; 0x07
    1fca:	89 81       	ldd	r24, Y+1	; 0x01
    1fcc:	9a 81       	ldd	r25, Y+2	; 0x02
    1fce:	fc 01       	movw	r30, r24
    1fd0:	80 81       	ld	r24, Z
    1fd2:	91 81       	ldd	r25, Z+1	; 0x01
    1fd4:	28 17       	cp	r18, r24
    1fd6:	39 07       	cpc	r19, r25
    1fd8:	a8 f4       	brcc	.+42     	; 0x2004 <prvCopyDataToQueue+0x158>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1fda:	89 81       	ldd	r24, Y+1	; 0x01
    1fdc:	9a 81       	ldd	r25, Y+2	; 0x02
    1fde:	fc 01       	movw	r30, r24
    1fe0:	22 81       	ldd	r18, Z+2	; 0x02
    1fe2:	33 81       	ldd	r19, Z+3	; 0x03
    1fe4:	89 81       	ldd	r24, Y+1	; 0x01
    1fe6:	9a 81       	ldd	r25, Y+2	; 0x02
    1fe8:	fc 01       	movw	r30, r24
    1fea:	84 8d       	ldd	r24, Z+28	; 0x1c
    1fec:	88 2f       	mov	r24, r24
    1fee:	90 e0       	ldi	r25, 0x00	; 0
    1ff0:	91 95       	neg	r25
    1ff2:	81 95       	neg	r24
    1ff4:	91 09       	sbc	r25, r1
    1ff6:	28 0f       	add	r18, r24
    1ff8:	39 1f       	adc	r19, r25
    1ffa:	89 81       	ldd	r24, Y+1	; 0x01
    1ffc:	9a 81       	ldd	r25, Y+2	; 0x02
    1ffe:	fc 01       	movw	r30, r24
    2000:	37 83       	std	Z+7, r19	; 0x07
    2002:	26 83       	std	Z+6, r18	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    2004:	89 81       	ldd	r24, Y+1	; 0x01
    2006:	9a 81       	ldd	r25, Y+2	; 0x02
    2008:	fc 01       	movw	r30, r24
    200a:	82 8d       	ldd	r24, Z+26	; 0x1a
    200c:	21 e0       	ldi	r18, 0x01	; 1
    200e:	28 0f       	add	r18, r24
    2010:	89 81       	ldd	r24, Y+1	; 0x01
    2012:	9a 81       	ldd	r25, Y+2	; 0x02
    2014:	fc 01       	movw	r30, r24
    2016:	22 8f       	std	Z+26, r18	; 0x1a
}
    2018:	0f 90       	pop	r0
    201a:	0f 90       	pop	r0
    201c:	0f 90       	pop	r0
    201e:	0f 90       	pop	r0
    2020:	0f 90       	pop	r0
    2022:	df 91       	pop	r29
    2024:	cf 91       	pop	r28
    2026:	08 95       	ret

00002028 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    2028:	cf 93       	push	r28
    202a:	df 93       	push	r29
    202c:	00 d0       	rcall	.+0      	; 0x202e <prvCopyDataFromQueue+0x6>
    202e:	1f 92       	push	r1
    2030:	cd b7       	in	r28, 0x3d	; 61
    2032:	de b7       	in	r29, 0x3e	; 62
    2034:	9a 83       	std	Y+2, r25	; 0x02
    2036:	89 83       	std	Y+1, r24	; 0x01
    2038:	7c 83       	std	Y+4, r23	; 0x04
    203a:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    203c:	89 81       	ldd	r24, Y+1	; 0x01
    203e:	9a 81       	ldd	r25, Y+2	; 0x02
    2040:	fc 01       	movw	r30, r24
    2042:	80 81       	ld	r24, Z
    2044:	91 81       	ldd	r25, Z+1	; 0x01
    2046:	00 97       	sbiw	r24, 0x00	; 0
    2048:	c9 f1       	breq	.+114    	; 0x20bc <prvCopyDataFromQueue+0x94>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    204a:	89 81       	ldd	r24, Y+1	; 0x01
    204c:	9a 81       	ldd	r25, Y+2	; 0x02
    204e:	fc 01       	movw	r30, r24
    2050:	26 81       	ldd	r18, Z+6	; 0x06
    2052:	37 81       	ldd	r19, Z+7	; 0x07
    2054:	89 81       	ldd	r24, Y+1	; 0x01
    2056:	9a 81       	ldd	r25, Y+2	; 0x02
    2058:	fc 01       	movw	r30, r24
    205a:	84 8d       	ldd	r24, Z+28	; 0x1c
    205c:	88 2f       	mov	r24, r24
    205e:	90 e0       	ldi	r25, 0x00	; 0
    2060:	28 0f       	add	r18, r24
    2062:	39 1f       	adc	r19, r25
    2064:	89 81       	ldd	r24, Y+1	; 0x01
    2066:	9a 81       	ldd	r25, Y+2	; 0x02
    2068:	fc 01       	movw	r30, r24
    206a:	37 83       	std	Z+7, r19	; 0x07
    206c:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    206e:	89 81       	ldd	r24, Y+1	; 0x01
    2070:	9a 81       	ldd	r25, Y+2	; 0x02
    2072:	fc 01       	movw	r30, r24
    2074:	26 81       	ldd	r18, Z+6	; 0x06
    2076:	37 81       	ldd	r19, Z+7	; 0x07
    2078:	89 81       	ldd	r24, Y+1	; 0x01
    207a:	9a 81       	ldd	r25, Y+2	; 0x02
    207c:	fc 01       	movw	r30, r24
    207e:	82 81       	ldd	r24, Z+2	; 0x02
    2080:	93 81       	ldd	r25, Z+3	; 0x03
    2082:	28 17       	cp	r18, r24
    2084:	39 07       	cpc	r19, r25
    2086:	50 f0       	brcs	.+20     	; 0x209c <prvCopyDataFromQueue+0x74>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    2088:	89 81       	ldd	r24, Y+1	; 0x01
    208a:	9a 81       	ldd	r25, Y+2	; 0x02
    208c:	fc 01       	movw	r30, r24
    208e:	20 81       	ld	r18, Z
    2090:	31 81       	ldd	r19, Z+1	; 0x01
    2092:	89 81       	ldd	r24, Y+1	; 0x01
    2094:	9a 81       	ldd	r25, Y+2	; 0x02
    2096:	fc 01       	movw	r30, r24
    2098:	37 83       	std	Z+7, r19	; 0x07
    209a:	26 83       	std	Z+6, r18	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    209c:	89 81       	ldd	r24, Y+1	; 0x01
    209e:	9a 81       	ldd	r25, Y+2	; 0x02
    20a0:	fc 01       	movw	r30, r24
    20a2:	84 8d       	ldd	r24, Z+28	; 0x1c
    20a4:	48 2f       	mov	r20, r24
    20a6:	50 e0       	ldi	r21, 0x00	; 0
    20a8:	89 81       	ldd	r24, Y+1	; 0x01
    20aa:	9a 81       	ldd	r25, Y+2	; 0x02
    20ac:	fc 01       	movw	r30, r24
    20ae:	26 81       	ldd	r18, Z+6	; 0x06
    20b0:	37 81       	ldd	r19, Z+7	; 0x07
    20b2:	8b 81       	ldd	r24, Y+3	; 0x03
    20b4:	9c 81       	ldd	r25, Y+4	; 0x04
    20b6:	b9 01       	movw	r22, r18
    20b8:	0e 94 77 1c 	call	0x38ee	; 0x38ee <memcpy>
	}
}
    20bc:	0f 90       	pop	r0
    20be:	0f 90       	pop	r0
    20c0:	0f 90       	pop	r0
    20c2:	0f 90       	pop	r0
    20c4:	df 91       	pop	r29
    20c6:	cf 91       	pop	r28
    20c8:	08 95       	ret

000020ca <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    20ca:	cf 93       	push	r28
    20cc:	df 93       	push	r29
    20ce:	1f 92       	push	r1
    20d0:	1f 92       	push	r1
    20d2:	cd b7       	in	r28, 0x3d	; 61
    20d4:	de b7       	in	r29, 0x3e	; 62
    20d6:	9a 83       	std	Y+2, r25	; 0x02
    20d8:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    20da:	0f b6       	in	r0, 0x3f	; 63
    20dc:	f8 94       	cli
    20de:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    20e0:	1b c0       	rjmp	.+54     	; 0x2118 <prvUnlockQueue+0x4e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    20e2:	89 81       	ldd	r24, Y+1	; 0x01
    20e4:	9a 81       	ldd	r25, Y+2	; 0x02
    20e6:	fc 01       	movw	r30, r24
    20e8:	81 89       	ldd	r24, Z+17	; 0x11
    20ea:	88 23       	and	r24, r24
    20ec:	a1 f0       	breq	.+40     	; 0x2116 <prvUnlockQueue+0x4c>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    20ee:	89 81       	ldd	r24, Y+1	; 0x01
    20f0:	9a 81       	ldd	r25, Y+2	; 0x02
    20f2:	41 96       	adiw	r24, 0x11	; 17
    20f4:	0e 94 e5 07 	call	0xfca	; 0xfca <xTaskRemoveFromEventList>
    20f8:	88 23       	and	r24, r24
    20fa:	11 f0       	breq	.+4      	; 0x2100 <prvUnlockQueue+0x36>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    20fc:	0e 94 da 08 	call	0x11b4	; 0x11b4 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    2100:	89 81       	ldd	r24, Y+1	; 0x01
    2102:	9a 81       	ldd	r25, Y+2	; 0x02
    2104:	fc 01       	movw	r30, r24
    2106:	86 8d       	ldd	r24, Z+30	; 0x1e
    2108:	2f ef       	ldi	r18, 0xFF	; 255
    210a:	28 0f       	add	r18, r24
    210c:	89 81       	ldd	r24, Y+1	; 0x01
    210e:	9a 81       	ldd	r25, Y+2	; 0x02
    2110:	fc 01       	movw	r30, r24
    2112:	26 8f       	std	Z+30, r18	; 0x1e
    2114:	01 c0       	rjmp	.+2      	; 0x2118 <prvUnlockQueue+0x4e>
			}
			else
			{
				break;
    2116:	06 c0       	rjmp	.+12     	; 0x2124 <prvUnlockQueue+0x5a>
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2118:	89 81       	ldd	r24, Y+1	; 0x01
    211a:	9a 81       	ldd	r25, Y+2	; 0x02
    211c:	fc 01       	movw	r30, r24
    211e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2120:	18 16       	cp	r1, r24
    2122:	fc f2       	brlt	.-66     	; 0x20e2 <prvUnlockQueue+0x18>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    2124:	89 81       	ldd	r24, Y+1	; 0x01
    2126:	9a 81       	ldd	r25, Y+2	; 0x02
    2128:	2f ef       	ldi	r18, 0xFF	; 255
    212a:	fc 01       	movw	r30, r24
    212c:	26 8f       	std	Z+30, r18	; 0x1e
	}
	taskEXIT_CRITICAL();
    212e:	0f 90       	pop	r0
    2130:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2132:	0f b6       	in	r0, 0x3f	; 63
    2134:	f8 94       	cli
    2136:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2138:	1b c0       	rjmp	.+54     	; 0x2170 <prvUnlockQueue+0xa6>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    213a:	89 81       	ldd	r24, Y+1	; 0x01
    213c:	9a 81       	ldd	r25, Y+2	; 0x02
    213e:	fc 01       	movw	r30, r24
    2140:	80 85       	ldd	r24, Z+8	; 0x08
    2142:	88 23       	and	r24, r24
    2144:	a1 f0       	breq	.+40     	; 0x216e <prvUnlockQueue+0xa4>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2146:	89 81       	ldd	r24, Y+1	; 0x01
    2148:	9a 81       	ldd	r25, Y+2	; 0x02
    214a:	08 96       	adiw	r24, 0x08	; 8
    214c:	0e 94 e5 07 	call	0xfca	; 0xfca <xTaskRemoveFromEventList>
    2150:	88 23       	and	r24, r24
    2152:	11 f0       	breq	.+4      	; 0x2158 <prvUnlockQueue+0x8e>
				{
					vTaskMissedYield();
    2154:	0e 94 da 08 	call	0x11b4	; 0x11b4 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    2158:	89 81       	ldd	r24, Y+1	; 0x01
    215a:	9a 81       	ldd	r25, Y+2	; 0x02
    215c:	fc 01       	movw	r30, r24
    215e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2160:	2f ef       	ldi	r18, 0xFF	; 255
    2162:	28 0f       	add	r18, r24
    2164:	89 81       	ldd	r24, Y+1	; 0x01
    2166:	9a 81       	ldd	r25, Y+2	; 0x02
    2168:	fc 01       	movw	r30, r24
    216a:	25 8f       	std	Z+29, r18	; 0x1d
    216c:	01 c0       	rjmp	.+2      	; 0x2170 <prvUnlockQueue+0xa6>
			}
			else
			{
				break;
    216e:	06 c0       	rjmp	.+12     	; 0x217c <prvUnlockQueue+0xb2>
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2170:	89 81       	ldd	r24, Y+1	; 0x01
    2172:	9a 81       	ldd	r25, Y+2	; 0x02
    2174:	fc 01       	movw	r30, r24
    2176:	85 8d       	ldd	r24, Z+29	; 0x1d
    2178:	18 16       	cp	r1, r24
    217a:	fc f2       	brlt	.-66     	; 0x213a <prvUnlockQueue+0x70>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    217c:	89 81       	ldd	r24, Y+1	; 0x01
    217e:	9a 81       	ldd	r25, Y+2	; 0x02
    2180:	2f ef       	ldi	r18, 0xFF	; 255
    2182:	fc 01       	movw	r30, r24
    2184:	25 8f       	std	Z+29, r18	; 0x1d
	}
	taskEXIT_CRITICAL();
    2186:	0f 90       	pop	r0
    2188:	0f be       	out	0x3f, r0	; 63
}
    218a:	0f 90       	pop	r0
    218c:	0f 90       	pop	r0
    218e:	df 91       	pop	r29
    2190:	cf 91       	pop	r28
    2192:	08 95       	ret

00002194 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    2194:	cf 93       	push	r28
    2196:	df 93       	push	r29
    2198:	00 d0       	rcall	.+0      	; 0x219a <prvIsQueueEmpty+0x6>
    219a:	cd b7       	in	r28, 0x3d	; 61
    219c:	de b7       	in	r29, 0x3e	; 62
    219e:	9b 83       	std	Y+3, r25	; 0x03
    21a0:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    21a2:	0f b6       	in	r0, 0x3f	; 63
    21a4:	f8 94       	cli
    21a6:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    21a8:	8a 81       	ldd	r24, Y+2	; 0x02
    21aa:	9b 81       	ldd	r25, Y+3	; 0x03
    21ac:	fc 01       	movw	r30, r24
    21ae:	92 8d       	ldd	r25, Z+26	; 0x1a
    21b0:	81 e0       	ldi	r24, 0x01	; 1
    21b2:	99 23       	and	r25, r25
    21b4:	09 f0       	breq	.+2      	; 0x21b8 <prvIsQueueEmpty+0x24>
    21b6:	80 e0       	ldi	r24, 0x00	; 0
    21b8:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    21ba:	0f 90       	pop	r0
    21bc:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    21be:	89 81       	ldd	r24, Y+1	; 0x01
}
    21c0:	0f 90       	pop	r0
    21c2:	0f 90       	pop	r0
    21c4:	0f 90       	pop	r0
    21c6:	df 91       	pop	r29
    21c8:	cf 91       	pop	r28
    21ca:	08 95       	ret

000021cc <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    21cc:	cf 93       	push	r28
    21ce:	df 93       	push	r29
    21d0:	00 d0       	rcall	.+0      	; 0x21d2 <xQueueIsQueueEmptyFromISR+0x6>
    21d2:	cd b7       	in	r28, 0x3d	; 61
    21d4:	de b7       	in	r29, 0x3e	; 62
    21d6:	9b 83       	std	Y+3, r25	; 0x03
    21d8:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    21da:	8a 81       	ldd	r24, Y+2	; 0x02
    21dc:	9b 81       	ldd	r25, Y+3	; 0x03
    21de:	fc 01       	movw	r30, r24
    21e0:	92 8d       	ldd	r25, Z+26	; 0x1a
    21e2:	81 e0       	ldi	r24, 0x01	; 1
    21e4:	99 23       	and	r25, r25
    21e6:	09 f0       	breq	.+2      	; 0x21ea <xQueueIsQueueEmptyFromISR+0x1e>
    21e8:	80 e0       	ldi	r24, 0x00	; 0
    21ea:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    21ec:	89 81       	ldd	r24, Y+1	; 0x01
}
    21ee:	0f 90       	pop	r0
    21f0:	0f 90       	pop	r0
    21f2:	0f 90       	pop	r0
    21f4:	df 91       	pop	r29
    21f6:	cf 91       	pop	r28
    21f8:	08 95       	ret

000021fa <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    21fa:	cf 93       	push	r28
    21fc:	df 93       	push	r29
    21fe:	00 d0       	rcall	.+0      	; 0x2200 <__stack+0x1>
    2200:	cd b7       	in	r28, 0x3d	; 61
    2202:	de b7       	in	r29, 0x3e	; 62
    2204:	9b 83       	std	Y+3, r25	; 0x03
    2206:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    2208:	0f b6       	in	r0, 0x3f	; 63
    220a:	f8 94       	cli
    220c:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    220e:	8a 81       	ldd	r24, Y+2	; 0x02
    2210:	9b 81       	ldd	r25, Y+3	; 0x03
    2212:	fc 01       	movw	r30, r24
    2214:	22 8d       	ldd	r18, Z+26	; 0x1a
    2216:	8a 81       	ldd	r24, Y+2	; 0x02
    2218:	9b 81       	ldd	r25, Y+3	; 0x03
    221a:	fc 01       	movw	r30, r24
    221c:	93 8d       	ldd	r25, Z+27	; 0x1b
    221e:	81 e0       	ldi	r24, 0x01	; 1
    2220:	29 17       	cp	r18, r25
    2222:	09 f0       	breq	.+2      	; 0x2226 <__stack+0x27>
    2224:	80 e0       	ldi	r24, 0x00	; 0
    2226:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    2228:	0f 90       	pop	r0
    222a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    222c:	89 81       	ldd	r24, Y+1	; 0x01
}
    222e:	0f 90       	pop	r0
    2230:	0f 90       	pop	r0
    2232:	0f 90       	pop	r0
    2234:	df 91       	pop	r29
    2236:	cf 91       	pop	r28
    2238:	08 95       	ret

0000223a <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    223a:	cf 93       	push	r28
    223c:	df 93       	push	r29
    223e:	00 d0       	rcall	.+0      	; 0x2240 <xQueueIsQueueFullFromISR+0x6>
    2240:	cd b7       	in	r28, 0x3d	; 61
    2242:	de b7       	in	r29, 0x3e	; 62
    2244:	9b 83       	std	Y+3, r25	; 0x03
    2246:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    2248:	8a 81       	ldd	r24, Y+2	; 0x02
    224a:	9b 81       	ldd	r25, Y+3	; 0x03
    224c:	fc 01       	movw	r30, r24
    224e:	22 8d       	ldd	r18, Z+26	; 0x1a
    2250:	8a 81       	ldd	r24, Y+2	; 0x02
    2252:	9b 81       	ldd	r25, Y+3	; 0x03
    2254:	fc 01       	movw	r30, r24
    2256:	93 8d       	ldd	r25, Z+27	; 0x1b
    2258:	81 e0       	ldi	r24, 0x01	; 1
    225a:	29 17       	cp	r18, r25
    225c:	09 f0       	breq	.+2      	; 0x2260 <xQueueIsQueueFullFromISR+0x26>
    225e:	80 e0       	ldi	r24, 0x00	; 0
    2260:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    2262:	89 81       	ldd	r24, Y+1	; 0x01
}
    2264:	0f 90       	pop	r0
    2266:	0f 90       	pop	r0
    2268:	0f 90       	pop	r0
    226a:	df 91       	pop	r29
    226c:	cf 91       	pop	r28
    226e:	08 95       	ret

00002270 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    2270:	cf 93       	push	r28
    2272:	df 93       	push	r29
    2274:	1f 92       	push	r1
    2276:	1f 92       	push	r1
    2278:	cd b7       	in	r28, 0x3d	; 61
    227a:	de b7       	in	r29, 0x3e	; 62
    227c:	9a 83       	std	Y+2, r25	; 0x02
    227e:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    2280:	89 81       	ldd	r24, Y+1	; 0x01
    2282:	9a 81       	ldd	r25, Y+2	; 0x02
    2284:	9c 01       	movw	r18, r24
    2286:	2d 5f       	subi	r18, 0xFD	; 253
    2288:	3f 4f       	sbci	r19, 0xFF	; 255
    228a:	89 81       	ldd	r24, Y+1	; 0x01
    228c:	9a 81       	ldd	r25, Y+2	; 0x02
    228e:	fc 01       	movw	r30, r24
    2290:	32 83       	std	Z+2, r19	; 0x02
    2292:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2294:	89 81       	ldd	r24, Y+1	; 0x01
    2296:	9a 81       	ldd	r25, Y+2	; 0x02
    2298:	2f ef       	ldi	r18, 0xFF	; 255
    229a:	3f ef       	ldi	r19, 0xFF	; 255
    229c:	fc 01       	movw	r30, r24
    229e:	34 83       	std	Z+4, r19	; 0x04
    22a0:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    22a2:	89 81       	ldd	r24, Y+1	; 0x01
    22a4:	9a 81       	ldd	r25, Y+2	; 0x02
    22a6:	9c 01       	movw	r18, r24
    22a8:	2d 5f       	subi	r18, 0xFD	; 253
    22aa:	3f 4f       	sbci	r19, 0xFF	; 255
    22ac:	89 81       	ldd	r24, Y+1	; 0x01
    22ae:	9a 81       	ldd	r25, Y+2	; 0x02
    22b0:	fc 01       	movw	r30, r24
    22b2:	36 83       	std	Z+6, r19	; 0x06
    22b4:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    22b6:	89 81       	ldd	r24, Y+1	; 0x01
    22b8:	9a 81       	ldd	r25, Y+2	; 0x02
    22ba:	9c 01       	movw	r18, r24
    22bc:	2d 5f       	subi	r18, 0xFD	; 253
    22be:	3f 4f       	sbci	r19, 0xFF	; 255
    22c0:	89 81       	ldd	r24, Y+1	; 0x01
    22c2:	9a 81       	ldd	r25, Y+2	; 0x02
    22c4:	fc 01       	movw	r30, r24
    22c6:	30 87       	std	Z+8, r19	; 0x08
    22c8:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    22ca:	89 81       	ldd	r24, Y+1	; 0x01
    22cc:	9a 81       	ldd	r25, Y+2	; 0x02
    22ce:	fc 01       	movw	r30, r24
    22d0:	10 82       	st	Z, r1
}
    22d2:	0f 90       	pop	r0
    22d4:	0f 90       	pop	r0
    22d6:	df 91       	pop	r29
    22d8:	cf 91       	pop	r28
    22da:	08 95       	ret

000022dc <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    22dc:	cf 93       	push	r28
    22de:	df 93       	push	r29
    22e0:	1f 92       	push	r1
    22e2:	1f 92       	push	r1
    22e4:	cd b7       	in	r28, 0x3d	; 61
    22e6:	de b7       	in	r29, 0x3e	; 62
    22e8:	9a 83       	std	Y+2, r25	; 0x02
    22ea:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    22ec:	89 81       	ldd	r24, Y+1	; 0x01
    22ee:	9a 81       	ldd	r25, Y+2	; 0x02
    22f0:	fc 01       	movw	r30, r24
    22f2:	11 86       	std	Z+9, r1	; 0x09
    22f4:	10 86       	std	Z+8, r1	; 0x08
}
    22f6:	0f 90       	pop	r0
    22f8:	0f 90       	pop	r0
    22fa:	df 91       	pop	r29
    22fc:	cf 91       	pop	r28
    22fe:	08 95       	ret

00002300 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    2300:	cf 93       	push	r28
    2302:	df 93       	push	r29
    2304:	00 d0       	rcall	.+0      	; 0x2306 <vListInsertEnd+0x6>
    2306:	00 d0       	rcall	.+0      	; 0x2308 <vListInsertEnd+0x8>
    2308:	cd b7       	in	r28, 0x3d	; 61
    230a:	de b7       	in	r29, 0x3e	; 62
    230c:	9c 83       	std	Y+4, r25	; 0x04
    230e:	8b 83       	std	Y+3, r24	; 0x03
    2310:	7e 83       	std	Y+6, r23	; 0x06
    2312:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    2314:	8b 81       	ldd	r24, Y+3	; 0x03
    2316:	9c 81       	ldd	r25, Y+4	; 0x04
    2318:	fc 01       	movw	r30, r24
    231a:	81 81       	ldd	r24, Z+1	; 0x01
    231c:	92 81       	ldd	r25, Z+2	; 0x02
    231e:	9a 83       	std	Y+2, r25	; 0x02
    2320:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    2322:	89 81       	ldd	r24, Y+1	; 0x01
    2324:	9a 81       	ldd	r25, Y+2	; 0x02
    2326:	fc 01       	movw	r30, r24
    2328:	22 81       	ldd	r18, Z+2	; 0x02
    232a:	33 81       	ldd	r19, Z+3	; 0x03
    232c:	8d 81       	ldd	r24, Y+5	; 0x05
    232e:	9e 81       	ldd	r25, Y+6	; 0x06
    2330:	fc 01       	movw	r30, r24
    2332:	33 83       	std	Z+3, r19	; 0x03
    2334:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    2336:	8b 81       	ldd	r24, Y+3	; 0x03
    2338:	9c 81       	ldd	r25, Y+4	; 0x04
    233a:	fc 01       	movw	r30, r24
    233c:	21 81       	ldd	r18, Z+1	; 0x01
    233e:	32 81       	ldd	r19, Z+2	; 0x02
    2340:	8d 81       	ldd	r24, Y+5	; 0x05
    2342:	9e 81       	ldd	r25, Y+6	; 0x06
    2344:	fc 01       	movw	r30, r24
    2346:	35 83       	std	Z+5, r19	; 0x05
    2348:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    234a:	89 81       	ldd	r24, Y+1	; 0x01
    234c:	9a 81       	ldd	r25, Y+2	; 0x02
    234e:	fc 01       	movw	r30, r24
    2350:	82 81       	ldd	r24, Z+2	; 0x02
    2352:	93 81       	ldd	r25, Z+3	; 0x03
    2354:	2d 81       	ldd	r18, Y+5	; 0x05
    2356:	3e 81       	ldd	r19, Y+6	; 0x06
    2358:	fc 01       	movw	r30, r24
    235a:	35 83       	std	Z+5, r19	; 0x05
    235c:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    235e:	89 81       	ldd	r24, Y+1	; 0x01
    2360:	9a 81       	ldd	r25, Y+2	; 0x02
    2362:	2d 81       	ldd	r18, Y+5	; 0x05
    2364:	3e 81       	ldd	r19, Y+6	; 0x06
    2366:	fc 01       	movw	r30, r24
    2368:	33 83       	std	Z+3, r19	; 0x03
    236a:	22 83       	std	Z+2, r18	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    236c:	8b 81       	ldd	r24, Y+3	; 0x03
    236e:	9c 81       	ldd	r25, Y+4	; 0x04
    2370:	2d 81       	ldd	r18, Y+5	; 0x05
    2372:	3e 81       	ldd	r19, Y+6	; 0x06
    2374:	fc 01       	movw	r30, r24
    2376:	32 83       	std	Z+2, r19	; 0x02
    2378:	21 83       	std	Z+1, r18	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    237a:	8d 81       	ldd	r24, Y+5	; 0x05
    237c:	9e 81       	ldd	r25, Y+6	; 0x06
    237e:	2b 81       	ldd	r18, Y+3	; 0x03
    2380:	3c 81       	ldd	r19, Y+4	; 0x04
    2382:	fc 01       	movw	r30, r24
    2384:	31 87       	std	Z+9, r19	; 0x09
    2386:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    2388:	8b 81       	ldd	r24, Y+3	; 0x03
    238a:	9c 81       	ldd	r25, Y+4	; 0x04
    238c:	fc 01       	movw	r30, r24
    238e:	80 81       	ld	r24, Z
    2390:	21 e0       	ldi	r18, 0x01	; 1
    2392:	28 0f       	add	r18, r24
    2394:	8b 81       	ldd	r24, Y+3	; 0x03
    2396:	9c 81       	ldd	r25, Y+4	; 0x04
    2398:	fc 01       	movw	r30, r24
    239a:	20 83       	st	Z, r18
}
    239c:	26 96       	adiw	r28, 0x06	; 6
    239e:	0f b6       	in	r0, 0x3f	; 63
    23a0:	f8 94       	cli
    23a2:	de bf       	out	0x3e, r29	; 62
    23a4:	0f be       	out	0x3f, r0	; 63
    23a6:	cd bf       	out	0x3d, r28	; 61
    23a8:	df 91       	pop	r29
    23aa:	cf 91       	pop	r28
    23ac:	08 95       	ret

000023ae <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    23ae:	cf 93       	push	r28
    23b0:	df 93       	push	r29
    23b2:	cd b7       	in	r28, 0x3d	; 61
    23b4:	de b7       	in	r29, 0x3e	; 62
    23b6:	28 97       	sbiw	r28, 0x08	; 8
    23b8:	0f b6       	in	r0, 0x3f	; 63
    23ba:	f8 94       	cli
    23bc:	de bf       	out	0x3e, r29	; 62
    23be:	0f be       	out	0x3f, r0	; 63
    23c0:	cd bf       	out	0x3d, r28	; 61
    23c2:	9e 83       	std	Y+6, r25	; 0x06
    23c4:	8d 83       	std	Y+5, r24	; 0x05
    23c6:	78 87       	std	Y+8, r23	; 0x08
    23c8:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    23ca:	8f 81       	ldd	r24, Y+7	; 0x07
    23cc:	98 85       	ldd	r25, Y+8	; 0x08
    23ce:	fc 01       	movw	r30, r24
    23d0:	80 81       	ld	r24, Z
    23d2:	91 81       	ldd	r25, Z+1	; 0x01
    23d4:	9c 83       	std	Y+4, r25	; 0x04
    23d6:	8b 83       	std	Y+3, r24	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    23d8:	8b 81       	ldd	r24, Y+3	; 0x03
    23da:	9c 81       	ldd	r25, Y+4	; 0x04
    23dc:	8f 3f       	cpi	r24, 0xFF	; 255
    23de:	ff ef       	ldi	r31, 0xFF	; 255
    23e0:	9f 07       	cpc	r25, r31
    23e2:	41 f4       	brne	.+16     	; 0x23f4 <vListInsert+0x46>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    23e4:	8d 81       	ldd	r24, Y+5	; 0x05
    23e6:	9e 81       	ldd	r25, Y+6	; 0x06
    23e8:	fc 01       	movw	r30, r24
    23ea:	87 81       	ldd	r24, Z+7	; 0x07
    23ec:	90 85       	ldd	r25, Z+8	; 0x08
    23ee:	9a 83       	std	Y+2, r25	; 0x02
    23f0:	89 83       	std	Y+1, r24	; 0x01
    23f2:	1a c0       	rjmp	.+52     	; 0x2428 <vListInsert+0x7a>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    23f4:	8d 81       	ldd	r24, Y+5	; 0x05
    23f6:	9e 81       	ldd	r25, Y+6	; 0x06
    23f8:	03 96       	adiw	r24, 0x03	; 3
    23fa:	9a 83       	std	Y+2, r25	; 0x02
    23fc:	89 83       	std	Y+1, r24	; 0x01
    23fe:	07 c0       	rjmp	.+14     	; 0x240e <vListInsert+0x60>
    2400:	89 81       	ldd	r24, Y+1	; 0x01
    2402:	9a 81       	ldd	r25, Y+2	; 0x02
    2404:	fc 01       	movw	r30, r24
    2406:	82 81       	ldd	r24, Z+2	; 0x02
    2408:	93 81       	ldd	r25, Z+3	; 0x03
    240a:	9a 83       	std	Y+2, r25	; 0x02
    240c:	89 83       	std	Y+1, r24	; 0x01
    240e:	89 81       	ldd	r24, Y+1	; 0x01
    2410:	9a 81       	ldd	r25, Y+2	; 0x02
    2412:	fc 01       	movw	r30, r24
    2414:	82 81       	ldd	r24, Z+2	; 0x02
    2416:	93 81       	ldd	r25, Z+3	; 0x03
    2418:	fc 01       	movw	r30, r24
    241a:	20 81       	ld	r18, Z
    241c:	31 81       	ldd	r19, Z+1	; 0x01
    241e:	8b 81       	ldd	r24, Y+3	; 0x03
    2420:	9c 81       	ldd	r25, Y+4	; 0x04
    2422:	82 17       	cp	r24, r18
    2424:	93 07       	cpc	r25, r19
    2426:	60 f7       	brcc	.-40     	; 0x2400 <vListInsert+0x52>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2428:	89 81       	ldd	r24, Y+1	; 0x01
    242a:	9a 81       	ldd	r25, Y+2	; 0x02
    242c:	fc 01       	movw	r30, r24
    242e:	22 81       	ldd	r18, Z+2	; 0x02
    2430:	33 81       	ldd	r19, Z+3	; 0x03
    2432:	8f 81       	ldd	r24, Y+7	; 0x07
    2434:	98 85       	ldd	r25, Y+8	; 0x08
    2436:	fc 01       	movw	r30, r24
    2438:	33 83       	std	Z+3, r19	; 0x03
    243a:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    243c:	8f 81       	ldd	r24, Y+7	; 0x07
    243e:	98 85       	ldd	r25, Y+8	; 0x08
    2440:	fc 01       	movw	r30, r24
    2442:	82 81       	ldd	r24, Z+2	; 0x02
    2444:	93 81       	ldd	r25, Z+3	; 0x03
    2446:	2f 81       	ldd	r18, Y+7	; 0x07
    2448:	38 85       	ldd	r19, Y+8	; 0x08
    244a:	fc 01       	movw	r30, r24
    244c:	35 83       	std	Z+5, r19	; 0x05
    244e:	24 83       	std	Z+4, r18	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    2450:	8f 81       	ldd	r24, Y+7	; 0x07
    2452:	98 85       	ldd	r25, Y+8	; 0x08
    2454:	29 81       	ldd	r18, Y+1	; 0x01
    2456:	3a 81       	ldd	r19, Y+2	; 0x02
    2458:	fc 01       	movw	r30, r24
    245a:	35 83       	std	Z+5, r19	; 0x05
    245c:	24 83       	std	Z+4, r18	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    245e:	89 81       	ldd	r24, Y+1	; 0x01
    2460:	9a 81       	ldd	r25, Y+2	; 0x02
    2462:	2f 81       	ldd	r18, Y+7	; 0x07
    2464:	38 85       	ldd	r19, Y+8	; 0x08
    2466:	fc 01       	movw	r30, r24
    2468:	33 83       	std	Z+3, r19	; 0x03
    246a:	22 83       	std	Z+2, r18	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    246c:	8f 81       	ldd	r24, Y+7	; 0x07
    246e:	98 85       	ldd	r25, Y+8	; 0x08
    2470:	2d 81       	ldd	r18, Y+5	; 0x05
    2472:	3e 81       	ldd	r19, Y+6	; 0x06
    2474:	fc 01       	movw	r30, r24
    2476:	31 87       	std	Z+9, r19	; 0x09
    2478:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    247a:	8d 81       	ldd	r24, Y+5	; 0x05
    247c:	9e 81       	ldd	r25, Y+6	; 0x06
    247e:	fc 01       	movw	r30, r24
    2480:	80 81       	ld	r24, Z
    2482:	21 e0       	ldi	r18, 0x01	; 1
    2484:	28 0f       	add	r18, r24
    2486:	8d 81       	ldd	r24, Y+5	; 0x05
    2488:	9e 81       	ldd	r25, Y+6	; 0x06
    248a:	fc 01       	movw	r30, r24
    248c:	20 83       	st	Z, r18
}
    248e:	28 96       	adiw	r28, 0x08	; 8
    2490:	0f b6       	in	r0, 0x3f	; 63
    2492:	f8 94       	cli
    2494:	de bf       	out	0x3e, r29	; 62
    2496:	0f be       	out	0x3f, r0	; 63
    2498:	cd bf       	out	0x3d, r28	; 61
    249a:	df 91       	pop	r29
    249c:	cf 91       	pop	r28
    249e:	08 95       	ret

000024a0 <uxListRemove>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
{
    24a0:	cf 93       	push	r28
    24a2:	df 93       	push	r29
    24a4:	00 d0       	rcall	.+0      	; 0x24a6 <uxListRemove+0x6>
    24a6:	1f 92       	push	r1
    24a8:	cd b7       	in	r28, 0x3d	; 61
    24aa:	de b7       	in	r29, 0x3e	; 62
    24ac:	9c 83       	std	Y+4, r25	; 0x04
    24ae:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    24b0:	8b 81       	ldd	r24, Y+3	; 0x03
    24b2:	9c 81       	ldd	r25, Y+4	; 0x04
    24b4:	fc 01       	movw	r30, r24
    24b6:	82 81       	ldd	r24, Z+2	; 0x02
    24b8:	93 81       	ldd	r25, Z+3	; 0x03
    24ba:	2b 81       	ldd	r18, Y+3	; 0x03
    24bc:	3c 81       	ldd	r19, Y+4	; 0x04
    24be:	f9 01       	movw	r30, r18
    24c0:	24 81       	ldd	r18, Z+4	; 0x04
    24c2:	35 81       	ldd	r19, Z+5	; 0x05
    24c4:	fc 01       	movw	r30, r24
    24c6:	35 83       	std	Z+5, r19	; 0x05
    24c8:	24 83       	std	Z+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    24ca:	8b 81       	ldd	r24, Y+3	; 0x03
    24cc:	9c 81       	ldd	r25, Y+4	; 0x04
    24ce:	fc 01       	movw	r30, r24
    24d0:	84 81       	ldd	r24, Z+4	; 0x04
    24d2:	95 81       	ldd	r25, Z+5	; 0x05
    24d4:	2b 81       	ldd	r18, Y+3	; 0x03
    24d6:	3c 81       	ldd	r19, Y+4	; 0x04
    24d8:	f9 01       	movw	r30, r18
    24da:	22 81       	ldd	r18, Z+2	; 0x02
    24dc:	33 81       	ldd	r19, Z+3	; 0x03
    24de:	fc 01       	movw	r30, r24
    24e0:	33 83       	std	Z+3, r19	; 0x03
    24e2:	22 83       	std	Z+2, r18	; 0x02

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    24e4:	8b 81       	ldd	r24, Y+3	; 0x03
    24e6:	9c 81       	ldd	r25, Y+4	; 0x04
    24e8:	fc 01       	movw	r30, r24
    24ea:	80 85       	ldd	r24, Z+8	; 0x08
    24ec:	91 85       	ldd	r25, Z+9	; 0x09
    24ee:	9a 83       	std	Y+2, r25	; 0x02
    24f0:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    24f2:	89 81       	ldd	r24, Y+1	; 0x01
    24f4:	9a 81       	ldd	r25, Y+2	; 0x02
    24f6:	fc 01       	movw	r30, r24
    24f8:	21 81       	ldd	r18, Z+1	; 0x01
    24fa:	32 81       	ldd	r19, Z+2	; 0x02
    24fc:	8b 81       	ldd	r24, Y+3	; 0x03
    24fe:	9c 81       	ldd	r25, Y+4	; 0x04
    2500:	28 17       	cp	r18, r24
    2502:	39 07       	cpc	r19, r25
    2504:	51 f4       	brne	.+20     	; 0x251a <uxListRemove+0x7a>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2506:	8b 81       	ldd	r24, Y+3	; 0x03
    2508:	9c 81       	ldd	r25, Y+4	; 0x04
    250a:	fc 01       	movw	r30, r24
    250c:	24 81       	ldd	r18, Z+4	; 0x04
    250e:	35 81       	ldd	r19, Z+5	; 0x05
    2510:	89 81       	ldd	r24, Y+1	; 0x01
    2512:	9a 81       	ldd	r25, Y+2	; 0x02
    2514:	fc 01       	movw	r30, r24
    2516:	32 83       	std	Z+2, r19	; 0x02
    2518:	21 83       	std	Z+1, r18	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    251a:	8b 81       	ldd	r24, Y+3	; 0x03
    251c:	9c 81       	ldd	r25, Y+4	; 0x04
    251e:	fc 01       	movw	r30, r24
    2520:	11 86       	std	Z+9, r1	; 0x09
    2522:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    2524:	89 81       	ldd	r24, Y+1	; 0x01
    2526:	9a 81       	ldd	r25, Y+2	; 0x02
    2528:	fc 01       	movw	r30, r24
    252a:	80 81       	ld	r24, Z
    252c:	2f ef       	ldi	r18, 0xFF	; 255
    252e:	28 0f       	add	r18, r24
    2530:	89 81       	ldd	r24, Y+1	; 0x01
    2532:	9a 81       	ldd	r25, Y+2	; 0x02
    2534:	fc 01       	movw	r30, r24
    2536:	20 83       	st	Z, r18

	return pxList->uxNumberOfItems;
    2538:	89 81       	ldd	r24, Y+1	; 0x01
    253a:	9a 81       	ldd	r25, Y+2	; 0x02
    253c:	fc 01       	movw	r30, r24
    253e:	80 81       	ld	r24, Z
}
    2540:	0f 90       	pop	r0
    2542:	0f 90       	pop	r0
    2544:	0f 90       	pop	r0
    2546:	0f 90       	pop	r0
    2548:	df 91       	pop	r29
    254a:	cf 91       	pop	r28
    254c:	08 95       	ret

0000254e <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    254e:	cf 93       	push	r28
    2550:	df 93       	push	r29
    2552:	cd b7       	in	r28, 0x3d	; 61
    2554:	de b7       	in	r29, 0x3e	; 62
    2556:	27 97       	sbiw	r28, 0x07	; 7
    2558:	0f b6       	in	r0, 0x3f	; 63
    255a:	f8 94       	cli
    255c:	de bf       	out	0x3e, r29	; 62
    255e:	0f be       	out	0x3f, r0	; 63
    2560:	cd bf       	out	0x3d, r28	; 61
    2562:	9d 83       	std	Y+5, r25	; 0x05
    2564:	8c 83       	std	Y+4, r24	; 0x04
    2566:	6e 83       	std	Y+6, r22	; 0x06
    2568:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    256a:	8a e1       	ldi	r24, 0x1A	; 26
    256c:	90 e0       	ldi	r25, 0x00	; 0
    256e:	0e 94 9f 15 	call	0x2b3e	; 0x2b3e <pvPortMalloc>
    2572:	9b 83       	std	Y+3, r25	; 0x03
    2574:	8a 83       	std	Y+2, r24	; 0x02
	if( pxCoRoutine )
    2576:	8a 81       	ldd	r24, Y+2	; 0x02
    2578:	9b 81       	ldd	r25, Y+3	; 0x03
    257a:	00 97       	sbiw	r24, 0x00	; 0
    257c:	09 f4       	brne	.+2      	; 0x2580 <xCoRoutineCreate+0x32>
    257e:	77 c0       	rjmp	.+238    	; 0x266e <xCoRoutineCreate+0x120>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    2580:	80 91 75 02 	lds	r24, 0x0275
    2584:	90 91 76 02 	lds	r25, 0x0276
    2588:	00 97       	sbiw	r24, 0x00	; 0
    258a:	41 f4       	brne	.+16     	; 0x259c <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    258c:	8a 81       	ldd	r24, Y+2	; 0x02
    258e:	9b 81       	ldd	r25, Y+3	; 0x03
    2590:	90 93 76 02 	sts	0x0276, r25
    2594:	80 93 75 02 	sts	0x0275, r24
			prvInitialiseCoRoutineLists();
    2598:	0e 94 2d 15 	call	0x2a5a	; 0x2a5a <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    259c:	8e 81       	ldd	r24, Y+6	; 0x06
    259e:	82 30       	cpi	r24, 0x02	; 2
    25a0:	10 f0       	brcs	.+4      	; 0x25a6 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    25a2:	81 e0       	ldi	r24, 0x01	; 1
    25a4:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    25a6:	8a 81       	ldd	r24, Y+2	; 0x02
    25a8:	9b 81       	ldd	r25, Y+3	; 0x03
    25aa:	fc 01       	movw	r30, r24
    25ac:	11 8e       	std	Z+25, r1	; 0x19
    25ae:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    25b0:	8a 81       	ldd	r24, Y+2	; 0x02
    25b2:	9b 81       	ldd	r25, Y+3	; 0x03
    25b4:	2e 81       	ldd	r18, Y+6	; 0x06
    25b6:	fc 01       	movw	r30, r24
    25b8:	26 8b       	std	Z+22, r18	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    25ba:	8a 81       	ldd	r24, Y+2	; 0x02
    25bc:	9b 81       	ldd	r25, Y+3	; 0x03
    25be:	2f 81       	ldd	r18, Y+7	; 0x07
    25c0:	fc 01       	movw	r30, r24
    25c2:	27 8b       	std	Z+23, r18	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    25c4:	8a 81       	ldd	r24, Y+2	; 0x02
    25c6:	9b 81       	ldd	r25, Y+3	; 0x03
    25c8:	2c 81       	ldd	r18, Y+4	; 0x04
    25ca:	3d 81       	ldd	r19, Y+5	; 0x05
    25cc:	fc 01       	movw	r30, r24
    25ce:	31 83       	std	Z+1, r19	; 0x01
    25d0:	20 83       	st	Z, r18

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    25d2:	8a 81       	ldd	r24, Y+2	; 0x02
    25d4:	9b 81       	ldd	r25, Y+3	; 0x03
    25d6:	02 96       	adiw	r24, 0x02	; 2
    25d8:	0e 94 6e 11 	call	0x22dc	; 0x22dc <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    25dc:	8a 81       	ldd	r24, Y+2	; 0x02
    25de:	9b 81       	ldd	r25, Y+3	; 0x03
    25e0:	0c 96       	adiw	r24, 0x0c	; 12
    25e2:	0e 94 6e 11 	call	0x22dc	; 0x22dc <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    25e6:	8a 81       	ldd	r24, Y+2	; 0x02
    25e8:	9b 81       	ldd	r25, Y+3	; 0x03
    25ea:	2a 81       	ldd	r18, Y+2	; 0x02
    25ec:	3b 81       	ldd	r19, Y+3	; 0x03
    25ee:	fc 01       	movw	r30, r24
    25f0:	31 87       	std	Z+9, r19	; 0x09
    25f2:	20 87       	std	Z+8, r18	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    25f4:	8a 81       	ldd	r24, Y+2	; 0x02
    25f6:	9b 81       	ldd	r25, Y+3	; 0x03
    25f8:	2a 81       	ldd	r18, Y+2	; 0x02
    25fa:	3b 81       	ldd	r19, Y+3	; 0x03
    25fc:	fc 01       	movw	r30, r24
    25fe:	33 8b       	std	Z+19, r19	; 0x13
    2600:	22 8b       	std	Z+18, r18	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    2602:	8e 81       	ldd	r24, Y+6	; 0x06
    2604:	88 2f       	mov	r24, r24
    2606:	90 e0       	ldi	r25, 0x00	; 0
    2608:	24 e0       	ldi	r18, 0x04	; 4
    260a:	30 e0       	ldi	r19, 0x00	; 0
    260c:	28 1b       	sub	r18, r24
    260e:	39 0b       	sbc	r19, r25
    2610:	8a 81       	ldd	r24, Y+2	; 0x02
    2612:	9b 81       	ldd	r25, Y+3	; 0x03
    2614:	fc 01       	movw	r30, r24
    2616:	35 87       	std	Z+13, r19	; 0x0d
    2618:	24 87       	std	Z+12, r18	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    261a:	8a 81       	ldd	r24, Y+2	; 0x02
    261c:	9b 81       	ldd	r25, Y+3	; 0x03
    261e:	fc 01       	movw	r30, r24
    2620:	96 89       	ldd	r25, Z+22	; 0x16
    2622:	80 91 a8 02 	lds	r24, 0x02A8
    2626:	89 17       	cp	r24, r25
    2628:	30 f4       	brcc	.+12     	; 0x2636 <xCoRoutineCreate+0xe8>
    262a:	8a 81       	ldd	r24, Y+2	; 0x02
    262c:	9b 81       	ldd	r25, Y+3	; 0x03
    262e:	fc 01       	movw	r30, r24
    2630:	86 89       	ldd	r24, Z+22	; 0x16
    2632:	80 93 a8 02 	sts	0x02A8, r24
    2636:	8a 81       	ldd	r24, Y+2	; 0x02
    2638:	9b 81       	ldd	r25, Y+3	; 0x03
    263a:	ac 01       	movw	r20, r24
    263c:	4e 5f       	subi	r20, 0xFE	; 254
    263e:	5f 4f       	sbci	r21, 0xFF	; 255
    2640:	8a 81       	ldd	r24, Y+2	; 0x02
    2642:	9b 81       	ldd	r25, Y+3	; 0x03
    2644:	fc 01       	movw	r30, r24
    2646:	86 89       	ldd	r24, Z+22	; 0x16
    2648:	28 2f       	mov	r18, r24
    264a:	30 e0       	ldi	r19, 0x00	; 0
    264c:	c9 01       	movw	r24, r18
    264e:	88 0f       	add	r24, r24
    2650:	99 1f       	adc	r25, r25
    2652:	88 0f       	add	r24, r24
    2654:	99 1f       	adc	r25, r25
    2656:	88 0f       	add	r24, r24
    2658:	99 1f       	adc	r25, r25
    265a:	82 0f       	add	r24, r18
    265c:	93 1f       	adc	r25, r19
    265e:	89 58       	subi	r24, 0x89	; 137
    2660:	9d 4f       	sbci	r25, 0xFD	; 253
    2662:	ba 01       	movw	r22, r20
    2664:	0e 94 80 11 	call	0x2300	; 0x2300 <vListInsertEnd>

		xReturn = pdPASS;
    2668:	81 e0       	ldi	r24, 0x01	; 1
    266a:	89 83       	std	Y+1, r24	; 0x01
    266c:	02 c0       	rjmp	.+4      	; 0x2672 <xCoRoutineCreate+0x124>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    266e:	8f ef       	ldi	r24, 0xFF	; 255
    2670:	89 83       	std	Y+1, r24	; 0x01
	}
	
	return xReturn;	
    2672:	89 81       	ldd	r24, Y+1	; 0x01
}
    2674:	27 96       	adiw	r28, 0x07	; 7
    2676:	0f b6       	in	r0, 0x3f	; 63
    2678:	f8 94       	cli
    267a:	de bf       	out	0x3e, r29	; 62
    267c:	0f be       	out	0x3f, r0	; 63
    267e:	cd bf       	out	0x3d, r28	; 61
    2680:	df 91       	pop	r29
    2682:	cf 91       	pop	r28
    2684:	08 95       	ret

00002686 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    2686:	cf 93       	push	r28
    2688:	df 93       	push	r29
    268a:	00 d0       	rcall	.+0      	; 0x268c <vCoRoutineAddToDelayedList+0x6>
    268c:	00 d0       	rcall	.+0      	; 0x268e <vCoRoutineAddToDelayedList+0x8>
    268e:	cd b7       	in	r28, 0x3d	; 61
    2690:	de b7       	in	r29, 0x3e	; 62
    2692:	9c 83       	std	Y+4, r25	; 0x04
    2694:	8b 83       	std	Y+3, r24	; 0x03
    2696:	7e 83       	std	Y+6, r23	; 0x06
    2698:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    269a:	20 91 a9 02 	lds	r18, 0x02A9
    269e:	30 91 aa 02 	lds	r19, 0x02AA
    26a2:	8b 81       	ldd	r24, Y+3	; 0x03
    26a4:	9c 81       	ldd	r25, Y+4	; 0x04
    26a6:	82 0f       	add	r24, r18
    26a8:	93 1f       	adc	r25, r19
    26aa:	9a 83       	std	Y+2, r25	; 0x02
    26ac:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    26ae:	80 91 75 02 	lds	r24, 0x0275
    26b2:	90 91 76 02 	lds	r25, 0x0276
    26b6:	02 96       	adiw	r24, 0x02	; 2
    26b8:	0e 94 50 12 	call	0x24a0	; 0x24a0 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    26bc:	80 91 75 02 	lds	r24, 0x0275
    26c0:	90 91 76 02 	lds	r25, 0x0276
    26c4:	29 81       	ldd	r18, Y+1	; 0x01
    26c6:	3a 81       	ldd	r19, Y+2	; 0x02
    26c8:	fc 01       	movw	r30, r24
    26ca:	33 83       	std	Z+3, r19	; 0x03
    26cc:	22 83       	std	Z+2, r18	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    26ce:	80 91 a9 02 	lds	r24, 0x02A9
    26d2:	90 91 aa 02 	lds	r25, 0x02AA
    26d6:	29 81       	ldd	r18, Y+1	; 0x01
    26d8:	3a 81       	ldd	r19, Y+2	; 0x02
    26da:	28 17       	cp	r18, r24
    26dc:	39 07       	cpc	r19, r25
    26de:	78 f4       	brcc	.+30     	; 0x26fe <vCoRoutineAddToDelayedList+0x78>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    26e0:	80 91 75 02 	lds	r24, 0x0275
    26e4:	90 91 76 02 	lds	r25, 0x0276
    26e8:	9c 01       	movw	r18, r24
    26ea:	2e 5f       	subi	r18, 0xFE	; 254
    26ec:	3f 4f       	sbci	r19, 0xFF	; 255
    26ee:	80 91 9d 02 	lds	r24, 0x029D
    26f2:	90 91 9e 02 	lds	r25, 0x029E
    26f6:	b9 01       	movw	r22, r18
    26f8:	0e 94 d7 11 	call	0x23ae	; 0x23ae <vListInsert>
    26fc:	0e c0       	rjmp	.+28     	; 0x271a <vCoRoutineAddToDelayedList+0x94>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    26fe:	80 91 75 02 	lds	r24, 0x0275
    2702:	90 91 76 02 	lds	r25, 0x0276
    2706:	9c 01       	movw	r18, r24
    2708:	2e 5f       	subi	r18, 0xFE	; 254
    270a:	3f 4f       	sbci	r19, 0xFF	; 255
    270c:	80 91 9b 02 	lds	r24, 0x029B
    2710:	90 91 9c 02 	lds	r25, 0x029C
    2714:	b9 01       	movw	r22, r18
    2716:	0e 94 d7 11 	call	0x23ae	; 0x23ae <vListInsert>
	}

	if( pxEventList )
    271a:	8d 81       	ldd	r24, Y+5	; 0x05
    271c:	9e 81       	ldd	r25, Y+6	; 0x06
    271e:	00 97       	sbiw	r24, 0x00	; 0
    2720:	61 f0       	breq	.+24     	; 0x273a <vCoRoutineAddToDelayedList+0xb4>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    2722:	80 91 75 02 	lds	r24, 0x0275
    2726:	90 91 76 02 	lds	r25, 0x0276
    272a:	9c 01       	movw	r18, r24
    272c:	24 5f       	subi	r18, 0xF4	; 244
    272e:	3f 4f       	sbci	r19, 0xFF	; 255
    2730:	8d 81       	ldd	r24, Y+5	; 0x05
    2732:	9e 81       	ldd	r25, Y+6	; 0x06
    2734:	b9 01       	movw	r22, r18
    2736:	0e 94 d7 11 	call	0x23ae	; 0x23ae <vListInsert>
	}
}
    273a:	26 96       	adiw	r28, 0x06	; 6
    273c:	0f b6       	in	r0, 0x3f	; 63
    273e:	f8 94       	cli
    2740:	de bf       	out	0x3e, r29	; 62
    2742:	0f be       	out	0x3f, r0	; 63
    2744:	cd bf       	out	0x3d, r28	; 61
    2746:	df 91       	pop	r29
    2748:	cf 91       	pop	r28
    274a:	08 95       	ret

0000274c <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    274c:	cf 93       	push	r28
    274e:	df 93       	push	r29
    2750:	1f 92       	push	r1
    2752:	1f 92       	push	r1
    2754:	cd b7       	in	r28, 0x3d	; 61
    2756:	de b7       	in	r29, 0x3e	; 62
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    2758:	3c c0       	rjmp	.+120    	; 0x27d2 <prvCheckPendingReadyList+0x86>
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    275a:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    275c:	80 91 a4 02 	lds	r24, 0x02A4
    2760:	90 91 a5 02 	lds	r25, 0x02A5
    2764:	fc 01       	movw	r30, r24
    2766:	86 81       	ldd	r24, Z+6	; 0x06
    2768:	97 81       	ldd	r25, Z+7	; 0x07
    276a:	9a 83       	std	Y+2, r25	; 0x02
    276c:	89 83       	std	Y+1, r24	; 0x01
			uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    276e:	89 81       	ldd	r24, Y+1	; 0x01
    2770:	9a 81       	ldd	r25, Y+2	; 0x02
    2772:	0c 96       	adiw	r24, 0x0c	; 12
    2774:	0e 94 50 12 	call	0x24a0	; 0x24a0 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    2778:	78 94       	sei

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    277a:	89 81       	ldd	r24, Y+1	; 0x01
    277c:	9a 81       	ldd	r25, Y+2	; 0x02
    277e:	02 96       	adiw	r24, 0x02	; 2
    2780:	0e 94 50 12 	call	0x24a0	; 0x24a0 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    2784:	89 81       	ldd	r24, Y+1	; 0x01
    2786:	9a 81       	ldd	r25, Y+2	; 0x02
    2788:	fc 01       	movw	r30, r24
    278a:	96 89       	ldd	r25, Z+22	; 0x16
    278c:	80 91 a8 02 	lds	r24, 0x02A8
    2790:	89 17       	cp	r24, r25
    2792:	30 f4       	brcc	.+12     	; 0x27a0 <prvCheckPendingReadyList+0x54>
    2794:	89 81       	ldd	r24, Y+1	; 0x01
    2796:	9a 81       	ldd	r25, Y+2	; 0x02
    2798:	fc 01       	movw	r30, r24
    279a:	86 89       	ldd	r24, Z+22	; 0x16
    279c:	80 93 a8 02 	sts	0x02A8, r24
    27a0:	89 81       	ldd	r24, Y+1	; 0x01
    27a2:	9a 81       	ldd	r25, Y+2	; 0x02
    27a4:	ac 01       	movw	r20, r24
    27a6:	4e 5f       	subi	r20, 0xFE	; 254
    27a8:	5f 4f       	sbci	r21, 0xFF	; 255
    27aa:	89 81       	ldd	r24, Y+1	; 0x01
    27ac:	9a 81       	ldd	r25, Y+2	; 0x02
    27ae:	fc 01       	movw	r30, r24
    27b0:	86 89       	ldd	r24, Z+22	; 0x16
    27b2:	28 2f       	mov	r18, r24
    27b4:	30 e0       	ldi	r19, 0x00	; 0
    27b6:	c9 01       	movw	r24, r18
    27b8:	88 0f       	add	r24, r24
    27ba:	99 1f       	adc	r25, r25
    27bc:	88 0f       	add	r24, r24
    27be:	99 1f       	adc	r25, r25
    27c0:	88 0f       	add	r24, r24
    27c2:	99 1f       	adc	r25, r25
    27c4:	82 0f       	add	r24, r18
    27c6:	93 1f       	adc	r25, r19
    27c8:	89 58       	subi	r24, 0x89	; 137
    27ca:	9d 4f       	sbci	r25, 0xFD	; 253
    27cc:	ba 01       	movw	r22, r20
    27ce:	0e 94 80 11 	call	0x2300	; 0x2300 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    27d2:	80 91 9f 02 	lds	r24, 0x029F
    27d6:	88 23       	and	r24, r24
    27d8:	09 f0       	breq	.+2      	; 0x27dc <prvCheckPendingReadyList+0x90>
    27da:	bf cf       	rjmp	.-130    	; 0x275a <prvCheckPendingReadyList+0xe>
		portENABLE_INTERRUPTS();

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    27dc:	0f 90       	pop	r0
    27de:	0f 90       	pop	r0
    27e0:	df 91       	pop	r29
    27e2:	cf 91       	pop	r28
    27e4:	08 95       	ret

000027e6 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    27e6:	cf 93       	push	r28
    27e8:	df 93       	push	r29
    27ea:	00 d0       	rcall	.+0      	; 0x27ec <prvCheckDelayedList+0x6>
    27ec:	1f 92       	push	r1
    27ee:	cd b7       	in	r28, 0x3d	; 61
    27f0:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    27f2:	0e 94 18 06 	call	0xc30	; 0xc30 <xTaskGetTickCount>
    27f6:	9c 01       	movw	r18, r24
    27f8:	80 91 ab 02 	lds	r24, 0x02AB
    27fc:	90 91 ac 02 	lds	r25, 0x02AC
    2800:	a9 01       	movw	r20, r18
    2802:	48 1b       	sub	r20, r24
    2804:	59 0b       	sbc	r21, r25
    2806:	ca 01       	movw	r24, r20
    2808:	90 93 ae 02 	sts	0x02AE, r25
    280c:	80 93 ad 02 	sts	0x02AD, r24
	while( xPassedTicks )
    2810:	8a c0       	rjmp	.+276    	; 0x2926 <prvCheckDelayedList+0x140>
	{
		xCoRoutineTickCount++;
    2812:	80 91 a9 02 	lds	r24, 0x02A9
    2816:	90 91 aa 02 	lds	r25, 0x02AA
    281a:	01 96       	adiw	r24, 0x01	; 1
    281c:	90 93 aa 02 	sts	0x02AA, r25
    2820:	80 93 a9 02 	sts	0x02A9, r24
		xPassedTicks--;
    2824:	80 91 ad 02 	lds	r24, 0x02AD
    2828:	90 91 ae 02 	lds	r25, 0x02AE
    282c:	01 97       	sbiw	r24, 0x01	; 1
    282e:	90 93 ae 02 	sts	0x02AE, r25
    2832:	80 93 ad 02 	sts	0x02AD, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    2836:	80 91 a9 02 	lds	r24, 0x02A9
    283a:	90 91 aa 02 	lds	r25, 0x02AA
    283e:	00 97       	sbiw	r24, 0x00	; 0
    2840:	a9 f4       	brne	.+42     	; 0x286c <prvCheckDelayedList+0x86>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    2842:	80 91 9b 02 	lds	r24, 0x029B
    2846:	90 91 9c 02 	lds	r25, 0x029C
    284a:	9a 83       	std	Y+2, r25	; 0x02
    284c:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    284e:	80 91 9d 02 	lds	r24, 0x029D
    2852:	90 91 9e 02 	lds	r25, 0x029E
    2856:	90 93 9c 02 	sts	0x029C, r25
    285a:	80 93 9b 02 	sts	0x029B, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    285e:	89 81       	ldd	r24, Y+1	; 0x01
    2860:	9a 81       	ldd	r25, Y+2	; 0x02
    2862:	90 93 9e 02 	sts	0x029E, r25
    2866:	80 93 9d 02 	sts	0x029D, r24
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    286a:	54 c0       	rjmp	.+168    	; 0x2914 <prvCheckDelayedList+0x12e>
    286c:	53 c0       	rjmp	.+166    	; 0x2914 <prvCheckDelayedList+0x12e>
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    286e:	80 91 9b 02 	lds	r24, 0x029B
    2872:	90 91 9c 02 	lds	r25, 0x029C
    2876:	fc 01       	movw	r30, r24
    2878:	85 81       	ldd	r24, Z+5	; 0x05
    287a:	96 81       	ldd	r25, Z+6	; 0x06
    287c:	fc 01       	movw	r30, r24
    287e:	86 81       	ldd	r24, Z+6	; 0x06
    2880:	97 81       	ldd	r25, Z+7	; 0x07
    2882:	9c 83       	std	Y+4, r25	; 0x04
    2884:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    2886:	8b 81       	ldd	r24, Y+3	; 0x03
    2888:	9c 81       	ldd	r25, Y+4	; 0x04
    288a:	fc 01       	movw	r30, r24
    288c:	22 81       	ldd	r18, Z+2	; 0x02
    288e:	33 81       	ldd	r19, Z+3	; 0x03
    2890:	80 91 a9 02 	lds	r24, 0x02A9
    2894:	90 91 aa 02 	lds	r25, 0x02AA
    2898:	82 17       	cp	r24, r18
    289a:	93 07       	cpc	r25, r19
    289c:	08 f4       	brcc	.+2      	; 0x28a0 <prvCheckDelayedList+0xba>
			{			
				/* Timeout not yet expired. */																			
				break;																				
    289e:	43 c0       	rjmp	.+134    	; 0x2926 <prvCheckDelayedList+0x140>
			}																						

			portDISABLE_INTERRUPTS();
    28a0:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				uxListRemove( &( pxCRCB->xGenericListItem ) );											
    28a2:	8b 81       	ldd	r24, Y+3	; 0x03
    28a4:	9c 81       	ldd	r25, Y+4	; 0x04
    28a6:	02 96       	adiw	r24, 0x02	; 2
    28a8:	0e 94 50 12 	call	0x24a0	; 0x24a0 <uxListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    28ac:	8b 81       	ldd	r24, Y+3	; 0x03
    28ae:	9c 81       	ldd	r25, Y+4	; 0x04
    28b0:	fc 01       	movw	r30, r24
    28b2:	84 89       	ldd	r24, Z+20	; 0x14
    28b4:	95 89       	ldd	r25, Z+21	; 0x15
    28b6:	00 97       	sbiw	r24, 0x00	; 0
    28b8:	29 f0       	breq	.+10     	; 0x28c4 <prvCheckDelayedList+0xde>
				{															
					uxListRemove( &( pxCRCB->xEventListItem ) );											
    28ba:	8b 81       	ldd	r24, Y+3	; 0x03
    28bc:	9c 81       	ldd	r25, Y+4	; 0x04
    28be:	0c 96       	adiw	r24, 0x0c	; 12
    28c0:	0e 94 50 12 	call	0x24a0	; 0x24a0 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    28c4:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    28c6:	8b 81       	ldd	r24, Y+3	; 0x03
    28c8:	9c 81       	ldd	r25, Y+4	; 0x04
    28ca:	fc 01       	movw	r30, r24
    28cc:	96 89       	ldd	r25, Z+22	; 0x16
    28ce:	80 91 a8 02 	lds	r24, 0x02A8
    28d2:	89 17       	cp	r24, r25
    28d4:	30 f4       	brcc	.+12     	; 0x28e2 <prvCheckDelayedList+0xfc>
    28d6:	8b 81       	ldd	r24, Y+3	; 0x03
    28d8:	9c 81       	ldd	r25, Y+4	; 0x04
    28da:	fc 01       	movw	r30, r24
    28dc:	86 89       	ldd	r24, Z+22	; 0x16
    28de:	80 93 a8 02 	sts	0x02A8, r24
    28e2:	8b 81       	ldd	r24, Y+3	; 0x03
    28e4:	9c 81       	ldd	r25, Y+4	; 0x04
    28e6:	ac 01       	movw	r20, r24
    28e8:	4e 5f       	subi	r20, 0xFE	; 254
    28ea:	5f 4f       	sbci	r21, 0xFF	; 255
    28ec:	8b 81       	ldd	r24, Y+3	; 0x03
    28ee:	9c 81       	ldd	r25, Y+4	; 0x04
    28f0:	fc 01       	movw	r30, r24
    28f2:	86 89       	ldd	r24, Z+22	; 0x16
    28f4:	28 2f       	mov	r18, r24
    28f6:	30 e0       	ldi	r19, 0x00	; 0
    28f8:	c9 01       	movw	r24, r18
    28fa:	88 0f       	add	r24, r24
    28fc:	99 1f       	adc	r25, r25
    28fe:	88 0f       	add	r24, r24
    2900:	99 1f       	adc	r25, r25
    2902:	88 0f       	add	r24, r24
    2904:	99 1f       	adc	r25, r25
    2906:	82 0f       	add	r24, r18
    2908:	93 1f       	adc	r25, r19
    290a:	89 58       	subi	r24, 0x89	; 137
    290c:	9d 4f       	sbci	r25, 0xFD	; 253
    290e:	ba 01       	movw	r22, r20
    2910:	0e 94 80 11 	call	0x2300	; 0x2300 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    2914:	80 91 9b 02 	lds	r24, 0x029B
    2918:	90 91 9c 02 	lds	r25, 0x029C
    291c:	fc 01       	movw	r30, r24
    291e:	80 81       	ld	r24, Z
    2920:	88 23       	and	r24, r24
    2922:	09 f0       	breq	.+2      	; 0x2926 <prvCheckDelayedList+0x140>
    2924:	a4 cf       	rjmp	.-184    	; 0x286e <prvCheckDelayedList+0x88>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    2926:	80 91 ad 02 	lds	r24, 0x02AD
    292a:	90 91 ae 02 	lds	r25, 0x02AE
    292e:	00 97       	sbiw	r24, 0x00	; 0
    2930:	09 f0       	breq	.+2      	; 0x2934 <prvCheckDelayedList+0x14e>
    2932:	6f cf       	rjmp	.-290    	; 0x2812 <prvCheckDelayedList+0x2c>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    2934:	80 91 a9 02 	lds	r24, 0x02A9
    2938:	90 91 aa 02 	lds	r25, 0x02AA
    293c:	90 93 ac 02 	sts	0x02AC, r25
    2940:	80 93 ab 02 	sts	0x02AB, r24
}
    2944:	0f 90       	pop	r0
    2946:	0f 90       	pop	r0
    2948:	0f 90       	pop	r0
    294a:	0f 90       	pop	r0
    294c:	df 91       	pop	r29
    294e:	cf 91       	pop	r28
    2950:	08 95       	ret

00002952 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    2952:	cf 93       	push	r28
    2954:	df 93       	push	r29
    2956:	1f 92       	push	r1
    2958:	1f 92       	push	r1
    295a:	cd b7       	in	r28, 0x3d	; 61
    295c:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    295e:	0e 94 a6 13 	call	0x274c	; 0x274c <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    2962:	0e 94 f3 13 	call	0x27e6	; 0x27e6 <prvCheckDelayedList>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2966:	0a c0       	rjmp	.+20     	; 0x297c <vCoRoutineSchedule+0x2a>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    2968:	80 91 a8 02 	lds	r24, 0x02A8
    296c:	88 23       	and	r24, r24
    296e:	09 f4       	brne	.+2      	; 0x2972 <vCoRoutineSchedule+0x20>
		{
			/* No more co-routines to check. */
			return;
    2970:	6f c0       	rjmp	.+222    	; 0x2a50 <vCoRoutineSchedule+0xfe>
		}
		--uxTopCoRoutineReadyPriority;
    2972:	80 91 a8 02 	lds	r24, 0x02A8
    2976:	81 50       	subi	r24, 0x01	; 1
    2978:	80 93 a8 02 	sts	0x02A8, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    297c:	80 91 a8 02 	lds	r24, 0x02A8
    2980:	28 2f       	mov	r18, r24
    2982:	30 e0       	ldi	r19, 0x00	; 0
    2984:	c9 01       	movw	r24, r18
    2986:	88 0f       	add	r24, r24
    2988:	99 1f       	adc	r25, r25
    298a:	88 0f       	add	r24, r24
    298c:	99 1f       	adc	r25, r25
    298e:	88 0f       	add	r24, r24
    2990:	99 1f       	adc	r25, r25
    2992:	82 0f       	add	r24, r18
    2994:	93 1f       	adc	r25, r19
    2996:	89 58       	subi	r24, 0x89	; 137
    2998:	9d 4f       	sbci	r25, 0xFD	; 253
    299a:	fc 01       	movw	r30, r24
    299c:	80 81       	ld	r24, Z
    299e:	88 23       	and	r24, r24
    29a0:	19 f3       	breq	.-58     	; 0x2968 <vCoRoutineSchedule+0x16>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    29a2:	80 91 a8 02 	lds	r24, 0x02A8
    29a6:	28 2f       	mov	r18, r24
    29a8:	30 e0       	ldi	r19, 0x00	; 0
    29aa:	c9 01       	movw	r24, r18
    29ac:	88 0f       	add	r24, r24
    29ae:	99 1f       	adc	r25, r25
    29b0:	88 0f       	add	r24, r24
    29b2:	99 1f       	adc	r25, r25
    29b4:	88 0f       	add	r24, r24
    29b6:	99 1f       	adc	r25, r25
    29b8:	82 0f       	add	r24, r18
    29ba:	93 1f       	adc	r25, r19
    29bc:	89 58       	subi	r24, 0x89	; 137
    29be:	9d 4f       	sbci	r25, 0xFD	; 253
    29c0:	9a 83       	std	Y+2, r25	; 0x02
    29c2:	89 83       	std	Y+1, r24	; 0x01
    29c4:	89 81       	ldd	r24, Y+1	; 0x01
    29c6:	9a 81       	ldd	r25, Y+2	; 0x02
    29c8:	fc 01       	movw	r30, r24
    29ca:	81 81       	ldd	r24, Z+1	; 0x01
    29cc:	92 81       	ldd	r25, Z+2	; 0x02
    29ce:	fc 01       	movw	r30, r24
    29d0:	22 81       	ldd	r18, Z+2	; 0x02
    29d2:	33 81       	ldd	r19, Z+3	; 0x03
    29d4:	89 81       	ldd	r24, Y+1	; 0x01
    29d6:	9a 81       	ldd	r25, Y+2	; 0x02
    29d8:	fc 01       	movw	r30, r24
    29da:	32 83       	std	Z+2, r19	; 0x02
    29dc:	21 83       	std	Z+1, r18	; 0x01
    29de:	89 81       	ldd	r24, Y+1	; 0x01
    29e0:	9a 81       	ldd	r25, Y+2	; 0x02
    29e2:	fc 01       	movw	r30, r24
    29e4:	21 81       	ldd	r18, Z+1	; 0x01
    29e6:	32 81       	ldd	r19, Z+2	; 0x02
    29e8:	89 81       	ldd	r24, Y+1	; 0x01
    29ea:	9a 81       	ldd	r25, Y+2	; 0x02
    29ec:	03 96       	adiw	r24, 0x03	; 3
    29ee:	28 17       	cp	r18, r24
    29f0:	39 07       	cpc	r19, r25
    29f2:	69 f4       	brne	.+26     	; 0x2a0e <vCoRoutineSchedule+0xbc>
    29f4:	89 81       	ldd	r24, Y+1	; 0x01
    29f6:	9a 81       	ldd	r25, Y+2	; 0x02
    29f8:	fc 01       	movw	r30, r24
    29fa:	81 81       	ldd	r24, Z+1	; 0x01
    29fc:	92 81       	ldd	r25, Z+2	; 0x02
    29fe:	fc 01       	movw	r30, r24
    2a00:	22 81       	ldd	r18, Z+2	; 0x02
    2a02:	33 81       	ldd	r19, Z+3	; 0x03
    2a04:	89 81       	ldd	r24, Y+1	; 0x01
    2a06:	9a 81       	ldd	r25, Y+2	; 0x02
    2a08:	fc 01       	movw	r30, r24
    2a0a:	32 83       	std	Z+2, r19	; 0x02
    2a0c:	21 83       	std	Z+1, r18	; 0x01
    2a0e:	89 81       	ldd	r24, Y+1	; 0x01
    2a10:	9a 81       	ldd	r25, Y+2	; 0x02
    2a12:	fc 01       	movw	r30, r24
    2a14:	81 81       	ldd	r24, Z+1	; 0x01
    2a16:	92 81       	ldd	r25, Z+2	; 0x02
    2a18:	fc 01       	movw	r30, r24
    2a1a:	86 81       	ldd	r24, Z+6	; 0x06
    2a1c:	97 81       	ldd	r25, Z+7	; 0x07
    2a1e:	90 93 76 02 	sts	0x0276, r25
    2a22:	80 93 75 02 	sts	0x0275, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2a26:	80 91 75 02 	lds	r24, 0x0275
    2a2a:	90 91 76 02 	lds	r25, 0x0276
    2a2e:	fc 01       	movw	r30, r24
    2a30:	20 81       	ld	r18, Z
    2a32:	31 81       	ldd	r19, Z+1	; 0x01
    2a34:	80 91 75 02 	lds	r24, 0x0275
    2a38:	90 91 76 02 	lds	r25, 0x0276
    2a3c:	fc 01       	movw	r30, r24
    2a3e:	47 89       	ldd	r20, Z+23	; 0x17
    2a40:	80 91 75 02 	lds	r24, 0x0275
    2a44:	90 91 76 02 	lds	r25, 0x0276
    2a48:	64 2f       	mov	r22, r20
    2a4a:	f9 01       	movw	r30, r18
    2a4c:	19 95       	eicall

	return;
    2a4e:	00 00       	nop
}
    2a50:	0f 90       	pop	r0
    2a52:	0f 90       	pop	r0
    2a54:	df 91       	pop	r29
    2a56:	cf 91       	pop	r28
    2a58:	08 95       	ret

00002a5a <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    2a5a:	cf 93       	push	r28
    2a5c:	df 93       	push	r29
    2a5e:	1f 92       	push	r1
    2a60:	cd b7       	in	r28, 0x3d	; 61
    2a62:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2a64:	19 82       	std	Y+1, r1	; 0x01
    2a66:	13 c0       	rjmp	.+38     	; 0x2a8e <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    2a68:	89 81       	ldd	r24, Y+1	; 0x01
    2a6a:	28 2f       	mov	r18, r24
    2a6c:	30 e0       	ldi	r19, 0x00	; 0
    2a6e:	c9 01       	movw	r24, r18
    2a70:	88 0f       	add	r24, r24
    2a72:	99 1f       	adc	r25, r25
    2a74:	88 0f       	add	r24, r24
    2a76:	99 1f       	adc	r25, r25
    2a78:	88 0f       	add	r24, r24
    2a7a:	99 1f       	adc	r25, r25
    2a7c:	82 0f       	add	r24, r18
    2a7e:	93 1f       	adc	r25, r19
    2a80:	89 58       	subi	r24, 0x89	; 137
    2a82:	9d 4f       	sbci	r25, 0xFD	; 253
    2a84:	0e 94 38 11 	call	0x2270	; 0x2270 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2a88:	89 81       	ldd	r24, Y+1	; 0x01
    2a8a:	8f 5f       	subi	r24, 0xFF	; 255
    2a8c:	89 83       	std	Y+1, r24	; 0x01
    2a8e:	89 81       	ldd	r24, Y+1	; 0x01
    2a90:	82 30       	cpi	r24, 0x02	; 2
    2a92:	50 f3       	brcs	.-44     	; 0x2a68 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    2a94:	89 e8       	ldi	r24, 0x89	; 137
    2a96:	92 e0       	ldi	r25, 0x02	; 2
    2a98:	0e 94 38 11 	call	0x2270	; 0x2270 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    2a9c:	82 e9       	ldi	r24, 0x92	; 146
    2a9e:	92 e0       	ldi	r25, 0x02	; 2
    2aa0:	0e 94 38 11 	call	0x2270	; 0x2270 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    2aa4:	8f e9       	ldi	r24, 0x9F	; 159
    2aa6:	92 e0       	ldi	r25, 0x02	; 2
    2aa8:	0e 94 38 11 	call	0x2270	; 0x2270 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    2aac:	89 e8       	ldi	r24, 0x89	; 137
    2aae:	92 e0       	ldi	r25, 0x02	; 2
    2ab0:	90 93 9c 02 	sts	0x029C, r25
    2ab4:	80 93 9b 02 	sts	0x029B, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    2ab8:	82 e9       	ldi	r24, 0x92	; 146
    2aba:	92 e0       	ldi	r25, 0x02	; 2
    2abc:	90 93 9e 02 	sts	0x029E, r25
    2ac0:	80 93 9d 02 	sts	0x029D, r24
}
    2ac4:	0f 90       	pop	r0
    2ac6:	df 91       	pop	r29
    2ac8:	cf 91       	pop	r28
    2aca:	08 95       	ret

00002acc <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    2acc:	cf 93       	push	r28
    2ace:	df 93       	push	r29
    2ad0:	00 d0       	rcall	.+0      	; 0x2ad2 <xCoRoutineRemoveFromEventList+0x6>
    2ad2:	1f 92       	push	r1
    2ad4:	1f 92       	push	r1
    2ad6:	cd b7       	in	r28, 0x3d	; 61
    2ad8:	de b7       	in	r29, 0x3e	; 62
    2ada:	9d 83       	std	Y+5, r25	; 0x05
    2adc:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2ade:	8c 81       	ldd	r24, Y+4	; 0x04
    2ae0:	9d 81       	ldd	r25, Y+5	; 0x05
    2ae2:	fc 01       	movw	r30, r24
    2ae4:	85 81       	ldd	r24, Z+5	; 0x05
    2ae6:	96 81       	ldd	r25, Z+6	; 0x06
    2ae8:	fc 01       	movw	r30, r24
    2aea:	86 81       	ldd	r24, Z+6	; 0x06
    2aec:	97 81       	ldd	r25, Z+7	; 0x07
    2aee:	9b 83       	std	Y+3, r25	; 0x03
    2af0:	8a 83       	std	Y+2, r24	; 0x02
	uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2af2:	8a 81       	ldd	r24, Y+2	; 0x02
    2af4:	9b 81       	ldd	r25, Y+3	; 0x03
    2af6:	0c 96       	adiw	r24, 0x0c	; 12
    2af8:	0e 94 50 12 	call	0x24a0	; 0x24a0 <uxListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    2afc:	8a 81       	ldd	r24, Y+2	; 0x02
    2afe:	9b 81       	ldd	r25, Y+3	; 0x03
    2b00:	0c 96       	adiw	r24, 0x0c	; 12
    2b02:	bc 01       	movw	r22, r24
    2b04:	8f e9       	ldi	r24, 0x9F	; 159
    2b06:	92 e0       	ldi	r25, 0x02	; 2
    2b08:	0e 94 80 11 	call	0x2300	; 0x2300 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    2b0c:	8a 81       	ldd	r24, Y+2	; 0x02
    2b0e:	9b 81       	ldd	r25, Y+3	; 0x03
    2b10:	fc 01       	movw	r30, r24
    2b12:	26 89       	ldd	r18, Z+22	; 0x16
    2b14:	80 91 75 02 	lds	r24, 0x0275
    2b18:	90 91 76 02 	lds	r25, 0x0276
    2b1c:	fc 01       	movw	r30, r24
    2b1e:	86 89       	ldd	r24, Z+22	; 0x16
    2b20:	28 17       	cp	r18, r24
    2b22:	18 f0       	brcs	.+6      	; 0x2b2a <xCoRoutineRemoveFromEventList+0x5e>
	{
		xReturn = pdTRUE;
    2b24:	81 e0       	ldi	r24, 0x01	; 1
    2b26:	89 83       	std	Y+1, r24	; 0x01
    2b28:	01 c0       	rjmp	.+2      	; 0x2b2c <xCoRoutineRemoveFromEventList+0x60>
	}
	else
	{
		xReturn = pdFALSE;
    2b2a:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2b2c:	89 81       	ldd	r24, Y+1	; 0x01
}
    2b2e:	0f 90       	pop	r0
    2b30:	0f 90       	pop	r0
    2b32:	0f 90       	pop	r0
    2b34:	0f 90       	pop	r0
    2b36:	0f 90       	pop	r0
    2b38:	df 91       	pop	r29
    2b3a:	cf 91       	pop	r28
    2b3c:	08 95       	ret

00002b3e <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2b3e:	cf 93       	push	r28
    2b40:	df 93       	push	r29
    2b42:	00 d0       	rcall	.+0      	; 0x2b44 <pvPortMalloc+0x6>
    2b44:	1f 92       	push	r1
    2b46:	cd b7       	in	r28, 0x3d	; 61
    2b48:	de b7       	in	r29, 0x3e	; 62
    2b4a:	9c 83       	std	Y+4, r25	; 0x04
    2b4c:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    2b4e:	1a 82       	std	Y+2, r1	; 0x02
    2b50:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    2b52:	0e 94 88 05 	call	0xb10	; 0xb10 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    2b56:	20 91 af 1a 	lds	r18, 0x1AAF
    2b5a:	30 91 b0 1a 	lds	r19, 0x1AB0
    2b5e:	8b 81       	ldd	r24, Y+3	; 0x03
    2b60:	9c 81       	ldd	r25, Y+4	; 0x04
    2b62:	82 0f       	add	r24, r18
    2b64:	93 1f       	adc	r25, r19
    2b66:	81 15       	cp	r24, r1
    2b68:	28 e1       	ldi	r18, 0x18	; 24
    2b6a:	92 07       	cpc	r25, r18
    2b6c:	18 f5       	brcc	.+70     	; 0x2bb4 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
    2b6e:	20 91 af 1a 	lds	r18, 0x1AAF
    2b72:	30 91 b0 1a 	lds	r19, 0x1AB0
    2b76:	8b 81       	ldd	r24, Y+3	; 0x03
    2b78:	9c 81       	ldd	r25, Y+4	; 0x04
    2b7a:	28 0f       	add	r18, r24
    2b7c:	39 1f       	adc	r19, r25
    2b7e:	80 91 af 1a 	lds	r24, 0x1AAF
    2b82:	90 91 b0 1a 	lds	r25, 0x1AB0
	#endif

	vTaskSuspendAll();
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    2b86:	82 17       	cp	r24, r18
    2b88:	93 07       	cpc	r25, r19
    2b8a:	a0 f4       	brcc	.+40     	; 0x2bb4 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    2b8c:	80 91 af 1a 	lds	r24, 0x1AAF
    2b90:	90 91 b0 1a 	lds	r25, 0x1AB0
    2b94:	81 55       	subi	r24, 0x51	; 81
    2b96:	9d 4f       	sbci	r25, 0xFD	; 253
    2b98:	9a 83       	std	Y+2, r25	; 0x02
    2b9a:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    2b9c:	20 91 af 1a 	lds	r18, 0x1AAF
    2ba0:	30 91 b0 1a 	lds	r19, 0x1AB0
    2ba4:	8b 81       	ldd	r24, Y+3	; 0x03
    2ba6:	9c 81       	ldd	r25, Y+4	; 0x04
    2ba8:	82 0f       	add	r24, r18
    2baa:	93 1f       	adc	r25, r19
    2bac:	90 93 b0 1a 	sts	0x1AB0, r25
    2bb0:	80 93 af 1a 	sts	0x1AAF, r24
		}
	}
	xTaskResumeAll();
    2bb4:	0e 94 94 05 	call	0xb28	; 0xb28 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    2bb8:	89 81       	ldd	r24, Y+1	; 0x01
    2bba:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2bbc:	0f 90       	pop	r0
    2bbe:	0f 90       	pop	r0
    2bc0:	0f 90       	pop	r0
    2bc2:	0f 90       	pop	r0
    2bc4:	df 91       	pop	r29
    2bc6:	cf 91       	pop	r28
    2bc8:	08 95       	ret

00002bca <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2bca:	cf 93       	push	r28
    2bcc:	df 93       	push	r29
    2bce:	1f 92       	push	r1
    2bd0:	1f 92       	push	r1
    2bd2:	cd b7       	in	r28, 0x3d	; 61
    2bd4:	de b7       	in	r29, 0x3e	; 62
    2bd6:	9a 83       	std	Y+2, r25	; 0x02
    2bd8:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    2bda:	0f 90       	pop	r0
    2bdc:	0f 90       	pop	r0
    2bde:	df 91       	pop	r29
    2be0:	cf 91       	pop	r28
    2be2:	08 95       	ret

00002be4 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    2be4:	cf 93       	push	r28
    2be6:	df 93       	push	r29
    2be8:	cd b7       	in	r28, 0x3d	; 61
    2bea:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    2bec:	10 92 b0 1a 	sts	0x1AB0, r1
    2bf0:	10 92 af 1a 	sts	0x1AAF, r1
}
    2bf4:	df 91       	pop	r29
    2bf6:	cf 91       	pop	r28
    2bf8:	08 95       	ret

00002bfa <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    2bfa:	cf 93       	push	r28
    2bfc:	df 93       	push	r29
    2bfe:	cd b7       	in	r28, 0x3d	; 61
    2c00:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    2c02:	80 91 af 1a 	lds	r24, 0x1AAF
    2c06:	90 91 b0 1a 	lds	r25, 0x1AB0
    2c0a:	20 e0       	ldi	r18, 0x00	; 0
    2c0c:	38 e1       	ldi	r19, 0x18	; 24
    2c0e:	a9 01       	movw	r20, r18
    2c10:	48 1b       	sub	r20, r24
    2c12:	59 0b       	sbc	r21, r25
    2c14:	ca 01       	movw	r24, r20
}
    2c16:	df 91       	pop	r29
    2c18:	cf 91       	pop	r28
    2c1a:	08 95       	ret

00002c1c <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    2c1c:	cf 93       	push	r28
    2c1e:	df 93       	push	r29
    2c20:	cd b7       	in	r28, 0x3d	; 61
    2c22:	de b7       	in	r29, 0x3e	; 62
    2c24:	28 97       	sbiw	r28, 0x08	; 8
    2c26:	0f b6       	in	r0, 0x3f	; 63
    2c28:	f8 94       	cli
    2c2a:	de bf       	out	0x3e, r29	; 62
    2c2c:	0f be       	out	0x3f, r0	; 63
    2c2e:	cd bf       	out	0x3d, r28	; 61
    2c30:	9c 83       	std	Y+4, r25	; 0x04
    2c32:	8b 83       	std	Y+3, r24	; 0x03
    2c34:	7e 83       	std	Y+6, r23	; 0x06
    2c36:	6d 83       	std	Y+5, r22	; 0x05
    2c38:	58 87       	std	Y+8, r21	; 0x08
    2c3a:	4f 83       	std	Y+7, r20	; 0x07
#endif

	/* Place a few bytes of known values on the bottom of the stack.
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2c3c:	8b 81       	ldd	r24, Y+3	; 0x03
    2c3e:	9c 81       	ldd	r25, Y+4	; 0x04
    2c40:	21 e1       	ldi	r18, 0x11	; 17
    2c42:	fc 01       	movw	r30, r24
    2c44:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c46:	8b 81       	ldd	r24, Y+3	; 0x03
    2c48:	9c 81       	ldd	r25, Y+4	; 0x04
    2c4a:	01 97       	sbiw	r24, 0x01	; 1
    2c4c:	9c 83       	std	Y+4, r25	; 0x04
    2c4e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    2c50:	8b 81       	ldd	r24, Y+3	; 0x03
    2c52:	9c 81       	ldd	r25, Y+4	; 0x04
    2c54:	22 e2       	ldi	r18, 0x22	; 34
    2c56:	fc 01       	movw	r30, r24
    2c58:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c5a:	8b 81       	ldd	r24, Y+3	; 0x03
    2c5c:	9c 81       	ldd	r25, Y+4	; 0x04
    2c5e:	01 97       	sbiw	r24, 0x01	; 1
    2c60:	9c 83       	std	Y+4, r25	; 0x04
    2c62:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    2c64:	8b 81       	ldd	r24, Y+3	; 0x03
    2c66:	9c 81       	ldd	r25, Y+4	; 0x04
    2c68:	23 e3       	ldi	r18, 0x33	; 51
    2c6a:	fc 01       	movw	r30, r24
    2c6c:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c6e:	8b 81       	ldd	r24, Y+3	; 0x03
    2c70:	9c 81       	ldd	r25, Y+4	; 0x04
    2c72:	01 97       	sbiw	r24, 0x01	; 1
    2c74:	9c 83       	std	Y+4, r25	; 0x04
    2c76:	8b 83       	std	Y+3, r24	; 0x03
	 * of flash. We do this by adding the .task label in the linker script.
	 *
	 * In order to do this properly, we would need to get a full 3-byte pointer to
	 * pxCode.  That requires a change to GCC.  Not likely to happen any time soon.
	 */
	usAddress = ( unsigned portSHORT ) pxCode;
    2c78:	8d 81       	ldd	r24, Y+5	; 0x05
    2c7a:	9e 81       	ldd	r25, Y+6	; 0x06
    2c7c:	9a 83       	std	Y+2, r25	; 0x02
    2c7e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    2c80:	29 81       	ldd	r18, Y+1	; 0x01
    2c82:	8b 81       	ldd	r24, Y+3	; 0x03
    2c84:	9c 81       	ldd	r25, Y+4	; 0x04
    2c86:	fc 01       	movw	r30, r24
    2c88:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c8a:	8b 81       	ldd	r24, Y+3	; 0x03
    2c8c:	9c 81       	ldd	r25, Y+4	; 0x04
    2c8e:	01 97       	sbiw	r24, 0x01	; 1
    2c90:	9c 83       	std	Y+4, r25	; 0x04
    2c92:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2c94:	89 81       	ldd	r24, Y+1	; 0x01
    2c96:	9a 81       	ldd	r25, Y+2	; 0x02
    2c98:	89 2f       	mov	r24, r25
    2c9a:	99 27       	eor	r25, r25
    2c9c:	9a 83       	std	Y+2, r25	; 0x02
    2c9e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    2ca0:	29 81       	ldd	r18, Y+1	; 0x01
    2ca2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ca4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ca6:	fc 01       	movw	r30, r24
    2ca8:	20 83       	st	Z, r18
	pxTopOfStack--;
    2caa:	8b 81       	ldd	r24, Y+3	; 0x03
    2cac:	9c 81       	ldd	r25, Y+4	; 0x04
    2cae:	01 97       	sbiw	r24, 0x01	; 1
    2cb0:	9c 83       	std	Y+4, r25	; 0x04
    2cb2:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = 0;
    2cb4:	8b 81       	ldd	r24, Y+3	; 0x03
    2cb6:	9c 81       	ldd	r25, Y+4	; 0x04
    2cb8:	fc 01       	movw	r30, r24
    2cba:	10 82       	st	Z, r1
	pxTopOfStack--;
    2cbc:	8b 81       	ldd	r24, Y+3	; 0x03
    2cbe:	9c 81       	ldd	r25, Y+4	; 0x04
    2cc0:	01 97       	sbiw	r24, 0x01	; 1
    2cc2:	9c 83       	std	Y+4, r25	; 0x04
    2cc4:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    2cc6:	8b 81       	ldd	r24, Y+3	; 0x03
    2cc8:	9c 81       	ldd	r25, Y+4	; 0x04
    2cca:	fc 01       	movw	r30, r24
    2ccc:	10 82       	st	Z, r1
	pxTopOfStack--;
    2cce:	8b 81       	ldd	r24, Y+3	; 0x03
    2cd0:	9c 81       	ldd	r25, Y+4	; 0x04
    2cd2:	01 97       	sbiw	r24, 0x01	; 1
    2cd4:	9c 83       	std	Y+4, r25	; 0x04
    2cd6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2cd8:	8b 81       	ldd	r24, Y+3	; 0x03
    2cda:	9c 81       	ldd	r25, Y+4	; 0x04
    2cdc:	20 e8       	ldi	r18, 0x80	; 128
    2cde:	fc 01       	movw	r30, r24
    2ce0:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ce2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ce4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ce6:	01 97       	sbiw	r24, 0x01	; 1
    2ce8:	9c 83       	std	Y+4, r25	; 0x04
    2cea:	8b 83       	std	Y+3, r24	; 0x03
#if defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

	/* If we have an ATmega256x, we are also saving the RAMPZ and EIND registers.
	 * We should default those to 0.
	 */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* EIND */
    2cec:	8b 81       	ldd	r24, Y+3	; 0x03
    2cee:	9c 81       	ldd	r25, Y+4	; 0x04
    2cf0:	fc 01       	movw	r30, r24
    2cf2:	10 82       	st	Z, r1
	pxTopOfStack--;
    2cf4:	8b 81       	ldd	r24, Y+3	; 0x03
    2cf6:	9c 81       	ldd	r25, Y+4	; 0x04
    2cf8:	01 97       	sbiw	r24, 0x01	; 1
    2cfa:	9c 83       	std	Y+4, r25	; 0x04
    2cfc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* RAMPZ */
    2cfe:	8b 81       	ldd	r24, Y+3	; 0x03
    2d00:	9c 81       	ldd	r25, Y+4	; 0x04
    2d02:	fc 01       	movw	r30, r24
    2d04:	10 82       	st	Z, r1
	pxTopOfStack--;
    2d06:	8b 81       	ldd	r24, Y+3	; 0x03
    2d08:	9c 81       	ldd	r25, Y+4	; 0x04
    2d0a:	01 97       	sbiw	r24, 0x01	; 1
    2d0c:	9c 83       	std	Y+4, r25	; 0x04
    2d0e:	8b 83       	std	Y+3, r24	; 0x03

#endif

	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    2d10:	8b 81       	ldd	r24, Y+3	; 0x03
    2d12:	9c 81       	ldd	r25, Y+4	; 0x04
    2d14:	fc 01       	movw	r30, r24
    2d16:	10 82       	st	Z, r1
	pxTopOfStack--;
    2d18:	8b 81       	ldd	r24, Y+3	; 0x03
    2d1a:	9c 81       	ldd	r25, Y+4	; 0x04
    2d1c:	01 97       	sbiw	r24, 0x01	; 1
    2d1e:	9c 83       	std	Y+4, r25	; 0x04
    2d20:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    2d22:	8b 81       	ldd	r24, Y+3	; 0x03
    2d24:	9c 81       	ldd	r25, Y+4	; 0x04
    2d26:	22 e0       	ldi	r18, 0x02	; 2
    2d28:	fc 01       	movw	r30, r24
    2d2a:	20 83       	st	Z, r18
	pxTopOfStack--;
    2d2c:	8b 81       	ldd	r24, Y+3	; 0x03
    2d2e:	9c 81       	ldd	r25, Y+4	; 0x04
    2d30:	01 97       	sbiw	r24, 0x01	; 1
    2d32:	9c 83       	std	Y+4, r25	; 0x04
    2d34:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    2d36:	8b 81       	ldd	r24, Y+3	; 0x03
    2d38:	9c 81       	ldd	r25, Y+4	; 0x04
    2d3a:	23 e0       	ldi	r18, 0x03	; 3
    2d3c:	fc 01       	movw	r30, r24
    2d3e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2d40:	8b 81       	ldd	r24, Y+3	; 0x03
    2d42:	9c 81       	ldd	r25, Y+4	; 0x04
    2d44:	01 97       	sbiw	r24, 0x01	; 1
    2d46:	9c 83       	std	Y+4, r25	; 0x04
    2d48:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    2d4a:	8b 81       	ldd	r24, Y+3	; 0x03
    2d4c:	9c 81       	ldd	r25, Y+4	; 0x04
    2d4e:	24 e0       	ldi	r18, 0x04	; 4
    2d50:	fc 01       	movw	r30, r24
    2d52:	20 83       	st	Z, r18
	pxTopOfStack--;
    2d54:	8b 81       	ldd	r24, Y+3	; 0x03
    2d56:	9c 81       	ldd	r25, Y+4	; 0x04
    2d58:	01 97       	sbiw	r24, 0x01	; 1
    2d5a:	9c 83       	std	Y+4, r25	; 0x04
    2d5c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    2d5e:	8b 81       	ldd	r24, Y+3	; 0x03
    2d60:	9c 81       	ldd	r25, Y+4	; 0x04
    2d62:	25 e0       	ldi	r18, 0x05	; 5
    2d64:	fc 01       	movw	r30, r24
    2d66:	20 83       	st	Z, r18
	pxTopOfStack--;
    2d68:	8b 81       	ldd	r24, Y+3	; 0x03
    2d6a:	9c 81       	ldd	r25, Y+4	; 0x04
    2d6c:	01 97       	sbiw	r24, 0x01	; 1
    2d6e:	9c 83       	std	Y+4, r25	; 0x04
    2d70:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    2d72:	8b 81       	ldd	r24, Y+3	; 0x03
    2d74:	9c 81       	ldd	r25, Y+4	; 0x04
    2d76:	26 e0       	ldi	r18, 0x06	; 6
    2d78:	fc 01       	movw	r30, r24
    2d7a:	20 83       	st	Z, r18
	pxTopOfStack--;
    2d7c:	8b 81       	ldd	r24, Y+3	; 0x03
    2d7e:	9c 81       	ldd	r25, Y+4	; 0x04
    2d80:	01 97       	sbiw	r24, 0x01	; 1
    2d82:	9c 83       	std	Y+4, r25	; 0x04
    2d84:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    2d86:	8b 81       	ldd	r24, Y+3	; 0x03
    2d88:	9c 81       	ldd	r25, Y+4	; 0x04
    2d8a:	27 e0       	ldi	r18, 0x07	; 7
    2d8c:	fc 01       	movw	r30, r24
    2d8e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2d90:	8b 81       	ldd	r24, Y+3	; 0x03
    2d92:	9c 81       	ldd	r25, Y+4	; 0x04
    2d94:	01 97       	sbiw	r24, 0x01	; 1
    2d96:	9c 83       	std	Y+4, r25	; 0x04
    2d98:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    2d9a:	8b 81       	ldd	r24, Y+3	; 0x03
    2d9c:	9c 81       	ldd	r25, Y+4	; 0x04
    2d9e:	28 e0       	ldi	r18, 0x08	; 8
    2da0:	fc 01       	movw	r30, r24
    2da2:	20 83       	st	Z, r18
	pxTopOfStack--;
    2da4:	8b 81       	ldd	r24, Y+3	; 0x03
    2da6:	9c 81       	ldd	r25, Y+4	; 0x04
    2da8:	01 97       	sbiw	r24, 0x01	; 1
    2daa:	9c 83       	std	Y+4, r25	; 0x04
    2dac:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    2dae:	8b 81       	ldd	r24, Y+3	; 0x03
    2db0:	9c 81       	ldd	r25, Y+4	; 0x04
    2db2:	29 e0       	ldi	r18, 0x09	; 9
    2db4:	fc 01       	movw	r30, r24
    2db6:	20 83       	st	Z, r18
	pxTopOfStack--;
    2db8:	8b 81       	ldd	r24, Y+3	; 0x03
    2dba:	9c 81       	ldd	r25, Y+4	; 0x04
    2dbc:	01 97       	sbiw	r24, 0x01	; 1
    2dbe:	9c 83       	std	Y+4, r25	; 0x04
    2dc0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    2dc2:	8b 81       	ldd	r24, Y+3	; 0x03
    2dc4:	9c 81       	ldd	r25, Y+4	; 0x04
    2dc6:	20 e1       	ldi	r18, 0x10	; 16
    2dc8:	fc 01       	movw	r30, r24
    2dca:	20 83       	st	Z, r18
	pxTopOfStack--;
    2dcc:	8b 81       	ldd	r24, Y+3	; 0x03
    2dce:	9c 81       	ldd	r25, Y+4	; 0x04
    2dd0:	01 97       	sbiw	r24, 0x01	; 1
    2dd2:	9c 83       	std	Y+4, r25	; 0x04
    2dd4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    2dd6:	8b 81       	ldd	r24, Y+3	; 0x03
    2dd8:	9c 81       	ldd	r25, Y+4	; 0x04
    2dda:	21 e1       	ldi	r18, 0x11	; 17
    2ddc:	fc 01       	movw	r30, r24
    2dde:	20 83       	st	Z, r18
	pxTopOfStack--;
    2de0:	8b 81       	ldd	r24, Y+3	; 0x03
    2de2:	9c 81       	ldd	r25, Y+4	; 0x04
    2de4:	01 97       	sbiw	r24, 0x01	; 1
    2de6:	9c 83       	std	Y+4, r25	; 0x04
    2de8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    2dea:	8b 81       	ldd	r24, Y+3	; 0x03
    2dec:	9c 81       	ldd	r25, Y+4	; 0x04
    2dee:	22 e1       	ldi	r18, 0x12	; 18
    2df0:	fc 01       	movw	r30, r24
    2df2:	20 83       	st	Z, r18
	pxTopOfStack--;
    2df4:	8b 81       	ldd	r24, Y+3	; 0x03
    2df6:	9c 81       	ldd	r25, Y+4	; 0x04
    2df8:	01 97       	sbiw	r24, 0x01	; 1
    2dfa:	9c 83       	std	Y+4, r25	; 0x04
    2dfc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    2dfe:	8b 81       	ldd	r24, Y+3	; 0x03
    2e00:	9c 81       	ldd	r25, Y+4	; 0x04
    2e02:	23 e1       	ldi	r18, 0x13	; 19
    2e04:	fc 01       	movw	r30, r24
    2e06:	20 83       	st	Z, r18
	pxTopOfStack--;
    2e08:	8b 81       	ldd	r24, Y+3	; 0x03
    2e0a:	9c 81       	ldd	r25, Y+4	; 0x04
    2e0c:	01 97       	sbiw	r24, 0x01	; 1
    2e0e:	9c 83       	std	Y+4, r25	; 0x04
    2e10:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    2e12:	8b 81       	ldd	r24, Y+3	; 0x03
    2e14:	9c 81       	ldd	r25, Y+4	; 0x04
    2e16:	24 e1       	ldi	r18, 0x14	; 20
    2e18:	fc 01       	movw	r30, r24
    2e1a:	20 83       	st	Z, r18
	pxTopOfStack--;
    2e1c:	8b 81       	ldd	r24, Y+3	; 0x03
    2e1e:	9c 81       	ldd	r25, Y+4	; 0x04
    2e20:	01 97       	sbiw	r24, 0x01	; 1
    2e22:	9c 83       	std	Y+4, r25	; 0x04
    2e24:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    2e26:	8b 81       	ldd	r24, Y+3	; 0x03
    2e28:	9c 81       	ldd	r25, Y+4	; 0x04
    2e2a:	25 e1       	ldi	r18, 0x15	; 21
    2e2c:	fc 01       	movw	r30, r24
    2e2e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2e30:	8b 81       	ldd	r24, Y+3	; 0x03
    2e32:	9c 81       	ldd	r25, Y+4	; 0x04
    2e34:	01 97       	sbiw	r24, 0x01	; 1
    2e36:	9c 83       	std	Y+4, r25	; 0x04
    2e38:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    2e3a:	8b 81       	ldd	r24, Y+3	; 0x03
    2e3c:	9c 81       	ldd	r25, Y+4	; 0x04
    2e3e:	26 e1       	ldi	r18, 0x16	; 22
    2e40:	fc 01       	movw	r30, r24
    2e42:	20 83       	st	Z, r18
	pxTopOfStack--;
    2e44:	8b 81       	ldd	r24, Y+3	; 0x03
    2e46:	9c 81       	ldd	r25, Y+4	; 0x04
    2e48:	01 97       	sbiw	r24, 0x01	; 1
    2e4a:	9c 83       	std	Y+4, r25	; 0x04
    2e4c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    2e4e:	8b 81       	ldd	r24, Y+3	; 0x03
    2e50:	9c 81       	ldd	r25, Y+4	; 0x04
    2e52:	27 e1       	ldi	r18, 0x17	; 23
    2e54:	fc 01       	movw	r30, r24
    2e56:	20 83       	st	Z, r18
	pxTopOfStack--;
    2e58:	8b 81       	ldd	r24, Y+3	; 0x03
    2e5a:	9c 81       	ldd	r25, Y+4	; 0x04
    2e5c:	01 97       	sbiw	r24, 0x01	; 1
    2e5e:	9c 83       	std	Y+4, r25	; 0x04
    2e60:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    2e62:	8b 81       	ldd	r24, Y+3	; 0x03
    2e64:	9c 81       	ldd	r25, Y+4	; 0x04
    2e66:	28 e1       	ldi	r18, 0x18	; 24
    2e68:	fc 01       	movw	r30, r24
    2e6a:	20 83       	st	Z, r18
	pxTopOfStack--;
    2e6c:	8b 81       	ldd	r24, Y+3	; 0x03
    2e6e:	9c 81       	ldd	r25, Y+4	; 0x04
    2e70:	01 97       	sbiw	r24, 0x01	; 1
    2e72:	9c 83       	std	Y+4, r25	; 0x04
    2e74:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    2e76:	8b 81       	ldd	r24, Y+3	; 0x03
    2e78:	9c 81       	ldd	r25, Y+4	; 0x04
    2e7a:	29 e1       	ldi	r18, 0x19	; 25
    2e7c:	fc 01       	movw	r30, r24
    2e7e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2e80:	8b 81       	ldd	r24, Y+3	; 0x03
    2e82:	9c 81       	ldd	r25, Y+4	; 0x04
    2e84:	01 97       	sbiw	r24, 0x01	; 1
    2e86:	9c 83       	std	Y+4, r25	; 0x04
    2e88:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    2e8a:	8b 81       	ldd	r24, Y+3	; 0x03
    2e8c:	9c 81       	ldd	r25, Y+4	; 0x04
    2e8e:	20 e2       	ldi	r18, 0x20	; 32
    2e90:	fc 01       	movw	r30, r24
    2e92:	20 83       	st	Z, r18
	pxTopOfStack--;
    2e94:	8b 81       	ldd	r24, Y+3	; 0x03
    2e96:	9c 81       	ldd	r25, Y+4	; 0x04
    2e98:	01 97       	sbiw	r24, 0x01	; 1
    2e9a:	9c 83       	std	Y+4, r25	; 0x04
    2e9c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    2e9e:	8b 81       	ldd	r24, Y+3	; 0x03
    2ea0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ea2:	21 e2       	ldi	r18, 0x21	; 33
    2ea4:	fc 01       	movw	r30, r24
    2ea6:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ea8:	8b 81       	ldd	r24, Y+3	; 0x03
    2eaa:	9c 81       	ldd	r25, Y+4	; 0x04
    2eac:	01 97       	sbiw	r24, 0x01	; 1
    2eae:	9c 83       	std	Y+4, r25	; 0x04
    2eb0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    2eb2:	8b 81       	ldd	r24, Y+3	; 0x03
    2eb4:	9c 81       	ldd	r25, Y+4	; 0x04
    2eb6:	22 e2       	ldi	r18, 0x22	; 34
    2eb8:	fc 01       	movw	r30, r24
    2eba:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ebc:	8b 81       	ldd	r24, Y+3	; 0x03
    2ebe:	9c 81       	ldd	r25, Y+4	; 0x04
    2ec0:	01 97       	sbiw	r24, 0x01	; 1
    2ec2:	9c 83       	std	Y+4, r25	; 0x04
    2ec4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    2ec6:	8b 81       	ldd	r24, Y+3	; 0x03
    2ec8:	9c 81       	ldd	r25, Y+4	; 0x04
    2eca:	23 e2       	ldi	r18, 0x23	; 35
    2ecc:	fc 01       	movw	r30, r24
    2ece:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ed0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ed2:	9c 81       	ldd	r25, Y+4	; 0x04
    2ed4:	01 97       	sbiw	r24, 0x01	; 1
    2ed6:	9c 83       	std	Y+4, r25	; 0x04
    2ed8:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    2eda:	8f 81       	ldd	r24, Y+7	; 0x07
    2edc:	98 85       	ldd	r25, Y+8	; 0x08
    2ede:	9a 83       	std	Y+2, r25	; 0x02
    2ee0:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2ee2:	29 81       	ldd	r18, Y+1	; 0x01
    2ee4:	8b 81       	ldd	r24, Y+3	; 0x03
    2ee6:	9c 81       	ldd	r25, Y+4	; 0x04
    2ee8:	fc 01       	movw	r30, r24
    2eea:	20 83       	st	Z, r18
	pxTopOfStack--;
    2eec:	8b 81       	ldd	r24, Y+3	; 0x03
    2eee:	9c 81       	ldd	r25, Y+4	; 0x04
    2ef0:	01 97       	sbiw	r24, 0x01	; 1
    2ef2:	9c 83       	std	Y+4, r25	; 0x04
    2ef4:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2ef6:	89 81       	ldd	r24, Y+1	; 0x01
    2ef8:	9a 81       	ldd	r25, Y+2	; 0x02
    2efa:	89 2f       	mov	r24, r25
    2efc:	99 27       	eor	r25, r25
    2efe:	9a 83       	std	Y+2, r25	; 0x02
    2f00:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2f02:	29 81       	ldd	r18, Y+1	; 0x01
    2f04:	8b 81       	ldd	r24, Y+3	; 0x03
    2f06:	9c 81       	ldd	r25, Y+4	; 0x04
    2f08:	fc 01       	movw	r30, r24
    2f0a:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f0c:	8b 81       	ldd	r24, Y+3	; 0x03
    2f0e:	9c 81       	ldd	r25, Y+4	; 0x04
    2f10:	01 97       	sbiw	r24, 0x01	; 1
    2f12:	9c 83       	std	Y+4, r25	; 0x04
    2f14:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    2f16:	8b 81       	ldd	r24, Y+3	; 0x03
    2f18:	9c 81       	ldd	r25, Y+4	; 0x04
    2f1a:	26 e2       	ldi	r18, 0x26	; 38
    2f1c:	fc 01       	movw	r30, r24
    2f1e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f20:	8b 81       	ldd	r24, Y+3	; 0x03
    2f22:	9c 81       	ldd	r25, Y+4	; 0x04
    2f24:	01 97       	sbiw	r24, 0x01	; 1
    2f26:	9c 83       	std	Y+4, r25	; 0x04
    2f28:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    2f2a:	8b 81       	ldd	r24, Y+3	; 0x03
    2f2c:	9c 81       	ldd	r25, Y+4	; 0x04
    2f2e:	27 e2       	ldi	r18, 0x27	; 39
    2f30:	fc 01       	movw	r30, r24
    2f32:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f34:	8b 81       	ldd	r24, Y+3	; 0x03
    2f36:	9c 81       	ldd	r25, Y+4	; 0x04
    2f38:	01 97       	sbiw	r24, 0x01	; 1
    2f3a:	9c 83       	std	Y+4, r25	; 0x04
    2f3c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    2f3e:	8b 81       	ldd	r24, Y+3	; 0x03
    2f40:	9c 81       	ldd	r25, Y+4	; 0x04
    2f42:	28 e2       	ldi	r18, 0x28	; 40
    2f44:	fc 01       	movw	r30, r24
    2f46:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f48:	8b 81       	ldd	r24, Y+3	; 0x03
    2f4a:	9c 81       	ldd	r25, Y+4	; 0x04
    2f4c:	01 97       	sbiw	r24, 0x01	; 1
    2f4e:	9c 83       	std	Y+4, r25	; 0x04
    2f50:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    2f52:	8b 81       	ldd	r24, Y+3	; 0x03
    2f54:	9c 81       	ldd	r25, Y+4	; 0x04
    2f56:	29 e2       	ldi	r18, 0x29	; 41
    2f58:	fc 01       	movw	r30, r24
    2f5a:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f5c:	8b 81       	ldd	r24, Y+3	; 0x03
    2f5e:	9c 81       	ldd	r25, Y+4	; 0x04
    2f60:	01 97       	sbiw	r24, 0x01	; 1
    2f62:	9c 83       	std	Y+4, r25	; 0x04
    2f64:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    2f66:	8b 81       	ldd	r24, Y+3	; 0x03
    2f68:	9c 81       	ldd	r25, Y+4	; 0x04
    2f6a:	20 e3       	ldi	r18, 0x30	; 48
    2f6c:	fc 01       	movw	r30, r24
    2f6e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f70:	8b 81       	ldd	r24, Y+3	; 0x03
    2f72:	9c 81       	ldd	r25, Y+4	; 0x04
    2f74:	01 97       	sbiw	r24, 0x01	; 1
    2f76:	9c 83       	std	Y+4, r25	; 0x04
    2f78:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    2f7a:	8b 81       	ldd	r24, Y+3	; 0x03
    2f7c:	9c 81       	ldd	r25, Y+4	; 0x04
    2f7e:	21 e3       	ldi	r18, 0x31	; 49
    2f80:	fc 01       	movw	r30, r24
    2f82:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f84:	8b 81       	ldd	r24, Y+3	; 0x03
    2f86:	9c 81       	ldd	r25, Y+4	; 0x04
    2f88:	01 97       	sbiw	r24, 0x01	; 1
    2f8a:	9c 83       	std	Y+4, r25	; 0x04
    2f8c:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    2f8e:	8b 81       	ldd	r24, Y+3	; 0x03
    2f90:	9c 81       	ldd	r25, Y+4	; 0x04
}
    2f92:	28 96       	adiw	r28, 0x08	; 8
    2f94:	0f b6       	in	r0, 0x3f	; 63
    2f96:	f8 94       	cli
    2f98:	de bf       	out	0x3e, r29	; 62
    2f9a:	0f be       	out	0x3f, r0	; 63
    2f9c:	cd bf       	out	0x3d, r28	; 61
    2f9e:	df 91       	pop	r29
    2fa0:	cf 91       	pop	r28
    2fa2:	08 95       	ret

00002fa4 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    2fa4:	cf 93       	push	r28
    2fa6:	df 93       	push	r29
    2fa8:	cd b7       	in	r28, 0x3d	; 61
    2faa:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    2fac:	0e 94 d6 18 	call	0x31ac	; 0x31ac <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2fb0:	a0 91 1c 02 	lds	r26, 0x021C
    2fb4:	b0 91 1d 02 	lds	r27, 0x021D
    2fb8:	cd 91       	ld	r28, X+
    2fba:	cd bf       	out	0x3d, r28	; 61
    2fbc:	dd 91       	ld	r29, X+
    2fbe:	de bf       	out	0x3e, r29	; 62
    2fc0:	ff 91       	pop	r31
    2fc2:	ef 91       	pop	r30
    2fc4:	df 91       	pop	r29
    2fc6:	cf 91       	pop	r28
    2fc8:	bf 91       	pop	r27
    2fca:	af 91       	pop	r26
    2fcc:	9f 91       	pop	r25
    2fce:	8f 91       	pop	r24
    2fd0:	7f 91       	pop	r23
    2fd2:	6f 91       	pop	r22
    2fd4:	5f 91       	pop	r21
    2fd6:	4f 91       	pop	r20
    2fd8:	3f 91       	pop	r19
    2fda:	2f 91       	pop	r18
    2fdc:	1f 91       	pop	r17
    2fde:	0f 91       	pop	r16
    2fe0:	ff 90       	pop	r15
    2fe2:	ef 90       	pop	r14
    2fe4:	df 90       	pop	r13
    2fe6:	cf 90       	pop	r12
    2fe8:	bf 90       	pop	r11
    2fea:	af 90       	pop	r10
    2fec:	9f 90       	pop	r9
    2fee:	8f 90       	pop	r8
    2ff0:	7f 90       	pop	r7
    2ff2:	6f 90       	pop	r6
    2ff4:	5f 90       	pop	r5
    2ff6:	4f 90       	pop	r4
    2ff8:	3f 90       	pop	r3
    2ffa:	2f 90       	pop	r2
    2ffc:	1f 90       	pop	r1
    2ffe:	0f 90       	pop	r0
    3000:	0c be       	out	0x3c, r0	; 60
    3002:	0f 90       	pop	r0
    3004:	0b be       	out	0x3b, r0	; 59
    3006:	0f 90       	pop	r0
    3008:	0f be       	out	0x3f, r0	; 63
    300a:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    300c:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    300e:	81 e0       	ldi	r24, 0x01	; 1
}
    3010:	df 91       	pop	r29
    3012:	cf 91       	pop	r28
    3014:	08 95       	ret

00003016 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    3016:	cf 93       	push	r28
    3018:	df 93       	push	r29
    301a:	cd b7       	in	r28, 0x3d	; 61
    301c:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    301e:	df 91       	pop	r29
    3020:	cf 91       	pop	r28
    3022:	08 95       	ret

00003024 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    3024:	0f 92       	push	r0
    3026:	0f b6       	in	r0, 0x3f	; 63
    3028:	f8 94       	cli
    302a:	0f 92       	push	r0
    302c:	0b b6       	in	r0, 0x3b	; 59
    302e:	0f 92       	push	r0
    3030:	0c b6       	in	r0, 0x3c	; 60
    3032:	0f 92       	push	r0
    3034:	1f 92       	push	r1
    3036:	11 24       	eor	r1, r1
    3038:	2f 92       	push	r2
    303a:	3f 92       	push	r3
    303c:	4f 92       	push	r4
    303e:	5f 92       	push	r5
    3040:	6f 92       	push	r6
    3042:	7f 92       	push	r7
    3044:	8f 92       	push	r8
    3046:	9f 92       	push	r9
    3048:	af 92       	push	r10
    304a:	bf 92       	push	r11
    304c:	cf 92       	push	r12
    304e:	df 92       	push	r13
    3050:	ef 92       	push	r14
    3052:	ff 92       	push	r15
    3054:	0f 93       	push	r16
    3056:	1f 93       	push	r17
    3058:	2f 93       	push	r18
    305a:	3f 93       	push	r19
    305c:	4f 93       	push	r20
    305e:	5f 93       	push	r21
    3060:	6f 93       	push	r22
    3062:	7f 93       	push	r23
    3064:	8f 93       	push	r24
    3066:	9f 93       	push	r25
    3068:	af 93       	push	r26
    306a:	bf 93       	push	r27
    306c:	cf 93       	push	r28
    306e:	df 93       	push	r29
    3070:	ef 93       	push	r30
    3072:	ff 93       	push	r31
    3074:	a0 91 1c 02 	lds	r26, 0x021C
    3078:	b0 91 1d 02 	lds	r27, 0x021D
    307c:	0d b6       	in	r0, 0x3d	; 61
    307e:	0d 92       	st	X+, r0
    3080:	0e b6       	in	r0, 0x3e	; 62
    3082:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    3084:	0e 94 32 07 	call	0xe64	; 0xe64 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3088:	a0 91 1c 02 	lds	r26, 0x021C
    308c:	b0 91 1d 02 	lds	r27, 0x021D
    3090:	cd 91       	ld	r28, X+
    3092:	cd bf       	out	0x3d, r28	; 61
    3094:	dd 91       	ld	r29, X+
    3096:	de bf       	out	0x3e, r29	; 62
    3098:	ff 91       	pop	r31
    309a:	ef 91       	pop	r30
    309c:	df 91       	pop	r29
    309e:	cf 91       	pop	r28
    30a0:	bf 91       	pop	r27
    30a2:	af 91       	pop	r26
    30a4:	9f 91       	pop	r25
    30a6:	8f 91       	pop	r24
    30a8:	7f 91       	pop	r23
    30aa:	6f 91       	pop	r22
    30ac:	5f 91       	pop	r21
    30ae:	4f 91       	pop	r20
    30b0:	3f 91       	pop	r19
    30b2:	2f 91       	pop	r18
    30b4:	1f 91       	pop	r17
    30b6:	0f 91       	pop	r16
    30b8:	ff 90       	pop	r15
    30ba:	ef 90       	pop	r14
    30bc:	df 90       	pop	r13
    30be:	cf 90       	pop	r12
    30c0:	bf 90       	pop	r11
    30c2:	af 90       	pop	r10
    30c4:	9f 90       	pop	r9
    30c6:	8f 90       	pop	r8
    30c8:	7f 90       	pop	r7
    30ca:	6f 90       	pop	r6
    30cc:	5f 90       	pop	r5
    30ce:	4f 90       	pop	r4
    30d0:	3f 90       	pop	r3
    30d2:	2f 90       	pop	r2
    30d4:	1f 90       	pop	r1
    30d6:	0f 90       	pop	r0
    30d8:	0c be       	out	0x3c, r0	; 60
    30da:	0f 90       	pop	r0
    30dc:	0b be       	out	0x3b, r0	; 59
    30de:	0f 90       	pop	r0
    30e0:	0f be       	out	0x3f, r0	; 63
    30e2:	0f 90       	pop	r0

	asm volatile ( "ret" );
    30e4:	08 95       	ret

000030e6 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    30e6:	0f 92       	push	r0
    30e8:	0f b6       	in	r0, 0x3f	; 63
    30ea:	f8 94       	cli
    30ec:	0f 92       	push	r0
    30ee:	0b b6       	in	r0, 0x3b	; 59
    30f0:	0f 92       	push	r0
    30f2:	0c b6       	in	r0, 0x3c	; 60
    30f4:	0f 92       	push	r0
    30f6:	1f 92       	push	r1
    30f8:	11 24       	eor	r1, r1
    30fa:	2f 92       	push	r2
    30fc:	3f 92       	push	r3
    30fe:	4f 92       	push	r4
    3100:	5f 92       	push	r5
    3102:	6f 92       	push	r6
    3104:	7f 92       	push	r7
    3106:	8f 92       	push	r8
    3108:	9f 92       	push	r9
    310a:	af 92       	push	r10
    310c:	bf 92       	push	r11
    310e:	cf 92       	push	r12
    3110:	df 92       	push	r13
    3112:	ef 92       	push	r14
    3114:	ff 92       	push	r15
    3116:	0f 93       	push	r16
    3118:	1f 93       	push	r17
    311a:	2f 93       	push	r18
    311c:	3f 93       	push	r19
    311e:	4f 93       	push	r20
    3120:	5f 93       	push	r21
    3122:	6f 93       	push	r22
    3124:	7f 93       	push	r23
    3126:	8f 93       	push	r24
    3128:	9f 93       	push	r25
    312a:	af 93       	push	r26
    312c:	bf 93       	push	r27
    312e:	cf 93       	push	r28
    3130:	df 93       	push	r29
    3132:	ef 93       	push	r30
    3134:	ff 93       	push	r31
    3136:	a0 91 1c 02 	lds	r26, 0x021C
    313a:	b0 91 1d 02 	lds	r27, 0x021D
    313e:	0d b6       	in	r0, 0x3d	; 61
    3140:	0d 92       	st	X+, r0
    3142:	0e b6       	in	r0, 0x3e	; 62
    3144:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    3146:	0e 94 4d 06 	call	0xc9a	; 0xc9a <vTaskIncrementTick>
	vTaskSwitchContext();
    314a:	0e 94 32 07 	call	0xe64	; 0xe64 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    314e:	a0 91 1c 02 	lds	r26, 0x021C
    3152:	b0 91 1d 02 	lds	r27, 0x021D
    3156:	cd 91       	ld	r28, X+
    3158:	cd bf       	out	0x3d, r28	; 61
    315a:	dd 91       	ld	r29, X+
    315c:	de bf       	out	0x3e, r29	; 62
    315e:	ff 91       	pop	r31
    3160:	ef 91       	pop	r30
    3162:	df 91       	pop	r29
    3164:	cf 91       	pop	r28
    3166:	bf 91       	pop	r27
    3168:	af 91       	pop	r26
    316a:	9f 91       	pop	r25
    316c:	8f 91       	pop	r24
    316e:	7f 91       	pop	r23
    3170:	6f 91       	pop	r22
    3172:	5f 91       	pop	r21
    3174:	4f 91       	pop	r20
    3176:	3f 91       	pop	r19
    3178:	2f 91       	pop	r18
    317a:	1f 91       	pop	r17
    317c:	0f 91       	pop	r16
    317e:	ff 90       	pop	r15
    3180:	ef 90       	pop	r14
    3182:	df 90       	pop	r13
    3184:	cf 90       	pop	r12
    3186:	bf 90       	pop	r11
    3188:	af 90       	pop	r10
    318a:	9f 90       	pop	r9
    318c:	8f 90       	pop	r8
    318e:	7f 90       	pop	r7
    3190:	6f 90       	pop	r6
    3192:	5f 90       	pop	r5
    3194:	4f 90       	pop	r4
    3196:	3f 90       	pop	r3
    3198:	2f 90       	pop	r2
    319a:	1f 90       	pop	r1
    319c:	0f 90       	pop	r0
    319e:	0c be       	out	0x3c, r0	; 60
    31a0:	0f 90       	pop	r0
    31a2:	0b be       	out	0x3b, r0	; 59
    31a4:	0f 90       	pop	r0
    31a6:	0f be       	out	0x3f, r0	; 63
    31a8:	0f 90       	pop	r0

	asm volatile ( "ret" );
    31aa:	08 95       	ret

000031ac <prvSetupTimerInterrupt>:

/*
 * Setup timer 0 or 3 or 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    31ac:	cf 93       	push	r28
    31ae:	df 93       	push	r29
    31b0:	00 d0       	rcall	.+0      	; 0x31b2 <prvSetupTimerInterrupt+0x6>
    31b2:	00 d0       	rcall	.+0      	; 0x31b4 <prvSetupTimerInterrupt+0x8>
    31b4:	cd b7       	in	r28, 0x3d	; 61
    31b6:	de b7       	in	r29, 0x3e	; 62

    /* Using 8bit Timer0 or 16bit Timer1 or Timer3 to generate the tick. */

    // ulCompareMatch 40,000 = 20,000,000 / 500; 20MHz
    // ulCompareMatch 110,592 = 22,118,400 / 200; 22.1184 MHz
    ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    31b8:	80 e0       	ldi	r24, 0x00	; 0
    31ba:	9d e7       	ldi	r25, 0x7D	; 125
    31bc:	a0 e0       	ldi	r26, 0x00	; 0
    31be:	b0 e0       	ldi	r27, 0x00	; 0
    31c0:	89 83       	std	Y+1, r24	; 0x01
    31c2:	9a 83       	std	Y+2, r25	; 0x02
    31c4:	ab 83       	std	Y+3, r26	; 0x03
    31c6:	bc 83       	std	Y+4, r27	; 0x04

    /* We only have 8 or 16 bits so have to scale 64 or 256 to get our required tick rate. */
    //ulCompareMatch = 625 /= portCLOCK_PRESCALER; 20MHz with 64 prescale
    //ulCompareMatch = 108 /= portCLOCK_PRESCALER; 22.1184 MHz with 1024 prescale
    ulCompareMatch /= portCLOCK_PRESCALER;
    31c8:	89 81       	ldd	r24, Y+1	; 0x01
    31ca:	9a 81       	ldd	r25, Y+2	; 0x02
    31cc:	ab 81       	ldd	r26, Y+3	; 0x03
    31ce:	bc 81       	ldd	r27, Y+4	; 0x04
    31d0:	68 94       	set
    31d2:	15 f8       	bld	r1, 5
    31d4:	b6 95       	lsr	r27
    31d6:	a7 95       	ror	r26
    31d8:	97 95       	ror	r25
    31da:	87 95       	ror	r24
    31dc:	16 94       	lsr	r1
    31de:	d1 f7       	brne	.-12     	; 0x31d4 <prvSetupTimerInterrupt+0x28>
    31e0:	89 83       	std	Y+1, r24	; 0x01
    31e2:	9a 83       	std	Y+2, r25	; 0x02
    31e4:	ab 83       	std	Y+3, r26	; 0x03
    31e6:	bc 83       	std	Y+4, r27	; 0x04

    /* Adjust for correct value. */
    ulCompareMatch -= ( unsigned portLONG ) 1;
    31e8:	89 81       	ldd	r24, Y+1	; 0x01
    31ea:	9a 81       	ldd	r25, Y+2	; 0x02
    31ec:	ab 81       	ldd	r26, Y+3	; 0x03
    31ee:	bc 81       	ldd	r27, Y+4	; 0x04
    31f0:	01 97       	sbiw	r24, 0x01	; 1
    31f2:	a1 09       	sbc	r26, r1
    31f4:	b1 09       	sbc	r27, r1
    31f6:	89 83       	std	Y+1, r24	; 0x01
    31f8:	9a 83       	std	Y+2, r25	; 0x02
    31fa:	ab 83       	std	Y+3, r26	; 0x03
    31fc:	bc 83       	std	Y+4, r27	; 0x04

    /* Setup compare match value for compare match A.  Interrupts are disabled
    before this is called so we need not worry here. */
    ucLowByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
    31fe:	89 81       	ldd	r24, Y+1	; 0x01
    3200:	8d 83       	std	Y+5, r24	; 0x05
    //  OCR3AL = ucLowByte;

    // the HiByte is only needed, if a 16 Bit counter is being utilized
#ifdef portOCRH

    ulCompareMatch >>= 8;
    3202:	89 81       	ldd	r24, Y+1	; 0x01
    3204:	9a 81       	ldd	r25, Y+2	; 0x02
    3206:	ab 81       	ldd	r26, Y+3	; 0x03
    3208:	bc 81       	ldd	r27, Y+4	; 0x04
    320a:	89 2f       	mov	r24, r25
    320c:	9a 2f       	mov	r25, r26
    320e:	ab 2f       	mov	r26, r27
    3210:	bb 27       	eor	r27, r27
    3212:	89 83       	std	Y+1, r24	; 0x01
    3214:	9a 83       	std	Y+2, r25	; 0x02
    3216:	ab 83       	std	Y+3, r26	; 0x03
    3218:	bc 83       	std	Y+4, r27	; 0x04
    ucHighByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
    321a:	89 81       	ldd	r24, Y+1	; 0x01
    321c:	8e 83       	std	Y+6, r24	; 0x06
    portOCRH = ucHighByte;
    321e:	89 e9       	ldi	r24, 0x99	; 153
    3220:	90 e0       	ldi	r25, 0x00	; 0
    3222:	2e 81       	ldd	r18, Y+6	; 0x06
    3224:	fc 01       	movw	r30, r24
    3226:	20 83       	st	Z, r18

#endif

    portOCRL = ucLowByte;
    3228:	88 e9       	ldi	r24, 0x98	; 152
    322a:	90 e0       	ldi	r25, 0x00	; 0
    322c:	2d 81       	ldd	r18, Y+5	; 0x05
    322e:	fc 01       	movw	r30, r24
    3230:	20 83       	st	Z, r18
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	portTCCRb = ucLowByte;

#elif defined( portUSE_TIMER3 )
	/* Setup clock source and compare match behaviour. Assuming  640 / 1280 /1281 / 1284p / 2560 / 2561 (with Timer3) */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    3232:	8b e0       	ldi	r24, 0x0B	; 11
    3234:	8d 83       	std	Y+5, r24	; 0x05
	portTCCRb = ucLowByte;
    3236:	81 e9       	ldi	r24, 0x91	; 145
    3238:	90 e0       	ldi	r25, 0x00	; 0
    323a:	2d 81       	ldd	r18, Y+5	; 0x05
    323c:	fc 01       	movw	r30, r24
    323e:	20 83       	st	Z, r18
#endif

    /* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
    ucLowByte = portTIMSK;
    3240:	81 e7       	ldi	r24, 0x71	; 113
    3242:	90 e0       	ldi	r25, 0x00	; 0
    3244:	fc 01       	movw	r30, r24
    3246:	80 81       	ld	r24, Z
    3248:	8d 83       	std	Y+5, r24	; 0x05
    ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    324a:	8d 81       	ldd	r24, Y+5	; 0x05
    324c:	82 60       	ori	r24, 0x02	; 2
    324e:	8d 83       	std	Y+5, r24	; 0x05
    portTIMSK = ucLowByte;
    3250:	81 e7       	ldi	r24, 0x71	; 113
    3252:	90 e0       	ldi	r25, 0x00	; 0
    3254:	2d 81       	ldd	r18, Y+5	; 0x05
    3256:	fc 01       	movw	r30, r24
    3258:	20 83       	st	Z, r18

}
    325a:	26 96       	adiw	r28, 0x06	; 6
    325c:	0f b6       	in	r0, 0x3f	; 63
    325e:	f8 94       	cli
    3260:	de bf       	out	0x3e, r29	; 62
    3262:	0f be       	out	0x3f, r0	; 63
    3264:	cd bf       	out	0x3d, r28	; 61
    3266:	df 91       	pop	r29
    3268:	cf 91       	pop	r28
    326a:	08 95       	ret

0000326c <__vector_32>:

	#elif defined( portUSE_TIMER3 )
		#warning "Timer3 used for PRE-EMPTIVE scheduler."
		ISR(TIMER3_COMPA_vect, ISR_NAKED)
		{
			vPortYieldFromTick();
    326c:	0e 94 73 18 	call	0x30e6	; 0x30e6 <vPortYieldFromTick>
			asm volatile ( "reti" );
    3270:	18 95       	reti

00003272 <USART_Init>:
*  the specified baud rate and clk speed.
*
* Param buadin: The desired Baud rate.
* Param clk_seedin: The clk speed of the ATmega328p
************************************/
void USART_Init(uint16_t baudin, uint32_t clk_speedin) {
    3272:	cf 93       	push	r28
    3274:	df 93       	push	r29
    3276:	cd b7       	in	r28, 0x3d	; 61
    3278:	de b7       	in	r29, 0x3e	; 62
    327a:	2e 97       	sbiw	r28, 0x0e	; 14
    327c:	0f b6       	in	r0, 0x3f	; 63
    327e:	f8 94       	cli
    3280:	de bf       	out	0x3e, r29	; 62
    3282:	0f be       	out	0x3f, r0	; 63
    3284:	cd bf       	out	0x3d, r28	; 61
    3286:	9e 83       	std	Y+6, r25	; 0x06
    3288:	8d 83       	std	Y+5, r24	; 0x05
    328a:	4f 83       	std	Y+7, r20	; 0x07
    328c:	58 87       	std	Y+8, r21	; 0x08
    328e:	69 87       	std	Y+9, r22	; 0x09
    3290:	7a 87       	std	Y+10, r23	; 0x0a
    USART_WriteQueue = xQueueCreate(32,sizeof(uint8_t));
    3292:	40 e0       	ldi	r20, 0x00	; 0
    3294:	61 e0       	ldi	r22, 0x01	; 1
    3296:	80 e2       	ldi	r24, 0x20	; 32
    3298:	0e 94 15 0c 	call	0x182a	; 0x182a <xQueueGenericCreate>
    329c:	90 93 b7 1a 	sts	0x1AB7, r25
    32a0:	80 93 b6 1a 	sts	0x1AB6, r24
    USART_ReadQueue = xQueueCreate(8,sizeof(uint8_t));
    32a4:	40 e0       	ldi	r20, 0x00	; 0
    32a6:	61 e0       	ldi	r22, 0x01	; 1
    32a8:	88 e0       	ldi	r24, 0x08	; 8
    32aa:	0e 94 15 0c 	call	0x182a	; 0x182a <xQueueGenericCreate>
    32ae:	90 93 b5 1a 	sts	0x1AB5, r25
    32b2:	80 93 b4 1a 	sts	0x1AB4, r24

    uint32_t ubrr = clk_speedin/(16UL)/baudin-1;
    32b6:	8f 81       	ldd	r24, Y+7	; 0x07
    32b8:	98 85       	ldd	r25, Y+8	; 0x08
    32ba:	a9 85       	ldd	r26, Y+9	; 0x09
    32bc:	ba 85       	ldd	r27, Y+10	; 0x0a
    32be:	68 94       	set
    32c0:	13 f8       	bld	r1, 3
    32c2:	b6 95       	lsr	r27
    32c4:	a7 95       	ror	r26
    32c6:	97 95       	ror	r25
    32c8:	87 95       	ror	r24
    32ca:	16 94       	lsr	r1
    32cc:	d1 f7       	brne	.-12     	; 0x32c2 <USART_Init+0x50>
    32ce:	2d 81       	ldd	r18, Y+5	; 0x05
    32d0:	3e 81       	ldd	r19, Y+6	; 0x06
    32d2:	99 01       	movw	r18, r18
    32d4:	40 e0       	ldi	r20, 0x00	; 0
    32d6:	50 e0       	ldi	r21, 0x00	; 0
    32d8:	bc 01       	movw	r22, r24
    32da:	cd 01       	movw	r24, r26
    32dc:	0e 94 55 1c 	call	0x38aa	; 0x38aa <__udivmodsi4>
    32e0:	da 01       	movw	r26, r20
    32e2:	c9 01       	movw	r24, r18
    32e4:	01 97       	sbiw	r24, 0x01	; 1
    32e6:	a1 09       	sbc	r26, r1
    32e8:	b1 09       	sbc	r27, r1
    32ea:	89 83       	std	Y+1, r24	; 0x01
    32ec:	9a 83       	std	Y+2, r25	; 0x02
    32ee:	ab 83       	std	Y+3, r26	; 0x03
    32f0:	bc 83       	std	Y+4, r27	; 0x04
    UBRR1H = (unsigned char)(ubrr>>8) ;// & 0x7F;
    32f2:	2d ec       	ldi	r18, 0xCD	; 205
    32f4:	30 e0       	ldi	r19, 0x00	; 0
    32f6:	89 81       	ldd	r24, Y+1	; 0x01
    32f8:	9a 81       	ldd	r25, Y+2	; 0x02
    32fa:	ab 81       	ldd	r26, Y+3	; 0x03
    32fc:	bc 81       	ldd	r27, Y+4	; 0x04
    32fe:	89 2f       	mov	r24, r25
    3300:	9a 2f       	mov	r25, r26
    3302:	ab 2f       	mov	r26, r27
    3304:	bb 27       	eor	r27, r27
    3306:	f9 01       	movw	r30, r18
    3308:	80 83       	st	Z, r24
    UBRR1L = (unsigned char)ubrr;
    330a:	8c ec       	ldi	r24, 0xCC	; 204
    330c:	90 e0       	ldi	r25, 0x00	; 0
    330e:	29 81       	ldd	r18, Y+1	; 0x01
    3310:	fc 01       	movw	r30, r24
    3312:	20 83       	st	Z, r18
    
    //UBRR0H = 0; //115200
    //UBRR0L = 8;

    /* Enable receiver and transmitter */
    UCSR1B = (1<<RXEN1)|(1<<TXEN1);
    3314:	89 ec       	ldi	r24, 0xC9	; 201
    3316:	90 e0       	ldi	r25, 0x00	; 0
    3318:	28 e1       	ldi	r18, 0x18	; 24
    331a:	fc 01       	movw	r30, r24
    331c:	20 83       	st	Z, r18
    /* Set frame format: 8data, 1stop bit */
    UCSR1C = (1<<UCSZ11)|(1<<UCSZ10);
    331e:	8a ec       	ldi	r24, 0xCA	; 202
    3320:	90 e0       	ldi	r25, 0x00	; 0
    3322:	26 e0       	ldi	r18, 0x06	; 6
    3324:	fc 01       	movw	r30, r24
    3326:	20 83       	st	Z, r18
	// clear U2X0 for Synchronous operation
    UCSR1A &= ~(1<<U2X1);
    3328:	88 ec       	ldi	r24, 0xC8	; 200
    332a:	90 e0       	ldi	r25, 0x00	; 0
    332c:	28 ec       	ldi	r18, 0xC8	; 200
    332e:	30 e0       	ldi	r19, 0x00	; 0
    3330:	f9 01       	movw	r30, r18
    3332:	20 81       	ld	r18, Z
    3334:	2d 7f       	andi	r18, 0xFD	; 253
    3336:	fc 01       	movw	r30, r24
    3338:	20 83       	st	Z, r18

    //UCSR0B |= (1<<UDRIE0);

}
    333a:	2e 96       	adiw	r28, 0x0e	; 14
    333c:	0f b6       	in	r0, 0x3f	; 63
    333e:	f8 94       	cli
    3340:	de bf       	out	0x3e, r29	; 62
    3342:	0f be       	out	0x3f, r0	; 63
    3344:	cd bf       	out	0x3d, r28	; 61
    3346:	df 91       	pop	r29
    3348:	cf 91       	pop	r28
    334a:	08 95       	ret

0000334c <USART_Write>:

/*the send function will put 8bits on the trans line. */
void USART_Write(uint8_t data) {
    334c:	cf 93       	push	r28
    334e:	df 93       	push	r29
    3350:	1f 92       	push	r1
    3352:	cd b7       	in	r28, 0x3d	; 61
    3354:	de b7       	in	r29, 0x3e	; 62
    3356:	89 83       	std	Y+1, r24	; 0x01
		/* Wait for empty transmit buffer */
		while ( !( UCSR0A & (1<<UDRE0)) )
    3358:	00 00       	nop
    335a:	80 ec       	ldi	r24, 0xC0	; 192
    335c:	90 e0       	ldi	r25, 0x00	; 0
    335e:	fc 01       	movw	r30, r24
    3360:	80 81       	ld	r24, Z
    3362:	88 2f       	mov	r24, r24
    3364:	90 e0       	ldi	r25, 0x00	; 0
    3366:	80 72       	andi	r24, 0x20	; 32
    3368:	99 27       	eor	r25, r25
    336a:	00 97       	sbiw	r24, 0x00	; 0
    336c:	b1 f3       	breq	.-20     	; 0x335a <USART_Write+0xe>
		;
		/* Put data into buffer, sends the data */
		UDR0 = data;
    336e:	86 ec       	ldi	r24, 0xC6	; 198
    3370:	90 e0       	ldi	r25, 0x00	; 0
    3372:	29 81       	ldd	r18, Y+1	; 0x01
    3374:	fc 01       	movw	r30, r24
    3376:	20 83       	st	Z, r18
}
    3378:	0f 90       	pop	r0
    337a:	df 91       	pop	r29
    337c:	cf 91       	pop	r28
    337e:	08 95       	ret

00003380 <USART_Write_Unprotected>:

/*the send function will put 8bits on the trans line. */
void USART_Write_Unprotected(uint8_t data) {
    3380:	cf 93       	push	r28
    3382:	df 93       	push	r29
    3384:	1f 92       	push	r1
    3386:	cd b7       	in	r28, 0x3d	; 61
    3388:	de b7       	in	r29, 0x3e	; 62
    338a:	89 83       	std	Y+1, r24	; 0x01
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)) )
    338c:	00 00       	nop
    338e:	80 ec       	ldi	r24, 0xC0	; 192
    3390:	90 e0       	ldi	r25, 0x00	; 0
    3392:	fc 01       	movw	r30, r24
    3394:	80 81       	ld	r24, Z
    3396:	88 2f       	mov	r24, r24
    3398:	90 e0       	ldi	r25, 0x00	; 0
    339a:	80 72       	andi	r24, 0x20	; 32
    339c:	99 27       	eor	r25, r25
    339e:	00 97       	sbiw	r24, 0x00	; 0
    33a0:	b1 f3       	breq	.-20     	; 0x338e <USART_Write_Unprotected+0xe>
	;
	/* Put data into buffer, sends the data */
	UDR0 = data;
    33a2:	86 ec       	ldi	r24, 0xC6	; 198
    33a4:	90 e0       	ldi	r25, 0x00	; 0
    33a6:	29 81       	ldd	r18, Y+1	; 0x01
    33a8:	fc 01       	movw	r30, r24
    33aa:	20 83       	st	Z, r18
}
    33ac:	0f 90       	pop	r0
    33ae:	df 91       	pop	r29
    33b0:	cf 91       	pop	r28
    33b2:	08 95       	ret

000033b4 <USART_Read>:
Therefore you may not get control back after this is called 
until a much later time. It may be helpful to use the 
istheredata() function to check before calling this function
        @return 8bit data packet from sender
*/
uint8_t USART_Read(void) {
    33b4:	cf 93       	push	r28
    33b6:	df 93       	push	r29
    33b8:	cd b7       	in	r28, 0x3d	; 61
    33ba:	de b7       	in	r29, 0x3e	; 62
    /* Wait for data to be received */
    while ( !(UCSR0A & (1<<RXC0)) )
    33bc:	00 00       	nop
    33be:	80 ec       	ldi	r24, 0xC0	; 192
    33c0:	90 e0       	ldi	r25, 0x00	; 0
    33c2:	fc 01       	movw	r30, r24
    33c4:	80 81       	ld	r24, Z
    33c6:	88 23       	and	r24, r24
    33c8:	d4 f7       	brge	.-12     	; 0x33be <USART_Read+0xa>
        ;
    /* Get and return received data from buffer */
    return UDR0;
    33ca:	86 ec       	ldi	r24, 0xC6	; 198
    33cc:	90 e0       	ldi	r25, 0x00	; 0
    33ce:	fc 01       	movw	r30, r24
    33d0:	80 81       	ld	r24, Z
}
    33d2:	df 91       	pop	r29
    33d4:	cf 91       	pop	r28
    33d6:	08 95       	ret

000033d8 <ISR>:


ISR(USART1_RX_vect){
    33d8:	cf 93       	push	r28
    33da:	df 93       	push	r29
    33dc:	00 d0       	rcall	.+0      	; 0x33de <ISR+0x6>
    33de:	cd b7       	in	r28, 0x3d	; 61
    33e0:	de b7       	in	r29, 0x3e	; 62
    33e2:	9b 83       	std	Y+3, r25	; 0x03
    33e4:	8a 83       	std	Y+2, r24	; 0x02
    uint8_t data;
    data = UDR1;
    33e6:	8e ec       	ldi	r24, 0xCE	; 206
    33e8:	90 e0       	ldi	r25, 0x00	; 0
    33ea:	fc 01       	movw	r30, r24
    33ec:	80 81       	ld	r24, Z
    33ee:	89 83       	std	Y+1, r24	; 0x01
    xQueueSendToBackFromISR(USART_ReadQueue,&data,NULL);
    33f0:	80 91 b4 1a 	lds	r24, 0x1AB4
    33f4:	90 91 b5 1a 	lds	r25, 0x1AB5
    33f8:	20 e0       	ldi	r18, 0x00	; 0
    33fa:	40 e0       	ldi	r20, 0x00	; 0
    33fc:	50 e0       	ldi	r21, 0x00	; 0
    33fe:	be 01       	movw	r22, r28
    3400:	6f 5f       	subi	r22, 0xFF	; 255
    3402:	7f 4f       	sbci	r23, 0xFF	; 255
    3404:	0e 94 70 0d 	call	0x1ae0	; 0x1ae0 <xQueueGenericSendFromISR>
}
    3408:	0f 90       	pop	r0
    340a:	0f 90       	pop	r0
    340c:	0f 90       	pop	r0
    340e:	df 91       	pop	r29
    3410:	cf 91       	pop	r28
    3412:	08 95       	ret

00003414 <USART_AddToQueue>:

void USART_AddToQueue(uint8_t data){
    3414:	cf 93       	push	r28
    3416:	df 93       	push	r29
    3418:	1f 92       	push	r1
    341a:	cd b7       	in	r28, 0x3d	; 61
    341c:	de b7       	in	r29, 0x3e	; 62
    341e:	89 83       	std	Y+1, r24	; 0x01
    
    xQueueSendToBack(USART_WriteQueue,&data,portMAX_DELAY);
    3420:	80 91 b6 1a 	lds	r24, 0x1AB6
    3424:	90 91 b7 1a 	lds	r25, 0x1AB7
    3428:	20 e0       	ldi	r18, 0x00	; 0
    342a:	4f ef       	ldi	r20, 0xFF	; 255
    342c:	5f ef       	ldi	r21, 0xFF	; 255
    342e:	be 01       	movw	r22, r28
    3430:	6f 5f       	subi	r22, 0xFF	; 255
    3432:	7f 4f       	sbci	r23, 0xFF	; 255
    3434:	0e 94 cc 0c 	call	0x1998	; 0x1998 <xQueueGenericSend>

}
    3438:	0f 90       	pop	r0
    343a:	df 91       	pop	r29
    343c:	cf 91       	pop	r28
    343e:	08 95       	ret

00003440 <USART_TransmitString>:

void USART_TransmitString(char* str){
    3440:	cf 93       	push	r28
    3442:	df 93       	push	r29
    3444:	1f 92       	push	r1
    3446:	1f 92       	push	r1
    3448:	cd b7       	in	r28, 0x3d	; 61
    344a:	de b7       	in	r29, 0x3e	; 62
    344c:	9a 83       	std	Y+2, r25	; 0x02
    344e:	89 83       	std	Y+1, r24	; 0x01
    while(*str) {
    3450:	0b c0       	rjmp	.+22     	; 0x3468 <USART_TransmitString+0x28>
        USART_AddToQueue(*str);
    3452:	89 81       	ldd	r24, Y+1	; 0x01
    3454:	9a 81       	ldd	r25, Y+2	; 0x02
    3456:	fc 01       	movw	r30, r24
    3458:	80 81       	ld	r24, Z
    345a:	0e 94 0a 1a 	call	0x3414	; 0x3414 <USART_AddToQueue>
        str++;
    345e:	89 81       	ldd	r24, Y+1	; 0x01
    3460:	9a 81       	ldd	r25, Y+2	; 0x02
    3462:	01 96       	adiw	r24, 0x01	; 1
    3464:	9a 83       	std	Y+2, r25	; 0x02
    3466:	89 83       	std	Y+1, r24	; 0x01
    xQueueSendToBack(USART_WriteQueue,&data,portMAX_DELAY);

}

void USART_TransmitString(char* str){
    while(*str) {
    3468:	89 81       	ldd	r24, Y+1	; 0x01
    346a:	9a 81       	ldd	r25, Y+2	; 0x02
    346c:	fc 01       	movw	r30, r24
    346e:	80 81       	ld	r24, Z
    3470:	88 23       	and	r24, r24
    3472:	79 f7       	brne	.-34     	; 0x3452 <USART_TransmitString+0x12>
        USART_AddToQueue(*str);
        str++;
    }
}
    3474:	0f 90       	pop	r0
    3476:	0f 90       	pop	r0
    3478:	df 91       	pop	r29
    347a:	cf 91       	pop	r28
    347c:	08 95       	ret

0000347e <vTaskUARTWrite>:

void vTaskUARTWrite(void *pvParameters)
{
    347e:	cf 93       	push	r28
    3480:	df 93       	push	r29
    3482:	00 d0       	rcall	.+0      	; 0x3484 <vTaskUARTWrite+0x6>
    3484:	cd b7       	in	r28, 0x3d	; 61
    3486:	de b7       	in	r29, 0x3e	; 62
    3488:	9b 83       	std	Y+3, r25	; 0x03
    348a:	8a 83       	std	Y+2, r24	; 0x02
    uint8_t data;
    while(1){
        while(xQueueReceive(USART_WriteQueue,&data,portMAX_DELAY)==pdFALSE);
    348c:	00 00       	nop
    348e:	80 91 b6 1a 	lds	r24, 0x1AB6
    3492:	90 91 b7 1a 	lds	r25, 0x1AB7
    3496:	20 e0       	ldi	r18, 0x00	; 0
    3498:	4f ef       	ldi	r20, 0xFF	; 255
    349a:	5f ef       	ldi	r21, 0xFF	; 255
    349c:	be 01       	movw	r22, r28
    349e:	6f 5f       	subi	r22, 0xFF	; 255
    34a0:	7f 4f       	sbci	r23, 0xFF	; 255
    34a2:	0e 94 c9 0d 	call	0x1b92	; 0x1b92 <xQueueGenericReceive>
    34a6:	88 23       	and	r24, r24
    34a8:	91 f3       	breq	.-28     	; 0x348e <vTaskUARTWrite+0x10>

        while(!(UCSR1A & (1<<UDRE1))) vTaskDelay(1);
    34aa:	04 c0       	rjmp	.+8      	; 0x34b4 <vTaskUARTWrite+0x36>
    34ac:	81 e0       	ldi	r24, 0x01	; 1
    34ae:	90 e0       	ldi	r25, 0x00	; 0
    34b0:	0e 94 b4 03 	call	0x768	; 0x768 <vTaskDelay>
    34b4:	88 ec       	ldi	r24, 0xC8	; 200
    34b6:	90 e0       	ldi	r25, 0x00	; 0
    34b8:	fc 01       	movw	r30, r24
    34ba:	80 81       	ld	r24, Z
    34bc:	88 2f       	mov	r24, r24
    34be:	90 e0       	ldi	r25, 0x00	; 0
    34c0:	80 72       	andi	r24, 0x20	; 32
    34c2:	99 27       	eor	r25, r25
    34c4:	00 97       	sbiw	r24, 0x00	; 0
    34c6:	91 f3       	breq	.-28     	; 0x34ac <vTaskUARTWrite+0x2e>
        UDR1 = data;
    34c8:	8e ec       	ldi	r24, 0xCE	; 206
    34ca:	90 e0       	ldi	r25, 0x00	; 0
    34cc:	29 81       	ldd	r18, Y+1	; 0x01
    34ce:	fc 01       	movw	r30, r24
    34d0:	20 83       	st	Z, r18

    }
    34d2:	00 00       	nop

void vTaskUARTWrite(void *pvParameters)
{
    uint8_t data;
    while(1){
        while(xQueueReceive(USART_WriteQueue,&data,portMAX_DELAY)==pdFALSE);
    34d4:	db cf       	rjmp	.-74     	; 0x348c <vTaskUARTWrite+0xe>

000034d6 <vTaskUARTRead>:
        UDR1 = data;

    }
}

void vTaskUARTRead(void *pvParameters){
    34d6:	cf 93       	push	r28
    34d8:	df 93       	push	r29
    34da:	cd b7       	in	r28, 0x3d	; 61
    34dc:	de b7       	in	r29, 0x3e	; 62
    34de:	2e 97       	sbiw	r28, 0x0e	; 14
    34e0:	0f b6       	in	r0, 0x3f	; 63
    34e2:	f8 94       	cli
    34e4:	de bf       	out	0x3e, r29	; 62
    34e6:	0f be       	out	0x3f, r0	; 63
    34e8:	cd bf       	out	0x3d, r28	; 61
    34ea:	9e 87       	std	Y+14, r25	; 0x0e
    34ec:	8d 87       	std	Y+13, r24	; 0x0d
    //Command command;
    //Response response;

    while(1){
        //Get Header
        bytesRecieved = 0;
    34ee:	19 82       	std	Y+1, r1	; 0x01
        while(bytesRecieved < 4){
    34f0:	1a c0       	rjmp	.+52     	; 0x3526 <vTaskUARTRead+0x50>
            if((UCSR1A & (1<<RXC1))){
    34f2:	88 ec       	ldi	r24, 0xC8	; 200
    34f4:	90 e0       	ldi	r25, 0x00	; 0
    34f6:	fc 01       	movw	r30, r24
    34f8:	80 81       	ld	r24, Z
    34fa:	88 23       	and	r24, r24
    34fc:	a4 f4       	brge	.+40     	; 0x3526 <vTaskUARTRead+0x50>
                rxData = UDR1;
    34fe:	8e ec       	ldi	r24, 0xCE	; 206
    3500:	90 e0       	ldi	r25, 0x00	; 0
    3502:	fc 01       	movw	r30, r24
    3504:	80 81       	ld	r24, Z
    3506:	8b 83       	std	Y+3, r24	; 0x03
                //PORTB = 0;
            //if(xQueueReceive(USART_ReadQueue,&rxData,portMAX_DELAY) == pdTRUE){
                buffer[bytesRecieved] = rxData;
    3508:	89 81       	ldd	r24, Y+1	; 0x01
    350a:	99 27       	eor	r25, r25
    350c:	87 fd       	sbrc	r24, 7
    350e:	90 95       	com	r25
    3510:	9e 01       	movw	r18, r28
    3512:	2b 5f       	subi	r18, 0xFB	; 251
    3514:	3f 4f       	sbci	r19, 0xFF	; 255
    3516:	82 0f       	add	r24, r18
    3518:	93 1f       	adc	r25, r19
    351a:	2b 81       	ldd	r18, Y+3	; 0x03
    351c:	fc 01       	movw	r30, r24
    351e:	20 83       	st	Z, r18
                //USART_AddToQueue(rxData);
                bytesRecieved++;
    3520:	89 81       	ldd	r24, Y+1	; 0x01
    3522:	8f 5f       	subi	r24, 0xFF	; 255
    3524:	89 83       	std	Y+1, r24	; 0x01
    //Response response;

    while(1){
        //Get Header
        bytesRecieved = 0;
        while(bytesRecieved < 4){
    3526:	89 81       	ldd	r24, Y+1	; 0x01
    3528:	84 30       	cpi	r24, 0x04	; 4
    352a:	1c f3       	brlt	.-58     	; 0x34f2 <vTaskUARTRead+0x1c>
                buffer[bytesRecieved] = rxData;
                //USART_AddToQueue(rxData);
                bytesRecieved++;
            }
        }
        if(calcChecksum(buffer,3) != buffer[3]){
    352c:	ce 01       	movw	r24, r28
    352e:	05 96       	adiw	r24, 0x05	; 5
    3530:	63 e0       	ldi	r22, 0x03	; 3
    3532:	0e 94 0f 1b 	call	0x361e	; 0x361e <calcChecksum>
    3536:	98 2f       	mov	r25, r24
    3538:	88 85       	ldd	r24, Y+8	; 0x08
    353a:	98 17       	cp	r25, r24
    353c:	19 f0       	breq	.+6      	; 0x3544 <vTaskUARTRead+0x6e>
            sendNACK();
    353e:	0e 94 05 1b 	call	0x360a	; 0x360a <sendNACK>
    3542:	58 c0       	rjmp	.+176    	; 0x35f4 <vTaskUARTRead+0x11e>
        } else {
            sendACK();
    3544:	0e 94 fb 1a 	call	0x35f6	; 0x35f6 <sendACK>
            bytesRecieved = 0;
    3548:	19 82       	std	Y+1, r1	; 0x01
            //command.groupID = buffer[0];
            //command.cmd = buffer[1];
            //command.crc = buffer[3];
            size = buffer[2];
    354a:	8f 81       	ldd	r24, Y+7	; 0x07
    354c:	8c 83       	std	Y+4, r24	; 0x04
            timeout = 0;
    354e:	1a 82       	std	Y+2, r1	; 0x02
            while(1){
                if(size == 0){
                    //processCommand(&command,&response);
                }
                while((bytesRecieved < size+1) && (timeout < 50)){  //1 for crc
    3550:	1d c0       	rjmp	.+58     	; 0x358c <vTaskUARTRead+0xb6>
                    if(UCSR1A & (1<<RXC1)){
    3552:	88 ec       	ldi	r24, 0xC8	; 200
    3554:	90 e0       	ldi	r25, 0x00	; 0
    3556:	fc 01       	movw	r30, r24
    3558:	80 81       	ld	r24, Z
    355a:	88 23       	and	r24, r24
    355c:	ac f4       	brge	.+42     	; 0x3588 <vTaskUARTRead+0xb2>
                        rxData = UDR1;
    355e:	8e ec       	ldi	r24, 0xCE	; 206
    3560:	90 e0       	ldi	r25, 0x00	; 0
    3562:	fc 01       	movw	r30, r24
    3564:	80 81       	ld	r24, Z
    3566:	8b 83       	std	Y+3, r24	; 0x03

                        //PORTB = 0xFF;
                    //if(xQueueReceive(USART_ReadQueue,&rxData,portMAX_DELAY) == pdTRUE){
                        buffer[bytesRecieved] = rxData;
    3568:	89 81       	ldd	r24, Y+1	; 0x01
    356a:	99 27       	eor	r25, r25
    356c:	87 fd       	sbrc	r24, 7
    356e:	90 95       	com	r25
    3570:	9e 01       	movw	r18, r28
    3572:	2b 5f       	subi	r18, 0xFB	; 251
    3574:	3f 4f       	sbci	r19, 0xFF	; 255
    3576:	82 0f       	add	r24, r18
    3578:	93 1f       	adc	r25, r19
    357a:	2b 81       	ldd	r18, Y+3	; 0x03
    357c:	fc 01       	movw	r30, r24
    357e:	20 83       	st	Z, r18
                        bytesRecieved++;
    3580:	89 81       	ldd	r24, Y+1	; 0x01
    3582:	8f 5f       	subi	r24, 0xFF	; 255
    3584:	89 83       	std	Y+1, r24	; 0x01
    3586:	02 c0       	rjmp	.+4      	; 0x358c <vTaskUARTRead+0xb6>
                    } else {
                        //timeout++;
                        timeout = 1;
    3588:	81 e0       	ldi	r24, 0x01	; 1
    358a:	8a 83       	std	Y+2, r24	; 0x02
            timeout = 0;
            while(1){
                if(size == 0){
                    //processCommand(&command,&response);
                }
                while((bytesRecieved < size+1) && (timeout < 50)){  //1 for crc
    358c:	89 81       	ldd	r24, Y+1	; 0x01
    358e:	28 2f       	mov	r18, r24
    3590:	33 27       	eor	r19, r19
    3592:	27 fd       	sbrc	r18, 7
    3594:	30 95       	com	r19
    3596:	8c 81       	ldd	r24, Y+4	; 0x04
    3598:	99 27       	eor	r25, r25
    359a:	87 fd       	sbrc	r24, 7
    359c:	90 95       	com	r25
    359e:	01 96       	adiw	r24, 0x01	; 1
    35a0:	28 17       	cp	r18, r24
    35a2:	39 07       	cpc	r19, r25
    35a4:	1c f4       	brge	.+6      	; 0x35ac <vTaskUARTRead+0xd6>
    35a6:	8a 81       	ldd	r24, Y+2	; 0x02
    35a8:	82 33       	cpi	r24, 0x32	; 50
    35aa:	9c f2       	brlt	.-90     	; 0x3552 <vTaskUARTRead+0x7c>
                    } else {
                        //timeout++;
                        timeout = 1;
                    }
                } 
                if(timeout >= 50){
    35ac:	8a 81       	ldd	r24, Y+2	; 0x02
    35ae:	82 33       	cpi	r24, 0x32	; 50
    35b0:	0c f0       	brlt	.+2      	; 0x35b4 <vTaskUARTRead+0xde>
                    break;
    35b2:	20 c0       	rjmp	.+64     	; 0x35f4 <vTaskUARTRead+0x11e>
                }
                if(calcChecksum(buffer,size) != buffer[size]){
    35b4:	2c 81       	ldd	r18, Y+4	; 0x04
    35b6:	ce 01       	movw	r24, r28
    35b8:	05 96       	adiw	r24, 0x05	; 5
    35ba:	62 2f       	mov	r22, r18
    35bc:	0e 94 0f 1b 	call	0x361e	; 0x361e <calcChecksum>
    35c0:	48 2f       	mov	r20, r24
    35c2:	8c 81       	ldd	r24, Y+4	; 0x04
    35c4:	99 27       	eor	r25, r25
    35c6:	87 fd       	sbrc	r24, 7
    35c8:	90 95       	com	r25
    35ca:	9e 01       	movw	r18, r28
    35cc:	2b 5f       	subi	r18, 0xFB	; 251
    35ce:	3f 4f       	sbci	r19, 0xFF	; 255
    35d0:	82 0f       	add	r24, r18
    35d2:	93 1f       	adc	r25, r19
    35d4:	fc 01       	movw	r30, r24
    35d6:	80 81       	ld	r24, Z
    35d8:	48 17       	cp	r20, r24
    35da:	21 f0       	breq	.+8      	; 0x35e4 <vTaskUARTRead+0x10e>
                    sendNACK();
    35dc:	0e 94 05 1b 	call	0x360a	; 0x360a <sendNACK>
                    bytesRecieved = 0;
    35e0:	19 82       	std	Y+1, r1	; 0x01
                    sendACK();
                    //memcpy(command.payload,buffer,size);
                    //processCommand(&command,&response);
                    break;
                }
            }
    35e2:	b6 cf       	rjmp	.-148    	; 0x3550 <vTaskUARTRead+0x7a>
                }
                if(calcChecksum(buffer,size) != buffer[size]){
                    sendNACK();
                    bytesRecieved = 0;
                } else {
                    PORTB = buffer[0];
    35e4:	85 e2       	ldi	r24, 0x25	; 37
    35e6:	90 e0       	ldi	r25, 0x00	; 0
    35e8:	2d 81       	ldd	r18, Y+5	; 0x05
    35ea:	fc 01       	movw	r30, r24
    35ec:	20 83       	st	Z, r18
                    sendACK();
    35ee:	0e 94 fb 1a 	call	0x35f6	; 0x35f6 <sendACK>
                    //memcpy(command.payload,buffer,size);
                    //processCommand(&command,&response);
                    break;
    35f2:	00 00       	nop
                }
            }
        }

    }
    35f4:	7c cf       	rjmp	.-264    	; 0x34ee <vTaskUARTRead+0x18>

000035f6 <sendACK>:

}

void sendACK(){
    35f6:	cf 93       	push	r28
    35f8:	df 93       	push	r29
    35fa:	cd b7       	in	r28, 0x3d	; 61
    35fc:	de b7       	in	r29, 0x3e	; 62
    USART_AddToQueue(0xFF);
    35fe:	8f ef       	ldi	r24, 0xFF	; 255
    3600:	0e 94 0a 1a 	call	0x3414	; 0x3414 <USART_AddToQueue>
}
    3604:	df 91       	pop	r29
    3606:	cf 91       	pop	r28
    3608:	08 95       	ret

0000360a <sendNACK>:

void sendNACK(){
    360a:	cf 93       	push	r28
    360c:	df 93       	push	r29
    360e:	cd b7       	in	r28, 0x3d	; 61
    3610:	de b7       	in	r29, 0x3e	; 62
    USART_AddToQueue(0);
    3612:	80 e0       	ldi	r24, 0x00	; 0
    3614:	0e 94 0a 1a 	call	0x3414	; 0x3414 <USART_AddToQueue>
}
    3618:	df 91       	pop	r29
    361a:	cf 91       	pop	r28
    361c:	08 95       	ret

0000361e <calcChecksum>:

uint8_t calcChecksum(uint8_t* buffer,uint8_t size){
    361e:	cf 93       	push	r28
    3620:	df 93       	push	r29
    3622:	00 d0       	rcall	.+0      	; 0x3624 <calcChecksum+0x6>
    3624:	1f 92       	push	r1
    3626:	cd b7       	in	r28, 0x3d	; 61
    3628:	de b7       	in	r29, 0x3e	; 62
    362a:	9b 83       	std	Y+3, r25	; 0x03
    362c:	8a 83       	std	Y+2, r24	; 0x02
    362e:	6c 83       	std	Y+4, r22	; 0x04
    uint8_t checksum = 0;
    3630:	19 82       	std	Y+1, r1	; 0x01
    while(size-- > 0){
    3632:	0c c0       	rjmp	.+24     	; 0x364c <calcChecksum+0x2e>
        checksum += *(buffer++);
    3634:	8a 81       	ldd	r24, Y+2	; 0x02
    3636:	9b 81       	ldd	r25, Y+3	; 0x03
    3638:	9c 01       	movw	r18, r24
    363a:	2f 5f       	subi	r18, 0xFF	; 255
    363c:	3f 4f       	sbci	r19, 0xFF	; 255
    363e:	3b 83       	std	Y+3, r19	; 0x03
    3640:	2a 83       	std	Y+2, r18	; 0x02
    3642:	fc 01       	movw	r30, r24
    3644:	80 81       	ld	r24, Z
    3646:	99 81       	ldd	r25, Y+1	; 0x01
    3648:	89 0f       	add	r24, r25
    364a:	89 83       	std	Y+1, r24	; 0x01
    USART_AddToQueue(0);
}

uint8_t calcChecksum(uint8_t* buffer,uint8_t size){
    uint8_t checksum = 0;
    while(size-- > 0){
    364c:	8c 81       	ldd	r24, Y+4	; 0x04
    364e:	9f ef       	ldi	r25, 0xFF	; 255
    3650:	98 0f       	add	r25, r24
    3652:	9c 83       	std	Y+4, r25	; 0x04
    3654:	88 23       	and	r24, r24
    3656:	71 f7       	brne	.-36     	; 0x3634 <calcChecksum+0x16>
        checksum += *(buffer++);
    }
    return checksum;
    3658:	89 81       	ldd	r24, Y+1	; 0x01
    365a:	0f 90       	pop	r0
    365c:	0f 90       	pop	r0
    365e:	0f 90       	pop	r0
    3660:	0f 90       	pop	r0
    3662:	df 91       	pop	r29
    3664:	cf 91       	pop	r28
    3666:	08 95       	ret

00003668 <setSonarData>:
extern int count;

unsigned char currSonar;
unsigned char lastSonarData = 0;
	
void setSonarData(int i,unsigned char data){
    3668:	cf 93       	push	r28
    366a:	df 93       	push	r29
    366c:	00 d0       	rcall	.+0      	; 0x366e <setSonarData+0x6>
    366e:	cd b7       	in	r28, 0x3d	; 61
    3670:	de b7       	in	r29, 0x3e	; 62
    3672:	9a 83       	std	Y+2, r25	; 0x02
    3674:	89 83       	std	Y+1, r24	; 0x01
    3676:	6b 83       	std	Y+3, r22	; 0x03
//	xSemaphoreTake(sonarDataMutex[i],portMAX_DELAY);
	sonarData[i] = data;
    3678:	89 81       	ldd	r24, Y+1	; 0x01
    367a:	9a 81       	ldd	r25, Y+2	; 0x02
    367c:	88 54       	subi	r24, 0x48	; 72
    367e:	95 4e       	sbci	r25, 0xE5	; 229
    3680:	2b 81       	ldd	r18, Y+3	; 0x03
    3682:	fc 01       	movw	r30, r24
    3684:	20 83       	st	Z, r18
	//xSemaphoreGive(sonarDataMutex[i]);
}
    3686:	0f 90       	pop	r0
    3688:	0f 90       	pop	r0
    368a:	0f 90       	pop	r0
    368c:	df 91       	pop	r29
    368e:	cf 91       	pop	r28
    3690:	08 95       	ret

00003692 <getSonarData>:

unsigned char getSonarData(int i){
    3692:	cf 93       	push	r28
    3694:	df 93       	push	r29
    3696:	1f 92       	push	r1
    3698:	1f 92       	push	r1
    369a:	cd b7       	in	r28, 0x3d	; 61
    369c:	de b7       	in	r29, 0x3e	; 62
    369e:	9a 83       	std	Y+2, r25	; 0x02
    36a0:	89 83       	std	Y+1, r24	; 0x01
	//xSemaphoreTake(sonarDataMutex[i],portMAX_DELAY);
	return sonarData[i];
    36a2:	89 81       	ldd	r24, Y+1	; 0x01
    36a4:	9a 81       	ldd	r25, Y+2	; 0x02
    36a6:	88 54       	subi	r24, 0x48	; 72
    36a8:	95 4e       	sbci	r25, 0xE5	; 229
    36aa:	fc 01       	movw	r30, r24
    36ac:	80 81       	ld	r24, Z
	//xSemaphoreGive(sonarDataMutex[i]);
}
    36ae:	0f 90       	pop	r0
    36b0:	0f 90       	pop	r0
    36b2:	df 91       	pop	r29
    36b4:	cf 91       	pop	r28
    36b6:	08 95       	ret

000036b8 <getTimerCount>:

unsigned char getTimerCount(){
    36b8:	cf 93       	push	r28
    36ba:	df 93       	push	r29
    36bc:	cd b7       	in	r28, 0x3d	; 61
    36be:	de b7       	in	r29, 0x3e	; 62
	return TCNT0;
    36c0:	86 e4       	ldi	r24, 0x46	; 70
    36c2:	90 e0       	ldi	r25, 0x00	; 0
    36c4:	fc 01       	movw	r30, r24
    36c6:	80 81       	ld	r24, Z
}
    36c8:	df 91       	pop	r29
    36ca:	cf 91       	pop	r28
    36cc:	08 95       	ret

000036ce <__vector_11>:

inline void setTimerCount(unsigned char i){
	TCNT0 = i;
}

ISR(PCINT2_vect) {
    36ce:	1f 92       	push	r1
    36d0:	0f 92       	push	r0
    36d2:	00 90 5f 00 	lds	r0, 0x005F
    36d6:	0f 92       	push	r0
    36d8:	11 24       	eor	r1, r1
    36da:	00 90 5b 00 	lds	r0, 0x005B
    36de:	0f 92       	push	r0
    36e0:	2f 93       	push	r18
    36e2:	3f 93       	push	r19
    36e4:	4f 93       	push	r20
    36e6:	5f 93       	push	r21
    36e8:	6f 93       	push	r22
    36ea:	7f 93       	push	r23
    36ec:	8f 93       	push	r24
    36ee:	9f 93       	push	r25
    36f0:	af 93       	push	r26
    36f2:	bf 93       	push	r27
    36f4:	ef 93       	push	r30
    36f6:	ff 93       	push	r31
    36f8:	cf 93       	push	r28
    36fa:	df 93       	push	r29
    36fc:	00 d0       	rcall	.+0      	; 0x36fe <__vector_11+0x30>
    36fe:	cd b7       	in	r28, 0x3d	; 61
    3700:	de b7       	in	r29, 0x3e	; 62

	unsigned char beginCount;
	unsigned char currCount;
	char i=0;	
    3702:	19 82       	std	Y+1, r1	; 0x01

	if(PINK&(1<<currSonar)){
    3704:	86 e0       	ldi	r24, 0x06	; 6
    3706:	91 e0       	ldi	r25, 0x01	; 1
    3708:	fc 01       	movw	r30, r24
    370a:	80 81       	ld	r24, Z
    370c:	88 2f       	mov	r24, r24
    370e:	90 e0       	ldi	r25, 0x00	; 0
    3710:	20 91 cc 1a 	lds	r18, 0x1ACC
    3714:	22 2f       	mov	r18, r18
    3716:	30 e0       	ldi	r19, 0x00	; 0
    3718:	02 2e       	mov	r0, r18
    371a:	02 c0       	rjmp	.+4      	; 0x3720 <__vector_11+0x52>
    371c:	95 95       	asr	r25
    371e:	87 95       	ror	r24
    3720:	0a 94       	dec	r0
    3722:	e2 f7       	brpl	.-8      	; 0x371c <__vector_11+0x4e>
    3724:	81 70       	andi	r24, 0x01	; 1
    3726:	99 27       	eor	r25, r25
    3728:	00 97       	sbiw	r24, 0x00	; 0
    372a:	49 f0       	breq	.+18     	; 0x373e <__vector_11+0x70>
		beginCount = getTimerCount();
    372c:	0e 94 5c 1b 	call	0x36b8	; 0x36b8 <getTimerCount>
    3730:	8a 83       	std	Y+2, r24	; 0x02
		PORTE = 0xFF;
    3732:	8e e2       	ldi	r24, 0x2E	; 46
    3734:	90 e0       	ldi	r25, 0x00	; 0
    3736:	2f ef       	ldi	r18, 0xFF	; 255
    3738:	fc 01       	movw	r30, r24
    373a:	20 83       	st	Z, r18
    373c:	1d c0       	rjmp	.+58     	; 0x3778 <__vector_11+0xaa>
	} else {
		currCount = getTimerCount();
    373e:	0e 94 5c 1b 	call	0x36b8	; 0x36b8 <getTimerCount>
    3742:	8b 83       	std	Y+3, r24	; 0x03
		if(currCount > beginCount){
    3744:	9b 81       	ldd	r25, Y+3	; 0x03
    3746:	8a 81       	ldd	r24, Y+2	; 0x02
    3748:	89 17       	cp	r24, r25
    374a:	38 f4       	brcc	.+14     	; 0x375a <__vector_11+0x8c>
			lastSonarData = currCount - beginCount;
    374c:	9b 81       	ldd	r25, Y+3	; 0x03
    374e:	8a 81       	ldd	r24, Y+2	; 0x02
    3750:	f9 2f       	mov	r31, r25
    3752:	f8 1b       	sub	r31, r24
    3754:	8f 2f       	mov	r24, r31
    3756:	80 93 b1 1a 	sts	0x1AB1, r24
		}
		PORTE = 0;
    375a:	8e e2       	ldi	r24, 0x2E	; 46
    375c:	90 e0       	ldi	r25, 0x00	; 0
    375e:	fc 01       	movw	r30, r24
    3760:	10 82       	st	Z, r1
		xSemaphoreGiveFromISR(sonarSemaphore,0);
    3762:	80 91 be 1a 	lds	r24, 0x1ABE
    3766:	90 91 bf 1a 	lds	r25, 0x1ABF
    376a:	20 e0       	ldi	r18, 0x00	; 0
    376c:	40 e0       	ldi	r20, 0x00	; 0
    376e:	50 e0       	ldi	r21, 0x00	; 0
    3770:	60 e0       	ldi	r22, 0x00	; 0
    3772:	70 e0       	ldi	r23, 0x00	; 0
    3774:	0e 94 70 0d 	call	0x1ae0	; 0x1ae0 <xQueueGenericSendFromISR>
	}

}
    3778:	0f 90       	pop	r0
    377a:	0f 90       	pop	r0
    377c:	0f 90       	pop	r0
    377e:	df 91       	pop	r29
    3780:	cf 91       	pop	r28
    3782:	ff 91       	pop	r31
    3784:	ef 91       	pop	r30
    3786:	bf 91       	pop	r27
    3788:	af 91       	pop	r26
    378a:	9f 91       	pop	r25
    378c:	8f 91       	pop	r24
    378e:	7f 91       	pop	r23
    3790:	6f 91       	pop	r22
    3792:	5f 91       	pop	r21
    3794:	4f 91       	pop	r20
    3796:	3f 91       	pop	r19
    3798:	2f 91       	pop	r18
    379a:	0f 90       	pop	r0
    379c:	00 92 5b 00 	sts	0x005B, r0
    37a0:	0f 90       	pop	r0
    37a2:	00 92 5f 00 	sts	0x005F, r0
    37a6:	0f 90       	pop	r0
    37a8:	1f 90       	pop	r1
    37aa:	18 95       	reti

000037ac <initializeSonarSensors>:

void initializeSonarSensors(){
    37ac:	cf 93       	push	r28
    37ae:	df 93       	push	r29
    37b0:	cd b7       	in	r28, 0x3d	; 61
    37b2:	de b7       	in	r29, 0x3e	; 62
	//DDRD &= 0xFE;	
	DIDR2 = 0;
    37b4:	8d e7       	ldi	r24, 0x7D	; 125
    37b6:	90 e0       	ldi	r25, 0x00	; 0
    37b8:	fc 01       	movw	r30, r24
    37ba:	10 82       	st	Z, r1
	DDRK = 0;
    37bc:	87 e0       	ldi	r24, 0x07	; 7
    37be:	91 e0       	ldi	r25, 0x01	; 1
    37c0:	fc 01       	movw	r30, r24
    37c2:	10 82       	st	Z, r1
	DDRC = 0;
    37c4:	87 e2       	ldi	r24, 0x27	; 39
    37c6:	90 e0       	ldi	r25, 0x00	; 0
    37c8:	fc 01       	movw	r30, r24
    37ca:	10 82       	st	Z, r1

	PORTC = 0;
    37cc:	88 e2       	ldi	r24, 0x28	; 40
    37ce:	90 e0       	ldi	r25, 0x00	; 0
    37d0:	fc 01       	movw	r30, r24
    37d2:	10 82       	st	Z, r1

	//EICRA = 1;
	//EIMSK = 1;

	PCMSK2 = 0xFF;
    37d4:	8d e6       	ldi	r24, 0x6D	; 109
    37d6:	90 e0       	ldi	r25, 0x00	; 0
    37d8:	2f ef       	ldi	r18, 0xFF	; 255
    37da:	fc 01       	movw	r30, r24
    37dc:	20 83       	st	Z, r18
	PCICR = 0x7;
    37de:	88 e6       	ldi	r24, 0x68	; 104
    37e0:	90 e0       	ldi	r25, 0x00	; 0
    37e2:	27 e0       	ldi	r18, 0x07	; 7
    37e4:	fc 01       	movw	r30, r24
    37e6:	20 83       	st	Z, r18

	TCCR0A = 0;
    37e8:	84 e4       	ldi	r24, 0x44	; 68
    37ea:	90 e0       	ldi	r25, 0x00	; 0
    37ec:	fc 01       	movw	r30, r24
    37ee:	10 82       	st	Z, r1
	TCCR0B = 5;
    37f0:	85 e4       	ldi	r24, 0x45	; 69
    37f2:	90 e0       	ldi	r25, 0x00	; 0
    37f4:	25 e0       	ldi	r18, 0x05	; 5
    37f6:	fc 01       	movw	r30, r24
    37f8:	20 83       	st	Z, r18

}
    37fa:	df 91       	pop	r29
    37fc:	cf 91       	pop	r28
    37fe:	08 95       	ret

00003800 <vTaskSonar>:

void vTaskSonar(void* parameter){
    3800:	cf 93       	push	r28
    3802:	df 93       	push	r29
    3804:	00 d0       	rcall	.+0      	; 0x3806 <vTaskSonar+0x6>
    3806:	1f 92       	push	r1
    3808:	cd b7       	in	r28, 0x3d	; 61
    380a:	de b7       	in	r29, 0x3e	; 62
    380c:	9c 83       	std	Y+4, r25	; 0x04
    380e:	8b 83       	std	Y+3, r24	; 0x03

	int i;
	initializeSonarSensors();
    3810:	0e 94 d6 1b 	call	0x37ac	; 0x37ac <initializeSonarSensors>
	
	vSemaphoreCreateBinary(sonarSemaphore);
    3814:	43 e0       	ldi	r20, 0x03	; 3
    3816:	60 e0       	ldi	r22, 0x00	; 0
    3818:	81 e0       	ldi	r24, 0x01	; 1
    381a:	0e 94 15 0c 	call	0x182a	; 0x182a <xQueueGenericCreate>
    381e:	90 93 bf 1a 	sts	0x1ABF, r25
    3822:	80 93 be 1a 	sts	0x1ABE, r24
    3826:	80 91 be 1a 	lds	r24, 0x1ABE
    382a:	90 91 bf 1a 	lds	r25, 0x1ABF
    382e:	00 97       	sbiw	r24, 0x00	; 0
    3830:	59 f0       	breq	.+22     	; 0x3848 <vTaskSonar+0x48>
    3832:	80 91 be 1a 	lds	r24, 0x1ABE
    3836:	90 91 bf 1a 	lds	r25, 0x1ABF
    383a:	20 e0       	ldi	r18, 0x00	; 0
    383c:	40 e0       	ldi	r20, 0x00	; 0
    383e:	50 e0       	ldi	r21, 0x00	; 0
    3840:	60 e0       	ldi	r22, 0x00	; 0
    3842:	70 e0       	ldi	r23, 0x00	; 0
    3844:	0e 94 cc 0c 	call	0x1998	; 0x1998 <xQueueGenericSend>
		
	currSonar = 0;
    3848:	10 92 cc 1a 	sts	0x1ACC, r1

	while(1){
		for(i=0;i<2;i++){
    384c:	1a 82       	std	Y+2, r1	; 0x02
    384e:	19 82       	std	Y+1, r1	; 0x01
    3850:	26 c0       	rjmp	.+76     	; 0x389e <vTaskSonar+0x9e>
			currSonar = i;
    3852:	89 81       	ldd	r24, Y+1	; 0x01
    3854:	80 93 cc 1a 	sts	0x1ACC, r24
			PORTC = (1<<i);
    3858:	88 e2       	ldi	r24, 0x28	; 40
    385a:	90 e0       	ldi	r25, 0x00	; 0
    385c:	21 e0       	ldi	r18, 0x01	; 1
    385e:	30 e0       	ldi	r19, 0x00	; 0
    3860:	09 80       	ldd	r0, Y+1	; 0x01
    3862:	02 c0       	rjmp	.+4      	; 0x3868 <vTaskSonar+0x68>
    3864:	22 0f       	add	r18, r18
    3866:	33 1f       	adc	r19, r19
    3868:	0a 94       	dec	r0
    386a:	e2 f7       	brpl	.-8      	; 0x3864 <vTaskSonar+0x64>
    386c:	fc 01       	movw	r30, r24
    386e:	20 83       	st	Z, r18
			xSemaphoreTake(sonarSemaphore,portMAX_DELAY);
    3870:	80 91 be 1a 	lds	r24, 0x1ABE
    3874:	90 91 bf 1a 	lds	r25, 0x1ABF
    3878:	20 e0       	ldi	r18, 0x00	; 0
    387a:	4f ef       	ldi	r20, 0xFF	; 255
    387c:	5f ef       	ldi	r21, 0xFF	; 255
    387e:	60 e0       	ldi	r22, 0x00	; 0
    3880:	70 e0       	ldi	r23, 0x00	; 0
    3882:	0e 94 c9 0d 	call	0x1b92	; 0x1b92 <xQueueGenericReceive>
			setSonarData(i,lastSonarData);
    3886:	20 91 b1 1a 	lds	r18, 0x1AB1
    388a:	89 81       	ldd	r24, Y+1	; 0x01
    388c:	9a 81       	ldd	r25, Y+2	; 0x02
    388e:	62 2f       	mov	r22, r18
    3890:	0e 94 34 1b 	call	0x3668	; 0x3668 <setSonarData>
	vSemaphoreCreateBinary(sonarSemaphore);
		
	currSonar = 0;

	while(1){
		for(i=0;i<2;i++){
    3894:	89 81       	ldd	r24, Y+1	; 0x01
    3896:	9a 81       	ldd	r25, Y+2	; 0x02
    3898:	01 96       	adiw	r24, 0x01	; 1
    389a:	9a 83       	std	Y+2, r25	; 0x02
    389c:	89 83       	std	Y+1, r24	; 0x01
    389e:	89 81       	ldd	r24, Y+1	; 0x01
    38a0:	9a 81       	ldd	r25, Y+2	; 0x02
    38a2:	82 30       	cpi	r24, 0x02	; 2
    38a4:	91 05       	cpc	r25, r1
    38a6:	ac f2       	brlt	.-86     	; 0x3852 <vTaskSonar+0x52>
			currSonar = i;
			PORTC = (1<<i);
			xSemaphoreTake(sonarSemaphore,portMAX_DELAY);
			setSonarData(i,lastSonarData);
		}
	}
    38a8:	d1 cf       	rjmp	.-94     	; 0x384c <vTaskSonar+0x4c>

000038aa <__udivmodsi4>:
    38aa:	a1 e2       	ldi	r26, 0x21	; 33
    38ac:	1a 2e       	mov	r1, r26
    38ae:	aa 1b       	sub	r26, r26
    38b0:	bb 1b       	sub	r27, r27
    38b2:	fd 01       	movw	r30, r26
    38b4:	0d c0       	rjmp	.+26     	; 0x38d0 <__udivmodsi4_ep>

000038b6 <__udivmodsi4_loop>:
    38b6:	aa 1f       	adc	r26, r26
    38b8:	bb 1f       	adc	r27, r27
    38ba:	ee 1f       	adc	r30, r30
    38bc:	ff 1f       	adc	r31, r31
    38be:	a2 17       	cp	r26, r18
    38c0:	b3 07       	cpc	r27, r19
    38c2:	e4 07       	cpc	r30, r20
    38c4:	f5 07       	cpc	r31, r21
    38c6:	20 f0       	brcs	.+8      	; 0x38d0 <__udivmodsi4_ep>
    38c8:	a2 1b       	sub	r26, r18
    38ca:	b3 0b       	sbc	r27, r19
    38cc:	e4 0b       	sbc	r30, r20
    38ce:	f5 0b       	sbc	r31, r21

000038d0 <__udivmodsi4_ep>:
    38d0:	66 1f       	adc	r22, r22
    38d2:	77 1f       	adc	r23, r23
    38d4:	88 1f       	adc	r24, r24
    38d6:	99 1f       	adc	r25, r25
    38d8:	1a 94       	dec	r1
    38da:	69 f7       	brne	.-38     	; 0x38b6 <__udivmodsi4_loop>
    38dc:	60 95       	com	r22
    38de:	70 95       	com	r23
    38e0:	80 95       	com	r24
    38e2:	90 95       	com	r25
    38e4:	9b 01       	movw	r18, r22
    38e6:	ac 01       	movw	r20, r24
    38e8:	bd 01       	movw	r22, r26
    38ea:	cf 01       	movw	r24, r30
    38ec:	08 95       	ret

000038ee <memcpy>:
    38ee:	fb 01       	movw	r30, r22
    38f0:	dc 01       	movw	r26, r24
    38f2:	02 c0       	rjmp	.+4      	; 0x38f8 <memcpy+0xa>
    38f4:	01 90       	ld	r0, Z+
    38f6:	0d 92       	st	X+, r0
    38f8:	41 50       	subi	r20, 0x01	; 1
    38fa:	50 40       	sbci	r21, 0x00	; 0
    38fc:	d8 f7       	brcc	.-10     	; 0x38f4 <memcpy+0x6>
    38fe:	08 95       	ret

00003900 <memset>:
    3900:	dc 01       	movw	r26, r24
    3902:	01 c0       	rjmp	.+2      	; 0x3906 <memset+0x6>
    3904:	6d 93       	st	X+, r22
    3906:	41 50       	subi	r20, 0x01	; 1
    3908:	50 40       	sbci	r21, 0x00	; 0
    390a:	e0 f7       	brcc	.-8      	; 0x3904 <memset+0x4>
    390c:	08 95       	ret

0000390e <strncpy>:
    390e:	fb 01       	movw	r30, r22
    3910:	dc 01       	movw	r26, r24
    3912:	41 50       	subi	r20, 0x01	; 1
    3914:	50 40       	sbci	r21, 0x00	; 0
    3916:	48 f0       	brcs	.+18     	; 0x392a <strncpy+0x1c>
    3918:	01 90       	ld	r0, Z+
    391a:	0d 92       	st	X+, r0
    391c:	00 20       	and	r0, r0
    391e:	c9 f7       	brne	.-14     	; 0x3912 <strncpy+0x4>
    3920:	01 c0       	rjmp	.+2      	; 0x3924 <strncpy+0x16>
    3922:	1d 92       	st	X+, r1
    3924:	41 50       	subi	r20, 0x01	; 1
    3926:	50 40       	sbci	r21, 0x00	; 0
    3928:	e0 f7       	brcc	.-8      	; 0x3922 <strncpy+0x14>
    392a:	08 95       	ret

0000392c <itoa>:
    392c:	fb 01       	movw	r30, r22
    392e:	9f 01       	movw	r18, r30
    3930:	e8 94       	clt
    3932:	42 30       	cpi	r20, 0x02	; 2
    3934:	c4 f0       	brlt	.+48     	; 0x3966 <itoa+0x3a>
    3936:	45 32       	cpi	r20, 0x25	; 37
    3938:	b4 f4       	brge	.+44     	; 0x3966 <itoa+0x3a>
    393a:	4a 30       	cpi	r20, 0x0A	; 10
    393c:	29 f4       	brne	.+10     	; 0x3948 <itoa+0x1c>
    393e:	97 fb       	bst	r25, 7
    3940:	1e f4       	brtc	.+6      	; 0x3948 <itoa+0x1c>
    3942:	90 95       	com	r25
    3944:	81 95       	neg	r24
    3946:	9f 4f       	sbci	r25, 0xFF	; 255
    3948:	64 2f       	mov	r22, r20
    394a:	77 27       	eor	r23, r23
    394c:	0e 94 c7 1c 	call	0x398e	; 0x398e <__udivmodhi4>
    3950:	80 5d       	subi	r24, 0xD0	; 208
    3952:	8a 33       	cpi	r24, 0x3A	; 58
    3954:	0c f0       	brlt	.+2      	; 0x3958 <itoa+0x2c>
    3956:	89 5d       	subi	r24, 0xD9	; 217
    3958:	81 93       	st	Z+, r24
    395a:	cb 01       	movw	r24, r22
    395c:	00 97       	sbiw	r24, 0x00	; 0
    395e:	a1 f7       	brne	.-24     	; 0x3948 <itoa+0x1c>
    3960:	16 f4       	brtc	.+4      	; 0x3966 <itoa+0x3a>
    3962:	5d e2       	ldi	r21, 0x2D	; 45
    3964:	51 93       	st	Z+, r21
    3966:	10 82       	st	Z, r1
    3968:	c9 01       	movw	r24, r18
    396a:	0c 94 b7 1c 	jmp	0x396e	; 0x396e <strrev>

0000396e <strrev>:
    396e:	dc 01       	movw	r26, r24
    3970:	fc 01       	movw	r30, r24
    3972:	67 2f       	mov	r22, r23
    3974:	71 91       	ld	r23, Z+
    3976:	77 23       	and	r23, r23
    3978:	e1 f7       	brne	.-8      	; 0x3972 <strrev+0x4>
    397a:	32 97       	sbiw	r30, 0x02	; 2
    397c:	04 c0       	rjmp	.+8      	; 0x3986 <strrev+0x18>
    397e:	7c 91       	ld	r23, X
    3980:	6d 93       	st	X+, r22
    3982:	70 83       	st	Z, r23
    3984:	62 91       	ld	r22, -Z
    3986:	ae 17       	cp	r26, r30
    3988:	bf 07       	cpc	r27, r31
    398a:	c8 f3       	brcs	.-14     	; 0x397e <strrev+0x10>
    398c:	08 95       	ret

0000398e <__udivmodhi4>:
    398e:	aa 1b       	sub	r26, r26
    3990:	bb 1b       	sub	r27, r27
    3992:	51 e1       	ldi	r21, 0x11	; 17
    3994:	07 c0       	rjmp	.+14     	; 0x39a4 <__udivmodhi4_ep>

00003996 <__udivmodhi4_loop>:
    3996:	aa 1f       	adc	r26, r26
    3998:	bb 1f       	adc	r27, r27
    399a:	a6 17       	cp	r26, r22
    399c:	b7 07       	cpc	r27, r23
    399e:	10 f0       	brcs	.+4      	; 0x39a4 <__udivmodhi4_ep>
    39a0:	a6 1b       	sub	r26, r22
    39a2:	b7 0b       	sbc	r27, r23

000039a4 <__udivmodhi4_ep>:
    39a4:	88 1f       	adc	r24, r24
    39a6:	99 1f       	adc	r25, r25
    39a8:	5a 95       	dec	r21
    39aa:	a9 f7       	brne	.-22     	; 0x3996 <__udivmodhi4_loop>
    39ac:	80 95       	com	r24
    39ae:	90 95       	com	r25
    39b0:	bc 01       	movw	r22, r24
    39b2:	cd 01       	movw	r24, r26
    39b4:	08 95       	ret

000039b6 <_exit>:
    39b6:	f8 94       	cli

000039b8 <__stop_program>:
    39b8:	ff cf       	rjmp	.-2      	; 0x39b8 <__stop_program>
