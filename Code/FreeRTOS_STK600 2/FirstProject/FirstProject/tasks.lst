   1               		.file	"tasks.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 160               	.global	pxCurrentTCB
 161               		.section .bss
 164               	pxCurrentTCB:
 165 0000 0000      		.zero	2
 166               		.local	pxReadyTasksLists
 167               		.comm	pxReadyTasksLists,36,1
 168               		.local	xDelayedTaskList1
 169               		.comm	xDelayedTaskList1,9,1
 170               		.local	xDelayedTaskList2
 171               		.comm	xDelayedTaskList2,9,1
 172               		.local	pxDelayedTaskList
 173               		.comm	pxDelayedTaskList,2,1
 174               		.local	pxOverflowDelayedTaskList
 175               		.comm	pxOverflowDelayedTaskList,2,1
 176               		.local	xPendingReadyList
 177               		.comm	xPendingReadyList,9,1
 178               		.local	xSuspendedTaskList
 179               		.comm	xSuspendedTaskList,9,1
 180               		.local	uxCurrentNumberOfTasks
 181               		.comm	uxCurrentNumberOfTasks,1,1
 182               		.local	xTickCount
 183               		.comm	xTickCount,2,1
 184               		.local	uxTopUsedPriority
 185               		.comm	uxTopUsedPriority,1,1
 186               		.local	uxTopReadyPriority
 187               		.comm	uxTopReadyPriority,1,1
 188               		.local	xSchedulerRunning
 189               		.comm	xSchedulerRunning,1,1
 190               		.local	uxSchedulerSuspended
 191               		.comm	uxSchedulerSuspended,1,1
 192               		.local	uxMissedTicks
 193               		.comm	uxMissedTicks,1,1
 194               		.local	xMissedYield
 195               		.comm	xMissedYield,1,1
 196               		.local	xNumOfOverflows
 197               		.comm	xNumOfOverflows,1,1
 198               		.local	uxTaskNumber
 199               		.comm	uxTaskNumber,1,1
 200               		.data
 203               	xNextTaskUnblockTime:
 204 0000 FFFF      		.word	-1
 205               		.text
 215               	.global	xTaskGenericCreate
 217               	xTaskGenericCreate:
 218               		.stabd	46,0,0
   1:tasks.c       **** /*
   2:tasks.c       ****     FreeRTOS V7.3.0 - Copyright (C) 2012 Real Time Engineers Ltd.
   3:tasks.c       **** 
   4:tasks.c       ****     FEATURES AND PORTS ARE ADDED TO FREERTOS ALL THE TIME.  PLEASE VISIT
   5:tasks.c       ****     http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:tasks.c       **** 
   7:tasks.c       ****     ***************************************************************************
   8:tasks.c       ****      *                                                                       *
   9:tasks.c       ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
  10:tasks.c       ****      *    Complete, revised, and edited pdf reference manuals are also       *
  11:tasks.c       ****      *    available.                                                         *
  12:tasks.c       ****      *                                                                       *
  13:tasks.c       ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  14:tasks.c       ****      *    ensuring you get running as quickly as possible and with an        *
  15:tasks.c       ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  16:tasks.c       ****      *    the FreeRTOS project to continue with its mission of providing     *
  17:tasks.c       ****      *    professional grade, cross platform, de facto standard solutions    *
  18:tasks.c       ****      *    for microcontrollers - completely free of charge!                  *
  19:tasks.c       ****      *                                                                       *
  20:tasks.c       ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  21:tasks.c       ****      *                                                                       *
  22:tasks.c       ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  23:tasks.c       ****      *                                                                       *
  24:tasks.c       ****     ***************************************************************************
  25:tasks.c       **** 
  26:tasks.c       **** 
  27:tasks.c       ****     This file is part of the FreeRTOS distribution.
  28:tasks.c       **** 
  29:tasks.c       ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  30:tasks.c       ****     the terms of the GNU General Public License (version 2) as published by the
  31:tasks.c       ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  32:tasks.c       ****     >>>NOTE<<< The modification to the GPL is included to allow you to
  33:tasks.c       ****     distribute a combined work that includes FreeRTOS without being obliged to
  34:tasks.c       ****     provide the source code for proprietary components outside of the FreeRTOS
  35:tasks.c       ****     kernel.  FreeRTOS is distributed in the hope that it will be useful, but
  36:tasks.c       ****     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  37:tasks.c       ****     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  38:tasks.c       ****     more details. You should have received a copy of the GNU General Public
  39:tasks.c       ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  40:tasks.c       ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  41:tasks.c       ****     by writing to Richard Barry, contact details for whom are available on the
  42:tasks.c       ****     FreeRTOS WEB site.
  43:tasks.c       **** 
  44:tasks.c       ****     1 tab == 4 spaces!
  45:tasks.c       **** 
  46:tasks.c       ****     ***************************************************************************
  47:tasks.c       ****      *                                                                       *
  48:tasks.c       ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  49:tasks.c       ****      *    not run, what could be wrong?"                                     *
  50:tasks.c       ****      *                                                                       *
  51:tasks.c       ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  52:tasks.c       ****      *                                                                       *
  53:tasks.c       ****     ***************************************************************************
  54:tasks.c       **** 
  55:tasks.c       **** 
  56:tasks.c       ****     http://www.FreeRTOS.org - Documentation, training, latest versions, license
  57:tasks.c       ****     and contact details.
  58:tasks.c       **** 
  59:tasks.c       ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  60:tasks.c       ****     including FreeRTOS+Trace - an indispensable productivity tool.
  61:tasks.c       **** 
  62:tasks.c       ****     Real Time Engineers ltd license FreeRTOS to High Integrity Systems, who sell
  63:tasks.c       ****     the code with commercial support, indemnification, and middleware, under
  64:tasks.c       ****     the OpenRTOS brand: http://www.OpenRTOS.com.  High Integrity Systems also
  65:tasks.c       ****     provide a safety engineered and independently SIL3 certified version under
  66:tasks.c       ****     the SafeRTOS brand: http://www.SafeRTOS.com.
  67:tasks.c       **** */
  68:tasks.c       **** 
  69:tasks.c       **** /* Standard includes. */
  70:tasks.c       **** #include <stdio.h>
  71:tasks.c       **** #include <stdlib.h>
  72:tasks.c       **** #include <string.h>
  73:tasks.c       **** 
  74:tasks.c       **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  75:tasks.c       **** all the API functions to use the MPU wrappers.  That should only be done when
  76:tasks.c       **** task.h is included from an application file. */
  77:tasks.c       **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  78:tasks.c       **** 
  79:tasks.c       **** /* FreeRTOS includes. */
  80:tasks.c       **** #include "FreeRTOS.h"
  81:tasks.c       **** #include "task.h"
  82:tasks.c       **** #include "timers.h"
  83:tasks.c       **** #include "StackMacros.h"
  84:tasks.c       **** 
  85:tasks.c       **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  86:tasks.c       **** 
  87:tasks.c       **** /*
  88:tasks.c       ****  * Defines the size, in words, of the stack allocated to the idle task.
  89:tasks.c       ****  */
  90:tasks.c       **** #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
  91:tasks.c       **** 
  92:tasks.c       **** /*
  93:tasks.c       ****  * Task control block.  A task control block (TCB) is allocated for each task,
  94:tasks.c       ****  * and stores task state information, including a pointer to the task's context
  95:tasks.c       ****  * (the task's run time environment, including register values)
  96:tasks.c       ****  */
  97:tasks.c       **** typedef struct tskTaskControlBlock
  98:tasks.c       **** {
  99:tasks.c       **** 	volatile portSTACK_TYPE	*pxTopOfStack;		/*< Points to the location of the last item placed on the 
 100:tasks.c       **** 
 101:tasks.c       **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 102:tasks.c       **** 		xMPU_SETTINGS xMPUSettings;				/*< The MPU settings are defined as part of the port layer.  THIS 
 103:tasks.c       **** 	#endif
 104:tasks.c       **** 
 105:tasks.c       **** 	xListItem				xGenericListItem;		/*< The list that the state list item of a task is reference from 
 106:tasks.c       **** 	xListItem				xEventListItem;		/*< Used to reference a task from an event list. */
 107:tasks.c       **** 	unsigned portBASE_TYPE	uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
 108:tasks.c       **** 	portSTACK_TYPE			*pxStack;			/*< Points to the start of the stack. */
 109:tasks.c       **** 	signed char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when c
 110:tasks.c       **** 
 111:tasks.c       **** 	#if ( portSTACK_GROWTH > 0 )
 112:tasks.c       **** 		portSTACK_TYPE *pxEndOfStack;			/*< Points to the end of the stack on architectures where the sta
 113:tasks.c       **** 	#endif
 114:tasks.c       **** 
 115:tasks.c       **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 116:tasks.c       **** 		unsigned portBASE_TYPE uxCriticalNesting; /*< Holds the critical section nesting depth for ports 
 117:tasks.c       **** 	#endif
 118:tasks.c       **** 
 119:tasks.c       **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 120:tasks.c       **** 		unsigned portBASE_TYPE	uxTCBNumber;	/*< Stores a number that increments each time a TCB is create
 121:tasks.c       **** 		unsigned portBASE_TYPE  uxTaskNumber;	/*< Stores a number specifically for use by third party tra
 122:tasks.c       **** 	#endif
 123:tasks.c       **** 
 124:tasks.c       **** 	#if ( configUSE_MUTEXES == 1 )
 125:tasks.c       **** 		unsigned portBASE_TYPE uxBasePriority;	/*< The priority last assigned to the task - used by the p
 126:tasks.c       **** 	#endif
 127:tasks.c       **** 
 128:tasks.c       **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 129:tasks.c       **** 		pdTASK_HOOK_CODE pxTaskTag;
 130:tasks.c       **** 	#endif
 131:tasks.c       **** 
 132:tasks.c       **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 133:tasks.c       **** 		unsigned long ulRunTimeCounter;			/*< Stores the amount of time the task has spent in the Running
 134:tasks.c       **** 	#endif
 135:tasks.c       **** 
 136:tasks.c       **** } tskTCB;
 137:tasks.c       **** 
 138:tasks.c       **** 
 139:tasks.c       **** /*
 140:tasks.c       ****  * Some kernel aware debuggers require the data the debugger needs access to to
 141:tasks.c       ****  * be global, rather than file scope.
 142:tasks.c       ****  */
 143:tasks.c       **** #ifdef portREMOVE_STATIC_QUALIFIER
 144:tasks.c       **** 	#define static
 145:tasks.c       **** #endif
 146:tasks.c       **** 
 147:tasks.c       **** /*lint -e956 */
 148:tasks.c       **** PRIVILEGED_DATA tskTCB * volatile pxCurrentTCB = NULL;
 149:tasks.c       **** 
 150:tasks.c       **** /* Lists for ready and blocked tasks. --------------------*/
 151:tasks.c       **** PRIVILEGED_DATA static xList pxReadyTasksLists[ configMAX_PRIORITIES ];	/*< Prioritised ready tasks
 152:tasks.c       **** PRIVILEGED_DATA static xList xDelayedTaskList1;							/*< Delayed tasks. */
 153:tasks.c       **** PRIVILEGED_DATA static xList xDelayedTaskList2;							/*< Delayed tasks (two lists are used - one f
 154:tasks.c       **** PRIVILEGED_DATA static xList * volatile pxDelayedTaskList ;				/*< Points to the delayed task list 
 155:tasks.c       **** PRIVILEGED_DATA static xList * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task 
 156:tasks.c       **** PRIVILEGED_DATA static xList xPendingReadyList;							/*< Tasks that have been readied while the sc
 157:tasks.c       **** 
 158:tasks.c       **** #if ( INCLUDE_vTaskDelete == 1 )
 159:tasks.c       **** 
 160:tasks.c       **** 	PRIVILEGED_DATA static xList xTasksWaitingTermination;				/*< Tasks that have been deleted - but t
 161:tasks.c       **** 	PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTasksDeleted = ( unsigned portBASE_TYPE )
 162:tasks.c       **** 
 163:tasks.c       **** #endif
 164:tasks.c       **** 
 165:tasks.c       **** #if ( INCLUDE_vTaskSuspend == 1 )
 166:tasks.c       **** 
 167:tasks.c       **** 	PRIVILEGED_DATA static xList xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 168:tasks.c       **** 
 169:tasks.c       **** #endif
 170:tasks.c       **** 
 171:tasks.c       **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
 172:tasks.c       **** 
 173:tasks.c       **** 	PRIVILEGED_DATA static xTaskHandle xIdleTaskHandle = NULL;			/*< Holds the handle of the idle task
 174:tasks.c       **** 
 175:tasks.c       **** #endif
 176:tasks.c       **** 
 177:tasks.c       **** /* File private variables. --------------------------------*/
 178:tasks.c       **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxCurrentNumberOfTasks 	= ( unsigned portBAS
 179:tasks.c       **** PRIVILEGED_DATA static volatile portTickType xTickCount 						= ( portTickType ) 0U;
 180:tasks.c       **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTopUsedPriority	 				= tskIDLE_PRIORITY;
 181:tasks.c       **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTopReadyPriority 		= tskIDLE_PRIORITY;
 182:tasks.c       **** PRIVILEGED_DATA static volatile signed portBASE_TYPE xSchedulerRunning 			= pdFALSE;
 183:tasks.c       **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxSchedulerSuspended	 	= ( unsigned portBASE
 184:tasks.c       **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxMissedTicks 			= ( unsigned portBASE_TYPE 
 185:tasks.c       **** PRIVILEGED_DATA static volatile portBASE_TYPE xMissedYield 						= ( portBASE_TYPE ) pdFALSE;
 186:tasks.c       **** PRIVILEGED_DATA static volatile portBASE_TYPE xNumOfOverflows 					= ( portBASE_TYPE ) 0;
 187:tasks.c       **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTaskNumber 						= ( unsigned portBASE_TYPE ) 0U;
 188:tasks.c       **** PRIVILEGED_DATA static volatile portTickType xNextTaskUnblockTime				= ( portTickType ) portMAX_DEL
 189:tasks.c       **** 
 190:tasks.c       **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 191:tasks.c       **** 
 192:tasks.c       **** 	PRIVILEGED_DATA static char pcStatsString[ 50 ] ;
 193:tasks.c       **** 	PRIVILEGED_DATA static unsigned long ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/co
 194:tasks.c       **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
 195:tasks.c       **** 
 196:tasks.c       **** #endif
 197:tasks.c       **** 
 198:tasks.c       **** /* Debugging and trace facilities private variables and macros. ------------*/
 199:tasks.c       **** 
 200:tasks.c       **** /*
 201:tasks.c       ****  * The value used to fill the stack of a task when the task is created.  This
 202:tasks.c       ****  * is used purely for checking the high water mark for tasks.
 203:tasks.c       ****  */
 204:tasks.c       **** #define tskSTACK_FILL_BYTE	( 0xa5U )
 205:tasks.c       **** 
 206:tasks.c       **** /*
 207:tasks.c       ****  * Macros used by vListTask to indicate which state a task is in.
 208:tasks.c       ****  */
 209:tasks.c       **** #define tskBLOCKED_CHAR		( ( signed char ) 'B' )
 210:tasks.c       **** #define tskREADY_CHAR		( ( signed char ) 'R' )
 211:tasks.c       **** #define tskDELETED_CHAR		( ( signed char ) 'D' )
 212:tasks.c       **** #define tskSUSPENDED_CHAR	( ( signed char ) 'S' )
 213:tasks.c       **** 
 214:tasks.c       **** /*-----------------------------------------------------------*/
 215:tasks.c       **** 
 216:tasks.c       **** #if configUSE_PORT_OPTIMISED_TASK_SELECTION == 0
 217:tasks.c       **** 
 218:tasks.c       **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
 219:tasks.c       **** 	performed in a generic way that is not optimised to any particular
 220:tasks.c       **** 	microcontroller architecture. */
 221:tasks.c       **** 
 222:tasks.c       **** 	/* uxTopReadyPriority holds the priority of the highest priority ready
 223:tasks.c       **** 	state task. */
 224:tasks.c       **** 	#define taskRECORD_READY_PRIORITY( uxPriority )																		\
 225:tasks.c       **** 	{																													\
 226:tasks.c       **** 		if( ( uxPriority ) > uxTopReadyPriority )																		\
 227:tasks.c       **** 		{																												\
 228:tasks.c       **** 			uxTopReadyPriority = ( uxPriority );																		\
 229:tasks.c       **** 		}																												\
 230:tasks.c       **** 	} /* taskRECORD_READY_PRIORITY */
 231:tasks.c       **** 
 232:tasks.c       **** 	/*-----------------------------------------------------------*/
 233:tasks.c       **** 
 234:tasks.c       **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()																			\
 235:tasks.c       **** 	{																													\
 236:tasks.c       **** 		/* Find the highest priority queue that contains ready tasks. */												\
 237:tasks.c       **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )										\
 238:tasks.c       **** 		{																												\
 239:tasks.c       **** 			configASSERT( uxTopReadyPriority );																			\
 240:tasks.c       **** 			--uxTopReadyPriority;																						\
 241:tasks.c       **** 		}																												\
 242:tasks.c       **** 																														\
 243:tasks.c       **** 		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of										\
 244:tasks.c       **** 		the	same priority get an equal share of the processor time. */													\
 245:tasks.c       **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );						\
 246:tasks.c       **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
 247:tasks.c       **** 
 248:tasks.c       **** 	/*-----------------------------------------------------------*/
 249:tasks.c       **** 
 250:tasks.c       **** 	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
 251:tasks.c       **** 	they are only required when a port optimised method of task selection is
 252:tasks.c       **** 	being used. */
 253:tasks.c       **** 	#define taskRESET_READY_PRIORITY( uxPriority )
 254:tasks.c       **** 	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
 255:tasks.c       **** 
 256:tasks.c       **** #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 257:tasks.c       **** 
 258:tasks.c       **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
 259:tasks.c       **** 	performed in a way that is tailored to the particular microcontroller
 260:tasks.c       **** 	architecture being used. */
 261:tasks.c       **** 
 262:tasks.c       **** 	/* A port optimised version is provided.  Call the port defined macros. */
 263:tasks.c       **** 	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyP
 264:tasks.c       **** 
 265:tasks.c       **** 	/*-----------------------------------------------------------*/
 266:tasks.c       **** 
 267:tasks.c       **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
 268:tasks.c       **** 	{																								\
 269:tasks.c       **** 	unsigned portBASE_TYPE uxTopPriority;															\
 270:tasks.c       **** 																									\
 271:tasks.c       **** 		/* Find the highest priority queue that contains ready tasks. */							\
 272:tasks.c       **** 		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
 273:tasks.c       **** 		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
 274:tasks.c       **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
 275:tasks.c       **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
 276:tasks.c       **** 
 277:tasks.c       **** 	/*-----------------------------------------------------------*/
 278:tasks.c       **** 
 279:tasks.c       **** 	/* A port optimised version is provided, call it only if the TCB being reset
 280:tasks.c       **** 	is being referenced from a ready list.  If it is referenced from a delayed
 281:tasks.c       **** 	or suspended list then it won't be in a ready list. */
 282:tasks.c       **** 	#define taskRESET_READY_PRIORITY( uxPriority )													\
 283:tasks.c       **** 	{																								\
 284:tasks.c       **** 		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == 0 )				\
 285:tasks.c       **** 		{																							\
 286:tasks.c       **** 			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );						\
 287:tasks.c       **** 		}																							\
 288:tasks.c       **** 	}
 289:tasks.c       **** 
 290:tasks.c       **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 291:tasks.c       **** 
 292:tasks.c       **** /*
 293:tasks.c       ****  * Place the task represented by pxTCB into the appropriate ready queue for
 294:tasks.c       ****  * the task.  It is inserted at the end of the list.  One quirk of this is
 295:tasks.c       ****  * that if the task being inserted is at the same priority as the currently
 296:tasks.c       ****  * executing task, then it will only be rescheduled after the currently
 297:tasks.c       ****  * executing task has been rescheduled.
 298:tasks.c       ****  */
 299:tasks.c       **** #define prvAddTaskToReadyQueue( pxTCB )																				\
 300:tasks.c       **** 	traceMOVED_TASK_TO_READY_STATE( pxTCB )																			\
 301:tasks.c       **** 	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );																\
 302:tasks.c       **** 	vListInsertEnd( ( xList * ) &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGeneri
 303:tasks.c       **** /*-----------------------------------------------------------*/
 304:tasks.c       **** 
 305:tasks.c       **** /*
 306:tasks.c       ****  * Macro that looks at the list of tasks that are currently delayed to see if
 307:tasks.c       ****  * any require waking.
 308:tasks.c       ****  *
 309:tasks.c       ****  * Tasks are stored in the queue in the order of their wake time - meaning
 310:tasks.c       ****  * once one tasks has been found whose timer has not expired we need not look
 311:tasks.c       ****  * any further down the list.
 312:tasks.c       ****  */
 313:tasks.c       **** #define prvCheckDelayedTasks()															\
 314:tasks.c       **** {																						\
 315:tasks.c       **** portTickType xItemValue;																\
 316:tasks.c       **** 																						\
 317:tasks.c       **** 	/* Is the tick count greater than or equal to the wake time of the first			\
 318:tasks.c       **** 	task referenced from the delayed tasks list? */										\
 319:tasks.c       **** 	if( xTickCount >= xNextTaskUnblockTime )											\
 320:tasks.c       **** 	{																					\
 321:tasks.c       **** 		for( ;; )																		\
 322:tasks.c       **** 		{																				\
 323:tasks.c       **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )						\
 324:tasks.c       **** 			{																			\
 325:tasks.c       **** 				/* The delayed list is empty.  Set xNextTaskUnblockTime to the			\
 326:tasks.c       **** 				maximum possible value so it is extremely unlikely that the				\
 327:tasks.c       **** 				if( xTickCount >= xNextTaskUnblockTime ) test will pass next			\
 328:tasks.c       **** 				time through. */														\
 329:tasks.c       **** 				xNextTaskUnblockTime = portMAX_DELAY;									\
 330:tasks.c       **** 				break;																	\
 331:tasks.c       **** 			}																			\
 332:tasks.c       **** 			else																		\
 333:tasks.c       **** 			{																			\
 334:tasks.c       **** 				/* The delayed list is not empty, get the value of the item at			\
 335:tasks.c       **** 				the head of the delayed list.  This is the time at which the			\
 336:tasks.c       **** 				task at the head of the delayed list should be removed from				\
 337:tasks.c       **** 				the Blocked state. */													\
 338:tasks.c       **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );	\
 339:tasks.c       **** 				xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );	\
 340:tasks.c       **** 																						\
 341:tasks.c       **** 				if( xTickCount < xItemValue )											\
 342:tasks.c       **** 				{																		\
 343:tasks.c       **** 					/* It is not time to unblock this item yet, but the item			\
 344:tasks.c       **** 					value is the time at which the task at the head of the				\
 345:tasks.c       **** 					blocked list should be removed from the Blocked state -				\
 346:tasks.c       **** 					so record the item value in xNextTaskUnblockTime. */				\
 347:tasks.c       **** 					xNextTaskUnblockTime = xItemValue;									\
 348:tasks.c       **** 					break;																\
 349:tasks.c       **** 				}																		\
 350:tasks.c       **** 																						\
 351:tasks.c       **** 				/* It is time to remove the item from the Blocked state. */				\
 352:tasks.c       **** 				uxListRemove( &( pxTCB->xGenericListItem ) );							\
 353:tasks.c       **** 																						\
 354:tasks.c       **** 				/* Is the task waiting on an event also? */								\
 355:tasks.c       **** 				if( pxTCB->xEventListItem.pvContainer != NULL )							\
 356:tasks.c       **** 				{																		\
 357:tasks.c       **** 					uxListRemove( &( pxTCB->xEventListItem ) );							\
 358:tasks.c       **** 				}																		\
 359:tasks.c       **** 				prvAddTaskToReadyQueue( pxTCB );										\
 360:tasks.c       **** 			}																			\
 361:tasks.c       **** 		}																				\
 362:tasks.c       **** 	}																					\
 363:tasks.c       **** }
 364:tasks.c       **** /*-----------------------------------------------------------*/
 365:tasks.c       **** 
 366:tasks.c       **** /*
 367:tasks.c       ****  * Several functions take an xTaskHandle parameter that can optionally be NULL,
 368:tasks.c       ****  * where NULL is used to indicate that the handle of the currently executing
 369:tasks.c       ****  * task should be used in place of the parameter.  This macro simply checks to
 370:tasks.c       ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 371:tasks.c       ****  */
 372:tasks.c       **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( tskTCB * ) pxCurrentTCB : ( 
 373:tasks.c       **** 
 374:tasks.c       **** /* Callback function prototypes. --------------------------*/
 375:tasks.c       **** extern void vApplicationStackOverflowHook( xTaskHandle pxTask, signed char *pcTaskName ) __attribut
 376:tasks.c       **** extern void vApplicationTickHook( void );
 377:tasks.c       **** 
 378:tasks.c       **** /* File private functions. --------------------------------*/
 379:tasks.c       **** 
 380:tasks.c       **** /*
 381:tasks.c       ****  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
 382:tasks.c       ****  * into the TCB structure.
 383:tasks.c       ****  */
 384:tasks.c       **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
 385:tasks.c       **** 
 386:tasks.c       **** /*
 387:tasks.c       ****  * Utility to ready all the lists used by the scheduler.  This is called
 388:tasks.c       ****  * automatically upon the creation of the first task.
 389:tasks.c       ****  */
 390:tasks.c       **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 391:tasks.c       **** 
 392:tasks.c       **** /*
 393:tasks.c       ****  * The idle task, which as all tasks is implemented as a never ending loop.
 394:tasks.c       ****  * The idle task is automatically created and added to the ready lists upon
 395:tasks.c       ****  * creation of the first user task.
 396:tasks.c       ****  *
 397:tasks.c       ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 398:tasks.c       ****  * language extensions.  The equivalent prototype for this function is:
 399:tasks.c       ****  *
 400:tasks.c       ****  * void prvIdleTask( void *pvParameters );
 401:tasks.c       ****  *
 402:tasks.c       ****  */
 403:tasks.c       **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 404:tasks.c       **** 
 405:tasks.c       **** /*
 406:tasks.c       ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 407:tasks.c       ****  * including the stack pointed to by the TCB.
 408:tasks.c       ****  *
 409:tasks.c       ****  * This does not free memory allocated by the task itself (i.e. memory
 410:tasks.c       ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 411:tasks.c       ****  */
 412:tasks.c       **** #if ( INCLUDE_vTaskDelete == 1 )
 413:tasks.c       **** 
 414:tasks.c       **** 	static void prvDeleteTCB( tskTCB *pxTCB ) PRIVILEGED_FUNCTION;
 415:tasks.c       **** 
 416:tasks.c       **** #endif
 417:tasks.c       **** 
 418:tasks.c       **** /*
 419:tasks.c       ****  * Used only by the idle task.  This checks to see if anything has been placed
 420:tasks.c       ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 421:tasks.c       ****  * and its TCB deleted.
 422:tasks.c       ****  */
 423:tasks.c       **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 424:tasks.c       **** 
 425:tasks.c       **** /*
 426:tasks.c       ****  * The currently executing task is entering the Blocked state.  Add the task to
 427:tasks.c       ****  * either the current or the overflow delayed task list.
 428:tasks.c       ****  */
 429:tasks.c       **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake ) PRIVILEGED_FUNCTION;
 430:tasks.c       **** 
 431:tasks.c       **** /*
 432:tasks.c       ****  * Allocates memory from the heap for a TCB and associated stack.  Checks the
 433:tasks.c       ****  * allocation was successful.
 434:tasks.c       ****  */
 435:tasks.c       **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
 436:tasks.c       **** 
 437:tasks.c       **** /*
 438:tasks.c       ****  * Called from vTaskList.  vListTasks details all the tasks currently under
 439:tasks.c       ****  * control of the scheduler.  The tasks may be in one of a number of lists.
 440:tasks.c       ****  * prvListTaskWithinSingleList accepts a list and details the tasks from
 441:tasks.c       ****  * within just that list.
 442:tasks.c       ****  *
 443:tasks.c       ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 444:tasks.c       ****  * NORMAL APPLICATION CODE.
 445:tasks.c       ****  */
 446:tasks.c       **** #if ( configUSE_TRACE_FACILITY == 1 )
 447:tasks.c       **** 
 448:tasks.c       **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
 449:tasks.c       **** 
 450:tasks.c       **** #endif
 451:tasks.c       **** 
 452:tasks.c       **** /*
 453:tasks.c       ****  * When a task is created, the stack of the task is filled with a known value.
 454:tasks.c       ****  * This function determines the 'high water mark' of the task stack by
 455:tasks.c       ****  * determining how much of the stack remains at the original preset value.
 456:tasks.c       ****  */
 457:tasks.c       **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 458:tasks.c       **** 
 459:tasks.c       **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte ) PRIVILEGED_F
 460:tasks.c       **** 
 461:tasks.c       **** #endif
 462:tasks.c       **** 
 463:tasks.c       **** /*
 464:tasks.c       ****  * Return the amount of time, in ticks, that will pass before the kernel will
 465:tasks.c       ****  * next move a task from the Blocked state to the Running state.
 466:tasks.c       ****  *
 467:tasks.c       ****  * This conditional compilation should use inequality to 0, not equality to 1.
 468:tasks.c       ****  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 469:tasks.c       ****  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 470:tasks.c       ****  * set to a value other than 1.
 471:tasks.c       ****  */
 472:tasks.c       **** #if ( configUSE_TICKLESS_IDLE != 0 )
 473:tasks.c       **** 
 474:tasks.c       **** 	static portTickType prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
 475:tasks.c       **** 
 476:tasks.c       **** #endif
 477:tasks.c       **** 
 478:tasks.c       **** /*lint +e956 */
 479:tasks.c       **** 
 480:tasks.c       **** 
 481:tasks.c       **** 
 482:tasks.c       **** /*-----------------------------------------------------------
 483:tasks.c       ****  * TASK CREATION API documented in task.h
 484:tasks.c       ****  *----------------------------------------------------------*/
 485:tasks.c       **** 
 486:tasks.c       **** signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, 
 487:tasks.c       **** {
 220               	.LM0:
 221               	.LFBB1:
 222 0000 AF92      		push r10
 223 0002 BF92      		push r11
 224 0004 CF92      		push r12
 225 0006 DF92      		push r13
 226 0008 EF92      		push r14
 227 000a FF92      		push r15
 228 000c 0F93      		push r16
 229 000e 1F93      		push r17
 230 0010 CF93      		push r28
 231 0012 DF93      		push r29
 232 0014 CDB7      		in r28,__SP_L__
 233 0016 DEB7      		in r29,__SP_H__
 234 0018 6497      		sbiw r28,20
 235 001a 0FB6      		in __tmp_reg__,__SREG__
 236 001c F894      		cli
 237 001e DEBF      		out __SP_H__,r29
 238 0020 0FBE      		out __SREG__,__tmp_reg__
 239 0022 CDBF      		out __SP_L__,r28
 240               	/* prologue: function */
 241               	/* frame size = 20 */
 242               	/* stack size = 30 */
 243               	.L__stack_usage = 30
 244 0024 9F83      		std Y+7,r25
 245 0026 8E83      		std Y+6,r24
 246 0028 7987      		std Y+9,r23
 247 002a 6887      		std Y+8,r22
 248 002c 5B87      		std Y+11,r21
 249 002e 4A87      		std Y+10,r20
 250 0030 3D87      		std Y+13,r19
 251 0032 2C87      		std Y+12,r18
 252 0034 0E87      		std Y+14,r16
 253 0036 F88A      		std Y+16,r15
 254 0038 EF86      		std Y+15,r14
 255 003a DA8A      		std Y+18,r13
 256 003c C98A      		std Y+17,r12
 257 003e BC8A      		std Y+20,r11
 258 0040 AB8A      		std Y+19,r10
 488:tasks.c       **** signed portBASE_TYPE xReturn;
 489:tasks.c       **** tskTCB * pxNewTCB;
 490:tasks.c       **** 
 491:tasks.c       **** 	configASSERT( pxTaskCode );
 492:tasks.c       **** 	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
 493:tasks.c       **** 
 494:tasks.c       **** 	/* Allocate the memory required by the TCB and stack for the new task,
 495:tasks.c       **** 	checking that the allocation was successful. */
 496:tasks.c       **** 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 260               	.LM1:
 261 0042 2989      		ldd r18,Y+17
 262 0044 3A89      		ldd r19,Y+18
 263 0046 8A85      		ldd r24,Y+10
 264 0048 9B85      		ldd r25,Y+11
 265 004a B901      		movw r22,r18
 266 004c 0E94 0000 		call prvAllocateTCBAndStack
 267 0050 9B83      		std Y+3,r25
 268 0052 8A83      		std Y+2,r24
 497:tasks.c       **** 
 498:tasks.c       **** 	if( pxNewTCB != NULL )
 270               	.LM2:
 271 0054 8A81      		ldd r24,Y+2
 272 0056 9B81      		ldd r25,Y+3
 273 0058 0097      		sbiw r24,0
 274 005a 01F4      		brne .+2
 275 005c 00C0      		rjmp .L2
 276               	.LBB2:
 499:tasks.c       **** 	{
 500:tasks.c       **** 		portSTACK_TYPE *pxTopOfStack;
 501:tasks.c       **** 
 502:tasks.c       **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 503:tasks.c       **** 			/* Should the task be created in privileged mode? */
 504:tasks.c       **** 			portBASE_TYPE xRunPrivileged;
 505:tasks.c       **** 			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 506:tasks.c       **** 			{
 507:tasks.c       **** 				xRunPrivileged = pdTRUE;
 508:tasks.c       **** 			}
 509:tasks.c       **** 			else
 510:tasks.c       **** 			{
 511:tasks.c       **** 				xRunPrivileged = pdFALSE;
 512:tasks.c       **** 			}
 513:tasks.c       **** 			uxPriority &= ~portPRIVILEGE_BIT;
 514:tasks.c       **** 		#endif /* portUSING_MPU_WRAPPERS == 1 */
 515:tasks.c       **** 
 516:tasks.c       **** 		/* Calculate the top of stack address.  This depends on whether the
 517:tasks.c       **** 		stack grows from high memory to low (as per the 80x86) or visa versa.
 518:tasks.c       **** 		portSTACK_GROWTH is used to make the result positive or negative as
 519:tasks.c       **** 		required by the port. */
 520:tasks.c       **** 		#if( portSTACK_GROWTH < 0 )
 521:tasks.c       **** 		{
 522:tasks.c       **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 278               	.LM3:
 279 005e 8A81      		ldd r24,Y+2
 280 0060 9B81      		ldd r25,Y+3
 281 0062 FC01      		movw r30,r24
 282 0064 2789      		ldd r18,Z+23
 283 0066 308D      		ldd r19,Z+24
 284 0068 8A85      		ldd r24,Y+10
 285 006a 9B85      		ldd r25,Y+11
 286 006c 0197      		sbiw r24,1
 287 006e 820F      		add r24,r18
 288 0070 931F      		adc r25,r19
 289 0072 9D83      		std Y+5,r25
 290 0074 8C83      		std Y+4,r24
 523:tasks.c       **** 			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINT
 524:tasks.c       **** 
 525:tasks.c       **** 			/* Check the alignment of the calculated top of stack is correct. */
 526:tasks.c       **** 			configASSERT( ( ( ( unsigned long ) pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) =
 527:tasks.c       **** 		}
 528:tasks.c       **** 		#else
 529:tasks.c       **** 		{
 530:tasks.c       **** 			pxTopOfStack = pxNewTCB->pxStack;
 531:tasks.c       **** 
 532:tasks.c       **** 			/* Check the alignment of the stack buffer is correct. */
 533:tasks.c       **** 			configASSERT( ( ( ( unsigned long ) pxNewTCB->pxStack & ( unsigned long ) portBYTE_ALIGNMENT_MAS
 534:tasks.c       **** 
 535:tasks.c       **** 			/* If we want to use stack checking on architectures that use
 536:tasks.c       **** 			a positive stack growth direction then we also need to store the
 537:tasks.c       **** 			other extreme of the stack space. */
 538:tasks.c       **** 			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 539:tasks.c       **** 		}
 540:tasks.c       **** 		#endif
 541:tasks.c       **** 
 542:tasks.c       **** 		/* Setup the newly allocated TCB with the initial state of the task. */
 543:tasks.c       **** 		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 292               	.LM4:
 293 0076 4A85      		ldd r20,Y+10
 294 0078 5B85      		ldd r21,Y+11
 295 007a 2B89      		ldd r18,Y+19
 296 007c 3C89      		ldd r19,Y+20
 297 007e 6885      		ldd r22,Y+8
 298 0080 7985      		ldd r23,Y+9
 299 0082 8A81      		ldd r24,Y+2
 300 0084 9B81      		ldd r25,Y+3
 301 0086 8A01      		movw r16,r20
 302 0088 4E85      		ldd r20,Y+14
 303 008a 0E94 0000 		call prvInitialiseTCBVariables
 544:tasks.c       **** 
 545:tasks.c       **** 		/* Initialize the TCB stack to look as if the task was already running,
 546:tasks.c       **** 		but had been interrupted by the scheduler.  The return address is set
 547:tasks.c       **** 		to the start of the task function. Once the stack has been initialised
 548:tasks.c       **** 		the	top of stack variable is updated. */
 549:tasks.c       **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 550:tasks.c       **** 		{
 551:tasks.c       **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
 552:tasks.c       **** 		}
 553:tasks.c       **** 		#else
 554:tasks.c       **** 		{
 555:tasks.c       **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 305               	.LM5:
 306 008e 4C85      		ldd r20,Y+12
 307 0090 5D85      		ldd r21,Y+13
 308 0092 2E81      		ldd r18,Y+6
 309 0094 3F81      		ldd r19,Y+7
 310 0096 8C81      		ldd r24,Y+4
 311 0098 9D81      		ldd r25,Y+5
 312 009a B901      		movw r22,r18
 313 009c 0E94 0000 		call pxPortInitialiseStack
 314 00a0 9C01      		movw r18,r24
 315 00a2 8A81      		ldd r24,Y+2
 316 00a4 9B81      		ldd r25,Y+3
 317 00a6 FC01      		movw r30,r24
 318 00a8 3183      		std Z+1,r19
 319 00aa 2083      		st Z,r18
 556:tasks.c       **** 		}
 557:tasks.c       **** 		#endif
 558:tasks.c       **** 
 559:tasks.c       **** 		/* Check the alignment of the initialised stack. */
 560:tasks.c       **** 		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long
 561:tasks.c       **** 
 562:tasks.c       **** 		if( ( void * ) pxCreatedTask != NULL )
 321               	.LM6:
 322 00ac 8F85      		ldd r24,Y+15
 323 00ae 9889      		ldd r25,Y+16
 324 00b0 0097      		sbiw r24,0
 325 00b2 01F0      		breq .L3
 563:tasks.c       **** 		{
 564:tasks.c       **** 			/* Pass the TCB out - in an anonymous way.  The calling function/
 565:tasks.c       **** 			task can use this as a handle to delete the task later if
 566:tasks.c       **** 			required.*/
 567:tasks.c       **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 327               	.LM7:
 328 00b4 8F85      		ldd r24,Y+15
 329 00b6 9889      		ldd r25,Y+16
 330 00b8 2A81      		ldd r18,Y+2
 331 00ba 3B81      		ldd r19,Y+3
 332 00bc FC01      		movw r30,r24
 333 00be 3183      		std Z+1,r19
 334 00c0 2083      		st Z,r18
 335               	.L3:
 568:tasks.c       **** 		}
 569:tasks.c       **** 
 570:tasks.c       **** 		/* We are going to manipulate the task queues to add this task to a
 571:tasks.c       **** 		ready list, so must make sure no interrupts occur. */
 572:tasks.c       **** 		taskENTER_CRITICAL();
 337               	.LM8:
 338               	/* #APP */
 339               	 ;  572 "tasks.c" 1
 340 00c2 0FB6      		in		__tmp_reg__, __SREG__
 341               	 ;  0 "" 2
 342               	 ;  572 "tasks.c" 1
 343 00c4 F894      		cli
 344               	 ;  0 "" 2
 345               	 ;  572 "tasks.c" 1
 346 00c6 0F92      		push	__tmp_reg__
 347               	 ;  0 "" 2
 573:tasks.c       **** 		{
 574:tasks.c       **** 			uxCurrentNumberOfTasks++;
 349               	.LM9:
 350               	/* #NOAPP */
 351 00c8 8091 0000 		lds r24,uxCurrentNumberOfTasks
 352 00cc 8F5F      		subi r24,lo8(-(1))
 353 00ce 8093 0000 		sts uxCurrentNumberOfTasks,r24
 575:tasks.c       **** 			if( pxCurrentTCB == NULL )
 355               	.LM10:
 356 00d2 8091 0000 		lds r24,pxCurrentTCB
 357 00d6 9091 0000 		lds r25,pxCurrentTCB+1
 358 00da 0097      		sbiw r24,0
 359 00dc 01F4      		brne .L4
 576:tasks.c       **** 			{
 577:tasks.c       **** 				/* There are no other tasks, or all the other tasks are in
 578:tasks.c       **** 				the suspended state - make this the current task. */
 579:tasks.c       **** 				pxCurrentTCB =  pxNewTCB;
 361               	.LM11:
 362 00de 8A81      		ldd r24,Y+2
 363 00e0 9B81      		ldd r25,Y+3
 364 00e2 9093 0000 		sts pxCurrentTCB+1,r25
 365 00e6 8093 0000 		sts pxCurrentTCB,r24
 580:tasks.c       **** 
 581:tasks.c       **** 				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 367               	.LM12:
 368 00ea 8091 0000 		lds r24,uxCurrentNumberOfTasks
 369 00ee 8130      		cpi r24,lo8(1)
 370 00f0 01F4      		brne .L6
 582:tasks.c       **** 				{
 583:tasks.c       **** 					/* This is the first task to be created so do the preliminary
 584:tasks.c       **** 					initialisation required.  We will not recover if this call
 585:tasks.c       **** 					fails, but we will report the failure. */
 586:tasks.c       **** 					prvInitialiseTaskLists();
 372               	.LM13:
 373 00f2 0E94 0000 		call prvInitialiseTaskLists
 374 00f6 00C0      		rjmp .L6
 375               	.L4:
 587:tasks.c       **** 				}
 588:tasks.c       **** 			}
 589:tasks.c       **** 			else
 590:tasks.c       **** 			{
 591:tasks.c       **** 				/* If the scheduler is not already running, make this task the
 592:tasks.c       **** 				current task if it is the highest priority task to be created
 593:tasks.c       **** 				so far. */
 594:tasks.c       **** 				if( xSchedulerRunning == pdFALSE )
 377               	.LM14:
 378 00f8 8091 0000 		lds r24,xSchedulerRunning
 379 00fc 8823      		tst r24
 380 00fe 01F4      		brne .L6
 595:tasks.c       **** 				{
 596:tasks.c       **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 382               	.LM15:
 383 0100 8091 0000 		lds r24,pxCurrentTCB
 384 0104 9091 0000 		lds r25,pxCurrentTCB+1
 385 0108 FC01      		movw r30,r24
 386 010a 9689      		ldd r25,Z+22
 387 010c 8E85      		ldd r24,Y+14
 388 010e 8917      		cp r24,r25
 389 0110 00F0      		brlo .L6
 597:tasks.c       **** 					{
 598:tasks.c       **** 						pxCurrentTCB = pxNewTCB;
 391               	.LM16:
 392 0112 8A81      		ldd r24,Y+2
 393 0114 9B81      		ldd r25,Y+3
 394 0116 9093 0000 		sts pxCurrentTCB+1,r25
 395 011a 8093 0000 		sts pxCurrentTCB,r24
 396               	.L6:
 599:tasks.c       **** 					}
 600:tasks.c       **** 				}
 601:tasks.c       **** 			}
 602:tasks.c       **** 
 603:tasks.c       **** 			/* Remember the top priority to make context switching faster.  Use
 604:tasks.c       **** 			the priority in pxNewTCB as this has been capped to a valid value. */
 605:tasks.c       **** 			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 398               	.LM17:
 399 011e 8A81      		ldd r24,Y+2
 400 0120 9B81      		ldd r25,Y+3
 401 0122 FC01      		movw r30,r24
 402 0124 9689      		ldd r25,Z+22
 403 0126 8091 0000 		lds r24,uxTopUsedPriority
 404 012a 8917      		cp r24,r25
 405 012c 00F4      		brsh .L7
 606:tasks.c       **** 			{
 607:tasks.c       **** 				uxTopUsedPriority = pxNewTCB->uxPriority;
 407               	.LM18:
 408 012e 8A81      		ldd r24,Y+2
 409 0130 9B81      		ldd r25,Y+3
 410 0132 FC01      		movw r30,r24
 411 0134 8689      		ldd r24,Z+22
 412 0136 8093 0000 		sts uxTopUsedPriority,r24
 413               	.L7:
 608:tasks.c       **** 			}
 609:tasks.c       **** 
 610:tasks.c       **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 611:tasks.c       **** 			{
 612:tasks.c       **** 				/* Add a counter into the TCB for tracing only. */
 613:tasks.c       **** 				pxNewTCB->uxTCBNumber = uxTaskNumber;
 614:tasks.c       **** 			}
 615:tasks.c       **** 			#endif
 616:tasks.c       **** 			uxTaskNumber++;
 415               	.LM19:
 416 013a 8091 0000 		lds r24,uxTaskNumber
 417 013e 8F5F      		subi r24,lo8(-(1))
 418 0140 8093 0000 		sts uxTaskNumber,r24
 617:tasks.c       **** 
 618:tasks.c       **** 			prvAddTaskToReadyQueue( pxNewTCB );
 420               	.LM20:
 421 0144 8A81      		ldd r24,Y+2
 422 0146 9B81      		ldd r25,Y+3
 423 0148 FC01      		movw r30,r24
 424 014a 9689      		ldd r25,Z+22
 425 014c 8091 0000 		lds r24,uxTopReadyPriority
 426 0150 8917      		cp r24,r25
 427 0152 00F4      		brsh .L8
 429               	.LM21:
 430 0154 8A81      		ldd r24,Y+2
 431 0156 9B81      		ldd r25,Y+3
 432 0158 FC01      		movw r30,r24
 433 015a 8689      		ldd r24,Z+22
 434 015c 8093 0000 		sts uxTopReadyPriority,r24
 435               	.L8:
 437               	.LM22:
 438 0160 8A81      		ldd r24,Y+2
 439 0162 9B81      		ldd r25,Y+3
 440 0164 AC01      		movw r20,r24
 441 0166 4E5F      		subi r20,-2
 442 0168 5F4F      		sbci r21,-1
 443 016a 8A81      		ldd r24,Y+2
 444 016c 9B81      		ldd r25,Y+3
 445 016e FC01      		movw r30,r24
 446 0170 8689      		ldd r24,Z+22
 447 0172 282F      		mov r18,r24
 448 0174 30E0      		ldi r19,0
 449 0176 C901      		movw r24,r18
 450 0178 880F      		lsl r24
 451 017a 991F      		rol r25
 452 017c 880F      		lsl r24
 453 017e 991F      		rol r25
 454 0180 880F      		lsl r24
 455 0182 991F      		rol r25
 456 0184 820F      		add r24,r18
 457 0186 931F      		adc r25,r19
 458 0188 8050      		subi r24,lo8(-(pxReadyTasksLists))
 459 018a 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 460 018c BA01      		movw r22,r20
 461 018e 0E94 0000 		call vListInsertEnd
 619:tasks.c       **** 
 620:tasks.c       **** 			xReturn = pdPASS;
 463               	.LM23:
 464 0192 81E0      		ldi r24,lo8(1)
 465 0194 8983      		std Y+1,r24
 621:tasks.c       **** 			portSETUP_TCB( pxNewTCB );
 622:tasks.c       **** 			traceTASK_CREATE( pxNewTCB );
 623:tasks.c       **** 		}
 624:tasks.c       **** 		taskEXIT_CRITICAL();
 467               	.LM24:
 468               	/* #APP */
 469               	 ;  624 "tasks.c" 1
 470 0196 0F90      		pop		__tmp_reg__
 471               	 ;  0 "" 2
 472               	 ;  624 "tasks.c" 1
 473 0198 0FBE      		out		__SREG__, __tmp_reg__
 474               	 ;  0 "" 2
 475               	/* #NOAPP */
 476               	.LBE2:
 477 019a 00C0      		rjmp .L9
 478               	.L2:
 625:tasks.c       **** 	}
 626:tasks.c       **** 	else
 627:tasks.c       **** 	{
 628:tasks.c       **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 480               	.LM25:
 481 019c 8FEF      		ldi r24,lo8(-1)
 482 019e 8983      		std Y+1,r24
 483               	.L9:
 629:tasks.c       **** 		traceTASK_CREATE_FAILED();
 630:tasks.c       **** 	}
 631:tasks.c       **** 
 632:tasks.c       **** 	if( xReturn == pdPASS )
 485               	.LM26:
 486 01a0 8981      		ldd r24,Y+1
 487 01a2 8130      		cpi r24,lo8(1)
 488 01a4 01F4      		brne .L10
 633:tasks.c       **** 	{
 634:tasks.c       **** 		if( xSchedulerRunning != pdFALSE )
 490               	.LM27:
 491 01a6 8091 0000 		lds r24,xSchedulerRunning
 492 01aa 8823      		tst r24
 493 01ac 01F0      		breq .L10
 635:tasks.c       **** 		{
 636:tasks.c       **** 			/* If the created task is of a higher priority than the current task
 637:tasks.c       **** 			then it should run now. */
 638:tasks.c       **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 495               	.LM28:
 496 01ae 8091 0000 		lds r24,pxCurrentTCB
 497 01b2 9091 0000 		lds r25,pxCurrentTCB+1
 498 01b6 FC01      		movw r30,r24
 499 01b8 9689      		ldd r25,Z+22
 500 01ba 8E85      		ldd r24,Y+14
 501 01bc 9817      		cp r25,r24
 502 01be 00F4      		brsh .L10
 639:tasks.c       **** 			{
 640:tasks.c       **** 				portYIELD_WITHIN_API();
 504               	.LM29:
 505 01c0 0E94 0000 		call vPortYield
 506               	.L10:
 641:tasks.c       **** 			}
 642:tasks.c       **** 		}
 643:tasks.c       **** 	}
 644:tasks.c       **** 
 645:tasks.c       **** 	return xReturn;
 508               	.LM30:
 509 01c4 8981      		ldd r24,Y+1
 510               	/* epilogue start */
 646:tasks.c       **** }
 512               	.LM31:
 513 01c6 6496      		adiw r28,20
 514 01c8 0FB6      		in __tmp_reg__,__SREG__
 515 01ca F894      		cli
 516 01cc DEBF      		out __SP_H__,r29
 517 01ce 0FBE      		out __SREG__,__tmp_reg__
 518 01d0 CDBF      		out __SP_L__,r28
 519 01d2 DF91      		pop r29
 520 01d4 CF91      		pop r28
 521 01d6 1F91      		pop r17
 522 01d8 0F91      		pop r16
 523 01da FF90      		pop r15
 524 01dc EF90      		pop r14
 525 01de DF90      		pop r13
 526 01e0 CF90      		pop r12
 527 01e2 BF90      		pop r11
 528 01e4 AF90      		pop r10
 529 01e6 0895      		ret
 538               	.Lscope1:
 540               		.stabd	78,0,0
 544               	.global	vTaskDelayUntil
 546               	vTaskDelayUntil:
 547               		.stabd	46,0,0
 647:tasks.c       **** /*-----------------------------------------------------------*/
 648:tasks.c       **** 
 649:tasks.c       **** #if ( INCLUDE_vTaskDelete == 1 )
 650:tasks.c       **** 
 651:tasks.c       **** 	void vTaskDelete( xTaskHandle pxTaskToDelete )
 652:tasks.c       **** 	{
 653:tasks.c       **** 	tskTCB *pxTCB;
 654:tasks.c       **** 
 655:tasks.c       **** 		taskENTER_CRITICAL();
 656:tasks.c       **** 		{
 657:tasks.c       **** 			/* Ensure a yield is performed if the current task is being
 658:tasks.c       **** 			deleted. */
 659:tasks.c       **** 			if( pxTaskToDelete == pxCurrentTCB )
 660:tasks.c       **** 			{
 661:tasks.c       **** 				pxTaskToDelete = NULL;
 662:tasks.c       **** 			}
 663:tasks.c       **** 
 664:tasks.c       **** 			/* If null is passed in here then we are deleting ourselves. */
 665:tasks.c       **** 			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
 666:tasks.c       **** 
 667:tasks.c       **** 			/* Remove task from the ready list and place in the	termination list.
 668:tasks.c       **** 			This will stop the task from be scheduled.  The idle task will check
 669:tasks.c       **** 			the termination list and free up any memory allocated by the
 670:tasks.c       **** 			scheduler for the TCB and stack. */
 671:tasks.c       **** 			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
 672:tasks.c       **** 			{
 673:tasks.c       **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 674:tasks.c       **** 			}
 675:tasks.c       **** 
 676:tasks.c       **** 			/* Is the task waiting on an event also? */
 677:tasks.c       **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 678:tasks.c       **** 			{
 679:tasks.c       **** 				uxListRemove( &( pxTCB->xEventListItem ) );
 680:tasks.c       **** 			}
 681:tasks.c       **** 
 682:tasks.c       **** 			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 683:tasks.c       **** 
 684:tasks.c       **** 			/* Increment the ucTasksDeleted variable so the idle task knows
 685:tasks.c       **** 			there is a task that has been deleted and that it should therefore
 686:tasks.c       **** 			check the xTasksWaitingTermination list. */
 687:tasks.c       **** 			++uxTasksDeleted;
 688:tasks.c       **** 
 689:tasks.c       **** 			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
 690:tasks.c       **** 			can detect that the task lists need re-generating. */
 691:tasks.c       **** 			uxTaskNumber++;
 692:tasks.c       **** 
 693:tasks.c       **** 			traceTASK_DELETE( pxTCB );
 694:tasks.c       **** 		}
 695:tasks.c       **** 		taskEXIT_CRITICAL();
 696:tasks.c       **** 
 697:tasks.c       **** 		/* Force a reschedule if we have just deleted the current task. */
 698:tasks.c       **** 		if( xSchedulerRunning != pdFALSE )
 699:tasks.c       **** 		{
 700:tasks.c       **** 			if( ( void * ) pxTaskToDelete == NULL )
 701:tasks.c       **** 			{
 702:tasks.c       **** 				portYIELD_WITHIN_API();
 703:tasks.c       **** 			}
 704:tasks.c       **** 		}
 705:tasks.c       **** 	}
 706:tasks.c       **** 
 707:tasks.c       **** #endif
 708:tasks.c       **** 
 709:tasks.c       **** 
 710:tasks.c       **** 
 711:tasks.c       **** 
 712:tasks.c       **** 
 713:tasks.c       **** 
 714:tasks.c       **** /*-----------------------------------------------------------
 715:tasks.c       ****  * TASK CONTROL API documented in task.h
 716:tasks.c       ****  *----------------------------------------------------------*/
 717:tasks.c       **** 
 718:tasks.c       **** #if ( INCLUDE_vTaskDelayUntil == 1 )
 719:tasks.c       **** 
 720:tasks.c       **** 	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
 721:tasks.c       **** 	{
 549               	.LM32:
 550               	.LFBB2:
 551 01e8 CF93      		push r28
 552 01ea DF93      		push r29
 553 01ec CDB7      		in r28,__SP_L__
 554 01ee DEB7      		in r29,__SP_H__
 555 01f0 2897      		sbiw r28,8
 556 01f2 0FB6      		in __tmp_reg__,__SREG__
 557 01f4 F894      		cli
 558 01f6 DEBF      		out __SP_H__,r29
 559 01f8 0FBE      		out __SREG__,__tmp_reg__
 560 01fa CDBF      		out __SP_L__,r28
 561               	/* prologue: function */
 562               	/* frame size = 8 */
 563               	/* stack size = 10 */
 564               	.L__stack_usage = 10
 565 01fc 9E83      		std Y+6,r25
 566 01fe 8D83      		std Y+5,r24
 567 0200 7887      		std Y+8,r23
 568 0202 6F83      		std Y+7,r22
 722:tasks.c       **** 	portTickType xTimeToWake;
 723:tasks.c       **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 570               	.LM33:
 571 0204 1982      		std Y+1,__zero_reg__
 724:tasks.c       **** 
 725:tasks.c       **** 		configASSERT( pxPreviousWakeTime );
 726:tasks.c       **** 		configASSERT( ( xTimeIncrement > 0U ) );
 727:tasks.c       **** 
 728:tasks.c       **** 		vTaskSuspendAll();
 573               	.LM34:
 574 0206 0E94 0000 		call vTaskSuspendAll
 729:tasks.c       **** 		{
 730:tasks.c       **** 			/* Generate the tick time at which the task wants to wake. */
 731:tasks.c       **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 576               	.LM35:
 577 020a 8D81      		ldd r24,Y+5
 578 020c 9E81      		ldd r25,Y+6
 579 020e FC01      		movw r30,r24
 580 0210 2081      		ld r18,Z
 581 0212 3181      		ldd r19,Z+1
 582 0214 8F81      		ldd r24,Y+7
 583 0216 9885      		ldd r25,Y+8
 584 0218 820F      		add r24,r18
 585 021a 931F      		adc r25,r19
 586 021c 9B83      		std Y+3,r25
 587 021e 8A83      		std Y+2,r24
 732:tasks.c       **** 
 733:tasks.c       **** 			if( xTickCount < *pxPreviousWakeTime )
 589               	.LM36:
 590 0220 8D81      		ldd r24,Y+5
 591 0222 9E81      		ldd r25,Y+6
 592 0224 FC01      		movw r30,r24
 593 0226 2081      		ld r18,Z
 594 0228 3181      		ldd r19,Z+1
 595 022a 8091 0000 		lds r24,xTickCount
 596 022e 9091 0000 		lds r25,xTickCount+1
 597 0232 8217      		cp r24,r18
 598 0234 9307      		cpc r25,r19
 599 0236 00F4      		brsh .L13
 734:tasks.c       **** 			{
 735:tasks.c       **** 				/* The tick count has overflowed since this function was
 736:tasks.c       **** 				lasted called.  In this case the only time we should ever
 737:tasks.c       **** 				actually delay is if the wake time has also	overflowed,
 738:tasks.c       **** 				and the wake time is greater than the tick time.  When this
 739:tasks.c       **** 				is the case it is as if neither time had overflowed. */
 740:tasks.c       **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 601               	.LM37:
 602 0238 8D81      		ldd r24,Y+5
 603 023a 9E81      		ldd r25,Y+6
 604 023c FC01      		movw r30,r24
 605 023e 2081      		ld r18,Z
 606 0240 3181      		ldd r19,Z+1
 607 0242 8A81      		ldd r24,Y+2
 608 0244 9B81      		ldd r25,Y+3
 609 0246 8217      		cp r24,r18
 610 0248 9307      		cpc r25,r19
 611 024a 00F4      		brsh .L15
 613               	.LM38:
 614 024c 8091 0000 		lds r24,xTickCount
 615 0250 9091 0000 		lds r25,xTickCount+1
 616 0254 2A81      		ldd r18,Y+2
 617 0256 3B81      		ldd r19,Y+3
 618 0258 8217      		cp r24,r18
 619 025a 9307      		cpc r25,r19
 620 025c 00F4      		brsh .L15
 741:tasks.c       **** 				{
 742:tasks.c       **** 					xShouldDelay = pdTRUE;
 622               	.LM39:
 623 025e 81E0      		ldi r24,lo8(1)
 624 0260 8983      		std Y+1,r24
 625 0262 00C0      		rjmp .L15
 626               	.L13:
 743:tasks.c       **** 				}
 744:tasks.c       **** 			}
 745:tasks.c       **** 			else
 746:tasks.c       **** 			{
 747:tasks.c       **** 				/* The tick time has not overflowed.  In this case we will
 748:tasks.c       **** 				delay if either the wake time has overflowed, and/or the
 749:tasks.c       **** 				tick time is less than the wake time. */
 750:tasks.c       **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 628               	.LM40:
 629 0264 8D81      		ldd r24,Y+5
 630 0266 9E81      		ldd r25,Y+6
 631 0268 FC01      		movw r30,r24
 632 026a 2081      		ld r18,Z
 633 026c 3181      		ldd r19,Z+1
 634 026e 8A81      		ldd r24,Y+2
 635 0270 9B81      		ldd r25,Y+3
 636 0272 8217      		cp r24,r18
 637 0274 9307      		cpc r25,r19
 638 0276 00F0      		brlo .L16
 640               	.LM41:
 641 0278 8091 0000 		lds r24,xTickCount
 642 027c 9091 0000 		lds r25,xTickCount+1
 643 0280 2A81      		ldd r18,Y+2
 644 0282 3B81      		ldd r19,Y+3
 645 0284 8217      		cp r24,r18
 646 0286 9307      		cpc r25,r19
 647 0288 00F4      		brsh .L15
 648               	.L16:
 751:tasks.c       **** 				{
 752:tasks.c       **** 					xShouldDelay = pdTRUE;
 650               	.LM42:
 651 028a 81E0      		ldi r24,lo8(1)
 652 028c 8983      		std Y+1,r24
 653               	.L15:
 753:tasks.c       **** 				}
 754:tasks.c       **** 			}
 755:tasks.c       **** 
 756:tasks.c       **** 			/* Update the wake time ready for the next call. */
 757:tasks.c       **** 			*pxPreviousWakeTime = xTimeToWake;
 655               	.LM43:
 656 028e 8D81      		ldd r24,Y+5
 657 0290 9E81      		ldd r25,Y+6
 658 0292 2A81      		ldd r18,Y+2
 659 0294 3B81      		ldd r19,Y+3
 660 0296 FC01      		movw r30,r24
 661 0298 3183      		std Z+1,r19
 662 029a 2083      		st Z,r18
 758:tasks.c       **** 
 759:tasks.c       **** 			if( xShouldDelay != pdFALSE )
 664               	.LM44:
 665 029c 8981      		ldd r24,Y+1
 666 029e 8823      		tst r24
 667 02a0 01F0      		breq .L17
 760:tasks.c       **** 			{
 761:tasks.c       **** 				traceTASK_DELAY_UNTIL();
 762:tasks.c       **** 
 763:tasks.c       **** 				/* We must remove ourselves from the ready list before adding
 764:tasks.c       **** 				ourselves to the blocked list as the same list item is used for
 765:tasks.c       **** 				both lists. */
 766:tasks.c       **** 				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
 669               	.LM45:
 670 02a2 8091 0000 		lds r24,pxCurrentTCB
 671 02a6 9091 0000 		lds r25,pxCurrentTCB+1
 672 02aa 0296      		adiw r24,2
 673 02ac 0E94 0000 		call uxListRemove
 767:tasks.c       **** 				{
 768:tasks.c       **** 					/* The current task must be in a ready list, so there is
 769:tasks.c       **** 					no need to check, and the port reset macro can be called
 770:tasks.c       **** 					directly. */
 771:tasks.c       **** 					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 772:tasks.c       **** 				}
 773:tasks.c       **** 
 774:tasks.c       **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 675               	.LM46:
 676 02b0 8A81      		ldd r24,Y+2
 677 02b2 9B81      		ldd r25,Y+3
 678 02b4 0E94 0000 		call prvAddCurrentTaskToDelayedList
 679               	.L17:
 775:tasks.c       **** 			}
 776:tasks.c       **** 		}
 777:tasks.c       **** 		xAlreadyYielded = xTaskResumeAll();
 681               	.LM47:
 682 02b8 0E94 0000 		call xTaskResumeAll
 683 02bc 8C83      		std Y+4,r24
 778:tasks.c       **** 
 779:tasks.c       **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 780:tasks.c       **** 		have put ourselves to sleep. */
 781:tasks.c       **** 		if( xAlreadyYielded == pdFALSE )
 685               	.LM48:
 686 02be 8C81      		ldd r24,Y+4
 687 02c0 8823      		tst r24
 688 02c2 01F4      		brne .L12
 782:tasks.c       **** 		{
 783:tasks.c       **** 			portYIELD_WITHIN_API();
 690               	.LM49:
 691 02c4 0E94 0000 		call vPortYield
 692               	.L12:
 693               	/* epilogue start */
 784:tasks.c       **** 		}
 785:tasks.c       **** 	}
 695               	.LM50:
 696 02c8 2896      		adiw r28,8
 697 02ca 0FB6      		in __tmp_reg__,__SREG__
 698 02cc F894      		cli
 699 02ce DEBF      		out __SP_H__,r29
 700 02d0 0FBE      		out __SREG__,__tmp_reg__
 701 02d2 CDBF      		out __SP_L__,r28
 702 02d4 DF91      		pop r29
 703 02d6 CF91      		pop r28
 704 02d8 0895      		ret
 711               	.Lscope2:
 713               		.stabd	78,0,0
 716               	.global	vTaskDelay
 718               	vTaskDelay:
 719               		.stabd	46,0,0
 786:tasks.c       **** 
 787:tasks.c       **** #endif
 788:tasks.c       **** /*-----------------------------------------------------------*/
 789:tasks.c       **** 
 790:tasks.c       **** #if ( INCLUDE_vTaskDelay == 1 )
 791:tasks.c       **** 
 792:tasks.c       **** 	void vTaskDelay( portTickType xTicksToDelay )
 793:tasks.c       **** 	{
 721               	.LM51:
 722               	.LFBB3:
 723 02da CF93      		push r28
 724 02dc DF93      		push r29
 725 02de 00D0      		rcall .
 726 02e0 1F92      		push __zero_reg__
 727 02e2 1F92      		push __zero_reg__
 728 02e4 CDB7      		in r28,__SP_L__
 729 02e6 DEB7      		in r29,__SP_H__
 730               	/* prologue: function */
 731               	/* frame size = 5 */
 732               	/* stack size = 7 */
 733               	.L__stack_usage = 7
 734 02e8 9D83      		std Y+5,r25
 735 02ea 8C83      		std Y+4,r24
 794:tasks.c       **** 	portTickType xTimeToWake;
 795:tasks.c       **** 	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 737               	.LM52:
 738 02ec 1982      		std Y+1,__zero_reg__
 796:tasks.c       **** 
 797:tasks.c       **** 		/* A delay time of zero just forces a reschedule. */
 798:tasks.c       **** 		if( xTicksToDelay > ( portTickType ) 0U )
 740               	.LM53:
 741 02ee 8C81      		ldd r24,Y+4
 742 02f0 9D81      		ldd r25,Y+5
 743 02f2 0097      		sbiw r24,0
 744 02f4 01F0      		breq .L20
 799:tasks.c       **** 		{
 800:tasks.c       **** 			vTaskSuspendAll();
 746               	.LM54:
 747 02f6 0E94 0000 		call vTaskSuspendAll
 801:tasks.c       **** 			{
 802:tasks.c       **** 				traceTASK_DELAY();
 803:tasks.c       **** 
 804:tasks.c       **** 				/* A task that is removed from the event list while the
 805:tasks.c       **** 				scheduler is suspended will not get placed in the ready
 806:tasks.c       **** 				list or removed from the blocked list until the scheduler
 807:tasks.c       **** 				is resumed.
 808:tasks.c       **** 
 809:tasks.c       **** 				This task cannot be in an event list as it is the currently
 810:tasks.c       **** 				executing task. */
 811:tasks.c       **** 
 812:tasks.c       **** 				/* Calculate the time to wake - this may overflow but this is
 813:tasks.c       **** 				not a problem. */
 814:tasks.c       **** 				xTimeToWake = xTickCount + xTicksToDelay;
 749               	.LM55:
 750 02fa 2091 0000 		lds r18,xTickCount
 751 02fe 3091 0000 		lds r19,xTickCount+1
 752 0302 8C81      		ldd r24,Y+4
 753 0304 9D81      		ldd r25,Y+5
 754 0306 820F      		add r24,r18
 755 0308 931F      		adc r25,r19
 756 030a 9B83      		std Y+3,r25
 757 030c 8A83      		std Y+2,r24
 815:tasks.c       **** 
 816:tasks.c       **** 				/* We must remove ourselves from the ready list before adding
 817:tasks.c       **** 				ourselves to the blocked list as the same list item is used for
 818:tasks.c       **** 				both lists. */
 819:tasks.c       **** 				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
 759               	.LM56:
 760 030e 8091 0000 		lds r24,pxCurrentTCB
 761 0312 9091 0000 		lds r25,pxCurrentTCB+1
 762 0316 0296      		adiw r24,2
 763 0318 0E94 0000 		call uxListRemove
 820:tasks.c       **** 				{
 821:tasks.c       **** 					/* The current task must be in a ready list, so there is
 822:tasks.c       **** 					no need to check, and the port reset macro can be called
 823:tasks.c       **** 					directly. */
 824:tasks.c       **** 					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 825:tasks.c       **** 				}
 826:tasks.c       **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 765               	.LM57:
 766 031c 8A81      		ldd r24,Y+2
 767 031e 9B81      		ldd r25,Y+3
 768 0320 0E94 0000 		call prvAddCurrentTaskToDelayedList
 827:tasks.c       **** 			}
 828:tasks.c       **** 			xAlreadyYielded = xTaskResumeAll();
 770               	.LM58:
 771 0324 0E94 0000 		call xTaskResumeAll
 772 0328 8983      		std Y+1,r24
 773               	.L20:
 829:tasks.c       **** 		}
 830:tasks.c       **** 
 831:tasks.c       **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 832:tasks.c       **** 		have put ourselves to sleep. */
 833:tasks.c       **** 		if( xAlreadyYielded == pdFALSE )
 775               	.LM59:
 776 032a 8981      		ldd r24,Y+1
 777 032c 8823      		tst r24
 778 032e 01F4      		brne .L19
 834:tasks.c       **** 		{
 835:tasks.c       **** 			portYIELD_WITHIN_API();
 780               	.LM60:
 781 0330 0E94 0000 		call vPortYield
 782               	.L19:
 783               	/* epilogue start */
 836:tasks.c       **** 		}
 837:tasks.c       **** 	}
 785               	.LM61:
 786 0334 0F90      		pop __tmp_reg__
 787 0336 0F90      		pop __tmp_reg__
 788 0338 0F90      		pop __tmp_reg__
 789 033a 0F90      		pop __tmp_reg__
 790 033c 0F90      		pop __tmp_reg__
 791 033e DF91      		pop r29
 792 0340 CF91      		pop r28
 793 0342 0895      		ret
 799               	.Lscope3:
 801               		.stabd	78,0,0
 804               	.global	vTaskSuspend
 806               	vTaskSuspend:
 807               		.stabd	46,0,0
 838:tasks.c       **** 
 839:tasks.c       **** #endif
 840:tasks.c       **** /*-----------------------------------------------------------*/
 841:tasks.c       **** 
 842:tasks.c       **** #if ( INCLUDE_eTaskStateGet == 1 )
 843:tasks.c       **** 
 844:tasks.c       **** 	eTaskState eTaskStateGet( xTaskHandle pxTask )
 845:tasks.c       **** 	{
 846:tasks.c       **** 	eTaskState eReturn;
 847:tasks.c       **** 	xList *pxStateList;
 848:tasks.c       **** 	tskTCB *pxTCB;
 849:tasks.c       **** 
 850:tasks.c       **** 		pxTCB = ( tskTCB * ) pxTask;
 851:tasks.c       **** 
 852:tasks.c       **** 		if( pxTCB == pxCurrentTCB )
 853:tasks.c       **** 		{
 854:tasks.c       **** 			/* The task calling this function is querying its own state. */
 855:tasks.c       **** 			eReturn = eRunning;
 856:tasks.c       **** 		}
 857:tasks.c       **** 		else
 858:tasks.c       **** 		{
 859:tasks.c       **** 			taskENTER_CRITICAL();
 860:tasks.c       **** 			{
 861:tasks.c       **** 				pxStateList = ( xList * ) listLIST_ITEM_CONTAINER( &( pxTCB->xGenericListItem ) );
 862:tasks.c       **** 			}
 863:tasks.c       **** 			taskEXIT_CRITICAL();
 864:tasks.c       **** 
 865:tasks.c       **** 			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
 866:tasks.c       **** 			{
 867:tasks.c       **** 				/* The task being queried is referenced from one of the Blocked
 868:tasks.c       **** 				lists. */
 869:tasks.c       **** 				eReturn = eBlocked;
 870:tasks.c       **** 			}
 871:tasks.c       **** 
 872:tasks.c       **** 			#if ( INCLUDE_vTaskSuspend == 1 )
 873:tasks.c       **** 				else if( pxStateList == &xSuspendedTaskList )
 874:tasks.c       **** 				{
 875:tasks.c       **** 					/* The task being queried is referenced from the suspended
 876:tasks.c       **** 					list. */
 877:tasks.c       **** 					eReturn = eSuspended;
 878:tasks.c       **** 				}
 879:tasks.c       **** 			#endif
 880:tasks.c       **** 
 881:tasks.c       **** 			#if ( INCLUDE_vTaskDelete == 1 )
 882:tasks.c       **** 				else if( pxStateList == &xTasksWaitingTermination )
 883:tasks.c       **** 				{
 884:tasks.c       **** 					/* The task being queried is referenced from the deleted
 885:tasks.c       **** 					tasks list. */
 886:tasks.c       **** 					eReturn = eDeleted;
 887:tasks.c       **** 				}
 888:tasks.c       **** 			#endif
 889:tasks.c       **** 
 890:tasks.c       **** 			else
 891:tasks.c       **** 			{
 892:tasks.c       **** 				/* If the task is not in any other state, it must be in the
 893:tasks.c       **** 				Ready (including pending ready) state. */
 894:tasks.c       **** 				eReturn = eReady;
 895:tasks.c       **** 			}
 896:tasks.c       **** 		}
 897:tasks.c       **** 
 898:tasks.c       **** 		return eReturn;
 899:tasks.c       **** 	}
 900:tasks.c       **** 
 901:tasks.c       **** #endif
 902:tasks.c       **** /*-----------------------------------------------------------*/
 903:tasks.c       **** 
 904:tasks.c       **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
 905:tasks.c       **** 
 906:tasks.c       **** 	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
 907:tasks.c       **** 	{
 908:tasks.c       **** 	tskTCB *pxTCB;
 909:tasks.c       **** 	unsigned portBASE_TYPE uxReturn;
 910:tasks.c       **** 
 911:tasks.c       **** 		taskENTER_CRITICAL();
 912:tasks.c       **** 		{
 913:tasks.c       **** 			/* If null is passed in here then we are changing the
 914:tasks.c       **** 			priority of the calling function. */
 915:tasks.c       **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 916:tasks.c       **** 			uxReturn = pxTCB->uxPriority;
 917:tasks.c       **** 		}
 918:tasks.c       **** 		taskEXIT_CRITICAL();
 919:tasks.c       **** 
 920:tasks.c       **** 		return uxReturn;
 921:tasks.c       **** 	}
 922:tasks.c       **** 
 923:tasks.c       **** #endif
 924:tasks.c       **** /*-----------------------------------------------------------*/
 925:tasks.c       **** 
 926:tasks.c       **** #if ( INCLUDE_vTaskPrioritySet == 1 )
 927:tasks.c       **** 
 928:tasks.c       **** 	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
 929:tasks.c       **** 	{
 930:tasks.c       **** 	tskTCB *pxTCB;
 931:tasks.c       **** 	unsigned portBASE_TYPE uxCurrentPriority, uxPriorityUsedOnEntry;
 932:tasks.c       **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 933:tasks.c       **** 
 934:tasks.c       **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 935:tasks.c       **** 
 936:tasks.c       **** 		/* Ensure the new priority is valid. */
 937:tasks.c       **** 		if( uxNewPriority >= configMAX_PRIORITIES )
 938:tasks.c       **** 		{
 939:tasks.c       **** 			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 940:tasks.c       **** 		}
 941:tasks.c       **** 
 942:tasks.c       **** 		taskENTER_CRITICAL();
 943:tasks.c       **** 		{
 944:tasks.c       **** 			if( pxTask == pxCurrentTCB )
 945:tasks.c       **** 			{
 946:tasks.c       **** 				pxTask = NULL;
 947:tasks.c       **** 			}
 948:tasks.c       **** 
 949:tasks.c       **** 			/* If null is passed in here then we are changing the
 950:tasks.c       **** 			priority of the calling function. */
 951:tasks.c       **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 952:tasks.c       **** 
 953:tasks.c       **** 			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
 954:tasks.c       **** 
 955:tasks.c       **** 			#if ( configUSE_MUTEXES == 1 )
 956:tasks.c       **** 			{
 957:tasks.c       **** 				uxCurrentPriority = pxTCB->uxBasePriority;
 958:tasks.c       **** 			}
 959:tasks.c       **** 			#else
 960:tasks.c       **** 			{
 961:tasks.c       **** 				uxCurrentPriority = pxTCB->uxPriority;
 962:tasks.c       **** 			}
 963:tasks.c       **** 			#endif
 964:tasks.c       **** 
 965:tasks.c       **** 			if( uxCurrentPriority != uxNewPriority )
 966:tasks.c       **** 			{
 967:tasks.c       **** 				/* The priority change may have readied a task of higher
 968:tasks.c       **** 				priority than the calling task. */
 969:tasks.c       **** 				if( uxNewPriority > uxCurrentPriority )
 970:tasks.c       **** 				{
 971:tasks.c       **** 					if( pxTask != NULL )
 972:tasks.c       **** 					{
 973:tasks.c       **** 						/* The priority of another task is being raised.  If we
 974:tasks.c       **** 						were raising the priority of the currently running task
 975:tasks.c       **** 						there would be no need to switch as it must have already
 976:tasks.c       **** 						been the highest priority task. */
 977:tasks.c       **** 						xYieldRequired = pdTRUE;
 978:tasks.c       **** 					}
 979:tasks.c       **** 				}
 980:tasks.c       **** 				else if( pxTask == NULL )
 981:tasks.c       **** 				{
 982:tasks.c       **** 					/* Setting our own priority down means there may now be another
 983:tasks.c       **** 					task of higher priority that is ready to execute. */
 984:tasks.c       **** 					xYieldRequired = pdTRUE;
 985:tasks.c       **** 				}
 986:tasks.c       **** 
 987:tasks.c       **** 				/* Remember the ready list the task might be referenced from
 988:tasks.c       **** 				before its uxPriority member is changed so the
 989:tasks.c       **** 				taskRESET_READY_PRIORITY() macro can function correctly. */
 990:tasks.c       **** 				uxPriorityUsedOnEntry = pxTCB->uxPriority;
 991:tasks.c       **** 
 992:tasks.c       **** 				#if ( configUSE_MUTEXES == 1 )
 993:tasks.c       **** 				{
 994:tasks.c       **** 					/* Only change the priority being used if the task is not
 995:tasks.c       **** 					currently using an inherited priority. */
 996:tasks.c       **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 997:tasks.c       **** 					{
 998:tasks.c       **** 						pxTCB->uxPriority = uxNewPriority;
 999:tasks.c       **** 					}
1000:tasks.c       **** 
1001:tasks.c       **** 					/* The base priority gets set whatever. */
1002:tasks.c       **** 					pxTCB->uxBasePriority = uxNewPriority;
1003:tasks.c       **** 				}
1004:tasks.c       **** 				#else
1005:tasks.c       **** 				{
1006:tasks.c       **** 					pxTCB->uxPriority = uxNewPriority;
1007:tasks.c       **** 				}
1008:tasks.c       **** 				#endif
1009:tasks.c       **** 
1010:tasks.c       **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) 
1011:tasks.c       **** 
1012:tasks.c       **** 				/* If the task is in the blocked or suspended list we need do
1013:tasks.c       **** 				nothing more than change it's priority variable. However, if
1014:tasks.c       **** 				the task is in a ready list it needs to be removed and placed
1015:tasks.c       **** 				in the queue appropriate to its new priority. */
1016:tasks.c       **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericLis
1017:tasks.c       **** 				{
1018:tasks.c       **** 					/* The task is currently in its ready list - remove before adding
1019:tasks.c       **** 					it to it's new ready list.  As we are in a critical section we
1020:tasks.c       **** 					can do this even if the scheduler is suspended. */
1021:tasks.c       **** 					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
1022:tasks.c       **** 					{
1023:tasks.c       **** 						taskRESET_READY_PRIORITY( uxPriorityUsedOnEntry );
1024:tasks.c       **** 					}
1025:tasks.c       **** 					prvAddTaskToReadyQueue( pxTCB );
1026:tasks.c       **** 				}
1027:tasks.c       **** 
1028:tasks.c       **** 				if( xYieldRequired == pdTRUE )
1029:tasks.c       **** 				{
1030:tasks.c       **** 					portYIELD_WITHIN_API();
1031:tasks.c       **** 				}
1032:tasks.c       **** 			}
1033:tasks.c       **** 		}
1034:tasks.c       **** 		taskEXIT_CRITICAL();
1035:tasks.c       **** 
1036:tasks.c       **** 		/* Remove compiler warning about unused parameter when the port
1037:tasks.c       **** 		optimised task selection is not being used. */
1038:tasks.c       **** 		( void ) uxPriorityUsedOnEntry;
1039:tasks.c       **** 	}
1040:tasks.c       **** 
1041:tasks.c       **** #endif
1042:tasks.c       **** /*-----------------------------------------------------------*/
1043:tasks.c       **** 
1044:tasks.c       **** #if ( INCLUDE_vTaskSuspend == 1 )
1045:tasks.c       **** 
1046:tasks.c       **** 	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
1047:tasks.c       **** 	{
 809               	.LM62:
 810               	.LFBB4:
 811 0344 CF93      		push r28
 812 0346 DF93      		push r29
 813 0348 00D0      		rcall .
 814 034a 1F92      		push __zero_reg__
 815 034c CDB7      		in r28,__SP_L__
 816 034e DEB7      		in r29,__SP_H__
 817               	/* prologue: function */
 818               	/* frame size = 4 */
 819               	/* stack size = 6 */
 820               	.L__stack_usage = 6
 821 0350 9C83      		std Y+4,r25
 822 0352 8B83      		std Y+3,r24
1048:tasks.c       **** 	tskTCB *pxTCB;
1049:tasks.c       **** 
1050:tasks.c       **** 		taskENTER_CRITICAL();
 824               	.LM63:
 825               	/* #APP */
 826               	 ;  1050 "tasks.c" 1
 827 0354 0FB6      		in		__tmp_reg__, __SREG__
 828               	 ;  0 "" 2
 829               	 ;  1050 "tasks.c" 1
 830 0356 F894      		cli
 831               	 ;  0 "" 2
 832               	 ;  1050 "tasks.c" 1
 833 0358 0F92      		push	__tmp_reg__
 834               	 ;  0 "" 2
1051:tasks.c       **** 		{
1052:tasks.c       **** 			/* Ensure a yield is performed if the current task is being
1053:tasks.c       **** 			suspended. */
1054:tasks.c       **** 			if( pxTaskToSuspend == pxCurrentTCB )
 836               	.LM64:
 837               	/* #NOAPP */
 838 035a 8091 0000 		lds r24,pxCurrentTCB
 839 035e 9091 0000 		lds r25,pxCurrentTCB+1
 840 0362 2B81      		ldd r18,Y+3
 841 0364 3C81      		ldd r19,Y+4
 842 0366 2817      		cp r18,r24
 843 0368 3907      		cpc r19,r25
 844 036a 01F4      		brne .L23
1055:tasks.c       **** 			{
1056:tasks.c       **** 				pxTaskToSuspend = NULL;
 846               	.LM65:
 847 036c 1C82      		std Y+4,__zero_reg__
 848 036e 1B82      		std Y+3,__zero_reg__
 849               	.L23:
1057:tasks.c       **** 			}
1058:tasks.c       **** 
1059:tasks.c       **** 			/* If null is passed in here then we are suspending ourselves. */
1060:tasks.c       **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 851               	.LM66:
 852 0370 8B81      		ldd r24,Y+3
 853 0372 9C81      		ldd r25,Y+4
 854 0374 0097      		sbiw r24,0
 855 0376 01F4      		brne .L24
 857               	.LM67:
 858 0378 8091 0000 		lds r24,pxCurrentTCB
 859 037c 9091 0000 		lds r25,pxCurrentTCB+1
 860 0380 00C0      		rjmp .L25
 861               	.L24:
 863               	.LM68:
 864 0382 8B81      		ldd r24,Y+3
 865 0384 9C81      		ldd r25,Y+4
 866               	.L25:
 868               	.LM69:
 869 0386 9A83      		std Y+2,r25
 870 0388 8983      		std Y+1,r24
1061:tasks.c       **** 
1062:tasks.c       **** 			traceTASK_SUSPEND( pxTCB );
1063:tasks.c       **** 
1064:tasks.c       **** 			/* Remove task from the ready/delayed list and place in the	suspended list. */
1065:tasks.c       **** 			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
 872               	.LM70:
 873 038a 8981      		ldd r24,Y+1
 874 038c 9A81      		ldd r25,Y+2
 875 038e 0296      		adiw r24,2
 876 0390 0E94 0000 		call uxListRemove
1066:tasks.c       **** 			{
1067:tasks.c       **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1068:tasks.c       **** 			}
1069:tasks.c       **** 
1070:tasks.c       **** 			/* Is the task waiting on an event also? */
1071:tasks.c       **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 878               	.LM71:
 879 0394 8981      		ldd r24,Y+1
 880 0396 9A81      		ldd r25,Y+2
 881 0398 FC01      		movw r30,r24
 882 039a 8489      		ldd r24,Z+20
 883 039c 9589      		ldd r25,Z+21
 884 039e 0097      		sbiw r24,0
 885 03a0 01F0      		breq .L26
1072:tasks.c       **** 			{
1073:tasks.c       **** 				uxListRemove( &( pxTCB->xEventListItem ) );
 887               	.LM72:
 888 03a2 8981      		ldd r24,Y+1
 889 03a4 9A81      		ldd r25,Y+2
 890 03a6 0C96      		adiw r24,12
 891 03a8 0E94 0000 		call uxListRemove
 892               	.L26:
1074:tasks.c       **** 			}
1075:tasks.c       **** 
1076:tasks.c       **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 894               	.LM73:
 895 03ac 8981      		ldd r24,Y+1
 896 03ae 9A81      		ldd r25,Y+2
 897 03b0 0296      		adiw r24,2
 898 03b2 BC01      		movw r22,r24
 899 03b4 80E0      		ldi r24,lo8(xSuspendedTaskList)
 900 03b6 90E0      		ldi r25,hi8(xSuspendedTaskList)
 901 03b8 0E94 0000 		call vListInsertEnd
1077:tasks.c       **** 		}
1078:tasks.c       **** 		taskEXIT_CRITICAL();
 903               	.LM74:
 904               	/* #APP */
 905               	 ;  1078 "tasks.c" 1
 906 03bc 0F90      		pop		__tmp_reg__
 907               	 ;  0 "" 2
 908               	 ;  1078 "tasks.c" 1
 909 03be 0FBE      		out		__SREG__, __tmp_reg__
 910               	 ;  0 "" 2
1079:tasks.c       **** 
1080:tasks.c       **** 		if( ( void * ) pxTaskToSuspend == NULL )
 912               	.LM75:
 913               	/* #NOAPP */
 914 03c0 8B81      		ldd r24,Y+3
 915 03c2 9C81      		ldd r25,Y+4
 916 03c4 0097      		sbiw r24,0
 917 03c6 01F4      		brne .L22
1081:tasks.c       **** 		{
1082:tasks.c       **** 			if( xSchedulerRunning != pdFALSE )
 919               	.LM76:
 920 03c8 8091 0000 		lds r24,xSchedulerRunning
 921 03cc 8823      		tst r24
 922 03ce 01F0      		breq .L28
1083:tasks.c       **** 			{
1084:tasks.c       **** 				/* We have just suspended the current task. */
1085:tasks.c       **** 				portYIELD_WITHIN_API();
 924               	.LM77:
 925 03d0 0E94 0000 		call vPortYield
 926 03d4 00C0      		rjmp .L22
 927               	.L28:
1086:tasks.c       **** 			}
1087:tasks.c       **** 			else
1088:tasks.c       **** 			{
1089:tasks.c       **** 				/* The scheduler is not running, but the task that was pointed
1090:tasks.c       **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
1091:tasks.c       **** 				must be adjusted to point to a different task. */
1092:tasks.c       **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 929               	.LM78:
 930 03d6 9091 0000 		lds r25,xSuspendedTaskList
 931 03da 8091 0000 		lds r24,uxCurrentNumberOfTasks
 932 03de 9817      		cp r25,r24
 933 03e0 01F4      		brne .L29
1093:tasks.c       **** 				{
1094:tasks.c       **** 					/* No other tasks are ready, so set pxCurrentTCB back to
1095:tasks.c       **** 					NULL so when the next task is created pxCurrentTCB will
1096:tasks.c       **** 					be set to point to it no matter what its relative priority
1097:tasks.c       **** 					is. */
1098:tasks.c       **** 					pxCurrentTCB = NULL;
 935               	.LM79:
 936 03e2 1092 0000 		sts pxCurrentTCB+1,__zero_reg__
 937 03e6 1092 0000 		sts pxCurrentTCB,__zero_reg__
 938 03ea 00C0      		rjmp .L22
 939               	.L29:
1099:tasks.c       **** 				}
1100:tasks.c       **** 				else
1101:tasks.c       **** 				{
1102:tasks.c       **** 					vTaskSwitchContext();
 941               	.LM80:
 942 03ec 0E94 0000 		call vTaskSwitchContext
 943               	.L22:
 944               	/* epilogue start */
1103:tasks.c       **** 				}
1104:tasks.c       **** 			}
1105:tasks.c       **** 		}
1106:tasks.c       **** 	}
 946               	.LM81:
 947 03f0 0F90      		pop __tmp_reg__
 948 03f2 0F90      		pop __tmp_reg__
 949 03f4 0F90      		pop __tmp_reg__
 950 03f6 0F90      		pop __tmp_reg__
 951 03f8 DF91      		pop r29
 952 03fa CF91      		pop r28
 953 03fc 0895      		ret
 958               	.Lscope4:
 960               		.stabd	78,0,0
 963               	.global	xTaskIsTaskSuspended
 965               	xTaskIsTaskSuspended:
 966               		.stabd	46,0,0
1107:tasks.c       **** 
1108:tasks.c       **** #endif
1109:tasks.c       **** /*-----------------------------------------------------------*/
1110:tasks.c       **** 
1111:tasks.c       **** #if ( INCLUDE_vTaskSuspend == 1 )
1112:tasks.c       **** 
1113:tasks.c       **** 	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
1114:tasks.c       **** 	{
 968               	.LM82:
 969               	.LFBB5:
 970 03fe CF93      		push r28
 971 0400 DF93      		push r29
 972 0402 00D0      		rcall .
 973 0404 1F92      		push __zero_reg__
 974 0406 1F92      		push __zero_reg__
 975 0408 CDB7      		in r28,__SP_L__
 976 040a DEB7      		in r29,__SP_H__
 977               	/* prologue: function */
 978               	/* frame size = 5 */
 979               	/* stack size = 7 */
 980               	.L__stack_usage = 7
 981 040c 9D83      		std Y+5,r25
 982 040e 8C83      		std Y+4,r24
1115:tasks.c       **** 	portBASE_TYPE xReturn = pdFALSE;
 984               	.LM83:
 985 0410 1982      		std Y+1,__zero_reg__
1116:tasks.c       **** 	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
 987               	.LM84:
 988 0412 8C81      		ldd r24,Y+4
 989 0414 9D81      		ldd r25,Y+5
 990 0416 9B83      		std Y+3,r25
 991 0418 8A83      		std Y+2,r24
1117:tasks.c       **** 
1118:tasks.c       **** 		/* It does not make sense to check if the calling task is suspended. */
1119:tasks.c       **** 		configASSERT( xTask );
1120:tasks.c       **** 
1121:tasks.c       **** 		/* Is the task we are attempting to resume actually in the
1122:tasks.c       **** 		suspended list? */
1123:tasks.c       **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 993               	.LM85:
 994 041a 8A81      		ldd r24,Y+2
 995 041c 9B81      		ldd r25,Y+3
 996 041e FC01      		movw r30,r24
 997 0420 8285      		ldd r24,Z+10
 998 0422 9385      		ldd r25,Z+11
 999 0424 F0E0      		ldi r31,hi8(xSuspendedTaskList)
 1000 0426 8030      		cpi r24,lo8(xSuspendedTaskList)
 1001 0428 9F07      		cpc r25,r31
 1002 042a 01F4      		brne .L31
1124:tasks.c       **** 		{
1125:tasks.c       **** 			/* Has the task already been resumed from within an ISR? */
1126:tasks.c       **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
 1004               	.LM86:
 1005 042c 8A81      		ldd r24,Y+2
 1006 042e 9B81      		ldd r25,Y+3
 1007 0430 FC01      		movw r30,r24
 1008 0432 8489      		ldd r24,Z+20
 1009 0434 9589      		ldd r25,Z+21
 1010 0436 F0E0      		ldi r31,hi8(xPendingReadyList)
 1011 0438 8030      		cpi r24,lo8(xPendingReadyList)
 1012 043a 9F07      		cpc r25,r31
 1013 043c 01F0      		breq .L31
1127:tasks.c       **** 			{
1128:tasks.c       **** 				/* Is it in the suspended list because it is in the
1129:tasks.c       **** 				Suspended state?  It is possible to be in the suspended
1130:tasks.c       **** 				list because it is blocked on a task with no timeout
1131:tasks.c       **** 				specified. */
1132:tasks.c       **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
 1015               	.LM87:
 1016 043e 8A81      		ldd r24,Y+2
 1017 0440 9B81      		ldd r25,Y+3
 1018 0442 FC01      		movw r30,r24
 1019 0444 8489      		ldd r24,Z+20
 1020 0446 9589      		ldd r25,Z+21
 1021 0448 0097      		sbiw r24,0
 1022 044a 01F4      		brne .L31
1133:tasks.c       **** 				{
1134:tasks.c       **** 					xReturn = pdTRUE;
 1024               	.LM88:
 1025 044c 81E0      		ldi r24,lo8(1)
 1026 044e 8983      		std Y+1,r24
 1027               	.L31:
1135:tasks.c       **** 				}
1136:tasks.c       **** 			}
1137:tasks.c       **** 		}
1138:tasks.c       **** 
1139:tasks.c       **** 		return xReturn;
 1029               	.LM89:
 1030 0450 8981      		ldd r24,Y+1
 1031               	/* epilogue start */
1140:tasks.c       **** 	}
 1033               	.LM90:
 1034 0452 0F90      		pop __tmp_reg__
 1035 0454 0F90      		pop __tmp_reg__
 1036 0456 0F90      		pop __tmp_reg__
 1037 0458 0F90      		pop __tmp_reg__
 1038 045a 0F90      		pop __tmp_reg__
 1039 045c DF91      		pop r29
 1040 045e CF91      		pop r28
 1041 0460 0895      		ret
 1047               	.Lscope5:
 1049               		.stabd	78,0,0
 1052               	.global	vTaskResume
 1054               	vTaskResume:
 1055               		.stabd	46,0,0
1141:tasks.c       **** 
1142:tasks.c       **** #endif
1143:tasks.c       **** /*-----------------------------------------------------------*/
1144:tasks.c       **** 
1145:tasks.c       **** #if ( INCLUDE_vTaskSuspend == 1 )
1146:tasks.c       **** 
1147:tasks.c       **** 	void vTaskResume( xTaskHandle pxTaskToResume )
1148:tasks.c       **** 	{
 1057               	.LM91:
 1058               	.LFBB6:
 1059 0462 CF93      		push r28
 1060 0464 DF93      		push r29
 1061 0466 00D0      		rcall .
 1062 0468 1F92      		push __zero_reg__
 1063 046a CDB7      		in r28,__SP_L__
 1064 046c DEB7      		in r29,__SP_H__
 1065               	/* prologue: function */
 1066               	/* frame size = 4 */
 1067               	/* stack size = 6 */
 1068               	.L__stack_usage = 6
 1069 046e 9C83      		std Y+4,r25
 1070 0470 8B83      		std Y+3,r24
1149:tasks.c       **** 	tskTCB *pxTCB;
1150:tasks.c       **** 
1151:tasks.c       **** 		/* It does not make sense to resume the calling task. */
1152:tasks.c       **** 		configASSERT( pxTaskToResume );
1153:tasks.c       **** 
1154:tasks.c       **** 		/* Remove the task from whichever list it is currently in, and place
1155:tasks.c       **** 		it in the ready list. */
1156:tasks.c       **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 1072               	.LM92:
 1073 0472 8B81      		ldd r24,Y+3
 1074 0474 9C81      		ldd r25,Y+4
 1075 0476 9A83      		std Y+2,r25
 1076 0478 8983      		std Y+1,r24
1157:tasks.c       **** 
1158:tasks.c       **** 		/* The parameter cannot be NULL as it is impossible to resume the
1159:tasks.c       **** 		currently executing task. */
1160:tasks.c       **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 1078               	.LM93:
 1079 047a 8981      		ldd r24,Y+1
 1080 047c 9A81      		ldd r25,Y+2
 1081 047e 0097      		sbiw r24,0
 1082 0480 01F4      		brne .+2
 1083 0482 00C0      		rjmp .L33
 1085               	.LM94:
 1086 0484 8091 0000 		lds r24,pxCurrentTCB
 1087 0488 9091 0000 		lds r25,pxCurrentTCB+1
 1088 048c 2981      		ldd r18,Y+1
 1089 048e 3A81      		ldd r19,Y+2
 1090 0490 2817      		cp r18,r24
 1091 0492 3907      		cpc r19,r25
 1092 0494 01F4      		brne .+2
 1093 0496 00C0      		rjmp .L33
1161:tasks.c       **** 		{
1162:tasks.c       **** 			taskENTER_CRITICAL();
 1095               	.LM95:
 1096               	/* #APP */
 1097               	 ;  1162 "tasks.c" 1
 1098 0498 0FB6      		in		__tmp_reg__, __SREG__
 1099               	 ;  0 "" 2
 1100               	 ;  1162 "tasks.c" 1
 1101 049a F894      		cli
 1102               	 ;  0 "" 2
 1103               	 ;  1162 "tasks.c" 1
 1104 049c 0F92      		push	__tmp_reg__
 1105               	 ;  0 "" 2
1163:tasks.c       **** 			{
1164:tasks.c       **** 				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1107               	.LM96:
 1108               	/* #NOAPP */
 1109 049e 8981      		ldd r24,Y+1
 1110 04a0 9A81      		ldd r25,Y+2
 1111 04a2 0E94 0000 		call xTaskIsTaskSuspended
 1112 04a6 8130      		cpi r24,lo8(1)
 1113 04a8 01F4      		brne .L35
1165:tasks.c       **** 				{
1166:tasks.c       **** 					traceTASK_RESUME( pxTCB );
1167:tasks.c       **** 
1168:tasks.c       **** 					/* As we are in a critical section we can access the ready
1169:tasks.c       **** 					lists even if the scheduler is suspended. */
1170:tasks.c       **** 					uxListRemove(  &( pxTCB->xGenericListItem ) );
 1115               	.LM97:
 1116 04aa 8981      		ldd r24,Y+1
 1117 04ac 9A81      		ldd r25,Y+2
 1118 04ae 0296      		adiw r24,2
 1119 04b0 0E94 0000 		call uxListRemove
1171:tasks.c       **** 					prvAddTaskToReadyQueue( pxTCB );
 1121               	.LM98:
 1122 04b4 8981      		ldd r24,Y+1
 1123 04b6 9A81      		ldd r25,Y+2
 1124 04b8 FC01      		movw r30,r24
 1125 04ba 9689      		ldd r25,Z+22
 1126 04bc 8091 0000 		lds r24,uxTopReadyPriority
 1127 04c0 8917      		cp r24,r25
 1128 04c2 00F4      		brsh .L36
 1130               	.LM99:
 1131 04c4 8981      		ldd r24,Y+1
 1132 04c6 9A81      		ldd r25,Y+2
 1133 04c8 FC01      		movw r30,r24
 1134 04ca 8689      		ldd r24,Z+22
 1135 04cc 8093 0000 		sts uxTopReadyPriority,r24
 1136               	.L36:
 1138               	.LM100:
 1139 04d0 8981      		ldd r24,Y+1
 1140 04d2 9A81      		ldd r25,Y+2
 1141 04d4 AC01      		movw r20,r24
 1142 04d6 4E5F      		subi r20,-2
 1143 04d8 5F4F      		sbci r21,-1
 1144 04da 8981      		ldd r24,Y+1
 1145 04dc 9A81      		ldd r25,Y+2
 1146 04de FC01      		movw r30,r24
 1147 04e0 8689      		ldd r24,Z+22
 1148 04e2 282F      		mov r18,r24
 1149 04e4 30E0      		ldi r19,0
 1150 04e6 C901      		movw r24,r18
 1151 04e8 880F      		lsl r24
 1152 04ea 991F      		rol r25
 1153 04ec 880F      		lsl r24
 1154 04ee 991F      		rol r25
 1155 04f0 880F      		lsl r24
 1156 04f2 991F      		rol r25
 1157 04f4 820F      		add r24,r18
 1158 04f6 931F      		adc r25,r19
 1159 04f8 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1160 04fa 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1161 04fc BA01      		movw r22,r20
 1162 04fe 0E94 0000 		call vListInsertEnd
1172:tasks.c       **** 
1173:tasks.c       **** 					/* We may have just resumed a higher priority task. */
1174:tasks.c       **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1164               	.LM101:
 1165 0502 8981      		ldd r24,Y+1
 1166 0504 9A81      		ldd r25,Y+2
 1167 0506 FC01      		movw r30,r24
 1168 0508 2689      		ldd r18,Z+22
 1169 050a 8091 0000 		lds r24,pxCurrentTCB
 1170 050e 9091 0000 		lds r25,pxCurrentTCB+1
 1171 0512 FC01      		movw r30,r24
 1172 0514 8689      		ldd r24,Z+22
 1173 0516 2817      		cp r18,r24
 1174 0518 00F0      		brlo .L35
1175:tasks.c       **** 					{
1176:tasks.c       **** 						/* This yield may not cause the task just resumed to run, but
1177:tasks.c       **** 						will leave the lists in the correct state for the next yield. */
1178:tasks.c       **** 						portYIELD_WITHIN_API();
 1176               	.LM102:
 1177 051a 0E94 0000 		call vPortYield
 1178               	.L35:
1179:tasks.c       **** 					}
1180:tasks.c       **** 				}
1181:tasks.c       **** 			}
1182:tasks.c       **** 			taskEXIT_CRITICAL();
 1180               	.LM103:
 1181               	/* #APP */
 1182               	 ;  1182 "tasks.c" 1
 1183 051e 0F90      		pop		__tmp_reg__
 1184               	 ;  0 "" 2
 1185               	 ;  1182 "tasks.c" 1
 1186 0520 0FBE      		out		__SREG__, __tmp_reg__
 1187               	 ;  0 "" 2
 1188               	/* #NOAPP */
 1189               	.L33:
 1190               	/* epilogue start */
1183:tasks.c       **** 		}
1184:tasks.c       **** 	}
 1192               	.LM104:
 1193 0522 0F90      		pop __tmp_reg__
 1194 0524 0F90      		pop __tmp_reg__
 1195 0526 0F90      		pop __tmp_reg__
 1196 0528 0F90      		pop __tmp_reg__
 1197 052a DF91      		pop r29
 1198 052c CF91      		pop r28
 1199 052e 0895      		ret
 1204               	.Lscope6:
 1206               		.stabd	78,0,0
 1209               	.global	xTaskResumeFromISR
 1211               	xTaskResumeFromISR:
 1212               		.stabd	46,0,0
1185:tasks.c       **** 
1186:tasks.c       **** #endif
1187:tasks.c       **** 
1188:tasks.c       **** /*-----------------------------------------------------------*/
1189:tasks.c       **** 
1190:tasks.c       **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1191:tasks.c       **** 
1192:tasks.c       **** 	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
1193:tasks.c       **** 	{
 1214               	.LM105:
 1215               	.LFBB7:
 1216 0530 CF93      		push r28
 1217 0532 DF93      		push r29
 1218 0534 00D0      		rcall .
 1219 0536 00D0      		rcall .
 1220 0538 CDB7      		in r28,__SP_L__
 1221 053a DEB7      		in r29,__SP_H__
 1222               	/* prologue: function */
 1223               	/* frame size = 6 */
 1224               	/* stack size = 8 */
 1225               	.L__stack_usage = 8
 1226 053c 9E83      		std Y+6,r25
 1227 053e 8D83      		std Y+5,r24
1194:tasks.c       **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 1229               	.LM106:
 1230 0540 1982      		std Y+1,__zero_reg__
1195:tasks.c       **** 	tskTCB *pxTCB;
1196:tasks.c       **** 	unsigned portBASE_TYPE uxSavedInterruptStatus;
1197:tasks.c       **** 
1198:tasks.c       **** 		configASSERT( pxTaskToResume );
1199:tasks.c       **** 
1200:tasks.c       **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 1232               	.LM107:
 1233 0542 8D81      		ldd r24,Y+5
 1234 0544 9E81      		ldd r25,Y+6
 1235 0546 9B83      		std Y+3,r25
 1236 0548 8A83      		std Y+2,r24
1201:tasks.c       **** 
1202:tasks.c       **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1238               	.LM108:
 1239 054a 1C82      		std Y+4,__zero_reg__
1203:tasks.c       **** 		{
1204:tasks.c       **** 			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1241               	.LM109:
 1242 054c 8A81      		ldd r24,Y+2
 1243 054e 9B81      		ldd r25,Y+3
 1244 0550 0E94 0000 		call xTaskIsTaskSuspended
 1245 0554 8130      		cpi r24,lo8(1)
 1246 0556 01F0      		breq .+2
 1247 0558 00C0      		rjmp .L38
1205:tasks.c       **** 			{
1206:tasks.c       **** 				traceTASK_RESUME_FROM_ISR( pxTCB );
1207:tasks.c       **** 
1208:tasks.c       **** 				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1249               	.LM110:
 1250 055a 8091 0000 		lds r24,uxSchedulerSuspended
 1251 055e 8823      		tst r24
 1252 0560 01F4      		brne .L39
1209:tasks.c       **** 				{
1210:tasks.c       **** 					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
 1254               	.LM111:
 1255 0562 8A81      		ldd r24,Y+2
 1256 0564 9B81      		ldd r25,Y+3
 1257 0566 FC01      		movw r30,r24
 1258 0568 2689      		ldd r18,Z+22
 1259 056a 8091 0000 		lds r24,pxCurrentTCB
 1260 056e 9091 0000 		lds r25,pxCurrentTCB+1
 1261 0572 FC01      		movw r30,r24
 1262 0574 9689      		ldd r25,Z+22
 1263 0576 81E0      		ldi r24,lo8(1)
 1264 0578 2917      		cp r18,r25
 1265 057a 00F4      		brsh .L40
 1266 057c 80E0      		ldi r24,0
 1267               	.L40:
 1268 057e 8983      		std Y+1,r24
1211:tasks.c       **** 					uxListRemove(  &( pxTCB->xGenericListItem ) );
 1270               	.LM112:
 1271 0580 8A81      		ldd r24,Y+2
 1272 0582 9B81      		ldd r25,Y+3
 1273 0584 0296      		adiw r24,2
 1274 0586 0E94 0000 		call uxListRemove
1212:tasks.c       **** 					prvAddTaskToReadyQueue( pxTCB );
 1276               	.LM113:
 1277 058a 8A81      		ldd r24,Y+2
 1278 058c 9B81      		ldd r25,Y+3
 1279 058e FC01      		movw r30,r24
 1280 0590 9689      		ldd r25,Z+22
 1281 0592 8091 0000 		lds r24,uxTopReadyPriority
 1282 0596 8917      		cp r24,r25
 1283 0598 00F4      		brsh .L41
 1285               	.LM114:
 1286 059a 8A81      		ldd r24,Y+2
 1287 059c 9B81      		ldd r25,Y+3
 1288 059e FC01      		movw r30,r24
 1289 05a0 8689      		ldd r24,Z+22
 1290 05a2 8093 0000 		sts uxTopReadyPriority,r24
 1291               	.L41:
 1293               	.LM115:
 1294 05a6 8A81      		ldd r24,Y+2
 1295 05a8 9B81      		ldd r25,Y+3
 1296 05aa AC01      		movw r20,r24
 1297 05ac 4E5F      		subi r20,-2
 1298 05ae 5F4F      		sbci r21,-1
 1299 05b0 8A81      		ldd r24,Y+2
 1300 05b2 9B81      		ldd r25,Y+3
 1301 05b4 FC01      		movw r30,r24
 1302 05b6 8689      		ldd r24,Z+22
 1303 05b8 282F      		mov r18,r24
 1304 05ba 30E0      		ldi r19,0
 1305 05bc C901      		movw r24,r18
 1306 05be 880F      		lsl r24
 1307 05c0 991F      		rol r25
 1308 05c2 880F      		lsl r24
 1309 05c4 991F      		rol r25
 1310 05c6 880F      		lsl r24
 1311 05c8 991F      		rol r25
 1312 05ca 820F      		add r24,r18
 1313 05cc 931F      		adc r25,r19
 1314 05ce 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1315 05d0 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1316 05d2 BA01      		movw r22,r20
 1317 05d4 0E94 0000 		call vListInsertEnd
 1318 05d8 00C0      		rjmp .L38
 1319               	.L39:
1213:tasks.c       **** 				}
1214:tasks.c       **** 				else
1215:tasks.c       **** 				{
1216:tasks.c       **** 					/* We cannot access the delayed or ready lists, so will hold this
1217:tasks.c       **** 					task pending until the scheduler is resumed, at which point a
1218:tasks.c       **** 					yield will be performed if necessary. */
1219:tasks.c       **** 					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 1321               	.LM116:
 1322 05da 8A81      		ldd r24,Y+2
 1323 05dc 9B81      		ldd r25,Y+3
 1324 05de 0C96      		adiw r24,12
 1325 05e0 BC01      		movw r22,r24
 1326 05e2 80E0      		ldi r24,lo8(xPendingReadyList)
 1327 05e4 90E0      		ldi r25,hi8(xPendingReadyList)
 1328 05e6 0E94 0000 		call vListInsertEnd
 1329               	.L38:
1220:tasks.c       **** 				}
1221:tasks.c       **** 			}
1222:tasks.c       **** 		}
1223:tasks.c       **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1224:tasks.c       **** 
1225:tasks.c       **** 		return xYieldRequired;
 1331               	.LM117:
 1332 05ea 8981      		ldd r24,Y+1
 1333               	/* epilogue start */
1226:tasks.c       **** 	}
 1335               	.LM118:
 1336 05ec 2696      		adiw r28,6
 1337 05ee 0FB6      		in __tmp_reg__,__SREG__
 1338 05f0 F894      		cli
 1339 05f2 DEBF      		out __SP_H__,r29
 1340 05f4 0FBE      		out __SREG__,__tmp_reg__
 1341 05f6 CDBF      		out __SP_L__,r28
 1342 05f8 DF91      		pop r29
 1343 05fa CF91      		pop r28
 1344 05fc 0895      		ret
 1351               	.Lscope7:
 1353               		.stabd	78,0,0
 1354               		.section	.rodata
 1355               	.LC0:
 1356 0000 4944 4C45 		.string	"IDLE"
 1356      00
 1357               		.text
 1359               	.global	vTaskStartScheduler
 1361               	vTaskStartScheduler:
 1362               		.stabd	46,0,0
1227:tasks.c       **** 
1228:tasks.c       **** #endif
1229:tasks.c       **** 
1230:tasks.c       **** 
1231:tasks.c       **** 
1232:tasks.c       **** 
1233:tasks.c       **** /*-----------------------------------------------------------
1234:tasks.c       ****  * PUBLIC SCHEDULER CONTROL documented in task.h
1235:tasks.c       ****  *----------------------------------------------------------*/
1236:tasks.c       **** 
1237:tasks.c       **** 
1238:tasks.c       **** void vTaskStartScheduler( void )
1239:tasks.c       **** {
 1364               	.LM119:
 1365               	.LFBB8:
 1366 05fe AF92      		push r10
 1367 0600 BF92      		push r11
 1368 0602 CF92      		push r12
 1369 0604 DF92      		push r13
 1370 0606 EF92      		push r14
 1371 0608 FF92      		push r15
 1372 060a 0F93      		push r16
 1373 060c CF93      		push r28
 1374 060e DF93      		push r29
 1375 0610 1F92      		push __zero_reg__
 1376 0612 CDB7      		in r28,__SP_L__
 1377 0614 DEB7      		in r29,__SP_H__
 1378               	/* prologue: function */
 1379               	/* frame size = 1 */
 1380               	/* stack size = 10 */
 1381               	.L__stack_usage = 10
1240:tasks.c       **** portBASE_TYPE xReturn;
1241:tasks.c       **** 
1242:tasks.c       **** 	/* Add the idle task at the lowest priority. */
1243:tasks.c       **** 	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1244:tasks.c       **** 	{
1245:tasks.c       **** 		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
1246:tasks.c       **** 		be returned by the xTaskGetIdleTaskHandle() function. */
1247:tasks.c       **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
1248:tasks.c       **** 	}
1249:tasks.c       **** 	#else
1250:tasks.c       **** 	{
1251:tasks.c       **** 		/* Create the idle task without storing its handle. */
1252:tasks.c       **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
 1383               	.LM120:
 1384 0616 A12C      		mov r10,__zero_reg__
 1385 0618 B12C      		mov r11,__zero_reg__
 1386 061a C12C      		mov r12,__zero_reg__
 1387 061c D12C      		mov r13,__zero_reg__
 1388 061e E12C      		mov r14,__zero_reg__
 1389 0620 F12C      		mov r15,__zero_reg__
 1390 0622 00E0      		ldi r16,0
 1391 0624 20E0      		ldi r18,0
 1392 0626 30E0      		ldi r19,0
 1393 0628 45E5      		ldi r20,lo8(85)
 1394 062a 50E0      		ldi r21,0
 1395 062c 60E0      		ldi r22,lo8(.LC0)
 1396 062e 70E0      		ldi r23,hi8(.LC0)
 1397 0630 80E0      		ldi r24,lo8(gs(prvIdleTask))
 1398 0632 90E0      		ldi r25,hi8(gs(prvIdleTask))
 1399 0634 0E94 0000 		call xTaskGenericCreate
 1400 0638 8983      		std Y+1,r24
1253:tasks.c       **** 	}
1254:tasks.c       **** 	#endif
1255:tasks.c       **** 
1256:tasks.c       **** 	#if ( configUSE_TIMERS == 1 )
1257:tasks.c       **** 	{
1258:tasks.c       **** 		if( xReturn == pdPASS )
1259:tasks.c       **** 		{
1260:tasks.c       **** 			xReturn = xTimerCreateTimerTask();
1261:tasks.c       **** 		}
1262:tasks.c       **** 	}
1263:tasks.c       **** 	#endif
1264:tasks.c       **** 
1265:tasks.c       **** 	if( xReturn == pdPASS )
 1402               	.LM121:
 1403 063a 8981      		ldd r24,Y+1
 1404 063c 8130      		cpi r24,lo8(1)
 1405 063e 01F4      		brne .L43
1266:tasks.c       **** 	{
1267:tasks.c       **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1268:tasks.c       **** 		before or during the call to xPortStartScheduler().  The stacks of
1269:tasks.c       **** 		the created tasks contain a status word with interrupts switched on
1270:tasks.c       **** 		so interrupts will automatically get re-enabled when the first task
1271:tasks.c       **** 		starts to run.
1272:tasks.c       **** 
1273:tasks.c       **** 		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
1274:tasks.c       **** 		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
1275:tasks.c       **** 		portDISABLE_INTERRUPTS();
 1407               	.LM122:
 1408               	/* #APP */
 1409               	 ;  1275 "tasks.c" 1
 1410 0640 F894      		cli
 1411               	 ;  0 "" 2
1276:tasks.c       **** 
1277:tasks.c       **** 		xSchedulerRunning = pdTRUE;
 1413               	.LM123:
 1414               	/* #NOAPP */
 1415 0642 81E0      		ldi r24,lo8(1)
 1416 0644 8093 0000 		sts xSchedulerRunning,r24
1278:tasks.c       **** 		xTickCount = ( portTickType ) 0U;
 1418               	.LM124:
 1419 0648 1092 0000 		sts xTickCount+1,__zero_reg__
 1420 064c 1092 0000 		sts xTickCount,__zero_reg__
1279:tasks.c       **** 
1280:tasks.c       **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1281:tasks.c       **** 		macro must be defined to configure the timer/counter used to generate
1282:tasks.c       **** 		the run time counter time base. */
1283:tasks.c       **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1284:tasks.c       **** 
1285:tasks.c       **** 		/* Setting up the timer tick is hardware specific and thus in the
1286:tasks.c       **** 		portable interface. */
1287:tasks.c       **** 		if( xPortStartScheduler() != pdFALSE )
 1422               	.LM125:
 1423 0650 0E94 0000 		call xPortStartScheduler
 1424               	.L43:
 1425               	/* epilogue start */
1288:tasks.c       **** 		{
1289:tasks.c       **** 			/* Should not reach here as if the scheduler is running the
1290:tasks.c       **** 			function will not return. */
1291:tasks.c       **** 		}
1292:tasks.c       **** 		else
1293:tasks.c       **** 		{
1294:tasks.c       **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1295:tasks.c       **** 		}
1296:tasks.c       **** 	}
1297:tasks.c       **** 
1298:tasks.c       **** 	/* This line will only be reached if the kernel could not be started. */
1299:tasks.c       **** 	configASSERT( xReturn );
1300:tasks.c       **** }
 1427               	.LM126:
 1428 0654 0F90      		pop __tmp_reg__
 1429 0656 DF91      		pop r29
 1430 0658 CF91      		pop r28
 1431 065a 0F91      		pop r16
 1432 065c FF90      		pop r15
 1433 065e EF90      		pop r14
 1434 0660 DF90      		pop r13
 1435 0662 CF90      		pop r12
 1436 0664 BF90      		pop r11
 1437 0666 AF90      		pop r10
 1438 0668 0895      		ret
 1443               	.Lscope8:
 1445               		.stabd	78,0,0
 1447               	.global	vTaskEndScheduler
 1449               	vTaskEndScheduler:
 1450               		.stabd	46,0,0
1301:tasks.c       **** /*-----------------------------------------------------------*/
1302:tasks.c       **** 
1303:tasks.c       **** void vTaskEndScheduler( void )
1304:tasks.c       **** {
 1452               	.LM127:
 1453               	.LFBB9:
 1454 066a CF93      		push r28
 1455 066c DF93      		push r29
 1456 066e CDB7      		in r28,__SP_L__
 1457 0670 DEB7      		in r29,__SP_H__
 1458               	/* prologue: function */
 1459               	/* frame size = 0 */
 1460               	/* stack size = 2 */
 1461               	.L__stack_usage = 2
1305:tasks.c       **** 	/* Stop the scheduler interrupts and call the portable scheduler end
1306:tasks.c       **** 	routine so the original ISRs can be restored if necessary.  The port
1307:tasks.c       **** 	layer must ensure interrupts enable	bit is left in the correct state. */
1308:tasks.c       **** 	portDISABLE_INTERRUPTS();
 1463               	.LM128:
 1464               	/* #APP */
 1465               	 ;  1308 "tasks.c" 1
 1466 0672 F894      		cli
 1467               	 ;  0 "" 2
1309:tasks.c       **** 	xSchedulerRunning = pdFALSE;
 1469               	.LM129:
 1470               	/* #NOAPP */
 1471 0674 1092 0000 		sts xSchedulerRunning,__zero_reg__
1310:tasks.c       **** 	vPortEndScheduler();
 1473               	.LM130:
 1474 0678 0E94 0000 		call vPortEndScheduler
 1475               	/* epilogue start */
1311:tasks.c       **** }
 1477               	.LM131:
 1478 067c DF91      		pop r29
 1479 067e CF91      		pop r28
 1480 0680 0895      		ret
 1482               	.Lscope9:
 1484               		.stabd	78,0,0
 1486               	.global	vTaskSuspendAll
 1488               	vTaskSuspendAll:
 1489               		.stabd	46,0,0
1312:tasks.c       **** /*----------------------------------------------------------*/
1313:tasks.c       **** 
1314:tasks.c       **** void vTaskSuspendAll( void )
1315:tasks.c       **** {
 1491               	.LM132:
 1492               	.LFBB10:
 1493 0682 CF93      		push r28
 1494 0684 DF93      		push r29
 1495 0686 CDB7      		in r28,__SP_L__
 1496 0688 DEB7      		in r29,__SP_H__
 1497               	/* prologue: function */
 1498               	/* frame size = 0 */
 1499               	/* stack size = 2 */
 1500               	.L__stack_usage = 2
1316:tasks.c       **** 	/* A critical section is not required as the variable is of type
1317:tasks.c       **** 	portBASE_TYPE. */
1318:tasks.c       **** 	++uxSchedulerSuspended;
 1502               	.LM133:
 1503 068a 8091 0000 		lds r24,uxSchedulerSuspended
 1504 068e 8F5F      		subi r24,lo8(-(1))
 1505 0690 8093 0000 		sts uxSchedulerSuspended,r24
 1506               	/* epilogue start */
1319:tasks.c       **** }
 1508               	.LM134:
 1509 0694 DF91      		pop r29
 1510 0696 CF91      		pop r28
 1511 0698 0895      		ret
 1513               	.Lscope10:
 1515               		.stabd	78,0,0
 1517               	.global	xTaskResumeAll
 1519               	xTaskResumeAll:
 1520               		.stabd	46,0,0
1320:tasks.c       **** /*----------------------------------------------------------*/
1321:tasks.c       **** 
1322:tasks.c       **** #if ( configUSE_TICKLESS_IDLE != 0 )
1323:tasks.c       **** 
1324:tasks.c       **** 	portTickType prvGetExpectedIdleTime( void )
1325:tasks.c       **** 	{
1326:tasks.c       **** 	portTickType xReturn;
1327:tasks.c       **** 
1328:tasks.c       **** 		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
1329:tasks.c       **** 		{
1330:tasks.c       **** 			xReturn = 0;
1331:tasks.c       **** 		}
1332:tasks.c       **** 		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
1333:tasks.c       **** 		{
1334:tasks.c       **** 			/* There are other idle priority tasks in the ready state.  If
1335:tasks.c       **** 			time slicing is used then the very next tick interrupt must be
1336:tasks.c       **** 			processed. */
1337:tasks.c       **** 			xReturn = 0;
1338:tasks.c       **** 		}
1339:tasks.c       **** 		else
1340:tasks.c       **** 		{
1341:tasks.c       **** 			xReturn = xNextTaskUnblockTime - xTickCount;
1342:tasks.c       **** 		}
1343:tasks.c       **** 
1344:tasks.c       **** 		return xReturn;
1345:tasks.c       **** 	}
1346:tasks.c       **** 
1347:tasks.c       **** #endif /* configUSE_TICKLESS_IDLE != 0  */
1348:tasks.c       **** /*----------------------------------------------------------*/
1349:tasks.c       **** 
1350:tasks.c       **** signed portBASE_TYPE xTaskResumeAll( void )
1351:tasks.c       **** {
 1522               	.LM135:
 1523               	.LFBB11:
 1524 069a 0F93      		push r16
 1525 069c 1F93      		push r17
 1526 069e CF93      		push r28
 1527 06a0 DF93      		push r29
 1528 06a2 1F92      		push __zero_reg__
 1529 06a4 1F92      		push __zero_reg__
 1530 06a6 CDB7      		in r28,__SP_L__
 1531 06a8 DEB7      		in r29,__SP_H__
 1532               	/* prologue: function */
 1533               	/* frame size = 2 */
 1534               	/* stack size = 6 */
 1535               	.L__stack_usage = 6
1352:tasks.c       **** register tskTCB *pxTCB;
1353:tasks.c       **** signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 1537               	.LM136:
 1538 06aa 1982      		std Y+1,__zero_reg__
1354:tasks.c       **** 
1355:tasks.c       **** 	/* If uxSchedulerSuspended is zero then this function does not match a
1356:tasks.c       **** 	previous call to vTaskSuspendAll(). */
1357:tasks.c       **** 	configASSERT( uxSchedulerSuspended );
1358:tasks.c       **** 
1359:tasks.c       **** 	/* It is possible that an ISR caused a task to be removed from an event
1360:tasks.c       **** 	list while the scheduler was suspended.  If this was the case then the
1361:tasks.c       **** 	removed task will have been added to the xPendingReadyList.  Once the
1362:tasks.c       **** 	scheduler has been resumed it is safe to move all the pending ready
1363:tasks.c       **** 	tasks from this list into their appropriate ready list. */
1364:tasks.c       **** 	taskENTER_CRITICAL();
 1540               	.LM137:
 1541               	/* #APP */
 1542               	 ;  1364 "tasks.c" 1
 1543 06ac 0FB6      		in		__tmp_reg__, __SREG__
 1544               	 ;  0 "" 2
 1545               	 ;  1364 "tasks.c" 1
 1546 06ae F894      		cli
 1547               	 ;  0 "" 2
 1548               	 ;  1364 "tasks.c" 1
 1549 06b0 0F92      		push	__tmp_reg__
 1550               	 ;  0 "" 2
1365:tasks.c       **** 	{
1366:tasks.c       **** 		--uxSchedulerSuspended;
 1552               	.LM138:
 1553               	/* #NOAPP */
 1554 06b2 8091 0000 		lds r24,uxSchedulerSuspended
 1555 06b6 8150      		subi r24,lo8(-(-1))
 1556 06b8 8093 0000 		sts uxSchedulerSuspended,r24
1367:tasks.c       **** 
1368:tasks.c       **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1558               	.LM139:
 1559 06bc 8091 0000 		lds r24,uxSchedulerSuspended
 1560 06c0 8823      		tst r24
 1561 06c2 01F0      		breq .+2
 1562 06c4 00C0      		rjmp .L48
1369:tasks.c       **** 		{
1370:tasks.c       **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
 1564               	.LM140:
 1565 06c6 8091 0000 		lds r24,uxCurrentNumberOfTasks
 1566 06ca 8823      		tst r24
 1567 06cc 01F4      		brne .+2
 1568 06ce 00C0      		rjmp .L48
 1569               	.LBB3:
1371:tasks.c       **** 			{
1372:tasks.c       **** 				portBASE_TYPE xYieldRequired = pdFALSE;
 1571               	.LM141:
 1572 06d0 1A82      		std Y+2,__zero_reg__
1373:tasks.c       **** 
1374:tasks.c       **** 				/* Move any readied tasks from the pending list into the
1375:tasks.c       **** 				appropriate ready list. */
1376:tasks.c       **** 				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 1574               	.LM142:
 1575 06d2 00C0      		rjmp .L49
 1576               	.L51:
1377:tasks.c       **** 				{
1378:tasks.c       **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
 1578               	.LM143:
 1579 06d4 8091 0000 		lds r24,xPendingReadyList+5
 1580 06d8 9091 0000 		lds r25,xPendingReadyList+5+1
 1581 06dc FC01      		movw r30,r24
 1582 06de 0681      		ldd r16,Z+6
 1583 06e0 1781      		ldd r17,Z+7
1379:tasks.c       **** 					uxListRemove( &( pxTCB->xEventListItem ) );
 1585               	.LM144:
 1586 06e2 C801      		movw r24,r16
 1587 06e4 0C96      		adiw r24,12
 1588 06e6 0E94 0000 		call uxListRemove
1380:tasks.c       **** 					uxListRemove( &( pxTCB->xGenericListItem ) );
 1590               	.LM145:
 1591 06ea C801      		movw r24,r16
 1592 06ec 0296      		adiw r24,2
 1593 06ee 0E94 0000 		call uxListRemove
1381:tasks.c       **** 					prvAddTaskToReadyQueue( pxTCB );
 1595               	.LM146:
 1596 06f2 F801      		movw r30,r16
 1597 06f4 9689      		ldd r25,Z+22
 1598 06f6 8091 0000 		lds r24,uxTopReadyPriority
 1599 06fa 8917      		cp r24,r25
 1600 06fc 00F4      		brsh .L50
 1602               	.LM147:
 1603 06fe F801      		movw r30,r16
 1604 0700 8689      		ldd r24,Z+22
 1605 0702 8093 0000 		sts uxTopReadyPriority,r24
 1606               	.L50:
 1608               	.LM148:
 1609 0706 A801      		movw r20,r16
 1610 0708 4E5F      		subi r20,-2
 1611 070a 5F4F      		sbci r21,-1
 1612 070c F801      		movw r30,r16
 1613 070e 8689      		ldd r24,Z+22
 1614 0710 282F      		mov r18,r24
 1615 0712 30E0      		ldi r19,0
 1616 0714 C901      		movw r24,r18
 1617 0716 880F      		lsl r24
 1618 0718 991F      		rol r25
 1619 071a 880F      		lsl r24
 1620 071c 991F      		rol r25
 1621 071e 880F      		lsl r24
 1622 0720 991F      		rol r25
 1623 0722 820F      		add r24,r18
 1624 0724 931F      		adc r25,r19
 1625 0726 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1626 0728 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1627 072a BA01      		movw r22,r20
 1628 072c 0E94 0000 		call vListInsertEnd
1382:tasks.c       **** 
1383:tasks.c       **** 					/* If we have moved a task that has a priority higher than
1384:tasks.c       **** 					the current task then we should yield. */
1385:tasks.c       **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1630               	.LM149:
 1631 0730 F801      		movw r30,r16
 1632 0732 2689      		ldd r18,Z+22
 1633 0734 8091 0000 		lds r24,pxCurrentTCB
 1634 0738 9091 0000 		lds r25,pxCurrentTCB+1
 1635 073c FC01      		movw r30,r24
 1636 073e 8689      		ldd r24,Z+22
 1637 0740 2817      		cp r18,r24
 1638 0742 00F0      		brlo .L49
1386:tasks.c       **** 					{
1387:tasks.c       **** 						xYieldRequired = pdTRUE;
 1640               	.LM150:
 1641 0744 81E0      		ldi r24,lo8(1)
 1642 0746 8A83      		std Y+2,r24
 1643               	.L49:
1376:tasks.c       **** 				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 1645               	.LM151:
 1646 0748 8091 0000 		lds r24,xPendingReadyList
 1647 074c 8823      		tst r24
 1648 074e 01F4      		brne .L51
1388:tasks.c       **** 					}
1389:tasks.c       **** 				}
1390:tasks.c       **** 
1391:tasks.c       **** 				/* If any ticks occurred while the scheduler was suspended then
1392:tasks.c       **** 				they should be processed now.  This ensures the tick count does not
1393:tasks.c       **** 				slip, and that any delayed tasks are resumed at the correct time. */
1394:tasks.c       **** 				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 1650               	.LM152:
 1651 0750 8091 0000 		lds r24,uxMissedTicks
 1652 0754 8823      		tst r24
 1653 0756 01F0      		breq .L52
1395:tasks.c       **** 				{
1396:tasks.c       **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 1655               	.LM153:
 1656 0758 00C0      		rjmp .L53
 1657               	.L54:
1397:tasks.c       **** 					{
1398:tasks.c       **** 						vTaskIncrementTick();
 1659               	.LM154:
 1660 075a 0E94 0000 		call vTaskIncrementTick
1399:tasks.c       **** 						--uxMissedTicks;
 1662               	.LM155:
 1663 075e 8091 0000 		lds r24,uxMissedTicks
 1664 0762 8150      		subi r24,lo8(-(-1))
 1665 0764 8093 0000 		sts uxMissedTicks,r24
 1666               	.L53:
1396:tasks.c       **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 1668               	.LM156:
 1669 0768 8091 0000 		lds r24,uxMissedTicks
 1670 076c 8823      		tst r24
 1671 076e 01F4      		brne .L54
1400:tasks.c       **** 					}
1401:tasks.c       **** 
1402:tasks.c       **** 					/* As we have processed some ticks it is appropriate to yield
1403:tasks.c       **** 					to ensure the highest priority task that is ready to run is
1404:tasks.c       **** 					the task actually running. */
1405:tasks.c       **** 					#if configUSE_PREEMPTION == 1
1406:tasks.c       **** 					{
1407:tasks.c       **** 						xYieldRequired = pdTRUE;
 1673               	.LM157:
 1674 0770 81E0      		ldi r24,lo8(1)
 1675 0772 8A83      		std Y+2,r24
 1676               	.L52:
1408:tasks.c       **** 					}
1409:tasks.c       **** 					#endif
1410:tasks.c       **** 				}
1411:tasks.c       **** 
1412:tasks.c       **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 1678               	.LM158:
 1679 0774 8A81      		ldd r24,Y+2
 1680 0776 8130      		cpi r24,lo8(1)
 1681 0778 01F0      		breq .L55
 1683               	.LM159:
 1684 077a 8091 0000 		lds r24,xMissedYield
 1685 077e 8130      		cpi r24,lo8(1)
 1686 0780 01F4      		brne .L48
 1687               	.L55:
1413:tasks.c       **** 				{
1414:tasks.c       **** 					xAlreadyYielded = pdTRUE;
 1689               	.LM160:
 1690 0782 81E0      		ldi r24,lo8(1)
 1691 0784 8983      		std Y+1,r24
1415:tasks.c       **** 					xMissedYield = pdFALSE;
 1693               	.LM161:
 1694 0786 1092 0000 		sts xMissedYield,__zero_reg__
1416:tasks.c       **** 					portYIELD_WITHIN_API();
 1696               	.LM162:
 1697 078a 0E94 0000 		call vPortYield
 1698               	.L48:
 1699               	.LBE3:
1417:tasks.c       **** 				}
1418:tasks.c       **** 			}
1419:tasks.c       **** 		}
1420:tasks.c       **** 	}
1421:tasks.c       **** 	taskEXIT_CRITICAL();
 1701               	.LM163:
 1702               	/* #APP */
 1703               	 ;  1421 "tasks.c" 1
 1704 078e 0F90      		pop		__tmp_reg__
 1705               	 ;  0 "" 2
 1706               	 ;  1421 "tasks.c" 1
 1707 0790 0FBE      		out		__SREG__, __tmp_reg__
 1708               	 ;  0 "" 2
1422:tasks.c       **** 
1423:tasks.c       **** 	return xAlreadyYielded;
 1710               	.LM164:
 1711               	/* #NOAPP */
 1712 0792 8981      		ldd r24,Y+1
 1713               	/* epilogue start */
1424:tasks.c       **** }
 1715               	.LM165:
 1716 0794 0F90      		pop __tmp_reg__
 1717 0796 0F90      		pop __tmp_reg__
 1718 0798 DF91      		pop r29
 1719 079a CF91      		pop r28
 1720 079c 1F91      		pop r17
 1721 079e 0F91      		pop r16
 1722 07a0 0895      		ret
 1731               	.Lscope11:
 1733               		.stabd	78,0,0
 1735               	.global	xTaskGetTickCount
 1737               	xTaskGetTickCount:
 1738               		.stabd	46,0,0
1425:tasks.c       **** 
1426:tasks.c       **** 
1427:tasks.c       **** 
1428:tasks.c       **** 
1429:tasks.c       **** 
1430:tasks.c       **** 
1431:tasks.c       **** /*-----------------------------------------------------------
1432:tasks.c       ****  * PUBLIC TASK UTILITIES documented in task.h
1433:tasks.c       ****  *----------------------------------------------------------*/
1434:tasks.c       **** 
1435:tasks.c       **** 
1436:tasks.c       **** 
1437:tasks.c       **** portTickType xTaskGetTickCount( void )
1438:tasks.c       **** {
 1740               	.LM166:
 1741               	.LFBB12:
 1742 07a2 CF93      		push r28
 1743 07a4 DF93      		push r29
 1744 07a6 1F92      		push __zero_reg__
 1745 07a8 1F92      		push __zero_reg__
 1746 07aa CDB7      		in r28,__SP_L__
 1747 07ac DEB7      		in r29,__SP_H__
 1748               	/* prologue: function */
 1749               	/* frame size = 2 */
 1750               	/* stack size = 4 */
 1751               	.L__stack_usage = 4
1439:tasks.c       **** portTickType xTicks;
1440:tasks.c       **** 
1441:tasks.c       **** 	/* Critical section required if running on a 16 bit processor. */
1442:tasks.c       **** 	taskENTER_CRITICAL();
 1753               	.LM167:
 1754               	/* #APP */
 1755               	 ;  1442 "tasks.c" 1
 1756 07ae 0FB6      		in		__tmp_reg__, __SREG__
 1757               	 ;  0 "" 2
 1758               	 ;  1442 "tasks.c" 1
 1759 07b0 F894      		cli
 1760               	 ;  0 "" 2
 1761               	 ;  1442 "tasks.c" 1
 1762 07b2 0F92      		push	__tmp_reg__
 1763               	 ;  0 "" 2
1443:tasks.c       **** 	{
1444:tasks.c       **** 		xTicks = xTickCount;
 1765               	.LM168:
 1766               	/* #NOAPP */
 1767 07b4 8091 0000 		lds r24,xTickCount
 1768 07b8 9091 0000 		lds r25,xTickCount+1
 1769 07bc 9A83      		std Y+2,r25
 1770 07be 8983      		std Y+1,r24
1445:tasks.c       **** 	}
1446:tasks.c       **** 	taskEXIT_CRITICAL();
 1772               	.LM169:
 1773               	/* #APP */
 1774               	 ;  1446 "tasks.c" 1
 1775 07c0 0F90      		pop		__tmp_reg__
 1776               	 ;  0 "" 2
 1777               	 ;  1446 "tasks.c" 1
 1778 07c2 0FBE      		out		__SREG__, __tmp_reg__
 1779               	 ;  0 "" 2
1447:tasks.c       **** 
1448:tasks.c       **** 	return xTicks;
 1781               	.LM170:
 1782               	/* #NOAPP */
 1783 07c4 8981      		ldd r24,Y+1
 1784 07c6 9A81      		ldd r25,Y+2
 1785               	/* epilogue start */
1449:tasks.c       **** }
 1787               	.LM171:
 1788 07c8 0F90      		pop __tmp_reg__
 1789 07ca 0F90      		pop __tmp_reg__
 1790 07cc DF91      		pop r29
 1791 07ce CF91      		pop r28
 1792 07d0 0895      		ret
 1797               	.Lscope12:
 1799               		.stabd	78,0,0
 1801               	.global	xTaskGetTickCountFromISR
 1803               	xTaskGetTickCountFromISR:
 1804               		.stabd	46,0,0
1450:tasks.c       **** /*-----------------------------------------------------------*/
1451:tasks.c       **** 
1452:tasks.c       **** portTickType xTaskGetTickCountFromISR( void )
1453:tasks.c       **** {
 1806               	.LM172:
 1807               	.LFBB13:
 1808 07d2 CF93      		push r28
 1809 07d4 DF93      		push r29
 1810 07d6 00D0      		rcall .
 1811 07d8 CDB7      		in r28,__SP_L__
 1812 07da DEB7      		in r29,__SP_H__
 1813               	/* prologue: function */
 1814               	/* frame size = 3 */
 1815               	/* stack size = 5 */
 1816               	.L__stack_usage = 5
1454:tasks.c       **** portTickType xReturn;
1455:tasks.c       **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1456:tasks.c       **** 
1457:tasks.c       **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1818               	.LM173:
 1819 07dc 1982      		std Y+1,__zero_reg__
1458:tasks.c       **** 	xReturn = xTickCount;
 1821               	.LM174:
 1822 07de 8091 0000 		lds r24,xTickCount
 1823 07e2 9091 0000 		lds r25,xTickCount+1
 1824 07e6 9B83      		std Y+3,r25
 1825 07e8 8A83      		std Y+2,r24
1459:tasks.c       **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1460:tasks.c       **** 
1461:tasks.c       **** 	return xReturn;
 1827               	.LM175:
 1828 07ea 8A81      		ldd r24,Y+2
 1829 07ec 9B81      		ldd r25,Y+3
 1830               	/* epilogue start */
1462:tasks.c       **** }
 1832               	.LM176:
 1833 07ee 0F90      		pop __tmp_reg__
 1834 07f0 0F90      		pop __tmp_reg__
 1835 07f2 0F90      		pop __tmp_reg__
 1836 07f4 DF91      		pop r29
 1837 07f6 CF91      		pop r28
 1838 07f8 0895      		ret
 1844               	.Lscope13:
 1846               		.stabd	78,0,0
 1848               	.global	uxTaskGetNumberOfTasks
 1850               	uxTaskGetNumberOfTasks:
 1851               		.stabd	46,0,0
1463:tasks.c       **** /*-----------------------------------------------------------*/
1464:tasks.c       **** 
1465:tasks.c       **** unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
1466:tasks.c       **** {
 1853               	.LM177:
 1854               	.LFBB14:
 1855 07fa CF93      		push r28
 1856 07fc DF93      		push r29
 1857 07fe CDB7      		in r28,__SP_L__
 1858 0800 DEB7      		in r29,__SP_H__
 1859               	/* prologue: function */
 1860               	/* frame size = 0 */
 1861               	/* stack size = 2 */
 1862               	.L__stack_usage = 2
1467:tasks.c       **** 	/* A critical section is not required because the variables are of type
1468:tasks.c       **** 	portBASE_TYPE. */
1469:tasks.c       **** 	return uxCurrentNumberOfTasks;
 1864               	.LM178:
 1865 0802 8091 0000 		lds r24,uxCurrentNumberOfTasks
 1866               	/* epilogue start */
1470:tasks.c       **** }
 1868               	.LM179:
 1869 0806 DF91      		pop r29
 1870 0808 CF91      		pop r28
 1871 080a 0895      		ret
 1873               	.Lscope14:
 1875               		.stabd	78,0,0
 1877               	.global	vTaskIncrementTick
 1879               	vTaskIncrementTick:
 1880               		.stabd	46,0,0
1471:tasks.c       **** /*-----------------------------------------------------------*/
1472:tasks.c       **** 
1473:tasks.c       **** #if ( INCLUDE_pcTaskGetTaskName == 1 )
1474:tasks.c       **** 
1475:tasks.c       **** 	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
1476:tasks.c       **** 	{
1477:tasks.c       **** 	tskTCB *pxTCB;
1478:tasks.c       **** 
1479:tasks.c       **** 		/* If null is passed in here then the name of the calling task is being queried. */
1480:tasks.c       **** 		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
1481:tasks.c       **** 		configASSERT( pxTCB );
1482:tasks.c       **** 		return &( pxTCB->pcTaskName[ 0 ] );
1483:tasks.c       **** 	}
1484:tasks.c       **** 
1485:tasks.c       **** #endif
1486:tasks.c       **** /*-----------------------------------------------------------*/
1487:tasks.c       **** 
1488:tasks.c       **** #if ( configUSE_TRACE_FACILITY == 1 )
1489:tasks.c       **** 
1490:tasks.c       **** 	void vTaskList( signed char *pcWriteBuffer )
1491:tasks.c       **** 	{
1492:tasks.c       **** 	unsigned portBASE_TYPE uxQueue;
1493:tasks.c       **** 
1494:tasks.c       **** 		/* This is a VERY costly function that should be used for debug only.
1495:tasks.c       **** 		It leaves interrupts disabled for a LONG time. */
1496:tasks.c       **** 
1497:tasks.c       **** 		vTaskSuspendAll();
1498:tasks.c       **** 		{
1499:tasks.c       **** 			/* Run through all the lists that could potentially contain a TCB and
1500:tasks.c       **** 			report the task name, state and stack high water mark. */
1501:tasks.c       **** 
1502:tasks.c       **** 			*pcWriteBuffer = ( signed char ) 0x00;
1503:tasks.c       **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1504:tasks.c       **** 
1505:tasks.c       **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
1506:tasks.c       **** 
1507:tasks.c       **** 			do
1508:tasks.c       **** 			{
1509:tasks.c       **** 				uxQueue--;
1510:tasks.c       **** 
1511:tasks.c       **** 				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
1512:tasks.c       **** 				{
1513:tasks.c       **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tsk
1514:tasks.c       **** 				}
1515:tasks.c       **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1516:tasks.c       **** 
1517:tasks.c       **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
1518:tasks.c       **** 			{
1519:tasks.c       **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
1520:tasks.c       **** 			}
1521:tasks.c       **** 
1522:tasks.c       **** 			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
1523:tasks.c       **** 			{
1524:tasks.c       **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_C
1525:tasks.c       **** 			}
1526:tasks.c       **** 
1527:tasks.c       **** 			#if( INCLUDE_vTaskDelete == 1 )
1528:tasks.c       **** 			{
1529:tasks.c       **** 				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
1530:tasks.c       **** 				{
1531:tasks.c       **** 					prvListTaskWithinSingleList( pcWriteBuffer, &xTasksWaitingTermination, tskDELETED_CHAR );
1532:tasks.c       **** 				}
1533:tasks.c       **** 			}
1534:tasks.c       **** 			#endif
1535:tasks.c       **** 
1536:tasks.c       **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1537:tasks.c       **** 			{
1538:tasks.c       **** 				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
1539:tasks.c       **** 				{
1540:tasks.c       **** 					prvListTaskWithinSingleList( pcWriteBuffer, &xSuspendedTaskList, tskSUSPENDED_CHAR );
1541:tasks.c       **** 				}
1542:tasks.c       **** 			}
1543:tasks.c       **** 			#endif
1544:tasks.c       **** 		}
1545:tasks.c       **** 		xTaskResumeAll();
1546:tasks.c       **** 	}
1547:tasks.c       **** 
1548:tasks.c       **** #endif
1549:tasks.c       **** /*----------------------------------------------------------*/
1550:tasks.c       **** 
1551:tasks.c       **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
1552:tasks.c       **** 
1553:tasks.c       **** 	void vTaskGetRunTimeStats( signed char *pcWriteBuffer )
1554:tasks.c       **** 	{
1555:tasks.c       **** 	unsigned portBASE_TYPE uxQueue;
1556:tasks.c       **** 	unsigned long ulTotalRunTime;
1557:tasks.c       **** 
1558:tasks.c       **** 		/* This is a VERY costly function that should be used for debug only.
1559:tasks.c       **** 		It leaves interrupts disabled for a LONG time. */
1560:tasks.c       **** 
1561:tasks.c       **** 		vTaskSuspendAll();
1562:tasks.c       **** 		{
1563:tasks.c       **** 			#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1564:tasks.c       **** 				portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
1565:tasks.c       **** 			#else
1566:tasks.c       **** 				ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1567:tasks.c       **** 			#endif
1568:tasks.c       **** 
1569:tasks.c       **** 			/* Divide ulTotalRunTime by 100 to make the percentage caluclations
1570:tasks.c       **** 			simpler in the prvGenerateRunTimeStatsForTasksInList() function. */
1571:tasks.c       **** 			ulTotalRunTime /= 100UL;
1572:tasks.c       **** 
1573:tasks.c       **** 			/* Run through all the lists that could potentially contain a TCB,
1574:tasks.c       **** 			generating a table of run timer percentages in the provided
1575:tasks.c       **** 			buffer. */
1576:tasks.c       **** 
1577:tasks.c       **** 			*pcWriteBuffer = ( signed char ) 0x00;
1578:tasks.c       **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1579:tasks.c       **** 
1580:tasks.c       **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
1581:tasks.c       **** 
1582:tasks.c       **** 			do
1583:tasks.c       **** 			{
1584:tasks.c       **** 				uxQueue--;
1585:tasks.c       **** 
1586:tasks.c       **** 				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
1587:tasks.c       **** 				{
1588:tasks.c       **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueu
1589:tasks.c       **** 				}
1590:tasks.c       **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1591:tasks.c       **** 
1592:tasks.c       **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
1593:tasks.c       **** 			{
1594:tasks.c       **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, ulTotalRun
1595:tasks.c       **** 			}
1596:tasks.c       **** 
1597:tasks.c       **** 			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
1598:tasks.c       **** 			{
1599:tasks.c       **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, ul
1600:tasks.c       **** 			}
1601:tasks.c       **** 
1602:tasks.c       **** 			#if ( INCLUDE_vTaskDelete == 1 )
1603:tasks.c       **** 			{
1604:tasks.c       **** 				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
1605:tasks.c       **** 				{
1606:tasks.c       **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xTasksWaitingTermination, ulTotalRunTim
1607:tasks.c       **** 				}
1608:tasks.c       **** 			}
1609:tasks.c       **** 			#endif
1610:tasks.c       **** 
1611:tasks.c       **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1612:tasks.c       **** 			{
1613:tasks.c       **** 				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
1614:tasks.c       **** 				{
1615:tasks.c       **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xSuspendedTaskList, ulTotalRunTime );
1616:tasks.c       **** 				}
1617:tasks.c       **** 			}
1618:tasks.c       **** 			#endif
1619:tasks.c       **** 		}
1620:tasks.c       **** 		xTaskResumeAll();
1621:tasks.c       **** 	}
1622:tasks.c       **** 
1623:tasks.c       **** #endif
1624:tasks.c       **** /*----------------------------------------------------------*/
1625:tasks.c       **** 
1626:tasks.c       **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1627:tasks.c       **** 
1628:tasks.c       **** 	xTaskHandle xTaskGetIdleTaskHandle( void )
1629:tasks.c       **** 	{
1630:tasks.c       **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
1631:tasks.c       **** 		started, then xIdleTaskHandle will be NULL. */
1632:tasks.c       **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
1633:tasks.c       **** 		return xIdleTaskHandle;
1634:tasks.c       **** 	}
1635:tasks.c       **** 
1636:tasks.c       **** #endif
1637:tasks.c       **** /*----------------------------------------------------------*/
1638:tasks.c       **** 
1639:tasks.c       **** /* This conditional compilation should use inequality to 0, not equality to 1.
1640:tasks.c       **** This is to ensure vTaskStepTick() is available when user defined low power mode
1641:tasks.c       **** implementations require configUSE_TICKLESS_IDLE to be set to a value other than
1642:tasks.c       **** 1. */
1643:tasks.c       **** #if ( configUSE_TICKLESS_IDLE != 0 )
1644:tasks.c       **** 
1645:tasks.c       **** 	void vTaskStepTick( portTickType xTicksToJump )
1646:tasks.c       **** 	{
1647:tasks.c       **** 		configASSERT( xTicksToJump <= xNextTaskUnblockTime );
1648:tasks.c       **** 		xTickCount += xTicksToJump;
1649:tasks.c       **** 	}
1650:tasks.c       **** 
1651:tasks.c       **** #endif
1652:tasks.c       **** 
1653:tasks.c       **** /*-----------------------------------------------------------
1654:tasks.c       ****  * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
1655:tasks.c       ****  * documented in task.h
1656:tasks.c       ****  *----------------------------------------------------------*/
1657:tasks.c       **** 
1658:tasks.c       **** void vTaskIncrementTick( void )
1659:tasks.c       **** {
 1882               	.LM180:
 1883               	.LFBB15:
 1884 080c CF93      		push r28
 1885 080e DF93      		push r29
 1886 0810 00D0      		rcall .
 1887 0812 00D0      		rcall .
 1888 0814 CDB7      		in r28,__SP_L__
 1889 0816 DEB7      		in r29,__SP_H__
 1890               	/* prologue: function */
 1891               	/* frame size = 6 */
 1892               	/* stack size = 8 */
 1893               	.L__stack_usage = 8
1660:tasks.c       **** tskTCB * pxTCB;
1661:tasks.c       **** 
1662:tasks.c       **** 	/* Called by the portable layer each time a tick interrupt occurs.
1663:tasks.c       **** 	Increments the tick then checks to see if the new tick value will cause any
1664:tasks.c       **** 	tasks to be unblocked. */
1665:tasks.c       **** 	traceTASK_INCREMENT_TICK( xTickCount );
1666:tasks.c       **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1895               	.LM181:
 1896 0818 8091 0000 		lds r24,uxSchedulerSuspended
 1897 081c 8823      		tst r24
 1898 081e 01F0      		breq .+2
 1899 0820 00C0      		rjmp .L64
1667:tasks.c       **** 	{
1668:tasks.c       **** 		++xTickCount;
 1901               	.LM182:
 1902 0822 8091 0000 		lds r24,xTickCount
 1903 0826 9091 0000 		lds r25,xTickCount+1
 1904 082a 0196      		adiw r24,1
 1905 082c 9093 0000 		sts xTickCount+1,r25
 1906 0830 8093 0000 		sts xTickCount,r24
1669:tasks.c       **** 		if( xTickCount == ( portTickType ) 0U )
 1908               	.LM183:
 1909 0834 8091 0000 		lds r24,xTickCount
 1910 0838 9091 0000 		lds r25,xTickCount+1
 1911 083c 0097      		sbiw r24,0
 1912 083e 01F4      		brne .L65
 1913               	.LBB4:
1670:tasks.c       **** 		{
1671:tasks.c       **** 			xList *pxTemp;
1672:tasks.c       **** 
1673:tasks.c       **** 			/* Tick count has overflowed so we need to swap the delay lists.
1674:tasks.c       **** 			If there are any items in pxDelayedTaskList here then there is
1675:tasks.c       **** 			an error! */
1676:tasks.c       **** 			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
1677:tasks.c       **** 
1678:tasks.c       **** 			pxTemp = pxDelayedTaskList;
 1915               	.LM184:
 1916 0840 8091 0000 		lds r24,pxDelayedTaskList
 1917 0844 9091 0000 		lds r25,pxDelayedTaskList+1
 1918 0848 9A83      		std Y+2,r25
 1919 084a 8983      		std Y+1,r24
1679:tasks.c       **** 			pxDelayedTaskList = pxOverflowDelayedTaskList;
 1921               	.LM185:
 1922 084c 8091 0000 		lds r24,pxOverflowDelayedTaskList
 1923 0850 9091 0000 		lds r25,pxOverflowDelayedTaskList+1
 1924 0854 9093 0000 		sts pxDelayedTaskList+1,r25
 1925 0858 8093 0000 		sts pxDelayedTaskList,r24
1680:tasks.c       **** 			pxOverflowDelayedTaskList = pxTemp;
 1927               	.LM186:
 1928 085c 8981      		ldd r24,Y+1
 1929 085e 9A81      		ldd r25,Y+2
 1930 0860 9093 0000 		sts pxOverflowDelayedTaskList+1,r25
 1931 0864 8093 0000 		sts pxOverflowDelayedTaskList,r24
1681:tasks.c       **** 			xNumOfOverflows++;
 1933               	.LM187:
 1934 0868 8091 0000 		lds r24,xNumOfOverflows
 1935 086c 8F5F      		subi r24,lo8(-(1))
 1936 086e 8093 0000 		sts xNumOfOverflows,r24
1682:tasks.c       **** 
1683:tasks.c       **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 1938               	.LM188:
 1939 0872 8091 0000 		lds r24,pxDelayedTaskList
 1940 0876 9091 0000 		lds r25,pxDelayedTaskList+1
 1941 087a FC01      		movw r30,r24
 1942 087c 8081      		ld r24,Z
 1943 087e 8823      		tst r24
 1944 0880 01F4      		brne .L66
1684:tasks.c       **** 			{
1685:tasks.c       **** 				/* The new current delayed list is empty.  Set
1686:tasks.c       **** 				xNextTaskUnblockTime to the maximum possible value so it is
1687:tasks.c       **** 				extremely unlikely that the
1688:tasks.c       **** 				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
1689:tasks.c       **** 				there is an item in the delayed list. */
1690:tasks.c       **** 				xNextTaskUnblockTime = portMAX_DELAY;
 1946               	.LM189:
 1947 0882 8FEF      		ldi r24,lo8(-1)
 1948 0884 9FEF      		ldi r25,lo8(-1)
 1949 0886 9093 0000 		sts xNextTaskUnblockTime+1,r25
 1950 088a 8093 0000 		sts xNextTaskUnblockTime,r24
 1951 088e 00C0      		rjmp .L65
 1952               	.L66:
1691:tasks.c       **** 			}
1692:tasks.c       **** 			else
1693:tasks.c       **** 			{
1694:tasks.c       **** 				/* The new current delayed list is not empty, get the value of
1695:tasks.c       **** 				the item at the head of the delayed list.  This is the time at
1696:tasks.c       **** 				which the task at the head of the delayed list should be removed
1697:tasks.c       **** 				from the Blocked state. */
1698:tasks.c       **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 1954               	.LM190:
 1955 0890 8091 0000 		lds r24,pxDelayedTaskList
 1956 0894 9091 0000 		lds r25,pxDelayedTaskList+1
 1957 0898 FC01      		movw r30,r24
 1958 089a 8581      		ldd r24,Z+5
 1959 089c 9681      		ldd r25,Z+6
 1960 089e FC01      		movw r30,r24
 1961 08a0 8681      		ldd r24,Z+6
 1962 08a2 9781      		ldd r25,Z+7
 1963 08a4 9C83      		std Y+4,r25
 1964 08a6 8B83      		std Y+3,r24
1699:tasks.c       **** 				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 1966               	.LM191:
 1967 08a8 8B81      		ldd r24,Y+3
 1968 08aa 9C81      		ldd r25,Y+4
 1969 08ac FC01      		movw r30,r24
 1970 08ae 8281      		ldd r24,Z+2
 1971 08b0 9381      		ldd r25,Z+3
 1972 08b2 9093 0000 		sts xNextTaskUnblockTime+1,r25
 1973 08b6 8093 0000 		sts xNextTaskUnblockTime,r24
 1974               	.L65:
 1975               	.LBE4:
 1976               	.LBB5:
1700:tasks.c       **** 			}
1701:tasks.c       **** 		}
1702:tasks.c       **** 
1703:tasks.c       **** 		/* See if this tick has made a timeout expire. */
1704:tasks.c       **** 		prvCheckDelayedTasks();
 1978               	.LM192:
 1979 08ba 2091 0000 		lds r18,xTickCount
 1980 08be 3091 0000 		lds r19,xTickCount+1
 1981 08c2 8091 0000 		lds r24,xNextTaskUnblockTime
 1982 08c6 9091 0000 		lds r25,xNextTaskUnblockTime+1
 1983 08ca 2817      		cp r18,r24
 1984 08cc 3907      		cpc r19,r25
 1985 08ce 00F4      		brsh .+2
 1986 08d0 00C0      		rjmp .L67
 1987               	.L72:
 1989               	.LM193:
 1990 08d2 8091 0000 		lds r24,pxDelayedTaskList
 1991 08d6 9091 0000 		lds r25,pxDelayedTaskList+1
 1992 08da FC01      		movw r30,r24
 1993 08dc 8081      		ld r24,Z
 1994 08de 8823      		tst r24
 1995 08e0 01F4      		brne .L68
 1996 08e2 8FEF      		ldi r24,lo8(-1)
 1997 08e4 9FEF      		ldi r25,lo8(-1)
 1998 08e6 9093 0000 		sts xNextTaskUnblockTime+1,r25
 1999 08ea 8093 0000 		sts xNextTaskUnblockTime,r24
 2000 08ee 00C0      		rjmp .L67
 2001               	.L68:
 2003               	.LM194:
 2004 08f0 8091 0000 		lds r24,pxDelayedTaskList
 2005 08f4 9091 0000 		lds r25,pxDelayedTaskList+1
 2006 08f8 FC01      		movw r30,r24
 2007 08fa 8581      		ldd r24,Z+5
 2008 08fc 9681      		ldd r25,Z+6
 2009 08fe FC01      		movw r30,r24
 2010 0900 8681      		ldd r24,Z+6
 2011 0902 9781      		ldd r25,Z+7
 2012 0904 9C83      		std Y+4,r25
 2013 0906 8B83      		std Y+3,r24
 2014 0908 8B81      		ldd r24,Y+3
 2015 090a 9C81      		ldd r25,Y+4
 2016 090c FC01      		movw r30,r24
 2017 090e 8281      		ldd r24,Z+2
 2018 0910 9381      		ldd r25,Z+3
 2019 0912 9E83      		std Y+6,r25
 2020 0914 8D83      		std Y+5,r24
 2021 0916 2091 0000 		lds r18,xTickCount
 2022 091a 3091 0000 		lds r19,xTickCount+1
 2023 091e 8D81      		ldd r24,Y+5
 2024 0920 9E81      		ldd r25,Y+6
 2025 0922 2817      		cp r18,r24
 2026 0924 3907      		cpc r19,r25
 2027 0926 00F4      		brsh .L69
 2029               	.LM195:
 2030 0928 8D81      		ldd r24,Y+5
 2031 092a 9E81      		ldd r25,Y+6
 2032 092c 9093 0000 		sts xNextTaskUnblockTime+1,r25
 2033 0930 8093 0000 		sts xNextTaskUnblockTime,r24
 2034 0934 00C0      		rjmp .L67
 2035               	.L69:
 2037               	.LM196:
 2038 0936 8B81      		ldd r24,Y+3
 2039 0938 9C81      		ldd r25,Y+4
 2040 093a 0296      		adiw r24,2
 2041 093c 0E94 0000 		call uxListRemove
 2042 0940 8B81      		ldd r24,Y+3
 2043 0942 9C81      		ldd r25,Y+4
 2044 0944 FC01      		movw r30,r24
 2045 0946 8489      		ldd r24,Z+20
 2046 0948 9589      		ldd r25,Z+21
 2047 094a 0097      		sbiw r24,0
 2048 094c 01F0      		breq .L70
 2050               	.LM197:
 2051 094e 8B81      		ldd r24,Y+3
 2052 0950 9C81      		ldd r25,Y+4
 2053 0952 0C96      		adiw r24,12
 2054 0954 0E94 0000 		call uxListRemove
 2055               	.L70:
 2057               	.LM198:
 2058 0958 8B81      		ldd r24,Y+3
 2059 095a 9C81      		ldd r25,Y+4
 2060 095c FC01      		movw r30,r24
 2061 095e 9689      		ldd r25,Z+22
 2062 0960 8091 0000 		lds r24,uxTopReadyPriority
 2063 0964 8917      		cp r24,r25
 2064 0966 00F4      		brsh .L71
 2066               	.LM199:
 2067 0968 8B81      		ldd r24,Y+3
 2068 096a 9C81      		ldd r25,Y+4
 2069 096c FC01      		movw r30,r24
 2070 096e 8689      		ldd r24,Z+22
 2071 0970 8093 0000 		sts uxTopReadyPriority,r24
 2072               	.L71:
 2074               	.LM200:
 2075 0974 8B81      		ldd r24,Y+3
 2076 0976 9C81      		ldd r25,Y+4
 2077 0978 AC01      		movw r20,r24
 2078 097a 4E5F      		subi r20,-2
 2079 097c 5F4F      		sbci r21,-1
 2080 097e 8B81      		ldd r24,Y+3
 2081 0980 9C81      		ldd r25,Y+4
 2082 0982 FC01      		movw r30,r24
 2083 0984 8689      		ldd r24,Z+22
 2084 0986 282F      		mov r18,r24
 2085 0988 30E0      		ldi r19,0
 2086 098a C901      		movw r24,r18
 2087 098c 880F      		lsl r24
 2088 098e 991F      		rol r25
 2089 0990 880F      		lsl r24
 2090 0992 991F      		rol r25
 2091 0994 880F      		lsl r24
 2092 0996 991F      		rol r25
 2093 0998 820F      		add r24,r18
 2094 099a 931F      		adc r25,r19
 2095 099c 8050      		subi r24,lo8(-(pxReadyTasksLists))
 2096 099e 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 2097 09a0 BA01      		movw r22,r20
 2098 09a2 0E94 0000 		call vListInsertEnd
 2099 09a6 00C0      		rjmp .L72
 2100               	.L67:
 2101               	.LBE5:
 2102 09a8 00C0      		rjmp .L73
 2103               	.L64:
1705:tasks.c       **** 	}
1706:tasks.c       **** 	else
1707:tasks.c       **** 	{
1708:tasks.c       **** 		++uxMissedTicks;
 2105               	.LM201:
 2106 09aa 8091 0000 		lds r24,uxMissedTicks
 2107 09ae 8F5F      		subi r24,lo8(-(1))
 2108 09b0 8093 0000 		sts uxMissedTicks,r24
1709:tasks.c       **** 
1710:tasks.c       **** 		/* The tick hook gets called at regular intervals, even if the
1711:tasks.c       **** 		scheduler is locked. */
1712:tasks.c       **** 		#if ( configUSE_TICK_HOOK == 1 )
1713:tasks.c       **** 		{
1714:tasks.c       **** 			vApplicationTickHook();
 2110               	.LM202:
 2111 09b4 0E94 0000 		call vApplicationTickHook
 2112               	.L73:
1715:tasks.c       **** 		}
1716:tasks.c       **** 		#endif
1717:tasks.c       **** 	}
1718:tasks.c       **** 
1719:tasks.c       **** 	#if ( configUSE_TICK_HOOK == 1 )
1720:tasks.c       **** 	{
1721:tasks.c       **** 		/* Guard against the tick hook being called when the missed tick
1722:tasks.c       **** 		count is being unwound (when the scheduler is being unlocked. */
1723:tasks.c       **** 		if( uxMissedTicks == ( unsigned portBASE_TYPE ) 0U )
 2114               	.LM203:
 2115 09b8 8091 0000 		lds r24,uxMissedTicks
 2116 09bc 8823      		tst r24
 2117 09be 01F4      		brne .L63
1724:tasks.c       **** 		{
1725:tasks.c       **** 			vApplicationTickHook();
 2119               	.LM204:
 2120 09c0 0E94 0000 		call vApplicationTickHook
 2121               	.L63:
 2122               	/* epilogue start */
1726:tasks.c       **** 		}
1727:tasks.c       **** 	}
1728:tasks.c       **** 	#endif
1729:tasks.c       **** }
 2124               	.LM205:
 2125 09c4 2696      		adiw r28,6
 2126 09c6 0FB6      		in __tmp_reg__,__SREG__
 2127 09c8 F894      		cli
 2128 09ca DEBF      		out __SP_H__,r29
 2129 09cc 0FBE      		out __SREG__,__tmp_reg__
 2130 09ce CDBF      		out __SP_L__,r28
 2131 09d0 DF91      		pop r29
 2132 09d2 CF91      		pop r28
 2133 09d4 0895      		ret
 2144               	.Lscope15:
 2146               		.stabd	78,0,0
 2148               	.global	vTaskSwitchContext
 2150               	vTaskSwitchContext:
 2151               		.stabd	46,0,0
1730:tasks.c       **** /*-----------------------------------------------------------*/
1731:tasks.c       **** 
1732:tasks.c       **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1733:tasks.c       **** 
1734:tasks.c       **** 	void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction )
1735:tasks.c       **** 	{
1736:tasks.c       **** 	tskTCB *xTCB;
1737:tasks.c       **** 
1738:tasks.c       **** 		/* If xTask is NULL then we are setting our own task hook. */
1739:tasks.c       **** 		if( xTask == NULL )
1740:tasks.c       **** 		{
1741:tasks.c       **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1742:tasks.c       **** 		}
1743:tasks.c       **** 		else
1744:tasks.c       **** 		{
1745:tasks.c       **** 			xTCB = ( tskTCB * ) xTask;
1746:tasks.c       **** 		}
1747:tasks.c       **** 
1748:tasks.c       **** 		/* Save the hook function in the TCB.  A critical section is required as
1749:tasks.c       **** 		the value can be accessed from an interrupt. */
1750:tasks.c       **** 		taskENTER_CRITICAL();
1751:tasks.c       **** 			xTCB->pxTaskTag = pxHookFunction;
1752:tasks.c       **** 		taskEXIT_CRITICAL();
1753:tasks.c       **** 	}
1754:tasks.c       **** 
1755:tasks.c       **** #endif
1756:tasks.c       **** /*-----------------------------------------------------------*/
1757:tasks.c       **** 
1758:tasks.c       **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1759:tasks.c       **** 
1760:tasks.c       **** 	pdTASK_HOOK_CODE xTaskGetApplicationTaskTag( xTaskHandle xTask )
1761:tasks.c       **** 	{
1762:tasks.c       **** 	tskTCB *xTCB;
1763:tasks.c       **** 	pdTASK_HOOK_CODE xReturn;
1764:tasks.c       **** 
1765:tasks.c       **** 		/* If xTask is NULL then we are setting our own task hook. */
1766:tasks.c       **** 		if( xTask == NULL )
1767:tasks.c       **** 		{
1768:tasks.c       **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1769:tasks.c       **** 		}
1770:tasks.c       **** 		else
1771:tasks.c       **** 		{
1772:tasks.c       **** 			xTCB = ( tskTCB * ) xTask;
1773:tasks.c       **** 		}
1774:tasks.c       **** 
1775:tasks.c       **** 		/* Save the hook function in the TCB.  A critical section is required as
1776:tasks.c       **** 		the value can be accessed from an interrupt. */
1777:tasks.c       **** 		taskENTER_CRITICAL();
1778:tasks.c       **** 			xReturn = xTCB->pxTaskTag;
1779:tasks.c       **** 		taskEXIT_CRITICAL();
1780:tasks.c       **** 
1781:tasks.c       **** 		return xReturn;
1782:tasks.c       **** 	}
1783:tasks.c       **** 
1784:tasks.c       **** #endif
1785:tasks.c       **** /*-----------------------------------------------------------*/
1786:tasks.c       **** 
1787:tasks.c       **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1788:tasks.c       **** 
1789:tasks.c       **** 	portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter )
1790:tasks.c       **** 	{
1791:tasks.c       **** 	tskTCB *xTCB;
1792:tasks.c       **** 	portBASE_TYPE xReturn;
1793:tasks.c       **** 
1794:tasks.c       **** 		/* If xTask is NULL then we are calling our own task hook. */
1795:tasks.c       **** 		if( xTask == NULL )
1796:tasks.c       **** 		{
1797:tasks.c       **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1798:tasks.c       **** 		}
1799:tasks.c       **** 		else
1800:tasks.c       **** 		{
1801:tasks.c       **** 			xTCB = ( tskTCB * ) xTask;
1802:tasks.c       **** 		}
1803:tasks.c       **** 
1804:tasks.c       **** 		if( xTCB->pxTaskTag != NULL )
1805:tasks.c       **** 		{
1806:tasks.c       **** 			xReturn = xTCB->pxTaskTag( pvParameter );
1807:tasks.c       **** 		}
1808:tasks.c       **** 		else
1809:tasks.c       **** 		{
1810:tasks.c       **** 			xReturn = pdFAIL;
1811:tasks.c       **** 		}
1812:tasks.c       **** 
1813:tasks.c       **** 		return xReturn;
1814:tasks.c       **** 	}
1815:tasks.c       **** 
1816:tasks.c       **** #endif
1817:tasks.c       **** /*-----------------------------------------------------------*/
1818:tasks.c       **** 
1819:tasks.c       **** void vTaskSwitchContext( void )
1820:tasks.c       **** {
 2153               	.LM206:
 2154               	.LFBB16:
 2155 09d6 CF93      		push r28
 2156 09d8 DF93      		push r29
 2157 09da 1F92      		push __zero_reg__
 2158 09dc 1F92      		push __zero_reg__
 2159 09de CDB7      		in r28,__SP_L__
 2160 09e0 DEB7      		in r29,__SP_H__
 2161               	/* prologue: function */
 2162               	/* frame size = 2 */
 2163               	/* stack size = 4 */
 2164               	.L__stack_usage = 4
1821:tasks.c       **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 2166               	.LM207:
 2167 09e2 8091 0000 		lds r24,uxSchedulerSuspended
 2168 09e6 8823      		tst r24
 2169 09e8 01F0      		breq .L76
1822:tasks.c       **** 	{
1823:tasks.c       **** 		/* The scheduler is currently suspended - do not allow a context
1824:tasks.c       **** 		switch. */
1825:tasks.c       **** 		xMissedYield = pdTRUE;
 2171               	.LM208:
 2172 09ea 81E0      		ldi r24,lo8(1)
 2173 09ec 8093 0000 		sts xMissedYield,r24
 2174 09f0 00C0      		rjmp .L75
 2175               	.L76:
1826:tasks.c       **** 	}
1827:tasks.c       **** 	else
1828:tasks.c       **** 	{
1829:tasks.c       **** 		traceTASK_SWITCHED_OUT();
1830:tasks.c       **** 
1831:tasks.c       **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
1832:tasks.c       **** 		{
1833:tasks.c       **** 			unsigned long ulTempCounter;
1834:tasks.c       **** 
1835:tasks.c       **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1836:tasks.c       **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTempCounter );
1837:tasks.c       **** 				#else
1838:tasks.c       **** 					ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
1839:tasks.c       **** 				#endif
1840:tasks.c       **** 
1841:tasks.c       **** 				/* Add the amount of time the task has been running to the accumulated
1842:tasks.c       **** 				time so far.  The time the task started running was stored in
1843:tasks.c       **** 				ulTaskSwitchedInTime.  Note that there is no overflow protection here
1844:tasks.c       **** 				so count values are only valid until the timer overflows.  Generally
1845:tasks.c       **** 				this will be about 1 hour assuming a 1uS timer increment. */
1846:tasks.c       **** 				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
1847:tasks.c       **** 				ulTaskSwitchedInTime = ulTempCounter;
1848:tasks.c       **** 		}
1849:tasks.c       **** 		#endif
1850:tasks.c       **** 
1851:tasks.c       **** //BB Commented out...
1852:tasks.c       **** //		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
1853:tasks.c       **** 		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
1854:tasks.c       **** 
1855:tasks.c       **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
 2177               	.LM209:
 2178 09f2 00C0      		rjmp .L78
 2179               	.L79:
 2181               	.LM210:
 2182 09f4 8091 0000 		lds r24,uxTopReadyPriority
 2183 09f8 8150      		subi r24,lo8(-(-1))
 2184 09fa 8093 0000 		sts uxTopReadyPriority,r24
 2185               	.L78:
 2187               	.LM211:
 2188 09fe 8091 0000 		lds r24,uxTopReadyPriority
 2189 0a02 282F      		mov r18,r24
 2190 0a04 30E0      		ldi r19,0
 2191 0a06 C901      		movw r24,r18
 2192 0a08 880F      		lsl r24
 2193 0a0a 991F      		rol r25
 2194 0a0c 880F      		lsl r24
 2195 0a0e 991F      		rol r25
 2196 0a10 880F      		lsl r24
 2197 0a12 991F      		rol r25
 2198 0a14 820F      		add r24,r18
 2199 0a16 931F      		adc r25,r19
 2200 0a18 8050      		subi r24,lo8(-(pxReadyTasksLists))
 2201 0a1a 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 2202 0a1c FC01      		movw r30,r24
 2203 0a1e 8081      		ld r24,Z
 2204 0a20 8823      		tst r24
 2205 0a22 01F0      		breq .L79
 2206               	.LBB6:
 2208               	.LM212:
 2209 0a24 8091 0000 		lds r24,uxTopReadyPriority
 2210 0a28 282F      		mov r18,r24
 2211 0a2a 30E0      		ldi r19,0
 2212 0a2c C901      		movw r24,r18
 2213 0a2e 880F      		lsl r24
 2214 0a30 991F      		rol r25
 2215 0a32 880F      		lsl r24
 2216 0a34 991F      		rol r25
 2217 0a36 880F      		lsl r24
 2218 0a38 991F      		rol r25
 2219 0a3a 820F      		add r24,r18
 2220 0a3c 931F      		adc r25,r19
 2221 0a3e 8050      		subi r24,lo8(-(pxReadyTasksLists))
 2222 0a40 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 2223 0a42 9A83      		std Y+2,r25
 2224 0a44 8983      		std Y+1,r24
 2225 0a46 8981      		ldd r24,Y+1
 2226 0a48 9A81      		ldd r25,Y+2
 2227 0a4a FC01      		movw r30,r24
 2228 0a4c 8181      		ldd r24,Z+1
 2229 0a4e 9281      		ldd r25,Z+2
 2230 0a50 FC01      		movw r30,r24
 2231 0a52 2281      		ldd r18,Z+2
 2232 0a54 3381      		ldd r19,Z+3
 2233 0a56 8981      		ldd r24,Y+1
 2234 0a58 9A81      		ldd r25,Y+2
 2235 0a5a FC01      		movw r30,r24
 2236 0a5c 3283      		std Z+2,r19
 2237 0a5e 2183      		std Z+1,r18
 2238 0a60 8981      		ldd r24,Y+1
 2239 0a62 9A81      		ldd r25,Y+2
 2240 0a64 FC01      		movw r30,r24
 2241 0a66 2181      		ldd r18,Z+1
 2242 0a68 3281      		ldd r19,Z+2
 2243 0a6a 8981      		ldd r24,Y+1
 2244 0a6c 9A81      		ldd r25,Y+2
 2245 0a6e 0396      		adiw r24,3
 2246 0a70 2817      		cp r18,r24
 2247 0a72 3907      		cpc r19,r25
 2248 0a74 01F4      		brne .L80
 2250               	.LM213:
 2251 0a76 8981      		ldd r24,Y+1
 2252 0a78 9A81      		ldd r25,Y+2
 2253 0a7a FC01      		movw r30,r24
 2254 0a7c 8181      		ldd r24,Z+1
 2255 0a7e 9281      		ldd r25,Z+2
 2256 0a80 FC01      		movw r30,r24
 2257 0a82 2281      		ldd r18,Z+2
 2258 0a84 3381      		ldd r19,Z+3
 2259 0a86 8981      		ldd r24,Y+1
 2260 0a88 9A81      		ldd r25,Y+2
 2261 0a8a FC01      		movw r30,r24
 2262 0a8c 3283      		std Z+2,r19
 2263 0a8e 2183      		std Z+1,r18
 2264               	.L80:
 2266               	.LM214:
 2267 0a90 8981      		ldd r24,Y+1
 2268 0a92 9A81      		ldd r25,Y+2
 2269 0a94 FC01      		movw r30,r24
 2270 0a96 8181      		ldd r24,Z+1
 2271 0a98 9281      		ldd r25,Z+2
 2272 0a9a FC01      		movw r30,r24
 2273 0a9c 8681      		ldd r24,Z+6
 2274 0a9e 9781      		ldd r25,Z+7
 2275 0aa0 9093 0000 		sts pxCurrentTCB+1,r25
 2276 0aa4 8093 0000 		sts pxCurrentTCB,r24
 2277               	.L75:
 2278               	/* epilogue start */
 2279               	.LBE6:
1856:tasks.c       **** 
1857:tasks.c       **** 		traceTASK_SWITCHED_IN();
1858:tasks.c       **** 	}
1859:tasks.c       **** }
 2281               	.LM215:
 2282 0aa8 0F90      		pop __tmp_reg__
 2283 0aaa 0F90      		pop __tmp_reg__
 2284 0aac DF91      		pop r29
 2285 0aae CF91      		pop r28
 2286 0ab0 0895      		ret
 2291               	.Lscope16:
 2293               		.stabd	78,0,0
 2297               	.global	vTaskPlaceOnEventList
 2299               	vTaskPlaceOnEventList:
 2300               		.stabd	46,0,0
1860:tasks.c       **** /*-----------------------------------------------------------*/
1861:tasks.c       **** 
1862:tasks.c       **** void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
1863:tasks.c       **** {
 2302               	.LM216:
 2303               	.LFBB17:
 2304 0ab2 CF93      		push r28
 2305 0ab4 DF93      		push r29
 2306 0ab6 00D0      		rcall .
 2307 0ab8 00D0      		rcall .
 2308 0aba CDB7      		in r28,__SP_L__
 2309 0abc DEB7      		in r29,__SP_H__
 2310               	/* prologue: function */
 2311               	/* frame size = 6 */
 2312               	/* stack size = 8 */
 2313               	.L__stack_usage = 8
 2314 0abe 9C83      		std Y+4,r25
 2315 0ac0 8B83      		std Y+3,r24
 2316 0ac2 7E83      		std Y+6,r23
 2317 0ac4 6D83      		std Y+5,r22
1864:tasks.c       **** portTickType xTimeToWake;
1865:tasks.c       **** 
1866:tasks.c       **** 	configASSERT( pxEventList );
1867:tasks.c       **** 
1868:tasks.c       **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1869:tasks.c       **** 	SCHEDULER SUSPENDED. */
1870:tasks.c       **** 
1871:tasks.c       **** 	/* Place the event list item of the TCB in the appropriate event list.
1872:tasks.c       **** 	This is placed in the list in priority order so the highest priority task
1873:tasks.c       **** 	is the first to be woken by the event. */
1874:tasks.c       **** 	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 2319               	.LM217:
 2320 0ac6 8091 0000 		lds r24,pxCurrentTCB
 2321 0aca 9091 0000 		lds r25,pxCurrentTCB+1
 2322 0ace 9C01      		movw r18,r24
 2323 0ad0 245F      		subi r18,-12
 2324 0ad2 3F4F      		sbci r19,-1
 2325 0ad4 8B81      		ldd r24,Y+3
 2326 0ad6 9C81      		ldd r25,Y+4
 2327 0ad8 B901      		movw r22,r18
 2328 0ada 0E94 0000 		call vListInsert
1875:tasks.c       **** 
1876:tasks.c       **** 	/* We must remove ourselves from the ready list before adding ourselves
1877:tasks.c       **** 	to the blocked list as the same list item is used for both lists.  We have
1878:tasks.c       **** 	exclusive access to the ready lists as the scheduler is locked. */
1879:tasks.c       **** 	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
 2330               	.LM218:
 2331 0ade 8091 0000 		lds r24,pxCurrentTCB
 2332 0ae2 9091 0000 		lds r25,pxCurrentTCB+1
 2333 0ae6 0296      		adiw r24,2
 2334 0ae8 0E94 0000 		call uxListRemove
1880:tasks.c       **** 	{
1881:tasks.c       **** 		/* The current task must be in a ready list, so there is no need to
1882:tasks.c       **** 		check, and the port reset macro can be called directly. */
1883:tasks.c       **** 		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
1884:tasks.c       **** 	}
1885:tasks.c       **** 
1886:tasks.c       **** 	#if ( INCLUDE_vTaskSuspend == 1 )
1887:tasks.c       **** 	{
1888:tasks.c       **** 		if( xTicksToWait == portMAX_DELAY )
 2336               	.LM219:
 2337 0aec 8D81      		ldd r24,Y+5
 2338 0aee 9E81      		ldd r25,Y+6
 2339 0af0 8F3F      		cpi r24,-1
 2340 0af2 2FEF      		ldi r18,-1
 2341 0af4 9207      		cpc r25,r18
 2342 0af6 01F4      		brne .L82
1889:tasks.c       **** 		{
1890:tasks.c       **** 			/* Add ourselves to the suspended task list instead of a delayed task
1891:tasks.c       **** 			list to ensure we are not woken by a timing event.  We will block
1892:tasks.c       **** 			indefinitely. */
1893:tasks.c       **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListIt
 2344               	.LM220:
 2345 0af8 8091 0000 		lds r24,pxCurrentTCB
 2346 0afc 9091 0000 		lds r25,pxCurrentTCB+1
 2347 0b00 0296      		adiw r24,2
 2348 0b02 BC01      		movw r22,r24
 2349 0b04 80E0      		ldi r24,lo8(xSuspendedTaskList)
 2350 0b06 90E0      		ldi r25,hi8(xSuspendedTaskList)
 2351 0b08 0E94 0000 		call vListInsertEnd
 2352 0b0c 00C0      		rjmp .L81
 2353               	.L82:
1894:tasks.c       **** 		}
1895:tasks.c       **** 		else
1896:tasks.c       **** 		{
1897:tasks.c       **** 			/* Calculate the time at which the task should be woken if the event does
1898:tasks.c       **** 			not occur.  This may overflow but this doesn't matter. */
1899:tasks.c       **** 			xTimeToWake = xTickCount + xTicksToWait;
 2355               	.LM221:
 2356 0b0e 2091 0000 		lds r18,xTickCount
 2357 0b12 3091 0000 		lds r19,xTickCount+1
 2358 0b16 8D81      		ldd r24,Y+5
 2359 0b18 9E81      		ldd r25,Y+6
 2360 0b1a 820F      		add r24,r18
 2361 0b1c 931F      		adc r25,r19
 2362 0b1e 9A83      		std Y+2,r25
 2363 0b20 8983      		std Y+1,r24
1900:tasks.c       **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 2365               	.LM222:
 2366 0b22 8981      		ldd r24,Y+1
 2367 0b24 9A81      		ldd r25,Y+2
 2368 0b26 0E94 0000 		call prvAddCurrentTaskToDelayedList
 2369               	.L81:
 2370               	/* epilogue start */
1901:tasks.c       **** 		}
1902:tasks.c       **** 	}
1903:tasks.c       **** 	#else
1904:tasks.c       **** 	{
1905:tasks.c       **** 			/* Calculate the time at which the task should be woken if the event does
1906:tasks.c       **** 			not occur.  This may overflow but this doesn't matter. */
1907:tasks.c       **** 			xTimeToWake = xTickCount + xTicksToWait;
1908:tasks.c       **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
1909:tasks.c       **** 	}
1910:tasks.c       **** 	#endif
1911:tasks.c       **** }
 2372               	.LM223:
 2373 0b2a 2696      		adiw r28,6
 2374 0b2c 0FB6      		in __tmp_reg__,__SREG__
 2375 0b2e F894      		cli
 2376 0b30 DEBF      		out __SP_H__,r29
 2377 0b32 0FBE      		out __SREG__,__tmp_reg__
 2378 0b34 CDBF      		out __SP_L__,r28
 2379 0b36 DF91      		pop r29
 2380 0b38 CF91      		pop r28
 2381 0b3a 0895      		ret
 2386               	.Lscope17:
 2388               		.stabd	78,0,0
 2391               	.global	xTaskRemoveFromEventList
 2393               	xTaskRemoveFromEventList:
 2394               		.stabd	46,0,0
1912:tasks.c       **** /*-----------------------------------------------------------*/
1913:tasks.c       **** 
1914:tasks.c       **** #if configUSE_TIMERS == 1
1915:tasks.c       **** 
1916:tasks.c       **** 	void vTaskPlaceOnEventListRestricted( const xList * const pxEventList, portTickType xTicksToWait )
1917:tasks.c       **** 	{
1918:tasks.c       **** 	portTickType xTimeToWake;
1919:tasks.c       **** 
1920:tasks.c       **** 		configASSERT( pxEventList );
1921:tasks.c       **** 
1922:tasks.c       **** 		/* This function should not be called by application code hence the
1923:tasks.c       **** 		'Restricted' in its name.  It is not part of the public API.  It is
1924:tasks.c       **** 		designed for use by kernel code, and has special calling requirements -
1925:tasks.c       **** 		it should be called from a critical section. */
1926:tasks.c       **** 
1927:tasks.c       **** 
1928:tasks.c       **** 		/* Place the event list item of the TCB in the appropriate event list.
1929:tasks.c       **** 		In this case it is assume that this is the only task that is going to
1930:tasks.c       **** 		be waiting on this event list, so the faster vListInsertEnd() function
1931:tasks.c       **** 		can be used in place of vListInsert. */
1932:tasks.c       **** 		vListInsertEnd( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
1933:tasks.c       **** 
1934:tasks.c       **** 		/* We must remove this task from the ready list before adding it to the
1935:tasks.c       **** 		blocked list as the same list item is used for both lists.  This
1936:tasks.c       **** 		function is called form a critical section. */
1937:tasks.c       **** 		if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
1938:tasks.c       **** 		{
1939:tasks.c       **** 			/* The current task must be in a ready list, so there is no need to
1940:tasks.c       **** 			check, and the port reset macro can be called directly. */
1941:tasks.c       **** 			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
1942:tasks.c       **** 		}
1943:tasks.c       **** 
1944:tasks.c       **** 		/* Calculate the time at which the task should be woken if the event does
1945:tasks.c       **** 		not occur.  This may overflow but this doesn't matter. */
1946:tasks.c       **** 		xTimeToWake = xTickCount + xTicksToWait;
1947:tasks.c       **** 
1948:tasks.c       **** 		traceTASK_DELAY_UNTIL();
1949:tasks.c       **** 		prvAddCurrentTaskToDelayedList( xTimeToWake );
1950:tasks.c       **** 	}
1951:tasks.c       **** 
1952:tasks.c       **** #endif /* configUSE_TIMERS */
1953:tasks.c       **** /*-----------------------------------------------------------*/
1954:tasks.c       **** 
1955:tasks.c       **** signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
1956:tasks.c       **** {
 2396               	.LM224:
 2397               	.LFBB18:
 2398 0b3c CF93      		push r28
 2399 0b3e DF93      		push r29
 2400 0b40 00D0      		rcall .
 2401 0b42 1F92      		push __zero_reg__
 2402 0b44 1F92      		push __zero_reg__
 2403 0b46 CDB7      		in r28,__SP_L__
 2404 0b48 DEB7      		in r29,__SP_H__
 2405               	/* prologue: function */
 2406               	/* frame size = 5 */
 2407               	/* stack size = 7 */
 2408               	.L__stack_usage = 7
 2409 0b4a 9D83      		std Y+5,r25
 2410 0b4c 8C83      		std Y+4,r24
1957:tasks.c       **** tskTCB *pxUnblockedTCB;
1958:tasks.c       **** portBASE_TYPE xReturn;
1959:tasks.c       **** 
1960:tasks.c       **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1961:tasks.c       **** 	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
1962:tasks.c       **** 
1963:tasks.c       **** 	/* The event list is sorted in priority order, so we can remove the
1964:tasks.c       **** 	first in the list, remove the TCB from the delayed list, and add
1965:tasks.c       **** 	it to the ready list.
1966:tasks.c       **** 
1967:tasks.c       **** 	If an event is for a queue that is locked then this function will never
1968:tasks.c       **** 	get called - the lock count on the queue will get modified instead.  This
1969:tasks.c       **** 	means we can always expect exclusive access to the event list here.
1970:tasks.c       **** 
1971:tasks.c       **** 	This function assumes that a check has already been made to ensure that
1972:tasks.c       **** 	pxEventList is not empty. */
1973:tasks.c       **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 2412               	.LM225:
 2413 0b4e 8C81      		ldd r24,Y+4
 2414 0b50 9D81      		ldd r25,Y+5
 2415 0b52 FC01      		movw r30,r24
 2416 0b54 8581      		ldd r24,Z+5
 2417 0b56 9681      		ldd r25,Z+6
 2418 0b58 FC01      		movw r30,r24
 2419 0b5a 8681      		ldd r24,Z+6
 2420 0b5c 9781      		ldd r25,Z+7
 2421 0b5e 9B83      		std Y+3,r25
 2422 0b60 8A83      		std Y+2,r24
1974:tasks.c       **** 	configASSERT( pxUnblockedTCB );
1975:tasks.c       **** 	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 2424               	.LM226:
 2425 0b62 8A81      		ldd r24,Y+2
 2426 0b64 9B81      		ldd r25,Y+3
 2427 0b66 0C96      		adiw r24,12
 2428 0b68 0E94 0000 		call uxListRemove
1976:tasks.c       **** 
1977:tasks.c       **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 2430               	.LM227:
 2431 0b6c 8091 0000 		lds r24,uxSchedulerSuspended
 2432 0b70 8823      		tst r24
 2433 0b72 01F4      		brne .L85
1978:tasks.c       **** 	{
1979:tasks.c       **** 		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 2435               	.LM228:
 2436 0b74 8A81      		ldd r24,Y+2
 2437 0b76 9B81      		ldd r25,Y+3
 2438 0b78 0296      		adiw r24,2
 2439 0b7a 0E94 0000 		call uxListRemove
1980:tasks.c       **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
 2441               	.LM229:
 2442 0b7e 8A81      		ldd r24,Y+2
 2443 0b80 9B81      		ldd r25,Y+3
 2444 0b82 FC01      		movw r30,r24
 2445 0b84 9689      		ldd r25,Z+22
 2446 0b86 8091 0000 		lds r24,uxTopReadyPriority
 2447 0b8a 8917      		cp r24,r25
 2448 0b8c 00F4      		brsh .L86
 2450               	.LM230:
 2451 0b8e 8A81      		ldd r24,Y+2
 2452 0b90 9B81      		ldd r25,Y+3
 2453 0b92 FC01      		movw r30,r24
 2454 0b94 8689      		ldd r24,Z+22
 2455 0b96 8093 0000 		sts uxTopReadyPriority,r24
 2456               	.L86:
 2458               	.LM231:
 2459 0b9a 8A81      		ldd r24,Y+2
 2460 0b9c 9B81      		ldd r25,Y+3
 2461 0b9e AC01      		movw r20,r24
 2462 0ba0 4E5F      		subi r20,-2
 2463 0ba2 5F4F      		sbci r21,-1
 2464 0ba4 8A81      		ldd r24,Y+2
 2465 0ba6 9B81      		ldd r25,Y+3
 2466 0ba8 FC01      		movw r30,r24
 2467 0baa 8689      		ldd r24,Z+22
 2468 0bac 282F      		mov r18,r24
 2469 0bae 30E0      		ldi r19,0
 2470 0bb0 C901      		movw r24,r18
 2471 0bb2 880F      		lsl r24
 2472 0bb4 991F      		rol r25
 2473 0bb6 880F      		lsl r24
 2474 0bb8 991F      		rol r25
 2475 0bba 880F      		lsl r24
 2476 0bbc 991F      		rol r25
 2477 0bbe 820F      		add r24,r18
 2478 0bc0 931F      		adc r25,r19
 2479 0bc2 8050      		subi r24,lo8(-(pxReadyTasksLists))
 2480 0bc4 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 2481 0bc6 BA01      		movw r22,r20
 2482 0bc8 0E94 0000 		call vListInsertEnd
 2483 0bcc 00C0      		rjmp .L87
 2484               	.L85:
1981:tasks.c       **** 	}
1982:tasks.c       **** 	else
1983:tasks.c       **** 	{
1984:tasks.c       **** 		/* We cannot access the delayed or ready lists, so will hold this
1985:tasks.c       **** 		task pending until the scheduler is resumed. */
1986:tasks.c       **** 		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 2486               	.LM232:
 2487 0bce 8A81      		ldd r24,Y+2
 2488 0bd0 9B81      		ldd r25,Y+3
 2489 0bd2 0C96      		adiw r24,12
 2490 0bd4 BC01      		movw r22,r24
 2491 0bd6 80E0      		ldi r24,lo8(xPendingReadyList)
 2492 0bd8 90E0      		ldi r25,hi8(xPendingReadyList)
 2493 0bda 0E94 0000 		call vListInsertEnd
 2494               	.L87:
1987:tasks.c       **** 	}
1988:tasks.c       **** 
1989:tasks.c       **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2496               	.LM233:
 2497 0bde 8A81      		ldd r24,Y+2
 2498 0be0 9B81      		ldd r25,Y+3
 2499 0be2 FC01      		movw r30,r24
 2500 0be4 2689      		ldd r18,Z+22
 2501 0be6 8091 0000 		lds r24,pxCurrentTCB
 2502 0bea 9091 0000 		lds r25,pxCurrentTCB+1
 2503 0bee FC01      		movw r30,r24
 2504 0bf0 8689      		ldd r24,Z+22
 2505 0bf2 2817      		cp r18,r24
 2506 0bf4 00F0      		brlo .L88
1990:tasks.c       **** 	{
1991:tasks.c       **** 		/* Return true if the task removed from the event list has
1992:tasks.c       **** 		a higher priority than the calling task.  This allows
1993:tasks.c       **** 		the calling task to know if it should force a context
1994:tasks.c       **** 		switch now. */
1995:tasks.c       **** 		xReturn = pdTRUE;
 2508               	.LM234:
 2509 0bf6 81E0      		ldi r24,lo8(1)
 2510 0bf8 8983      		std Y+1,r24
 2511 0bfa 00C0      		rjmp .L89
 2512               	.L88:
1996:tasks.c       **** 	}
1997:tasks.c       **** 	else
1998:tasks.c       **** 	{
1999:tasks.c       **** 		xReturn = pdFALSE;
 2514               	.LM235:
 2515 0bfc 1982      		std Y+1,__zero_reg__
 2516               	.L89:
2000:tasks.c       **** 	}
2001:tasks.c       **** 
2002:tasks.c       **** 	return xReturn;
 2518               	.LM236:
 2519 0bfe 8981      		ldd r24,Y+1
 2520               	/* epilogue start */
2003:tasks.c       **** }
 2522               	.LM237:
 2523 0c00 0F90      		pop __tmp_reg__
 2524 0c02 0F90      		pop __tmp_reg__
 2525 0c04 0F90      		pop __tmp_reg__
 2526 0c06 0F90      		pop __tmp_reg__
 2527 0c08 0F90      		pop __tmp_reg__
 2528 0c0a DF91      		pop r29
 2529 0c0c CF91      		pop r28
 2530 0c0e 0895      		ret
 2536               	.Lscope18:
 2538               		.stabd	78,0,0
 2541               	.global	vTaskSetTimeOutState
 2543               	vTaskSetTimeOutState:
 2544               		.stabd	46,0,0
2004:tasks.c       **** /*-----------------------------------------------------------*/
2005:tasks.c       **** 
2006:tasks.c       **** void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
2007:tasks.c       **** {
 2546               	.LM238:
 2547               	.LFBB19:
 2548 0c10 CF93      		push r28
 2549 0c12 DF93      		push r29
 2550 0c14 1F92      		push __zero_reg__
 2551 0c16 1F92      		push __zero_reg__
 2552 0c18 CDB7      		in r28,__SP_L__
 2553 0c1a DEB7      		in r29,__SP_H__
 2554               	/* prologue: function */
 2555               	/* frame size = 2 */
 2556               	/* stack size = 4 */
 2557               	.L__stack_usage = 4
 2558 0c1c 9A83      		std Y+2,r25
 2559 0c1e 8983      		std Y+1,r24
2008:tasks.c       **** 	configASSERT( pxTimeOut );
2009:tasks.c       **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 2561               	.LM239:
 2562 0c20 2091 0000 		lds r18,xNumOfOverflows
 2563 0c24 8981      		ldd r24,Y+1
 2564 0c26 9A81      		ldd r25,Y+2
 2565 0c28 FC01      		movw r30,r24
 2566 0c2a 2083      		st Z,r18
2010:tasks.c       **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 2568               	.LM240:
 2569 0c2c 2091 0000 		lds r18,xTickCount
 2570 0c30 3091 0000 		lds r19,xTickCount+1
 2571 0c34 8981      		ldd r24,Y+1
 2572 0c36 9A81      		ldd r25,Y+2
 2573 0c38 FC01      		movw r30,r24
 2574 0c3a 3283      		std Z+2,r19
 2575 0c3c 2183      		std Z+1,r18
 2576               	/* epilogue start */
2011:tasks.c       **** }
 2578               	.LM241:
 2579 0c3e 0F90      		pop __tmp_reg__
 2580 0c40 0F90      		pop __tmp_reg__
 2581 0c42 DF91      		pop r29
 2582 0c44 CF91      		pop r28
 2583 0c46 0895      		ret
 2585               	.Lscope19:
 2587               		.stabd	78,0,0
 2591               	.global	xTaskCheckForTimeOut
 2593               	xTaskCheckForTimeOut:
 2594               		.stabd	46,0,0
2012:tasks.c       **** /*-----------------------------------------------------------*/
2013:tasks.c       **** 
2014:tasks.c       **** portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToW
2015:tasks.c       **** {
 2596               	.LM242:
 2597               	.LFBB20:
 2598 0c48 CF93      		push r28
 2599 0c4a DF93      		push r29
 2600 0c4c 00D0      		rcall .
 2601 0c4e 1F92      		push __zero_reg__
 2602 0c50 1F92      		push __zero_reg__
 2603 0c52 CDB7      		in r28,__SP_L__
 2604 0c54 DEB7      		in r29,__SP_H__
 2605               	/* prologue: function */
 2606               	/* frame size = 5 */
 2607               	/* stack size = 7 */
 2608               	.L__stack_usage = 7
 2609 0c56 9B83      		std Y+3,r25
 2610 0c58 8A83      		std Y+2,r24
 2611 0c5a 7D83      		std Y+5,r23
 2612 0c5c 6C83      		std Y+4,r22
2016:tasks.c       **** portBASE_TYPE xReturn;
2017:tasks.c       **** 
2018:tasks.c       **** 	configASSERT( pxTimeOut );
2019:tasks.c       **** 	configASSERT( pxTicksToWait );
2020:tasks.c       **** 
2021:tasks.c       **** 	taskENTER_CRITICAL();
 2614               	.LM243:
 2615               	/* #APP */
 2616               	 ;  2021 "tasks.c" 1
 2617 0c5e 0FB6      		in		__tmp_reg__, __SREG__
 2618               	 ;  0 "" 2
 2619               	 ;  2021 "tasks.c" 1
 2620 0c60 F894      		cli
 2621               	 ;  0 "" 2
 2622               	 ;  2021 "tasks.c" 1
 2623 0c62 0F92      		push	__tmp_reg__
 2624               	 ;  0 "" 2
2022:tasks.c       **** 	{
2023:tasks.c       **** 		#if ( INCLUDE_vTaskSuspend == 1 )
2024:tasks.c       **** 			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
2025:tasks.c       **** 			the maximum block time then the task should block indefinitely, and
2026:tasks.c       **** 			therefore never time out. */
2027:tasks.c       **** 			if( *pxTicksToWait == portMAX_DELAY )
 2626               	.LM244:
 2627               	/* #NOAPP */
 2628 0c64 8C81      		ldd r24,Y+4
 2629 0c66 9D81      		ldd r25,Y+5
 2630 0c68 FC01      		movw r30,r24
 2631 0c6a 8081      		ld r24,Z
 2632 0c6c 9181      		ldd r25,Z+1
 2633 0c6e 8F3F      		cpi r24,-1
 2634 0c70 FFEF      		ldi r31,-1
 2635 0c72 9F07      		cpc r25,r31
 2636 0c74 01F4      		brne .L93
2028:tasks.c       **** 			{
2029:tasks.c       **** 				xReturn = pdFALSE;
 2638               	.LM245:
 2639 0c76 1982      		std Y+1,__zero_reg__
 2640 0c78 00C0      		rjmp .L94
 2641               	.L93:
2030:tasks.c       **** 			}
2031:tasks.c       **** 			else /* We are not blocking indefinitely, perform the checks below. */
2032:tasks.c       **** 		#endif
2033:tasks.c       **** 
2034:tasks.c       **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
 2643               	.LM246:
 2644 0c7a 8A81      		ldd r24,Y+2
 2645 0c7c 9B81      		ldd r25,Y+3
 2646 0c7e FC01      		movw r30,r24
 2647 0c80 9081      		ld r25,Z
 2648 0c82 8091 0000 		lds r24,xNumOfOverflows
 2649 0c86 9817      		cp r25,r24
 2650 0c88 01F0      		breq .L95
 2652               	.LM247:
 2653 0c8a 8A81      		ldd r24,Y+2
 2654 0c8c 9B81      		ldd r25,Y+3
 2655 0c8e FC01      		movw r30,r24
 2656 0c90 2181      		ldd r18,Z+1
 2657 0c92 3281      		ldd r19,Z+2
 2658 0c94 8091 0000 		lds r24,xTickCount
 2659 0c98 9091 0000 		lds r25,xTickCount+1
 2660 0c9c 8217      		cp r24,r18
 2661 0c9e 9307      		cpc r25,r19
 2662 0ca0 00F0      		brlo .L95
2035:tasks.c       **** 		{
2036:tasks.c       **** 			/* The tick count is greater than the time at which vTaskSetTimeout()
2037:tasks.c       **** 			was called, but has also overflowed since vTaskSetTimeOut() was called.
2038:tasks.c       **** 			It must have wrapped all the way around and gone past us again. This
2039:tasks.c       **** 			passed since vTaskSetTimeout() was called. */
2040:tasks.c       **** 			xReturn = pdTRUE;
 2664               	.LM248:
 2665 0ca2 81E0      		ldi r24,lo8(1)
 2666 0ca4 8983      		std Y+1,r24
 2667 0ca6 00C0      		rjmp .L94
 2668               	.L95:
2041:tasks.c       **** 		}
2042:tasks.c       **** 		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEn
 2670               	.LM249:
 2671 0ca8 2091 0000 		lds r18,xTickCount
 2672 0cac 3091 0000 		lds r19,xTickCount+1
 2673 0cb0 8A81      		ldd r24,Y+2
 2674 0cb2 9B81      		ldd r25,Y+3
 2675 0cb4 FC01      		movw r30,r24
 2676 0cb6 8181      		ldd r24,Z+1
 2677 0cb8 9281      		ldd r25,Z+2
 2678 0cba 281B      		sub r18,r24
 2679 0cbc 390B      		sbc r19,r25
 2680 0cbe 8C81      		ldd r24,Y+4
 2681 0cc0 9D81      		ldd r25,Y+5
 2682 0cc2 FC01      		movw r30,r24
 2683 0cc4 8081      		ld r24,Z
 2684 0cc6 9181      		ldd r25,Z+1
 2685 0cc8 2817      		cp r18,r24
 2686 0cca 3907      		cpc r19,r25
 2687 0ccc 00F4      		brsh .L96
2043:tasks.c       **** 		{
2044:tasks.c       **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
2045:tasks.c       **** 			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
 2689               	.LM250:
 2690 0cce 8C81      		ldd r24,Y+4
 2691 0cd0 9D81      		ldd r25,Y+5
 2692 0cd2 FC01      		movw r30,r24
 2693 0cd4 2081      		ld r18,Z
 2694 0cd6 3181      		ldd r19,Z+1
 2695 0cd8 8A81      		ldd r24,Y+2
 2696 0cda 9B81      		ldd r25,Y+3
 2697 0cdc FC01      		movw r30,r24
 2698 0cde 4181      		ldd r20,Z+1
 2699 0ce0 5281      		ldd r21,Z+2
 2700 0ce2 8091 0000 		lds r24,xTickCount
 2701 0ce6 9091 0000 		lds r25,xTickCount+1
 2702 0cea BA01      		movw r22,r20
 2703 0cec 681B      		sub r22,r24
 2704 0cee 790B      		sbc r23,r25
 2705 0cf0 CB01      		movw r24,r22
 2706 0cf2 280F      		add r18,r24
 2707 0cf4 391F      		adc r19,r25
 2708 0cf6 8C81      		ldd r24,Y+4
 2709 0cf8 9D81      		ldd r25,Y+5
 2710 0cfa FC01      		movw r30,r24
 2711 0cfc 3183      		std Z+1,r19
 2712 0cfe 2083      		st Z,r18
2046:tasks.c       **** 			vTaskSetTimeOutState( pxTimeOut );
 2714               	.LM251:
 2715 0d00 8A81      		ldd r24,Y+2
 2716 0d02 9B81      		ldd r25,Y+3
 2717 0d04 0E94 0000 		call vTaskSetTimeOutState
2047:tasks.c       **** 			xReturn = pdFALSE;
 2719               	.LM252:
 2720 0d08 1982      		std Y+1,__zero_reg__
 2721 0d0a 00C0      		rjmp .L94
 2722               	.L96:
2048:tasks.c       **** 		}
2049:tasks.c       **** 		else
2050:tasks.c       **** 		{
2051:tasks.c       **** 			xReturn = pdTRUE;
 2724               	.LM253:
 2725 0d0c 81E0      		ldi r24,lo8(1)
 2726 0d0e 8983      		std Y+1,r24
 2727               	.L94:
2052:tasks.c       **** 		}
2053:tasks.c       **** 	}
2054:tasks.c       **** 	taskEXIT_CRITICAL();
 2729               	.LM254:
 2730               	/* #APP */
 2731               	 ;  2054 "tasks.c" 1
 2732 0d10 0F90      		pop		__tmp_reg__
 2733               	 ;  0 "" 2
 2734               	 ;  2054 "tasks.c" 1
 2735 0d12 0FBE      		out		__SREG__, __tmp_reg__
 2736               	 ;  0 "" 2
2055:tasks.c       **** 
2056:tasks.c       **** 	return xReturn;
 2738               	.LM255:
 2739               	/* #NOAPP */
 2740 0d14 8981      		ldd r24,Y+1
 2741               	/* epilogue start */
2057:tasks.c       **** }
 2743               	.LM256:
 2744 0d16 0F90      		pop __tmp_reg__
 2745 0d18 0F90      		pop __tmp_reg__
 2746 0d1a 0F90      		pop __tmp_reg__
 2747 0d1c 0F90      		pop __tmp_reg__
 2748 0d1e 0F90      		pop __tmp_reg__
 2749 0d20 DF91      		pop r29
 2750 0d22 CF91      		pop r28
 2751 0d24 0895      		ret
 2756               	.Lscope20:
 2758               		.stabd	78,0,0
 2760               	.global	vTaskMissedYield
 2762               	vTaskMissedYield:
 2763               		.stabd	46,0,0
2058:tasks.c       **** /*-----------------------------------------------------------*/
2059:tasks.c       **** 
2060:tasks.c       **** void vTaskMissedYield( void )
2061:tasks.c       **** {
 2765               	.LM257:
 2766               	.LFBB21:
 2767 0d26 CF93      		push r28
 2768 0d28 DF93      		push r29
 2769 0d2a CDB7      		in r28,__SP_L__
 2770 0d2c DEB7      		in r29,__SP_H__
 2771               	/* prologue: function */
 2772               	/* frame size = 0 */
 2773               	/* stack size = 2 */
 2774               	.L__stack_usage = 2
2062:tasks.c       **** 	xMissedYield = pdTRUE;
 2776               	.LM258:
 2777 0d2e 81E0      		ldi r24,lo8(1)
 2778 0d30 8093 0000 		sts xMissedYield,r24
 2779               	/* epilogue start */
2063:tasks.c       **** }
 2781               	.LM259:
 2782 0d34 DF91      		pop r29
 2783 0d36 CF91      		pop r28
 2784 0d38 0895      		ret
 2786               	.Lscope21:
 2788               		.stabd	78,0,0
 2792               	prvIdleTask:
 2793               		.stabd	46,0,0
2064:tasks.c       **** /*-----------------------------------------------------------*/
2065:tasks.c       **** 
2066:tasks.c       **** #if ( configUSE_TRACE_FACILITY == 1 )
2067:tasks.c       **** 	unsigned portBASE_TYPE uxTaskGetTaskNumber( xTaskHandle xTask )
2068:tasks.c       **** 	{
2069:tasks.c       **** 	unsigned portBASE_TYPE uxReturn;
2070:tasks.c       **** 	tskTCB *pxTCB;
2071:tasks.c       **** 
2072:tasks.c       **** 		if( xTask != NULL )
2073:tasks.c       **** 		{
2074:tasks.c       **** 			pxTCB = ( tskTCB * ) xTask;
2075:tasks.c       **** 			uxReturn = pxTCB->uxTaskNumber;
2076:tasks.c       **** 		}
2077:tasks.c       **** 		else
2078:tasks.c       **** 		{
2079:tasks.c       **** 			uxReturn = 0U;
2080:tasks.c       **** 		}
2081:tasks.c       **** 
2082:tasks.c       **** 		return uxReturn;
2083:tasks.c       **** 	}
2084:tasks.c       **** #endif
2085:tasks.c       **** /*-----------------------------------------------------------*/
2086:tasks.c       **** 
2087:tasks.c       **** #if ( configUSE_TRACE_FACILITY == 1 )
2088:tasks.c       **** 	void vTaskSetTaskNumber( xTaskHandle xTask, unsigned portBASE_TYPE uxHandle )
2089:tasks.c       **** 	{
2090:tasks.c       **** 	tskTCB *pxTCB;
2091:tasks.c       **** 
2092:tasks.c       **** 		if( xTask != NULL )
2093:tasks.c       **** 		{
2094:tasks.c       **** 			pxTCB = ( tskTCB * ) xTask;
2095:tasks.c       **** 			pxTCB->uxTaskNumber = uxHandle;
2096:tasks.c       **** 		}
2097:tasks.c       **** 	}
2098:tasks.c       **** #endif
2099:tasks.c       **** 
2100:tasks.c       **** 
2101:tasks.c       **** /*
2102:tasks.c       ****  * -----------------------------------------------------------
2103:tasks.c       ****  * The Idle task.
2104:tasks.c       ****  * ----------------------------------------------------------
2105:tasks.c       ****  *
2106:tasks.c       ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
2107:tasks.c       ****  * language extensions.  The equivalent prototype for this function is:
2108:tasks.c       ****  *
2109:tasks.c       ****  * void prvIdleTask( void *pvParameters );
2110:tasks.c       ****  *
2111:tasks.c       ****  */
2112:tasks.c       **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
2113:tasks.c       **** {
 2795               	.LM260:
 2796               	.LFBB22:
 2797 0d3a CF93      		push r28
 2798 0d3c DF93      		push r29
 2799 0d3e 1F92      		push __zero_reg__
 2800 0d40 1F92      		push __zero_reg__
 2801 0d42 CDB7      		in r28,__SP_L__
 2802 0d44 DEB7      		in r29,__SP_H__
 2803               	/* prologue: function */
 2804               	/* frame size = 2 */
 2805               	/* stack size = 4 */
 2806               	.L__stack_usage = 4
 2807 0d46 9A83      		std Y+2,r25
 2808 0d48 8983      		std Y+1,r24
 2809               	.L101:
2114:tasks.c       **** 	/* Stop warnings. */
2115:tasks.c       **** 	( void ) pvParameters;
2116:tasks.c       **** 
2117:tasks.c       **** 	for( ;; )
2118:tasks.c       **** 	{
2119:tasks.c       **** 		/* See if any tasks have been deleted. */
2120:tasks.c       **** 		prvCheckTasksWaitingTermination();
 2811               	.LM261:
 2812 0d4a 0E94 0000 		call prvCheckTasksWaitingTermination
2121:tasks.c       **** 
2122:tasks.c       **** 		#if ( configUSE_PREEMPTION == 0 )
2123:tasks.c       **** 		{
2124:tasks.c       **** 			/* If we are not using preemption we keep forcing a task switch to
2125:tasks.c       **** 			see if any other task has become available.  If we are using
2126:tasks.c       **** 			preemption we don't need to do this as any task becoming available
2127:tasks.c       **** 			will automatically get the processor anyway. */
2128:tasks.c       **** 			taskYIELD();
2129:tasks.c       **** 		}
2130:tasks.c       **** 		#endif
2131:tasks.c       **** 
2132:tasks.c       **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
2133:tasks.c       **** 		{
2134:tasks.c       **** 			/* When using preemption tasks of equal priority will be
2135:tasks.c       **** 			timesliced.  If a task that is sharing the idle priority is ready
2136:tasks.c       **** 			to run then the idle task should yield before the end of the
2137:tasks.c       **** 			timeslice.
2138:tasks.c       **** 
2139:tasks.c       **** 			A critical region is not required here as we are just reading from
2140:tasks.c       **** 			the list, and an occasional incorrect value will not matter.  If
2141:tasks.c       **** 			the ready list at the idle priority contains more than one task
2142:tasks.c       **** 			then a task other than the idle task is ready to execute. */
2143:tasks.c       **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_
 2814               	.LM262:
 2815 0d4e 8091 0000 		lds r24,pxReadyTasksLists
 2816 0d52 8230      		cpi r24,lo8(2)
 2817 0d54 00F0      		brlo .L100
2144:tasks.c       **** 			{
2145:tasks.c       **** 				taskYIELD();
 2819               	.LM263:
 2820 0d56 0E94 0000 		call vPortYield
2146:tasks.c       **** 			}
2147:tasks.c       **** 		}
2148:tasks.c       **** 		#endif
2149:tasks.c       **** 
2150:tasks.c       **** 		#if ( configUSE_IDLE_HOOK == 1 )
2151:tasks.c       **** 		{
2152:tasks.c       **** 			extern void vApplicationIdleHook( void );
2153:tasks.c       **** 
2154:tasks.c       **** 			/* Call the user defined function from within the idle task.  This
2155:tasks.c       **** 			allows the application designer to add background functionality
2156:tasks.c       **** 			without the overhead of a separate task.
2157:tasks.c       **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
2158:tasks.c       **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
2159:tasks.c       **** 			vApplicationIdleHook();
2160:tasks.c       **** 		}
2161:tasks.c       **** 		#endif
2162:tasks.c       **** 
2163:tasks.c       **** 		/* This conditional compilation should use inequality to 0, not equality
2164:tasks.c       **** 		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
2165:tasks.c       **** 		user defined low power mode	implementations require
2166:tasks.c       **** 		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
2167:tasks.c       **** 		#if ( configUSE_TICKLESS_IDLE != 0 )
2168:tasks.c       **** 		{
2169:tasks.c       **** 		portTickType xExpectedIdleTime;
2170:tasks.c       **** 		/* If the expected idle time is 1 then the idle time would end at
2171:tasks.c       **** 		the end of the current time slice.  The idle time must be at least
2172:tasks.c       **** 		2 to ensure any pended ticks between this point and the tick being
2173:tasks.c       **** 		stopped can be legitimately stepped over when the tick suppression
2174:tasks.c       **** 		routines returns. */
2175:tasks.c       **** 		const portTickType xMinimumExpectedIdleTime = ( portTickType ) 2;
2176:tasks.c       **** 
2177:tasks.c       **** 			/* It is not desirable to suspend then resume the scheduler on
2178:tasks.c       **** 			each iteration of the idle task.  Therefore, a preliminary
2179:tasks.c       **** 			test of the expected idle time is performed without the
2180:tasks.c       **** 			scheduler suspended.  The result here is not necessarily
2181:tasks.c       **** 			valid. */
2182:tasks.c       **** 			xExpectedIdleTime = prvGetExpectedIdleTime();
2183:tasks.c       **** 
2184:tasks.c       **** 			if( xExpectedIdleTime >= xMinimumExpectedIdleTime )
2185:tasks.c       **** 			{
2186:tasks.c       **** 				vTaskSuspendAll();
2187:tasks.c       **** 				{
2188:tasks.c       **** 					/* Now the scheduler is suspended, the expected idle
2189:tasks.c       **** 					time can be sampled again, and this time its value can
2190:tasks.c       **** 					be used. */
2191:tasks.c       **** 					configASSERT( xNextTaskUnblockTime >= xTickCount );
2192:tasks.c       **** 					xExpectedIdleTime = prvGetExpectedIdleTime();
2193:tasks.c       **** 
2194:tasks.c       **** 					if( xExpectedIdleTime >= xMinimumExpectedIdleTime )
2195:tasks.c       **** 					{
2196:tasks.c       **** 						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
2197:tasks.c       **** 					}
2198:tasks.c       **** 				}
2199:tasks.c       **** 				xTaskResumeAll();
2200:tasks.c       **** 			}
2201:tasks.c       **** 		}
2202:tasks.c       **** 		#endif
2203:tasks.c       **** 	}
 2822               	.LM264:
 2823 0d5a 00C0      		rjmp .L101
 2824               	.L100:
 2825 0d5c 00C0      		rjmp .L101
 2827               	.Lscope22:
 2829               		.stabd	78,0,0
 2837               	prvInitialiseTCBVariables:
 2838               		.stabd	46,0,0
2204:tasks.c       **** } /*lint !e715 pvParameters is not accessed but all task functions require the same prototype. */
2205:tasks.c       **** 
2206:tasks.c       **** 
2207:tasks.c       **** 
2208:tasks.c       **** 
2209:tasks.c       **** 
2210:tasks.c       **** 
2211:tasks.c       **** 
2212:tasks.c       **** /*-----------------------------------------------------------
2213:tasks.c       ****  * File private functions documented at the top of the file.
2214:tasks.c       ****  *----------------------------------------------------------*/
2215:tasks.c       **** 
2216:tasks.c       **** 
2217:tasks.c       **** 
2218:tasks.c       **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
2219:tasks.c       **** {
 2840               	.LM265:
 2841               	.LFBB23:
 2842 0d5e 0F93      		push r16
 2843 0d60 1F93      		push r17
 2844 0d62 CF93      		push r28
 2845 0d64 DF93      		push r29
 2846 0d66 CDB7      		in r28,__SP_L__
 2847 0d68 DEB7      		in r29,__SP_H__
 2848 0d6a 2997      		sbiw r28,9
 2849 0d6c 0FB6      		in __tmp_reg__,__SREG__
 2850 0d6e F894      		cli
 2851 0d70 DEBF      		out __SP_H__,r29
 2852 0d72 0FBE      		out __SREG__,__tmp_reg__
 2853 0d74 CDBF      		out __SP_L__,r28
 2854               	/* prologue: function */
 2855               	/* frame size = 9 */
 2856               	/* stack size = 13 */
 2857               	.L__stack_usage = 13
 2858 0d76 9A83      		std Y+2,r25
 2859 0d78 8983      		std Y+1,r24
 2860 0d7a 7C83      		std Y+4,r23
 2861 0d7c 6B83      		std Y+3,r22
 2862 0d7e 4D83      		std Y+5,r20
 2863 0d80 3F83      		std Y+7,r19
 2864 0d82 2E83      		std Y+6,r18
 2865 0d84 1987      		std Y+9,r17
 2866 0d86 0887      		std Y+8,r16
2220:tasks.c       **** 	/* Store the function name in the TCB. */
2221:tasks.c       **** 	#if configMAX_TASK_NAME_LEN > 1
2222:tasks.c       **** 	{
2223:tasks.c       **** 		/* Don't bring strncpy into the build unnecessarily. */
2224:tasks.c       **** 		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK
 2868               	.LM266:
 2869 0d88 8981      		ldd r24,Y+1
 2870 0d8a 9A81      		ldd r25,Y+2
 2871 0d8c 4996      		adiw r24,25
 2872 0d8e 2B81      		ldd r18,Y+3
 2873 0d90 3C81      		ldd r19,Y+4
 2874 0d92 40E1      		ldi r20,lo8(16)
 2875 0d94 50E0      		ldi r21,0
 2876 0d96 B901      		movw r22,r18
 2877 0d98 0E94 0000 		call strncpy
2225:tasks.c       **** 	}
2226:tasks.c       **** 	#endif
2227:tasks.c       **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed 
 2879               	.LM267:
 2880 0d9c 8981      		ldd r24,Y+1
 2881 0d9e 9A81      		ldd r25,Y+2
 2882 0da0 FC01      		movw r30,r24
 2883 0da2 10A6      		std Z+40,__zero_reg__
2228:tasks.c       **** 
2229:tasks.c       **** 	/* This is used as an array index so must ensure it's not too large.  First
2230:tasks.c       **** 	remove the privilege bit if one is present. */
2231:tasks.c       **** 	if( uxPriority >= configMAX_PRIORITIES )
 2885               	.LM268:
 2886 0da4 8D81      		ldd r24,Y+5
 2887 0da6 8430      		cpi r24,lo8(4)
 2888 0da8 00F0      		brlo .L103
2232:tasks.c       **** 	{
2233:tasks.c       **** 		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 2890               	.LM269:
 2891 0daa 83E0      		ldi r24,lo8(3)
 2892 0dac 8D83      		std Y+5,r24
 2893               	.L103:
2234:tasks.c       **** 	}
2235:tasks.c       **** 
2236:tasks.c       **** 	pxTCB->uxPriority = uxPriority;
 2895               	.LM270:
 2896 0dae 8981      		ldd r24,Y+1
 2897 0db0 9A81      		ldd r25,Y+2
 2898 0db2 2D81      		ldd r18,Y+5
 2899 0db4 FC01      		movw r30,r24
 2900 0db6 268B      		std Z+22,r18
2237:tasks.c       **** 	#if ( configUSE_MUTEXES == 1 )
2238:tasks.c       **** 	{
2239:tasks.c       **** 		pxTCB->uxBasePriority = uxPriority;
 2902               	.LM271:
 2903 0db8 8981      		ldd r24,Y+1
 2904 0dba 9A81      		ldd r25,Y+2
 2905 0dbc 2D81      		ldd r18,Y+5
 2906 0dbe FC01      		movw r30,r24
 2907 0dc0 21A7      		std Z+41,r18
2240:tasks.c       **** 	}
2241:tasks.c       **** 	#endif
2242:tasks.c       **** 
2243:tasks.c       **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 2909               	.LM272:
 2910 0dc2 8981      		ldd r24,Y+1
 2911 0dc4 9A81      		ldd r25,Y+2
 2912 0dc6 0296      		adiw r24,2
 2913 0dc8 0E94 0000 		call vListInitialiseItem
2244:tasks.c       **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 2915               	.LM273:
 2916 0dcc 8981      		ldd r24,Y+1
 2917 0dce 9A81      		ldd r25,Y+2
 2918 0dd0 0C96      		adiw r24,12
 2919 0dd2 0E94 0000 		call vListInitialiseItem
2245:tasks.c       **** 
2246:tasks.c       **** 	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
2247:tasks.c       **** 	back to	the containing TCB from a generic item in a list. */
2248:tasks.c       **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 2921               	.LM274:
 2922 0dd6 8981      		ldd r24,Y+1
 2923 0dd8 9A81      		ldd r25,Y+2
 2924 0dda 2981      		ldd r18,Y+1
 2925 0ddc 3A81      		ldd r19,Y+2
 2926 0dde FC01      		movw r30,r24
 2927 0de0 3187      		std Z+9,r19
 2928 0de2 2087      		std Z+8,r18
2249:tasks.c       **** 
2250:tasks.c       **** 	/* Event lists are always in priority order. */
2251:tasks.c       **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPri
 2930               	.LM275:
 2931 0de4 8D81      		ldd r24,Y+5
 2932 0de6 882F      		mov r24,r24
 2933 0de8 90E0      		ldi r25,0
 2934 0dea 24E0      		ldi r18,lo8(4)
 2935 0dec 30E0      		ldi r19,0
 2936 0dee 281B      		sub r18,r24
 2937 0df0 390B      		sbc r19,r25
 2938 0df2 8981      		ldd r24,Y+1
 2939 0df4 9A81      		ldd r25,Y+2
 2940 0df6 FC01      		movw r30,r24
 2941 0df8 3587      		std Z+13,r19
 2942 0dfa 2487      		std Z+12,r18
2252:tasks.c       **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 2944               	.LM276:
 2945 0dfc 8981      		ldd r24,Y+1
 2946 0dfe 9A81      		ldd r25,Y+2
 2947 0e00 2981      		ldd r18,Y+1
 2948 0e02 3A81      		ldd r19,Y+2
 2949 0e04 FC01      		movw r30,r24
 2950 0e06 338B      		std Z+19,r19
 2951 0e08 228B      		std Z+18,r18
 2952               	/* epilogue start */
2253:tasks.c       **** 
2254:tasks.c       **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
2255:tasks.c       **** 	{
2256:tasks.c       **** 		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0U;
2257:tasks.c       **** 	}
2258:tasks.c       **** 	#endif
2259:tasks.c       **** 
2260:tasks.c       **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
2261:tasks.c       **** 	{
2262:tasks.c       **** 		pxTCB->pxTaskTag = NULL;
2263:tasks.c       **** 	}
2264:tasks.c       **** 	#endif
2265:tasks.c       **** 
2266:tasks.c       **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
2267:tasks.c       **** 	{
2268:tasks.c       **** 		pxTCB->ulRunTimeCounter = 0UL;
2269:tasks.c       **** 	}
2270:tasks.c       **** 	#endif
2271:tasks.c       **** 
2272:tasks.c       **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
2273:tasks.c       **** 	{
2274:tasks.c       **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
2275:tasks.c       **** 	}
2276:tasks.c       **** 	#else
2277:tasks.c       **** 	{
2278:tasks.c       **** 		( void ) xRegions;
2279:tasks.c       **** 		( void ) usStackDepth;
2280:tasks.c       **** 	}
2281:tasks.c       **** 	#endif
2282:tasks.c       **** }
 2954               	.LM277:
 2955 0e0a 2996      		adiw r28,9
 2956 0e0c 0FB6      		in __tmp_reg__,__SREG__
 2957 0e0e F894      		cli
 2958 0e10 DEBF      		out __SP_H__,r29
 2959 0e12 0FBE      		out __SREG__,__tmp_reg__
 2960 0e14 CDBF      		out __SP_L__,r28
 2961 0e16 DF91      		pop r29
 2962 0e18 CF91      		pop r28
 2963 0e1a 1F91      		pop r17
 2964 0e1c 0F91      		pop r16
 2965 0e1e 0895      		ret
 2967               	.Lscope23:
 2969               		.stabd	78,0,0
 2972               	prvInitialiseTaskLists:
 2973               		.stabd	46,0,0
2283:tasks.c       **** /*-----------------------------------------------------------*/
2284:tasks.c       **** 
2285:tasks.c       **** #if ( portUSING_MPU_WRAPPERS == 1 )
2286:tasks.c       **** 
2287:tasks.c       **** 	void vTaskAllocateMPURegions( xTaskHandle xTaskToModify, const xMemoryRegion * const xRegions )
2288:tasks.c       **** 	{
2289:tasks.c       **** 	tskTCB *pxTCB;
2290:tasks.c       **** 
2291:tasks.c       **** 		if( xTaskToModify == pxCurrentTCB )
2292:tasks.c       **** 		{
2293:tasks.c       **** 			xTaskToModify = NULL;
2294:tasks.c       **** 		}
2295:tasks.c       **** 
2296:tasks.c       **** 		/* If null is passed in here then we are deleting ourselves. */
2297:tasks.c       **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
2298:tasks.c       **** 
2299:tasks.c       ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
2300:tasks.c       **** 	}
2301:tasks.c       **** 	/*-----------------------------------------------------------*/
2302:tasks.c       **** #endif
2303:tasks.c       **** 
2304:tasks.c       **** static void prvInitialiseTaskLists( void )
2305:tasks.c       **** {
 2975               	.LM278:
 2976               	.LFBB24:
 2977 0e20 CF93      		push r28
 2978 0e22 DF93      		push r29
 2979 0e24 1F92      		push __zero_reg__
 2980 0e26 CDB7      		in r28,__SP_L__
 2981 0e28 DEB7      		in r29,__SP_H__
 2982               	/* prologue: function */
 2983               	/* frame size = 1 */
 2984               	/* stack size = 3 */
 2985               	.L__stack_usage = 3
2306:tasks.c       **** unsigned portBASE_TYPE uxPriority;
2307:tasks.c       **** 
2308:tasks.c       **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 2987               	.LM279:
 2988 0e2a 1982      		std Y+1,__zero_reg__
 2989 0e2c 00C0      		rjmp .L105
 2990               	.L106:
2309:tasks.c       **** 	{
2310:tasks.c       **** 		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 2992               	.LM280:
 2993 0e2e 8981      		ldd r24,Y+1
 2994 0e30 282F      		mov r18,r24
 2995 0e32 30E0      		ldi r19,0
 2996 0e34 C901      		movw r24,r18
 2997 0e36 880F      		lsl r24
 2998 0e38 991F      		rol r25
 2999 0e3a 880F      		lsl r24
 3000 0e3c 991F      		rol r25
 3001 0e3e 880F      		lsl r24
 3002 0e40 991F      		rol r25
 3003 0e42 820F      		add r24,r18
 3004 0e44 931F      		adc r25,r19
 3005 0e46 8050      		subi r24,lo8(-(pxReadyTasksLists))
 3006 0e48 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 3007 0e4a 0E94 0000 		call vListInitialise
2308:tasks.c       **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 3009               	.LM281:
 3010 0e4e 8981      		ldd r24,Y+1
 3011 0e50 8F5F      		subi r24,lo8(-(1))
 3012 0e52 8983      		std Y+1,r24
 3013               	.L105:
2308:tasks.c       **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 3015               	.LM282:
 3016 0e54 8981      		ldd r24,Y+1
 3017 0e56 8430      		cpi r24,lo8(4)
 3018 0e58 00F0      		brlo .L106
2311:tasks.c       **** 	}
2312:tasks.c       **** 
2313:tasks.c       **** 	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 3020               	.LM283:
 3021 0e5a 80E0      		ldi r24,lo8(xDelayedTaskList1)
 3022 0e5c 90E0      		ldi r25,hi8(xDelayedTaskList1)
 3023 0e5e 0E94 0000 		call vListInitialise
2314:tasks.c       **** 	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 3025               	.LM284:
 3026 0e62 80E0      		ldi r24,lo8(xDelayedTaskList2)
 3027 0e64 90E0      		ldi r25,hi8(xDelayedTaskList2)
 3028 0e66 0E94 0000 		call vListInitialise
2315:tasks.c       **** 	vListInitialise( ( xList * ) &xPendingReadyList );
 3030               	.LM285:
 3031 0e6a 80E0      		ldi r24,lo8(xPendingReadyList)
 3032 0e6c 90E0      		ldi r25,hi8(xPendingReadyList)
 3033 0e6e 0E94 0000 		call vListInitialise
2316:tasks.c       **** 
2317:tasks.c       **** 	#if ( INCLUDE_vTaskDelete == 1 )
2318:tasks.c       **** 	{
2319:tasks.c       **** 		vListInitialise( ( xList * ) &xTasksWaitingTermination );
2320:tasks.c       **** 	}
2321:tasks.c       **** 	#endif
2322:tasks.c       **** 
2323:tasks.c       **** 	#if ( INCLUDE_vTaskSuspend == 1 )
2324:tasks.c       **** 	{
2325:tasks.c       **** 		vListInitialise( ( xList * ) &xSuspendedTaskList );
 3035               	.LM286:
 3036 0e72 80E0      		ldi r24,lo8(xSuspendedTaskList)
 3037 0e74 90E0      		ldi r25,hi8(xSuspendedTaskList)
 3038 0e76 0E94 0000 		call vListInitialise
2326:tasks.c       **** 	}
2327:tasks.c       **** 	#endif
2328:tasks.c       **** 
2329:tasks.c       **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
2330:tasks.c       **** 	using list2. */
2331:tasks.c       **** 	pxDelayedTaskList = &xDelayedTaskList1;
 3040               	.LM287:
 3041 0e7a 80E0      		ldi r24,lo8(xDelayedTaskList1)
 3042 0e7c 90E0      		ldi r25,hi8(xDelayedTaskList1)
 3043 0e7e 9093 0000 		sts pxDelayedTaskList+1,r25
 3044 0e82 8093 0000 		sts pxDelayedTaskList,r24
2332:tasks.c       **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 3046               	.LM288:
 3047 0e86 80E0      		ldi r24,lo8(xDelayedTaskList2)
 3048 0e88 90E0      		ldi r25,hi8(xDelayedTaskList2)
 3049 0e8a 9093 0000 		sts pxOverflowDelayedTaskList+1,r25
 3050 0e8e 8093 0000 		sts pxOverflowDelayedTaskList,r24
 3051               	/* epilogue start */
2333:tasks.c       **** }
 3053               	.LM289:
 3054 0e92 0F90      		pop __tmp_reg__
 3055 0e94 DF91      		pop r29
 3056 0e96 CF91      		pop r28
 3057 0e98 0895      		ret
 3062               	.Lscope24:
 3064               		.stabd	78,0,0
 3067               	prvCheckTasksWaitingTermination:
 3068               		.stabd	46,0,0
2334:tasks.c       **** /*-----------------------------------------------------------*/
2335:tasks.c       **** 
2336:tasks.c       **** static void prvCheckTasksWaitingTermination( void )
2337:tasks.c       **** {
 3070               	.LM290:
 3071               	.LFBB25:
 3072 0e9a CF93      		push r28
 3073 0e9c DF93      		push r29
 3074 0e9e CDB7      		in r28,__SP_L__
 3075 0ea0 DEB7      		in r29,__SP_H__
 3076               	/* prologue: function */
 3077               	/* frame size = 0 */
 3078               	/* stack size = 2 */
 3079               	.L__stack_usage = 2
 3080               	/* epilogue start */
2338:tasks.c       **** 	#if ( INCLUDE_vTaskDelete == 1 )
2339:tasks.c       **** 	{
2340:tasks.c       **** 		portBASE_TYPE xListIsEmpty;
2341:tasks.c       **** 
2342:tasks.c       **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
2343:tasks.c       **** 		too often in the idle task. */
2344:tasks.c       **** 		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
2345:tasks.c       **** 		{
2346:tasks.c       **** 			vTaskSuspendAll();
2347:tasks.c       **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
2348:tasks.c       **** 			xTaskResumeAll();
2349:tasks.c       **** 
2350:tasks.c       **** 			if( xListIsEmpty == pdFALSE )
2351:tasks.c       **** 			{
2352:tasks.c       **** 				tskTCB *pxTCB;
2353:tasks.c       **** 
2354:tasks.c       **** 				taskENTER_CRITICAL();
2355:tasks.c       **** 				{
2356:tasks.c       **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
2357:tasks.c       **** 					uxListRemove( &( pxTCB->xGenericListItem ) );
2358:tasks.c       **** 					--uxCurrentNumberOfTasks;
2359:tasks.c       **** 					--uxTasksDeleted;
2360:tasks.c       **** 				}
2361:tasks.c       **** 				taskEXIT_CRITICAL();
2362:tasks.c       **** 
2363:tasks.c       **** 				prvDeleteTCB( pxTCB );
2364:tasks.c       **** 			}
2365:tasks.c       **** 		}
2366:tasks.c       **** 	}
2367:tasks.c       **** 	#endif
2368:tasks.c       **** }
 3082               	.LM291:
 3083 0ea2 DF91      		pop r29
 3084 0ea4 CF91      		pop r28
 3085 0ea6 0895      		ret
 3087               	.Lscope25:
 3089               		.stabd	78,0,0
 3093               	prvAddCurrentTaskToDelayedList:
 3094               		.stabd	46,0,0
2369:tasks.c       **** /*-----------------------------------------------------------*/
2370:tasks.c       **** 
2371:tasks.c       **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
2372:tasks.c       **** {
 3096               	.LM292:
 3097               	.LFBB26:
 3098 0ea8 CF93      		push r28
 3099 0eaa DF93      		push r29
 3100 0eac 1F92      		push __zero_reg__
 3101 0eae 1F92      		push __zero_reg__
 3102 0eb0 CDB7      		in r28,__SP_L__
 3103 0eb2 DEB7      		in r29,__SP_H__
 3104               	/* prologue: function */
 3105               	/* frame size = 2 */
 3106               	/* stack size = 4 */
 3107               	.L__stack_usage = 4
 3108 0eb4 9A83      		std Y+2,r25
 3109 0eb6 8983      		std Y+1,r24
2373:tasks.c       **** 	/* The list item will be inserted in wake time order. */
2374:tasks.c       **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 3111               	.LM293:
 3112 0eb8 8091 0000 		lds r24,pxCurrentTCB
 3113 0ebc 9091 0000 		lds r25,pxCurrentTCB+1
 3114 0ec0 2981      		ldd r18,Y+1
 3115 0ec2 3A81      		ldd r19,Y+2
 3116 0ec4 FC01      		movw r30,r24
 3117 0ec6 3383      		std Z+3,r19
 3118 0ec8 2283      		std Z+2,r18
2375:tasks.c       **** 
2376:tasks.c       **** 	if( xTimeToWake < xTickCount )
 3120               	.LM294:
 3121 0eca 8091 0000 		lds r24,xTickCount
 3122 0ece 9091 0000 		lds r25,xTickCount+1
 3123 0ed2 2981      		ldd r18,Y+1
 3124 0ed4 3A81      		ldd r19,Y+2
 3125 0ed6 2817      		cp r18,r24
 3126 0ed8 3907      		cpc r19,r25
 3127 0eda 00F4      		brsh .L109
2377:tasks.c       **** 	{
2378:tasks.c       **** 		/* Wake time has overflowed.  Place this item in the overflow list. */
2379:tasks.c       **** 		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericList
 3129               	.LM295:
 3130 0edc 8091 0000 		lds r24,pxCurrentTCB
 3131 0ee0 9091 0000 		lds r25,pxCurrentTCB+1
 3132 0ee4 9C01      		movw r18,r24
 3133 0ee6 2E5F      		subi r18,-2
 3134 0ee8 3F4F      		sbci r19,-1
 3135 0eea 8091 0000 		lds r24,pxOverflowDelayedTaskList
 3136 0eee 9091 0000 		lds r25,pxOverflowDelayedTaskList+1
 3137 0ef2 B901      		movw r22,r18
 3138 0ef4 0E94 0000 		call vListInsert
 3139 0ef8 00C0      		rjmp .L108
 3140               	.L109:
2380:tasks.c       **** 	}
2381:tasks.c       **** 	else
2382:tasks.c       **** 	{
2383:tasks.c       **** 		/* The wake time has not overflowed, so we can use the current block list. */
2384:tasks.c       **** 		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) )
 3142               	.LM296:
 3143 0efa 8091 0000 		lds r24,pxCurrentTCB
 3144 0efe 9091 0000 		lds r25,pxCurrentTCB+1
 3145 0f02 9C01      		movw r18,r24
 3146 0f04 2E5F      		subi r18,-2
 3147 0f06 3F4F      		sbci r19,-1
 3148 0f08 8091 0000 		lds r24,pxDelayedTaskList
 3149 0f0c 9091 0000 		lds r25,pxDelayedTaskList+1
 3150 0f10 B901      		movw r22,r18
 3151 0f12 0E94 0000 		call vListInsert
2385:tasks.c       **** 
2386:tasks.c       **** 		/* If the task entering the blocked state was placed at the head of the
2387:tasks.c       **** 		list of blocked tasks then xNextTaskUnblockTime needs to be updated
2388:tasks.c       **** 		too. */
2389:tasks.c       **** 		if( xTimeToWake < xNextTaskUnblockTime )
 3153               	.LM297:
 3154 0f16 8091 0000 		lds r24,xNextTaskUnblockTime
 3155 0f1a 9091 0000 		lds r25,xNextTaskUnblockTime+1
 3156 0f1e 2981      		ldd r18,Y+1
 3157 0f20 3A81      		ldd r19,Y+2
 3158 0f22 2817      		cp r18,r24
 3159 0f24 3907      		cpc r19,r25
 3160 0f26 00F4      		brsh .L108
2390:tasks.c       **** 		{
2391:tasks.c       **** 			xNextTaskUnblockTime = xTimeToWake;
 3162               	.LM298:
 3163 0f28 8981      		ldd r24,Y+1
 3164 0f2a 9A81      		ldd r25,Y+2
 3165 0f2c 9093 0000 		sts xNextTaskUnblockTime+1,r25
 3166 0f30 8093 0000 		sts xNextTaskUnblockTime,r24
 3167               	.L108:
 3168               	/* epilogue start */
2392:tasks.c       **** 		}
2393:tasks.c       **** 	}
2394:tasks.c       **** }
 3170               	.LM299:
 3171 0f34 0F90      		pop __tmp_reg__
 3172 0f36 0F90      		pop __tmp_reg__
 3173 0f38 DF91      		pop r29
 3174 0f3a CF91      		pop r28
 3175 0f3c 0895      		ret
 3177               	.Lscope26:
 3179               		.stabd	78,0,0
 3184               	prvAllocateTCBAndStack:
 3185               		.stabd	46,0,0
2395:tasks.c       **** /*-----------------------------------------------------------*/
2396:tasks.c       **** 
2397:tasks.c       **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
2398:tasks.c       **** {
 3187               	.LM300:
 3188               	.LFBB27:
 3189 0f3e CF93      		push r28
 3190 0f40 DF93      		push r29
 3191 0f42 00D0      		rcall .
 3192 0f44 00D0      		rcall .
 3193 0f46 CDB7      		in r28,__SP_L__
 3194 0f48 DEB7      		in r29,__SP_H__
 3195               	/* prologue: function */
 3196               	/* frame size = 6 */
 3197               	/* stack size = 8 */
 3198               	.L__stack_usage = 8
 3199 0f4a 9C83      		std Y+4,r25
 3200 0f4c 8B83      		std Y+3,r24
 3201 0f4e 7E83      		std Y+6,r23
 3202 0f50 6D83      		std Y+5,r22
2399:tasks.c       **** tskTCB *pxNewTCB;
2400:tasks.c       **** 
2401:tasks.c       **** 	/* Allocate space for the TCB.  Where the memory comes from depends on
2402:tasks.c       **** 	the implementation of the port malloc function. */
2403:tasks.c       **** 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 3204               	.LM301:
 3205 0f52 8AE2      		ldi r24,lo8(42)
 3206 0f54 90E0      		ldi r25,0
 3207 0f56 0E94 0000 		call pvPortMalloc
 3208 0f5a 9A83      		std Y+2,r25
 3209 0f5c 8983      		std Y+1,r24
2404:tasks.c       **** 
2405:tasks.c       **** 	if( pxNewTCB != NULL )
 3211               	.LM302:
 3212 0f5e 8981      		ldd r24,Y+1
 3213 0f60 9A81      		ldd r25,Y+2
 3214 0f62 0097      		sbiw r24,0
 3215 0f64 01F0      		breq .L112
2406:tasks.c       **** 	{
2407:tasks.c       **** 		/* Allocate space for the stack used by the task being created.
2408:tasks.c       **** 		The base of the stack memory stored in the TCB so the task can
2409:tasks.c       **** 		be deleted later if required. */
2410:tasks.c       **** 		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * size
 3217               	.LM303:
 3218 0f66 8D81      		ldd r24,Y+5
 3219 0f68 9E81      		ldd r25,Y+6
 3220 0f6a 0097      		sbiw r24,0
 3221 0f6c 01F4      		brne .L113
 3223               	.LM304:
 3224 0f6e 8B81      		ldd r24,Y+3
 3225 0f70 9C81      		ldd r25,Y+4
 3226 0f72 0E94 0000 		call pvPortMalloc
 3227 0f76 00C0      		rjmp .L114
 3228               	.L113:
 3230               	.LM305:
 3231 0f78 8D81      		ldd r24,Y+5
 3232 0f7a 9E81      		ldd r25,Y+6
 3233               	.L114:
 3235               	.LM306:
 3236 0f7c 2981      		ldd r18,Y+1
 3237 0f7e 3A81      		ldd r19,Y+2
 3238 0f80 F901      		movw r30,r18
 3239 0f82 908F      		std Z+24,r25
 3240 0f84 878B      		std Z+23,r24
2411:tasks.c       **** 
2412:tasks.c       **** 		if( pxNewTCB->pxStack == NULL )
 3242               	.LM307:
 3243 0f86 8981      		ldd r24,Y+1
 3244 0f88 9A81      		ldd r25,Y+2
 3245 0f8a FC01      		movw r30,r24
 3246 0f8c 8789      		ldd r24,Z+23
 3247 0f8e 908D      		ldd r25,Z+24
 3248 0f90 0097      		sbiw r24,0
 3249 0f92 01F4      		brne .L115
2413:tasks.c       **** 		{
2414:tasks.c       **** 			/* Could not allocate the stack.  Delete the allocated TCB. */
2415:tasks.c       **** 			vPortFree( pxNewTCB );
 3251               	.LM308:
 3252 0f94 8981      		ldd r24,Y+1
 3253 0f96 9A81      		ldd r25,Y+2
 3254 0f98 0E94 0000 		call vPortFree
2416:tasks.c       **** 			pxNewTCB = NULL;
 3256               	.LM309:
 3257 0f9c 1A82      		std Y+2,__zero_reg__
 3258 0f9e 1982      		std Y+1,__zero_reg__
 3259 0fa0 00C0      		rjmp .L112
 3260               	.L115:
2417:tasks.c       **** 		}
2418:tasks.c       **** 		else
2419:tasks.c       **** 		{
2420:tasks.c       **** 			/* Just to help debugging. */
2421:tasks.c       **** 			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTA
 3262               	.LM310:
 3263 0fa2 8981      		ldd r24,Y+1
 3264 0fa4 9A81      		ldd r25,Y+2
 3265 0fa6 FC01      		movw r30,r24
 3266 0fa8 8789      		ldd r24,Z+23
 3267 0faa 908D      		ldd r25,Z+24
 3268 0fac 2B81      		ldd r18,Y+3
 3269 0fae 3C81      		ldd r19,Y+4
 3270 0fb0 A901      		movw r20,r18
 3271 0fb2 65EA      		ldi r22,lo8(-91)
 3272 0fb4 70E0      		ldi r23,0
 3273 0fb6 0E94 0000 		call memset
 3274               	.L112:
2422:tasks.c       **** 		}
2423:tasks.c       **** 	}
2424:tasks.c       **** 
2425:tasks.c       **** 	return pxNewTCB;
 3276               	.LM311:
 3277 0fba 8981      		ldd r24,Y+1
 3278 0fbc 9A81      		ldd r25,Y+2
 3279               	/* epilogue start */
2426:tasks.c       **** }
 3281               	.LM312:
 3282 0fbe 2696      		adiw r28,6
 3283 0fc0 0FB6      		in __tmp_reg__,__SREG__
 3284 0fc2 F894      		cli
 3285 0fc4 DEBF      		out __SP_H__,r29
 3286 0fc6 0FBE      		out __SREG__,__tmp_reg__
 3287 0fc8 CDBF      		out __SP_L__,r28
 3288 0fca DF91      		pop r29
 3289 0fcc CF91      		pop r28
 3290 0fce 0895      		ret
 3295               	.Lscope27:
 3297               		.stabd	78,0,0
 3301               	usTaskCheckFreeStackSpace:
 3302               		.stabd	46,0,0
2427:tasks.c       **** /*-----------------------------------------------------------*/
2428:tasks.c       **** 
2429:tasks.c       **** #if ( configUSE_TRACE_FACILITY == 1 )
2430:tasks.c       **** 
2431:tasks.c       **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
2432:tasks.c       **** 	{
2433:tasks.c       **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2434:tasks.c       **** 	unsigned short usStackRemaining;
2435:tasks.c       **** 	PRIVILEGED_DATA static char pcStatusString[ configMAX_TASK_NAME_LEN + 30 ];
2436:tasks.c       **** 
2437:tasks.c       **** 		/* Write the details of all the TCB's in pxList into the buffer. */
2438:tasks.c       **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2439:tasks.c       **** 		do
2440:tasks.c       **** 		{
2441:tasks.c       **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2442:tasks.c       **** 			#if ( portSTACK_GROWTH > 0 )
2443:tasks.c       **** 			{
2444:tasks.c       **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
2445:tasks.c       **** 			}
2446:tasks.c       **** 			#else
2447:tasks.c       **** 			{
2448:tasks.c       **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
2449:tasks.c       **** 			}
2450:tasks.c       **** 			#endif
2451:tasks.c       **** 
2452:tasks.c       **** 			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, 
2453:tasks.c       **** 			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
2454:tasks.c       **** 
2455:tasks.c       **** 		} while( pxNextTCB != pxFirstTCB );
2456:tasks.c       **** 	}
2457:tasks.c       **** 
2458:tasks.c       **** #endif
2459:tasks.c       **** /*-----------------------------------------------------------*/
2460:tasks.c       **** 
2461:tasks.c       **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
2462:tasks.c       **** 
2463:tasks.c       **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
2464:tasks.c       **** 	{
2465:tasks.c       **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2466:tasks.c       **** 	unsigned long ulStatsAsPercentage;
2467:tasks.c       **** 
2468:tasks.c       **** 		/* Write the run time stats of all the TCB's in pxList into the buffer. */
2469:tasks.c       **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2470:tasks.c       **** 		do
2471:tasks.c       **** 		{
2472:tasks.c       **** 			/* Get next TCB in from the list. */
2473:tasks.c       **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2474:tasks.c       **** 
2475:tasks.c       **** 			/* Divide by zero check. */
2476:tasks.c       **** 			if( ulTotalRunTime > 0UL )
2477:tasks.c       **** 			{
2478:tasks.c       **** 				/* Has the task run at all? */
2479:tasks.c       **** 				if( pxNextTCB->ulRunTimeCounter == 0UL )
2480:tasks.c       **** 				{
2481:tasks.c       **** 					/* The task has used no CPU time at all. */
2482:tasks.c       **** 					sprintf( pcStatsString, ( char * ) "%s\t\t0\t\t0%%\r\n", pxNextTCB->pcTaskName );
2483:tasks.c       **** 				}
2484:tasks.c       **** 				else
2485:tasks.c       **** 				{
2486:tasks.c       **** 					/* What percentage of the total run time has the task used?
2487:tasks.c       **** 					This will always be rounded down to the nearest integer.
2488:tasks.c       **** 					ulTotalRunTime has already been divided by 100. */
2489:tasks.c       **** 					ulStatsAsPercentage = pxNextTCB->ulRunTimeCounter / ulTotalRunTime;
2490:tasks.c       **** 
2491:tasks.c       **** 					if( ulStatsAsPercentage > 0UL )
2492:tasks.c       **** 					{
2493:tasks.c       **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2494:tasks.c       **** 						{
2495:tasks.c       **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t%lu%%\r\n", pxNextTCB->pcTaskName, pxNextTC
2496:tasks.c       **** 						}
2497:tasks.c       **** 						#else
2498:tasks.c       **** 						{
2499:tasks.c       **** 							/* sizeof( int ) == sizeof( long ) so a smaller
2500:tasks.c       **** 							printf() library can be used. */
2501:tasks.c       **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t%u%%\r\n", pxNextTCB->pcTaskName, ( unsigned
2502:tasks.c       **** 						}
2503:tasks.c       **** 						#endif
2504:tasks.c       **** 					}
2505:tasks.c       **** 					else
2506:tasks.c       **** 					{
2507:tasks.c       **** 						/* If the percentage is zero here then the task has
2508:tasks.c       **** 						consumed less than 1% of the total run time. */
2509:tasks.c       **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2510:tasks.c       **** 						{
2511:tasks.c       **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t<1%%\r\n", pxNextTCB->pcTaskName, pxNextTCB
2512:tasks.c       **** 						}
2513:tasks.c       **** 						#else
2514:tasks.c       **** 						{
2515:tasks.c       **** 							/* sizeof( int ) == sizeof( long ) so a smaller
2516:tasks.c       **** 							printf() library can be used. */
2517:tasks.c       **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t<1%%\r\n", pxNextTCB->pcTaskName, ( unsigned
2518:tasks.c       **** 						}
2519:tasks.c       **** 						#endif
2520:tasks.c       **** 					}
2521:tasks.c       **** 				}
2522:tasks.c       **** 
2523:tasks.c       **** 				strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatsString );
2524:tasks.c       **** 			}
2525:tasks.c       **** 
2526:tasks.c       **** 		} while( pxNextTCB != pxFirstTCB );
2527:tasks.c       **** 	}
2528:tasks.c       **** 
2529:tasks.c       **** #endif
2530:tasks.c       **** /*-----------------------------------------------------------*/
2531:tasks.c       **** 
2532:tasks.c       **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
2533:tasks.c       **** 
2534:tasks.c       **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
2535:tasks.c       **** 	{
 3304               	.LM313:
 3305               	.LFBB28:
 3306 0fd0 0F93      		push r16
 3307 0fd2 1F93      		push r17
 3308 0fd4 CF93      		push r28
 3309 0fd6 DF93      		push r29
 3310 0fd8 1F92      		push __zero_reg__
 3311 0fda 1F92      		push __zero_reg__
 3312 0fdc CDB7      		in r28,__SP_L__
 3313 0fde DEB7      		in r29,__SP_H__
 3314               	/* prologue: function */
 3315               	/* frame size = 2 */
 3316               	/* stack size = 6 */
 3317               	.L__stack_usage = 6
 3318 0fe0 9A83      		std Y+2,r25
 3319 0fe2 8983      		std Y+1,r24
2536:tasks.c       **** 	register unsigned short usCount = 0U;
 3321               	.LM314:
 3322 0fe4 00E0      		ldi r16,0
 3323 0fe6 10E0      		ldi r17,0
2537:tasks.c       **** 
2538:tasks.c       **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
 3325               	.LM315:
 3326 0fe8 00C0      		rjmp .L118
 3327               	.L119:
2539:tasks.c       **** 		{
2540:tasks.c       **** 			pucStackByte -= portSTACK_GROWTH;
 3329               	.LM316:
 3330 0fea 8981      		ldd r24,Y+1
 3331 0fec 9A81      		ldd r25,Y+2
 3332 0fee 0196      		adiw r24,1
 3333 0ff0 9A83      		std Y+2,r25
 3334 0ff2 8983      		std Y+1,r24
2541:tasks.c       **** 			usCount++;
 3336               	.LM317:
 3337 0ff4 C801      		movw r24,r16
 3338 0ff6 8C01      		movw r16,r24
 3339 0ff8 0F5F      		subi r16,-1
 3340 0ffa 1F4F      		sbci r17,-1
 3341               	.L118:
2538:tasks.c       **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
 3343               	.LM318:
 3344 0ffc 8981      		ldd r24,Y+1
 3345 0ffe 9A81      		ldd r25,Y+2
 3346 1000 FC01      		movw r30,r24
 3347 1002 8081      		ld r24,Z
 3348 1004 853A      		cpi r24,lo8(-91)
 3349 1006 01F0      		breq .L119
2542:tasks.c       **** 		}
2543:tasks.c       **** 
2544:tasks.c       **** 		usCount /= sizeof( portSTACK_TYPE );
2545:tasks.c       **** 
2546:tasks.c       **** 		return usCount;
 3351               	.LM319:
 3352 1008 C801      		movw r24,r16
 3353               	/* epilogue start */
2547:tasks.c       **** 	}
 3355               	.LM320:
 3356 100a 0F90      		pop __tmp_reg__
 3357 100c 0F90      		pop __tmp_reg__
 3358 100e DF91      		pop r29
 3359 1010 CF91      		pop r28
 3360 1012 1F91      		pop r17
 3361 1014 0F91      		pop r16
 3362 1016 0895      		ret
 3367               	.Lscope28:
 3369               		.stabd	78,0,0
 3372               	.global	uxTaskGetStackHighWaterMark
 3374               	uxTaskGetStackHighWaterMark:
 3375               		.stabd	46,0,0
2548:tasks.c       **** 
2549:tasks.c       **** #endif
2550:tasks.c       **** /*-----------------------------------------------------------*/
2551:tasks.c       **** 
2552:tasks.c       **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
2553:tasks.c       **** 
2554:tasks.c       **** 	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
2555:tasks.c       **** 	{
 3377               	.LM321:
 3378               	.LFBB29:
 3379 1018 CF93      		push r28
 3380 101a DF93      		push r29
 3381 101c CDB7      		in r28,__SP_L__
 3382 101e DEB7      		in r29,__SP_H__
 3383 1020 2797      		sbiw r28,7
 3384 1022 0FB6      		in __tmp_reg__,__SREG__
 3385 1024 F894      		cli
 3386 1026 DEBF      		out __SP_H__,r29
 3387 1028 0FBE      		out __SREG__,__tmp_reg__
 3388 102a CDBF      		out __SP_L__,r28
 3389               	/* prologue: function */
 3390               	/* frame size = 7 */
 3391               	/* stack size = 9 */
 3392               	.L__stack_usage = 9
 3393 102c 9F83      		std Y+7,r25
 3394 102e 8E83      		std Y+6,r24
2556:tasks.c       **** 	tskTCB *pxTCB;
2557:tasks.c       **** 	unsigned char *pcEndOfStack;
2558:tasks.c       **** 	unsigned portBASE_TYPE uxReturn;
2559:tasks.c       **** 
2560:tasks.c       **** 		pxTCB = prvGetTCBFromHandle( xTask );
 3396               	.LM322:
 3397 1030 8E81      		ldd r24,Y+6
 3398 1032 9F81      		ldd r25,Y+7
 3399 1034 0097      		sbiw r24,0
 3400 1036 01F4      		brne .L122
 3402               	.LM323:
 3403 1038 8091 0000 		lds r24,pxCurrentTCB
 3404 103c 9091 0000 		lds r25,pxCurrentTCB+1
 3405 1040 00C0      		rjmp .L123
 3406               	.L122:
 3408               	.LM324:
 3409 1042 8E81      		ldd r24,Y+6
 3410 1044 9F81      		ldd r25,Y+7
 3411               	.L123:
 3413               	.LM325:
 3414 1046 9A83      		std Y+2,r25
 3415 1048 8983      		std Y+1,r24
2561:tasks.c       **** 
2562:tasks.c       **** 		#if portSTACK_GROWTH < 0
2563:tasks.c       **** 		{
2564:tasks.c       **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
 3417               	.LM326:
 3418 104a 8981      		ldd r24,Y+1
 3419 104c 9A81      		ldd r25,Y+2
 3420 104e FC01      		movw r30,r24
 3421 1050 8789      		ldd r24,Z+23
 3422 1052 908D      		ldd r25,Z+24
 3423 1054 9C83      		std Y+4,r25
 3424 1056 8B83      		std Y+3,r24
2565:tasks.c       **** 		}
2566:tasks.c       **** 		#else
2567:tasks.c       **** 		{
2568:tasks.c       **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
2569:tasks.c       **** 		}
2570:tasks.c       **** 		#endif
2571:tasks.c       **** 
2572:tasks.c       **** 		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
 3426               	.LM327:
 3427 1058 8B81      		ldd r24,Y+3
 3428 105a 9C81      		ldd r25,Y+4
 3429 105c 0E94 0000 		call usTaskCheckFreeStackSpace
 3430 1060 8D83      		std Y+5,r24
2573:tasks.c       **** 
2574:tasks.c       **** 		return uxReturn;
 3432               	.LM328:
 3433 1062 8D81      		ldd r24,Y+5
 3434               	/* epilogue start */
2575:tasks.c       **** 	}
 3436               	.LM329:
 3437 1064 2796      		adiw r28,7
 3438 1066 0FB6      		in __tmp_reg__,__SREG__
 3439 1068 F894      		cli
 3440 106a DEBF      		out __SP_H__,r29
 3441 106c 0FBE      		out __SREG__,__tmp_reg__
 3442 106e CDBF      		out __SP_L__,r28
 3443 1070 DF91      		pop r29
 3444 1072 CF91      		pop r28
 3445 1074 0895      		ret
 3452               	.Lscope29:
 3454               		.stabd	78,0,0
 3456               	.global	xTaskGetCurrentTaskHandle
 3458               	xTaskGetCurrentTaskHandle:
 3459               		.stabd	46,0,0
2576:tasks.c       **** 
2577:tasks.c       **** #endif
2578:tasks.c       **** /*-----------------------------------------------------------*/
2579:tasks.c       **** 
2580:tasks.c       **** #if ( INCLUDE_vTaskDelete == 1 )
2581:tasks.c       **** 
2582:tasks.c       **** 	static void prvDeleteTCB( tskTCB *pxTCB )
2583:tasks.c       **** 	{
2584:tasks.c       **** 		/* This call is required specifically for the TriCore port.  It must be
2585:tasks.c       **** 		above the vPortFree() calls.  The call is also used by ports/demos that
2586:tasks.c       **** 		want to allocate and clean RAM statically. */
2587:tasks.c       **** 		portCLEAN_UP_TCB( pxTCB );
2588:tasks.c       **** 
2589:tasks.c       **** 		/* Free up the memory allocated by the scheduler for the task.  It is up to
2590:tasks.c       **** 		the task to free any memory allocated at the application level. */
2591:tasks.c       **** 		vPortFreeAligned( pxTCB->pxStack );
2592:tasks.c       **** 		vPortFree( pxTCB );
2593:tasks.c       **** 	}
2594:tasks.c       **** 
2595:tasks.c       **** #endif
2596:tasks.c       **** 
2597:tasks.c       **** 
2598:tasks.c       **** /*-----------------------------------------------------------*/
2599:tasks.c       **** 
2600:tasks.c       **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
2601:tasks.c       **** 
2602:tasks.c       **** 	xTaskHandle xTaskGetCurrentTaskHandle( void )
2603:tasks.c       **** 	{
 3461               	.LM330:
 3462               	.LFBB30:
 3463 1076 CF93      		push r28
 3464 1078 DF93      		push r29
 3465 107a 1F92      		push __zero_reg__
 3466 107c 1F92      		push __zero_reg__
 3467 107e CDB7      		in r28,__SP_L__
 3468 1080 DEB7      		in r29,__SP_H__
 3469               	/* prologue: function */
 3470               	/* frame size = 2 */
 3471               	/* stack size = 4 */
 3472               	.L__stack_usage = 4
2604:tasks.c       **** 	xTaskHandle xReturn;
2605:tasks.c       **** 
2606:tasks.c       **** 		/* A critical section is not required as this is not called from
2607:tasks.c       **** 		an interrupt and the current TCB will always be the same for any
2608:tasks.c       **** 		individual execution thread. */
2609:tasks.c       **** 		xReturn = pxCurrentTCB;
 3474               	.LM331:
 3475 1082 8091 0000 		lds r24,pxCurrentTCB
 3476 1086 9091 0000 		lds r25,pxCurrentTCB+1
 3477 108a 9A83      		std Y+2,r25
 3478 108c 8983      		std Y+1,r24
2610:tasks.c       **** 
2611:tasks.c       **** 		return xReturn;
 3480               	.LM332:
 3481 108e 8981      		ldd r24,Y+1
 3482 1090 9A81      		ldd r25,Y+2
 3483               	/* epilogue start */
2612:tasks.c       **** 	}
 3485               	.LM333:
 3486 1092 0F90      		pop __tmp_reg__
 3487 1094 0F90      		pop __tmp_reg__
 3488 1096 DF91      		pop r29
 3489 1098 CF91      		pop r28
 3490 109a 0895      		ret
 3495               	.Lscope30:
 3497               		.stabd	78,0,0
 3500               	.global	vTaskPriorityInherit
 3502               	vTaskPriorityInherit:
 3503               		.stabd	46,0,0
2613:tasks.c       **** 
2614:tasks.c       **** #endif
2615:tasks.c       **** 
2616:tasks.c       **** /*-----------------------------------------------------------*/
2617:tasks.c       **** 
2618:tasks.c       **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
2619:tasks.c       **** 
2620:tasks.c       **** 	portBASE_TYPE xTaskGetSchedulerState( void )
2621:tasks.c       **** 	{
2622:tasks.c       **** 	portBASE_TYPE xReturn;
2623:tasks.c       **** 
2624:tasks.c       **** 		if( xSchedulerRunning == pdFALSE )
2625:tasks.c       **** 		{
2626:tasks.c       **** 			xReturn = taskSCHEDULER_NOT_STARTED;
2627:tasks.c       **** 		}
2628:tasks.c       **** 		else
2629:tasks.c       **** 		{
2630:tasks.c       **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
2631:tasks.c       **** 			{
2632:tasks.c       **** 				xReturn = taskSCHEDULER_RUNNING;
2633:tasks.c       **** 			}
2634:tasks.c       **** 			else
2635:tasks.c       **** 			{
2636:tasks.c       **** 				xReturn = taskSCHEDULER_SUSPENDED;
2637:tasks.c       **** 			}
2638:tasks.c       **** 		}
2639:tasks.c       **** 
2640:tasks.c       **** 		return xReturn;
2641:tasks.c       **** 	}
2642:tasks.c       **** 
2643:tasks.c       **** #endif
2644:tasks.c       **** /*-----------------------------------------------------------*/
2645:tasks.c       **** 
2646:tasks.c       **** #if ( configUSE_MUTEXES == 1 )
2647:tasks.c       **** 
2648:tasks.c       **** 	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
2649:tasks.c       **** 	{
 3505               	.LM334:
 3506               	.LFBB31:
 3507 109c CF93      		push r28
 3508 109e DF93      		push r29
 3509 10a0 00D0      		rcall .
 3510 10a2 1F92      		push __zero_reg__
 3511 10a4 CDB7      		in r28,__SP_L__
 3512 10a6 DEB7      		in r29,__SP_H__
 3513               	/* prologue: function */
 3514               	/* frame size = 4 */
 3515               	/* stack size = 6 */
 3516               	.L__stack_usage = 6
 3517 10a8 9C83      		std Y+4,r25
 3518 10aa 8B83      		std Y+3,r24
2650:tasks.c       **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 3520               	.LM335:
 3521 10ac 8B81      		ldd r24,Y+3
 3522 10ae 9C81      		ldd r25,Y+4
 3523 10b0 9A83      		std Y+2,r25
 3524 10b2 8983      		std Y+1,r24
2651:tasks.c       **** 
2652:tasks.c       **** 		/* If the mutex was given back by an interrupt while the queue was
2653:tasks.c       **** 		locked then the mutex holder might now be NULL. */
2654:tasks.c       **** 		if( pxMutexHolder != NULL )
 3526               	.LM336:
 3527 10b4 8B81      		ldd r24,Y+3
 3528 10b6 9C81      		ldd r25,Y+4
 3529 10b8 0097      		sbiw r24,0
 3530 10ba 01F4      		brne .+2
 3531 10bc 00C0      		rjmp .L127
2655:tasks.c       **** 		{
2656:tasks.c       **** 			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 3533               	.LM337:
 3534 10be 8981      		ldd r24,Y+1
 3535 10c0 9A81      		ldd r25,Y+2
 3536 10c2 FC01      		movw r30,r24
 3537 10c4 2689      		ldd r18,Z+22
 3538 10c6 8091 0000 		lds r24,pxCurrentTCB
 3539 10ca 9091 0000 		lds r25,pxCurrentTCB+1
 3540 10ce FC01      		movw r30,r24
 3541 10d0 8689      		ldd r24,Z+22
 3542 10d2 2817      		cp r18,r24
 3543 10d4 00F0      		brlo .+2
 3544 10d6 00C0      		rjmp .L127
2657:tasks.c       **** 			{
2658:tasks.c       **** 				/* Adjust the mutex holder state to account for its new priority. */
2659:tasks.c       **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) px
 3546               	.LM338:
 3547 10d8 8091 0000 		lds r24,pxCurrentTCB
 3548 10dc 9091 0000 		lds r25,pxCurrentTCB+1
 3549 10e0 FC01      		movw r30,r24
 3550 10e2 8689      		ldd r24,Z+22
 3551 10e4 882F      		mov r24,r24
 3552 10e6 90E0      		ldi r25,0
 3553 10e8 24E0      		ldi r18,lo8(4)
 3554 10ea 30E0      		ldi r19,0
 3555 10ec 281B      		sub r18,r24
 3556 10ee 390B      		sbc r19,r25
 3557 10f0 8981      		ldd r24,Y+1
 3558 10f2 9A81      		ldd r25,Y+2
 3559 10f4 FC01      		movw r30,r24
 3560 10f6 3587      		std Z+13,r19
 3561 10f8 2487      		std Z+12,r18
2660:tasks.c       **** 
2661:tasks.c       **** 				/* If the task being modified is in the ready state it will need to
2662:tasks.c       **** 				be moved into a new list. */
2663:tasks.c       **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericLis
 3563               	.LM339:
 3564 10fa 8981      		ldd r24,Y+1
 3565 10fc 9A81      		ldd r25,Y+2
 3566 10fe FC01      		movw r30,r24
 3567 1100 4285      		ldd r20,Z+10
 3568 1102 5385      		ldd r21,Z+11
 3569 1104 8981      		ldd r24,Y+1
 3570 1106 9A81      		ldd r25,Y+2
 3571 1108 FC01      		movw r30,r24
 3572 110a 8689      		ldd r24,Z+22
 3573 110c 282F      		mov r18,r24
 3574 110e 30E0      		ldi r19,0
 3575 1110 C901      		movw r24,r18
 3576 1112 880F      		lsl r24
 3577 1114 991F      		rol r25
 3578 1116 880F      		lsl r24
 3579 1118 991F      		rol r25
 3580 111a 880F      		lsl r24
 3581 111c 991F      		rol r25
 3582 111e 820F      		add r24,r18
 3583 1120 931F      		adc r25,r19
 3584 1122 8050      		subi r24,lo8(-(pxReadyTasksLists))
 3585 1124 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 3586 1126 4817      		cp r20,r24
 3587 1128 5907      		cpc r21,r25
 3588 112a 01F4      		brne .L129
2664:tasks.c       **** 				{
2665:tasks.c       **** 					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
 3590               	.LM340:
 3591 112c 8981      		ldd r24,Y+1
 3592 112e 9A81      		ldd r25,Y+2
 3593 1130 0296      		adiw r24,2
 3594 1132 0E94 0000 		call uxListRemove
2666:tasks.c       **** 					{
2667:tasks.c       **** 						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
2668:tasks.c       **** 					}
2669:tasks.c       **** 
2670:tasks.c       **** 					/* Inherit the priority before being moved into the new list. */
2671:tasks.c       **** 					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 3596               	.LM341:
 3597 1136 8091 0000 		lds r24,pxCurrentTCB
 3598 113a 9091 0000 		lds r25,pxCurrentTCB+1
 3599 113e FC01      		movw r30,r24
 3600 1140 2689      		ldd r18,Z+22
 3601 1142 8981      		ldd r24,Y+1
 3602 1144 9A81      		ldd r25,Y+2
 3603 1146 FC01      		movw r30,r24
 3604 1148 268B      		std Z+22,r18
2672:tasks.c       **** 					prvAddTaskToReadyQueue( pxTCB );
 3606               	.LM342:
 3607 114a 8981      		ldd r24,Y+1
 3608 114c 9A81      		ldd r25,Y+2
 3609 114e FC01      		movw r30,r24
 3610 1150 9689      		ldd r25,Z+22
 3611 1152 8091 0000 		lds r24,uxTopReadyPriority
 3612 1156 8917      		cp r24,r25
 3613 1158 00F4      		brsh .L130
 3615               	.LM343:
 3616 115a 8981      		ldd r24,Y+1
 3617 115c 9A81      		ldd r25,Y+2
 3618 115e FC01      		movw r30,r24
 3619 1160 8689      		ldd r24,Z+22
 3620 1162 8093 0000 		sts uxTopReadyPriority,r24
 3621               	.L130:
 3623               	.LM344:
 3624 1166 8981      		ldd r24,Y+1
 3625 1168 9A81      		ldd r25,Y+2
 3626 116a AC01      		movw r20,r24
 3627 116c 4E5F      		subi r20,-2
 3628 116e 5F4F      		sbci r21,-1
 3629 1170 8981      		ldd r24,Y+1
 3630 1172 9A81      		ldd r25,Y+2
 3631 1174 FC01      		movw r30,r24
 3632 1176 8689      		ldd r24,Z+22
 3633 1178 282F      		mov r18,r24
 3634 117a 30E0      		ldi r19,0
 3635 117c C901      		movw r24,r18
 3636 117e 880F      		lsl r24
 3637 1180 991F      		rol r25
 3638 1182 880F      		lsl r24
 3639 1184 991F      		rol r25
 3640 1186 880F      		lsl r24
 3641 1188 991F      		rol r25
 3642 118a 820F      		add r24,r18
 3643 118c 931F      		adc r25,r19
 3644 118e 8050      		subi r24,lo8(-(pxReadyTasksLists))
 3645 1190 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 3646 1192 BA01      		movw r22,r20
 3647 1194 0E94 0000 		call vListInsertEnd
 3648 1198 00C0      		rjmp .L127
 3649               	.L129:
2673:tasks.c       **** 				}
2674:tasks.c       **** 				else
2675:tasks.c       **** 				{
2676:tasks.c       **** 					/* Just inherit the priority. */
2677:tasks.c       **** 					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 3651               	.LM345:
 3652 119a 8091 0000 		lds r24,pxCurrentTCB
 3653 119e 9091 0000 		lds r25,pxCurrentTCB+1
 3654 11a2 FC01      		movw r30,r24
 3655 11a4 2689      		ldd r18,Z+22
 3656 11a6 8981      		ldd r24,Y+1
 3657 11a8 9A81      		ldd r25,Y+2
 3658 11aa FC01      		movw r30,r24
 3659 11ac 268B      		std Z+22,r18
 3660               	.L127:
 3661               	/* epilogue start */
2678:tasks.c       **** 				}
2679:tasks.c       **** 
2680:tasks.c       **** 				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
2681:tasks.c       **** 			}
2682:tasks.c       **** 		}
2683:tasks.c       **** 	}
 3663               	.LM346:
 3664 11ae 0F90      		pop __tmp_reg__
 3665 11b0 0F90      		pop __tmp_reg__
 3666 11b2 0F90      		pop __tmp_reg__
 3667 11b4 0F90      		pop __tmp_reg__
 3668 11b6 DF91      		pop r29
 3669 11b8 CF91      		pop r28
 3670 11ba 0895      		ret
 3675               	.Lscope31:
 3677               		.stabd	78,0,0
 3680               	.global	vTaskPriorityDisinherit
 3682               	vTaskPriorityDisinherit:
 3683               		.stabd	46,0,0
2684:tasks.c       **** 
2685:tasks.c       **** #endif
2686:tasks.c       **** /*-----------------------------------------------------------*/
2687:tasks.c       **** 
2688:tasks.c       **** #if ( configUSE_MUTEXES == 1 )
2689:tasks.c       **** 
2690:tasks.c       **** 	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
2691:tasks.c       **** 	{
 3685               	.LM347:
 3686               	.LFBB32:
 3687 11bc CF93      		push r28
 3688 11be DF93      		push r29
 3689 11c0 00D0      		rcall .
 3690 11c2 1F92      		push __zero_reg__
 3691 11c4 CDB7      		in r28,__SP_L__
 3692 11c6 DEB7      		in r29,__SP_H__
 3693               	/* prologue: function */
 3694               	/* frame size = 4 */
 3695               	/* stack size = 6 */
 3696               	.L__stack_usage = 6
 3697 11c8 9C83      		std Y+4,r25
 3698 11ca 8B83      		std Y+3,r24
2692:tasks.c       **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 3700               	.LM348:
 3701 11cc 8B81      		ldd r24,Y+3
 3702 11ce 9C81      		ldd r25,Y+4
 3703 11d0 9A83      		std Y+2,r25
 3704 11d2 8983      		std Y+1,r24
2693:tasks.c       **** 
2694:tasks.c       **** 		if( pxMutexHolder != NULL )
 3706               	.LM349:
 3707 11d4 8B81      		ldd r24,Y+3
 3708 11d6 9C81      		ldd r25,Y+4
 3709 11d8 0097      		sbiw r24,0
 3710 11da 01F4      		brne .+2
 3711 11dc 00C0      		rjmp .L131
2695:tasks.c       **** 		{
2696:tasks.c       **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 3713               	.LM350:
 3714 11de 8981      		ldd r24,Y+1
 3715 11e0 9A81      		ldd r25,Y+2
 3716 11e2 FC01      		movw r30,r24
 3717 11e4 2689      		ldd r18,Z+22
 3718 11e6 8981      		ldd r24,Y+1
 3719 11e8 9A81      		ldd r25,Y+2
 3720 11ea FC01      		movw r30,r24
 3721 11ec 81A5      		ldd r24,Z+41
 3722 11ee 2817      		cp r18,r24
 3723 11f0 01F4      		brne .+2
 3724 11f2 00C0      		rjmp .L131
2697:tasks.c       **** 			{
2698:tasks.c       **** 				/* We must be the running task to be able to give the mutex back.
2699:tasks.c       **** 				Remove ourselves from the ready list we currently appear in. */
2700:tasks.c       **** 				if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
 3726               	.LM351:
 3727 11f4 8981      		ldd r24,Y+1
 3728 11f6 9A81      		ldd r25,Y+2
 3729 11f8 0296      		adiw r24,2
 3730 11fa 0E94 0000 		call uxListRemove
2701:tasks.c       **** 				{
2702:tasks.c       **** 					taskRESET_READY_PRIORITY( pxTCB->uxPriority );
2703:tasks.c       **** 				}
2704:tasks.c       **** 
2705:tasks.c       **** 				/* Disinherit the priority before adding the task into the new
2706:tasks.c       **** 				ready list. */
2707:tasks.c       **** 				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
2708:tasks.c       **** 				pxTCB->uxPriority = pxTCB->uxBasePriority;
 3732               	.LM352:
 3733 11fe 8981      		ldd r24,Y+1
 3734 1200 9A81      		ldd r25,Y+2
 3735 1202 FC01      		movw r30,r24
 3736 1204 21A5      		ldd r18,Z+41
 3737 1206 8981      		ldd r24,Y+1
 3738 1208 9A81      		ldd r25,Y+2
 3739 120a FC01      		movw r30,r24
 3740 120c 268B      		std Z+22,r18
2709:tasks.c       **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) px
 3742               	.LM353:
 3743 120e 8981      		ldd r24,Y+1
 3744 1210 9A81      		ldd r25,Y+2
 3745 1212 FC01      		movw r30,r24
 3746 1214 8689      		ldd r24,Z+22
 3747 1216 882F      		mov r24,r24
 3748 1218 90E0      		ldi r25,0
 3749 121a 24E0      		ldi r18,lo8(4)
 3750 121c 30E0      		ldi r19,0
 3751 121e 281B      		sub r18,r24
 3752 1220 390B      		sbc r19,r25
 3753 1222 8981      		ldd r24,Y+1
 3754 1224 9A81      		ldd r25,Y+2
 3755 1226 FC01      		movw r30,r24
 3756 1228 3587      		std Z+13,r19
 3757 122a 2487      		std Z+12,r18
2710:tasks.c       **** 				prvAddTaskToReadyQueue( pxTCB );
 3759               	.LM354:
 3760 122c 8981      		ldd r24,Y+1
 3761 122e 9A81      		ldd r25,Y+2
 3762 1230 FC01      		movw r30,r24
 3763 1232 9689      		ldd r25,Z+22
 3764 1234 8091 0000 		lds r24,uxTopReadyPriority
 3765 1238 8917      		cp r24,r25
 3766 123a 00F4      		brsh .L133
 3768               	.LM355:
 3769 123c 8981      		ldd r24,Y+1
 3770 123e 9A81      		ldd r25,Y+2
 3771 1240 FC01      		movw r30,r24
 3772 1242 8689      		ldd r24,Z+22
 3773 1244 8093 0000 		sts uxTopReadyPriority,r24
 3774               	.L133:
 3776               	.LM356:
 3777 1248 8981      		ldd r24,Y+1
 3778 124a 9A81      		ldd r25,Y+2
 3779 124c AC01      		movw r20,r24
 3780 124e 4E5F      		subi r20,-2
 3781 1250 5F4F      		sbci r21,-1
 3782 1252 8981      		ldd r24,Y+1
 3783 1254 9A81      		ldd r25,Y+2
 3784 1256 FC01      		movw r30,r24
 3785 1258 8689      		ldd r24,Z+22
 3786 125a 282F      		mov r18,r24
 3787 125c 30E0      		ldi r19,0
 3788 125e C901      		movw r24,r18
 3789 1260 880F      		lsl r24
 3790 1262 991F      		rol r25
 3791 1264 880F      		lsl r24
 3792 1266 991F      		rol r25
 3793 1268 880F      		lsl r24
 3794 126a 991F      		rol r25
 3795 126c 820F      		add r24,r18
 3796 126e 931F      		adc r25,r19
 3797 1270 8050      		subi r24,lo8(-(pxReadyTasksLists))
 3798 1272 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 3799 1274 BA01      		movw r22,r20
 3800 1276 0E94 0000 		call vListInsertEnd
 3801               	.L131:
 3802               	/* epilogue start */
2711:tasks.c       **** 			}
2712:tasks.c       **** 		}
2713:tasks.c       **** 	}
 3804               	.LM357:
 3805 127a 0F90      		pop __tmp_reg__
 3806 127c 0F90      		pop __tmp_reg__
 3807 127e 0F90      		pop __tmp_reg__
 3808 1280 0F90      		pop __tmp_reg__
 3809 1282 DF91      		pop r29
 3810 1284 CF91      		pop r28
 3811 1286 0895      		ret
 3816               	.Lscope32:
 3818               		.stabd	78,0,0
 3839               	.Letext0:
 3840               		.ident	"GCC: (GNU) 4.8.2"
 3841               	.global __do_copy_data
 3842               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 tasks.c
     /tmp/ccU6cuak.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccU6cuak.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccU6cuak.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccU6cuak.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccU6cuak.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccU6cuak.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccU6cuak.s:164    .bss:0000000000000000 pxCurrentTCB
                             .bss:0000000000000002 pxReadyTasksLists
     /tmp/ccU6cuak.s:167    .bss:0000000000000026 xDelayedTaskList1
     /tmp/ccU6cuak.s:169    .bss:000000000000002f xDelayedTaskList2
     /tmp/ccU6cuak.s:171    .bss:0000000000000038 pxDelayedTaskList
     /tmp/ccU6cuak.s:173    .bss:000000000000003a pxOverflowDelayedTaskList
     /tmp/ccU6cuak.s:175    .bss:000000000000003c xPendingReadyList
     /tmp/ccU6cuak.s:177    .bss:0000000000000045 xSuspendedTaskList
     /tmp/ccU6cuak.s:179    .bss:000000000000004e uxCurrentNumberOfTasks
     /tmp/ccU6cuak.s:181    .bss:000000000000004f xTickCount
     /tmp/ccU6cuak.s:183    .bss:0000000000000051 uxTopUsedPriority
     /tmp/ccU6cuak.s:185    .bss:0000000000000052 uxTopReadyPriority
     /tmp/ccU6cuak.s:187    .bss:0000000000000053 xSchedulerRunning
     /tmp/ccU6cuak.s:189    .bss:0000000000000054 uxSchedulerSuspended
     /tmp/ccU6cuak.s:191    .bss:0000000000000055 uxMissedTicks
     /tmp/ccU6cuak.s:193    .bss:0000000000000056 xMissedYield
     /tmp/ccU6cuak.s:195    .bss:0000000000000057 xNumOfOverflows
     /tmp/ccU6cuak.s:197    .bss:0000000000000058 uxTaskNumber
     /tmp/ccU6cuak.s:203    .data:0000000000000000 xNextTaskUnblockTime
     /tmp/ccU6cuak.s:217    .text:0000000000000000 xTaskGenericCreate
     /tmp/ccU6cuak.s:3184   .text:0000000000000f3e prvAllocateTCBAndStack
     /tmp/ccU6cuak.s:2837   .text:0000000000000d5e prvInitialiseTCBVariables
     /tmp/ccU6cuak.s:2972   .text:0000000000000e20 prvInitialiseTaskLists
     /tmp/ccU6cuak.s:546    .text:00000000000001e8 vTaskDelayUntil
     /tmp/ccU6cuak.s:1488   .text:0000000000000682 vTaskSuspendAll
     /tmp/ccU6cuak.s:3093   .text:0000000000000ea8 prvAddCurrentTaskToDelayedList
     /tmp/ccU6cuak.s:1519   .text:000000000000069a xTaskResumeAll
     /tmp/ccU6cuak.s:718    .text:00000000000002da vTaskDelay
     /tmp/ccU6cuak.s:806    .text:0000000000000344 vTaskSuspend
     /tmp/ccU6cuak.s:2150   .text:00000000000009d6 vTaskSwitchContext
     /tmp/ccU6cuak.s:965    .text:00000000000003fe xTaskIsTaskSuspended
     /tmp/ccU6cuak.s:1054   .text:0000000000000462 vTaskResume
     /tmp/ccU6cuak.s:1211   .text:0000000000000530 xTaskResumeFromISR
     /tmp/ccU6cuak.s:1361   .text:00000000000005fe vTaskStartScheduler
     /tmp/ccU6cuak.s:2792   .text:0000000000000d3a prvIdleTask
     /tmp/ccU6cuak.s:1449   .text:000000000000066a vTaskEndScheduler
     /tmp/ccU6cuak.s:1879   .text:000000000000080c vTaskIncrementTick
     /tmp/ccU6cuak.s:1737   .text:00000000000007a2 xTaskGetTickCount
     /tmp/ccU6cuak.s:1803   .text:00000000000007d2 xTaskGetTickCountFromISR
     /tmp/ccU6cuak.s:1850   .text:00000000000007fa uxTaskGetNumberOfTasks
     /tmp/ccU6cuak.s:2299   .text:0000000000000ab2 vTaskPlaceOnEventList
     /tmp/ccU6cuak.s:2393   .text:0000000000000b3c xTaskRemoveFromEventList
     /tmp/ccU6cuak.s:2543   .text:0000000000000c10 vTaskSetTimeOutState
     /tmp/ccU6cuak.s:2593   .text:0000000000000c48 xTaskCheckForTimeOut
     /tmp/ccU6cuak.s:2762   .text:0000000000000d26 vTaskMissedYield
     /tmp/ccU6cuak.s:3067   .text:0000000000000e9a prvCheckTasksWaitingTermination
     /tmp/ccU6cuak.s:3301   .text:0000000000000fd0 usTaskCheckFreeStackSpace
     /tmp/ccU6cuak.s:3374   .text:0000000000001018 uxTaskGetStackHighWaterMark
     /tmp/ccU6cuak.s:3458   .text:0000000000001076 xTaskGetCurrentTaskHandle
     /tmp/ccU6cuak.s:3502   .text:000000000000109c vTaskPriorityInherit
     /tmp/ccU6cuak.s:3682   .text:00000000000011bc vTaskPriorityDisinherit

UNDEFINED SYMBOLS
pxPortInitialiseStack
vListInsertEnd
vPortYield
uxListRemove
xPortStartScheduler
vPortEndScheduler
vApplicationTickHook
vListInsert
strncpy
vListInitialiseItem
vListInitialise
pvPortMalloc
vPortFree
memset
__do_copy_data
__do_clear_bss
