   1               		.file	"tasks.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
  12               		.cfi_sections	.debug_frame
  14               	prvIdleTask:
  15               	.LFB22:
  16               		.file 1 "../../Source/tasks.c"
   1:../../Source/tasks.c **** /*
   2:../../Source/tasks.c ****     FreeRTOS V7.3.0 - Copyright (C) 2012 Real Time Engineers Ltd.
   3:../../Source/tasks.c **** 
   4:../../Source/tasks.c ****     FEATURES AND PORTS ARE ADDED TO FREERTOS ALL THE TIME.  PLEASE VISIT
   5:../../Source/tasks.c ****     http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:../../Source/tasks.c **** 
   7:../../Source/tasks.c ****     ***************************************************************************
   8:../../Source/tasks.c ****      *                                                                       *
   9:../../Source/tasks.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
  10:../../Source/tasks.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
  11:../../Source/tasks.c ****      *    available.                                                         *
  12:../../Source/tasks.c ****      *                                                                       *
  13:../../Source/tasks.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  14:../../Source/tasks.c ****      *    ensuring you get running as quickly as possible and with an        *
  15:../../Source/tasks.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  16:../../Source/tasks.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  17:../../Source/tasks.c ****      *    professional grade, cross platform, de facto standard solutions    *
  18:../../Source/tasks.c ****      *    for microcontrollers - completely free of charge!                  *
  19:../../Source/tasks.c ****      *                                                                       *
  20:../../Source/tasks.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  21:../../Source/tasks.c ****      *                                                                       *
  22:../../Source/tasks.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  23:../../Source/tasks.c ****      *                                                                       *
  24:../../Source/tasks.c ****     ***************************************************************************
  25:../../Source/tasks.c **** 
  26:../../Source/tasks.c **** 
  27:../../Source/tasks.c ****     This file is part of the FreeRTOS distribution.
  28:../../Source/tasks.c **** 
  29:../../Source/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  30:../../Source/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  31:../../Source/tasks.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  32:../../Source/tasks.c ****     >>>NOTE<<< The modification to the GPL is included to allow you to
  33:../../Source/tasks.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  34:../../Source/tasks.c ****     provide the source code for proprietary components outside of the FreeRTOS
  35:../../Source/tasks.c ****     kernel.  FreeRTOS is distributed in the hope that it will be useful, but
  36:../../Source/tasks.c ****     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  37:../../Source/tasks.c ****     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  38:../../Source/tasks.c ****     more details. You should have received a copy of the GNU General Public
  39:../../Source/tasks.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  40:../../Source/tasks.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  41:../../Source/tasks.c ****     by writing to Richard Barry, contact details for whom are available on the
  42:../../Source/tasks.c ****     FreeRTOS WEB site.
  43:../../Source/tasks.c **** 
  44:../../Source/tasks.c ****     1 tab == 4 spaces!
  45:../../Source/tasks.c **** 
  46:../../Source/tasks.c ****     ***************************************************************************
  47:../../Source/tasks.c ****      *                                                                       *
  48:../../Source/tasks.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  49:../../Source/tasks.c ****      *    not run, what could be wrong?"                                     *
  50:../../Source/tasks.c ****      *                                                                       *
  51:../../Source/tasks.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  52:../../Source/tasks.c ****      *                                                                       *
  53:../../Source/tasks.c ****     ***************************************************************************
  54:../../Source/tasks.c **** 
  55:../../Source/tasks.c **** 
  56:../../Source/tasks.c ****     http://www.FreeRTOS.org - Documentation, training, latest versions, license
  57:../../Source/tasks.c ****     and contact details.
  58:../../Source/tasks.c **** 
  59:../../Source/tasks.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  60:../../Source/tasks.c ****     including FreeRTOS+Trace - an indispensable productivity tool.
  61:../../Source/tasks.c **** 
  62:../../Source/tasks.c ****     Real Time Engineers ltd license FreeRTOS to High Integrity Systems, who sell
  63:../../Source/tasks.c ****     the code with commercial support, indemnification, and middleware, under
  64:../../Source/tasks.c ****     the OpenRTOS brand: http://www.OpenRTOS.com.  High Integrity Systems also
  65:../../Source/tasks.c ****     provide a safety engineered and independently SIL3 certified version under
  66:../../Source/tasks.c ****     the SafeRTOS brand: http://www.SafeRTOS.com.
  67:../../Source/tasks.c **** */
  68:../../Source/tasks.c **** 
  69:../../Source/tasks.c **** /* Standard includes. */
  70:../../Source/tasks.c **** #include <stdio.h>
  71:../../Source/tasks.c **** #include <stdlib.h>
  72:../../Source/tasks.c **** #include <string.h>
  73:../../Source/tasks.c **** 
  74:../../Source/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  75:../../Source/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  76:../../Source/tasks.c **** task.h is included from an application file. */
  77:../../Source/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  78:../../Source/tasks.c **** 
  79:../../Source/tasks.c **** /* FreeRTOS includes. */
  80:../../Source/tasks.c **** #include "FreeRTOS.h"
  81:../../Source/tasks.c **** #include "task.h"
  82:../../Source/tasks.c **** #include "timers.h"
  83:../../Source/tasks.c **** #include "StackMacros.h"
  84:../../Source/tasks.c **** 
  85:../../Source/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  86:../../Source/tasks.c **** 
  87:../../Source/tasks.c **** /*
  88:../../Source/tasks.c ****  * Defines the size, in words, of the stack allocated to the idle task.
  89:../../Source/tasks.c ****  */
  90:../../Source/tasks.c **** #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
  91:../../Source/tasks.c **** 
  92:../../Source/tasks.c **** /*
  93:../../Source/tasks.c ****  * Task control block.  A task control block (TCB) is allocated for each task,
  94:../../Source/tasks.c ****  * and stores task state information, including a pointer to the task's context
  95:../../Source/tasks.c ****  * (the task's run time environment, including register values)
  96:../../Source/tasks.c ****  */
  97:../../Source/tasks.c **** typedef struct tskTaskControlBlock
  98:../../Source/tasks.c **** {
  99:../../Source/tasks.c **** 	volatile portSTACK_TYPE	*pxTopOfStack;		/*< Points to the location of the last item placed on the 
 100:../../Source/tasks.c **** 
 101:../../Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 102:../../Source/tasks.c **** 		xMPU_SETTINGS xMPUSettings;				/*< The MPU settings are defined as part of the port layer.  THIS 
 103:../../Source/tasks.c **** 	#endif
 104:../../Source/tasks.c **** 
 105:../../Source/tasks.c **** 	xListItem				xGenericListItem;		/*< The list that the state list item of a task is reference from 
 106:../../Source/tasks.c **** 	xListItem				xEventListItem;		/*< Used to reference a task from an event list. */
 107:../../Source/tasks.c **** 	unsigned portBASE_TYPE	uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
 108:../../Source/tasks.c **** 	portSTACK_TYPE			*pxStack;			/*< Points to the start of the stack. */
 109:../../Source/tasks.c **** 	signed char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when c
 110:../../Source/tasks.c **** 
 111:../../Source/tasks.c **** 	#if ( portSTACK_GROWTH > 0 )
 112:../../Source/tasks.c **** 		portSTACK_TYPE *pxEndOfStack;			/*< Points to the end of the stack on architectures where the sta
 113:../../Source/tasks.c **** 	#endif
 114:../../Source/tasks.c **** 
 115:../../Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 116:../../Source/tasks.c **** 		unsigned portBASE_TYPE uxCriticalNesting; /*< Holds the critical section nesting depth for ports 
 117:../../Source/tasks.c **** 	#endif
 118:../../Source/tasks.c **** 
 119:../../Source/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 120:../../Source/tasks.c **** 		unsigned portBASE_TYPE	uxTCBNumber;	/*< Stores a number that increments each time a TCB is create
 121:../../Source/tasks.c **** 		unsigned portBASE_TYPE  uxTaskNumber;	/*< Stores a number specifically for use by third party tra
 122:../../Source/tasks.c **** 	#endif
 123:../../Source/tasks.c **** 
 124:../../Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 125:../../Source/tasks.c **** 		unsigned portBASE_TYPE uxBasePriority;	/*< The priority last assigned to the task - used by the p
 126:../../Source/tasks.c **** 	#endif
 127:../../Source/tasks.c **** 
 128:../../Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 129:../../Source/tasks.c **** 		pdTASK_HOOK_CODE pxTaskTag;
 130:../../Source/tasks.c **** 	#endif
 131:../../Source/tasks.c **** 
 132:../../Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 133:../../Source/tasks.c **** 		unsigned long ulRunTimeCounter;			/*< Stores the amount of time the task has spent in the Running
 134:../../Source/tasks.c **** 	#endif
 135:../../Source/tasks.c **** 
 136:../../Source/tasks.c **** } tskTCB;
 137:../../Source/tasks.c **** 
 138:../../Source/tasks.c **** 
 139:../../Source/tasks.c **** /*
 140:../../Source/tasks.c ****  * Some kernel aware debuggers require the data the debugger needs access to to
 141:../../Source/tasks.c ****  * be global, rather than file scope.
 142:../../Source/tasks.c ****  */
 143:../../Source/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 144:../../Source/tasks.c **** 	#define static
 145:../../Source/tasks.c **** #endif
 146:../../Source/tasks.c **** 
 147:../../Source/tasks.c **** /*lint -e956 */
 148:../../Source/tasks.c **** PRIVILEGED_DATA tskTCB * volatile pxCurrentTCB = NULL;
 149:../../Source/tasks.c **** 
 150:../../Source/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 151:../../Source/tasks.c **** PRIVILEGED_DATA static xList pxReadyTasksLists[ configMAX_PRIORITIES ];	/*< Prioritised ready tasks
 152:../../Source/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList1;							/*< Delayed tasks. */
 153:../../Source/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList2;							/*< Delayed tasks (two lists are used - one f
 154:../../Source/tasks.c **** PRIVILEGED_DATA static xList * volatile pxDelayedTaskList ;				/*< Points to the delayed task list 
 155:../../Source/tasks.c **** PRIVILEGED_DATA static xList * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task 
 156:../../Source/tasks.c **** PRIVILEGED_DATA static xList xPendingReadyList;							/*< Tasks that have been readied while the sc
 157:../../Source/tasks.c **** 
 158:../../Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 159:../../Source/tasks.c **** 
 160:../../Source/tasks.c **** 	PRIVILEGED_DATA static xList xTasksWaitingTermination;				/*< Tasks that have been deleted - but t
 161:../../Source/tasks.c **** 	PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTasksDeleted = ( unsigned portBASE_TYPE )
 162:../../Source/tasks.c **** 
 163:../../Source/tasks.c **** #endif
 164:../../Source/tasks.c **** 
 165:../../Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 166:../../Source/tasks.c **** 
 167:../../Source/tasks.c **** 	PRIVILEGED_DATA static xList xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 168:../../Source/tasks.c **** 
 169:../../Source/tasks.c **** #endif
 170:../../Source/tasks.c **** 
 171:../../Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
 172:../../Source/tasks.c **** 
 173:../../Source/tasks.c **** 	PRIVILEGED_DATA static xTaskHandle xIdleTaskHandle = NULL;			/*< Holds the handle of the idle task
 174:../../Source/tasks.c **** 
 175:../../Source/tasks.c **** #endif
 176:../../Source/tasks.c **** 
 177:../../Source/tasks.c **** /* File private variables. --------------------------------*/
 178:../../Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxCurrentNumberOfTasks 	= ( unsigned portBAS
 179:../../Source/tasks.c **** PRIVILEGED_DATA static volatile portTickType xTickCount 						= ( portTickType ) 0U;
 180:../../Source/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTopUsedPriority	 				= tskIDLE_PRIORITY;
 181:../../Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTopReadyPriority 		= tskIDLE_PRIORITY;
 182:../../Source/tasks.c **** PRIVILEGED_DATA static volatile signed portBASE_TYPE xSchedulerRunning 			= pdFALSE;
 183:../../Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxSchedulerSuspended	 	= ( unsigned portBASE
 184:../../Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxMissedTicks 			= ( unsigned portBASE_TYPE 
 185:../../Source/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xMissedYield 						= ( portBASE_TYPE ) pdFALSE;
 186:../../Source/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xNumOfOverflows 					= ( portBASE_TYPE ) 0;
 187:../../Source/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTaskNumber 						= ( unsigned portBASE_TYPE ) 0U;
 188:../../Source/tasks.c **** PRIVILEGED_DATA static volatile portTickType xNextTaskUnblockTime				= ( portTickType ) portMAX_DEL
 189:../../Source/tasks.c **** 
 190:../../Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 191:../../Source/tasks.c **** 
 192:../../Source/tasks.c **** 	PRIVILEGED_DATA static char pcStatsString[ 50 ] ;
 193:../../Source/tasks.c **** 	PRIVILEGED_DATA static unsigned long ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/co
 194:../../Source/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
 195:../../Source/tasks.c **** 
 196:../../Source/tasks.c **** #endif
 197:../../Source/tasks.c **** 
 198:../../Source/tasks.c **** /* Debugging and trace facilities private variables and macros. ------------*/
 199:../../Source/tasks.c **** 
 200:../../Source/tasks.c **** /*
 201:../../Source/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 202:../../Source/tasks.c ****  * is used purely for checking the high water mark for tasks.
 203:../../Source/tasks.c ****  */
 204:../../Source/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
 205:../../Source/tasks.c **** 
 206:../../Source/tasks.c **** /*
 207:../../Source/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 208:../../Source/tasks.c ****  */
 209:../../Source/tasks.c **** #define tskBLOCKED_CHAR		( ( signed char ) 'B' )
 210:../../Source/tasks.c **** #define tskREADY_CHAR		( ( signed char ) 'R' )
 211:../../Source/tasks.c **** #define tskDELETED_CHAR		( ( signed char ) 'D' )
 212:../../Source/tasks.c **** #define tskSUSPENDED_CHAR	( ( signed char ) 'S' )
 213:../../Source/tasks.c **** 
 214:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 215:../../Source/tasks.c **** 
 216:../../Source/tasks.c **** #if configUSE_PORT_OPTIMISED_TASK_SELECTION == 0
 217:../../Source/tasks.c **** 
 218:../../Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
 219:../../Source/tasks.c **** 	performed in a generic way that is not optimised to any particular
 220:../../Source/tasks.c **** 	microcontroller architecture. */
 221:../../Source/tasks.c **** 
 222:../../Source/tasks.c **** 	/* uxTopReadyPriority holds the priority of the highest priority ready
 223:../../Source/tasks.c **** 	state task. */
 224:../../Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )																		\
 225:../../Source/tasks.c **** 	{																													\
 226:../../Source/tasks.c **** 		if( ( uxPriority ) > uxTopReadyPriority )																		\
 227:../../Source/tasks.c **** 		{																												\
 228:../../Source/tasks.c **** 			uxTopReadyPriority = ( uxPriority );																		\
 229:../../Source/tasks.c **** 		}																												\
 230:../../Source/tasks.c **** 	} /* taskRECORD_READY_PRIORITY */
 231:../../Source/tasks.c **** 
 232:../../Source/tasks.c **** 	/*-----------------------------------------------------------*/
 233:../../Source/tasks.c **** 
 234:../../Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()																			\
 235:../../Source/tasks.c **** 	{																													\
 236:../../Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */												\
 237:../../Source/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )										\
 238:../../Source/tasks.c **** 		{																												\
 239:../../Source/tasks.c **** 			configASSERT( uxTopReadyPriority );																			\
 240:../../Source/tasks.c **** 			--uxTopReadyPriority;																						\
 241:../../Source/tasks.c **** 		}																												\
 242:../../Source/tasks.c **** 																														\
 243:../../Source/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of										\
 244:../../Source/tasks.c **** 		the	same priority get an equal share of the processor time. */													\
 245:../../Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );						\
 246:../../Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
 247:../../Source/tasks.c **** 
 248:../../Source/tasks.c **** 	/*-----------------------------------------------------------*/
 249:../../Source/tasks.c **** 
 250:../../Source/tasks.c **** 	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
 251:../../Source/tasks.c **** 	they are only required when a port optimised method of task selection is
 252:../../Source/tasks.c **** 	being used. */
 253:../../Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )
 254:../../Source/tasks.c **** 	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
 255:../../Source/tasks.c **** 
 256:../../Source/tasks.c **** #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 257:../../Source/tasks.c **** 
 258:../../Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
 259:../../Source/tasks.c **** 	performed in a way that is tailored to the particular microcontroller
 260:../../Source/tasks.c **** 	architecture being used. */
 261:../../Source/tasks.c **** 
 262:../../Source/tasks.c **** 	/* A port optimised version is provided.  Call the port defined macros. */
 263:../../Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyP
 264:../../Source/tasks.c **** 
 265:../../Source/tasks.c **** 	/*-----------------------------------------------------------*/
 266:../../Source/tasks.c **** 
 267:../../Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
 268:../../Source/tasks.c **** 	{																								\
 269:../../Source/tasks.c **** 	unsigned portBASE_TYPE uxTopPriority;															\
 270:../../Source/tasks.c **** 																									\
 271:../../Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */							\
 272:../../Source/tasks.c **** 		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
 273:../../Source/tasks.c **** 		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
 274:../../Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
 275:../../Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
 276:../../Source/tasks.c **** 
 277:../../Source/tasks.c **** 	/*-----------------------------------------------------------*/
 278:../../Source/tasks.c **** 
 279:../../Source/tasks.c **** 	/* A port optimised version is provided, call it only if the TCB being reset
 280:../../Source/tasks.c **** 	is being referenced from a ready list.  If it is referenced from a delayed
 281:../../Source/tasks.c **** 	or suspended list then it won't be in a ready list. */
 282:../../Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )													\
 283:../../Source/tasks.c **** 	{																								\
 284:../../Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == 0 )				\
 285:../../Source/tasks.c **** 		{																							\
 286:../../Source/tasks.c **** 			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );						\
 287:../../Source/tasks.c **** 		}																							\
 288:../../Source/tasks.c **** 	}
 289:../../Source/tasks.c **** 
 290:../../Source/tasks.c **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 291:../../Source/tasks.c **** 
 292:../../Source/tasks.c **** /*
 293:../../Source/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready queue for
 294:../../Source/tasks.c ****  * the task.  It is inserted at the end of the list.  One quirk of this is
 295:../../Source/tasks.c ****  * that if the task being inserted is at the same priority as the currently
 296:../../Source/tasks.c ****  * executing task, then it will only be rescheduled after the currently
 297:../../Source/tasks.c ****  * executing task has been rescheduled.
 298:../../Source/tasks.c ****  */
 299:../../Source/tasks.c **** #define prvAddTaskToReadyQueue( pxTCB )																				\
 300:../../Source/tasks.c **** 	traceMOVED_TASK_TO_READY_STATE( pxTCB )																			\
 301:../../Source/tasks.c **** 	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );																\
 302:../../Source/tasks.c **** 	vListInsertEnd( ( xList * ) &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGeneri
 303:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 304:../../Source/tasks.c **** 
 305:../../Source/tasks.c **** /*
 306:../../Source/tasks.c ****  * Macro that looks at the list of tasks that are currently delayed to see if
 307:../../Source/tasks.c ****  * any require waking.
 308:../../Source/tasks.c ****  *
 309:../../Source/tasks.c ****  * Tasks are stored in the queue in the order of their wake time - meaning
 310:../../Source/tasks.c ****  * once one tasks has been found whose timer has not expired we need not look
 311:../../Source/tasks.c ****  * any further down the list.
 312:../../Source/tasks.c ****  */
 313:../../Source/tasks.c **** #define prvCheckDelayedTasks()															\
 314:../../Source/tasks.c **** {																						\
 315:../../Source/tasks.c **** portTickType xItemValue;																\
 316:../../Source/tasks.c **** 																						\
 317:../../Source/tasks.c **** 	/* Is the tick count greater than or equal to the wake time of the first			\
 318:../../Source/tasks.c **** 	task referenced from the delayed tasks list? */										\
 319:../../Source/tasks.c **** 	if( xTickCount >= xNextTaskUnblockTime )											\
 320:../../Source/tasks.c **** 	{																					\
 321:../../Source/tasks.c **** 		for( ;; )																		\
 322:../../Source/tasks.c **** 		{																				\
 323:../../Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )						\
 324:../../Source/tasks.c **** 			{																			\
 325:../../Source/tasks.c **** 				/* The delayed list is empty.  Set xNextTaskUnblockTime to the			\
 326:../../Source/tasks.c **** 				maximum possible value so it is extremely unlikely that the				\
 327:../../Source/tasks.c **** 				if( xTickCount >= xNextTaskUnblockTime ) test will pass next			\
 328:../../Source/tasks.c **** 				time through. */														\
 329:../../Source/tasks.c **** 				xNextTaskUnblockTime = portMAX_DELAY;									\
 330:../../Source/tasks.c **** 				break;																	\
 331:../../Source/tasks.c **** 			}																			\
 332:../../Source/tasks.c **** 			else																		\
 333:../../Source/tasks.c **** 			{																			\
 334:../../Source/tasks.c **** 				/* The delayed list is not empty, get the value of the item at			\
 335:../../Source/tasks.c **** 				the head of the delayed list.  This is the time at which the			\
 336:../../Source/tasks.c **** 				task at the head of the delayed list should be removed from				\
 337:../../Source/tasks.c **** 				the Blocked state. */													\
 338:../../Source/tasks.c **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );	\
 339:../../Source/tasks.c **** 				xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );	\
 340:../../Source/tasks.c **** 																						\
 341:../../Source/tasks.c **** 				if( xTickCount < xItemValue )											\
 342:../../Source/tasks.c **** 				{																		\
 343:../../Source/tasks.c **** 					/* It is not time to unblock this item yet, but the item			\
 344:../../Source/tasks.c **** 					value is the time at which the task at the head of the				\
 345:../../Source/tasks.c **** 					blocked list should be removed from the Blocked state -				\
 346:../../Source/tasks.c **** 					so record the item value in xNextTaskUnblockTime. */				\
 347:../../Source/tasks.c **** 					xNextTaskUnblockTime = xItemValue;									\
 348:../../Source/tasks.c **** 					break;																\
 349:../../Source/tasks.c **** 				}																		\
 350:../../Source/tasks.c **** 																						\
 351:../../Source/tasks.c **** 				/* It is time to remove the item from the Blocked state. */				\
 352:../../Source/tasks.c **** 				uxListRemove( &( pxTCB->xGenericListItem ) );							\
 353:../../Source/tasks.c **** 																						\
 354:../../Source/tasks.c **** 				/* Is the task waiting on an event also? */								\
 355:../../Source/tasks.c **** 				if( pxTCB->xEventListItem.pvContainer != NULL )							\
 356:../../Source/tasks.c **** 				{																		\
 357:../../Source/tasks.c **** 					uxListRemove( &( pxTCB->xEventListItem ) );							\
 358:../../Source/tasks.c **** 				}																		\
 359:../../Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );										\
 360:../../Source/tasks.c **** 			}																			\
 361:../../Source/tasks.c **** 		}																				\
 362:../../Source/tasks.c **** 	}																					\
 363:../../Source/tasks.c **** }
 364:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 365:../../Source/tasks.c **** 
 366:../../Source/tasks.c **** /*
 367:../../Source/tasks.c ****  * Several functions take an xTaskHandle parameter that can optionally be NULL,
 368:../../Source/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 369:../../Source/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 370:../../Source/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 371:../../Source/tasks.c ****  */
 372:../../Source/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( tskTCB * ) pxCurrentTCB : ( 
 373:../../Source/tasks.c **** 
 374:../../Source/tasks.c **** /* Callback function prototypes. --------------------------*/
 375:../../Source/tasks.c **** extern void vApplicationStackOverflowHook( xTaskHandle pxTask, signed char *pcTaskName ) __attribut
 376:../../Source/tasks.c **** extern void vApplicationTickHook( void );
 377:../../Source/tasks.c **** 
 378:../../Source/tasks.c **** /* File private functions. --------------------------------*/
 379:../../Source/tasks.c **** 
 380:../../Source/tasks.c **** /*
 381:../../Source/tasks.c ****  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
 382:../../Source/tasks.c ****  * into the TCB structure.
 383:../../Source/tasks.c ****  */
 384:../../Source/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
 385:../../Source/tasks.c **** 
 386:../../Source/tasks.c **** /*
 387:../../Source/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 388:../../Source/tasks.c ****  * automatically upon the creation of the first task.
 389:../../Source/tasks.c ****  */
 390:../../Source/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 391:../../Source/tasks.c **** 
 392:../../Source/tasks.c **** /*
 393:../../Source/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 394:../../Source/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 395:../../Source/tasks.c ****  * creation of the first user task.
 396:../../Source/tasks.c ****  *
 397:../../Source/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 398:../../Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 399:../../Source/tasks.c ****  *
 400:../../Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
 401:../../Source/tasks.c ****  *
 402:../../Source/tasks.c ****  */
 403:../../Source/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 404:../../Source/tasks.c **** 
 405:../../Source/tasks.c **** /*
 406:../../Source/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 407:../../Source/tasks.c ****  * including the stack pointed to by the TCB.
 408:../../Source/tasks.c ****  *
 409:../../Source/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 410:../../Source/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 411:../../Source/tasks.c ****  */
 412:../../Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 413:../../Source/tasks.c **** 
 414:../../Source/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB ) PRIVILEGED_FUNCTION;
 415:../../Source/tasks.c **** 
 416:../../Source/tasks.c **** #endif
 417:../../Source/tasks.c **** 
 418:../../Source/tasks.c **** /*
 419:../../Source/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 420:../../Source/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 421:../../Source/tasks.c ****  * and its TCB deleted.
 422:../../Source/tasks.c ****  */
 423:../../Source/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 424:../../Source/tasks.c **** 
 425:../../Source/tasks.c **** /*
 426:../../Source/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 427:../../Source/tasks.c ****  * either the current or the overflow delayed task list.
 428:../../Source/tasks.c ****  */
 429:../../Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake ) PRIVILEGED_FUNCTION;
 430:../../Source/tasks.c **** 
 431:../../Source/tasks.c **** /*
 432:../../Source/tasks.c ****  * Allocates memory from the heap for a TCB and associated stack.  Checks the
 433:../../Source/tasks.c ****  * allocation was successful.
 434:../../Source/tasks.c ****  */
 435:../../Source/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
 436:../../Source/tasks.c **** 
 437:../../Source/tasks.c **** /*
 438:../../Source/tasks.c ****  * Called from vTaskList.  vListTasks details all the tasks currently under
 439:../../Source/tasks.c ****  * control of the scheduler.  The tasks may be in one of a number of lists.
 440:../../Source/tasks.c ****  * prvListTaskWithinSingleList accepts a list and details the tasks from
 441:../../Source/tasks.c ****  * within just that list.
 442:../../Source/tasks.c ****  *
 443:../../Source/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 444:../../Source/tasks.c ****  * NORMAL APPLICATION CODE.
 445:../../Source/tasks.c ****  */
 446:../../Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 447:../../Source/tasks.c **** 
 448:../../Source/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
 449:../../Source/tasks.c **** 
 450:../../Source/tasks.c **** #endif
 451:../../Source/tasks.c **** 
 452:../../Source/tasks.c **** /*
 453:../../Source/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 454:../../Source/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 455:../../Source/tasks.c ****  * determining how much of the stack remains at the original preset value.
 456:../../Source/tasks.c ****  */
 457:../../Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 458:../../Source/tasks.c **** 
 459:../../Source/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte ) PRIVILEGED_F
 460:../../Source/tasks.c **** 
 461:../../Source/tasks.c **** #endif
 462:../../Source/tasks.c **** 
 463:../../Source/tasks.c **** /*
 464:../../Source/tasks.c ****  * Return the amount of time, in ticks, that will pass before the kernel will
 465:../../Source/tasks.c ****  * next move a task from the Blocked state to the Running state.
 466:../../Source/tasks.c ****  *
 467:../../Source/tasks.c ****  * This conditional compilation should use inequality to 0, not equality to 1.
 468:../../Source/tasks.c ****  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 469:../../Source/tasks.c ****  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 470:../../Source/tasks.c ****  * set to a value other than 1.
 471:../../Source/tasks.c ****  */
 472:../../Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
 473:../../Source/tasks.c **** 
 474:../../Source/tasks.c **** 	static portTickType prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
 475:../../Source/tasks.c **** 
 476:../../Source/tasks.c **** #endif
 477:../../Source/tasks.c **** 
 478:../../Source/tasks.c **** /*lint +e956 */
 479:../../Source/tasks.c **** 
 480:../../Source/tasks.c **** 
 481:../../Source/tasks.c **** 
 482:../../Source/tasks.c **** /*-----------------------------------------------------------
 483:../../Source/tasks.c ****  * TASK CREATION API documented in task.h
 484:../../Source/tasks.c ****  *----------------------------------------------------------*/
 485:../../Source/tasks.c **** 
 486:../../Source/tasks.c **** signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, 
 487:../../Source/tasks.c **** {
 488:../../Source/tasks.c **** signed portBASE_TYPE xReturn;
 489:../../Source/tasks.c **** tskTCB * pxNewTCB;
 490:../../Source/tasks.c **** 
 491:../../Source/tasks.c **** 	configASSERT( pxTaskCode );
 492:../../Source/tasks.c **** 	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
 493:../../Source/tasks.c **** 
 494:../../Source/tasks.c **** 	/* Allocate the memory required by the TCB and stack for the new task,
 495:../../Source/tasks.c **** 	checking that the allocation was successful. */
 496:../../Source/tasks.c **** 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 497:../../Source/tasks.c **** 
 498:../../Source/tasks.c **** 	if( pxNewTCB != NULL )
 499:../../Source/tasks.c **** 	{
 500:../../Source/tasks.c **** 		portSTACK_TYPE *pxTopOfStack;
 501:../../Source/tasks.c **** 
 502:../../Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 503:../../Source/tasks.c **** 			/* Should the task be created in privileged mode? */
 504:../../Source/tasks.c **** 			portBASE_TYPE xRunPrivileged;
 505:../../Source/tasks.c **** 			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 506:../../Source/tasks.c **** 			{
 507:../../Source/tasks.c **** 				xRunPrivileged = pdTRUE;
 508:../../Source/tasks.c **** 			}
 509:../../Source/tasks.c **** 			else
 510:../../Source/tasks.c **** 			{
 511:../../Source/tasks.c **** 				xRunPrivileged = pdFALSE;
 512:../../Source/tasks.c **** 			}
 513:../../Source/tasks.c **** 			uxPriority &= ~portPRIVILEGE_BIT;
 514:../../Source/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS == 1 */
 515:../../Source/tasks.c **** 
 516:../../Source/tasks.c **** 		/* Calculate the top of stack address.  This depends on whether the
 517:../../Source/tasks.c **** 		stack grows from high memory to low (as per the 80x86) or visa versa.
 518:../../Source/tasks.c **** 		portSTACK_GROWTH is used to make the result positive or negative as
 519:../../Source/tasks.c **** 		required by the port. */
 520:../../Source/tasks.c **** 		#if( portSTACK_GROWTH < 0 )
 521:../../Source/tasks.c **** 		{
 522:../../Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 523:../../Source/tasks.c **** 			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINT
 524:../../Source/tasks.c **** 
 525:../../Source/tasks.c **** 			/* Check the alignment of the calculated top of stack is correct. */
 526:../../Source/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) =
 527:../../Source/tasks.c **** 		}
 528:../../Source/tasks.c **** 		#else
 529:../../Source/tasks.c **** 		{
 530:../../Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack;
 531:../../Source/tasks.c **** 
 532:../../Source/tasks.c **** 			/* Check the alignment of the stack buffer is correct. */
 533:../../Source/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxNewTCB->pxStack & ( unsigned long ) portBYTE_ALIGNMENT_MAS
 534:../../Source/tasks.c **** 
 535:../../Source/tasks.c **** 			/* If we want to use stack checking on architectures that use
 536:../../Source/tasks.c **** 			a positive stack growth direction then we also need to store the
 537:../../Source/tasks.c **** 			other extreme of the stack space. */
 538:../../Source/tasks.c **** 			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 539:../../Source/tasks.c **** 		}
 540:../../Source/tasks.c **** 		#endif
 541:../../Source/tasks.c **** 
 542:../../Source/tasks.c **** 		/* Setup the newly allocated TCB with the initial state of the task. */
 543:../../Source/tasks.c **** 		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 544:../../Source/tasks.c **** 
 545:../../Source/tasks.c **** 		/* Initialize the TCB stack to look as if the task was already running,
 546:../../Source/tasks.c **** 		but had been interrupted by the scheduler.  The return address is set
 547:../../Source/tasks.c **** 		to the start of the task function. Once the stack has been initialised
 548:../../Source/tasks.c **** 		the	top of stack variable is updated. */
 549:../../Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 550:../../Source/tasks.c **** 		{
 551:../../Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
 552:../../Source/tasks.c **** 		}
 553:../../Source/tasks.c **** 		#else
 554:../../Source/tasks.c **** 		{
 555:../../Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 556:../../Source/tasks.c **** 		}
 557:../../Source/tasks.c **** 		#endif
 558:../../Source/tasks.c **** 
 559:../../Source/tasks.c **** 		/* Check the alignment of the initialised stack. */
 560:../../Source/tasks.c **** 		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long
 561:../../Source/tasks.c **** 
 562:../../Source/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 563:../../Source/tasks.c **** 		{
 564:../../Source/tasks.c **** 			/* Pass the TCB out - in an anonymous way.  The calling function/
 565:../../Source/tasks.c **** 			task can use this as a handle to delete the task later if
 566:../../Source/tasks.c **** 			required.*/
 567:../../Source/tasks.c **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 568:../../Source/tasks.c **** 		}
 569:../../Source/tasks.c **** 
 570:../../Source/tasks.c **** 		/* We are going to manipulate the task queues to add this task to a
 571:../../Source/tasks.c **** 		ready list, so must make sure no interrupts occur. */
 572:../../Source/tasks.c **** 		taskENTER_CRITICAL();
 573:../../Source/tasks.c **** 		{
 574:../../Source/tasks.c **** 			uxCurrentNumberOfTasks++;
 575:../../Source/tasks.c **** 			if( pxCurrentTCB == NULL )
 576:../../Source/tasks.c **** 			{
 577:../../Source/tasks.c **** 				/* There are no other tasks, or all the other tasks are in
 578:../../Source/tasks.c **** 				the suspended state - make this the current task. */
 579:../../Source/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 580:../../Source/tasks.c **** 
 581:../../Source/tasks.c **** 				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 582:../../Source/tasks.c **** 				{
 583:../../Source/tasks.c **** 					/* This is the first task to be created so do the preliminary
 584:../../Source/tasks.c **** 					initialisation required.  We will not recover if this call
 585:../../Source/tasks.c **** 					fails, but we will report the failure. */
 586:../../Source/tasks.c **** 					prvInitialiseTaskLists();
 587:../../Source/tasks.c **** 				}
 588:../../Source/tasks.c **** 			}
 589:../../Source/tasks.c **** 			else
 590:../../Source/tasks.c **** 			{
 591:../../Source/tasks.c **** 				/* If the scheduler is not already running, make this task the
 592:../../Source/tasks.c **** 				current task if it is the highest priority task to be created
 593:../../Source/tasks.c **** 				so far. */
 594:../../Source/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 595:../../Source/tasks.c **** 				{
 596:../../Source/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 597:../../Source/tasks.c **** 					{
 598:../../Source/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 599:../../Source/tasks.c **** 					}
 600:../../Source/tasks.c **** 				}
 601:../../Source/tasks.c **** 			}
 602:../../Source/tasks.c **** 
 603:../../Source/tasks.c **** 			/* Remember the top priority to make context switching faster.  Use
 604:../../Source/tasks.c **** 			the priority in pxNewTCB as this has been capped to a valid value. */
 605:../../Source/tasks.c **** 			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 606:../../Source/tasks.c **** 			{
 607:../../Source/tasks.c **** 				uxTopUsedPriority = pxNewTCB->uxPriority;
 608:../../Source/tasks.c **** 			}
 609:../../Source/tasks.c **** 
 610:../../Source/tasks.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 611:../../Source/tasks.c **** 			{
 612:../../Source/tasks.c **** 				/* Add a counter into the TCB for tracing only. */
 613:../../Source/tasks.c **** 				pxNewTCB->uxTCBNumber = uxTaskNumber;
 614:../../Source/tasks.c **** 			}
 615:../../Source/tasks.c **** 			#endif
 616:../../Source/tasks.c **** 			uxTaskNumber++;
 617:../../Source/tasks.c **** 
 618:../../Source/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 619:../../Source/tasks.c **** 
 620:../../Source/tasks.c **** 			xReturn = pdPASS;
 621:../../Source/tasks.c **** 			portSETUP_TCB( pxNewTCB );
 622:../../Source/tasks.c **** 			traceTASK_CREATE( pxNewTCB );
 623:../../Source/tasks.c **** 		}
 624:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
 625:../../Source/tasks.c **** 	}
 626:../../Source/tasks.c **** 	else
 627:../../Source/tasks.c **** 	{
 628:../../Source/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 629:../../Source/tasks.c **** 		traceTASK_CREATE_FAILED();
 630:../../Source/tasks.c **** 	}
 631:../../Source/tasks.c **** 
 632:../../Source/tasks.c **** 	if( xReturn == pdPASS )
 633:../../Source/tasks.c **** 	{
 634:../../Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 635:../../Source/tasks.c **** 		{
 636:../../Source/tasks.c **** 			/* If the created task is of a higher priority than the current task
 637:../../Source/tasks.c **** 			then it should run now. */
 638:../../Source/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 639:../../Source/tasks.c **** 			{
 640:../../Source/tasks.c **** 				portYIELD_WITHIN_API();
 641:../../Source/tasks.c **** 			}
 642:../../Source/tasks.c **** 		}
 643:../../Source/tasks.c **** 	}
 644:../../Source/tasks.c **** 
 645:../../Source/tasks.c **** 	return xReturn;
 646:../../Source/tasks.c **** }
 647:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 648:../../Source/tasks.c **** 
 649:../../Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 650:../../Source/tasks.c **** 
 651:../../Source/tasks.c **** 	void vTaskDelete( xTaskHandle pxTaskToDelete )
 652:../../Source/tasks.c **** 	{
 653:../../Source/tasks.c **** 	tskTCB *pxTCB;
 654:../../Source/tasks.c **** 
 655:../../Source/tasks.c **** 		taskENTER_CRITICAL();
 656:../../Source/tasks.c **** 		{
 657:../../Source/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 658:../../Source/tasks.c **** 			deleted. */
 659:../../Source/tasks.c **** 			if( pxTaskToDelete == pxCurrentTCB )
 660:../../Source/tasks.c **** 			{
 661:../../Source/tasks.c **** 				pxTaskToDelete = NULL;
 662:../../Source/tasks.c **** 			}
 663:../../Source/tasks.c **** 
 664:../../Source/tasks.c **** 			/* If null is passed in here then we are deleting ourselves. */
 665:../../Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
 666:../../Source/tasks.c **** 
 667:../../Source/tasks.c **** 			/* Remove task from the ready list and place in the	termination list.
 668:../../Source/tasks.c **** 			This will stop the task from be scheduled.  The idle task will check
 669:../../Source/tasks.c **** 			the termination list and free up any memory allocated by the
 670:../../Source/tasks.c **** 			scheduler for the TCB and stack. */
 671:../../Source/tasks.c **** 			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
 672:../../Source/tasks.c **** 			{
 673:../../Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 674:../../Source/tasks.c **** 			}
 675:../../Source/tasks.c **** 
 676:../../Source/tasks.c **** 			/* Is the task waiting on an event also? */
 677:../../Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 678:../../Source/tasks.c **** 			{
 679:../../Source/tasks.c **** 				uxListRemove( &( pxTCB->xEventListItem ) );
 680:../../Source/tasks.c **** 			}
 681:../../Source/tasks.c **** 
 682:../../Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 683:../../Source/tasks.c **** 
 684:../../Source/tasks.c **** 			/* Increment the ucTasksDeleted variable so the idle task knows
 685:../../Source/tasks.c **** 			there is a task that has been deleted and that it should therefore
 686:../../Source/tasks.c **** 			check the xTasksWaitingTermination list. */
 687:../../Source/tasks.c **** 			++uxTasksDeleted;
 688:../../Source/tasks.c **** 
 689:../../Source/tasks.c **** 			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
 690:../../Source/tasks.c **** 			can detect that the task lists need re-generating. */
 691:../../Source/tasks.c **** 			uxTaskNumber++;
 692:../../Source/tasks.c **** 
 693:../../Source/tasks.c **** 			traceTASK_DELETE( pxTCB );
 694:../../Source/tasks.c **** 		}
 695:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
 696:../../Source/tasks.c **** 
 697:../../Source/tasks.c **** 		/* Force a reschedule if we have just deleted the current task. */
 698:../../Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 699:../../Source/tasks.c **** 		{
 700:../../Source/tasks.c **** 			if( ( void * ) pxTaskToDelete == NULL )
 701:../../Source/tasks.c **** 			{
 702:../../Source/tasks.c **** 				portYIELD_WITHIN_API();
 703:../../Source/tasks.c **** 			}
 704:../../Source/tasks.c **** 		}
 705:../../Source/tasks.c **** 	}
 706:../../Source/tasks.c **** 
 707:../../Source/tasks.c **** #endif
 708:../../Source/tasks.c **** 
 709:../../Source/tasks.c **** 
 710:../../Source/tasks.c **** 
 711:../../Source/tasks.c **** 
 712:../../Source/tasks.c **** 
 713:../../Source/tasks.c **** 
 714:../../Source/tasks.c **** /*-----------------------------------------------------------
 715:../../Source/tasks.c ****  * TASK CONTROL API documented in task.h
 716:../../Source/tasks.c ****  *----------------------------------------------------------*/
 717:../../Source/tasks.c **** 
 718:../../Source/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
 719:../../Source/tasks.c **** 
 720:../../Source/tasks.c **** 	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
 721:../../Source/tasks.c **** 	{
 722:../../Source/tasks.c **** 	portTickType xTimeToWake;
 723:../../Source/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 724:../../Source/tasks.c **** 
 725:../../Source/tasks.c **** 		configASSERT( pxPreviousWakeTime );
 726:../../Source/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
 727:../../Source/tasks.c **** 
 728:../../Source/tasks.c **** 		vTaskSuspendAll();
 729:../../Source/tasks.c **** 		{
 730:../../Source/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
 731:../../Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 732:../../Source/tasks.c **** 
 733:../../Source/tasks.c **** 			if( xTickCount < *pxPreviousWakeTime )
 734:../../Source/tasks.c **** 			{
 735:../../Source/tasks.c **** 				/* The tick count has overflowed since this function was
 736:../../Source/tasks.c **** 				lasted called.  In this case the only time we should ever
 737:../../Source/tasks.c **** 				actually delay is if the wake time has also	overflowed,
 738:../../Source/tasks.c **** 				and the wake time is greater than the tick time.  When this
 739:../../Source/tasks.c **** 				is the case it is as if neither time had overflowed. */
 740:../../Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 741:../../Source/tasks.c **** 				{
 742:../../Source/tasks.c **** 					xShouldDelay = pdTRUE;
 743:../../Source/tasks.c **** 				}
 744:../../Source/tasks.c **** 			}
 745:../../Source/tasks.c **** 			else
 746:../../Source/tasks.c **** 			{
 747:../../Source/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
 748:../../Source/tasks.c **** 				delay if either the wake time has overflowed, and/or the
 749:../../Source/tasks.c **** 				tick time is less than the wake time. */
 750:../../Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 751:../../Source/tasks.c **** 				{
 752:../../Source/tasks.c **** 					xShouldDelay = pdTRUE;
 753:../../Source/tasks.c **** 				}
 754:../../Source/tasks.c **** 			}
 755:../../Source/tasks.c **** 
 756:../../Source/tasks.c **** 			/* Update the wake time ready for the next call. */
 757:../../Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 758:../../Source/tasks.c **** 
 759:../../Source/tasks.c **** 			if( xShouldDelay != pdFALSE )
 760:../../Source/tasks.c **** 			{
 761:../../Source/tasks.c **** 				traceTASK_DELAY_UNTIL();
 762:../../Source/tasks.c **** 
 763:../../Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 764:../../Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 765:../../Source/tasks.c **** 				both lists. */
 766:../../Source/tasks.c **** 				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
 767:../../Source/tasks.c **** 				{
 768:../../Source/tasks.c **** 					/* The current task must be in a ready list, so there is
 769:../../Source/tasks.c **** 					no need to check, and the port reset macro can be called
 770:../../Source/tasks.c **** 					directly. */
 771:../../Source/tasks.c **** 					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 772:../../Source/tasks.c **** 				}
 773:../../Source/tasks.c **** 
 774:../../Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 775:../../Source/tasks.c **** 			}
 776:../../Source/tasks.c **** 		}
 777:../../Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 778:../../Source/tasks.c **** 
 779:../../Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 780:../../Source/tasks.c **** 		have put ourselves to sleep. */
 781:../../Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 782:../../Source/tasks.c **** 		{
 783:../../Source/tasks.c **** 			portYIELD_WITHIN_API();
 784:../../Source/tasks.c **** 		}
 785:../../Source/tasks.c **** 	}
 786:../../Source/tasks.c **** 
 787:../../Source/tasks.c **** #endif
 788:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 789:../../Source/tasks.c **** 
 790:../../Source/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
 791:../../Source/tasks.c **** 
 792:../../Source/tasks.c **** 	void vTaskDelay( portTickType xTicksToDelay )
 793:../../Source/tasks.c **** 	{
 794:../../Source/tasks.c **** 	portTickType xTimeToWake;
 795:../../Source/tasks.c **** 	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 796:../../Source/tasks.c **** 
 797:../../Source/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
 798:../../Source/tasks.c **** 		if( xTicksToDelay > ( portTickType ) 0U )
 799:../../Source/tasks.c **** 		{
 800:../../Source/tasks.c **** 			vTaskSuspendAll();
 801:../../Source/tasks.c **** 			{
 802:../../Source/tasks.c **** 				traceTASK_DELAY();
 803:../../Source/tasks.c **** 
 804:../../Source/tasks.c **** 				/* A task that is removed from the event list while the
 805:../../Source/tasks.c **** 				scheduler is suspended will not get placed in the ready
 806:../../Source/tasks.c **** 				list or removed from the blocked list until the scheduler
 807:../../Source/tasks.c **** 				is resumed.
 808:../../Source/tasks.c **** 
 809:../../Source/tasks.c **** 				This task cannot be in an event list as it is the currently
 810:../../Source/tasks.c **** 				executing task. */
 811:../../Source/tasks.c **** 
 812:../../Source/tasks.c **** 				/* Calculate the time to wake - this may overflow but this is
 813:../../Source/tasks.c **** 				not a problem. */
 814:../../Source/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 815:../../Source/tasks.c **** 
 816:../../Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 817:../../Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 818:../../Source/tasks.c **** 				both lists. */
 819:../../Source/tasks.c **** 				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
 820:../../Source/tasks.c **** 				{
 821:../../Source/tasks.c **** 					/* The current task must be in a ready list, so there is
 822:../../Source/tasks.c **** 					no need to check, and the port reset macro can be called
 823:../../Source/tasks.c **** 					directly. */
 824:../../Source/tasks.c **** 					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 825:../../Source/tasks.c **** 				}
 826:../../Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 827:../../Source/tasks.c **** 			}
 828:../../Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 829:../../Source/tasks.c **** 		}
 830:../../Source/tasks.c **** 
 831:../../Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 832:../../Source/tasks.c **** 		have put ourselves to sleep. */
 833:../../Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 834:../../Source/tasks.c **** 		{
 835:../../Source/tasks.c **** 			portYIELD_WITHIN_API();
 836:../../Source/tasks.c **** 		}
 837:../../Source/tasks.c **** 	}
 838:../../Source/tasks.c **** 
 839:../../Source/tasks.c **** #endif
 840:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 841:../../Source/tasks.c **** 
 842:../../Source/tasks.c **** #if ( INCLUDE_eTaskStateGet == 1 )
 843:../../Source/tasks.c **** 
 844:../../Source/tasks.c **** 	eTaskState eTaskStateGet( xTaskHandle pxTask )
 845:../../Source/tasks.c **** 	{
 846:../../Source/tasks.c **** 	eTaskState eReturn;
 847:../../Source/tasks.c **** 	xList *pxStateList;
 848:../../Source/tasks.c **** 	tskTCB *pxTCB;
 849:../../Source/tasks.c **** 
 850:../../Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTask;
 851:../../Source/tasks.c **** 
 852:../../Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
 853:../../Source/tasks.c **** 		{
 854:../../Source/tasks.c **** 			/* The task calling this function is querying its own state. */
 855:../../Source/tasks.c **** 			eReturn = eRunning;
 856:../../Source/tasks.c **** 		}
 857:../../Source/tasks.c **** 		else
 858:../../Source/tasks.c **** 		{
 859:../../Source/tasks.c **** 			taskENTER_CRITICAL();
 860:../../Source/tasks.c **** 			{
 861:../../Source/tasks.c **** 				pxStateList = ( xList * ) listLIST_ITEM_CONTAINER( &( pxTCB->xGenericListItem ) );
 862:../../Source/tasks.c **** 			}
 863:../../Source/tasks.c **** 			taskEXIT_CRITICAL();
 864:../../Source/tasks.c **** 
 865:../../Source/tasks.c **** 			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
 866:../../Source/tasks.c **** 			{
 867:../../Source/tasks.c **** 				/* The task being queried is referenced from one of the Blocked
 868:../../Source/tasks.c **** 				lists. */
 869:../../Source/tasks.c **** 				eReturn = eBlocked;
 870:../../Source/tasks.c **** 			}
 871:../../Source/tasks.c **** 
 872:../../Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
 873:../../Source/tasks.c **** 				else if( pxStateList == &xSuspendedTaskList )
 874:../../Source/tasks.c **** 				{
 875:../../Source/tasks.c **** 					/* The task being queried is referenced from the suspended
 876:../../Source/tasks.c **** 					list. */
 877:../../Source/tasks.c **** 					eReturn = eSuspended;
 878:../../Source/tasks.c **** 				}
 879:../../Source/tasks.c **** 			#endif
 880:../../Source/tasks.c **** 
 881:../../Source/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
 882:../../Source/tasks.c **** 				else if( pxStateList == &xTasksWaitingTermination )
 883:../../Source/tasks.c **** 				{
 884:../../Source/tasks.c **** 					/* The task being queried is referenced from the deleted
 885:../../Source/tasks.c **** 					tasks list. */
 886:../../Source/tasks.c **** 					eReturn = eDeleted;
 887:../../Source/tasks.c **** 				}
 888:../../Source/tasks.c **** 			#endif
 889:../../Source/tasks.c **** 
 890:../../Source/tasks.c **** 			else
 891:../../Source/tasks.c **** 			{
 892:../../Source/tasks.c **** 				/* If the task is not in any other state, it must be in the
 893:../../Source/tasks.c **** 				Ready (including pending ready) state. */
 894:../../Source/tasks.c **** 				eReturn = eReady;
 895:../../Source/tasks.c **** 			}
 896:../../Source/tasks.c **** 		}
 897:../../Source/tasks.c **** 
 898:../../Source/tasks.c **** 		return eReturn;
 899:../../Source/tasks.c **** 	}
 900:../../Source/tasks.c **** 
 901:../../Source/tasks.c **** #endif
 902:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 903:../../Source/tasks.c **** 
 904:../../Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
 905:../../Source/tasks.c **** 
 906:../../Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
 907:../../Source/tasks.c **** 	{
 908:../../Source/tasks.c **** 	tskTCB *pxTCB;
 909:../../Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
 910:../../Source/tasks.c **** 
 911:../../Source/tasks.c **** 		taskENTER_CRITICAL();
 912:../../Source/tasks.c **** 		{
 913:../../Source/tasks.c **** 			/* If null is passed in here then we are changing the
 914:../../Source/tasks.c **** 			priority of the calling function. */
 915:../../Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 916:../../Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 917:../../Source/tasks.c **** 		}
 918:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
 919:../../Source/tasks.c **** 
 920:../../Source/tasks.c **** 		return uxReturn;
 921:../../Source/tasks.c **** 	}
 922:../../Source/tasks.c **** 
 923:../../Source/tasks.c **** #endif
 924:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 925:../../Source/tasks.c **** 
 926:../../Source/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
 927:../../Source/tasks.c **** 
 928:../../Source/tasks.c **** 	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
 929:../../Source/tasks.c **** 	{
 930:../../Source/tasks.c **** 	tskTCB *pxTCB;
 931:../../Source/tasks.c **** 	unsigned portBASE_TYPE uxCurrentPriority, uxPriorityUsedOnEntry;
 932:../../Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 933:../../Source/tasks.c **** 
 934:../../Source/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 935:../../Source/tasks.c **** 
 936:../../Source/tasks.c **** 		/* Ensure the new priority is valid. */
 937:../../Source/tasks.c **** 		if( uxNewPriority >= configMAX_PRIORITIES )
 938:../../Source/tasks.c **** 		{
 939:../../Source/tasks.c **** 			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 940:../../Source/tasks.c **** 		}
 941:../../Source/tasks.c **** 
 942:../../Source/tasks.c **** 		taskENTER_CRITICAL();
 943:../../Source/tasks.c **** 		{
 944:../../Source/tasks.c **** 			if( pxTask == pxCurrentTCB )
 945:../../Source/tasks.c **** 			{
 946:../../Source/tasks.c **** 				pxTask = NULL;
 947:../../Source/tasks.c **** 			}
 948:../../Source/tasks.c **** 
 949:../../Source/tasks.c **** 			/* If null is passed in here then we are changing the
 950:../../Source/tasks.c **** 			priority of the calling function. */
 951:../../Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 952:../../Source/tasks.c **** 
 953:../../Source/tasks.c **** 			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
 954:../../Source/tasks.c **** 
 955:../../Source/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
 956:../../Source/tasks.c **** 			{
 957:../../Source/tasks.c **** 				uxCurrentPriority = pxTCB->uxBasePriority;
 958:../../Source/tasks.c **** 			}
 959:../../Source/tasks.c **** 			#else
 960:../../Source/tasks.c **** 			{
 961:../../Source/tasks.c **** 				uxCurrentPriority = pxTCB->uxPriority;
 962:../../Source/tasks.c **** 			}
 963:../../Source/tasks.c **** 			#endif
 964:../../Source/tasks.c **** 
 965:../../Source/tasks.c **** 			if( uxCurrentPriority != uxNewPriority )
 966:../../Source/tasks.c **** 			{
 967:../../Source/tasks.c **** 				/* The priority change may have readied a task of higher
 968:../../Source/tasks.c **** 				priority than the calling task. */
 969:../../Source/tasks.c **** 				if( uxNewPriority > uxCurrentPriority )
 970:../../Source/tasks.c **** 				{
 971:../../Source/tasks.c **** 					if( pxTask != NULL )
 972:../../Source/tasks.c **** 					{
 973:../../Source/tasks.c **** 						/* The priority of another task is being raised.  If we
 974:../../Source/tasks.c **** 						were raising the priority of the currently running task
 975:../../Source/tasks.c **** 						there would be no need to switch as it must have already
 976:../../Source/tasks.c **** 						been the highest priority task. */
 977:../../Source/tasks.c **** 						xYieldRequired = pdTRUE;
 978:../../Source/tasks.c **** 					}
 979:../../Source/tasks.c **** 				}
 980:../../Source/tasks.c **** 				else if( pxTask == NULL )
 981:../../Source/tasks.c **** 				{
 982:../../Source/tasks.c **** 					/* Setting our own priority down means there may now be another
 983:../../Source/tasks.c **** 					task of higher priority that is ready to execute. */
 984:../../Source/tasks.c **** 					xYieldRequired = pdTRUE;
 985:../../Source/tasks.c **** 				}
 986:../../Source/tasks.c **** 
 987:../../Source/tasks.c **** 				/* Remember the ready list the task might be referenced from
 988:../../Source/tasks.c **** 				before its uxPriority member is changed so the
 989:../../Source/tasks.c **** 				taskRESET_READY_PRIORITY() macro can function correctly. */
 990:../../Source/tasks.c **** 				uxPriorityUsedOnEntry = pxTCB->uxPriority;
 991:../../Source/tasks.c **** 
 992:../../Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
 993:../../Source/tasks.c **** 				{
 994:../../Source/tasks.c **** 					/* Only change the priority being used if the task is not
 995:../../Source/tasks.c **** 					currently using an inherited priority. */
 996:../../Source/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 997:../../Source/tasks.c **** 					{
 998:../../Source/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
 999:../../Source/tasks.c **** 					}
1000:../../Source/tasks.c **** 
1001:../../Source/tasks.c **** 					/* The base priority gets set whatever. */
1002:../../Source/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
1003:../../Source/tasks.c **** 				}
1004:../../Source/tasks.c **** 				#else
1005:../../Source/tasks.c **** 				{
1006:../../Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
1007:../../Source/tasks.c **** 				}
1008:../../Source/tasks.c **** 				#endif
1009:../../Source/tasks.c **** 
1010:../../Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) 
1011:../../Source/tasks.c **** 
1012:../../Source/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
1013:../../Source/tasks.c **** 				nothing more than change it's priority variable. However, if
1014:../../Source/tasks.c **** 				the task is in a ready list it needs to be removed and placed
1015:../../Source/tasks.c **** 				in the queue appropriate to its new priority. */
1016:../../Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericLis
1017:../../Source/tasks.c **** 				{
1018:../../Source/tasks.c **** 					/* The task is currently in its ready list - remove before adding
1019:../../Source/tasks.c **** 					it to it's new ready list.  As we are in a critical section we
1020:../../Source/tasks.c **** 					can do this even if the scheduler is suspended. */
1021:../../Source/tasks.c **** 					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
1022:../../Source/tasks.c **** 					{
1023:../../Source/tasks.c **** 						taskRESET_READY_PRIORITY( uxPriorityUsedOnEntry );
1024:../../Source/tasks.c **** 					}
1025:../../Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
1026:../../Source/tasks.c **** 				}
1027:../../Source/tasks.c **** 
1028:../../Source/tasks.c **** 				if( xYieldRequired == pdTRUE )
1029:../../Source/tasks.c **** 				{
1030:../../Source/tasks.c **** 					portYIELD_WITHIN_API();
1031:../../Source/tasks.c **** 				}
1032:../../Source/tasks.c **** 			}
1033:../../Source/tasks.c **** 		}
1034:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
1035:../../Source/tasks.c **** 
1036:../../Source/tasks.c **** 		/* Remove compiler warning about unused parameter when the port
1037:../../Source/tasks.c **** 		optimised task selection is not being used. */
1038:../../Source/tasks.c **** 		( void ) uxPriorityUsedOnEntry;
1039:../../Source/tasks.c **** 	}
1040:../../Source/tasks.c **** 
1041:../../Source/tasks.c **** #endif
1042:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1043:../../Source/tasks.c **** 
1044:../../Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1045:../../Source/tasks.c **** 
1046:../../Source/tasks.c **** 	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
1047:../../Source/tasks.c **** 	{
1048:../../Source/tasks.c **** 	tskTCB *pxTCB;
1049:../../Source/tasks.c **** 
1050:../../Source/tasks.c **** 		taskENTER_CRITICAL();
1051:../../Source/tasks.c **** 		{
1052:../../Source/tasks.c **** 			/* Ensure a yield is performed if the current task is being
1053:../../Source/tasks.c **** 			suspended. */
1054:../../Source/tasks.c **** 			if( pxTaskToSuspend == pxCurrentTCB )
1055:../../Source/tasks.c **** 			{
1056:../../Source/tasks.c **** 				pxTaskToSuspend = NULL;
1057:../../Source/tasks.c **** 			}
1058:../../Source/tasks.c **** 
1059:../../Source/tasks.c **** 			/* If null is passed in here then we are suspending ourselves. */
1060:../../Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
1061:../../Source/tasks.c **** 
1062:../../Source/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
1063:../../Source/tasks.c **** 
1064:../../Source/tasks.c **** 			/* Remove task from the ready/delayed list and place in the	suspended list. */
1065:../../Source/tasks.c **** 			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
1066:../../Source/tasks.c **** 			{
1067:../../Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1068:../../Source/tasks.c **** 			}
1069:../../Source/tasks.c **** 
1070:../../Source/tasks.c **** 			/* Is the task waiting on an event also? */
1071:../../Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
1072:../../Source/tasks.c **** 			{
1073:../../Source/tasks.c **** 				uxListRemove( &( pxTCB->xEventListItem ) );
1074:../../Source/tasks.c **** 			}
1075:../../Source/tasks.c **** 
1076:../../Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
1077:../../Source/tasks.c **** 		}
1078:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
1079:../../Source/tasks.c **** 
1080:../../Source/tasks.c **** 		if( ( void * ) pxTaskToSuspend == NULL )
1081:../../Source/tasks.c **** 		{
1082:../../Source/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
1083:../../Source/tasks.c **** 			{
1084:../../Source/tasks.c **** 				/* We have just suspended the current task. */
1085:../../Source/tasks.c **** 				portYIELD_WITHIN_API();
1086:../../Source/tasks.c **** 			}
1087:../../Source/tasks.c **** 			else
1088:../../Source/tasks.c **** 			{
1089:../../Source/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
1090:../../Source/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
1091:../../Source/tasks.c **** 				must be adjusted to point to a different task. */
1092:../../Source/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
1093:../../Source/tasks.c **** 				{
1094:../../Source/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
1095:../../Source/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
1096:../../Source/tasks.c **** 					be set to point to it no matter what its relative priority
1097:../../Source/tasks.c **** 					is. */
1098:../../Source/tasks.c **** 					pxCurrentTCB = NULL;
1099:../../Source/tasks.c **** 				}
1100:../../Source/tasks.c **** 				else
1101:../../Source/tasks.c **** 				{
1102:../../Source/tasks.c **** 					vTaskSwitchContext();
1103:../../Source/tasks.c **** 				}
1104:../../Source/tasks.c **** 			}
1105:../../Source/tasks.c **** 		}
1106:../../Source/tasks.c **** 	}
1107:../../Source/tasks.c **** 
1108:../../Source/tasks.c **** #endif
1109:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1110:../../Source/tasks.c **** 
1111:../../Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1112:../../Source/tasks.c **** 
1113:../../Source/tasks.c **** 	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
1114:../../Source/tasks.c **** 	{
1115:../../Source/tasks.c **** 	portBASE_TYPE xReturn = pdFALSE;
1116:../../Source/tasks.c **** 	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
1117:../../Source/tasks.c **** 
1118:../../Source/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
1119:../../Source/tasks.c **** 		configASSERT( xTask );
1120:../../Source/tasks.c **** 
1121:../../Source/tasks.c **** 		/* Is the task we are attempting to resume actually in the
1122:../../Source/tasks.c **** 		suspended list? */
1123:../../Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
1124:../../Source/tasks.c **** 		{
1125:../../Source/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
1126:../../Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
1127:../../Source/tasks.c **** 			{
1128:../../Source/tasks.c **** 				/* Is it in the suspended list because it is in the
1129:../../Source/tasks.c **** 				Suspended state?  It is possible to be in the suspended
1130:../../Source/tasks.c **** 				list because it is blocked on a task with no timeout
1131:../../Source/tasks.c **** 				specified. */
1132:../../Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
1133:../../Source/tasks.c **** 				{
1134:../../Source/tasks.c **** 					xReturn = pdTRUE;
1135:../../Source/tasks.c **** 				}
1136:../../Source/tasks.c **** 			}
1137:../../Source/tasks.c **** 		}
1138:../../Source/tasks.c **** 
1139:../../Source/tasks.c **** 		return xReturn;
1140:../../Source/tasks.c **** 	}
1141:../../Source/tasks.c **** 
1142:../../Source/tasks.c **** #endif
1143:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1144:../../Source/tasks.c **** 
1145:../../Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1146:../../Source/tasks.c **** 
1147:../../Source/tasks.c **** 	void vTaskResume( xTaskHandle pxTaskToResume )
1148:../../Source/tasks.c **** 	{
1149:../../Source/tasks.c **** 	tskTCB *pxTCB;
1150:../../Source/tasks.c **** 
1151:../../Source/tasks.c **** 		/* It does not make sense to resume the calling task. */
1152:../../Source/tasks.c **** 		configASSERT( pxTaskToResume );
1153:../../Source/tasks.c **** 
1154:../../Source/tasks.c **** 		/* Remove the task from whichever list it is currently in, and place
1155:../../Source/tasks.c **** 		it in the ready list. */
1156:../../Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
1157:../../Source/tasks.c **** 
1158:../../Source/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
1159:../../Source/tasks.c **** 		currently executing task. */
1160:../../Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
1161:../../Source/tasks.c **** 		{
1162:../../Source/tasks.c **** 			taskENTER_CRITICAL();
1163:../../Source/tasks.c **** 			{
1164:../../Source/tasks.c **** 				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
1165:../../Source/tasks.c **** 				{
1166:../../Source/tasks.c **** 					traceTASK_RESUME( pxTCB );
1167:../../Source/tasks.c **** 
1168:../../Source/tasks.c **** 					/* As we are in a critical section we can access the ready
1169:../../Source/tasks.c **** 					lists even if the scheduler is suspended. */
1170:../../Source/tasks.c **** 					uxListRemove(  &( pxTCB->xGenericListItem ) );
1171:../../Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
1172:../../Source/tasks.c **** 
1173:../../Source/tasks.c **** 					/* We may have just resumed a higher priority task. */
1174:../../Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1175:../../Source/tasks.c **** 					{
1176:../../Source/tasks.c **** 						/* This yield may not cause the task just resumed to run, but
1177:../../Source/tasks.c **** 						will leave the lists in the correct state for the next yield. */
1178:../../Source/tasks.c **** 						portYIELD_WITHIN_API();
1179:../../Source/tasks.c **** 					}
1180:../../Source/tasks.c **** 				}
1181:../../Source/tasks.c **** 			}
1182:../../Source/tasks.c **** 			taskEXIT_CRITICAL();
1183:../../Source/tasks.c **** 		}
1184:../../Source/tasks.c **** 	}
1185:../../Source/tasks.c **** 
1186:../../Source/tasks.c **** #endif
1187:../../Source/tasks.c **** 
1188:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1189:../../Source/tasks.c **** 
1190:../../Source/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1191:../../Source/tasks.c **** 
1192:../../Source/tasks.c **** 	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
1193:../../Source/tasks.c **** 	{
1194:../../Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
1195:../../Source/tasks.c **** 	tskTCB *pxTCB;
1196:../../Source/tasks.c **** 	unsigned portBASE_TYPE uxSavedInterruptStatus;
1197:../../Source/tasks.c **** 
1198:../../Source/tasks.c **** 		configASSERT( pxTaskToResume );
1199:../../Source/tasks.c **** 
1200:../../Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
1201:../../Source/tasks.c **** 
1202:../../Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1203:../../Source/tasks.c **** 		{
1204:../../Source/tasks.c **** 			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
1205:../../Source/tasks.c **** 			{
1206:../../Source/tasks.c **** 				traceTASK_RESUME_FROM_ISR( pxTCB );
1207:../../Source/tasks.c **** 
1208:../../Source/tasks.c **** 				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1209:../../Source/tasks.c **** 				{
1210:../../Source/tasks.c **** 					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
1211:../../Source/tasks.c **** 					uxListRemove(  &( pxTCB->xGenericListItem ) );
1212:../../Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
1213:../../Source/tasks.c **** 				}
1214:../../Source/tasks.c **** 				else
1215:../../Source/tasks.c **** 				{
1216:../../Source/tasks.c **** 					/* We cannot access the delayed or ready lists, so will hold this
1217:../../Source/tasks.c **** 					task pending until the scheduler is resumed, at which point a
1218:../../Source/tasks.c **** 					yield will be performed if necessary. */
1219:../../Source/tasks.c **** 					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
1220:../../Source/tasks.c **** 				}
1221:../../Source/tasks.c **** 			}
1222:../../Source/tasks.c **** 		}
1223:../../Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1224:../../Source/tasks.c **** 
1225:../../Source/tasks.c **** 		return xYieldRequired;
1226:../../Source/tasks.c **** 	}
1227:../../Source/tasks.c **** 
1228:../../Source/tasks.c **** #endif
1229:../../Source/tasks.c **** 
1230:../../Source/tasks.c **** 
1231:../../Source/tasks.c **** 
1232:../../Source/tasks.c **** 
1233:../../Source/tasks.c **** /*-----------------------------------------------------------
1234:../../Source/tasks.c ****  * PUBLIC SCHEDULER CONTROL documented in task.h
1235:../../Source/tasks.c ****  *----------------------------------------------------------*/
1236:../../Source/tasks.c **** 
1237:../../Source/tasks.c **** 
1238:../../Source/tasks.c **** void vTaskStartScheduler( void )
1239:../../Source/tasks.c **** {
1240:../../Source/tasks.c **** portBASE_TYPE xReturn;
1241:../../Source/tasks.c **** 
1242:../../Source/tasks.c **** 	/* Add the idle task at the lowest priority. */
1243:../../Source/tasks.c **** 	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1244:../../Source/tasks.c **** 	{
1245:../../Source/tasks.c **** 		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
1246:../../Source/tasks.c **** 		be returned by the xTaskGetIdleTaskHandle() function. */
1247:../../Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
1248:../../Source/tasks.c **** 	}
1249:../../Source/tasks.c **** 	#else
1250:../../Source/tasks.c **** 	{
1251:../../Source/tasks.c **** 		/* Create the idle task without storing its handle. */
1252:../../Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
1253:../../Source/tasks.c **** 	}
1254:../../Source/tasks.c **** 	#endif
1255:../../Source/tasks.c **** 
1256:../../Source/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
1257:../../Source/tasks.c **** 	{
1258:../../Source/tasks.c **** 		if( xReturn == pdPASS )
1259:../../Source/tasks.c **** 		{
1260:../../Source/tasks.c **** 			xReturn = xTimerCreateTimerTask();
1261:../../Source/tasks.c **** 		}
1262:../../Source/tasks.c **** 	}
1263:../../Source/tasks.c **** 	#endif
1264:../../Source/tasks.c **** 
1265:../../Source/tasks.c **** 	if( xReturn == pdPASS )
1266:../../Source/tasks.c **** 	{
1267:../../Source/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1268:../../Source/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1269:../../Source/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1270:../../Source/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1271:../../Source/tasks.c **** 		starts to run.
1272:../../Source/tasks.c **** 
1273:../../Source/tasks.c **** 		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
1274:../../Source/tasks.c **** 		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
1275:../../Source/tasks.c **** 		portDISABLE_INTERRUPTS();
1276:../../Source/tasks.c **** 
1277:../../Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
1278:../../Source/tasks.c **** 		xTickCount = ( portTickType ) 0U;
1279:../../Source/tasks.c **** 
1280:../../Source/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1281:../../Source/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
1282:../../Source/tasks.c **** 		the run time counter time base. */
1283:../../Source/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1284:../../Source/tasks.c **** 
1285:../../Source/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
1286:../../Source/tasks.c **** 		portable interface. */
1287:../../Source/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
1288:../../Source/tasks.c **** 		{
1289:../../Source/tasks.c **** 			/* Should not reach here as if the scheduler is running the
1290:../../Source/tasks.c **** 			function will not return. */
1291:../../Source/tasks.c **** 		}
1292:../../Source/tasks.c **** 		else
1293:../../Source/tasks.c **** 		{
1294:../../Source/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1295:../../Source/tasks.c **** 		}
1296:../../Source/tasks.c **** 	}
1297:../../Source/tasks.c **** 
1298:../../Source/tasks.c **** 	/* This line will only be reached if the kernel could not be started. */
1299:../../Source/tasks.c **** 	configASSERT( xReturn );
1300:../../Source/tasks.c **** }
1301:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1302:../../Source/tasks.c **** 
1303:../../Source/tasks.c **** void vTaskEndScheduler( void )
1304:../../Source/tasks.c **** {
1305:../../Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
1306:../../Source/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
1307:../../Source/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
1308:../../Source/tasks.c **** 	portDISABLE_INTERRUPTS();
1309:../../Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
1310:../../Source/tasks.c **** 	vPortEndScheduler();
1311:../../Source/tasks.c **** }
1312:../../Source/tasks.c **** /*----------------------------------------------------------*/
1313:../../Source/tasks.c **** 
1314:../../Source/tasks.c **** void vTaskSuspendAll( void )
1315:../../Source/tasks.c **** {
1316:../../Source/tasks.c **** 	/* A critical section is not required as the variable is of type
1317:../../Source/tasks.c **** 	portBASE_TYPE. */
1318:../../Source/tasks.c **** 	++uxSchedulerSuspended;
1319:../../Source/tasks.c **** }
1320:../../Source/tasks.c **** /*----------------------------------------------------------*/
1321:../../Source/tasks.c **** 
1322:../../Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
1323:../../Source/tasks.c **** 
1324:../../Source/tasks.c **** 	portTickType prvGetExpectedIdleTime( void )
1325:../../Source/tasks.c **** 	{
1326:../../Source/tasks.c **** 	portTickType xReturn;
1327:../../Source/tasks.c **** 
1328:../../Source/tasks.c **** 		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
1329:../../Source/tasks.c **** 		{
1330:../../Source/tasks.c **** 			xReturn = 0;
1331:../../Source/tasks.c **** 		}
1332:../../Source/tasks.c **** 		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
1333:../../Source/tasks.c **** 		{
1334:../../Source/tasks.c **** 			/* There are other idle priority tasks in the ready state.  If
1335:../../Source/tasks.c **** 			time slicing is used then the very next tick interrupt must be
1336:../../Source/tasks.c **** 			processed. */
1337:../../Source/tasks.c **** 			xReturn = 0;
1338:../../Source/tasks.c **** 		}
1339:../../Source/tasks.c **** 		else
1340:../../Source/tasks.c **** 		{
1341:../../Source/tasks.c **** 			xReturn = xNextTaskUnblockTime - xTickCount;
1342:../../Source/tasks.c **** 		}
1343:../../Source/tasks.c **** 
1344:../../Source/tasks.c **** 		return xReturn;
1345:../../Source/tasks.c **** 	}
1346:../../Source/tasks.c **** 
1347:../../Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE != 0  */
1348:../../Source/tasks.c **** /*----------------------------------------------------------*/
1349:../../Source/tasks.c **** 
1350:../../Source/tasks.c **** signed portBASE_TYPE xTaskResumeAll( void )
1351:../../Source/tasks.c **** {
1352:../../Source/tasks.c **** register tskTCB *pxTCB;
1353:../../Source/tasks.c **** signed portBASE_TYPE xAlreadyYielded = pdFALSE;
1354:../../Source/tasks.c **** 
1355:../../Source/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
1356:../../Source/tasks.c **** 	previous call to vTaskSuspendAll(). */
1357:../../Source/tasks.c **** 	configASSERT( uxSchedulerSuspended );
1358:../../Source/tasks.c **** 
1359:../../Source/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
1360:../../Source/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
1361:../../Source/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
1362:../../Source/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
1363:../../Source/tasks.c **** 	tasks from this list into their appropriate ready list. */
1364:../../Source/tasks.c **** 	taskENTER_CRITICAL();
1365:../../Source/tasks.c **** 	{
1366:../../Source/tasks.c **** 		--uxSchedulerSuspended;
1367:../../Source/tasks.c **** 
1368:../../Source/tasks.c **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1369:../../Source/tasks.c **** 		{
1370:../../Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
1371:../../Source/tasks.c **** 			{
1372:../../Source/tasks.c **** 				portBASE_TYPE xYieldRequired = pdFALSE;
1373:../../Source/tasks.c **** 
1374:../../Source/tasks.c **** 				/* Move any readied tasks from the pending list into the
1375:../../Source/tasks.c **** 				appropriate ready list. */
1376:../../Source/tasks.c **** 				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
1377:../../Source/tasks.c **** 				{
1378:../../Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
1379:../../Source/tasks.c **** 					uxListRemove( &( pxTCB->xEventListItem ) );
1380:../../Source/tasks.c **** 					uxListRemove( &( pxTCB->xGenericListItem ) );
1381:../../Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
1382:../../Source/tasks.c **** 
1383:../../Source/tasks.c **** 					/* If we have moved a task that has a priority higher than
1384:../../Source/tasks.c **** 					the current task then we should yield. */
1385:../../Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1386:../../Source/tasks.c **** 					{
1387:../../Source/tasks.c **** 						xYieldRequired = pdTRUE;
1388:../../Source/tasks.c **** 					}
1389:../../Source/tasks.c **** 				}
1390:../../Source/tasks.c **** 
1391:../../Source/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
1392:../../Source/tasks.c **** 				they should be processed now.  This ensures the tick count does not
1393:../../Source/tasks.c **** 				slip, and that any delayed tasks are resumed at the correct time. */
1394:../../Source/tasks.c **** 				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
1395:../../Source/tasks.c **** 				{
1396:../../Source/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
1397:../../Source/tasks.c **** 					{
1398:../../Source/tasks.c **** 						vTaskIncrementTick();
1399:../../Source/tasks.c **** 						--uxMissedTicks;
1400:../../Source/tasks.c **** 					}
1401:../../Source/tasks.c **** 
1402:../../Source/tasks.c **** 					/* As we have processed some ticks it is appropriate to yield
1403:../../Source/tasks.c **** 					to ensure the highest priority task that is ready to run is
1404:../../Source/tasks.c **** 					the task actually running. */
1405:../../Source/tasks.c **** 					#if configUSE_PREEMPTION == 1
1406:../../Source/tasks.c **** 					{
1407:../../Source/tasks.c **** 						xYieldRequired = pdTRUE;
1408:../../Source/tasks.c **** 					}
1409:../../Source/tasks.c **** 					#endif
1410:../../Source/tasks.c **** 				}
1411:../../Source/tasks.c **** 
1412:../../Source/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
1413:../../Source/tasks.c **** 				{
1414:../../Source/tasks.c **** 					xAlreadyYielded = pdTRUE;
1415:../../Source/tasks.c **** 					xMissedYield = pdFALSE;
1416:../../Source/tasks.c **** 					portYIELD_WITHIN_API();
1417:../../Source/tasks.c **** 				}
1418:../../Source/tasks.c **** 			}
1419:../../Source/tasks.c **** 		}
1420:../../Source/tasks.c **** 	}
1421:../../Source/tasks.c **** 	taskEXIT_CRITICAL();
1422:../../Source/tasks.c **** 
1423:../../Source/tasks.c **** 	return xAlreadyYielded;
1424:../../Source/tasks.c **** }
1425:../../Source/tasks.c **** 
1426:../../Source/tasks.c **** 
1427:../../Source/tasks.c **** 
1428:../../Source/tasks.c **** 
1429:../../Source/tasks.c **** 
1430:../../Source/tasks.c **** 
1431:../../Source/tasks.c **** /*-----------------------------------------------------------
1432:../../Source/tasks.c ****  * PUBLIC TASK UTILITIES documented in task.h
1433:../../Source/tasks.c ****  *----------------------------------------------------------*/
1434:../../Source/tasks.c **** 
1435:../../Source/tasks.c **** 
1436:../../Source/tasks.c **** 
1437:../../Source/tasks.c **** portTickType xTaskGetTickCount( void )
1438:../../Source/tasks.c **** {
1439:../../Source/tasks.c **** portTickType xTicks;
1440:../../Source/tasks.c **** 
1441:../../Source/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
1442:../../Source/tasks.c **** 	taskENTER_CRITICAL();
1443:../../Source/tasks.c **** 	{
1444:../../Source/tasks.c **** 		xTicks = xTickCount;
1445:../../Source/tasks.c **** 	}
1446:../../Source/tasks.c **** 	taskEXIT_CRITICAL();
1447:../../Source/tasks.c **** 
1448:../../Source/tasks.c **** 	return xTicks;
1449:../../Source/tasks.c **** }
1450:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1451:../../Source/tasks.c **** 
1452:../../Source/tasks.c **** portTickType xTaskGetTickCountFromISR( void )
1453:../../Source/tasks.c **** {
1454:../../Source/tasks.c **** portTickType xReturn;
1455:../../Source/tasks.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1456:../../Source/tasks.c **** 
1457:../../Source/tasks.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1458:../../Source/tasks.c **** 	xReturn = xTickCount;
1459:../../Source/tasks.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1460:../../Source/tasks.c **** 
1461:../../Source/tasks.c **** 	return xReturn;
1462:../../Source/tasks.c **** }
1463:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1464:../../Source/tasks.c **** 
1465:../../Source/tasks.c **** unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
1466:../../Source/tasks.c **** {
1467:../../Source/tasks.c **** 	/* A critical section is not required because the variables are of type
1468:../../Source/tasks.c **** 	portBASE_TYPE. */
1469:../../Source/tasks.c **** 	return uxCurrentNumberOfTasks;
1470:../../Source/tasks.c **** }
1471:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1472:../../Source/tasks.c **** 
1473:../../Source/tasks.c **** #if ( INCLUDE_pcTaskGetTaskName == 1 )
1474:../../Source/tasks.c **** 
1475:../../Source/tasks.c **** 	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
1476:../../Source/tasks.c **** 	{
1477:../../Source/tasks.c **** 	tskTCB *pxTCB;
1478:../../Source/tasks.c **** 
1479:../../Source/tasks.c **** 		/* If null is passed in here then the name of the calling task is being queried. */
1480:../../Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
1481:../../Source/tasks.c **** 		configASSERT( pxTCB );
1482:../../Source/tasks.c **** 		return &( pxTCB->pcTaskName[ 0 ] );
1483:../../Source/tasks.c **** 	}
1484:../../Source/tasks.c **** 
1485:../../Source/tasks.c **** #endif
1486:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1487:../../Source/tasks.c **** 
1488:../../Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1489:../../Source/tasks.c **** 
1490:../../Source/tasks.c **** 	void vTaskList( signed char *pcWriteBuffer )
1491:../../Source/tasks.c **** 	{
1492:../../Source/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1493:../../Source/tasks.c **** 
1494:../../Source/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1495:../../Source/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1496:../../Source/tasks.c **** 
1497:../../Source/tasks.c **** 		vTaskSuspendAll();
1498:../../Source/tasks.c **** 		{
1499:../../Source/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB and
1500:../../Source/tasks.c **** 			report the task name, state and stack high water mark. */
1501:../../Source/tasks.c **** 
1502:../../Source/tasks.c **** 			*pcWriteBuffer = ( signed char ) 0x00;
1503:../../Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1504:../../Source/tasks.c **** 
1505:../../Source/tasks.c **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
1506:../../Source/tasks.c **** 
1507:../../Source/tasks.c **** 			do
1508:../../Source/tasks.c **** 			{
1509:../../Source/tasks.c **** 				uxQueue--;
1510:../../Source/tasks.c **** 
1511:../../Source/tasks.c **** 				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
1512:../../Source/tasks.c **** 				{
1513:../../Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tsk
1514:../../Source/tasks.c **** 				}
1515:../../Source/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1516:../../Source/tasks.c **** 
1517:../../Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
1518:../../Source/tasks.c **** 			{
1519:../../Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
1520:../../Source/tasks.c **** 			}
1521:../../Source/tasks.c **** 
1522:../../Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
1523:../../Source/tasks.c **** 			{
1524:../../Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_C
1525:../../Source/tasks.c **** 			}
1526:../../Source/tasks.c **** 
1527:../../Source/tasks.c **** 			#if( INCLUDE_vTaskDelete == 1 )
1528:../../Source/tasks.c **** 			{
1529:../../Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
1530:../../Source/tasks.c **** 				{
1531:../../Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, &xTasksWaitingTermination, tskDELETED_CHAR );
1532:../../Source/tasks.c **** 				}
1533:../../Source/tasks.c **** 			}
1534:../../Source/tasks.c **** 			#endif
1535:../../Source/tasks.c **** 
1536:../../Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1537:../../Source/tasks.c **** 			{
1538:../../Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
1539:../../Source/tasks.c **** 				{
1540:../../Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, &xSuspendedTaskList, tskSUSPENDED_CHAR );
1541:../../Source/tasks.c **** 				}
1542:../../Source/tasks.c **** 			}
1543:../../Source/tasks.c **** 			#endif
1544:../../Source/tasks.c **** 		}
1545:../../Source/tasks.c **** 		xTaskResumeAll();
1546:../../Source/tasks.c **** 	}
1547:../../Source/tasks.c **** 
1548:../../Source/tasks.c **** #endif
1549:../../Source/tasks.c **** /*----------------------------------------------------------*/
1550:../../Source/tasks.c **** 
1551:../../Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
1552:../../Source/tasks.c **** 
1553:../../Source/tasks.c **** 	void vTaskGetRunTimeStats( signed char *pcWriteBuffer )
1554:../../Source/tasks.c **** 	{
1555:../../Source/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1556:../../Source/tasks.c **** 	unsigned long ulTotalRunTime;
1557:../../Source/tasks.c **** 
1558:../../Source/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1559:../../Source/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1560:../../Source/tasks.c **** 
1561:../../Source/tasks.c **** 		vTaskSuspendAll();
1562:../../Source/tasks.c **** 		{
1563:../../Source/tasks.c **** 			#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1564:../../Source/tasks.c **** 				portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
1565:../../Source/tasks.c **** 			#else
1566:../../Source/tasks.c **** 				ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1567:../../Source/tasks.c **** 			#endif
1568:../../Source/tasks.c **** 
1569:../../Source/tasks.c **** 			/* Divide ulTotalRunTime by 100 to make the percentage caluclations
1570:../../Source/tasks.c **** 			simpler in the prvGenerateRunTimeStatsForTasksInList() function. */
1571:../../Source/tasks.c **** 			ulTotalRunTime /= 100UL;
1572:../../Source/tasks.c **** 
1573:../../Source/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB,
1574:../../Source/tasks.c **** 			generating a table of run timer percentages in the provided
1575:../../Source/tasks.c **** 			buffer. */
1576:../../Source/tasks.c **** 
1577:../../Source/tasks.c **** 			*pcWriteBuffer = ( signed char ) 0x00;
1578:../../Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1579:../../Source/tasks.c **** 
1580:../../Source/tasks.c **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
1581:../../Source/tasks.c **** 
1582:../../Source/tasks.c **** 			do
1583:../../Source/tasks.c **** 			{
1584:../../Source/tasks.c **** 				uxQueue--;
1585:../../Source/tasks.c **** 
1586:../../Source/tasks.c **** 				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
1587:../../Source/tasks.c **** 				{
1588:../../Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueu
1589:../../Source/tasks.c **** 				}
1590:../../Source/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1591:../../Source/tasks.c **** 
1592:../../Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
1593:../../Source/tasks.c **** 			{
1594:../../Source/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, ulTotalRun
1595:../../Source/tasks.c **** 			}
1596:../../Source/tasks.c **** 
1597:../../Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
1598:../../Source/tasks.c **** 			{
1599:../../Source/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, ul
1600:../../Source/tasks.c **** 			}
1601:../../Source/tasks.c **** 
1602:../../Source/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1603:../../Source/tasks.c **** 			{
1604:../../Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
1605:../../Source/tasks.c **** 				{
1606:../../Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xTasksWaitingTermination, ulTotalRunTim
1607:../../Source/tasks.c **** 				}
1608:../../Source/tasks.c **** 			}
1609:../../Source/tasks.c **** 			#endif
1610:../../Source/tasks.c **** 
1611:../../Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1612:../../Source/tasks.c **** 			{
1613:../../Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
1614:../../Source/tasks.c **** 				{
1615:../../Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xSuspendedTaskList, ulTotalRunTime );
1616:../../Source/tasks.c **** 				}
1617:../../Source/tasks.c **** 			}
1618:../../Source/tasks.c **** 			#endif
1619:../../Source/tasks.c **** 		}
1620:../../Source/tasks.c **** 		xTaskResumeAll();
1621:../../Source/tasks.c **** 	}
1622:../../Source/tasks.c **** 
1623:../../Source/tasks.c **** #endif
1624:../../Source/tasks.c **** /*----------------------------------------------------------*/
1625:../../Source/tasks.c **** 
1626:../../Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1627:../../Source/tasks.c **** 
1628:../../Source/tasks.c **** 	xTaskHandle xTaskGetIdleTaskHandle( void )
1629:../../Source/tasks.c **** 	{
1630:../../Source/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
1631:../../Source/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
1632:../../Source/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
1633:../../Source/tasks.c **** 		return xIdleTaskHandle;
1634:../../Source/tasks.c **** 	}
1635:../../Source/tasks.c **** 
1636:../../Source/tasks.c **** #endif
1637:../../Source/tasks.c **** /*----------------------------------------------------------*/
1638:../../Source/tasks.c **** 
1639:../../Source/tasks.c **** /* This conditional compilation should use inequality to 0, not equality to 1.
1640:../../Source/tasks.c **** This is to ensure vTaskStepTick() is available when user defined low power mode
1641:../../Source/tasks.c **** implementations require configUSE_TICKLESS_IDLE to be set to a value other than
1642:../../Source/tasks.c **** 1. */
1643:../../Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
1644:../../Source/tasks.c **** 
1645:../../Source/tasks.c **** 	void vTaskStepTick( portTickType xTicksToJump )
1646:../../Source/tasks.c **** 	{
1647:../../Source/tasks.c **** 		configASSERT( xTicksToJump <= xNextTaskUnblockTime );
1648:../../Source/tasks.c **** 		xTickCount += xTicksToJump;
1649:../../Source/tasks.c **** 	}
1650:../../Source/tasks.c **** 
1651:../../Source/tasks.c **** #endif
1652:../../Source/tasks.c **** 
1653:../../Source/tasks.c **** /*-----------------------------------------------------------
1654:../../Source/tasks.c ****  * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
1655:../../Source/tasks.c ****  * documented in task.h
1656:../../Source/tasks.c ****  *----------------------------------------------------------*/
1657:../../Source/tasks.c **** 
1658:../../Source/tasks.c **** void vTaskIncrementTick( void )
1659:../../Source/tasks.c **** {
1660:../../Source/tasks.c **** tskTCB * pxTCB;
1661:../../Source/tasks.c **** 
1662:../../Source/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
1663:../../Source/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
1664:../../Source/tasks.c **** 	tasks to be unblocked. */
1665:../../Source/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
1666:../../Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1667:../../Source/tasks.c **** 	{
1668:../../Source/tasks.c **** 		++xTickCount;
1669:../../Source/tasks.c **** 		if( xTickCount == ( portTickType ) 0U )
1670:../../Source/tasks.c **** 		{
1671:../../Source/tasks.c **** 			xList *pxTemp;
1672:../../Source/tasks.c **** 
1673:../../Source/tasks.c **** 			/* Tick count has overflowed so we need to swap the delay lists.
1674:../../Source/tasks.c **** 			If there are any items in pxDelayedTaskList here then there is
1675:../../Source/tasks.c **** 			an error! */
1676:../../Source/tasks.c **** 			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
1677:../../Source/tasks.c **** 
1678:../../Source/tasks.c **** 			pxTemp = pxDelayedTaskList;
1679:../../Source/tasks.c **** 			pxDelayedTaskList = pxOverflowDelayedTaskList;
1680:../../Source/tasks.c **** 			pxOverflowDelayedTaskList = pxTemp;
1681:../../Source/tasks.c **** 			xNumOfOverflows++;
1682:../../Source/tasks.c **** 
1683:../../Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
1684:../../Source/tasks.c **** 			{
1685:../../Source/tasks.c **** 				/* The new current delayed list is empty.  Set
1686:../../Source/tasks.c **** 				xNextTaskUnblockTime to the maximum possible value so it is
1687:../../Source/tasks.c **** 				extremely unlikely that the
1688:../../Source/tasks.c **** 				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
1689:../../Source/tasks.c **** 				there is an item in the delayed list. */
1690:../../Source/tasks.c **** 				xNextTaskUnblockTime = portMAX_DELAY;
1691:../../Source/tasks.c **** 			}
1692:../../Source/tasks.c **** 			else
1693:../../Source/tasks.c **** 			{
1694:../../Source/tasks.c **** 				/* The new current delayed list is not empty, get the value of
1695:../../Source/tasks.c **** 				the item at the head of the delayed list.  This is the time at
1696:../../Source/tasks.c **** 				which the task at the head of the delayed list should be removed
1697:../../Source/tasks.c **** 				from the Blocked state. */
1698:../../Source/tasks.c **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
1699:../../Source/tasks.c **** 				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
1700:../../Source/tasks.c **** 			}
1701:../../Source/tasks.c **** 		}
1702:../../Source/tasks.c **** 
1703:../../Source/tasks.c **** 		/* See if this tick has made a timeout expire. */
1704:../../Source/tasks.c **** 		prvCheckDelayedTasks();
1705:../../Source/tasks.c **** 	}
1706:../../Source/tasks.c **** 	else
1707:../../Source/tasks.c **** 	{
1708:../../Source/tasks.c **** 		++uxMissedTicks;
1709:../../Source/tasks.c **** 
1710:../../Source/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
1711:../../Source/tasks.c **** 		scheduler is locked. */
1712:../../Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
1713:../../Source/tasks.c **** 		{
1714:../../Source/tasks.c **** 			vApplicationTickHook();
1715:../../Source/tasks.c **** 		}
1716:../../Source/tasks.c **** 		#endif
1717:../../Source/tasks.c **** 	}
1718:../../Source/tasks.c **** 
1719:../../Source/tasks.c **** 	#if ( configUSE_TICK_HOOK == 1 )
1720:../../Source/tasks.c **** 	{
1721:../../Source/tasks.c **** 		/* Guard against the tick hook being called when the missed tick
1722:../../Source/tasks.c **** 		count is being unwound (when the scheduler is being unlocked. */
1723:../../Source/tasks.c **** 		if( uxMissedTicks == ( unsigned portBASE_TYPE ) 0U )
1724:../../Source/tasks.c **** 		{
1725:../../Source/tasks.c **** 			vApplicationTickHook();
1726:../../Source/tasks.c **** 		}
1727:../../Source/tasks.c **** 	}
1728:../../Source/tasks.c **** 	#endif
1729:../../Source/tasks.c **** }
1730:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1731:../../Source/tasks.c **** 
1732:../../Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1733:../../Source/tasks.c **** 
1734:../../Source/tasks.c **** 	void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction )
1735:../../Source/tasks.c **** 	{
1736:../../Source/tasks.c **** 	tskTCB *xTCB;
1737:../../Source/tasks.c **** 
1738:../../Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1739:../../Source/tasks.c **** 		if( xTask == NULL )
1740:../../Source/tasks.c **** 		{
1741:../../Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1742:../../Source/tasks.c **** 		}
1743:../../Source/tasks.c **** 		else
1744:../../Source/tasks.c **** 		{
1745:../../Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1746:../../Source/tasks.c **** 		}
1747:../../Source/tasks.c **** 
1748:../../Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1749:../../Source/tasks.c **** 		the value can be accessed from an interrupt. */
1750:../../Source/tasks.c **** 		taskENTER_CRITICAL();
1751:../../Source/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
1752:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
1753:../../Source/tasks.c **** 	}
1754:../../Source/tasks.c **** 
1755:../../Source/tasks.c **** #endif
1756:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1757:../../Source/tasks.c **** 
1758:../../Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1759:../../Source/tasks.c **** 
1760:../../Source/tasks.c **** 	pdTASK_HOOK_CODE xTaskGetApplicationTaskTag( xTaskHandle xTask )
1761:../../Source/tasks.c **** 	{
1762:../../Source/tasks.c **** 	tskTCB *xTCB;
1763:../../Source/tasks.c **** 	pdTASK_HOOK_CODE xReturn;
1764:../../Source/tasks.c **** 
1765:../../Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1766:../../Source/tasks.c **** 		if( xTask == NULL )
1767:../../Source/tasks.c **** 		{
1768:../../Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1769:../../Source/tasks.c **** 		}
1770:../../Source/tasks.c **** 		else
1771:../../Source/tasks.c **** 		{
1772:../../Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1773:../../Source/tasks.c **** 		}
1774:../../Source/tasks.c **** 
1775:../../Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1776:../../Source/tasks.c **** 		the value can be accessed from an interrupt. */
1777:../../Source/tasks.c **** 		taskENTER_CRITICAL();
1778:../../Source/tasks.c **** 			xReturn = xTCB->pxTaskTag;
1779:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
1780:../../Source/tasks.c **** 
1781:../../Source/tasks.c **** 		return xReturn;
1782:../../Source/tasks.c **** 	}
1783:../../Source/tasks.c **** 
1784:../../Source/tasks.c **** #endif
1785:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1786:../../Source/tasks.c **** 
1787:../../Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1788:../../Source/tasks.c **** 
1789:../../Source/tasks.c **** 	portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter )
1790:../../Source/tasks.c **** 	{
1791:../../Source/tasks.c **** 	tskTCB *xTCB;
1792:../../Source/tasks.c **** 	portBASE_TYPE xReturn;
1793:../../Source/tasks.c **** 
1794:../../Source/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
1795:../../Source/tasks.c **** 		if( xTask == NULL )
1796:../../Source/tasks.c **** 		{
1797:../../Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1798:../../Source/tasks.c **** 		}
1799:../../Source/tasks.c **** 		else
1800:../../Source/tasks.c **** 		{
1801:../../Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1802:../../Source/tasks.c **** 		}
1803:../../Source/tasks.c **** 
1804:../../Source/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
1805:../../Source/tasks.c **** 		{
1806:../../Source/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
1807:../../Source/tasks.c **** 		}
1808:../../Source/tasks.c **** 		else
1809:../../Source/tasks.c **** 		{
1810:../../Source/tasks.c **** 			xReturn = pdFAIL;
1811:../../Source/tasks.c **** 		}
1812:../../Source/tasks.c **** 
1813:../../Source/tasks.c **** 		return xReturn;
1814:../../Source/tasks.c **** 	}
1815:../../Source/tasks.c **** 
1816:../../Source/tasks.c **** #endif
1817:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1818:../../Source/tasks.c **** 
1819:../../Source/tasks.c **** void vTaskSwitchContext( void )
1820:../../Source/tasks.c **** {
1821:../../Source/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
1822:../../Source/tasks.c **** 	{
1823:../../Source/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
1824:../../Source/tasks.c **** 		switch. */
1825:../../Source/tasks.c **** 		xMissedYield = pdTRUE;
1826:../../Source/tasks.c **** 	}
1827:../../Source/tasks.c **** 	else
1828:../../Source/tasks.c **** 	{
1829:../../Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
1830:../../Source/tasks.c **** 
1831:../../Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
1832:../../Source/tasks.c **** 		{
1833:../../Source/tasks.c **** 			unsigned long ulTempCounter;
1834:../../Source/tasks.c **** 
1835:../../Source/tasks.c **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1836:../../Source/tasks.c **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTempCounter );
1837:../../Source/tasks.c **** 				#else
1838:../../Source/tasks.c **** 					ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
1839:../../Source/tasks.c **** 				#endif
1840:../../Source/tasks.c **** 
1841:../../Source/tasks.c **** 				/* Add the amount of time the task has been running to the accumulated
1842:../../Source/tasks.c **** 				time so far.  The time the task started running was stored in
1843:../../Source/tasks.c **** 				ulTaskSwitchedInTime.  Note that there is no overflow protection here
1844:../../Source/tasks.c **** 				so count values are only valid until the timer overflows.  Generally
1845:../../Source/tasks.c **** 				this will be about 1 hour assuming a 1uS timer increment. */
1846:../../Source/tasks.c **** 				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
1847:../../Source/tasks.c **** 				ulTaskSwitchedInTime = ulTempCounter;
1848:../../Source/tasks.c **** 		}
1849:../../Source/tasks.c **** 		#endif
1850:../../Source/tasks.c **** 
1851:../../Source/tasks.c **** 		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
1852:../../Source/tasks.c **** 		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
1853:../../Source/tasks.c **** 
1854:../../Source/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
1855:../../Source/tasks.c **** 
1856:../../Source/tasks.c **** 		traceTASK_SWITCHED_IN();
1857:../../Source/tasks.c **** 	}
1858:../../Source/tasks.c **** }
1859:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1860:../../Source/tasks.c **** 
1861:../../Source/tasks.c **** void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
1862:../../Source/tasks.c **** {
1863:../../Source/tasks.c **** portTickType xTimeToWake;
1864:../../Source/tasks.c **** 
1865:../../Source/tasks.c **** 	configASSERT( pxEventList );
1866:../../Source/tasks.c **** 
1867:../../Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1868:../../Source/tasks.c **** 	SCHEDULER SUSPENDED. */
1869:../../Source/tasks.c **** 
1870:../../Source/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
1871:../../Source/tasks.c **** 	This is placed in the list in priority order so the highest priority task
1872:../../Source/tasks.c **** 	is the first to be woken by the event. */
1873:../../Source/tasks.c **** 	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
1874:../../Source/tasks.c **** 
1875:../../Source/tasks.c **** 	/* We must remove ourselves from the ready list before adding ourselves
1876:../../Source/tasks.c **** 	to the blocked list as the same list item is used for both lists.  We have
1877:../../Source/tasks.c **** 	exclusive access to the ready lists as the scheduler is locked. */
1878:../../Source/tasks.c **** 	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
1879:../../Source/tasks.c **** 	{
1880:../../Source/tasks.c **** 		/* The current task must be in a ready list, so there is no need to
1881:../../Source/tasks.c **** 		check, and the port reset macro can be called directly. */
1882:../../Source/tasks.c **** 		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
1883:../../Source/tasks.c **** 	}
1884:../../Source/tasks.c **** 
1885:../../Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
1886:../../Source/tasks.c **** 	{
1887:../../Source/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
1888:../../Source/tasks.c **** 		{
1889:../../Source/tasks.c **** 			/* Add ourselves to the suspended task list instead of a delayed task
1890:../../Source/tasks.c **** 			list to ensure we are not woken by a timing event.  We will block
1891:../../Source/tasks.c **** 			indefinitely. */
1892:../../Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListIt
1893:../../Source/tasks.c **** 		}
1894:../../Source/tasks.c **** 		else
1895:../../Source/tasks.c **** 		{
1896:../../Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1897:../../Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1898:../../Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1899:../../Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
1900:../../Source/tasks.c **** 		}
1901:../../Source/tasks.c **** 	}
1902:../../Source/tasks.c **** 	#else
1903:../../Source/tasks.c **** 	{
1904:../../Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1905:../../Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1906:../../Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1907:../../Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
1908:../../Source/tasks.c **** 	}
1909:../../Source/tasks.c **** 	#endif
1910:../../Source/tasks.c **** }
1911:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1912:../../Source/tasks.c **** 
1913:../../Source/tasks.c **** #if configUSE_TIMERS == 1
1914:../../Source/tasks.c **** 
1915:../../Source/tasks.c **** 	void vTaskPlaceOnEventListRestricted( const xList * const pxEventList, portTickType xTicksToWait )
1916:../../Source/tasks.c **** 	{
1917:../../Source/tasks.c **** 	portTickType xTimeToWake;
1918:../../Source/tasks.c **** 
1919:../../Source/tasks.c **** 		configASSERT( pxEventList );
1920:../../Source/tasks.c **** 
1921:../../Source/tasks.c **** 		/* This function should not be called by application code hence the
1922:../../Source/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
1923:../../Source/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
1924:../../Source/tasks.c **** 		it should be called from a critical section. */
1925:../../Source/tasks.c **** 
1926:../../Source/tasks.c **** 
1927:../../Source/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
1928:../../Source/tasks.c **** 		In this case it is assume that this is the only task that is going to
1929:../../Source/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
1930:../../Source/tasks.c **** 		can be used in place of vListInsert. */
1931:../../Source/tasks.c **** 		vListInsertEnd( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
1932:../../Source/tasks.c **** 
1933:../../Source/tasks.c **** 		/* We must remove this task from the ready list before adding it to the
1934:../../Source/tasks.c **** 		blocked list as the same list item is used for both lists.  This
1935:../../Source/tasks.c **** 		function is called form a critical section. */
1936:../../Source/tasks.c **** 		if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
1937:../../Source/tasks.c **** 		{
1938:../../Source/tasks.c **** 			/* The current task must be in a ready list, so there is no need to
1939:../../Source/tasks.c **** 			check, and the port reset macro can be called directly. */
1940:../../Source/tasks.c **** 			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
1941:../../Source/tasks.c **** 		}
1942:../../Source/tasks.c **** 
1943:../../Source/tasks.c **** 		/* Calculate the time at which the task should be woken if the event does
1944:../../Source/tasks.c **** 		not occur.  This may overflow but this doesn't matter. */
1945:../../Source/tasks.c **** 		xTimeToWake = xTickCount + xTicksToWait;
1946:../../Source/tasks.c **** 
1947:../../Source/tasks.c **** 		traceTASK_DELAY_UNTIL();
1948:../../Source/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTimeToWake );
1949:../../Source/tasks.c **** 	}
1950:../../Source/tasks.c **** 
1951:../../Source/tasks.c **** #endif /* configUSE_TIMERS */
1952:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1953:../../Source/tasks.c **** 
1954:../../Source/tasks.c **** signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
1955:../../Source/tasks.c **** {
1956:../../Source/tasks.c **** tskTCB *pxUnblockedTCB;
1957:../../Source/tasks.c **** portBASE_TYPE xReturn;
1958:../../Source/tasks.c **** 
1959:../../Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1960:../../Source/tasks.c **** 	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
1961:../../Source/tasks.c **** 
1962:../../Source/tasks.c **** 	/* The event list is sorted in priority order, so we can remove the
1963:../../Source/tasks.c **** 	first in the list, remove the TCB from the delayed list, and add
1964:../../Source/tasks.c **** 	it to the ready list.
1965:../../Source/tasks.c **** 
1966:../../Source/tasks.c **** 	If an event is for a queue that is locked then this function will never
1967:../../Source/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
1968:../../Source/tasks.c **** 	means we can always expect exclusive access to the event list here.
1969:../../Source/tasks.c **** 
1970:../../Source/tasks.c **** 	This function assumes that a check has already been made to ensure that
1971:../../Source/tasks.c **** 	pxEventList is not empty. */
1972:../../Source/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
1973:../../Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
1974:../../Source/tasks.c **** 	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
1975:../../Source/tasks.c **** 
1976:../../Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1977:../../Source/tasks.c **** 	{
1978:../../Source/tasks.c **** 		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
1979:../../Source/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
1980:../../Source/tasks.c **** 	}
1981:../../Source/tasks.c **** 	else
1982:../../Source/tasks.c **** 	{
1983:../../Source/tasks.c **** 		/* We cannot access the delayed or ready lists, so will hold this
1984:../../Source/tasks.c **** 		task pending until the scheduler is resumed. */
1985:../../Source/tasks.c **** 		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
1986:../../Source/tasks.c **** 	}
1987:../../Source/tasks.c **** 
1988:../../Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
1989:../../Source/tasks.c **** 	{
1990:../../Source/tasks.c **** 		/* Return true if the task removed from the event list has
1991:../../Source/tasks.c **** 		a higher priority than the calling task.  This allows
1992:../../Source/tasks.c **** 		the calling task to know if it should force a context
1993:../../Source/tasks.c **** 		switch now. */
1994:../../Source/tasks.c **** 		xReturn = pdTRUE;
1995:../../Source/tasks.c **** 	}
1996:../../Source/tasks.c **** 	else
1997:../../Source/tasks.c **** 	{
1998:../../Source/tasks.c **** 		xReturn = pdFALSE;
1999:../../Source/tasks.c **** 	}
2000:../../Source/tasks.c **** 
2001:../../Source/tasks.c **** 	return xReturn;
2002:../../Source/tasks.c **** }
2003:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2004:../../Source/tasks.c **** 
2005:../../Source/tasks.c **** void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
2006:../../Source/tasks.c **** {
2007:../../Source/tasks.c **** 	configASSERT( pxTimeOut );
2008:../../Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
2009:../../Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
2010:../../Source/tasks.c **** }
2011:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2012:../../Source/tasks.c **** 
2013:../../Source/tasks.c **** portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToW
2014:../../Source/tasks.c **** {
2015:../../Source/tasks.c **** portBASE_TYPE xReturn;
2016:../../Source/tasks.c **** 
2017:../../Source/tasks.c **** 	configASSERT( pxTimeOut );
2018:../../Source/tasks.c **** 	configASSERT( pxTicksToWait );
2019:../../Source/tasks.c **** 
2020:../../Source/tasks.c **** 	taskENTER_CRITICAL();
2021:../../Source/tasks.c **** 	{
2022:../../Source/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
2023:../../Source/tasks.c **** 			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
2024:../../Source/tasks.c **** 			the maximum block time then the task should block indefinitely, and
2025:../../Source/tasks.c **** 			therefore never time out. */
2026:../../Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
2027:../../Source/tasks.c **** 			{
2028:../../Source/tasks.c **** 				xReturn = pdFALSE;
2029:../../Source/tasks.c **** 			}
2030:../../Source/tasks.c **** 			else /* We are not blocking indefinitely, perform the checks below. */
2031:../../Source/tasks.c **** 		#endif
2032:../../Source/tasks.c **** 
2033:../../Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
2034:../../Source/tasks.c **** 		{
2035:../../Source/tasks.c **** 			/* The tick count is greater than the time at which vTaskSetTimeout()
2036:../../Source/tasks.c **** 			was called, but has also overflowed since vTaskSetTimeOut() was called.
2037:../../Source/tasks.c **** 			It must have wrapped all the way around and gone past us again. This
2038:../../Source/tasks.c **** 			passed since vTaskSetTimeout() was called. */
2039:../../Source/tasks.c **** 			xReturn = pdTRUE;
2040:../../Source/tasks.c **** 		}
2041:../../Source/tasks.c **** 		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEn
2042:../../Source/tasks.c **** 		{
2043:../../Source/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
2044:../../Source/tasks.c **** 			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
2045:../../Source/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
2046:../../Source/tasks.c **** 			xReturn = pdFALSE;
2047:../../Source/tasks.c **** 		}
2048:../../Source/tasks.c **** 		else
2049:../../Source/tasks.c **** 		{
2050:../../Source/tasks.c **** 			xReturn = pdTRUE;
2051:../../Source/tasks.c **** 		}
2052:../../Source/tasks.c **** 	}
2053:../../Source/tasks.c **** 	taskEXIT_CRITICAL();
2054:../../Source/tasks.c **** 
2055:../../Source/tasks.c **** 	return xReturn;
2056:../../Source/tasks.c **** }
2057:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2058:../../Source/tasks.c **** 
2059:../../Source/tasks.c **** void vTaskMissedYield( void )
2060:../../Source/tasks.c **** {
2061:../../Source/tasks.c **** 	xMissedYield = pdTRUE;
2062:../../Source/tasks.c **** }
2063:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2064:../../Source/tasks.c **** 
2065:../../Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2066:../../Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetTaskNumber( xTaskHandle xTask )
2067:../../Source/tasks.c **** 	{
2068:../../Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
2069:../../Source/tasks.c **** 	tskTCB *pxTCB;
2070:../../Source/tasks.c **** 
2071:../../Source/tasks.c **** 		if( xTask != NULL )
2072:../../Source/tasks.c **** 		{
2073:../../Source/tasks.c **** 			pxTCB = ( tskTCB * ) xTask;
2074:../../Source/tasks.c **** 			uxReturn = pxTCB->uxTaskNumber;
2075:../../Source/tasks.c **** 		}
2076:../../Source/tasks.c **** 		else
2077:../../Source/tasks.c **** 		{
2078:../../Source/tasks.c **** 			uxReturn = 0U;
2079:../../Source/tasks.c **** 		}
2080:../../Source/tasks.c **** 
2081:../../Source/tasks.c **** 		return uxReturn;
2082:../../Source/tasks.c **** 	}
2083:../../Source/tasks.c **** #endif
2084:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2085:../../Source/tasks.c **** 
2086:../../Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2087:../../Source/tasks.c **** 	void vTaskSetTaskNumber( xTaskHandle xTask, unsigned portBASE_TYPE uxHandle )
2088:../../Source/tasks.c **** 	{
2089:../../Source/tasks.c **** 	tskTCB *pxTCB;
2090:../../Source/tasks.c **** 
2091:../../Source/tasks.c **** 		if( xTask != NULL )
2092:../../Source/tasks.c **** 		{
2093:../../Source/tasks.c **** 			pxTCB = ( tskTCB * ) xTask;
2094:../../Source/tasks.c **** 			pxTCB->uxTaskNumber = uxHandle;
2095:../../Source/tasks.c **** 		}
2096:../../Source/tasks.c **** 	}
2097:../../Source/tasks.c **** #endif
2098:../../Source/tasks.c **** 
2099:../../Source/tasks.c **** 
2100:../../Source/tasks.c **** /*
2101:../../Source/tasks.c ****  * -----------------------------------------------------------
2102:../../Source/tasks.c ****  * The Idle task.
2103:../../Source/tasks.c ****  * ----------------------------------------------------------
2104:../../Source/tasks.c ****  *
2105:../../Source/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
2106:../../Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
2107:../../Source/tasks.c ****  *
2108:../../Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
2109:../../Source/tasks.c ****  *
2110:../../Source/tasks.c ****  */
2111:../../Source/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
2112:../../Source/tasks.c **** {
  17               		.loc 1 2112 0
  18               		.cfi_startproc
  19               	/* prologue: function */
  20               	/* frame size = 0 */
  21               	/* stack size = 0 */
  22               	.L__stack_usage = 0
  23               	.L6:
2113:../../Source/tasks.c **** 	/* Stop warnings. */
2114:../../Source/tasks.c **** 	( void ) pvParameters;
2115:../../Source/tasks.c **** 
2116:../../Source/tasks.c **** 	for( ;; )
2117:../../Source/tasks.c **** 	{
2118:../../Source/tasks.c **** 		/* See if any tasks have been deleted. */
2119:../../Source/tasks.c **** 		prvCheckTasksWaitingTermination();
2120:../../Source/tasks.c **** 
2121:../../Source/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
2122:../../Source/tasks.c **** 		{
2123:../../Source/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
2124:../../Source/tasks.c **** 			see if any other task has become available.  If we are using
2125:../../Source/tasks.c **** 			preemption we don't need to do this as any task becoming available
2126:../../Source/tasks.c **** 			will automatically get the processor anyway. */
2127:../../Source/tasks.c **** 			taskYIELD();
2128:../../Source/tasks.c **** 		}
2129:../../Source/tasks.c **** 		#endif
2130:../../Source/tasks.c **** 
2131:../../Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
2132:../../Source/tasks.c **** 		{
2133:../../Source/tasks.c **** 			/* When using preemption tasks of equal priority will be
2134:../../Source/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
2135:../../Source/tasks.c **** 			to run then the idle task should yield before the end of the
2136:../../Source/tasks.c **** 			timeslice.
2137:../../Source/tasks.c **** 
2138:../../Source/tasks.c **** 			A critical region is not required here as we are just reading from
2139:../../Source/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
2140:../../Source/tasks.c **** 			the ready list at the idle priority contains more than one task
2141:../../Source/tasks.c **** 			then a task other than the idle task is ready to execute. */
2142:../../Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_
  24               		.loc 1 2142 0
  25 0000 8091 0000 		lds r24,pxReadyTasksLists
  26 0004 8230      		cpi r24,lo8(2)
  27 0006 00F0      		brlo .L6
2143:../../Source/tasks.c **** 			{
2144:../../Source/tasks.c **** 				taskYIELD();
  28               		.loc 1 2144 0
  29 0008 0E94 0000 		call vPortYield
  30 000c 00C0      		rjmp .L6
  31               		.cfi_endproc
  32               	.LFE22:
  35               	prvAddCurrentTaskToDelayedList:
  36               	.LFB26:
2145:../../Source/tasks.c **** 			}
2146:../../Source/tasks.c **** 		}
2147:../../Source/tasks.c **** 		#endif
2148:../../Source/tasks.c **** 
2149:../../Source/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
2150:../../Source/tasks.c **** 		{
2151:../../Source/tasks.c **** 			extern void vApplicationIdleHook( void );
2152:../../Source/tasks.c **** 
2153:../../Source/tasks.c **** 			/* Call the user defined function from within the idle task.  This
2154:../../Source/tasks.c **** 			allows the application designer to add background functionality
2155:../../Source/tasks.c **** 			without the overhead of a separate task.
2156:../../Source/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
2157:../../Source/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
2158:../../Source/tasks.c **** 			vApplicationIdleHook();
2159:../../Source/tasks.c **** 		}
2160:../../Source/tasks.c **** 		#endif
2161:../../Source/tasks.c **** 
2162:../../Source/tasks.c **** 		/* This conditional compilation should use inequality to 0, not equality
2163:../../Source/tasks.c **** 		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
2164:../../Source/tasks.c **** 		user defined low power mode	implementations require
2165:../../Source/tasks.c **** 		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
2166:../../Source/tasks.c **** 		#if ( configUSE_TICKLESS_IDLE != 0 )
2167:../../Source/tasks.c **** 		{
2168:../../Source/tasks.c **** 		portTickType xExpectedIdleTime;
2169:../../Source/tasks.c **** 		/* If the expected idle time is 1 then the idle time would end at
2170:../../Source/tasks.c **** 		the end of the current time slice.  The idle time must be at least
2171:../../Source/tasks.c **** 		2 to ensure any pended ticks between this point and the tick being
2172:../../Source/tasks.c **** 		stopped can be legitimately stepped over when the tick suppression
2173:../../Source/tasks.c **** 		routines returns. */
2174:../../Source/tasks.c **** 		const portTickType xMinimumExpectedIdleTime = ( portTickType ) 2;
2175:../../Source/tasks.c **** 
2176:../../Source/tasks.c **** 			/* It is not desirable to suspend then resume the scheduler on
2177:../../Source/tasks.c **** 			each iteration of the idle task.  Therefore, a preliminary
2178:../../Source/tasks.c **** 			test of the expected idle time is performed without the
2179:../../Source/tasks.c **** 			scheduler suspended.  The result here is not necessarily
2180:../../Source/tasks.c **** 			valid. */
2181:../../Source/tasks.c **** 			xExpectedIdleTime = prvGetExpectedIdleTime();
2182:../../Source/tasks.c **** 
2183:../../Source/tasks.c **** 			if( xExpectedIdleTime >= xMinimumExpectedIdleTime )
2184:../../Source/tasks.c **** 			{
2185:../../Source/tasks.c **** 				vTaskSuspendAll();
2186:../../Source/tasks.c **** 				{
2187:../../Source/tasks.c **** 					/* Now the scheduler is suspended, the expected idle
2188:../../Source/tasks.c **** 					time can be sampled again, and this time its value can
2189:../../Source/tasks.c **** 					be used. */
2190:../../Source/tasks.c **** 					configASSERT( xNextTaskUnblockTime >= xTickCount );
2191:../../Source/tasks.c **** 					xExpectedIdleTime = prvGetExpectedIdleTime();
2192:../../Source/tasks.c **** 
2193:../../Source/tasks.c **** 					if( xExpectedIdleTime >= xMinimumExpectedIdleTime )
2194:../../Source/tasks.c **** 					{
2195:../../Source/tasks.c **** 						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
2196:../../Source/tasks.c **** 					}
2197:../../Source/tasks.c **** 				}
2198:../../Source/tasks.c **** 				xTaskResumeAll();
2199:../../Source/tasks.c **** 			}
2200:../../Source/tasks.c **** 		}
2201:../../Source/tasks.c **** 		#endif
2202:../../Source/tasks.c **** 	}
2203:../../Source/tasks.c **** } /*lint !e715 pvParameters is not accessed but all task functions require the same prototype. */
2204:../../Source/tasks.c **** 
2205:../../Source/tasks.c **** 
2206:../../Source/tasks.c **** 
2207:../../Source/tasks.c **** 
2208:../../Source/tasks.c **** 
2209:../../Source/tasks.c **** 
2210:../../Source/tasks.c **** 
2211:../../Source/tasks.c **** /*-----------------------------------------------------------
2212:../../Source/tasks.c ****  * File private functions documented at the top of the file.
2213:../../Source/tasks.c ****  *----------------------------------------------------------*/
2214:../../Source/tasks.c **** 
2215:../../Source/tasks.c **** 
2216:../../Source/tasks.c **** 
2217:../../Source/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
2218:../../Source/tasks.c **** {
2219:../../Source/tasks.c **** 	/* Store the function name in the TCB. */
2220:../../Source/tasks.c **** 	#if configMAX_TASK_NAME_LEN > 1
2221:../../Source/tasks.c **** 	{
2222:../../Source/tasks.c **** 		/* Don't bring strncpy into the build unnecessarily. */
2223:../../Source/tasks.c **** 		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK
2224:../../Source/tasks.c **** 	}
2225:../../Source/tasks.c **** 	#endif
2226:../../Source/tasks.c **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed 
2227:../../Source/tasks.c **** 
2228:../../Source/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
2229:../../Source/tasks.c **** 	remove the privilege bit if one is present. */
2230:../../Source/tasks.c **** 	if( uxPriority >= configMAX_PRIORITIES )
2231:../../Source/tasks.c **** 	{
2232:../../Source/tasks.c **** 		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
2233:../../Source/tasks.c **** 	}
2234:../../Source/tasks.c **** 
2235:../../Source/tasks.c **** 	pxTCB->uxPriority = uxPriority;
2236:../../Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
2237:../../Source/tasks.c **** 	{
2238:../../Source/tasks.c **** 		pxTCB->uxBasePriority = uxPriority;
2239:../../Source/tasks.c **** 	}
2240:../../Source/tasks.c **** 	#endif
2241:../../Source/tasks.c **** 
2242:../../Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
2243:../../Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
2244:../../Source/tasks.c **** 
2245:../../Source/tasks.c **** 	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
2246:../../Source/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
2247:../../Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
2248:../../Source/tasks.c **** 
2249:../../Source/tasks.c **** 	/* Event lists are always in priority order. */
2250:../../Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPri
2251:../../Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
2252:../../Source/tasks.c **** 
2253:../../Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
2254:../../Source/tasks.c **** 	{
2255:../../Source/tasks.c **** 		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0U;
2256:../../Source/tasks.c **** 	}
2257:../../Source/tasks.c **** 	#endif
2258:../../Source/tasks.c **** 
2259:../../Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
2260:../../Source/tasks.c **** 	{
2261:../../Source/tasks.c **** 		pxTCB->pxTaskTag = NULL;
2262:../../Source/tasks.c **** 	}
2263:../../Source/tasks.c **** 	#endif
2264:../../Source/tasks.c **** 
2265:../../Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
2266:../../Source/tasks.c **** 	{
2267:../../Source/tasks.c **** 		pxTCB->ulRunTimeCounter = 0UL;
2268:../../Source/tasks.c **** 	}
2269:../../Source/tasks.c **** 	#endif
2270:../../Source/tasks.c **** 
2271:../../Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
2272:../../Source/tasks.c **** 	{
2273:../../Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
2274:../../Source/tasks.c **** 	}
2275:../../Source/tasks.c **** 	#else
2276:../../Source/tasks.c **** 	{
2277:../../Source/tasks.c **** 		( void ) xRegions;
2278:../../Source/tasks.c **** 		( void ) usStackDepth;
2279:../../Source/tasks.c **** 	}
2280:../../Source/tasks.c **** 	#endif
2281:../../Source/tasks.c **** }
2282:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2283:../../Source/tasks.c **** 
2284:../../Source/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
2285:../../Source/tasks.c **** 
2286:../../Source/tasks.c **** 	void vTaskAllocateMPURegions( xTaskHandle xTaskToModify, const xMemoryRegion * const xRegions )
2287:../../Source/tasks.c **** 	{
2288:../../Source/tasks.c **** 	tskTCB *pxTCB;
2289:../../Source/tasks.c **** 
2290:../../Source/tasks.c **** 		if( xTaskToModify == pxCurrentTCB )
2291:../../Source/tasks.c **** 		{
2292:../../Source/tasks.c **** 			xTaskToModify = NULL;
2293:../../Source/tasks.c **** 		}
2294:../../Source/tasks.c **** 
2295:../../Source/tasks.c **** 		/* If null is passed in here then we are deleting ourselves. */
2296:../../Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
2297:../../Source/tasks.c **** 
2298:../../Source/tasks.c ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
2299:../../Source/tasks.c **** 	}
2300:../../Source/tasks.c **** 	/*-----------------------------------------------------------*/
2301:../../Source/tasks.c **** #endif
2302:../../Source/tasks.c **** 
2303:../../Source/tasks.c **** static void prvInitialiseTaskLists( void )
2304:../../Source/tasks.c **** {
2305:../../Source/tasks.c **** unsigned portBASE_TYPE uxPriority;
2306:../../Source/tasks.c **** 
2307:../../Source/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
2308:../../Source/tasks.c **** 	{
2309:../../Source/tasks.c **** 		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
2310:../../Source/tasks.c **** 	}
2311:../../Source/tasks.c **** 
2312:../../Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList1 );
2313:../../Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList2 );
2314:../../Source/tasks.c **** 	vListInitialise( ( xList * ) &xPendingReadyList );
2315:../../Source/tasks.c **** 
2316:../../Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2317:../../Source/tasks.c **** 	{
2318:../../Source/tasks.c **** 		vListInitialise( ( xList * ) &xTasksWaitingTermination );
2319:../../Source/tasks.c **** 	}
2320:../../Source/tasks.c **** 	#endif
2321:../../Source/tasks.c **** 
2322:../../Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
2323:../../Source/tasks.c **** 	{
2324:../../Source/tasks.c **** 		vListInitialise( ( xList * ) &xSuspendedTaskList );
2325:../../Source/tasks.c **** 	}
2326:../../Source/tasks.c **** 	#endif
2327:../../Source/tasks.c **** 
2328:../../Source/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
2329:../../Source/tasks.c **** 	using list2. */
2330:../../Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
2331:../../Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
2332:../../Source/tasks.c **** }
2333:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2334:../../Source/tasks.c **** 
2335:../../Source/tasks.c **** static void prvCheckTasksWaitingTermination( void )
2336:../../Source/tasks.c **** {
2337:../../Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2338:../../Source/tasks.c **** 	{
2339:../../Source/tasks.c **** 		portBASE_TYPE xListIsEmpty;
2340:../../Source/tasks.c **** 
2341:../../Source/tasks.c **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
2342:../../Source/tasks.c **** 		too often in the idle task. */
2343:../../Source/tasks.c **** 		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
2344:../../Source/tasks.c **** 		{
2345:../../Source/tasks.c **** 			vTaskSuspendAll();
2346:../../Source/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
2347:../../Source/tasks.c **** 			xTaskResumeAll();
2348:../../Source/tasks.c **** 
2349:../../Source/tasks.c **** 			if( xListIsEmpty == pdFALSE )
2350:../../Source/tasks.c **** 			{
2351:../../Source/tasks.c **** 				tskTCB *pxTCB;
2352:../../Source/tasks.c **** 
2353:../../Source/tasks.c **** 				taskENTER_CRITICAL();
2354:../../Source/tasks.c **** 				{
2355:../../Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
2356:../../Source/tasks.c **** 					uxListRemove( &( pxTCB->xGenericListItem ) );
2357:../../Source/tasks.c **** 					--uxCurrentNumberOfTasks;
2358:../../Source/tasks.c **** 					--uxTasksDeleted;
2359:../../Source/tasks.c **** 				}
2360:../../Source/tasks.c **** 				taskEXIT_CRITICAL();
2361:../../Source/tasks.c **** 
2362:../../Source/tasks.c **** 				prvDeleteTCB( pxTCB );
2363:../../Source/tasks.c **** 			}
2364:../../Source/tasks.c **** 		}
2365:../../Source/tasks.c **** 	}
2366:../../Source/tasks.c **** 	#endif
2367:../../Source/tasks.c **** }
2368:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2369:../../Source/tasks.c **** 
2370:../../Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
2371:../../Source/tasks.c **** {
  37               		.loc 1 2371 0
  38               		.cfi_startproc
  39               	.LVL0:
  40 000e CF93      		push r28
  41               	.LCFI0:
  42               		.cfi_def_cfa_offset 4
  43               		.cfi_offset 28, -3
  44 0010 DF93      		push r29
  45               	.LCFI1:
  46               		.cfi_def_cfa_offset 5
  47               		.cfi_offset 29, -4
  48               	/* prologue: function */
  49               	/* frame size = 0 */
  50               	/* stack size = 2 */
  51               	.L__stack_usage = 2
  52 0012 EC01      		movw r28,r24
2372:../../Source/tasks.c **** 	/* The list item will be inserted in wake time order. */
2373:../../Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
  53               		.loc 1 2373 0
  54 0014 E091 0000 		lds r30,pxCurrentTCB
  55 0018 F091 0000 		lds r31,pxCurrentTCB+1
  56 001c 9383      		std Z+3,r25
  57 001e 8283      		std Z+2,r24
2374:../../Source/tasks.c **** 
2375:../../Source/tasks.c **** 	if( xTimeToWake < xTickCount )
  58               		.loc 1 2375 0
  59 0020 8091 0000 		lds r24,xTickCount
  60 0024 9091 0000 		lds r25,xTickCount+1
  61               	.LVL1:
  62 0028 C817      		cp r28,r24
  63 002a D907      		cpc r29,r25
  64 002c 00F4      		brsh .L8
  65               	.LBB15:
  66               	.LBB16:
2376:../../Source/tasks.c **** 	{
2377:../../Source/tasks.c **** 		/* Wake time has overflowed.  Place this item in the overflow list. */
2378:../../Source/tasks.c **** 		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericList
  67               		.loc 1 2378 0
  68 002e 8091 0000 		lds r24,pxOverflowDelayedTaskList
  69 0032 9091 0000 		lds r25,pxOverflowDelayedTaskList+1
  70 0036 6091 0000 		lds r22,pxCurrentTCB
  71 003a 7091 0000 		lds r23,pxCurrentTCB+1
  72 003e 6E5F      		subi r22,lo8(-(2))
  73 0040 7F4F      		sbci r23,hi8(-(2))
  74 0042 0E94 0000 		call vListInsert
  75 0046 00C0      		rjmp .L7
  76               	.L8:
  77               	.LBE16:
  78               	.LBE15:
2379:../../Source/tasks.c **** 	}
2380:../../Source/tasks.c **** 	else
2381:../../Source/tasks.c **** 	{
2382:../../Source/tasks.c **** 		/* The wake time has not overflowed, so we can use the current block list. */
2383:../../Source/tasks.c **** 		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) )
  79               		.loc 1 2383 0
  80 0048 8091 0000 		lds r24,pxDelayedTaskList
  81 004c 9091 0000 		lds r25,pxDelayedTaskList+1
  82 0050 6091 0000 		lds r22,pxCurrentTCB
  83 0054 7091 0000 		lds r23,pxCurrentTCB+1
  84 0058 6E5F      		subi r22,lo8(-(2))
  85 005a 7F4F      		sbci r23,hi8(-(2))
  86 005c 0E94 0000 		call vListInsert
2384:../../Source/tasks.c **** 
2385:../../Source/tasks.c **** 		/* If the task entering the blocked state was placed at the head of the
2386:../../Source/tasks.c **** 		list of blocked tasks then xNextTaskUnblockTime needs to be updated
2387:../../Source/tasks.c **** 		too. */
2388:../../Source/tasks.c **** 		if( xTimeToWake < xNextTaskUnblockTime )
  87               		.loc 1 2388 0
  88 0060 8091 0000 		lds r24,xNextTaskUnblockTime
  89 0064 9091 0000 		lds r25,xNextTaskUnblockTime+1
  90 0068 C817      		cp r28,r24
  91 006a D907      		cpc r29,r25
  92 006c 00F4      		brsh .L7
2389:../../Source/tasks.c **** 		{
2390:../../Source/tasks.c **** 			xNextTaskUnblockTime = xTimeToWake;
  93               		.loc 1 2390 0
  94 006e D093 0000 		sts xNextTaskUnblockTime+1,r29
  95 0072 C093 0000 		sts xNextTaskUnblockTime,r28
  96               	.L7:
  97               	/* epilogue start */
2391:../../Source/tasks.c **** 		}
2392:../../Source/tasks.c **** 	}
2393:../../Source/tasks.c **** }
  98               		.loc 1 2393 0
  99 0076 DF91      		pop r29
 100 0078 CF91      		pop r28
 101               	.LVL2:
 102 007a 0895      		ret
 103               		.cfi_endproc
 104               	.LFE26:
 106               	.global	xTaskGenericCreate
 108               	xTaskGenericCreate:
 109               	.LFB1:
 487:../../Source/tasks.c **** {
 110               		.loc 1 487 0
 111               		.cfi_startproc
 112               	.LVL3:
 113 007c 4F92      		push r4
 114               	.LCFI2:
 115               		.cfi_def_cfa_offset 4
 116               		.cfi_offset 4, -3
 117 007e 5F92      		push r5
 118               	.LCFI3:
 119               		.cfi_def_cfa_offset 5
 120               		.cfi_offset 5, -4
 121 0080 6F92      		push r6
 122               	.LCFI4:
 123               		.cfi_def_cfa_offset 6
 124               		.cfi_offset 6, -5
 125 0082 7F92      		push r7
 126               	.LCFI5:
 127               		.cfi_def_cfa_offset 7
 128               		.cfi_offset 7, -6
 129 0084 8F92      		push r8
 130               	.LCFI6:
 131               		.cfi_def_cfa_offset 8
 132               		.cfi_offset 8, -7
 133 0086 9F92      		push r9
 134               	.LCFI7:
 135               		.cfi_def_cfa_offset 9
 136               		.cfi_offset 9, -8
 137 0088 BF92      		push r11
 138               	.LCFI8:
 139               		.cfi_def_cfa_offset 10
 140               		.cfi_offset 11, -9
 141 008a CF92      		push r12
 142               	.LCFI9:
 143               		.cfi_def_cfa_offset 11
 144               		.cfi_offset 12, -10
 145 008c DF92      		push r13
 146               	.LCFI10:
 147               		.cfi_def_cfa_offset 12
 148               		.cfi_offset 13, -11
 149 008e EF92      		push r14
 150               	.LCFI11:
 151               		.cfi_def_cfa_offset 13
 152               		.cfi_offset 14, -12
 153 0090 FF92      		push r15
 154               	.LCFI12:
 155               		.cfi_def_cfa_offset 14
 156               		.cfi_offset 15, -13
 157 0092 0F93      		push r16
 158               	.LCFI13:
 159               		.cfi_def_cfa_offset 15
 160               		.cfi_offset 16, -14
 161 0094 1F93      		push r17
 162               	.LCFI14:
 163               		.cfi_def_cfa_offset 16
 164               		.cfi_offset 17, -15
 165 0096 CF93      		push r28
 166               	.LCFI15:
 167               		.cfi_def_cfa_offset 17
 168               		.cfi_offset 28, -16
 169 0098 DF93      		push r29
 170               	.LCFI16:
 171               		.cfi_def_cfa_offset 18
 172               		.cfi_offset 29, -17
 173               	/* prologue: function */
 174               	/* frame size = 0 */
 175               	/* stack size = 15 */
 176               	.L__stack_usage = 15
 177 009a 2C01      		movw r4,r24
 178 009c 4B01      		movw r8,r22
 179 009e EA01      		movw r28,r20
 180 00a0 3901      		movw r6,r18
 181 00a2 B02E      		mov r11,r16
 182               	.LVL4:
 183               	.LBB17:
 184               	.LBB18:
2394:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2395:../../Source/tasks.c **** 
2396:../../Source/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
2397:../../Source/tasks.c **** {
2398:../../Source/tasks.c **** tskTCB *pxNewTCB;
2399:../../Source/tasks.c **** 
2400:../../Source/tasks.c **** 	/* Allocate space for the TCB.  Where the memory comes from depends on
2401:../../Source/tasks.c **** 	the implementation of the port malloc function. */
2402:../../Source/tasks.c **** 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 185               		.loc 1 2402 0
 186 00a4 8AE2      		ldi r24,lo8(42)
 187 00a6 90E0      		ldi r25,hi8(42)
 188               	.LVL5:
 189 00a8 0E94 0000 		call pvPortMalloc
 190               	.LVL6:
 191 00ac 8C01      		movw r16,r24
 192               	.LVL7:
2403:../../Source/tasks.c **** 
2404:../../Source/tasks.c **** 	if( pxNewTCB != NULL )
 193               		.loc 1 2404 0
 194 00ae 0097      		sbiw r24,0
 195 00b0 01F4      		brne .+2
 196 00b2 00C0      		rjmp .L21
 197               	.LVL8:
2405:../../Source/tasks.c **** 	{
2406:../../Source/tasks.c **** 		/* Allocate space for the stack used by the task being created.
2407:../../Source/tasks.c **** 		The base of the stack memory stored in the TCB so the task can
2408:../../Source/tasks.c **** 		be deleted later if required. */
2409:../../Source/tasks.c **** 		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * size
 198               		.loc 1 2409 0
 199 00b4 C114      		cp r12,__zero_reg__
 200 00b6 D104      		cpc r13,__zero_reg__
 201 00b8 01F4      		brne .L12
 202 00ba CE01      		movw r24,r28
 203               	.LVL9:
 204 00bc 0E94 0000 		call pvPortMalloc
 205 00c0 6C01      		movw r12,r24
 206               	.LVL10:
 207               	.L12:
 208 00c2 F801      		movw r30,r16
 209 00c4 D08E      		std Z+24,r13
 210 00c6 C78A      		std Z+23,r12
2410:../../Source/tasks.c **** 
2411:../../Source/tasks.c **** 		if( pxNewTCB->pxStack == NULL )
 211               		.loc 1 2411 0
 212 00c8 C114      		cp r12,__zero_reg__
 213 00ca D104      		cpc r13,__zero_reg__
 214 00cc 01F4      		brne .L13
2412:../../Source/tasks.c **** 		{
2413:../../Source/tasks.c **** 			/* Could not allocate the stack.  Delete the allocated TCB. */
2414:../../Source/tasks.c **** 			vPortFree( pxNewTCB );
 215               		.loc 1 2414 0
 216 00ce C801      		movw r24,r16
 217 00d0 0E94 0000 		call vPortFree
 218               	.LVL11:
 219 00d4 00C0      		rjmp .L21
 220               	.LVL12:
 221               	.L13:
2415:../../Source/tasks.c **** 			pxNewTCB = NULL;
2416:../../Source/tasks.c **** 		}
2417:../../Source/tasks.c **** 		else
2418:../../Source/tasks.c **** 		{
2419:../../Source/tasks.c **** 			/* Just to help debugging. */
2420:../../Source/tasks.c **** 			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTA
 222               		.loc 1 2420 0
 223 00d6 C601      		movw r24,r12
 224 00d8 65EA      		ldi r22,lo8(165)
 225 00da 70E0      		ldi r23,hi8(165)
 226 00dc AE01      		movw r20,r28
 227 00de 0E94 0000 		call memset
 228               	.LBE18:
 229               	.LBE17:
 230               	.LBB20:
 522:../../Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 231               		.loc 1 522 0
 232 00e2 CE01      		movw r24,r28
 233 00e4 0197      		sbiw r24,1
 234 00e6 F801      		movw r30,r16
 235 00e8 C788      		ldd r12,Z+23
 236 00ea D08C      		ldd r13,Z+24
 237 00ec C80E      		add r12,r24
 238 00ee D91E      		adc r13,r25
 239               	.LVL13:
 240               	.LBB21:
 241               	.LBB22:
2223:../../Source/tasks.c **** 		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK
 242               		.loc 1 2223 0
 243 00f0 C801      		movw r24,r16
 244 00f2 4996      		adiw r24,25
 245 00f4 B401      		movw r22,r8
 246 00f6 40E1      		ldi r20,lo8(16)
 247 00f8 50E0      		ldi r21,hi8(16)
 248 00fa 0E94 0000 		call strncpy
2226:../../Source/tasks.c **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed 
 249               		.loc 1 2226 0
 250 00fe F801      		movw r30,r16
 251 0100 10A6      		std Z+40,__zero_reg__
 252 0102 CB2D      		mov r28,r11
 253               	.LVL14:
 254 0104 F3E0      		ldi r31,lo8(3)
 255 0106 FB15      		cp r31,r11
 256 0108 00F4      		brsh .L14
 257 010a C3E0      		ldi r28,lo8(3)
 258               	.L14:
 259               	.LVL15:
2235:../../Source/tasks.c **** 	pxTCB->uxPriority = uxPriority;
 260               		.loc 1 2235 0
 261 010c F801      		movw r30,r16
 262 010e C68B      		std Z+22,r28
2238:../../Source/tasks.c **** 		pxTCB->uxBasePriority = uxPriority;
 263               		.loc 1 2238 0
 264 0110 C1A7      		std Z+41,r28
2242:../../Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 265               		.loc 1 2242 0
 266 0112 72E0      		ldi r23,lo8(2)
 267 0114 872E      		mov r8,r23
 268 0116 912C      		mov r9,__zero_reg__
 269               	.LVL16:
 270 0118 800E      		add r8,r16
 271 011a 911E      		adc r9,r17
 272 011c C401      		movw r24,r8
 273 011e 0E94 0000 		call vListInitialiseItem
2243:../../Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 274               		.loc 1 2243 0
 275 0122 C801      		movw r24,r16
 276 0124 0C96      		adiw r24,12
 277 0126 0E94 0000 		call vListInitialiseItem
2247:../../Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 278               		.loc 1 2247 0
 279 012a F801      		movw r30,r16
 280 012c 1187      		std Z+9,r17
 281 012e 0087      		std Z+8,r16
2250:../../Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPri
 282               		.loc 1 2250 0
 283 0130 84E0      		ldi r24,lo8(4)
 284 0132 90E0      		ldi r25,hi8(4)
 285 0134 8C1B      		sub r24,r28
 286 0136 9109      		sbc r25,__zero_reg__
 287 0138 9587      		std Z+13,r25
 288 013a 8487      		std Z+12,r24
2251:../../Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 289               		.loc 1 2251 0
 290 013c 138B      		std Z+19,r17
 291 013e 028B      		std Z+18,r16
 292               	.LBE22:
 293               	.LBE21:
 555:../../Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 294               		.loc 1 555 0
 295 0140 C601      		movw r24,r12
 296 0142 B201      		movw r22,r4
 297 0144 A301      		movw r20,r6
 298 0146 0E94 0000 		call pxPortInitialiseStack
 299 014a F801      		movw r30,r16
 300 014c 9183      		std Z+1,r25
 301 014e 8083      		st Z,r24
 562:../../Source/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 302               		.loc 1 562 0
 303 0150 E114      		cp r14,__zero_reg__
 304 0152 F104      		cpc r15,__zero_reg__
 305 0154 01F0      		breq .L15
 567:../../Source/tasks.c **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 306               		.loc 1 567 0
 307 0156 F701      		movw r30,r14
 308 0158 1183      		std Z+1,r17
 309 015a 0083      		st Z,r16
 310               	.L15:
 572:../../Source/tasks.c **** 		taskENTER_CRITICAL();
 311               		.loc 1 572 0
 312               	/* #APP */
 313               	 ;  572 "../../Source/tasks.c" 1
 314 015c 0FB6      		in		__tmp_reg__, __SREG__
 315               	 ;  0 "" 2
 316               	 ;  572 "../../Source/tasks.c" 1
 317 015e F894      		cli
 318               	 ;  0 "" 2
 319               	 ;  572 "../../Source/tasks.c" 1
 320 0160 0F92      		push	__tmp_reg__
 321               	 ;  0 "" 2
 574:../../Source/tasks.c **** 			uxCurrentNumberOfTasks++;
 322               		.loc 1 574 0
 323               	/* #NOAPP */
 324 0162 8091 0000 		lds r24,uxCurrentNumberOfTasks
 325 0166 8F5F      		subi r24,lo8(-(1))
 326 0168 8093 0000 		sts uxCurrentNumberOfTasks,r24
 575:../../Source/tasks.c **** 			if( pxCurrentTCB == NULL )
 327               		.loc 1 575 0
 328 016c 8091 0000 		lds r24,pxCurrentTCB
 329 0170 9091 0000 		lds r25,pxCurrentTCB+1
 330 0174 0097      		sbiw r24,0
 331 0176 01F4      		brne .L16
 579:../../Source/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 332               		.loc 1 579 0
 333 0178 1093 0000 		sts pxCurrentTCB+1,r17
 334 017c 0093 0000 		sts pxCurrentTCB,r16
 581:../../Source/tasks.c **** 				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 335               		.loc 1 581 0
 336 0180 8091 0000 		lds r24,uxCurrentNumberOfTasks
 337 0184 8130      		cpi r24,lo8(1)
 338 0186 01F4      		brne .L17
 339 0188 C0E0      		ldi r28,lo8(0)
 340 018a D0E0      		ldi r29,hi8(0)
 341               	.LVL17:
 342               	.L18:
 343               	.LBB23:
 344               	.LBB24:
2309:../../Source/tasks.c **** 		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 345               		.loc 1 2309 0
 346 018c CE01      		movw r24,r28
 347 018e 63E0      		ldi r22,3
 348 0190 880F      	1:	lsl r24
 349 0192 991F      		rol r25
 350 0194 6A95      		dec r22
 351 0196 01F4      		brne 1b
 352 0198 8C0F      		add r24,r28
 353 019a 9D1F      		adc r25,r29
 354 019c 8050      		subi r24,lo8(-(pxReadyTasksLists))
 355 019e 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 356 01a0 0E94 0000 		call vListInitialise
 357 01a4 2196      		adiw r28,1
2307:../../Source/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 358               		.loc 1 2307 0
 359 01a6 C430      		cpi r28,4
 360 01a8 D105      		cpc r29,__zero_reg__
 361 01aa 01F4      		brne .L18
2312:../../Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 362               		.loc 1 2312 0
 363 01ac C0E0      		ldi r28,lo8(xDelayedTaskList1)
 364 01ae D0E0      		ldi r29,hi8(xDelayedTaskList1)
 365 01b0 CE01      		movw r24,r28
 366 01b2 0E94 0000 		call vListInitialise
2313:../../Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 367               		.loc 1 2313 0
 368 01b6 50E0      		ldi r21,lo8(xDelayedTaskList2)
 369 01b8 C52E      		mov r12,r21
 370 01ba 50E0      		ldi r21,hi8(xDelayedTaskList2)
 371 01bc D52E      		mov r13,r21
 372               	.LVL18:
 373 01be C601      		movw r24,r12
 374 01c0 0E94 0000 		call vListInitialise
2314:../../Source/tasks.c **** 	vListInitialise( ( xList * ) &xPendingReadyList );
 375               		.loc 1 2314 0
 376 01c4 80E0      		ldi r24,lo8(xPendingReadyList)
 377 01c6 90E0      		ldi r25,hi8(xPendingReadyList)
 378 01c8 0E94 0000 		call vListInitialise
2324:../../Source/tasks.c **** 		vListInitialise( ( xList * ) &xSuspendedTaskList );
 379               		.loc 1 2324 0
 380 01cc 80E0      		ldi r24,lo8(xSuspendedTaskList)
 381 01ce 90E0      		ldi r25,hi8(xSuspendedTaskList)
 382 01d0 0E94 0000 		call vListInitialise
2330:../../Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
 383               		.loc 1 2330 0
 384 01d4 D093 0000 		sts pxDelayedTaskList+1,r29
 385 01d8 C093 0000 		sts pxDelayedTaskList,r28
2331:../../Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 386               		.loc 1 2331 0
 387 01dc D092 0000 		sts pxOverflowDelayedTaskList+1,r13
 388 01e0 C092 0000 		sts pxOverflowDelayedTaskList,r12
 389 01e4 00C0      		rjmp .L17
 390               	.LVL19:
 391               	.L16:
 392               	.LBE24:
 393               	.LBE23:
 594:../../Source/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 394               		.loc 1 594 0
 395 01e6 8091 0000 		lds r24,xSchedulerRunning
 396 01ea 8823      		tst r24
 397 01ec 01F4      		brne .L17
 596:../../Source/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 398               		.loc 1 596 0
 399 01ee E091 0000 		lds r30,pxCurrentTCB
 400 01f2 F091 0000 		lds r31,pxCurrentTCB+1
 401 01f6 8689      		ldd r24,Z+22
 402 01f8 B816      		cp r11,r24
 403 01fa 00F0      		brlo .L17
 598:../../Source/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 404               		.loc 1 598 0
 405 01fc 1093 0000 		sts pxCurrentTCB+1,r17
 406 0200 0093 0000 		sts pxCurrentTCB,r16
 407               	.LVL20:
 408               	.L17:
 605:../../Source/tasks.c **** 			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 409               		.loc 1 605 0
 410 0204 F801      		movw r30,r16
 411 0206 2689      		ldd r18,Z+22
 412 0208 8091 0000 		lds r24,uxTopUsedPriority
 413 020c 8217      		cp r24,r18
 414 020e 00F4      		brsh .L19
 607:../../Source/tasks.c **** 				uxTopUsedPriority = pxNewTCB->uxPriority;
 415               		.loc 1 607 0
 416 0210 2093 0000 		sts uxTopUsedPriority,r18
 417               	.L19:
 616:../../Source/tasks.c **** 			uxTaskNumber++;
 418               		.loc 1 616 0
 419 0214 8091 0000 		lds r24,uxTaskNumber
 420 0218 8F5F      		subi r24,lo8(-(1))
 421 021a 8093 0000 		sts uxTaskNumber,r24
 618:../../Source/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 422               		.loc 1 618 0
 423 021e 8091 0000 		lds r24,uxTopReadyPriority
 424 0222 8217      		cp r24,r18
 425 0224 00F4      		brsh .L20
 618:../../Source/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 426               		.loc 1 618 0 is_stmt 0 discriminator 1
 427 0226 2093 0000 		sts uxTopReadyPriority,r18
 428               	.L20:
 618:../../Source/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 429               		.loc 1 618 0 discriminator 2
 430 022a 30E0      		ldi r19,lo8(0)
 431 022c C901      		movw r24,r18
 432 022e 43E0      		ldi r20,3
 433 0230 880F      	1:	lsl r24
 434 0232 991F      		rol r25
 435 0234 4A95      		dec r20
 436 0236 01F4      		brne 1b
 437 0238 820F      		add r24,r18
 438 023a 931F      		adc r25,r19
 439 023c 8050      		subi r24,lo8(-(pxReadyTasksLists))
 440 023e 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 441 0240 B401      		movw r22,r8
 442 0242 0E94 0000 		call vListInsertEnd
 443               	.LVL21:
 624:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
 444               		.loc 1 624 0 is_stmt 1 discriminator 2
 445               	/* #APP */
 446               	 ;  624 "../../Source/tasks.c" 1
 447 0246 0F90      		pop		__tmp_reg__
 448               	 ;  0 "" 2
 449               	 ;  624 "../../Source/tasks.c" 1
 450 0248 0FBE      		out		__SREG__, __tmp_reg__
 451               	 ;  0 "" 2
 452               	/* #NOAPP */
 453               	.LBE20:
 634:../../Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 454               		.loc 1 634 0 discriminator 2
 455 024a 8091 0000 		lds r24,xSchedulerRunning
 456 024e 8823      		tst r24
 457 0250 01F0      		breq .L23
 638:../../Source/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 458               		.loc 1 638 0
 459 0252 E091 0000 		lds r30,pxCurrentTCB
 460 0256 F091 0000 		lds r31,pxCurrentTCB+1
 461 025a 8689      		ldd r24,Z+22
 462 025c 8B15      		cp r24,r11
 463 025e 00F4      		brsh .L23
 640:../../Source/tasks.c **** 				portYIELD_WITHIN_API();
 464               		.loc 1 640 0
 465 0260 0E94 0000 		call vPortYield
 466 0264 00C0      		rjmp .L23
 467               	.LVL22:
 468               	.L21:
 469               	.LBB25:
 470               	.LBB19:
 628:../../Source/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 471               		.loc 1 628 0
 472 0266 8FEF      		ldi r24,lo8(-1)
 473 0268 00C0      		rjmp .L11
 474               	.LVL23:
 475               	.L23:
 476               	.LBE19:
 477               	.LBE25:
 620:../../Source/tasks.c **** 			xReturn = pdPASS;
 478               		.loc 1 620 0
 479 026a 81E0      		ldi r24,lo8(1)
 480               	.LVL24:
 481               	.L11:
 482               	/* epilogue start */
 646:../../Source/tasks.c **** }
 483               		.loc 1 646 0
 484 026c DF91      		pop r29
 485 026e CF91      		pop r28
 486 0270 1F91      		pop r17
 487 0272 0F91      		pop r16
 488 0274 FF90      		pop r15
 489 0276 EF90      		pop r14
 490               	.LVL25:
 491 0278 DF90      		pop r13
 492 027a CF90      		pop r12
 493 027c BF90      		pop r11
 494               	.LVL26:
 495 027e 9F90      		pop r9
 496 0280 8F90      		pop r8
 497 0282 7F90      		pop r7
 498 0284 6F90      		pop r6
 499               	.LVL27:
 500 0286 5F90      		pop r5
 501 0288 4F90      		pop r4
 502               	.LVL28:
 503 028a 0895      		ret
 504               		.cfi_endproc
 505               	.LFE1:
 507               	.global	xTaskIsTaskSuspended
 509               	xTaskIsTaskSuspended:
 510               	.LFB5:
1114:../../Source/tasks.c **** 	{
 511               		.loc 1 1114 0
 512               		.cfi_startproc
 513               	.LVL29:
 514               	/* prologue: function */
 515               	/* frame size = 0 */
 516               	/* stack size = 0 */
 517               	.L__stack_usage = 0
 518 028c FC01      		movw r30,r24
 519               	.LVL30:
1123:../../Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 520               		.loc 1 1123 0
 521 028e 8285      		ldd r24,Z+10
 522 0290 9385      		ldd r25,Z+11
 523               	.LVL31:
 524 0292 20E0      		ldi r18,hi8(xSuspendedTaskList)
 525 0294 8030      		cpi r24,lo8(xSuspendedTaskList)
 526 0296 9207      		cpc r25,r18
 527 0298 01F4      		brne .L29
 528               	.LVL32:
 529               	.LBB28:
 530               	.LBB29:
1126:../../Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
 531               		.loc 1 1126 0
 532 029a 2489      		ldd r18,Z+20
 533 029c 3589      		ldd r19,Z+21
 534 029e 80E0      		ldi r24,hi8(xPendingReadyList)
 535 02a0 2030      		cpi r18,lo8(xPendingReadyList)
 536 02a2 3807      		cpc r19,r24
 537 02a4 01F0      		breq .L30
1115:../../Source/tasks.c **** 	portBASE_TYPE xReturn = pdFALSE;
 538               		.loc 1 1115 0
 539 02a6 81E0      		ldi r24,lo8(1)
 540 02a8 2115      		cp r18,__zero_reg__
 541 02aa 3105      		cpc r19,__zero_reg__
 542 02ac 01F0      		breq .L26
 543               	.L30:
 544 02ae 80E0      		ldi r24,lo8(0)
 545               	.LVL33:
 546 02b0 0895      		ret
 547               	.LVL34:
 548               	.L29:
 549               	.LBE29:
 550               	.LBE28:
 551 02b2 80E0      		ldi r24,lo8(0)
 552               	.L26:
 553               	.LVL35:
1140:../../Source/tasks.c **** 	}
 554               		.loc 1 1140 0
 555 02b4 0895      		ret
 556               		.cfi_endproc
 557               	.LFE5:
 559               	.global	vTaskResume
 561               	vTaskResume:
 562               	.LFB6:
1148:../../Source/tasks.c **** 	{
 563               		.loc 1 1148 0
 564               		.cfi_startproc
 565               	.LVL36:
 566 02b6 0F93      		push r16
 567               	.LCFI17:
 568               		.cfi_def_cfa_offset 4
 569               		.cfi_offset 16, -3
 570 02b8 1F93      		push r17
 571               	.LCFI18:
 572               		.cfi_def_cfa_offset 5
 573               		.cfi_offset 17, -4
 574 02ba CF93      		push r28
 575               	.LCFI19:
 576               		.cfi_def_cfa_offset 6
 577               		.cfi_offset 28, -5
 578 02bc DF93      		push r29
 579               	.LCFI20:
 580               		.cfi_def_cfa_offset 7
 581               		.cfi_offset 29, -6
 582               	/* prologue: function */
 583               	/* frame size = 0 */
 584               	/* stack size = 4 */
 585               	.L__stack_usage = 4
 586 02be EC01      		movw r28,r24
 587               	.LVL37:
1160:../../Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 588               		.loc 1 1160 0
 589 02c0 0097      		sbiw r24,0
 590 02c2 01F0      		breq .L31
1160:../../Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 591               		.loc 1 1160 0 is_stmt 0 discriminator 1
 592 02c4 8091 0000 		lds r24,pxCurrentTCB
 593 02c8 9091 0000 		lds r25,pxCurrentTCB+1
 594               	.LVL38:
 595 02cc C817      		cp r28,r24
 596 02ce D907      		cpc r29,r25
 597 02d0 01F0      		breq .L31
1162:../../Source/tasks.c **** 			taskENTER_CRITICAL();
 598               		.loc 1 1162 0 is_stmt 1
 599               	/* #APP */
 600               	 ;  1162 "../../Source/tasks.c" 1
 601 02d2 0FB6      		in		__tmp_reg__, __SREG__
 602               	 ;  0 "" 2
 603               	 ;  1162 "../../Source/tasks.c" 1
 604 02d4 F894      		cli
 605               	 ;  0 "" 2
 606               	 ;  1162 "../../Source/tasks.c" 1
 607 02d6 0F92      		push	__tmp_reg__
 608               	 ;  0 "" 2
1164:../../Source/tasks.c **** 				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 609               		.loc 1 1164 0
 610               	/* #NOAPP */
 611 02d8 CE01      		movw r24,r28
 612 02da 0E94 0000 		call xTaskIsTaskSuspended
 613 02de 8130      		cpi r24,lo8(1)
 614 02e0 01F4      		brne .L33
1170:../../Source/tasks.c **** 					uxListRemove(  &( pxTCB->xGenericListItem ) );
 615               		.loc 1 1170 0
 616 02e2 8E01      		movw r16,r28
 617 02e4 0E5F      		subi r16,lo8(-(2))
 618 02e6 1F4F      		sbci r17,hi8(-(2))
 619 02e8 C801      		movw r24,r16
 620 02ea 0E94 0000 		call uxListRemove
1171:../../Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 621               		.loc 1 1171 0
 622 02ee 2E89      		ldd r18,Y+22
 623 02f0 8091 0000 		lds r24,uxTopReadyPriority
 624 02f4 8217      		cp r24,r18
 625 02f6 00F4      		brsh .L34
1171:../../Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 626               		.loc 1 1171 0 is_stmt 0 discriminator 1
 627 02f8 2093 0000 		sts uxTopReadyPriority,r18
 628               	.L34:
1171:../../Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 629               		.loc 1 1171 0 discriminator 2
 630 02fc 30E0      		ldi r19,lo8(0)
 631 02fe C901      		movw r24,r18
 632 0300 E3E0      		ldi r30,3
 633 0302 880F      	1:	lsl r24
 634 0304 991F      		rol r25
 635 0306 EA95      		dec r30
 636 0308 01F4      		brne 1b
 637 030a 820F      		add r24,r18
 638 030c 931F      		adc r25,r19
 639 030e 8050      		subi r24,lo8(-(pxReadyTasksLists))
 640 0310 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 641 0312 B801      		movw r22,r16
 642 0314 0E94 0000 		call vListInsertEnd
1174:../../Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 643               		.loc 1 1174 0 is_stmt 1 discriminator 2
 644 0318 E091 0000 		lds r30,pxCurrentTCB
 645 031c F091 0000 		lds r31,pxCurrentTCB+1
 646 0320 9E89      		ldd r25,Y+22
 647 0322 8689      		ldd r24,Z+22
 648 0324 9817      		cp r25,r24
 649 0326 00F0      		brlo .L33
1178:../../Source/tasks.c **** 						portYIELD_WITHIN_API();
 650               		.loc 1 1178 0
 651 0328 0E94 0000 		call vPortYield
 652               	.L33:
1182:../../Source/tasks.c **** 			taskEXIT_CRITICAL();
 653               		.loc 1 1182 0
 654               	/* #APP */
 655               	 ;  1182 "../../Source/tasks.c" 1
 656 032c 0F90      		pop		__tmp_reg__
 657               	 ;  0 "" 2
 658               	 ;  1182 "../../Source/tasks.c" 1
 659 032e 0FBE      		out		__SREG__, __tmp_reg__
 660               	 ;  0 "" 2
 661               	/* #NOAPP */
 662               	.L31:
 663               	/* epilogue start */
1184:../../Source/tasks.c **** 	}
 664               		.loc 1 1184 0
 665 0330 DF91      		pop r29
 666 0332 CF91      		pop r28
 667 0334 1F91      		pop r17
 668 0336 0F91      		pop r16
 669 0338 0895      		ret
 670               		.cfi_endproc
 671               	.LFE6:
 673               	.global	xTaskResumeFromISR
 675               	xTaskResumeFromISR:
 676               	.LFB7:
1193:../../Source/tasks.c **** 	{
 677               		.loc 1 1193 0
 678               		.cfi_startproc
 679               	.LVL39:
 680 033a EF92      		push r14
 681               	.LCFI21:
 682               		.cfi_def_cfa_offset 4
 683               		.cfi_offset 14, -3
 684 033c FF92      		push r15
 685               	.LCFI22:
 686               		.cfi_def_cfa_offset 5
 687               		.cfi_offset 15, -4
 688 033e 1F93      		push r17
 689               	.LCFI23:
 690               		.cfi_def_cfa_offset 6
 691               		.cfi_offset 17, -5
 692 0340 CF93      		push r28
 693               	.LCFI24:
 694               		.cfi_def_cfa_offset 7
 695               		.cfi_offset 28, -6
 696 0342 DF93      		push r29
 697               	.LCFI25:
 698               		.cfi_def_cfa_offset 8
 699               		.cfi_offset 29, -7
 700               	/* prologue: function */
 701               	/* frame size = 0 */
 702               	/* stack size = 5 */
 703               	.L__stack_usage = 5
 704 0344 EC01      		movw r28,r24
 705               	.LVL40:
1204:../../Source/tasks.c **** 			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 706               		.loc 1 1204 0
 707 0346 0E94 0000 		call xTaskIsTaskSuspended
 708               	.LVL41:
 709 034a 8130      		cpi r24,lo8(1)
 710 034c 01F4      		brne .L40
1208:../../Source/tasks.c **** 				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 711               		.loc 1 1208 0
 712 034e 8091 0000 		lds r24,uxSchedulerSuspended
 713 0352 8823      		tst r24
 714 0354 01F4      		brne .L37
1210:../../Source/tasks.c **** 					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
 715               		.loc 1 1210 0
 716 0356 E091 0000 		lds r30,pxCurrentTCB
 717 035a F091 0000 		lds r31,pxCurrentTCB+1
 718 035e 11E0      		ldi r17,lo8(1)
 719 0360 9E89      		ldd r25,Y+22
 720 0362 8689      		ldd r24,Z+22
 721 0364 9817      		cp r25,r24
 722 0366 00F4      		brsh .L38
 723 0368 10E0      		ldi r17,lo8(0)
 724               	.L38:
 725               	.LVL42:
1211:../../Source/tasks.c **** 					uxListRemove(  &( pxTCB->xGenericListItem ) );
 726               		.loc 1 1211 0
 727 036a A2E0      		ldi r26,lo8(2)
 728 036c EA2E      		mov r14,r26
 729 036e F12C      		mov r15,__zero_reg__
 730 0370 EC0E      		add r14,r28
 731 0372 FD1E      		adc r15,r29
 732 0374 C701      		movw r24,r14
 733 0376 0E94 0000 		call uxListRemove
1212:../../Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 734               		.loc 1 1212 0
 735 037a 2E89      		ldd r18,Y+22
 736 037c 8091 0000 		lds r24,uxTopReadyPriority
 737 0380 8217      		cp r24,r18
 738 0382 00F4      		brsh .L39
1212:../../Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 739               		.loc 1 1212 0 is_stmt 0 discriminator 1
 740 0384 2093 0000 		sts uxTopReadyPriority,r18
 741               	.L39:
1212:../../Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 742               		.loc 1 1212 0 discriminator 2
 743 0388 30E0      		ldi r19,lo8(0)
 744 038a C901      		movw r24,r18
 745 038c F3E0      		ldi r31,3
 746 038e 880F      	1:	lsl r24
 747 0390 991F      		rol r25
 748 0392 FA95      		dec r31
 749 0394 01F4      		brne 1b
 750 0396 820F      		add r24,r18
 751 0398 931F      		adc r25,r19
 752 039a 8050      		subi r24,lo8(-(pxReadyTasksLists))
 753 039c 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 754 039e B701      		movw r22,r14
 755 03a0 0E94 0000 		call vListInsertEnd
 756 03a4 00C0      		rjmp .L36
 757               	.LVL43:
 758               	.L37:
1219:../../Source/tasks.c **** 					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 759               		.loc 1 1219 0 is_stmt 1
 760 03a6 BE01      		movw r22,r28
 761 03a8 645F      		subi r22,lo8(-(12))
 762 03aa 7F4F      		sbci r23,hi8(-(12))
 763 03ac 80E0      		ldi r24,lo8(xPendingReadyList)
 764 03ae 90E0      		ldi r25,hi8(xPendingReadyList)
 765 03b0 0E94 0000 		call vListInsertEnd
 766               	.L40:
1194:../../Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 767               		.loc 1 1194 0
 768 03b4 10E0      		ldi r17,lo8(0)
 769               	.LVL44:
 770               	.L36:
1226:../../Source/tasks.c **** 	}
 771               		.loc 1 1226 0
 772 03b6 812F      		mov r24,r17
 773               	/* epilogue start */
 774 03b8 DF91      		pop r29
 775 03ba CF91      		pop r28
 776               	.LVL45:
 777 03bc 1F91      		pop r17
 778               	.LVL46:
 779 03be FF90      		pop r15
 780 03c0 EF90      		pop r14
 781 03c2 0895      		ret
 782               		.cfi_endproc
 783               	.LFE7:
 785               		.data
 786               	.LC0:
 787 0000 4944 4C45 		.string	"IDLE"
 787      00
 788               		.text
 789               	.global	vTaskStartScheduler
 791               	vTaskStartScheduler:
 792               	.LFB8:
1239:../../Source/tasks.c **** {
 793               		.loc 1 1239 0
 794               		.cfi_startproc
 795 03c4 AF92      		push r10
 796               	.LCFI26:
 797               		.cfi_def_cfa_offset 4
 798               		.cfi_offset 10, -3
 799 03c6 BF92      		push r11
 800               	.LCFI27:
 801               		.cfi_def_cfa_offset 5
 802               		.cfi_offset 11, -4
 803 03c8 CF92      		push r12
 804               	.LCFI28:
 805               		.cfi_def_cfa_offset 6
 806               		.cfi_offset 12, -5
 807 03ca DF92      		push r13
 808               	.LCFI29:
 809               		.cfi_def_cfa_offset 7
 810               		.cfi_offset 13, -6
 811 03cc EF92      		push r14
 812               	.LCFI30:
 813               		.cfi_def_cfa_offset 8
 814               		.cfi_offset 14, -7
 815 03ce FF92      		push r15
 816               	.LCFI31:
 817               		.cfi_def_cfa_offset 9
 818               		.cfi_offset 15, -8
 819 03d0 0F93      		push r16
 820               	.LCFI32:
 821               		.cfi_def_cfa_offset 10
 822               		.cfi_offset 16, -9
 823               	/* prologue: function */
 824               	/* frame size = 0 */
 825               	/* stack size = 7 */
 826               	.L__stack_usage = 7
1252:../../Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
 827               		.loc 1 1252 0
 828 03d2 80E0      		ldi r24,lo8(gs(prvIdleTask))
 829 03d4 90E0      		ldi r25,hi8(gs(prvIdleTask))
 830 03d6 60E0      		ldi r22,lo8(.LC0)
 831 03d8 70E0      		ldi r23,hi8(.LC0)
 832 03da 45E5      		ldi r20,lo8(85)
 833 03dc 50E0      		ldi r21,hi8(85)
 834 03de 20E0      		ldi r18,lo8(0)
 835 03e0 30E0      		ldi r19,hi8(0)
 836 03e2 00E0      		ldi r16,lo8(0)
 837 03e4 EE24      		clr r14
 838 03e6 FF24      		clr r15
 839 03e8 CC24      		clr r12
 840 03ea DD24      		clr r13
 841 03ec AA24      		clr r10
 842 03ee BB24      		clr r11
 843 03f0 0E94 0000 		call xTaskGenericCreate
 844               	.LVL47:
1265:../../Source/tasks.c **** 	if( xReturn == pdPASS )
 845               		.loc 1 1265 0
 846 03f4 8130      		cpi r24,lo8(1)
 847 03f6 01F4      		brne .L41
1275:../../Source/tasks.c **** 		portDISABLE_INTERRUPTS();
 848               		.loc 1 1275 0
 849               	/* #APP */
 850               	 ;  1275 "../../Source/tasks.c" 1
 851 03f8 F894      		cli
 852               	 ;  0 "" 2
1277:../../Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
 853               		.loc 1 1277 0
 854               	/* #NOAPP */
 855 03fa 8093 0000 		sts xSchedulerRunning,r24
1278:../../Source/tasks.c **** 		xTickCount = ( portTickType ) 0U;
 856               		.loc 1 1278 0
 857 03fe 1092 0000 		sts xTickCount+1,__zero_reg__
 858 0402 1092 0000 		sts xTickCount,__zero_reg__
1287:../../Source/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
 859               		.loc 1 1287 0
 860 0406 0E94 0000 		call xPortStartScheduler
 861               	.L41:
 862               	/* epilogue start */
1300:../../Source/tasks.c **** }
 863               		.loc 1 1300 0
 864 040a 0F91      		pop r16
 865 040c FF90      		pop r15
 866 040e EF90      		pop r14
 867 0410 DF90      		pop r13
 868 0412 CF90      		pop r12
 869 0414 BF90      		pop r11
 870 0416 AF90      		pop r10
 871 0418 0895      		ret
 872               		.cfi_endproc
 873               	.LFE8:
 875               	.global	vTaskEndScheduler
 877               	vTaskEndScheduler:
 878               	.LFB9:
1304:../../Source/tasks.c **** {
 879               		.loc 1 1304 0
 880               		.cfi_startproc
 881               	/* prologue: function */
 882               	/* frame size = 0 */
 883               	/* stack size = 0 */
 884               	.L__stack_usage = 0
1308:../../Source/tasks.c **** 	portDISABLE_INTERRUPTS();
 885               		.loc 1 1308 0
 886               	/* #APP */
 887               	 ;  1308 "../../Source/tasks.c" 1
 888 041a F894      		cli
 889               	 ;  0 "" 2
1309:../../Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
 890               		.loc 1 1309 0
 891               	/* #NOAPP */
 892 041c 1092 0000 		sts xSchedulerRunning,__zero_reg__
1310:../../Source/tasks.c **** 	vPortEndScheduler();
 893               		.loc 1 1310 0
 894 0420 0E94 0000 		call vPortEndScheduler
 895               	/* epilogue start */
1311:../../Source/tasks.c **** }
 896               		.loc 1 1311 0
 897 0424 0895      		ret
 898               		.cfi_endproc
 899               	.LFE9:
 901               	.global	vTaskSuspendAll
 903               	vTaskSuspendAll:
 904               	.LFB10:
1315:../../Source/tasks.c **** {
 905               		.loc 1 1315 0
 906               		.cfi_startproc
 907               	/* prologue: function */
 908               	/* frame size = 0 */
 909               	/* stack size = 0 */
 910               	.L__stack_usage = 0
1318:../../Source/tasks.c **** 	++uxSchedulerSuspended;
 911               		.loc 1 1318 0
 912 0426 8091 0000 		lds r24,uxSchedulerSuspended
 913 042a 8F5F      		subi r24,lo8(-(1))
 914 042c 8093 0000 		sts uxSchedulerSuspended,r24
 915               	/* epilogue start */
1319:../../Source/tasks.c **** }
 916               		.loc 1 1319 0
 917 0430 0895      		ret
 918               		.cfi_endproc
 919               	.LFE10:
 921               	.global	xTaskGetTickCount
 923               	xTaskGetTickCount:
 924               	.LFB12:
1438:../../Source/tasks.c **** {
 925               		.loc 1 1438 0
 926               		.cfi_startproc
 927               	/* prologue: function */
 928               	/* frame size = 0 */
 929               	/* stack size = 0 */
 930               	.L__stack_usage = 0
1442:../../Source/tasks.c **** 	taskENTER_CRITICAL();
 931               		.loc 1 1442 0
 932               	/* #APP */
 933               	 ;  1442 "../../Source/tasks.c" 1
 934 0432 0FB6      		in		__tmp_reg__, __SREG__
 935               	 ;  0 "" 2
 936               	 ;  1442 "../../Source/tasks.c" 1
 937 0434 F894      		cli
 938               	 ;  0 "" 2
 939               	 ;  1442 "../../Source/tasks.c" 1
 940 0436 0F92      		push	__tmp_reg__
 941               	 ;  0 "" 2
1444:../../Source/tasks.c **** 		xTicks = xTickCount;
 942               		.loc 1 1444 0
 943               	/* #NOAPP */
 944 0438 8091 0000 		lds r24,xTickCount
 945 043c 9091 0000 		lds r25,xTickCount+1
 946               	.LVL48:
1446:../../Source/tasks.c **** 	taskEXIT_CRITICAL();
 947               		.loc 1 1446 0
 948               	/* #APP */
 949               	 ;  1446 "../../Source/tasks.c" 1
 950 0440 0F90      		pop		__tmp_reg__
 951               	 ;  0 "" 2
 952               	 ;  1446 "../../Source/tasks.c" 1
 953 0442 0FBE      		out		__SREG__, __tmp_reg__
 954               	 ;  0 "" 2
 955               	/* epilogue start */
1449:../../Source/tasks.c **** }
 956               		.loc 1 1449 0
 957               	/* #NOAPP */
 958 0444 0895      		ret
 959               		.cfi_endproc
 960               	.LFE12:
 962               	.global	xTaskGetTickCountFromISR
 964               	xTaskGetTickCountFromISR:
 965               	.LFB13:
1453:../../Source/tasks.c **** {
 966               		.loc 1 1453 0
 967               		.cfi_startproc
 968               	/* prologue: function */
 969               	/* frame size = 0 */
 970               	/* stack size = 0 */
 971               	.L__stack_usage = 0
 972               	.LVL49:
1458:../../Source/tasks.c **** 	xReturn = xTickCount;
 973               		.loc 1 1458 0
 974 0446 8091 0000 		lds r24,xTickCount
 975 044a 9091 0000 		lds r25,xTickCount+1
 976               	.LVL50:
 977               	/* epilogue start */
1462:../../Source/tasks.c **** }
 978               		.loc 1 1462 0
 979 044e 0895      		ret
 980               		.cfi_endproc
 981               	.LFE13:
 983               	.global	uxTaskGetNumberOfTasks
 985               	uxTaskGetNumberOfTasks:
 986               	.LFB14:
1466:../../Source/tasks.c **** {
 987               		.loc 1 1466 0
 988               		.cfi_startproc
 989               	/* prologue: function */
 990               	/* frame size = 0 */
 991               	/* stack size = 0 */
 992               	.L__stack_usage = 0
1469:../../Source/tasks.c **** 	return uxCurrentNumberOfTasks;
 993               		.loc 1 1469 0
 994 0450 8091 0000 		lds r24,uxCurrentNumberOfTasks
 995               	/* epilogue start */
1470:../../Source/tasks.c **** }
 996               		.loc 1 1470 0
 997 0454 0895      		ret
 998               		.cfi_endproc
 999               	.LFE14:
 1001               	.global	vTaskIncrementTick
 1003               	vTaskIncrementTick:
 1004               	.LFB15:
1659:../../Source/tasks.c **** {
 1005               		.loc 1 1659 0
 1006               		.cfi_startproc
 1007 0456 0F93      		push r16
 1008               	.LCFI33:
 1009               		.cfi_def_cfa_offset 4
 1010               		.cfi_offset 16, -3
 1011 0458 1F93      		push r17
 1012               	.LCFI34:
 1013               		.cfi_def_cfa_offset 5
 1014               		.cfi_offset 17, -4
 1015 045a CF93      		push r28
 1016               	.LCFI35:
 1017               		.cfi_def_cfa_offset 6
 1018               		.cfi_offset 28, -5
 1019 045c DF93      		push r29
 1020               	.LCFI36:
 1021               		.cfi_def_cfa_offset 7
 1022               		.cfi_offset 29, -6
 1023               	/* prologue: function */
 1024               	/* frame size = 0 */
 1025               	/* stack size = 4 */
 1026               	.L__stack_usage = 4
1666:../../Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1027               		.loc 1 1666 0
 1028 045e 8091 0000 		lds r24,uxSchedulerSuspended
 1029 0462 8823      		tst r24
 1030 0464 01F0      		breq .+2
 1031 0466 00C0      		rjmp .L49
1668:../../Source/tasks.c **** 		++xTickCount;
 1032               		.loc 1 1668 0
 1033 0468 8091 0000 		lds r24,xTickCount
 1034 046c 9091 0000 		lds r25,xTickCount+1
 1035 0470 0196      		adiw r24,1
 1036 0472 9093 0000 		sts xTickCount+1,r25
 1037 0476 8093 0000 		sts xTickCount,r24
1669:../../Source/tasks.c **** 		if( xTickCount == ( portTickType ) 0U )
 1038               		.loc 1 1669 0
 1039 047a 8091 0000 		lds r24,xTickCount
 1040 047e 9091 0000 		lds r25,xTickCount+1
 1041 0482 0097      		sbiw r24,0
 1042 0484 01F4      		brne .L50
 1043               	.LBB30:
1678:../../Source/tasks.c **** 			pxTemp = pxDelayedTaskList;
 1044               		.loc 1 1678 0
 1045 0486 8091 0000 		lds r24,pxDelayedTaskList
 1046 048a 9091 0000 		lds r25,pxDelayedTaskList+1
 1047               	.LVL51:
1679:../../Source/tasks.c **** 			pxDelayedTaskList = pxOverflowDelayedTaskList;
 1048               		.loc 1 1679 0
 1049 048e 2091 0000 		lds r18,pxOverflowDelayedTaskList
 1050 0492 3091 0000 		lds r19,pxOverflowDelayedTaskList+1
 1051 0496 3093 0000 		sts pxDelayedTaskList+1,r19
 1052 049a 2093 0000 		sts pxDelayedTaskList,r18
1680:../../Source/tasks.c **** 			pxOverflowDelayedTaskList = pxTemp;
 1053               		.loc 1 1680 0
 1054 049e 9093 0000 		sts pxOverflowDelayedTaskList+1,r25
 1055 04a2 8093 0000 		sts pxOverflowDelayedTaskList,r24
1681:../../Source/tasks.c **** 			xNumOfOverflows++;
 1056               		.loc 1 1681 0
 1057 04a6 8091 0000 		lds r24,xNumOfOverflows
 1058               	.LVL52:
 1059 04aa 8F5F      		subi r24,lo8(-(1))
 1060 04ac 8093 0000 		sts xNumOfOverflows,r24
1683:../../Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 1061               		.loc 1 1683 0
 1062 04b0 E091 0000 		lds r30,pxDelayedTaskList
 1063 04b4 F091 0000 		lds r31,pxDelayedTaskList+1
 1064 04b8 8081      		ld r24,Z
 1065 04ba 8823      		tst r24
 1066 04bc 01F4      		brne .L51
1690:../../Source/tasks.c **** 				xNextTaskUnblockTime = portMAX_DELAY;
 1067               		.loc 1 1690 0
 1068 04be 8FEF      		ldi r24,lo8(-1)
 1069 04c0 9FEF      		ldi r25,hi8(-1)
 1070 04c2 00C0      		rjmp .L59
 1071               	.L51:
1698:../../Source/tasks.c **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 1072               		.loc 1 1698 0
 1073 04c4 E091 0000 		lds r30,pxDelayedTaskList
 1074 04c8 F091 0000 		lds r31,pxDelayedTaskList+1
 1075 04cc 0580      		ldd __tmp_reg__,Z+5
 1076 04ce F681      		ldd r31,Z+6
 1077 04d0 E02D      		mov r30,__tmp_reg__
 1078 04d2 0680      		ldd __tmp_reg__,Z+6
 1079 04d4 F781      		ldd r31,Z+7
 1080 04d6 E02D      		mov r30,__tmp_reg__
 1081               	.LVL53:
1699:../../Source/tasks.c **** 				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 1082               		.loc 1 1699 0
 1083 04d8 8281      		ldd r24,Z+2
 1084 04da 9381      		ldd r25,Z+3
 1085               	.LVL54:
 1086               	.L59:
 1087 04dc 9093 0000 		sts xNextTaskUnblockTime+1,r25
 1088 04e0 8093 0000 		sts xNextTaskUnblockTime,r24
 1089               	.LVL55:
 1090               	.L50:
 1091               	.LBE30:
 1092               	.LBB31:
1704:../../Source/tasks.c **** 		prvCheckDelayedTasks();
 1093               		.loc 1 1704 0
 1094 04e4 2091 0000 		lds r18,xTickCount
 1095 04e8 3091 0000 		lds r19,xTickCount+1
 1096 04ec 8091 0000 		lds r24,xNextTaskUnblockTime
 1097 04f0 9091 0000 		lds r25,xNextTaskUnblockTime+1
 1098 04f4 2817      		cp r18,r24
 1099 04f6 3907      		cpc r19,r25
 1100 04f8 00F4      		brsh .+2
 1101 04fa 00C0      		rjmp .L48
 1102               	.L58:
1704:../../Source/tasks.c **** 		prvCheckDelayedTasks();
 1103               		.loc 1 1704 0 is_stmt 0 discriminator 1
 1104 04fc E091 0000 		lds r30,pxDelayedTaskList
 1105 0500 F091 0000 		lds r31,pxDelayedTaskList+1
 1106 0504 8081      		ld r24,Z
 1107 0506 8823      		tst r24
 1108 0508 01F4      		brne .L53
1704:../../Source/tasks.c **** 		prvCheckDelayedTasks();
 1109               		.loc 1 1704 0 discriminator 2
 1110 050a 8FEF      		ldi r24,lo8(-1)
 1111 050c 9FEF      		ldi r25,hi8(-1)
 1112 050e 00C0      		rjmp .L60
 1113               	.L53:
1704:../../Source/tasks.c **** 		prvCheckDelayedTasks();
 1114               		.loc 1 1704 0 discriminator 3
 1115 0510 E091 0000 		lds r30,pxDelayedTaskList
 1116 0514 F091 0000 		lds r31,pxDelayedTaskList+1
 1117 0518 0580      		ldd __tmp_reg__,Z+5
 1118 051a F681      		ldd r31,Z+6
 1119 051c E02D      		mov r30,__tmp_reg__
 1120 051e C681      		ldd r28,Z+6
 1121 0520 D781      		ldd r29,Z+7
 1122               	.LVL56:
 1123 0522 8A81      		ldd r24,Y+2
 1124 0524 9B81      		ldd r25,Y+3
 1125               	.LVL57:
 1126 0526 2091 0000 		lds r18,xTickCount
 1127 052a 3091 0000 		lds r19,xTickCount+1
 1128 052e 2817      		cp r18,r24
 1129 0530 3907      		cpc r19,r25
 1130 0532 00F4      		brsh .L54
 1131               	.LVL58:
 1132               	.L60:
1704:../../Source/tasks.c **** 		prvCheckDelayedTasks();
 1133               		.loc 1 1704 0
 1134 0534 9093 0000 		sts xNextTaskUnblockTime+1,r25
 1135 0538 8093 0000 		sts xNextTaskUnblockTime,r24
 1136 053c 00C0      		rjmp .L48
 1137               	.LVL59:
 1138               	.L54:
1704:../../Source/tasks.c **** 		prvCheckDelayedTasks();
 1139               		.loc 1 1704 0 discriminator 5
 1140 053e 8E01      		movw r16,r28
 1141 0540 0E5F      		subi r16,lo8(-(2))
 1142 0542 1F4F      		sbci r17,hi8(-(2))
 1143 0544 C801      		movw r24,r16
 1144               	.LVL60:
 1145 0546 0E94 0000 		call uxListRemove
 1146               	.LVL61:
 1147 054a 8C89      		ldd r24,Y+20
 1148 054c 9D89      		ldd r25,Y+21
 1149 054e 0097      		sbiw r24,0
 1150 0550 01F0      		breq .L55
1704:../../Source/tasks.c **** 		prvCheckDelayedTasks();
 1151               		.loc 1 1704 0 discriminator 6
 1152 0552 CE01      		movw r24,r28
 1153 0554 0C96      		adiw r24,12
 1154 0556 0E94 0000 		call uxListRemove
 1155               	.L55:
1704:../../Source/tasks.c **** 		prvCheckDelayedTasks();
 1156               		.loc 1 1704 0 discriminator 7
 1157 055a 2E89      		ldd r18,Y+22
 1158 055c 8091 0000 		lds r24,uxTopReadyPriority
 1159 0560 8217      		cp r24,r18
 1160 0562 00F4      		brsh .L56
1704:../../Source/tasks.c **** 		prvCheckDelayedTasks();
 1161               		.loc 1 1704 0 discriminator 8
 1162 0564 2093 0000 		sts uxTopReadyPriority,r18
 1163               	.L56:
1704:../../Source/tasks.c **** 		prvCheckDelayedTasks();
 1164               		.loc 1 1704 0 discriminator 9
 1165 0568 30E0      		ldi r19,lo8(0)
 1166 056a C901      		movw r24,r18
 1167 056c B3E0      		ldi r27,3
 1168 056e 880F      	1:	lsl r24
 1169 0570 991F      		rol r25
 1170 0572 BA95      		dec r27
 1171 0574 01F4      		brne 1b
 1172 0576 820F      		add r24,r18
 1173 0578 931F      		adc r25,r19
 1174 057a 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1175 057c 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1176 057e B801      		movw r22,r16
 1177 0580 0E94 0000 		call vListInsertEnd
 1178 0584 00C0      		rjmp .L58
 1179               	.LVL62:
 1180               	.L49:
 1181               	.LBE31:
1708:../../Source/tasks.c **** 		++uxMissedTicks;
 1182               		.loc 1 1708 0 is_stmt 1
 1183 0586 8091 0000 		lds r24,uxMissedTicks
 1184 058a 8F5F      		subi r24,lo8(-(1))
 1185 058c 8093 0000 		sts uxMissedTicks,r24
 1186               	.L48:
 1187               	/* epilogue start */
1729:../../Source/tasks.c **** }
 1188               		.loc 1 1729 0
 1189 0590 DF91      		pop r29
 1190 0592 CF91      		pop r28
 1191 0594 1F91      		pop r17
 1192 0596 0F91      		pop r16
 1193 0598 0895      		ret
 1194               		.cfi_endproc
 1195               	.LFE15:
 1197               	.global	xTaskResumeAll
 1199               	xTaskResumeAll:
 1200               	.LFB11:
1351:../../Source/tasks.c **** {
 1201               		.loc 1 1351 0
 1202               		.cfi_startproc
 1203 059a EF92      		push r14
 1204               	.LCFI37:
 1205               		.cfi_def_cfa_offset 4
 1206               		.cfi_offset 14, -3
 1207 059c FF92      		push r15
 1208               	.LCFI38:
 1209               		.cfi_def_cfa_offset 5
 1210               		.cfi_offset 15, -4
 1211 059e 0F93      		push r16
 1212               	.LCFI39:
 1213               		.cfi_def_cfa_offset 6
 1214               		.cfi_offset 16, -5
 1215 05a0 1F93      		push r17
 1216               	.LCFI40:
 1217               		.cfi_def_cfa_offset 7
 1218               		.cfi_offset 17, -6
 1219 05a2 CF93      		push r28
 1220               	.LCFI41:
 1221               		.cfi_def_cfa_offset 8
 1222               		.cfi_offset 28, -7
 1223 05a4 DF93      		push r29
 1224               	.LCFI42:
 1225               		.cfi_def_cfa_offset 9
 1226               		.cfi_offset 29, -8
 1227 05a6 0F92      		push __tmp_reg__
 1228               	.LCFI43:
 1229               		.cfi_def_cfa_offset 10
 1230 05a8 CDB7      		in r28,__SP_L__
 1231 05aa DEB7      		in r29,__SP_H__
 1232               	.LCFI44:
 1233               		.cfi_def_cfa_register 28
 1234               	/* prologue: function */
 1235               	/* frame size = 1 */
 1236               	/* stack size = 7 */
 1237               	.L__stack_usage = 7
 1238               	.LVL63:
1364:../../Source/tasks.c **** 	taskENTER_CRITICAL();
 1239               		.loc 1 1364 0
 1240               	/* #APP */
 1241               	 ;  1364 "../../Source/tasks.c" 1
 1242 05ac 0FB6      		in		__tmp_reg__, __SREG__
 1243               	 ;  0 "" 2
 1244               	 ;  1364 "../../Source/tasks.c" 1
 1245 05ae F894      		cli
 1246               	 ;  0 "" 2
 1247               	 ;  1364 "../../Source/tasks.c" 1
 1248 05b0 0F92      		push	__tmp_reg__
 1249               	 ;  0 "" 2
1366:../../Source/tasks.c **** 		--uxSchedulerSuspended;
 1250               		.loc 1 1366 0
 1251               	/* #NOAPP */
 1252 05b2 8091 0000 		lds r24,uxSchedulerSuspended
 1253 05b6 8150      		subi r24,lo8(-(-1))
 1254 05b8 8093 0000 		sts uxSchedulerSuspended,r24
1368:../../Source/tasks.c **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1255               		.loc 1 1368 0
 1256 05bc 8091 0000 		lds r24,uxSchedulerSuspended
 1257 05c0 8823      		tst r24
 1258 05c2 01F0      		breq .+2
 1259 05c4 00C0      		rjmp .L74
1370:../../Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
 1260               		.loc 1 1370 0
 1261 05c6 8091 0000 		lds r24,uxCurrentNumberOfTasks
 1262 05ca 8823      		tst r24
 1263 05cc 01F4      		brne .L72
 1264 05ce 00C0      		rjmp .L62
 1265               	.LVL64:
 1266               	.L66:
 1267               	.LBB32:
1378:../../Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
 1268               		.loc 1 1378 0
 1269 05d0 E091 0000 		lds r30,xPendingReadyList+5
 1270 05d4 F091 0000 		lds r31,xPendingReadyList+5+1
 1271 05d8 E680      		ldd r14,Z+6
 1272 05da F780      		ldd r15,Z+7
 1273               	.LVL65:
1379:../../Source/tasks.c **** 					uxListRemove( &( pxTCB->xEventListItem ) );
 1274               		.loc 1 1379 0
 1275 05dc C701      		movw r24,r14
 1276 05de 0C96      		adiw r24,12
 1277 05e0 0E94 0000 		call uxListRemove
1380:../../Source/tasks.c **** 					uxListRemove( &( pxTCB->xGenericListItem ) );
 1278               		.loc 1 1380 0
 1279 05e4 8701      		movw r16,r14
 1280 05e6 0E5F      		subi r16,lo8(-(2))
 1281 05e8 1F4F      		sbci r17,hi8(-(2))
 1282 05ea C801      		movw r24,r16
 1283 05ec 0E94 0000 		call uxListRemove
1381:../../Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1284               		.loc 1 1381 0
 1285 05f0 D701      		movw r26,r14
 1286 05f2 5696      		adiw r26,22
 1287 05f4 2C91      		ld r18,X
 1288 05f6 5697      		sbiw r26,22
 1289 05f8 8091 0000 		lds r24,uxTopReadyPriority
 1290 05fc 8217      		cp r24,r18
 1291 05fe 00F4      		brsh .L64
1381:../../Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1292               		.loc 1 1381 0 is_stmt 0 discriminator 1
 1293 0600 2093 0000 		sts uxTopReadyPriority,r18
 1294               	.L64:
1381:../../Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1295               		.loc 1 1381 0 discriminator 2
 1296 0604 30E0      		ldi r19,lo8(0)
 1297 0606 C901      		movw r24,r18
 1298 0608 43E0      		ldi r20,3
 1299 060a 880F      	1:	lsl r24
 1300 060c 991F      		rol r25
 1301 060e 4A95      		dec r20
 1302 0610 01F4      		brne 1b
 1303 0612 820F      		add r24,r18
 1304 0614 931F      		adc r25,r19
 1305 0616 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1306 0618 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1307 061a B801      		movw r22,r16
 1308 061c 0E94 0000 		call vListInsertEnd
1385:../../Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1309               		.loc 1 1385 0 is_stmt 1 discriminator 2
 1310 0620 E091 0000 		lds r30,pxCurrentTCB
 1311 0624 F091 0000 		lds r31,pxCurrentTCB+1
 1312 0628 D701      		movw r26,r14
 1313 062a 5696      		adiw r26,22
 1314 062c 9C91      		ld r25,X
 1315 062e 5697      		sbiw r26,22
 1316 0630 8689      		ldd r24,Z+22
 1317 0632 9817      		cp r25,r24
 1318 0634 00F0      		brlo .L76
1387:../../Source/tasks.c **** 						xYieldRequired = pdTRUE;
 1319               		.loc 1 1387 0
 1320 0636 B1E0      		ldi r27,lo8(1)
 1321 0638 B983      		std Y+1,r27
 1322 063a 00C0      		rjmp .L76
 1323               	.LVL66:
 1324               	.L72:
 1325               	.LBE32:
1370:../../Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
 1326               		.loc 1 1370 0
 1327 063c 1982      		std Y+1,__zero_reg__
 1328               	.L76:
 1329               	.LVL67:
 1330               	.LBB33:
1376:../../Source/tasks.c **** 				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 1331               		.loc 1 1376 0 discriminator 1
 1332 063e 8091 0000 		lds r24,xPendingReadyList
 1333 0642 8823      		tst r24
 1334 0644 01F4      		brne .L66
1394:../../Source/tasks.c **** 				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 1335               		.loc 1 1394 0
 1336 0646 8091 0000 		lds r24,uxMissedTicks
 1337 064a 8823      		tst r24
 1338 064c 01F4      		brne .L75
 1339 064e 00C0      		rjmp .L78
 1340               	.L69:
1398:../../Source/tasks.c **** 						vTaskIncrementTick();
 1341               		.loc 1 1398 0
 1342 0650 0E94 0000 		call vTaskIncrementTick
1399:../../Source/tasks.c **** 						--uxMissedTicks;
 1343               		.loc 1 1399 0
 1344 0654 8091 0000 		lds r24,uxMissedTicks
 1345 0658 8150      		subi r24,lo8(-(-1))
 1346 065a 8093 0000 		sts uxMissedTicks,r24
 1347               	.L75:
1396:../../Source/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 1348               		.loc 1 1396 0 discriminator 1
 1349 065e 8091 0000 		lds r24,uxMissedTicks
 1350 0662 8823      		tst r24
 1351 0664 01F4      		brne .L69
 1352 0666 00C0      		rjmp .L70
 1353               	.L78:
1412:../../Source/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 1354               		.loc 1 1412 0
 1355 0668 E981      		ldd r30,Y+1
 1356 066a E130      		cpi r30,lo8(1)
 1357 066c 01F0      		breq .L70
1412:../../Source/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 1358               		.loc 1 1412 0 is_stmt 0 discriminator 1
 1359 066e 8091 0000 		lds r24,xMissedYield
 1360 0672 8130      		cpi r24,lo8(1)
 1361 0674 01F4      		brne .L74
 1362               	.L70:
 1363               	.LVL68:
1415:../../Source/tasks.c **** 					xMissedYield = pdFALSE;
 1364               		.loc 1 1415 0 is_stmt 1
 1365 0676 1092 0000 		sts xMissedYield,__zero_reg__
1416:../../Source/tasks.c **** 					portYIELD_WITHIN_API();
 1366               		.loc 1 1416 0
 1367 067a 0E94 0000 		call vPortYield
1414:../../Source/tasks.c **** 					xAlreadyYielded = pdTRUE;
 1368               		.loc 1 1414 0
 1369 067e 81E0      		ldi r24,lo8(1)
 1370 0680 00C0      		rjmp .L62
 1371               	.LVL69:
 1372               	.L74:
1353:../../Source/tasks.c **** signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 1373               		.loc 1 1353 0
 1374 0682 80E0      		ldi r24,lo8(0)
 1375               	.LVL70:
 1376               	.L62:
 1377               	.LBE33:
1421:../../Source/tasks.c **** 	taskEXIT_CRITICAL();
 1378               		.loc 1 1421 0
 1379               	/* #APP */
 1380               	 ;  1421 "../../Source/tasks.c" 1
 1381 0684 0F90      		pop		__tmp_reg__
 1382               	 ;  0 "" 2
 1383               	 ;  1421 "../../Source/tasks.c" 1
 1384 0686 0FBE      		out		__SREG__, __tmp_reg__
 1385               	 ;  0 "" 2
 1386               	/* epilogue start */
1424:../../Source/tasks.c **** }
 1387               		.loc 1 1424 0
 1388               	/* #NOAPP */
 1389 0688 0F90      		pop __tmp_reg__
 1390 068a DF91      		pop r29
 1391 068c CF91      		pop r28
 1392 068e 1F91      		pop r17
 1393 0690 0F91      		pop r16
 1394 0692 FF90      		pop r15
 1395 0694 EF90      		pop r14
 1396 0696 0895      		ret
 1397               		.cfi_endproc
 1398               	.LFE11:
 1400               	.global	vTaskDelay
 1402               	vTaskDelay:
 1403               	.LFB3:
 793:../../Source/tasks.c **** 	{
 1404               		.loc 1 793 0
 1405               		.cfi_startproc
 1406               	.LVL71:
 1407 0698 0F93      		push r16
 1408               	.LCFI45:
 1409               		.cfi_def_cfa_offset 4
 1410               		.cfi_offset 16, -3
 1411 069a 1F93      		push r17
 1412               	.LCFI46:
 1413               		.cfi_def_cfa_offset 5
 1414               		.cfi_offset 17, -4
 1415 069c CF93      		push r28
 1416               	.LCFI47:
 1417               		.cfi_def_cfa_offset 6
 1418               		.cfi_offset 28, -5
 1419 069e DF93      		push r29
 1420               	.LCFI48:
 1421               		.cfi_def_cfa_offset 7
 1422               		.cfi_offset 29, -6
 1423               	/* prologue: function */
 1424               	/* frame size = 0 */
 1425               	/* stack size = 4 */
 1426               	.L__stack_usage = 4
 1427 06a0 8C01      		movw r16,r24
 1428               	.LVL72:
 798:../../Source/tasks.c **** 		if( xTicksToDelay > ( portTickType ) 0U )
 1429               		.loc 1 798 0
 1430 06a2 0097      		sbiw r24,0
 1431 06a4 01F0      		breq .L80
 1432               	.LVL73:
 800:../../Source/tasks.c **** 			vTaskSuspendAll();
 1433               		.loc 1 800 0
 1434 06a6 0E94 0000 		call vTaskSuspendAll
 814:../../Source/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 1435               		.loc 1 814 0
 1436 06aa C091 0000 		lds r28,xTickCount
 1437 06ae D091 0000 		lds r29,xTickCount+1
 1438 06b2 C00F      		add r28,r16
 1439 06b4 D11F      		adc r29,r17
 1440               	.LVL74:
 819:../../Source/tasks.c **** 				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
 1441               		.loc 1 819 0
 1442 06b6 8091 0000 		lds r24,pxCurrentTCB
 1443 06ba 9091 0000 		lds r25,pxCurrentTCB+1
 1444 06be 0296      		adiw r24,2
 1445 06c0 0E94 0000 		call uxListRemove
 826:../../Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 1446               		.loc 1 826 0
 1447 06c4 CE01      		movw r24,r28
 1448 06c6 0E94 0000 		call prvAddCurrentTaskToDelayedList
 828:../../Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 1449               		.loc 1 828 0
 1450 06ca 0E94 0000 		call xTaskResumeAll
 1451               	.LVL75:
 833:../../Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 1452               		.loc 1 833 0
 1453 06ce 8823      		tst r24
 1454 06d0 01F4      		brne .L79
 1455               	.LVL76:
 1456               	.L80:
 835:../../Source/tasks.c **** 			portYIELD_WITHIN_API();
 1457               		.loc 1 835 0
 1458 06d2 0E94 0000 		call vPortYield
 1459               	.L79:
 1460               	/* epilogue start */
 837:../../Source/tasks.c **** 	}
 1461               		.loc 1 837 0
 1462 06d6 DF91      		pop r29
 1463 06d8 CF91      		pop r28
 1464 06da 1F91      		pop r17
 1465 06dc 0F91      		pop r16
 1466               	.LVL77:
 1467 06de 0895      		ret
 1468               		.cfi_endproc
 1469               	.LFE3:
 1471               	.global	vTaskDelayUntil
 1473               	vTaskDelayUntil:
 1474               	.LFB2:
 721:../../Source/tasks.c **** 	{
 1475               		.loc 1 721 0
 1476               		.cfi_startproc
 1477               	.LVL78:
 1478 06e0 0F93      		push r16
 1479               	.LCFI49:
 1480               		.cfi_def_cfa_offset 4
 1481               		.cfi_offset 16, -3
 1482 06e2 1F93      		push r17
 1483               	.LCFI50:
 1484               		.cfi_def_cfa_offset 5
 1485               		.cfi_offset 17, -4
 1486 06e4 CF93      		push r28
 1487               	.LCFI51:
 1488               		.cfi_def_cfa_offset 6
 1489               		.cfi_offset 28, -5
 1490 06e6 DF93      		push r29
 1491               	.LCFI52:
 1492               		.cfi_def_cfa_offset 7
 1493               		.cfi_offset 29, -6
 1494               	/* prologue: function */
 1495               	/* frame size = 0 */
 1496               	/* stack size = 4 */
 1497               	.L__stack_usage = 4
 1498 06e8 8C01      		movw r16,r24
 1499 06ea EB01      		movw r28,r22
 1500               	.LVL79:
 728:../../Source/tasks.c **** 		vTaskSuspendAll();
 1501               		.loc 1 728 0
 1502 06ec 0E94 0000 		call vTaskSuspendAll
 1503               	.LVL80:
 731:../../Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 1504               		.loc 1 731 0
 1505 06f0 F801      		movw r30,r16
 1506 06f2 8081      		ld r24,Z
 1507 06f4 9181      		ldd r25,Z+1
 1508 06f6 C80F      		add r28,r24
 1509 06f8 D91F      		adc r29,r25
 1510               	.LVL81:
 733:../../Source/tasks.c **** 			if( xTickCount < *pxPreviousWakeTime )
 1511               		.loc 1 733 0
 1512 06fa 2091 0000 		lds r18,xTickCount
 1513 06fe 3091 0000 		lds r19,xTickCount+1
 1514 0702 2817      		cp r18,r24
 1515 0704 3907      		cpc r19,r25
 1516 0706 00F4      		brsh .L83
 740:../../Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 1517               		.loc 1 740 0
 1518 0708 C817      		cp r28,r24
 1519 070a D907      		cpc r29,r25
 1520 070c 00F4      		brsh .L89
 1521 070e 00C0      		rjmp .L93
 1522               	.L83:
 750:../../Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 1523               		.loc 1 750 0
 1524 0710 C817      		cp r28,r24
 1525 0712 D907      		cpc r29,r25
 1526 0714 00F0      		brlo .L90
 1527               	.L93:
 750:../../Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 1528               		.loc 1 750 0 is_stmt 0 discriminator 1
 1529 0716 8091 0000 		lds r24,xTickCount
 1530 071a 9091 0000 		lds r25,xTickCount+1
 723:../../Source/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 1531               		.loc 1 723 0 is_stmt 1 discriminator 1
 1532 071e 21E0      		ldi r18,lo8(1)
 1533 0720 8C17      		cp r24,r28
 1534 0722 9D07      		cpc r25,r29
 1535 0724 00F0      		brlo .L84
 1536               	.L89:
 723:../../Source/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 1537               		.loc 1 723 0 is_stmt 0
 1538 0726 20E0      		ldi r18,lo8(0)
 1539 0728 00C0      		rjmp .L84
 1540               	.L90:
 752:../../Source/tasks.c **** 					xShouldDelay = pdTRUE;
 1541               		.loc 1 752 0 is_stmt 1
 1542 072a 21E0      		ldi r18,lo8(1)
 1543               	.L84:
 1544               	.LVL82:
 757:../../Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 1545               		.loc 1 757 0
 1546 072c F801      		movw r30,r16
 1547 072e D183      		std Z+1,r29
 1548 0730 C083      		st Z,r28
 759:../../Source/tasks.c **** 			if( xShouldDelay != pdFALSE )
 1549               		.loc 1 759 0
 1550 0732 2223      		tst r18
 1551 0734 01F0      		breq .L87
 766:../../Source/tasks.c **** 				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
 1552               		.loc 1 766 0
 1553 0736 8091 0000 		lds r24,pxCurrentTCB
 1554 073a 9091 0000 		lds r25,pxCurrentTCB+1
 1555 073e 0296      		adiw r24,2
 1556 0740 0E94 0000 		call uxListRemove
 1557               	.LVL83:
 774:../../Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 1558               		.loc 1 774 0
 1559 0744 CE01      		movw r24,r28
 1560 0746 0E94 0000 		call prvAddCurrentTaskToDelayedList
 1561               	.L87:
 777:../../Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 1562               		.loc 1 777 0
 1563 074a 0E94 0000 		call xTaskResumeAll
 1564               	.LVL84:
 781:../../Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 1565               		.loc 1 781 0
 1566 074e 8823      		tst r24
 1567 0750 01F4      		brne .L82
 783:../../Source/tasks.c **** 			portYIELD_WITHIN_API();
 1568               		.loc 1 783 0
 1569 0752 0E94 0000 		call vPortYield
 1570               	.LVL85:
 1571               	.L82:
 1572               	/* epilogue start */
 785:../../Source/tasks.c **** 	}
 1573               		.loc 1 785 0
 1574 0756 DF91      		pop r29
 1575 0758 CF91      		pop r28
 1576               	.LVL86:
 1577 075a 1F91      		pop r17
 1578 075c 0F91      		pop r16
 1579               	.LVL87:
 1580 075e 0895      		ret
 1581               		.cfi_endproc
 1582               	.LFE2:
 1584               	.global	vTaskSwitchContext
 1586               	vTaskSwitchContext:
 1587               	.LFB16:
1820:../../Source/tasks.c **** {
 1588               		.loc 1 1820 0
 1589               		.cfi_startproc
 1590               	/* prologue: function */
 1591               	/* frame size = 0 */
 1592               	/* stack size = 0 */
 1593               	.L__stack_usage = 0
1821:../../Source/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 1594               		.loc 1 1821 0
 1595 0760 8091 0000 		lds r24,uxSchedulerSuspended
 1596 0764 8823      		tst r24
 1597 0766 01F0      		breq .L95
1825:../../Source/tasks.c **** 		xMissedYield = pdTRUE;
 1598               		.loc 1 1825 0
 1599 0768 81E0      		ldi r24,lo8(1)
 1600 076a 8093 0000 		sts xMissedYield,r24
 1601 076e 0895      		ret
 1602               	.L95:
1851:../../Source/tasks.c **** 		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
 1603               		.loc 1 1851 0
 1604 0770 A091 0000 		lds r26,pxCurrentTCB
 1605 0774 B091 0000 		lds r27,pxCurrentTCB+1
 1606 0778 E091 0000 		lds r30,pxCurrentTCB
 1607 077c F091 0000 		lds r31,pxCurrentTCB+1
 1608 0780 2D91      		ld r18,X+
 1609 0782 3C91      		ld r19,X
 1610 0784 1197      		sbiw r26,1
 1611 0786 8789      		ldd r24,Z+23
 1612 0788 908D      		ldd r25,Z+24
 1613 078a 8217      		cp r24,r18
 1614 078c 9307      		cpc r25,r19
 1615 078e 00F0      		brlo .L100
1851:../../Source/tasks.c **** 		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
 1616               		.loc 1 1851 0 is_stmt 0 discriminator 1
 1617 0790 8091 0000 		lds r24,pxCurrentTCB
 1618 0794 9091 0000 		lds r25,pxCurrentTCB+1
 1619 0798 6091 0000 		lds r22,pxCurrentTCB
 1620 079c 7091 0000 		lds r23,pxCurrentTCB+1
 1621 07a0 675E      		subi r22,lo8(-(25))
 1622 07a2 7F4F      		sbci r23,hi8(-(25))
 1623 07a4 0E94 0000 		call vApplicationStackOverflowHook
 1624               	.L98:
1854:../../Source/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
 1625               		.loc 1 1854 0 is_stmt 1 discriminator 2
 1626 07a8 8091 0000 		lds r24,uxTopReadyPriority
 1627 07ac 8150      		subi r24,lo8(-(-1))
 1628 07ae 8093 0000 		sts uxTopReadyPriority,r24
 1629               	.L100:
1854:../../Source/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
 1630               		.loc 1 1854 0 is_stmt 0 discriminator 1
 1631 07b2 8091 0000 		lds r24,uxTopReadyPriority
 1632 07b6 90E0      		ldi r25,lo8(0)
 1633 07b8 FC01      		movw r30,r24
 1634 07ba 63E0      		ldi r22,3
 1635 07bc EE0F      	1:	lsl r30
 1636 07be FF1F      		rol r31
 1637 07c0 6A95      		dec r22
 1638 07c2 01F4      		brne 1b
 1639 07c4 E80F      		add r30,r24
 1640 07c6 F91F      		adc r31,r25
 1641 07c8 E050      		subi r30,lo8(-(pxReadyTasksLists))
 1642 07ca F040      		sbci r31,hi8(-(pxReadyTasksLists))
 1643 07cc 8081      		ld r24,Z
 1644 07ce 8823      		tst r24
 1645 07d0 01F0      		breq .L98
 1646               	.LBB34:
1854:../../Source/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
 1647               		.loc 1 1854 0 discriminator 3
 1648 07d2 8091 0000 		lds r24,uxTopReadyPriority
 1649 07d6 90E0      		ldi r25,lo8(0)
 1650 07d8 FC01      		movw r30,r24
 1651 07da 53E0      		ldi r21,3
 1652 07dc EE0F      	1:	lsl r30
 1653 07de FF1F      		rol r31
 1654 07e0 5A95      		dec r21
 1655 07e2 01F4      		brne 1b
 1656 07e4 E80F      		add r30,r24
 1657 07e6 F91F      		adc r31,r25
 1658 07e8 E050      		subi r30,lo8(-(pxReadyTasksLists))
 1659 07ea F040      		sbci r31,hi8(-(pxReadyTasksLists))
 1660               	.LVL88:
 1661 07ec A181      		ldd r26,Z+1
 1662 07ee B281      		ldd r27,Z+2
 1663 07f0 1296      		adiw r26,2
 1664 07f2 0D90      		ld __tmp_reg__,X+
 1665 07f4 BC91      		ld r27,X
 1666 07f6 A02D      		mov r26,__tmp_reg__
 1667 07f8 B283      		std Z+2,r27
 1668 07fa A183      		std Z+1,r26
 1669 07fc CF01      		movw r24,r30
 1670 07fe 0396      		adiw r24,3
 1671 0800 A817      		cp r26,r24
 1672 0802 B907      		cpc r27,r25
 1673 0804 01F4      		brne .L99
1854:../../Source/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
 1674               		.loc 1 1854 0 discriminator 4
 1675 0806 1296      		adiw r26,2
 1676 0808 8D91      		ld r24,X+
 1677 080a 9C91      		ld r25,X
 1678 080c 1397      		sbiw r26,2+1
 1679 080e 9283      		std Z+2,r25
 1680 0810 8183      		std Z+1,r24
 1681               	.L99:
1854:../../Source/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
 1682               		.loc 1 1854 0 discriminator 5
 1683 0812 0180      		ldd __tmp_reg__,Z+1
 1684 0814 F281      		ldd r31,Z+2
 1685 0816 E02D      		mov r30,__tmp_reg__
 1686               	.LVL89:
 1687 0818 8681      		ldd r24,Z+6
 1688 081a 9781      		ldd r25,Z+7
 1689 081c 9093 0000 		sts pxCurrentTCB+1,r25
 1690 0820 8093 0000 		sts pxCurrentTCB,r24
 1691 0824 0895      		ret
 1692               	.LBE34:
 1693               		.cfi_endproc
 1694               	.LFE16:
 1696               	.global	vTaskSuspend
 1698               	vTaskSuspend:
 1699               	.LFB4:
1047:../../Source/tasks.c **** 	{
 1700               		.loc 1 1047 0 is_stmt 1
 1701               		.cfi_startproc
 1702               	.LVL90:
 1703 0826 EF92      		push r14
 1704               	.LCFI53:
 1705               		.cfi_def_cfa_offset 4
 1706               		.cfi_offset 14, -3
 1707 0828 FF92      		push r15
 1708               	.LCFI54:
 1709               		.cfi_def_cfa_offset 5
 1710               		.cfi_offset 15, -4
 1711 082a 0F93      		push r16
 1712               	.LCFI55:
 1713               		.cfi_def_cfa_offset 6
 1714               		.cfi_offset 16, -5
 1715 082c 1F93      		push r17
 1716               	.LCFI56:
 1717               		.cfi_def_cfa_offset 7
 1718               		.cfi_offset 17, -6
 1719 082e CF93      		push r28
 1720               	.LCFI57:
 1721               		.cfi_def_cfa_offset 8
 1722               		.cfi_offset 28, -7
 1723 0830 DF93      		push r29
 1724               	.LCFI58:
 1725               		.cfi_def_cfa_offset 9
 1726               		.cfi_offset 29, -8
 1727               	/* prologue: function */
 1728               	/* frame size = 0 */
 1729               	/* stack size = 6 */
 1730               	.L__stack_usage = 6
 1731 0832 7C01      		movw r14,r24
1050:../../Source/tasks.c **** 		taskENTER_CRITICAL();
 1732               		.loc 1 1050 0
 1733               	/* #APP */
 1734               	 ;  1050 "../../Source/tasks.c" 1
 1735 0834 0FB6      		in		__tmp_reg__, __SREG__
 1736               	 ;  0 "" 2
 1737               	 ;  1050 "../../Source/tasks.c" 1
 1738 0836 F894      		cli
 1739               	 ;  0 "" 2
 1740               	 ;  1050 "../../Source/tasks.c" 1
 1741 0838 0F92      		push	__tmp_reg__
 1742               	 ;  0 "" 2
1054:../../Source/tasks.c **** 			if( pxTaskToSuspend == pxCurrentTCB )
 1743               		.loc 1 1054 0
 1744               	/* #NOAPP */
 1745 083a 8091 0000 		lds r24,pxCurrentTCB
 1746 083e 9091 0000 		lds r25,pxCurrentTCB+1
 1747               	.LVL91:
 1748 0842 E816      		cp r14,r24
 1749 0844 F906      		cpc r15,r25
 1750 0846 01F0      		breq .L102
1060:../../Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 1751               		.loc 1 1060 0
 1752 0848 E114      		cp r14,__zero_reg__
 1753 084a F104      		cpc r15,__zero_reg__
 1754 084c 01F4      		brne .L108
 1755               	.L102:
1060:../../Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 1756               		.loc 1 1060 0 is_stmt 0 discriminator 1
 1757 084e C091 0000 		lds r28,pxCurrentTCB
 1758 0852 D091 0000 		lds r29,pxCurrentTCB+1
 1759 0856 EE24      		clr r14
 1760 0858 FF24      		clr r15
 1761 085a 00C0      		rjmp .L103
 1762               	.L108:
1060:../../Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 1763               		.loc 1 1060 0
 1764 085c E701      		movw r28,r14
 1765               	.L103:
 1766               	.LVL92:
1065:../../Source/tasks.c **** 			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
 1767               		.loc 1 1065 0 is_stmt 1 discriminator 3
 1768 085e 8E01      		movw r16,r28
 1769 0860 0E5F      		subi r16,lo8(-(2))
 1770 0862 1F4F      		sbci r17,hi8(-(2))
 1771 0864 C801      		movw r24,r16
 1772 0866 0E94 0000 		call uxListRemove
1071:../../Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 1773               		.loc 1 1071 0 discriminator 3
 1774 086a 8C89      		ldd r24,Y+20
 1775 086c 9D89      		ldd r25,Y+21
 1776 086e 0097      		sbiw r24,0
 1777 0870 01F0      		breq .L104
1073:../../Source/tasks.c **** 				uxListRemove( &( pxTCB->xEventListItem ) );
 1778               		.loc 1 1073 0
 1779 0872 CE01      		movw r24,r28
 1780 0874 0C96      		adiw r24,12
 1781 0876 0E94 0000 		call uxListRemove
 1782               	.L104:
1076:../../Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 1783               		.loc 1 1076 0
 1784 087a 80E0      		ldi r24,lo8(xSuspendedTaskList)
 1785 087c 90E0      		ldi r25,hi8(xSuspendedTaskList)
 1786 087e B801      		movw r22,r16
 1787 0880 0E94 0000 		call vListInsertEnd
1078:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
 1788               		.loc 1 1078 0
 1789               	/* #APP */
 1790               	 ;  1078 "../../Source/tasks.c" 1
 1791 0884 0F90      		pop		__tmp_reg__
 1792               	 ;  0 "" 2
 1793               	 ;  1078 "../../Source/tasks.c" 1
 1794 0886 0FBE      		out		__SREG__, __tmp_reg__
 1795               	 ;  0 "" 2
1080:../../Source/tasks.c **** 		if( ( void * ) pxTaskToSuspend == NULL )
 1796               		.loc 1 1080 0
 1797               	/* #NOAPP */
 1798 0888 E114      		cp r14,__zero_reg__
 1799 088a F104      		cpc r15,__zero_reg__
 1800 088c 01F4      		brne .L101
1082:../../Source/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
 1801               		.loc 1 1082 0
 1802 088e 8091 0000 		lds r24,xSchedulerRunning
 1803 0892 8823      		tst r24
 1804 0894 01F0      		breq .L106
1085:../../Source/tasks.c **** 				portYIELD_WITHIN_API();
 1805               		.loc 1 1085 0
 1806 0896 0E94 0000 		call vPortYield
 1807 089a 00C0      		rjmp .L101
 1808               	.L106:
1092:../../Source/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 1809               		.loc 1 1092 0
 1810 089c 9091 0000 		lds r25,xSuspendedTaskList
 1811 08a0 8091 0000 		lds r24,uxCurrentNumberOfTasks
 1812 08a4 9817      		cp r25,r24
 1813 08a6 01F4      		brne .L107
1098:../../Source/tasks.c **** 					pxCurrentTCB = NULL;
 1814               		.loc 1 1098 0
 1815 08a8 1092 0000 		sts pxCurrentTCB+1,__zero_reg__
 1816 08ac 1092 0000 		sts pxCurrentTCB,__zero_reg__
 1817 08b0 00C0      		rjmp .L101
 1818               	.L107:
1102:../../Source/tasks.c **** 					vTaskSwitchContext();
 1819               		.loc 1 1102 0
 1820 08b2 0E94 0000 		call vTaskSwitchContext
 1821               	.L101:
 1822               	/* epilogue start */
1106:../../Source/tasks.c **** 	}
 1823               		.loc 1 1106 0
 1824 08b6 DF91      		pop r29
 1825 08b8 CF91      		pop r28
 1826               	.LVL93:
 1827 08ba 1F91      		pop r17
 1828 08bc 0F91      		pop r16
 1829 08be FF90      		pop r15
 1830 08c0 EF90      		pop r14
 1831 08c2 0895      		ret
 1832               		.cfi_endproc
 1833               	.LFE4:
 1835               	.global	vTaskPlaceOnEventList
 1837               	vTaskPlaceOnEventList:
 1838               	.LFB17:
1862:../../Source/tasks.c **** {
 1839               		.loc 1 1862 0
 1840               		.cfi_startproc
 1841               	.LVL94:
 1842 08c4 CF93      		push r28
 1843               	.LCFI59:
 1844               		.cfi_def_cfa_offset 4
 1845               		.cfi_offset 28, -3
 1846 08c6 DF93      		push r29
 1847               	.LCFI60:
 1848               		.cfi_def_cfa_offset 5
 1849               		.cfi_offset 29, -4
 1850               	/* prologue: function */
 1851               	/* frame size = 0 */
 1852               	/* stack size = 2 */
 1853               	.L__stack_usage = 2
 1854 08c8 EB01      		movw r28,r22
1873:../../Source/tasks.c **** 	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 1855               		.loc 1 1873 0
 1856 08ca 6091 0000 		lds r22,pxCurrentTCB
 1857 08ce 7091 0000 		lds r23,pxCurrentTCB+1
 1858               	.LVL95:
 1859 08d2 645F      		subi r22,lo8(-(12))
 1860 08d4 7F4F      		sbci r23,hi8(-(12))
 1861 08d6 0E94 0000 		call vListInsert
 1862               	.LVL96:
1878:../../Source/tasks.c **** 	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
 1863               		.loc 1 1878 0
 1864 08da 8091 0000 		lds r24,pxCurrentTCB
 1865 08de 9091 0000 		lds r25,pxCurrentTCB+1
 1866 08e2 0296      		adiw r24,2
 1867 08e4 0E94 0000 		call uxListRemove
1887:../../Source/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
 1868               		.loc 1 1887 0
 1869 08e8 8FEF      		ldi r24,hi8(-1)
 1870 08ea CF3F      		cpi r28,lo8(-1)
 1871 08ec D807      		cpc r29,r24
 1872 08ee 01F4      		brne .L110
1892:../../Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListIt
 1873               		.loc 1 1892 0
 1874 08f0 6091 0000 		lds r22,pxCurrentTCB
 1875 08f4 7091 0000 		lds r23,pxCurrentTCB+1
 1876 08f8 6E5F      		subi r22,lo8(-(2))
 1877 08fa 7F4F      		sbci r23,hi8(-(2))
 1878 08fc 80E0      		ldi r24,lo8(xSuspendedTaskList)
 1879 08fe 90E0      		ldi r25,hi8(xSuspendedTaskList)
 1880 0900 0E94 0000 		call vListInsertEnd
 1881 0904 00C0      		rjmp .L109
 1882               	.L110:
1898:../../Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
 1883               		.loc 1 1898 0
 1884 0906 8091 0000 		lds r24,xTickCount
 1885 090a 9091 0000 		lds r25,xTickCount+1
 1886               	.LVL97:
1899:../../Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 1887               		.loc 1 1899 0
 1888 090e 8C0F      		add r24,r28
 1889 0910 9D1F      		adc r25,r29
 1890               	.LVL98:
 1891 0912 0E94 0000 		call prvAddCurrentTaskToDelayedList
 1892               	.LVL99:
 1893               	.L109:
 1894               	/* epilogue start */
1910:../../Source/tasks.c **** }
 1895               		.loc 1 1910 0
 1896 0916 DF91      		pop r29
 1897 0918 CF91      		pop r28
 1898               	.LVL100:
 1899 091a 0895      		ret
 1900               		.cfi_endproc
 1901               	.LFE17:
 1903               	.global	xTaskRemoveFromEventList
 1905               	xTaskRemoveFromEventList:
 1906               	.LFB18:
1955:../../Source/tasks.c **** {
 1907               		.loc 1 1955 0
 1908               		.cfi_startproc
 1909               	.LVL101:
 1910 091c 0F93      		push r16
 1911               	.LCFI61:
 1912               		.cfi_def_cfa_offset 4
 1913               		.cfi_offset 16, -3
 1914 091e 1F93      		push r17
 1915               	.LCFI62:
 1916               		.cfi_def_cfa_offset 5
 1917               		.cfi_offset 17, -4
 1918 0920 CF93      		push r28
 1919               	.LCFI63:
 1920               		.cfi_def_cfa_offset 6
 1921               		.cfi_offset 28, -5
 1922 0922 DF93      		push r29
 1923               	.LCFI64:
 1924               		.cfi_def_cfa_offset 7
 1925               		.cfi_offset 29, -6
 1926               	/* prologue: function */
 1927               	/* frame size = 0 */
 1928               	/* stack size = 4 */
 1929               	.L__stack_usage = 4
1972:../../Source/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 1930               		.loc 1 1972 0
 1931 0924 DC01      		movw r26,r24
 1932 0926 1596      		adiw r26,5
 1933 0928 ED91      		ld r30,X+
 1934 092a FC91      		ld r31,X
 1935 092c 1697      		sbiw r26,5+1
 1936 092e 0681      		ldd r16,Z+6
 1937 0930 1781      		ldd r17,Z+7
 1938               	.LVL102:
1974:../../Source/tasks.c **** 	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 1939               		.loc 1 1974 0
 1940 0932 E801      		movw r28,r16
 1941 0934 2C96      		adiw r28,12
 1942 0936 CE01      		movw r24,r28
 1943               	.LVL103:
 1944 0938 0E94 0000 		call uxListRemove
 1945               	.LVL104:
1976:../../Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1946               		.loc 1 1976 0
 1947 093c 8091 0000 		lds r24,uxSchedulerSuspended
 1948 0940 8823      		tst r24
 1949 0942 01F4      		brne .L113
1978:../../Source/tasks.c **** 		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 1950               		.loc 1 1978 0
 1951 0944 E801      		movw r28,r16
 1952 0946 2296      		adiw r28,2
 1953 0948 CE01      		movw r24,r28
 1954 094a 0E94 0000 		call uxListRemove
1979:../../Source/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
 1955               		.loc 1 1979 0
 1956 094e F801      		movw r30,r16
 1957 0950 2689      		ldd r18,Z+22
 1958 0952 8091 0000 		lds r24,uxTopReadyPriority
 1959 0956 8217      		cp r24,r18
 1960 0958 00F4      		brsh .L114
1979:../../Source/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
 1961               		.loc 1 1979 0 is_stmt 0 discriminator 1
 1962 095a 2093 0000 		sts uxTopReadyPriority,r18
 1963               	.L114:
1979:../../Source/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
 1964               		.loc 1 1979 0 discriminator 2
 1965 095e 30E0      		ldi r19,lo8(0)
 1966 0960 C901      		movw r24,r18
 1967 0962 73E0      		ldi r23,3
 1968 0964 880F      	1:	lsl r24
 1969 0966 991F      		rol r25
 1970 0968 7A95      		dec r23
 1971 096a 01F4      		brne 1b
 1972 096c 820F      		add r24,r18
 1973 096e 931F      		adc r25,r19
 1974 0970 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1975 0972 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1976 0974 00C0      		rjmp .L117
 1977               	.L113:
1985:../../Source/tasks.c **** 		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 1978               		.loc 1 1985 0 is_stmt 1
 1979 0976 80E0      		ldi r24,lo8(xPendingReadyList)
 1980 0978 90E0      		ldi r25,hi8(xPendingReadyList)
 1981               	.L117:
 1982 097a BE01      		movw r22,r28
 1983 097c 0E94 0000 		call vListInsertEnd
1988:../../Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1984               		.loc 1 1988 0
 1985 0980 E091 0000 		lds r30,pxCurrentTCB
 1986 0984 F091 0000 		lds r31,pxCurrentTCB+1
 1987               	.LVL105:
1994:../../Source/tasks.c **** 		xReturn = pdTRUE;
 1988               		.loc 1 1994 0
 1989 0988 81E0      		ldi r24,lo8(1)
 1990 098a D801      		movw r26,r16
 1991 098c 5696      		adiw r26,22
 1992 098e 2C91      		ld r18,X
 1993 0990 5697      		sbiw r26,22
 1994 0992 9689      		ldd r25,Z+22
 1995 0994 2917      		cp r18,r25
 1996 0996 00F4      		brsh .L116
 1997 0998 80E0      		ldi r24,lo8(0)
 1998               	.L116:
 1999               	/* epilogue start */
2002:../../Source/tasks.c **** }
 2000               		.loc 1 2002 0
 2001 099a DF91      		pop r29
 2002 099c CF91      		pop r28
 2003 099e 1F91      		pop r17
 2004 09a0 0F91      		pop r16
 2005               	.LVL106:
 2006 09a2 0895      		ret
 2007               		.cfi_endproc
 2008               	.LFE18:
 2010               	.global	vTaskSetTimeOutState
 2012               	vTaskSetTimeOutState:
 2013               	.LFB19:
2006:../../Source/tasks.c **** {
 2014               		.loc 1 2006 0
 2015               		.cfi_startproc
 2016               	.LVL107:
 2017               	/* prologue: function */
 2018               	/* frame size = 0 */
 2019               	/* stack size = 0 */
 2020               	.L__stack_usage = 0
 2021 09a4 FC01      		movw r30,r24
2008:../../Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 2022               		.loc 1 2008 0
 2023 09a6 8091 0000 		lds r24,xNumOfOverflows
 2024               	.LVL108:
 2025 09aa 8083      		st Z,r24
2009:../../Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 2026               		.loc 1 2009 0
 2027 09ac 8091 0000 		lds r24,xTickCount
 2028 09b0 9091 0000 		lds r25,xTickCount+1
 2029 09b4 9283      		std Z+2,r25
 2030 09b6 8183      		std Z+1,r24
 2031               	/* epilogue start */
2010:../../Source/tasks.c **** }
 2032               		.loc 1 2010 0
 2033 09b8 0895      		ret
 2034               		.cfi_endproc
 2035               	.LFE19:
 2037               	.global	xTaskCheckForTimeOut
 2039               	xTaskCheckForTimeOut:
 2040               	.LFB20:
2014:../../Source/tasks.c **** {
 2041               		.loc 1 2014 0
 2042               		.cfi_startproc
 2043               	.LVL109:
 2044               	/* prologue: function */
 2045               	/* frame size = 0 */
 2046               	/* stack size = 0 */
 2047               	.L__stack_usage = 0
 2048 09ba FC01      		movw r30,r24
 2049 09bc DB01      		movw r26,r22
2020:../../Source/tasks.c **** 	taskENTER_CRITICAL();
 2050               		.loc 1 2020 0
 2051               	/* #APP */
 2052               	 ;  2020 "../../Source/tasks.c" 1
 2053 09be 0FB6      		in		__tmp_reg__, __SREG__
 2054               	 ;  0 "" 2
 2055               	 ;  2020 "../../Source/tasks.c" 1
 2056 09c0 F894      		cli
 2057               	 ;  0 "" 2
 2058               	 ;  2020 "../../Source/tasks.c" 1
 2059 09c2 0F92      		push	__tmp_reg__
 2060               	 ;  0 "" 2
2026:../../Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
 2061               		.loc 1 2026 0
 2062               	/* #NOAPP */
 2063 09c4 4D91      		ld r20,X+
 2064 09c6 5C91      		ld r21,X
 2065 09c8 1197      		sbiw r26,1
 2066 09ca 8FEF      		ldi r24,hi8(-1)
 2067 09cc 4F3F      		cpi r20,lo8(-1)
 2068 09ce 5807      		cpc r21,r24
 2069               	.LVL110:
 2070 09d0 01F0      		breq .L122
2033:../../Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
 2071               		.loc 1 2033 0
 2072 09d2 9091 0000 		lds r25,xNumOfOverflows
 2073 09d6 8081      		ld r24,Z
 2074 09d8 2181      		ldd r18,Z+1
 2075 09da 3281      		ldd r19,Z+2
 2076 09dc 9817      		cp r25,r24
 2077 09de 01F0      		breq .L121
2033:../../Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
 2078               		.loc 1 2033 0 is_stmt 0 discriminator 1
 2079 09e0 8091 0000 		lds r24,xTickCount
 2080 09e4 9091 0000 		lds r25,xTickCount+1
 2081 09e8 8217      		cp r24,r18
 2082 09ea 9307      		cpc r25,r19
 2083 09ec 00F4      		brsh .L124
 2084               	.L121:
2041:../../Source/tasks.c **** 		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEn
 2085               		.loc 1 2041 0 is_stmt 1
 2086 09ee 8091 0000 		lds r24,xTickCount
 2087 09f2 9091 0000 		lds r25,xTickCount+1
 2088 09f6 821B      		sub r24,r18
 2089 09f8 930B      		sbc r25,r19
 2090 09fa 8417      		cp r24,r20
 2091 09fc 9507      		cpc r25,r21
 2092 09fe 00F4      		brsh .L124
2044:../../Source/tasks.c **** 			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
 2093               		.loc 1 2044 0
 2094 0a00 8091 0000 		lds r24,xTickCount
 2095 0a04 9091 0000 		lds r25,xTickCount+1
 2096 0a08 281B      		sub r18,r24
 2097 0a0a 390B      		sbc r19,r25
 2098 0a0c 240F      		add r18,r20
 2099 0a0e 351F      		adc r19,r21
 2100 0a10 2D93      		st X+,r18
 2101 0a12 3C93      		st X,r19
2045:../../Source/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 2102               		.loc 1 2045 0
 2103 0a14 CF01      		movw r24,r30
 2104 0a16 0E94 0000 		call vTaskSetTimeOutState
 2105               	.LVL111:
 2106               	.L122:
2028:../../Source/tasks.c **** 				xReturn = pdFALSE;
 2107               		.loc 1 2028 0
 2108 0a1a 80E0      		ldi r24,lo8(0)
 2109 0a1c 00C0      		rjmp .L120
 2110               	.LVL112:
 2111               	.L124:
2050:../../Source/tasks.c **** 			xReturn = pdTRUE;
 2112               		.loc 1 2050 0
 2113 0a1e 81E0      		ldi r24,lo8(1)
 2114               	.LVL113:
 2115               	.L120:
2053:../../Source/tasks.c **** 	taskEXIT_CRITICAL();
 2116               		.loc 1 2053 0
 2117               	/* #APP */
 2118               	 ;  2053 "../../Source/tasks.c" 1
 2119 0a20 0F90      		pop		__tmp_reg__
 2120               	 ;  0 "" 2
 2121               	 ;  2053 "../../Source/tasks.c" 1
 2122 0a22 0FBE      		out		__SREG__, __tmp_reg__
 2123               	 ;  0 "" 2
 2124               	/* epilogue start */
2056:../../Source/tasks.c **** }
 2125               		.loc 1 2056 0
 2126               	/* #NOAPP */
 2127 0a24 0895      		ret
 2128               		.cfi_endproc
 2129               	.LFE20:
 2131               	.global	vTaskMissedYield
 2133               	vTaskMissedYield:
 2134               	.LFB21:
2060:../../Source/tasks.c **** {
 2135               		.loc 1 2060 0
 2136               		.cfi_startproc
 2137               	/* prologue: function */
 2138               	/* frame size = 0 */
 2139               	/* stack size = 0 */
 2140               	.L__stack_usage = 0
2061:../../Source/tasks.c **** 	xMissedYield = pdTRUE;
 2141               		.loc 1 2061 0
 2142 0a26 81E0      		ldi r24,lo8(1)
 2143 0a28 8093 0000 		sts xMissedYield,r24
 2144               	/* epilogue start */
2062:../../Source/tasks.c **** }
 2145               		.loc 1 2062 0
 2146 0a2c 0895      		ret
 2147               		.cfi_endproc
 2148               	.LFE21:
 2150               	.global	uxTaskGetStackHighWaterMark
 2152               	uxTaskGetStackHighWaterMark:
 2153               	.LFB29:
2421:../../Source/tasks.c **** 		}
2422:../../Source/tasks.c **** 	}
2423:../../Source/tasks.c **** 
2424:../../Source/tasks.c **** 	return pxNewTCB;
2425:../../Source/tasks.c **** }
2426:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2427:../../Source/tasks.c **** 
2428:../../Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2429:../../Source/tasks.c **** 
2430:../../Source/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
2431:../../Source/tasks.c **** 	{
2432:../../Source/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2433:../../Source/tasks.c **** 	unsigned short usStackRemaining;
2434:../../Source/tasks.c **** 	PRIVILEGED_DATA static char pcStatusString[ configMAX_TASK_NAME_LEN + 30 ];
2435:../../Source/tasks.c **** 
2436:../../Source/tasks.c **** 		/* Write the details of all the TCB's in pxList into the buffer. */
2437:../../Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2438:../../Source/tasks.c **** 		do
2439:../../Source/tasks.c **** 		{
2440:../../Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2441:../../Source/tasks.c **** 			#if ( portSTACK_GROWTH > 0 )
2442:../../Source/tasks.c **** 			{
2443:../../Source/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
2444:../../Source/tasks.c **** 			}
2445:../../Source/tasks.c **** 			#else
2446:../../Source/tasks.c **** 			{
2447:../../Source/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
2448:../../Source/tasks.c **** 			}
2449:../../Source/tasks.c **** 			#endif
2450:../../Source/tasks.c **** 
2451:../../Source/tasks.c **** 			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, 
2452:../../Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
2453:../../Source/tasks.c **** 
2454:../../Source/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
2455:../../Source/tasks.c **** 	}
2456:../../Source/tasks.c **** 
2457:../../Source/tasks.c **** #endif
2458:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2459:../../Source/tasks.c **** 
2460:../../Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
2461:../../Source/tasks.c **** 
2462:../../Source/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
2463:../../Source/tasks.c **** 	{
2464:../../Source/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2465:../../Source/tasks.c **** 	unsigned long ulStatsAsPercentage;
2466:../../Source/tasks.c **** 
2467:../../Source/tasks.c **** 		/* Write the run time stats of all the TCB's in pxList into the buffer. */
2468:../../Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2469:../../Source/tasks.c **** 		do
2470:../../Source/tasks.c **** 		{
2471:../../Source/tasks.c **** 			/* Get next TCB in from the list. */
2472:../../Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2473:../../Source/tasks.c **** 
2474:../../Source/tasks.c **** 			/* Divide by zero check. */
2475:../../Source/tasks.c **** 			if( ulTotalRunTime > 0UL )
2476:../../Source/tasks.c **** 			{
2477:../../Source/tasks.c **** 				/* Has the task run at all? */
2478:../../Source/tasks.c **** 				if( pxNextTCB->ulRunTimeCounter == 0UL )
2479:../../Source/tasks.c **** 				{
2480:../../Source/tasks.c **** 					/* The task has used no CPU time at all. */
2481:../../Source/tasks.c **** 					sprintf( pcStatsString, ( char * ) "%s\t\t0\t\t0%%\r\n", pxNextTCB->pcTaskName );
2482:../../Source/tasks.c **** 				}
2483:../../Source/tasks.c **** 				else
2484:../../Source/tasks.c **** 				{
2485:../../Source/tasks.c **** 					/* What percentage of the total run time has the task used?
2486:../../Source/tasks.c **** 					This will always be rounded down to the nearest integer.
2487:../../Source/tasks.c **** 					ulTotalRunTime has already been divided by 100. */
2488:../../Source/tasks.c **** 					ulStatsAsPercentage = pxNextTCB->ulRunTimeCounter / ulTotalRunTime;
2489:../../Source/tasks.c **** 
2490:../../Source/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
2491:../../Source/tasks.c **** 					{
2492:../../Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2493:../../Source/tasks.c **** 						{
2494:../../Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t%lu%%\r\n", pxNextTCB->pcTaskName, pxNextTC
2495:../../Source/tasks.c **** 						}
2496:../../Source/tasks.c **** 						#else
2497:../../Source/tasks.c **** 						{
2498:../../Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
2499:../../Source/tasks.c **** 							printf() library can be used. */
2500:../../Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t%u%%\r\n", pxNextTCB->pcTaskName, ( unsigned
2501:../../Source/tasks.c **** 						}
2502:../../Source/tasks.c **** 						#endif
2503:../../Source/tasks.c **** 					}
2504:../../Source/tasks.c **** 					else
2505:../../Source/tasks.c **** 					{
2506:../../Source/tasks.c **** 						/* If the percentage is zero here then the task has
2507:../../Source/tasks.c **** 						consumed less than 1% of the total run time. */
2508:../../Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2509:../../Source/tasks.c **** 						{
2510:../../Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t<1%%\r\n", pxNextTCB->pcTaskName, pxNextTCB
2511:../../Source/tasks.c **** 						}
2512:../../Source/tasks.c **** 						#else
2513:../../Source/tasks.c **** 						{
2514:../../Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
2515:../../Source/tasks.c **** 							printf() library can be used. */
2516:../../Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t<1%%\r\n", pxNextTCB->pcTaskName, ( unsigned
2517:../../Source/tasks.c **** 						}
2518:../../Source/tasks.c **** 						#endif
2519:../../Source/tasks.c **** 					}
2520:../../Source/tasks.c **** 				}
2521:../../Source/tasks.c **** 
2522:../../Source/tasks.c **** 				strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatsString );
2523:../../Source/tasks.c **** 			}
2524:../../Source/tasks.c **** 
2525:../../Source/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
2526:../../Source/tasks.c **** 	}
2527:../../Source/tasks.c **** 
2528:../../Source/tasks.c **** #endif
2529:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2530:../../Source/tasks.c **** 
2531:../../Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
2532:../../Source/tasks.c **** 
2533:../../Source/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
2534:../../Source/tasks.c **** 	{
2535:../../Source/tasks.c **** 	register unsigned short usCount = 0U;
2536:../../Source/tasks.c **** 
2537:../../Source/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
2538:../../Source/tasks.c **** 		{
2539:../../Source/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
2540:../../Source/tasks.c **** 			usCount++;
2541:../../Source/tasks.c **** 		}
2542:../../Source/tasks.c **** 
2543:../../Source/tasks.c **** 		usCount /= sizeof( portSTACK_TYPE );
2544:../../Source/tasks.c **** 
2545:../../Source/tasks.c **** 		return usCount;
2546:../../Source/tasks.c **** 	}
2547:../../Source/tasks.c **** 
2548:../../Source/tasks.c **** #endif
2549:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2550:../../Source/tasks.c **** 
2551:../../Source/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
2552:../../Source/tasks.c **** 
2553:../../Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
2554:../../Source/tasks.c **** 	{
 2154               		.loc 1 2554 0
 2155               		.cfi_startproc
 2156               	.LVL114:
 2157               	/* prologue: function */
 2158               	/* frame size = 0 */
 2159               	/* stack size = 0 */
 2160               	.L__stack_usage = 0
2555:../../Source/tasks.c **** 	tskTCB *pxTCB;
2556:../../Source/tasks.c **** 	unsigned char *pcEndOfStack;
2557:../../Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
2558:../../Source/tasks.c **** 
2559:../../Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
 2161               		.loc 1 2559 0
 2162 0a2e 0097      		sbiw r24,0
 2163 0a30 01F4      		brne .L130
 2164               		.loc 1 2559 0 is_stmt 0 discriminator 1
 2165 0a32 E091 0000 		lds r30,pxCurrentTCB
 2166 0a36 F091 0000 		lds r31,pxCurrentTCB+1
 2167 0a3a 00C0      		rjmp .L127
 2168               	.L130:
 2169               		.loc 1 2559 0
 2170 0a3c FC01      		movw r30,r24
 2171               	.L127:
 2172               	.LVL115:
 2173               		.loc 1 2559 0 discriminator 3
 2174 0a3e 0788      		ldd __tmp_reg__,Z+23
 2175 0a40 F08D      		ldd r31,Z+24
 2176 0a42 E02D      		mov r30,__tmp_reg__
 2177               	.LVL116:
2535:../../Source/tasks.c **** 	register unsigned short usCount = 0U;
 2178               		.loc 1 2535 0 is_stmt 1 discriminator 3
 2179 0a44 80E0      		ldi r24,lo8(0)
 2180 0a46 90E0      		ldi r25,hi8(0)
 2181               	.LVL117:
 2182 0a48 00C0      		rjmp .L128
 2183               	.LVL118:
 2184               	.L129:
 2185               	.LBB35:
 2186               	.LBB36:
2540:../../Source/tasks.c **** 			usCount++;
 2187               		.loc 1 2540 0
 2188 0a4a 0196      		adiw r24,1
 2189               	.LVL119:
 2190               	.L128:
2537:../../Source/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
 2191               		.loc 1 2537 0
 2192 0a4c 2191      		ld r18,Z+
 2193 0a4e 253A      		cpi r18,lo8(-91)
 2194 0a50 01F0      		breq .L129
 2195               	/* epilogue start */
 2196               	.LBE36:
 2197               	.LBE35:
2560:../../Source/tasks.c **** 
2561:../../Source/tasks.c **** 		#if portSTACK_GROWTH < 0
2562:../../Source/tasks.c **** 		{
2563:../../Source/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
2564:../../Source/tasks.c **** 		}
2565:../../Source/tasks.c **** 		#else
2566:../../Source/tasks.c **** 		{
2567:../../Source/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
2568:../../Source/tasks.c **** 		}
2569:../../Source/tasks.c **** 		#endif
2570:../../Source/tasks.c **** 
2571:../../Source/tasks.c **** 		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
2572:../../Source/tasks.c **** 
2573:../../Source/tasks.c **** 		return uxReturn;
2574:../../Source/tasks.c **** 	}
 2198               		.loc 1 2574 0
 2199 0a52 0895      		ret
 2200               		.cfi_endproc
 2201               	.LFE29:
 2203               	.global	xTaskGetCurrentTaskHandle
 2205               	xTaskGetCurrentTaskHandle:
 2206               	.LFB30:
2575:../../Source/tasks.c **** 
2576:../../Source/tasks.c **** #endif
2577:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2578:../../Source/tasks.c **** 
2579:../../Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
2580:../../Source/tasks.c **** 
2581:../../Source/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB )
2582:../../Source/tasks.c **** 	{
2583:../../Source/tasks.c **** 		/* This call is required specifically for the TriCore port.  It must be
2584:../../Source/tasks.c **** 		above the vPortFree() calls.  The call is also used by ports/demos that
2585:../../Source/tasks.c **** 		want to allocate and clean RAM statically. */
2586:../../Source/tasks.c **** 		portCLEAN_UP_TCB( pxTCB );
2587:../../Source/tasks.c **** 
2588:../../Source/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up to
2589:../../Source/tasks.c **** 		the task to free any memory allocated at the application level. */
2590:../../Source/tasks.c **** 		vPortFreeAligned( pxTCB->pxStack );
2591:../../Source/tasks.c **** 		vPortFree( pxTCB );
2592:../../Source/tasks.c **** 	}
2593:../../Source/tasks.c **** 
2594:../../Source/tasks.c **** #endif
2595:../../Source/tasks.c **** 
2596:../../Source/tasks.c **** 
2597:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2598:../../Source/tasks.c **** 
2599:../../Source/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
2600:../../Source/tasks.c **** 
2601:../../Source/tasks.c **** 	xTaskHandle xTaskGetCurrentTaskHandle( void )
2602:../../Source/tasks.c **** 	{
 2207               		.loc 1 2602 0
 2208               		.cfi_startproc
 2209               	/* prologue: function */
 2210               	/* frame size = 0 */
 2211               	/* stack size = 0 */
 2212               	.L__stack_usage = 0
2603:../../Source/tasks.c **** 	xTaskHandle xReturn;
2604:../../Source/tasks.c **** 
2605:../../Source/tasks.c **** 		/* A critical section is not required as this is not called from
2606:../../Source/tasks.c **** 		an interrupt and the current TCB will always be the same for any
2607:../../Source/tasks.c **** 		individual execution thread. */
2608:../../Source/tasks.c **** 		xReturn = pxCurrentTCB;
 2213               		.loc 1 2608 0
 2214 0a54 8091 0000 		lds r24,pxCurrentTCB
 2215 0a58 9091 0000 		lds r25,pxCurrentTCB+1
 2216               	.LVL120:
 2217               	/* epilogue start */
2609:../../Source/tasks.c **** 
2610:../../Source/tasks.c **** 		return xReturn;
2611:../../Source/tasks.c **** 	}
 2218               		.loc 1 2611 0
 2219 0a5c 0895      		ret
 2220               		.cfi_endproc
 2221               	.LFE30:
 2223               	.global	vTaskPriorityInherit
 2225               	vTaskPriorityInherit:
 2226               	.LFB31:
2612:../../Source/tasks.c **** 
2613:../../Source/tasks.c **** #endif
2614:../../Source/tasks.c **** 
2615:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2616:../../Source/tasks.c **** 
2617:../../Source/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
2618:../../Source/tasks.c **** 
2619:../../Source/tasks.c **** 	portBASE_TYPE xTaskGetSchedulerState( void )
2620:../../Source/tasks.c **** 	{
2621:../../Source/tasks.c **** 	portBASE_TYPE xReturn;
2622:../../Source/tasks.c **** 
2623:../../Source/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
2624:../../Source/tasks.c **** 		{
2625:../../Source/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
2626:../../Source/tasks.c **** 		}
2627:../../Source/tasks.c **** 		else
2628:../../Source/tasks.c **** 		{
2629:../../Source/tasks.c **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
2630:../../Source/tasks.c **** 			{
2631:../../Source/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
2632:../../Source/tasks.c **** 			}
2633:../../Source/tasks.c **** 			else
2634:../../Source/tasks.c **** 			{
2635:../../Source/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
2636:../../Source/tasks.c **** 			}
2637:../../Source/tasks.c **** 		}
2638:../../Source/tasks.c **** 
2639:../../Source/tasks.c **** 		return xReturn;
2640:../../Source/tasks.c **** 	}
2641:../../Source/tasks.c **** 
2642:../../Source/tasks.c **** #endif
2643:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2644:../../Source/tasks.c **** 
2645:../../Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
2646:../../Source/tasks.c **** 
2647:../../Source/tasks.c **** 	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
2648:../../Source/tasks.c **** 	{
 2227               		.loc 1 2648 0
 2228               		.cfi_startproc
 2229               	.LVL121:
 2230 0a5e 0F93      		push r16
 2231               	.LCFI65:
 2232               		.cfi_def_cfa_offset 4
 2233               		.cfi_offset 16, -3
 2234 0a60 1F93      		push r17
 2235               	.LCFI66:
 2236               		.cfi_def_cfa_offset 5
 2237               		.cfi_offset 17, -4
 2238 0a62 CF93      		push r28
 2239               	.LCFI67:
 2240               		.cfi_def_cfa_offset 6
 2241               		.cfi_offset 28, -5
 2242 0a64 DF93      		push r29
 2243               	.LCFI68:
 2244               		.cfi_def_cfa_offset 7
 2245               		.cfi_offset 29, -6
 2246               	/* prologue: function */
 2247               	/* frame size = 0 */
 2248               	/* stack size = 4 */
 2249               	.L__stack_usage = 4
 2250 0a66 EC01      		movw r28,r24
 2251               	.LVL122:
2649:../../Source/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
2650:../../Source/tasks.c **** 
2651:../../Source/tasks.c **** 		/* If the mutex was given back by an interrupt while the queue was
2652:../../Source/tasks.c **** 		locked then the mutex holder might now be NULL. */
2653:../../Source/tasks.c **** 		if( pxMutexHolder != NULL )
 2252               		.loc 1 2653 0
 2253 0a68 0097      		sbiw r24,0
 2254 0a6a 01F4      		brne .+2
 2255 0a6c 00C0      		rjmp .L132
2654:../../Source/tasks.c **** 		{
2655:../../Source/tasks.c **** 			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 2256               		.loc 1 2655 0
 2257 0a6e 2E89      		ldd r18,Y+22
 2258 0a70 E091 0000 		lds r30,pxCurrentTCB
 2259 0a74 F091 0000 		lds r31,pxCurrentTCB+1
 2260 0a78 8689      		ldd r24,Z+22
 2261               	.LVL123:
 2262 0a7a 2817      		cp r18,r24
 2263 0a7c 00F0      		brlo .+2
 2264 0a7e 00C0      		rjmp .L132
2656:../../Source/tasks.c **** 			{
2657:../../Source/tasks.c **** 				/* Adjust the mutex holder state to account for its new priority. */
2658:../../Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) px
 2265               		.loc 1 2658 0
 2266 0a80 E091 0000 		lds r30,pxCurrentTCB
 2267 0a84 F091 0000 		lds r31,pxCurrentTCB+1
 2268 0a88 3689      		ldd r19,Z+22
 2269 0a8a 84E0      		ldi r24,lo8(4)
 2270 0a8c 90E0      		ldi r25,hi8(4)
 2271 0a8e 831B      		sub r24,r19
 2272 0a90 9109      		sbc r25,__zero_reg__
 2273 0a92 9D87      		std Y+13,r25
 2274 0a94 8C87      		std Y+12,r24
2659:../../Source/tasks.c **** 
2660:../../Source/tasks.c **** 				/* If the task being modified is in the ready state it will need to
2661:../../Source/tasks.c **** 				be moved into a new list. */
2662:../../Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericLis
 2275               		.loc 1 2662 0
 2276 0a96 30E0      		ldi r19,lo8(0)
 2277 0a98 C901      		movw r24,r18
 2278 0a9a A3E0      		ldi r26,3
 2279 0a9c 880F      	1:	lsl r24
 2280 0a9e 991F      		rol r25
 2281 0aa0 AA95      		dec r26
 2282 0aa2 01F4      		brne 1b
 2283 0aa4 820F      		add r24,r18
 2284 0aa6 931F      		adc r25,r19
 2285 0aa8 8050      		subi r24,lo8(-(pxReadyTasksLists))
 2286 0aaa 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 2287 0aac 2A85      		ldd r18,Y+10
 2288 0aae 3B85      		ldd r19,Y+11
 2289 0ab0 2817      		cp r18,r24
 2290 0ab2 3907      		cpc r19,r25
 2291 0ab4 01F4      		brne .L134
2663:../../Source/tasks.c **** 				{
2664:../../Source/tasks.c **** 					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
 2292               		.loc 1 2664 0
 2293 0ab6 8E01      		movw r16,r28
 2294 0ab8 0E5F      		subi r16,lo8(-(2))
 2295 0aba 1F4F      		sbci r17,hi8(-(2))
 2296 0abc C801      		movw r24,r16
 2297 0abe 0E94 0000 		call uxListRemove
2665:../../Source/tasks.c **** 					{
2666:../../Source/tasks.c **** 						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
2667:../../Source/tasks.c **** 					}
2668:../../Source/tasks.c **** 
2669:../../Source/tasks.c **** 					/* Inherit the priority before being moved into the new list. */
2670:../../Source/tasks.c **** 					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 2298               		.loc 1 2670 0
 2299 0ac2 E091 0000 		lds r30,pxCurrentTCB
 2300 0ac6 F091 0000 		lds r31,pxCurrentTCB+1
 2301 0aca 2689      		ldd r18,Z+22
 2302 0acc 2E8B      		std Y+22,r18
2671:../../Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 2303               		.loc 1 2671 0
 2304 0ace 8091 0000 		lds r24,uxTopReadyPriority
 2305 0ad2 8217      		cp r24,r18
 2306 0ad4 00F4      		brsh .L135
 2307               		.loc 1 2671 0 is_stmt 0 discriminator 1
 2308 0ad6 2093 0000 		sts uxTopReadyPriority,r18
 2309               	.L135:
 2310               		.loc 1 2671 0 discriminator 2
 2311 0ada 30E0      		ldi r19,lo8(0)
 2312 0adc C901      		movw r24,r18
 2313 0ade E3E0      		ldi r30,3
 2314 0ae0 880F      	1:	lsl r24
 2315 0ae2 991F      		rol r25
 2316 0ae4 EA95      		dec r30
 2317 0ae6 01F4      		brne 1b
 2318 0ae8 820F      		add r24,r18
 2319 0aea 931F      		adc r25,r19
 2320 0aec 8050      		subi r24,lo8(-(pxReadyTasksLists))
 2321 0aee 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 2322 0af0 B801      		movw r22,r16
 2323 0af2 0E94 0000 		call vListInsertEnd
 2324 0af6 00C0      		rjmp .L132
 2325               	.L134:
2672:../../Source/tasks.c **** 				}
2673:../../Source/tasks.c **** 				else
2674:../../Source/tasks.c **** 				{
2675:../../Source/tasks.c **** 					/* Just inherit the priority. */
2676:../../Source/tasks.c **** 					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 2326               		.loc 1 2676 0 is_stmt 1
 2327 0af8 E091 0000 		lds r30,pxCurrentTCB
 2328 0afc F091 0000 		lds r31,pxCurrentTCB+1
 2329 0b00 8689      		ldd r24,Z+22
 2330 0b02 8E8B      		std Y+22,r24
 2331               	.L132:
 2332               	/* epilogue start */
2677:../../Source/tasks.c **** 				}
2678:../../Source/tasks.c **** 
2679:../../Source/tasks.c **** 				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
2680:../../Source/tasks.c **** 			}
2681:../../Source/tasks.c **** 		}
2682:../../Source/tasks.c **** 	}
 2333               		.loc 1 2682 0
 2334 0b04 DF91      		pop r29
 2335 0b06 CF91      		pop r28
 2336               	.LVL124:
 2337 0b08 1F91      		pop r17
 2338 0b0a 0F91      		pop r16
 2339 0b0c 0895      		ret
 2340               		.cfi_endproc
 2341               	.LFE31:
 2343               	.global	vTaskPriorityDisinherit
 2345               	vTaskPriorityDisinherit:
 2346               	.LFB32:
2683:../../Source/tasks.c **** 
2684:../../Source/tasks.c **** #endif
2685:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2686:../../Source/tasks.c **** 
2687:../../Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
2688:../../Source/tasks.c **** 
2689:../../Source/tasks.c **** 	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
2690:../../Source/tasks.c **** 	{
 2347               		.loc 1 2690 0
 2348               		.cfi_startproc
 2349               	.LVL125:
 2350 0b0e 0F93      		push r16
 2351               	.LCFI69:
 2352               		.cfi_def_cfa_offset 4
 2353               		.cfi_offset 16, -3
 2354 0b10 1F93      		push r17
 2355               	.LCFI70:
 2356               		.cfi_def_cfa_offset 5
 2357               		.cfi_offset 17, -4
 2358 0b12 CF93      		push r28
 2359               	.LCFI71:
 2360               		.cfi_def_cfa_offset 6
 2361               		.cfi_offset 28, -5
 2362 0b14 DF93      		push r29
 2363               	.LCFI72:
 2364               		.cfi_def_cfa_offset 7
 2365               		.cfi_offset 29, -6
 2366               	/* prologue: function */
 2367               	/* frame size = 0 */
 2368               	/* stack size = 4 */
 2369               	.L__stack_usage = 4
 2370 0b16 EC01      		movw r28,r24
 2371               	.LVL126:
2691:../../Source/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
2692:../../Source/tasks.c **** 
2693:../../Source/tasks.c **** 		if( pxMutexHolder != NULL )
 2372               		.loc 1 2693 0
 2373 0b18 0097      		sbiw r24,0
 2374 0b1a 01F0      		breq .L136
2694:../../Source/tasks.c **** 		{
2695:../../Source/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 2375               		.loc 1 2695 0
 2376 0b1c 9E89      		ldd r25,Y+22
 2377 0b1e 89A5      		ldd r24,Y+41
 2378               	.LVL127:
 2379 0b20 9817      		cp r25,r24
 2380 0b22 01F0      		breq .L136
2696:../../Source/tasks.c **** 			{
2697:../../Source/tasks.c **** 				/* We must be the running task to be able to give the mutex back.
2698:../../Source/tasks.c **** 				Remove ourselves from the ready list we currently appear in. */
2699:../../Source/tasks.c **** 				if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
 2381               		.loc 1 2699 0
 2382 0b24 8E01      		movw r16,r28
 2383 0b26 0E5F      		subi r16,lo8(-(2))
 2384 0b28 1F4F      		sbci r17,hi8(-(2))
 2385 0b2a C801      		movw r24,r16
 2386 0b2c 0E94 0000 		call uxListRemove
2700:../../Source/tasks.c **** 				{
2701:../../Source/tasks.c **** 					taskRESET_READY_PRIORITY( pxTCB->uxPriority );
2702:../../Source/tasks.c **** 				}
2703:../../Source/tasks.c **** 
2704:../../Source/tasks.c **** 				/* Disinherit the priority before adding the task into the new
2705:../../Source/tasks.c **** 				ready list. */
2706:../../Source/tasks.c **** 				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
2707:../../Source/tasks.c **** 				pxTCB->uxPriority = pxTCB->uxBasePriority;
 2387               		.loc 1 2707 0
 2388 0b30 49A5      		ldd r20,Y+41
 2389 0b32 4E8B      		std Y+22,r20
2708:../../Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) px
 2390               		.loc 1 2708 0
 2391 0b34 242F      		mov r18,r20
 2392 0b36 30E0      		ldi r19,lo8(0)
 2393 0b38 84E0      		ldi r24,lo8(4)
 2394 0b3a 90E0      		ldi r25,hi8(4)
 2395 0b3c 821B      		sub r24,r18
 2396 0b3e 930B      		sbc r25,r19
 2397 0b40 9D87      		std Y+13,r25
 2398 0b42 8C87      		std Y+12,r24
2709:../../Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 2399               		.loc 1 2709 0
 2400 0b44 8091 0000 		lds r24,uxTopReadyPriority
 2401 0b48 8417      		cp r24,r20
 2402 0b4a 00F4      		brsh .L138
 2403               		.loc 1 2709 0 is_stmt 0 discriminator 1
 2404 0b4c 4093 0000 		sts uxTopReadyPriority,r20
 2405               	.L138:
 2406               		.loc 1 2709 0 discriminator 2
 2407 0b50 C901      		movw r24,r18
 2408 0b52 B3E0      		ldi r27,3
 2409 0b54 880F      	1:	lsl r24
 2410 0b56 991F      		rol r25
 2411 0b58 BA95      		dec r27
 2412 0b5a 01F4      		brne 1b
 2413 0b5c 820F      		add r24,r18
 2414 0b5e 931F      		adc r25,r19
 2415 0b60 8050      		subi r24,lo8(-(pxReadyTasksLists))
 2416 0b62 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 2417 0b64 B801      		movw r22,r16
 2418 0b66 0E94 0000 		call vListInsertEnd
 2419               	.L136:
 2420               	/* epilogue start */
2710:../../Source/tasks.c **** 			}
2711:../../Source/tasks.c **** 		}
2712:../../Source/tasks.c **** 	}
 2421               		.loc 1 2712 0 is_stmt 1
 2422 0b6a DF91      		pop r29
 2423 0b6c CF91      		pop r28
 2424               	.LVL128:
 2425 0b6e 1F91      		pop r17
 2426 0b70 0F91      		pop r16
 2427 0b72 0895      		ret
 2428               		.cfi_endproc
 2429               	.LFE32:
 2431               		.data
 2434               	xNextTaskUnblockTime:
 2435 0005 FFFF      		.word	-1
 2436               		.lcomm xNumOfOverflows,1
 2437               		.lcomm xMissedYield,1
 2438               		.lcomm uxMissedTicks,1
 2439               		.lcomm uxSchedulerSuspended,1
 2440               		.lcomm xSchedulerRunning,1
 2441               		.lcomm uxTopReadyPriority,1
 2442               		.lcomm xTickCount,2
 2443               		.lcomm uxCurrentNumberOfTasks,1
 2444               		.lcomm pxOverflowDelayedTaskList,2
 2445               		.lcomm pxDelayedTaskList,2
 2446               	.global	pxCurrentTCB
 2447               	.global	pxCurrentTCB
 2448               		.section .bss
 2451               	pxCurrentTCB:
 2452 0000 0000      		.skip 2,0
 2453               		.lcomm pxReadyTasksLists,36
 2454               		.lcomm xDelayedTaskList1,9
 2455               		.lcomm xDelayedTaskList2,9
 2456               		.lcomm xPendingReadyList,9
 2457               		.lcomm xSuspendedTaskList,9
 2458               		.lcomm uxTopUsedPriority,1
 2459               		.lcomm uxTaskNumber,1
 2460               		.text
 2461               	.Letext0:
 2462               		.file 2 "/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/stdint.h"
 2463               		.file 3 "/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/include/stddef.h"
 2464               		.file 4 "../../Source/include/projdefs.h"
 2465               		.file 5 "../../Source/include/../portable/portmacro.h"
 2466               		.file 6 "../../Source/include/list.h"
 2467               		.file 7 "../../Source/include/task.h"
DEFINED SYMBOLS
                            *ABS*:00000000 tasks.c
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:2      *ABS*:0000003f __SREG__
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:3      *ABS*:0000003e __SP_H__
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:4      *ABS*:0000003d __SP_L__
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:5      *ABS*:00000034 __CCP__
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:6      *ABS*:00000000 __tmp_reg__
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:7      *ABS*:00000001 __zero_reg__
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:14     .text:00000000 prvIdleTask
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:2445   .bss:0000000f pxReadyTasksLists
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:35     .text:0000000e prvAddCurrentTaskToDelayedList
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:2451   .bss:00000000 pxCurrentTCB
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:2441   .bss:00000008 xTickCount
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:2443   .bss:0000000b pxOverflowDelayedTaskList
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:2444   .bss:0000000d pxDelayedTaskList
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:2434   .data:00000005 xNextTaskUnblockTime
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:108    .text:0000007c xTaskGenericCreate
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:2442   .bss:0000000a uxCurrentNumberOfTasks
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:2453   .bss:00000033 xDelayedTaskList1
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:2454   .bss:0000003c xDelayedTaskList2
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:2455   .bss:00000045 xPendingReadyList
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:2456   .bss:0000004e xSuspendedTaskList
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:2439   .bss:00000006 xSchedulerRunning
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:2457   .bss:00000057 uxTopUsedPriority
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:2458   .bss:00000058 uxTaskNumber
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:2440   .bss:00000007 uxTopReadyPriority
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:509    .text:0000028c xTaskIsTaskSuspended
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:561    .text:000002b6 vTaskResume
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:675    .text:0000033a xTaskResumeFromISR
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:2438   .bss:00000005 uxSchedulerSuspended
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:791    .text:000003c4 vTaskStartScheduler
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:877    .text:0000041a vTaskEndScheduler
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:903    .text:00000426 vTaskSuspendAll
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:923    .text:00000432 xTaskGetTickCount
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:964    .text:00000446 xTaskGetTickCountFromISR
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:985    .text:00000450 uxTaskGetNumberOfTasks
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:1003   .text:00000456 vTaskIncrementTick
                             .bss:00000002 xNumOfOverflows
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:2437   .bss:00000004 uxMissedTicks
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:1199   .text:0000059a xTaskResumeAll
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:2436   .bss:00000003 xMissedYield
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:1402   .text:00000698 vTaskDelay
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:1473   .text:000006e0 vTaskDelayUntil
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:1586   .text:00000760 vTaskSwitchContext
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:1698   .text:00000826 vTaskSuspend
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:1837   .text:000008c4 vTaskPlaceOnEventList
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:1905   .text:0000091c xTaskRemoveFromEventList
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:2012   .text:000009a4 vTaskSetTimeOutState
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:2039   .text:000009ba xTaskCheckForTimeOut
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:2133   .text:00000a26 vTaskMissedYield
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:2152   .text:00000a2e uxTaskGetStackHighWaterMark
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:2205   .text:00000a54 xTaskGetCurrentTaskHandle
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:2225   .text:00000a5e vTaskPriorityInherit
/var/folders/5l/1cp6g7k97gv8yqpsz51wtznw0000gn/T//ccOrnYu1.s:2345   .text:00000b0e vTaskPriorityDisinherit

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
vPortYield
vListInsert
pvPortMalloc
vPortFree
memset
strncpy
vListInitialiseItem
pxPortInitialiseStack
vListInitialise
vListInsertEnd
uxListRemove
xPortStartScheduler
vPortEndScheduler
vApplicationStackOverflowHook
